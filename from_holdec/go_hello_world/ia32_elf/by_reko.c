// subject_text_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text_0000.h"

// 08049000: void sync/atomic.(*Value).Load(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      sync.(*Map).Load
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Map).dirtyLocked
void sync/atomic.(*Value).Load(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	if (dwLoc08 == 0x00 || dwLoc08 == ~0x00)
		return;
	sync/atomic.LoadPointer();
}

// 08049090: void sync/atomic.(*Value).Store(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Map).missLocked
void sync/atomic.(*Value).Store(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else
	{
		do
		{
			sync/atomic.LoadPointer();
			if (dwLoc0C == 0x00)
			{
				sync/atomic.runtime_procPin(gs);
				sync/atomic.CompareAndSwapPointer(dwArg04, 0x00, ~0x00);
				dwLoc0C.u0 = 0x00;
				if ((byte) (word32) bLoc04 != 0x00)
				{
					sync/atomic.StorePointer((word32) dwArg04 + 4, dwArg0C);
					sync/atomic.StorePointer(dwArg04, dwArg08);
					sync/atomic.runtime_procUnpin(gs);
					return;
				}
				else
				{
					sync/atomic.runtime_procUnpin(gs);
					continue;
				}
			}
		} while (dwLoc0C == ~0x00);
		if (dwLoc0C != dwArg08)
			runtime.gopanic(gs);
		else
			sync/atomic.StorePointer((word32) dwArg04 + 4, dwArg0C);
	}
}

// 080491A0: Register word32 sync/atomic.CompareAndSwapInt32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebpOut)
// Called from:
//      sync.(*Mutex).Lock
//      sync.(*Mutex).Unlock
word32 sync/atomic.CompareAndSwapInt32(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebpOut)
{
	ptr32 ebp_6;
	word32 ecx_7 = sync/atomic.CompareAndSwapUint32(dwArg04, dwArg08, dwArg0C, out ebp_6);
	ebpOut = ebp_6;
	return ecx_7;
}

// 080491B0: Register Eq_4 sync/atomic.CompareAndSwapUint32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_4 ebpOut)
// Called from:
//      sync/atomic.CompareAndSwapInt32
//      sync/atomic.CompareAndSwapUintptr
Eq_4 sync/atomic.CompareAndSwapUint32(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_4 & ebpOut)
{
	__lock();
	word32 eax_8;
	__cmpxchg(*dwArg04, dwArg0C, dwArg08, out eax_8);
	ebpOut = dwArg04;
	return dwArg0C;
}

// 080491D0: void sync/atomic.CompareAndSwapUintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync/atomic.CompareAndSwapPointer
void sync/atomic.CompareAndSwapUintptr(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	word32 ebp_12;
	sync/atomic.CompareAndSwapUint32(dwArg04, dwArg08, dwArg0C, out ebp_12);
}

// 080491E0: Register word32 sync/atomic.CompareAndSwapUint64(Stack Eq_4 dwArg04, Stack Eq_136 qwArg08, Stack Eq_136 qwArg10, Register out ptr32 ebxOut)
// Called from:
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).decref
//      internal/poll.(*fdMutex).rwlock
//      internal/poll.(*fdMutex).rwunlock
word32 sync/atomic.CompareAndSwapUint64(Eq_4 dwArg04, Eq_136 qwArg08, Eq_136 qwArg10, ptr32 & ebxOut)
{
	ptr32 dwArg10 = (word32) qwArg10;
	__lock();
	word64 edx_eax_19;
	__cmpxchg8b(qwArg08, *dwArg04, qwArg10, out edx_eax_19);
	ebxOut = dwArg10;
	return SLICE(edx_eax_19, word32, 32);
}

// 08049210: Register word32 sync/atomic.AddInt32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync.(*Mutex).Lock
//      sync.(*Mutex).Unlock
word32 sync/atomic.AddInt32(Eq_4 dwArg04, Eq_4 dwArg08)
{
	return sync/atomic.AddUint32(dwArg04, dwArg08);
}

// 08049220: Register Eq_4 sync/atomic.AddUint32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync/atomic.AddInt32
Eq_4 sync/atomic.AddUint32(Eq_4 dwArg04, Eq_4 dwArg08)
{
	__lock();
	*dwArg04 = __xadd(*dwArg04, dwArg08);
	return dwArg04;
}

// 08049240: void sync/atomic.LoadUint32()
// Called from:
//      sync/atomic.LoadUintptr
//      sync/atomic.LoadPointer
//      sync.(*Once).Do
void sync/atomic.LoadUint32()
{
}

// 08049250: void sync/atomic.LoadUint64(Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).decref
//      internal/poll.(*fdMutex).rwlock
//      internal/poll.(*fdMutex).rwunlock
void sync/atomic.LoadUint64(Eq_4 dwArg04)
{
	__emms();
}

// 08049270: void sync/atomic.LoadUintptr()
// Called from:
//      sync.(*Pool).getSlow
//      sync.(*Pool).pin
void sync/atomic.LoadUintptr()
{
	sync/atomic.LoadUint32();
}

// 08049280: void sync/atomic.LoadPointer()
// Called from:
//      sync/atomic.(*Value).Load
//      sync/atomic.(*Value).Store
//      sync.(*entry).load
//      sync.(*entry).tryStore
//      sync.(*entry).tryLoadOrStore
//      sync.(*entry).tryExpungeLocked
void sync/atomic.LoadPointer()
{
	sync/atomic.LoadUint32();
}

// 08049290: void sync/atomic.StoreUint32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync/atomic.StoreUintptr
void sync/atomic.StoreUint32(Eq_4 dwArg04, Eq_4 dwArg08)
{
	*dwArg04 = dwArg08;
}

// 080492A0: void sync/atomic.StoreUintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync/atomic.StorePointer
//      sync.(*Pool).pinSlow
void sync/atomic.StoreUintptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	sync/atomic.StoreUint32(dwArg04, dwArg08);
}

// 080492B0: void type..hash.sync/atomic.Value(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.sync/atomic.Value(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x00);
	runtime.nilinterhash(gs, dwArg04, dwLoc04);
}

// 08049310: void type..eq.sync/atomic.Value(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_238) dwArg04, Stack (ptr32 Eq_239) dwArg08)
void type..eq.sync/atomic.Value(struct Eq_2 * gs, struct Eq_238 * dwArg04, struct Eq_239 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_18 = dwArg04->dw0004;
	Eq_4 eax_19 = dwArg04->t0000;
	word32 ebx_21 = dwArg08->dw0004;
	if (eax_19 == dwArg08->t0000)
		runtime.efaceeq(gs, eax_19, ecx_18, ebx_21);
}

// 08049370: void runtime/internal/sys.Ctz64(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.nextFreeFast
//      runtime.(*mspan).nextFreeIndex
void runtime/internal/sys.Ctz64(Eq_4 dwArg04, Eq_4 dwArg08)
{
	__bsf(dwArg04);
	if (Test(NE,dwArg04 == 0x00))
		return;
	__bsf(dwArg08);
	if (Test(EQ,dwArg08 == 0x00))
		;
}

// 080493A0: void runtime/internal/atomic.Load()
// Called from:
//      runtime/internal/atomic.Loaduintptr
//      runtime/internal/atomic.Loaduint
//      runtime.cgocallbackg1
//      runtime.chanrecv
//      runtime.notesleep
//      runtime.notetsleep_internal
//      runtime.gchelper
//      runtime.markroot
//      runtime.gcAssistAlloc1
//      runtime.gcParkAssist
//      runtime.sweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*gcSweepBuf).numBlocks
//      runtime.(*gcSweepBuf).block
//      runtime.netpollinited
//      runtime.recordForPanic
//      runtime.main
//      runtime.ready
//      runtime.readgstatus
//      runtime.stopTheWorldWithSema
//      runtime.startTheWorldWithSema
//      runtime.handoffp
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.resetspinning
//      runtime.reentersyscall
//      runtime.entersyscall_sysmon
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.newproc1
//      runtime.sigprof
//      runtime.sysmon
//      runtime.retake
//      runtime.schedtrace
//      runtime.runqempty
//      runtime.runqput
//      runtime.runqget
//      runtime.runqgrab
//      runtime.runqsteal
//      runtime.gotraceback
//      runtime.semrelease1
//      runtime.cansemacquire
//      runtime.sigfwdgo
//      runtime.sigsend
//      runtime.signal_ignored
void runtime/internal/atomic.Load()
{
}

// 080493B0: void runtime/internal/atomic.Loadp()
// Called from:
//      runtime.getitab
//      runtime.(*gcSweepBuf).push
//      runtime.(*gcSweepBuf).block
//      runtime.newMarkBits
//      runtime.activeModules
void runtime/internal/atomic.Loadp()
{
}

// 080493C0: Register word32 runtime/internal/atomic.Xadd64(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebxOut, Register out Eq_294 ebpOut)
// Called from:
//      runtime/internal/atomic.Xaddint64
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mspan).sweep
//      runtime.(*gcWork).dispose
//      runtime.(*mheap).alloc_m
//      runtime.oneNewExtraM
//      runtime.newproc1
//      runtime.testAtomic64
word32 runtime/internal/atomic.Xadd64(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebxOut, union Eq_294 & ebpOut)
{
	do
	{
		Eq_4 ecx_9 = *dwArg04;
		Eq_4 ebp_14 = *((word32) dwArg04 + 4);
		Eq_294 ebp_26;
		ptr32 ebx_27;
		word32 edx_29 = runtime/internal/atomic.Cas64(dwArg04, SEQ(ebp_14, ecx_9), SEQ(ebp_14, dwArg08) + SEQ(dwArg0C, ecx_9), out ebx_27, out ebp_26);
	} while ((byte) (word32) bLoc0C == 0x00);
	ebxOut = ebx_27;
	ebpOut = ebp_26;
	return edx_29;
}

// 08049420: void runtime/internal/atomic.Xchg64(Stack Eq_4 dwArg04, Stack Eq_136 qwArg08)
// Called from:
//      runtime.findrunnable
//      runtime.testAtomic64
void runtime/internal/atomic.Xchg64(Eq_4 dwArg04, Eq_136 qwArg08)
{
	do
	{
		word32 ebx_66;
		word32 ebp_67;
		runtime/internal/atomic.Cas64(dwArg04, SEQ(*((word32) dwArg04 + 4), *dwArg04), qwArg08, out ebx_66, out ebp_67);
	} while ((byte) (word32) bLoc0C == 0x00);
}

// 08049480: Register Eq_4 runtime/internal/atomic.Cas(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime/internal/atomic.Casuintptr
//      runtime.(*waitq).dequeue
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addNonGo
//      runtime.lock
//      runtime.(*mcentral).cacheSpan
//      runtime.createfing
//      runtime.sweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*mheap).reclaimList
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.runSafePointFn
//      runtime.handoffp
//      runtime.wakep
//      runtime.entersyscall_gcwait
//      runtime.exitsyscallfast
//      runtime.retake
//      runtime.runqputslow
//      runtime.runqget
//      runtime.runqgrab
//      runtime.check
//      runtime.cansemacquire
//      runtime.sigsend
Eq_4 runtime/internal/atomic.Cas(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	__lock();
	word32 eax_8;
	__cmpxchg(*dwArg04, dwArg0C, dwArg08, out eax_8);
	return dwArg04;
}

// 080494A0: void runtime/internal/atomic.Casuintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.netpollblockcommit
//      runtime.netpollblock
//      runtime.netpollunblock
//      runtime.lockextra
//      runtime.(*guintptr).cas
void runtime/internal/atomic.Casuintptr(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	runtime/internal/atomic.Cas(dwArg04, dwArg08, dwArg0C);
}

// 080494B0: void runtime/internal/atomic.Loaduintptr()
// Called from:
//      runtime.gcMarkRootPrepare
//      runtime.(*gcSweepBuf).push
//      runtime.(*gcSweepBuf).block
//      runtime.(*gcBitsArena).tryAlloc
//      runtime.lockextra
//      runtime.runqempty
//      runtime.sigInstallGoHandler
//      runtime.raisebadsignal
//      runtime.sigfwdgo
//      runtime.newstack
void runtime/internal/atomic.Loaduintptr()
{
	runtime/internal/atomic.Load();
}

// 080494C0: void runtime/internal/atomic.Loaduint()
// Called from:
//      runtime.chanrecv
void runtime/internal/atomic.Loaduint()
{
	runtime/internal/atomic.Load();
}

// 080494D0: void runtime/internal/atomic.Storeuintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*gcSweepBuf).push
//      runtime.unlockextra
void runtime/internal/atomic.Storeuintptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime/internal/atomic.Store(dwArg04, dwArg08);
}

// 080494E0: void runtime/internal/atomic.Xadduintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*gcBitsArena).tryAlloc
//      runtime.mSysStatInc
//      runtime.mSysStatDec
void runtime/internal/atomic.Xadduintptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime/internal/atomic.Xadd(dwArg04, dwArg08);
}

// 080494F0: Register word32 runtime/internal/atomic.Loadint64(Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcAssistAlloc
//      runtime.gcParkAssist
word32 runtime/internal/atomic.Loadint64(Eq_4 dwArg04)
{
	word64 mm0_13;
	return runtime/internal/atomic.Load64(dwArg04, out mm0_13);
}

// 08049500: Register word32 runtime/internal/atomic.Xaddint64(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebxOut, Register out ptr32 ebpOut)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcMarkDone
//      runtime.gcBgMarkWorker
//      runtime.gcAssistAlloc
//      runtime.gcAssistAlloc1
//      runtime.gcFlushBgCredit
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.(*gcWork).dispose
//      runtime.(*gcControllerState).findRunnableGCWorker.func1
word32 runtime/internal/atomic.Xaddint64(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebxOut, ptr32 & ebpOut)
{
	ptr32 ebp_6;
	ptr32 ebx_7;
	word32 edx_9 = runtime/internal/atomic.Xadd64(dwArg04, dwArg08, dwArg0C, out ebx_7, out ebp_6);
	ebxOut = ebx_7;
	ebpOut = ebp_6;
	return edx_9;
}

// 08049510: Register word32 runtime/internal/atomic.Cas64(Stack Eq_4 dwArg04, Stack Eq_136 qwArg08, Stack Eq_136 qwArg10, Register out ptr32 ebxOut, Register out Eq_4 ebpOut)
// Called from:
//      runtime/internal/atomic.Xadd64
//      runtime/internal/atomic.Xchg64
//      runtime.(*lfstack).push
//      runtime.(*lfstack).pop
//      runtime.sysmon
//      runtime.(*profAtomic).cas
//      runtime.(*profBuf).takeOverflow
//      runtime.(*profBuf).incrementOverflow
//      runtime.testAtomic64
word32 runtime/internal/atomic.Cas64(Eq_4 dwArg04, Eq_136 qwArg08, Eq_136 qwArg10, ptr32 & ebxOut, union Eq_4 & ebpOut)
{
	ptr32 dwArg10 = (word32) qwArg10;
	Eq_4 ebp_17 = dwArg04;
	if ((dwArg04 & 0x07) != 0x00)
		ebp_17 = null;
	__lock();
	word64 edx_eax_19;
	__cmpxchg8b(qwArg08, *ebp_17, qwArg10, out edx_eax_19);
	ebxOut = dwArg10;
	ebpOut = ebp_17;
	return SLICE(edx_eax_19, word32, 32);
}

// 08049540: void runtime/internal/atomic.Casp1(Stack (ptr32 Eq_4) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.casp
//      runtime.adjustpointers
void runtime/internal/atomic.Casp1(union Eq_4 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	__lock();
	word32 eax_8;
	__cmpxchg(*dwArg04, dwArg0C, dwArg08, out eax_8);
}

// 08049560: Register Eq_4 runtime/internal/atomic.Xadd(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime/internal/atomic.Xadduintptr
//      runtime.queuefinalizer
//      runtime.gcMarkDone
//      runtime.gcBgMarkWorker
//      runtime.gchelper
//      runtime.gcAssistAlloc1
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.sweepone
//      runtime.(*gcSweepBuf).push
//      runtime.(*gcSweepBuf).pop
//      runtime.getfull
//      runtime.netpollblockcommit
//      runtime.netpollgoready
//      runtime.gopanic
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.needm
//      runtime.oneNewExtraM
//      runtime.dropm
//      runtime.lockextra
//      runtime.startm
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.resetspinning
//      runtime.goexit0
//      runtime.newproc1
//      runtime.pidleput
//      runtime.pidleget
//      runtime.(*rwmutex).rlock
//      runtime.(*rwmutex).runlock
//      runtime.semacquire1
//      runtime.semrelease1
Eq_4 runtime/internal/atomic.Xadd(Eq_4 dwArg04, Eq_4 dwArg08)
{
	__lock();
	*dwArg04 = __xadd(*dwArg04, dwArg08);
	return dwArg04;
}

// 08049580: Register Eq_4 runtime/internal/atomic.Xchg(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime/internal/atomic.Xchguintptr
//      runtime.lock
//      runtime.unlock
//      runtime.notewakeup
//      runtime.newextram
Eq_4 runtime/internal/atomic.Xchg(Eq_4 dwArg04, Eq_4 dwArg08)
{
	*dwArg04 = dwArg08;
	return dwArg04;
}

// 08049590: Register Eq_363 runtime/internal/atomic.Xchguintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.netpollblock
Eq_363 runtime/internal/atomic.Xchguintptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	return runtime/internal/atomic.Xchg(dwArg04, dwArg08);
}

// 080495A0: Register Eq_4 runtime/internal/atomic.StorepNoWB(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.atomicstorep
//      runtime.(*gcSweepBuf).push
//      runtime.newMarkBits
//      runtime.nextMarkBitArenaEpoch
Eq_4 runtime/internal/atomic.StorepNoWB(Eq_4 dwArg04, Eq_4 dwArg08)
{
	*dwArg04 = dwArg08;
	return dwArg04;
}

// 080495B0: void runtime/internal/atomic.Store(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime/internal/atomic.Storeuintptr
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addNonGo
//      runtime.(*mcentral).freeSpan
//      runtime.runfinq
//      runtime.setGCPhase
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).grow
//      internal/poll.runtime_pollServerInit
//      runtime.forcegchelper
//      runtime.freezetheworld
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.reentersyscall
//      runtime.entersyscall_sysmon
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.procresize
//      runtime.sysmon
//      runtime.runqput
//      runtime.runqsteal
//      runtime/debug.SetTraceback
//      runtime.traceback1
void runtime/internal/atomic.Store(Eq_4 dwArg04, Eq_4 dwArg08)
{
	*dwArg04 = dwArg08;
}

// 080495C0: Register ptr32 runtime/internal/atomic.Load64(Stack Eq_4 dwArg04, Register out Eq_4 mm0Out)
// Called from:
//      runtime/internal/atomic.Loadint64
//      runtime.(*lfstack).push
//      runtime.(*lfstack).pop
//      runtime.(*lfstack).empty
//      runtime.(*gcControllerState).revise
//      runtime.gcSetTriggerRatio
//      runtime.gcTrigger.test
//      runtime.gcStart
//      runtime.gcResetMarkState
//      runtime.deductSweepCredit
//      runtime.blocksampled
//      sync.event
//      runtime.handoffp
//      runtime.sysmon
//      runtime.(*profAtomic).load
//      runtime.(*profBuf).hasOverflow
//      runtime.(*profBuf).takeOverflow
//      runtime.(*profBuf).incrementOverflow
//      runtime.testAtomic64
ptr32 runtime/internal/atomic.Load64(Eq_4 dwArg04, union Eq_4 & mm0Out)
{
	Eq_4 eax_12 = dwArg04;
	if ((dwArg04 & 0x07) != 0x00)
		eax_12 = null;
	Eq_4 mm0_14 = *eax_12;
	__emms();
	mm0Out = mm0_14;
	return fp + 0x08;
}

// 080495E0: void runtime/internal/atomic.Store64(Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08)
// Called from:
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.findrunnable
//      runtime.(*profBuf).incrementOverflow
//      runtime.testAtomic64
void runtime/internal/atomic.Store64(Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 qwArg08)
{
	Eq_4 eax_13 = dwArg04;
	if ((dwArg04 & 0x07) != 0x00)
		eax_13 = null;
	*eax_13 = qwArg08;
	__emms();
	__lock();
	__xadd(dwArg00, 0x00);
}

// 08049610: void runtime/internal/atomic.Or8(Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.mapiterinit
//      runtime.markBits.setMarked
//      runtime.heapBits.setCheckmarked
//      runtime.greyobject
//      runtime.check
void runtime/internal/atomic.Or8(Eq_4 dwArg04, byte bArg08)
{
	__lock();
	*dwArg04 |= bArg08;
}

// 08049620: void runtime/internal/atomic.And8(Stack (ptr32 byte) dwArg04, Stack byte bArg08)
// Called from:
//      runtime.check
void runtime/internal/atomic.And8(byte * dwArg04, byte bArg08)
{
	__lock();
	*dwArg04 &= bArg08;
}

// 08049630: void runtime.memhash0(Register (ptr32 Eq_529) gs)
void runtime.memhash0(struct Eq_529 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049660: void runtime.memhash8(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void runtime.memhash8(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x01);
}

// 080496B0: void runtime.memhash16(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void runtime.memhash16(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x02);
}

// 08049700: void runtime.memhash32(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void runtime.memhash32(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04);
}

// 08049750: void runtime.memhash64(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void runtime.memhash64(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x08);
}

// 080497A0: void runtime.memhash128(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void runtime.memhash128(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x10);
}

// 080497F0: void runtime.strhash(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack (ptr32 Eq_639) dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.runtime.modulehash
//      type..hash.runtime.Frame
//      type..hash.runtime.TypeAssertionError
//      type..hash.runtime.dbgVar
//      type..hash.runtime.sigTabT
//      type..hash.[2]string
//      type..hash.[3]string
//      type..hash.[4]string
//      type..hash.[5]string
//      type..hash.[6]string
//      type..hash.[9]string
//      type..hash.strconv.leftCheat
//      type..hash.[133]string
//      type..hash.os.file
//      type..hash.os.PathError
//      type..hash.reflect.Method
//      type..hash.reflect.ValueError
//      type..hash.[27]string
//      type..hash.struct { F uintptr; reflect.name string }
void runtime.strhash(struct Eq_2 * gs, word64 mm0, struct Eq_639 * dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04->t0000, dwArg08, dwArg04->t0004);
}

// 08049840: Register Eq_661 runtime.f32hash(Register (ptr32 Eq_2) gs, Register word64 mm0, Register Eq_661 xmm1, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      runtime.c64hash
Eq_661 runtime.f32hash(struct Eq_2 * gs, word64 mm0, Eq_661 xmm1, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_678 xmm0_18 = (uint128) (uint32) *dwArg04;
	Eq_661 xmm1_23 = __xorps(xmm1, xmm1);
	if ((real32) xmm0_18 == xmm1_23 && !PARITY_EVEN((real32) xmm0_18 - xmm1_23))
		return;
	if ((real32) xmm0_18 != xmm0_18 || PARITY_EVEN((real32) xmm0_18 - xmm0_18))
	{
		Eq_4 eax_70 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		int32 ecx_71 = *((word32) eax_70 + 0x0094);
		*((word32) eax_70 + 0x0094) = ecx_71 << 0x01 ^ ecx_71 >> 0x1F & 0xA8888EEF;
		return;
	}
	else
	{
		runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04);
		return;
	}
}

// 08049900: Register Eq_661 runtime.f64hash(Register (ptr32 Eq_2) gs, Register word64 mm0, Register Eq_661 xmm1, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      runtime.c128hash
//      type..hash.runtime.MemStats
//      type..hash.runtime.gcControllerState
//      type..hash.runtime.mstats
//      type..hash.[33]float64
Eq_661 runtime.f64hash(struct Eq_2 * gs, word64 mm0, Eq_661 xmm1, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_751 xmm0_18 = (uint128) (uint64) *dwArg04;
	Eq_661 xmm1_23 = __xorps(xmm1, xmm1);
	if ((real64) xmm0_18 == xmm1_23 && !PARITY_EVEN((real64) xmm0_18 - xmm1_23))
		return;
	if ((real64) xmm0_18 != xmm0_18 || PARITY_EVEN((real64) xmm0_18 - xmm0_18))
	{
		Eq_4 eax_70 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		int32 ecx_71 = *((word32) eax_70 + 0x0094);
		*((word32) eax_70 + 0x0094) = ecx_71 << 0x01 ^ ecx_71 >> 0x1F & 0xA8888EEF;
		return;
	}
	else
	{
		runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x08);
		return;
	}
}

// 080499C0: void runtime.c64hash(Register (ptr32 Eq_2) gs, Register word64 mm0, Register Eq_661 xmm1, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void runtime.c64hash(struct Eq_2 * gs, word64 mm0, Eq_661 xmm1, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.f32hash(gs, mm0, runtime.f32hash(gs, mm0, xmm1, dwArg04, dwArg08), (word32) dwArg04 + 4, dwLoc04);
}

// 08049A20: void runtime.c128hash(Register (ptr32 Eq_2) gs, Register word64 mm0, Register Eq_661 xmm1, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void runtime.c128hash(struct Eq_2 * gs, word64 mm0, Eq_661 xmm1, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.f64hash(gs, mm0, runtime.f64hash(gs, mm0, xmm1, dwArg04, dwArg08), (word32) dwArg04 + 8, dwLoc04);
}

// 08049A80: void runtime.interhash(Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_869)) dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.os.PathError
//      type..hash.reflect.Method
void runtime.interhash(struct Eq_2 * gs, struct Eq_869 ** dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_869 * ecx_18 = *dwArg04;
	if (ecx_18 == null)
		return;
	Eq_4 ecx_26 = ecx_18->t0004;
	Eq_4 edx_28 = **((word32) ecx_26 + 16);
	if (edx_28 == 0x00)
	{
		runtime.(*_type).string(gs, ecx_26);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if (((byte) (word32) *((word32) ecx_26 + 0x0F) & 0x20) == 0x00)
	{
		Eq_4 eax_101 = *edx_28;
		word32 edx_105;
		eax_101();
	}
	else
	{
		Eq_4 eax_119 = *edx_28;
		word32 edx_122;
		eax_119();
	}
}

// 08049BA0: void runtime.nilinterhash(Register (ptr32 Eq_2) gs, Stack Eq_207 dwArg04, Stack word32 dwArg08)
// Called from:
//      type..hash.sync/atomic.Value
//      type..hash.runtime._panic
//      type..hash.struct { reflect.b bool; reflect.x interface {} }
void runtime.nilinterhash(struct Eq_2 * gs, Eq_207 dwArg04, word32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 == 0x00)
		return;
	Eq_4 edx_27 = **((word32) ecx_18 + 16);
	if (edx_27 == 0x00)
	{
		runtime.(*_type).string(gs, ecx_18);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if (((byte) (word32) *((word32) ecx_18 + 0x0F) & 0x20) == 0x00)
	{
		Eq_4 eax_100 = *edx_27;
		word32 edx_104;
		eax_100();
	}
	else
	{
		Eq_4 eax_118 = *edx_27;
		word32 edx_121;
		eax_118();
	}
}

// 08049CB0: void runtime.memequal0(Register (ptr32 Eq_987) gs)
void runtime.memequal0(struct Eq_987 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049CD0: void runtime.memequal8(Register (ptr32 Eq_1000) gs)
void runtime.memequal8(struct Eq_1000 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049D10: void runtime.memequal16(Register (ptr32 Eq_1013) gs)
void runtime.memequal16(struct Eq_1013 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049D50: void runtime.memequal32(Register (ptr32 Eq_1026) gs)
void runtime.memequal32(struct Eq_1026 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049D80: void runtime.memequal64(Register (ptr32 Eq_1039) gs)
void runtime.memequal64(struct Eq_1039 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049DC0: void runtime.memequal128(Register (ptr32 Eq_1052) gs, Stack (ptr32 Eq_1053) dwArg04, Stack (ptr32 Eq_1054) dwArg08)
// Called from:
//      type..eq.runtime.traceStack
void runtime.memequal128(struct Eq_1052 * gs, struct Eq_1053 * dwArg04, struct Eq_1054 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 ecx_17 = dwArg04->dw0004;
	word32 edx_18 = dwArg04->dw0000;
	(byte) (SEQ(SLICE(ecx_17, word24, 8), ecx_17 == dwArg08->dw0004) & SEQ(SLICE(edx_18, word24, 8), edx_18 == dwArg08->dw0000)) == 0x00;
}

// 08049E20: void runtime.f32equal(Register (ptr32 Eq_1091) gs, Stack (ptr32 real32) dwArg04, Stack (ptr32 real32) dwArg08)
void runtime.f32equal(struct Eq_1091 * gs, real32 * dwArg04, real32 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	PARITY_EVEN((real32) (uint128) (uint32) *dwArg04 - (uint128) ((uint32) (*dwArg08)));
}

// 08049E60: void runtime.f64equal(Register (ptr32 Eq_1122) gs, Stack (ptr32 real64) dwArg04, Stack (ptr32 real64) dwArg08)
void runtime.f64equal(struct Eq_1122 * gs, real64 * dwArg04, real64 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	PARITY_EVEN((real64) (uint128) (uint64) *dwArg04 - (uint128) ((uint64) (*dwArg08)));
}

// 08049EA0: void runtime.c64equal(Register (ptr32 Eq_1153) gs, Stack (ptr32 Eq_1154) dwArg04, Stack (ptr32 Eq_1155) dwArg08)
void runtime.c64equal(struct Eq_1153 * gs, struct Eq_1154 * dwArg04, struct Eq_1155 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uint128 xmm0_17 = (uint128) (uint32) dwArg04->r0004;
	Eq_1174 xmm2_20 = (uint128) (uint32) dwArg08->r0004;
	PARITY_EVEN((real32) (uint128) (uint32) dwArg04->r0000 - (uint128) ((uint32) dwArg08->r0000));
	PARITY_EVEN((real32) xmm0_17 - xmm2_20);
}

// 08049EF0: void runtime.c128equal(Register (ptr32 Eq_1202) gs, Stack (ptr32 Eq_1203) dwArg04, Stack (ptr32 Eq_1204) dwArg08)
void runtime.c128equal(struct Eq_1202 * gs, struct Eq_1203 * dwArg04, struct Eq_1204 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uint128 xmm0_17 = (uint128) (uint64) dwArg04->r0008;
	Eq_1223 xmm2_20 = (uint128) (uint64) dwArg08->r0008;
	PARITY_EVEN((real64) (uint128) (uint64) dwArg04->r0000 - (uint128) ((uint64) dwArg08->r0000));
	PARITY_EVEN((real64) xmm0_17 - xmm2_20);
}

// 08049F50: void runtime.strequal(Register (ptr32 Eq_1251) gs, Stack (ptr32 Eq_1252) dwArg04, Stack (ptr32 Eq_1253) dwArg08)
void runtime.strequal(struct Eq_1251 * gs, struct Eq_1252 * dwArg04, struct Eq_1253 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 eax_19 = dwArg04->t0000;
	Eq_4 edx_22 = dwArg08->t0000;
	if (ecx_18 == dwArg08->t0004)
	{
		word32 edi_29;
		word32 esi_30;
		runtime.eqstring(eax_19, ecx_18, edx_22, out esi_30, out edi_29);
	}
}

// 08049FB0: void runtime.interequal(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_1295) dwArg04, Stack (ptr32 Eq_1296) dwArg08)
void runtime.interequal(struct Eq_2 * gs, struct Eq_1295 * dwArg04, struct Eq_1296 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 eax_19 = dwArg04->t0000;
	Eq_4 edx_22 = dwArg08->t0004;
	if (eax_19 == dwArg08->t0000)
		runtime.ifaceeq(gs, eax_19, ecx_18, edx_22);
}

// 0804A010: void runtime.nilinterequal(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_1333) dwArg04, Stack (ptr32 Eq_1334) dwArg08)
void runtime.nilinterequal(struct Eq_2 * gs, struct Eq_1333 * dwArg04, struct Eq_1334 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_18 = dwArg04->dw0004;
	Eq_4 eax_19 = dwArg04->t0000;
	word32 edx_22 = dwArg08->dw0004;
	if (eax_19 == dwArg08->t0000)
		runtime.efaceeq(gs, eax_19, ecx_18, edx_22);
}

// 0804A070: void runtime.efaceeq(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      type..eq.sync/atomic.Value
//      runtime.nilinterequal
//      type..eq.runtime._panic
//      type..eq.struct { reflect.b bool; reflect.x interface {} }
void runtime.efaceeq(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	Eq_4 edx_25 = *((word32) *((word32) dwArg04 + 16) + 4);
	if (edx_25 == 0x00)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x20) == 0x00)
	{
		Eq_4 eax_95 = *edx_25;
		word32 edx_99;
		eax_95();
	}
	else
	{
		Eq_4 eax_110 = *edx_25;
		word32 edx_113;
		eax_110();
	}
}

// 0804A170: void runtime.ifaceeq(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.interequal
//      os.(*File).Write
//      os.(*file).close
//      type..eq.os.PathError
//      reflect.haveIdenticalType
//      type..eq.reflect.Method
void runtime.ifaceeq(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	Eq_4 eax_24 = *((word32) dwArg04 + 4);
	Eq_4 edx_26 = *((word32) *((word32) eax_24 + 16) + 4);
	if (edx_26 == 0x00)
	{
		runtime.(*_type).string(gs, eax_24);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if (((byte) (word32) *((word32) eax_24 + 0x0F) & 0x20) == 0x00)
	{
		Eq_4 eax_96 = *edx_26;
		word32 edx_100;
		eax_96();
	}
	else
	{
		Eq_4 eax_111 = *edx_26;
		word32 edx_114;
		eax_111();
	}
}

// 0804A270: void runtime.alginit(Register (ptr32 Eq_2) gs, Register word64 mm0)
// Called from:
//      runtime.schedinit
void runtime.alginit(struct Eq_2 * gs, word64 mm0)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_t8157576 == 0x00 || ((byte) ((word32) g_t8157581) == 0x00 || (byte) ((word32) g_t815757F) == 0x00))
	{
		runtime.getRandomData(gs, mm0, 135624416, 0x10);
		g_dw81576E0 |= 0x01;
		g_dw81576E4 |= 0x01;
		g_dw81576E8 |= 0x01;
		g_dw81576EC |= 0x01;
	}
	else
	{
		g_b8157582 = 0x01;
		if (g_t81576F0 == 0x00)
		{
			g_ptr8144340 = 0x080E7B80;
			g_ptr8144348 = 0x080E7B84;
			g_ptr8144358 = 0x080E7B88;
		}
		else
		{
			runtime.writebarrierptr(0x08144340, 0x080E7B80);
			runtime.writebarrierptr(0x08144348, 0x080E7B84);
			runtime.writebarrierptr(135545688, 0x080E7B88);
		}
		runtime.getRandomData(gs, mm0, 0x081577A0, 0x40);
	}
}

// 0804A3C0: Register word32 runtime.atomicstorep(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.cgocallbackg1
//      runtime.additab
//      internal/poll.runtime_pollUnblock
//      runtime.mcommoninit
//      runtime.procresize
//      runtime.modulesinit
//      runtime.(*traceStackTable).put
word32 runtime.atomicstorep(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime.writebarrierptr_prewrite(dwArg08);
	return runtime/internal/atomic.StorepNoWB(dwArg04, dwArg08);
}

// 0804A400: void runtime.casp(Stack (ptr32 Eq_4) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.check
void runtime.casp(union Eq_4 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	runtime.writebarrierptr_prewrite(dwArg0C);
	runtime/internal/atomic.Casp1(dwArg04, dwArg08, dwArg0C);
}

// 0804A450: void sync/atomic.StorePointer(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync/atomic.(*Value).Store
//      sync.(*entry).storeLocked
//      sync.(*Pool).pinSlow
void sync/atomic.StorePointer(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime.writebarrierptr_prewrite(dwArg08);
	sync/atomic.StoreUintptr(dwArg04, dwArg08);
}

// 0804A490: void sync/atomic.CompareAndSwapPointer(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync/atomic.(*Value).Store
//      sync.(*entry).tryStore
//      sync.(*entry).unexpungeLocked
//      sync.(*entry).tryLoadOrStore
//      sync.(*entry).tryExpungeLocked
void sync/atomic.CompareAndSwapPointer(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	runtime.writebarrierptr_prewrite(dwArg0C);
	sync/atomic.CompareAndSwapUintptr(dwArg04, dwArg08, dwArg0C);
}

// 0804A4E0: void runtime.cgocall(Register (ptr32 Eq_2) gs, Stack (ptr32 code) dwArg04, Stack ptr32 dwArg08)
// Called from:
//      runtime.main
void runtime.cgocall(struct Eq_2 * gs, <anonymous> * dwArg04, ptr32 dwArg08)
{
	if ((byte) (word32) g_b8157571 == 0x00)
		runtime.throw(gs);
	else if (dwArg04 == null)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_36 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		*((word32) ecx_36 + 452) = (word32) *((word32) ecx_36 + 452) + 2;
		Eq_4 ecx_41 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_42 = *((word32) ecx_41 + 24);
		if (g_t81576F0 == 0x00)
			*((word32) edx_42 + 188) = ecx_41;
		else
			runtime.writebarrierptr((word32) edx_42 + 188, ecx_41);
		Eq_4 ebp_68 = *((word32) ecx_41 + 24);
		if (g_t81576F0 == 0x00)
			*((word32) ecx_41 + 0x0088) = ebp_68;
		else
			runtime.writebarrierptr((word32) ecx_41 + 0x0088, ebp_68);
		Eq_4 eax_89 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		up32 ecx_92 = *((word32) eax_89 + 0x0098);
		word32 edx_95 = *((word32) eax_89 + 0x009C);
		*((word32) eax_89 + 0x0098) = ecx_92 + 0x01;
		*((word32) eax_89 + 0x009C) = (bool) (ecx_92 < 0x01) + edx_95;
		*((word32) eax_89 + 0x00A0) = (word32) *((word32) eax_89 + 0x00A0) + 1;
		*((word32) eax_89 + 0x0091) = 0x01;
		**((word32) eax_89 + 0x00A8) = 0x00;
		runtime.entersyscall(gs);
		word32 edi_198;
		runtime.asmcgocall(gs, dwArg04, dwArg08, out edi_198);
		word32 esi_199;
		runtime.exitsyscall(gs, out esi_199);
		runtime.endcgo(gs, eax_89);
	}
}

// 0804A670: void runtime.endcgo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.cgocall
//      runtime.unwindm
void runtime.endcgo(struct Eq_2 * gs, Eq_4 dwArg04)
{
	*((word32) dwArg04 + 0x0091) = 0x00;
	--*((word32) dwArg04 + 0x00A0);
	runtime.unlockOSThread(gs);
}

// 0804A690: void runtime.cgocallbackg(Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.cgocallback_gofunc
void runtime.cgocallbackg(Eq_4 ebp, struct Eq_2 * gs, Eq_4 dwArg00)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	if (eax_8 != *((word32) (*((word32) eax_8 + 24)) + 84))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.exit();
	}
	fn08090264((word32) *((word32) eax_8 + 24) + 528, fp - 0x20);
	Eq_4 ecx_65 = *((word32) eax_8 + 56);
	Eq_4 edx_67 = *((word32) eax_8 + 60);
	Eq_4 esi_75;
	runtime.exitsyscall(gs, out esi_75);
	dwLoc08->ptr0018->b0091 = 0x00;
	runtime.cgocallbackg1(ebp, esi_75, gs, dwArg00);
	dwLoc08->ptr0018->b0091 = 0x01;
	runtime.reentersyscall(gs, edx_67, ecx_65);
	fn08090264(fp - 0x24, &dwLoc08->ptr0018->b0091 + 383);
}

// 0804A780: void runtime.cgocallbackg1(Register Eq_4 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.cgocallbackg
void runtime.cgocallbackg1(Eq_4 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_35;
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	union Eq_4 * esp_16 = fp - 0x38;
	eax_35 = eax_18;
	if ((byte) (word32) *((word32) *((word32) eax_18 + 24) + 0x01CC) == 0x00)
	{
		runtime/internal/atomic.Load();
		esp_16 = fp - 0x34;
		if (dwLoc30 <= 0x00)
			goto l0804A7D4;
		eax_35 = dwLoc04;
	}
	*((word32) *((word32) eax_35 + 24) + 0x01CC) = 0x00;
	*esp_16 = (union Eq_4 *) 135167116;
	word32 edi_347;
	runtime.systemstack(gs, *esp_16, out ebp, out edi_347);
l0804A7D4:
	if (dwArg04 != 0x00)
	{
		Eq_4 edx_62 = *((word32) eax_18 + 188);
		Eq_4 ebx_104 = (word32) edx_62 + 1;
		Eq_4 ebp_64 = *((word32) eax_18 + 0x00B8);
		Eq_4 esi_112 = *((word32) eax_18 + 0x00C0);
		if ((word32) edx_62 + 1 > esi_112)
		{
			word32 esi_348;
			runtime.growslice(gs, 0x080CF360, ebp_64, edx_62, esi_112, (word32) edx_62 + 1, out esi_348);
			ebp_64 = dwLoc24;
			esi_112 = dwLoc1C;
			ebx_104 = dwLoc20 + 0x01;
		}
		*((word32) ebp_64 + edx_62 * 0x04) = dwArg04;
		if (ebx_104 <= 0x00)
			runtime.panicindex(gs);
		runtime.atomicstorep((word32) eax_18 + 0x00B8, ebp_64);
		*((word32) eax_18 + 0x00C0) = esi_112;
		*((word32) eax_18 + 188) = ebx_104;
		word32 edi_349;
		if (runtime.deferproc(gs, 0x04, 0x080E7BBC, eax_18, out ebp, out esi, out edi_349) != 0x00)
		{
			runtime.deferreturn(gs);
			return;
		}
	}
	if (*((word32) *((word32) eax_18 + 24) + 0x00A0) == 0x00)
	{
		word32 edi_350;
		runtime.chanrecv1(ebp, esi, gs, g_t8144FD4, 0x00, out edi_350);
	}
	word32 edi_353;
	word32 ebp_351;
	word32 esi_352;
	if (runtime.deferproc(gs, 0x04, 0x080E7D00, fp - 0x15, out ebp_351, out esi_352, out edi_353) != 0x00)
		runtime.deferreturn(gs);
	else
	{
		runtime.reflectcall(*((word32) *((word32) **((word32) eax_18 + 24) + 28) + 24));
		runtime.deferreturn(gs);
	}
}

// 0804A9A0: void runtime.unwindm(Register (ptr32 Eq_2) gs, Stack (ptr32 byte) dwArg04)
void runtime.unwindm(struct Eq_2 * gs, byte * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) *dwArg04 == 0x00)
		return;
	Eq_4 eax_26 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_27 = *((word32) eax_26 + 24);
	*((word32) ecx_27 + 0x0078) = (word32) *((word32) ecx_27 + 0x0078) + 1;
	Eq_4 ecx_31 = *((word32) eax_26 + 24);
	Eq_4 edx_32 = *ecx_31;
	*((word32) edx_32 + 28) = **((word32) edx_32 + 28);
	if (*((word32) ecx_31 + 0x00A0) > 0x00)
		runtime.endcgo(gs, ecx_31);
	Eq_4 eax_61 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_63 = *((word32) ecx_31 + 0x0078);
	*((word32) ecx_31 + 0x0078) = edx_63 - 0x01;
	if (edx_63 == 0x01 && (byte) ((word32) (*((word32) eax_61 + 0x006C))) != 0x00)
		((word32) eax_61 + 8)->u0 = ~0x0521;
}

// 0804AA50: Register Eq_4 runtime.cgoIsGoPointer(Stack Eq_4 dwArg04)
// Called from:
//      runtime.cgoCheckWriteBarrier
//      runtime.cgoCheckMemmove
//      runtime.cgoCheckSliceCopy
//      runtime.cgoCheckTypedBlock
//      runtime.cgoCheckBits
Eq_4 runtime.cgoIsGoPointer(Eq_4 dwArg04)
{
	if (dwArg04 == 0x00)
		return esi;
	if (dwArg04 != 0x00)
	{
		Eq_4 edx_17 = g_t81493A8;
		if (dwArg04 >= edx_17 && dwArg04 < g_t81493AC)
		{
			Eq_4 ebx_23 = g_t8149108;
			esi = dwArg04;
			uint32 ecx_26 = dwArg04 - edx_17;
			if (ecx_26 >> 0x0D >= g_t814910C)
				runtime.panicindex(gs);
			Eq_4 ecx_34 = *((word32) ebx_23 + (ecx_26 >> 0x0D) * 0x04);
			if (ecx_34 != 0x00 && (dwArg04 >= *((word32) ecx_34 + 0x0C) && ((byte) ((word32) (*((word32) ecx_34 + 60)) - 0x01) <= 0x01 && dwArg04 < *((word32) ecx_34 + 80))))
				return dwArg04;
		}
	}
	runtime.activeModules();
	word32 * ecx_129 = dwLoc0C;
	int32 ebx_133 = 0x00;
	while (true)
	{
		word24 edx_24_8_188 = SLICE(dwArg04, word24, 8);
		if (ebx_133 >= dwLoc08)
			break;
		Eq_4 esi_83;
		struct Eq_2173 * ebp_77 = *ecx_129;
		Eq_4 esi_78 = ebp_77->t0040;
		Eq_4 edi_79 = ebp_77->t0044;
		if (esi_78 <= dwArg04)
			esi_83 = SEQ(SLICE(esi_78, word24, 8), dwArg04 < edi_79);
		else
			esi_83.u0 = 0x00;
		esi = esi_83;
		if ((byte) esi_83 != 0x00)
			return esi;
		uip32 edx_219;
		esi = ebp_77->t0048;
		Eq_4 ebp_112 = ebp_77->t004C;
		if (esi <= dwArg04)
			edx_219 = SEQ(edx_24_8_188, dwArg04 < ebp_112);
		else
			edx_219 = 0x00;
		if ((byte) edx_219 != 0x00)
			return esi;
		++ecx_129;
		++ebx_133;
	}
	return esi;
}

// 0804AB50: void runtime.cgoCheckWriteBarrier(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.writebarrierptr
//      runtime.writebarrierptr_prewrite
void runtime.cgoCheckWriteBarrier(struct Eq_2 * gs)
{
	runtime.cgoIsGoPointer(dwArg08);
	if ((byte) (word32) bLoc10 == 0x00)
		return;
	runtime.cgoIsGoPointer(dwArg04);
	if ((byte) (word32) bLoc10 != 0x00)
		return;
	Eq_4 eax_36 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_37 = *((word32) eax_36 + 24);
	if (*ecx_37 == eax_36 || *((word32) ecx_37 + 44) == eax_36)
		return;
	if (*((word32) ecx_37 + 0x0068) != 0x00)
		return;
	word32 ebp_109;
	word32 edi_110;
	runtime.systemstack(gs, fp - 0x0C, out ebp_109, out edi_110);
}

// 0804ABE0: void runtime.cgoCheckMemmove(Stack Eq_4 dwArg04)
// Called from:
//      runtime.typedmemmove
//      reflect.typedmemmovepartial
void runtime.cgoCheckMemmove(Eq_4 dwArg04)
{
	if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x80) != 0x00)
		return;
	runtime.cgoIsGoPointer(dwArg0C);
	if ((byte) (word32) bLoc0C == 0x00)
		return;
	runtime.cgoIsGoPointer(dwArg08);
	if ((byte) (word32) bLoc0C != 0x00)
		return;
	runtime.cgoCheckTypedBlock(dwArg04, dwArg0C, dwArg10, dwArg14);
}

// 0804AC50: Register word32 runtime.cgoCheckSliceCopy(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg14, Stack Eq_4 dwArg20)
// Called from:
//      runtime.typedslicecopy
word32 runtime.cgoCheckSliceCopy(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg14, Eq_4 dwArg20)
{
	if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x80) != 0x00)
		return esi;
	word32 esi_21 = runtime.cgoIsGoPointer(dwArg14);
	if ((byte) (word32) bLoc14 == 0x00)
		return esi_21;
	word32 esi_129 = runtime.cgoIsGoPointer(dwArg08);
	if ((byte) (word32) bLoc14 != 0x00)
		return esi_129;
	Eq_4 eax_54 = 0x00;
	Eq_4 ecx_57 = dwArg14;
	while (eax_54 < dwArg20)
	{
		esi_129 = runtime.cgoCheckTypedBlock(dwArg04, ecx_57, 0x00, *dwArg04);
		eax_54 = (word32) eax_54 + 1;
		ecx_57 = Mem72[dwArg04 + 0x00:word32] + ecx_57;
	}
	return esi_129;
}

// 0804ACF0: Register Eq_4 runtime.cgoCheckTypedBlock(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.cgoCheckMemmove
//      runtime.cgoCheckSliceCopy
Eq_4 runtime.cgoCheckTypedBlock(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	Eq_4 ecx_7 = *((word32) dwArg04 + 4);
	if (ecx_7 <= dwArg0C)
		return esi;
	Eq_4 ecx_13 = ecx_7 - dwArg0C;
	if (dwArg10 <= ecx_13)
		ecx_13 = dwArg10;
	if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x40) == 0x00)
	{
		runtime.cgoCheckBits(dwArg08, *((word32) dwArg04 + 20), dwArg0C, ecx_13);
		return esi;
	}
	else
	{
		runtime.activeModules();
		word32 * eax_189 = dwLoc30;
		int32 ebx_267;
		for (ebx_267 = 0x00; ebx_267 < dwLoc2C; ++ebx_267)
		{
			Eq_2429 bl_201;
			struct Eq_2430 * ebp_190 = *eax_189;
			Eq_4 esi_191 = ebp_190->t0040;
			Eq_4 ebx_193 = ebp_190->t0044;
			if (esi_191 <= dwArg08)
				bl_201 = dwArg08 < ebx_193;
			else
				bl_201.u0 = 0x00;
			if (bl_201 != 0x00)
			{
				Eq_4 esi_210 = esi_191 - dwArg08;
				runtime.cgoCheckBits(esi_210 + dwArg08, Mem41[ebp_190 + 200:word32], dwArg0C + (dwArg08 - esi_191), ecx_13);
				return esi_210;
			}
			Eq_4 esi_236;
			Eq_4 ebx_232 = ebp_190->t0048;
			Eq_4 esi_233 = ebp_190->t004C;
			if (ebx_232 <= dwArg08)
				esi_236 = SEQ(SLICE(esi_233, word24, 8), dwArg08 < esi_233);
			else
				esi_236.u0 = 0x00;
			if ((byte) esi_236 != 0x00)
			{
				runtime.cgoCheckBits((word32) dwArg08 + (ebx_232 - dwArg08), ebp_190->t00D0, (word32) dwArg0C + (dwArg08 - ebx_232), ecx_13);
				return esi_236;
			}
			++eax_189;
		}
		uint32 ebx_63 = dwArg08 - g_t81493A8;
		Eq_4 esi_66 = g_t814910C;
		Eq_4 edx_68 = g_t8149108;
		if (ebx_63 >> 0x0D >= esi_66)
			runtime.panicindex(gs);
		else if ((byte) (word32) *((word32) *((word32) edx_68 + (ebx_63 >> 0x0D) * 0x04) + 60) == 0x02)
		{
			fn0808FD8B(0x00, fp - 0x14);
			word32 ebp_427;
			word32 edi_428;
			runtime.systemstack(gs, fp - 0x14, out ebp_427, out edi_428);
			return esi_66;
		}
		else
		{
			byte * edx_110 = g_t81493A0 - (ebx_63 >> 0x04) - 0x01;
			uint32 ebp_111 = ebx_63 >> 0x02 & 0x03;
			Eq_4 ecx_112 = 0x00;
			while (true)
			{
				byte bLoc2C_340 = (byte) dwLoc2C;
				if (ecx_112 >=u ecx_13 + dwArg0C)
					break;
				uint32 edi_131 = (word32) *edx_110 >> (byte) ebp_111;
				if (ecx_112 >= dwArg0C && (edi_131 & 0x01) != 0x00)
				{
					runtime.cgoIsGoPointer(Mem139[dwArg08 + ecx_112:word32]);
					if ((byte) (word32) bLoc2C_340 != 0x00)
					{
						word32 edi_430;
						word32 ebp_429;
						runtime.systemstack(gs, 0x080E7BB0, out ebp_429, out edi_430);
					}
				}
				if (ebp_111 < 0x03)
					++ebp_111;
				else
				{
					--edx_110;
					ebp_111 = 0x00;
				}
				ecx_112 = (word32) ecx_112 + 4;
			}
			return ecx_13;
		}
	}
}

// 0804AF50: void runtime.cgoCheckBits(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.cgoCheckTypedBlock
//      runtime.cgoCheckUsingType
void runtime.cgoCheckBits(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	uint32 eax_10 = dwArg0C >> 0x05 << 0x05;
	uint32 ecx_103 = dwArg0C - eax_10;
	Eq_2580 ebx_13 = (word32) dwArg10 + ecx_103;
	byte * edx_100 = (word32) dwArg08 + (dwArg0C >> 0x05);
	Eq_4 (* eax_18)[] = (word32) dwArg04 + eax_10;
	Eq_2580 ebp_20 = 0x00;
	uint32 esi_21 = 0x00;
	ebx_25 = ebx_13;
	eax_104 = eax_18;
	while (true)
	{
		Eq_4 (* eax_104)[];
		Eq_2580 ebx_25;
		if (ebp_20 >= ebx_25)
			break;
		uint32 esi_35;
		if ((ebp_20 & 0x1F) == 0x00)
		{
			esi_35 = (word32) *edx_100;
			++edx_100;
		}
		else
			esi_35 = esi_21 >> 0x01;
		if (ecx_103 > 0x00)
			ecx_103 += ~0x03;
		else if ((esi_35 & 0x01) != 0x00)
		{
			runtime.cgoIsGoPointer(Mem58[eax_104 + ebp_20:word32]);
			if ((byte) (word32) bLoc18 != 0x00)
			{
				word32 ebp_153;
				word32 edi_154;
				runtime.systemstack(gs, 0x080E7BAC, out ebp_153, out edi_154);
			}
			eax_104 = eax_18;
			ebx_25 = ebx_13;
		}
		esi_21 = esi_35;
		ebp_20 = (word32) ebp_20 + 4;
	}
}

// 0804B000: void runtime.cgoCheckUsingType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.cgoCheckUsingType
//      runtime.cgoCheckTypedBlock.func1
void runtime.cgoCheckUsingType(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	ui32 ecx_19 = (word32) *((word32) dwArg04 + 0x0F);
	Eq_4 eax_159 = dwArg04;
	byte cl_20 = (byte) ecx_19;
	if ((cl_20 & 0x80) != 0x00)
		return;
	Eq_4 edx_26 = *((word32) dwArg04 + 4);
	Eq_4 ebx_136 = dwArg0C;
	if (edx_26 <= dwArg0C)
		return;
	Eq_4 edx_100 = edx_26 - dwArg0C;
	if (dwArg10 <= edx_100)
		edx_100 = dwArg10;
	if ((cl_20 & 0x40) == 0x00)
		runtime.cgoCheckBits(dwArg08, *((word32) dwArg04 + 20), dwArg0C, edx_100);
	else
	{
		byte cl_64 = (byte) (ecx_19 & 0x1F);
		if (cl_64 != 0x11)
		{
			if (cl_64 != 0x19)
				runtime.throw(gs);
			else
			{
				struct Eq_2724 * ecx_143 = (word32) *((word32) dwArg04 + 36) + 4;
				Eq_4 eax_80 = *((word32) dwArg04 + 40);
				Eq_4 ebp_146 = 0x00;
				Eq_4 esi_102 = dwArg08;
				while (ebp_146 < eax_80)
				{
					Eq_4 edi_92 = ecx_143->dw0000;
					if (ebx_136 < *edi_92)
						runtime.cgoCheckUsingType(gs, edi_92, esi_102, ebx_136, edx_100);
					Eq_4 eax_130;
					Eq_4 eax_123 = *edi_92;
					esi_102 += eax_123;
					if (ebx_136 > eax_123)
						eax_130 = eax_123;
					else
						eax_130 = ebx_136;
					Eq_4 edi_134 = eax_123 - eax_130;
					ebx_136 -= eax_130;
					if (edx_100 <= edi_134)
						return;
					++ecx_143;
					ebp_146 = (word32) ebp_146 + 1;
					edx_100 -= edi_134;
				}
			}
		}
		else
		{
			Eq_4 ecx_155 = 0x00;
			Eq_4 ebp_158 = dwArg08;
			while (ecx_155 < *((word32) eax_159 + 40))
			{
				Eq_4 esi_169 = *((word32) eax_159 + 32);
				if (ebx_136 < *esi_169)
				{
					runtime.cgoCheckUsingType(gs, esi_169, ebp_158, ebx_136, edx_100);
					eax_159 = dwArg04;
				}
				Eq_4 esi_204;
				Eq_4 esi_197 = **((word32) eax_159 + 32);
				ebp_158 += esi_197;
				if (ebx_136 > esi_197)
					esi_204 = esi_197;
				else
					esi_204 = ebx_136;
				Eq_4 edi_208 = esi_197 - esi_204;
				ebx_136 -= esi_204;
				if (edx_100 <= edi_208)
					return;
				ecx_155 = (word32) ecx_155 + 1;
				edx_100 -= edi_208;
			}
		}
	}
}

// 0804B1C0: Register Eq_4 runtime.makechan(Register Eq_4 ebp, Register word32 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_2770) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 esiOut)
// Called from:
//      runtime.gcenable
//      runtime.main
Eq_4 runtime.makechan(Eq_4 ebp, word32 edi, struct Eq_2 * gs, struct Eq_2770 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0020;
	Eq_4 edx_19 = *ecx_18;
	if (edx_19 >= 0x00010000)
		runtime.throw(gs);
	else if ((byte) (word32) *((word32) ecx_18 + 0x0D) > 0x08)
		runtime.throw(gs);
	else
	{
		ui24 ebx_24_8_54 = SLICE(ebp, word24, 8);
		ui32 ebx_55 = SEQ(ebx_24_8_54, dwArg0C == 0x00);
		if ((byte) (SEQ(ebx_24_8_54, dwArg0C < 0x00) | SEQ(SLICE(edi, word24, 8), Test(ULT,false)) & ebx_55) != 0x00 || (dwArg0C != 0x00 || edx_19 > 0x00 && dwArg08 > (uint32) (0xFFFFFFC7 /u edx_19)))
			runtime.gopanic(gs);
		else
		{
			ptr32 esi_182;
			Eq_4 eax_236;
			word32 eax_144 = (word32) *((word32) ecx_18 + 0x0F);
			ui24 eax_24_8_153 = SLICE(eax_144, word24, 8);
			if (((byte) eax_144 & 0x80) != 0x00 || (byte) (SEQ(eax_24_8_153, dwArg08 == 0x00) & ebx_55) != 0x00)
			{
				eax_236 = dwLoc14;
				word32 ebx_427;
				word32 edi_229;
				if ((byte) (SEQ(SLICE(dwArg0C, word24, 8), dwArg0C > 0x00) | (word32) (dwArg0C == 0x00) & SEQ(SLICE(runtime.mallocgc(dwArg0C, gs, edx_19 *s dwArg08 + 0x38, 0x00, 0x01, out ebx_427, out esi_182, out edi_229), word24, 8), dwArg08 > 0x00)) != 0x00 && *ecx_18 != 0x00)
				{
					esi_182 = (word32) dwLoc14 + 56;
					if (g_t81576F0 == 0x00)
						*((word32) dwLoc14 + 8) = (word32) dwLoc14 + 56;
					else
					{
						runtime.writebarrierptr((word32) dwLoc14 + 8, (word32) dwLoc14 + 56);
						eax_236 = dwLoc14;
					}
				}
				else if (g_t81576F0 == 0x00)
					*((word32) dwLoc14 + 8) = dwLoc14;
				else
				{
					runtime.writebarrierptr((word32) dwLoc14 + 8, dwLoc14);
					eax_236 = dwLoc14;
				}
			}
			else
			{
				runtime.newobject(gs, 0x080DAD80);
				word32 edi_428;
				esi_182 = runtime.newarray(gs, ecx_18, dwArg08, out edi_428);
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc1C + 8) = dwLoc18;
				else
					runtime.writebarrierptr((word32) dwLoc1C + 8, dwLoc18);
				eax_236 = dwLoc1C;
			}
			*((word32) eax_236 + 0x0C) = *ecx_18;
			Eq_4 ebp_320 = (word32) eax_236 + 20;
			if (g_t81576F0 == 0x00)
				*((word32) eax_236 + 20) = ecx_18;
			else
				runtime.writebarrierptr(ebp_320, ecx_18);
			*((word32) eax_236 + 4) = dwArg08;
			esiOut = esi_182;
			return ebp_320;
		}
	}
}

// 0804B430: Register Eq_4 runtime.chansend1(Register word32 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.bgsweep
Eq_4 runtime.chansend1(word32 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime.getcallerpc();
	return runtime.chansend(ebp, esi, gs, dwArg04, dwArg08, 0x01);
}

// 0804B470: Register Eq_4 runtime.chansend(Register word32 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C)
// Called from:
//      runtime.chansend1
Eq_4 runtime.chansend(word32 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
	{
		if ((byte) (word32) bArg0C == 0x00)
			return esi;
		runtime.gopark(gs);
		runtime.throw(gs);
	}
	else
	{
		if ((byte) (word32) bArg0C == 0x00 && *((word32) dwArg04 + 16) == 0x00)
		{
			Eq_4 edx_65 = *((word32) dwArg04 + 4);
			Eq_3046 CZ_75 = SLICE(cond(edx_65), bool, 2);
			if (edx_65 == 0x00)
			{
				if (*((word32) dwArg04 + 32) == 0x00)
					return esi;
				CZ_75.u0 = SLICE(cond(edx_65), bool, 2);
			}
			if (!CZ_75 && *dwArg04 == edx_65)
				return esi;
		}
		ui64 ebx_edx_1065;
		up32 edx_87 = g_dw8157668;
		up32 ebx_88 = g_dw815766C;
		if ((byte) (SEQ(SLICE(edx_87, word24, 8), edx_87 > 0x00) & SEQ(SLICE(ebp, word24, 8), ebx_88 == 0x00) | SEQ(SLICE(ebx_88, word24, 8), ebx_88 > 0x00)) == 0x00)
			ebx_edx_1065 = 0x00;
		else
		{
			runtime.cputicks();
			ebx_edx_1065 = SEQ(dwLoc48, dwLoc4C);
		}
		word32 ebp_161;
		Eq_4 esi_163;
		word32 edi_1079;
		runtime.lock(esi, gs, (word32) dwArg04 + 48, out ebp_161, out esi_163, out edi_1079);
		word32 ebx_142 = SLICE(ebx_edx_1065, word32, 32);
		word32 edx_139 = (word32) ebx_edx_1065;
		if (*((word32) dwArg04 + 16) != 0x00)
		{
			word32 edx_1074;
			word32 ebx_1075;
			runtime.unlock(gs, (word32) dwArg04 + 48, out edx_1074, out ebx_1075);
			runtime.gopanic(gs);
		}
		else
		{
			runtime.(*waitq).dequeue(gs, (word32) dwArg04 + 32);
			if (dwLoc48 != 0x00)
				return runtime.send(gs, dwArg04, dwLoc48, dwArg08, fp - 0x08, 0x03);
			if (*dwArg04 < *((word32) dwArg04 + 4))
			{
				Eq_4 esi_263;
				word32 edi_1076;
				runtime.typedmemmove(*((word32) dwArg04 + 20), (word32) *((word32) dwArg04 + 8) + *((word32) dwArg04 + 24) *s (word32) (*((word32) dwArg04 + 0x0C)), dwArg08, out esi_263, out edi_1076);
				Eq_4 ecx_270 = *((word32) dwArg04 + 24);
				*((word32) dwArg04 + 24) = (word32) ecx_270 + 1;
				if ((word32) ecx_270 + 1 == *((word32) dwArg04 + 4))
					((word32) dwArg04 + 24)->u0 = 0x00;
				*dwArg04 = (word32) *dwArg04 + 1;
				word32 ebx_1081;
				word32 edx_1080;
				runtime.unlock(gs, (word32) dwArg04 + 48, out edx_1080, out ebx_1081);
				return esi_263;
			}
			else if ((byte) (word32) bArg0C != 0x00)
			{
				Eq_4 eax_305 = gs->ptr0000->tFFFFFFFC;
				ui24 edx_24_8_337 = SLICE(runtime.acquireSudog(gs), word24, 8);
				((word32) dwArg04 + 60)->u0 = 0x00;
				*((word32) dwArg04 + 64) = 0x00;
				if ((byte) (SEQ(SLICE(ebp_161, word24, 8), ebx_142 != 0x00) | SEQ(edx_24_8_337, edx_139 != 0x00)) != 0x00)
				{
					((word32) dwArg04 + 60)->u0 = ~0x00;
					*((word32) dwArg04 + 64) = ~0x00;
				}
				if (g_t81576F0 == 0x00)
				{
					*((word32) dwArg04 + 48) = dwArg08;
					*((word32) dwArg04 + 76) = 0x00;
					*((word32) dwArg04 + 32) = eax_305;
					((word32) dwArg04 + 36)->u0 = 0x00;
					*((word32) dwArg04 + 84) = dwArg04;
				}
				else
				{
					runtime.writebarrierptr((word32) dwArg04 + 48, dwArg08);
					runtime.writebarrierptr((word32) dwArg04 + 76, 0x00);
					runtime.writebarrierptr((word32) dwArg04 + 32, eax_305);
					runtime.writebarrierptr((word32) dwArg04 + 36, 0x00);
					runtime.writebarrierptr((word32) dwArg04 + 84, dwArg04);
				}
				if (g_t81576F0 == 0x00)
				{
					*((word32) eax_305 + 0x00B4) = (word32) dwArg04 + 32;
					((word32) eax_305 + 0x0044)->u0 = 0x00;
					((word32) dwArg04 + 40)->u0 = 0x00;
				}
				else
				{
					runtime.writebarrierptr((word32) eax_305 + 0x00B4, (word32) dwArg04 + 32);
					runtime.writebarrierptr((word32) eax_305 + 0x0044, 0x00);
					runtime.writebarrierptr((word32) dwArg04 + 40, 0x00);
				}
				ui24 ebx_24_8_734;
				Eq_4 ecx_506 = *((word32) dwArg04 + 44);
				if (ecx_506 != 0x00)
				{
					ebx_24_8_734 = SLICE((word32) dwArg04 + 44, word24, 8);
					ebx_24_8_734 = SLICE((word32) dwArg04 + 44, word24, 8);
					if (g_t81576F0 == 0x00)
					{
						*((word32) dwArg04 + 44) = ecx_506;
						*((word32) ecx_506 + 8) = (word32) dwArg04 + 32;
						*((word32) dwArg04 + 44) = (word32) dwArg04 + 32;
					}
					else
					{
						runtime.writebarrierptr((word32) dwArg04 + 44, ecx_506);
						runtime.writebarrierptr((word32) ecx_506 + 8, (word32) dwArg04 + 32);
						runtime.writebarrierptr((word32) dwArg04 + 44, (word32) dwArg04 + 32);
					}
				}
				else
				{
					ebx_24_8_734 = SLICE((word32) dwArg04 + 40, word24, 8);
					ebx_24_8_734 = SLICE((word32) dwArg04 + 40, word24, 8);
					if (g_t81576F0 == 0x00)
					{
						((word32) dwArg04 + 44)->u0 = 0x00;
						*((word32) dwArg04 + 40) = (word32) dwArg04 + 32;
						*((word32) dwArg04 + 44) = (word32) dwArg04 + 32;
					}
					else
					{
						runtime.writebarrierptr((word32) dwArg04 + 44, 0x00);
						runtime.writebarrierptr((word32) dwArg04 + 40, (word32) dwArg04 + 32);
						runtime.writebarrierptr((word32) dwArg04 + 44, (word32) dwArg04 + 32);
					}
				}
				runtime.goparkunlock(gs);
				if ((word32) dwArg04 + 32 != *((word32) eax_305 + 0x00B4))
					runtime.throw(gs);
				else
				{
					if (g_t81576F0 == 0x00)
						*((word32) eax_305 + 0x00B4) = null;
					else
						runtime.writebarrierptr((word32) eax_305 + 0x00B4, 0x00);
					if (*((word32) eax_305 + 0x0044) == 0x00)
					{
						if (*((word32) dwArg04 + 16) == 0x00)
							runtime.throw(gs);
						else
							runtime.gopanic(gs);
					}
					else
					{
						if (g_t81576F0 == 0x00)
							((word32) eax_305 + 0x0044)->u0 = 0x00;
						else
							runtime.writebarrierptr((word32) eax_305 + 0x0044, 0x00);
						int32 ecx_722 = *((word32) dwArg04 + 64);
						Eq_4 eax_721 = *((word32) dwArg04 + 60);
						ui32 ebx_755 = SEQ(ebx_24_8_734, ecx_722 > 0x00) | SEQ(SLICE(dwArg04, word24, 8), eax_721 > 0x00) & SEQ(ebx_24_8_734, ecx_722 == 0x00);
						Eq_3405 ebx_24_8_771 = SLICE(ebx_755, word24, 8);
						if ((byte) ebx_755 != 0x00)
						{
							ui64 ecx_eax_844 = SEQ(ecx_722, eax_721) - ebx_edx_1065;
							runtime.blockevent(ebx_24_8_771, gs, (word32) ecx_eax_844, SLICE(ecx_eax_844, word32, 32));
						}
						if (g_t81576F0 == 0x00)
							((word32) dwArg04 + 84)->u0 = 0x00;
						else
							runtime.writebarrierptr((word32) dwArg04 + 84, 0x00);
						word32 edi_1082;
						Eq_4 esi_813;
						runtime.releaseSudog(gs, (word32) dwArg04 + 32, out esi_813, out edi_1082);
						return esi_813;
					}
				}
			}
			else
			{
				word32 edx_1077;
				word32 ebx_1078;
				runtime.unlock(gs, (word32) dwArg04 + 48, out edx_1077, out ebx_1078);
				return esi_163;
			}
		}
	}
}

// 0804BAD0: Register word32 runtime.send(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 (ptr32 code)) dwArg10, Stack word32 dwArg14)
// Called from:
//      runtime.chansend
word32 runtime.send(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, <anonymous> ** dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg08 + 16) != 0x00)
	{
		Eq_4 ecx_25 = *((word32) dwArg04 + 20);
		esi = runtime.sendDirect(gs, ecx_25, dwArg08, dwArg0C);
		dwLoc14 = ecx_25;
		dwLoc10 = dwArg08;
		if (g_t81576F0 == 0x00)
			((word32) dwArg08 + 16)->u0 = 0x00;
		else
		{
			runtime.writebarrierptr((word32) dwArg08 + 16, 0x00);
			dwLoc14 = (word32) dwArg08 + 16;
			dwLoc10.u0 = 0x00;
		}
	}
	Eq_4 ecx_61 = *dwArg08;
	(*dwArg10)();
	if (g_t81576F0 == 0x00)
		*((word32) ecx_61 + 0x0044) = dwArg08;
	else
	{
		runtime.writebarrierptr((word32) ecx_61 + 0x0044, dwArg08);
		dwLoc14 = (word32) ecx_61 + 0x0044;
		dwLoc10 = dwArg08;
	}
	Eq_4 edx_97 = *((word32) dwArg08 + 28);
	Eq_4 ebx_98 = *((word32) dwArg08 + 32);
	if ((byte) (SEQ(SLICE(ebx_98, word24, 8), ebx_98 != 0x00) | SEQ(SLICE(edx_97, word24, 8), edx_97 != 0x00)) != 0x00)
	{
		runtime.cputicks();
		*((word32) dwArg08 + 28) = dwLoc14;
		*((word32) dwArg08 + 32) = dwLoc10;
	}
	runtime.goready(gs);
	return esi;
}

// 0804BBF0: Register word32 runtime.sendDirect(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.send
word32 runtime.sendDirect(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) dwArg08 + 16);
	runtime.typeBitsBulkBarrier(dwArg0C, gs, dwArg04, dwArg0C, *dwArg04);
	word32 esi_48;
	word32 ebp_80;
	word32 edi_81;
	runtime.memmove(eax_19, dwArg0C, *dwArg04, out ebp_80, out esi_48, out edi_81);
	return esi_48;
}

// 0804BC60: Register word32 runtime.recvDirect(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ediOut)
// Called from:
//      runtime.recv
word32 runtime.recvDirect(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) dwArg08 + 16);
	runtime.typeBitsBulkBarrier(eax_19, gs, dwArg04, eax_19, *dwArg04);
	ptr32 edi_47;
	word32 ebp_51;
	word32 esi_81;
	runtime.memmove(dwArg0C, eax_19, *dwArg04, out ebp_51, out esi_81, out edi_47);
	ediOut = edi_47;
	return ebp_51;
}

// 0804BCD0: void runtime.closechan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.main
void runtime.closechan(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.gopanic(gs);
	else
	{
		word32 edi_47;
		word32 ebp_463;
		word32 esi_464;
		runtime.lock(esi, gs, (word32) dwArg04 + 48, out ebp_463, out esi_464, out edi_47);
		if (*((word32) dwArg04 + 16) != 0x00)
		{
			word32 edx_465;
			word32 ebx_466;
			runtime.unlock(gs, (word32) dwArg04 + 48, out edx_465, out ebx_466);
			runtime.gopanic(gs);
		}
		else
		{
			((word32) dwArg04 + 16)->u0 = 0x01;
			Eq_4 eax_352 = 0x00;
			while (true)
			{
				runtime.(*waitq).dequeue(gs, (word32) dwArg04 + 32);
				Eq_4 dwLoc28_379 = (word32) dwArg04 + 32;
				if (dwLoc24 == 0x00)
					break;
				Eq_4 ecx_259 = *((word32) dwLoc24 + 16);
				if (ecx_259 != 0x00)
				{
					Eq_4 eax_266 = *((word32) dwArg04 + 20);
					runtime.typedmemclr(eax_266, ecx_259);
					Eq_4 dwLoc04_402 = (word32) dwLoc24 + 16;
					dwLoc24 = ecx_259;
					dwLoc28_379 = eax_266;
					if (g_t81576F0 == 0x00)
						((byte) dwLoc24.u0 + 16)->u0 = 0x00;
					else
					{
						runtime.writebarrierptr(dwLoc04_402, 0x00);
						dwLoc28_379 = dwLoc04_402;
						dwLoc24.u0 = 0x00;
					}
				}
				Eq_4 ecx_298 = *((word32) dwLoc24 + 28);
				Eq_4 edx_299 = *((word32) dwLoc24 + 32);
				if ((byte) (SEQ(SLICE(ecx_298, word24, 8), ecx_298 != 0x00) | SEQ(SLICE(edx_299, word24, 8), edx_299 != 0x00)) != 0x00)
				{
					runtime.cputicks();
					*((word32) dwLoc24 + 28) = dwLoc28_379;
					*((word32) dwLoc24 + 32) = dwLoc24;
				}
				Eq_4 eax_330 = *dwLoc24;
				if (g_t81576F0 == 0x00)
					((word32) eax_330 + 0x0044)->u0 = 0x00;
				else
				{
					runtime.writebarrierptr((word32) eax_330 + 0x0044, 0x00);
					dwLoc24.u0 = 0x00;
				}
				*((word32) eax_330 + 0x0068) = eax_352;
				eax_352 = eax_330;
			}
			Eq_4 eax_113 = eax_352;
			while (true)
			{
				runtime.(*waitq).dequeue(gs, (word32) dwArg04 + 40);
				Eq_4 dwLoc28_383 = (word32) dwArg04 + 40;
				if (dwLoc24 == 0x00)
					break;
				if (g_t81576F0 == 0x00)
					((byte) dwLoc24.u0 + 16)->u0 = 0x00;
				else
				{
					dwLoc28_383 = (byte) dwLoc24.u0 + 16;
					runtime.writebarrierptr(dwLoc28_383, 0x00);
					dwLoc24.u0 = 0x00;
				}
				Eq_4 ecx_195 = *((byte) dwLoc24.u0 + 32);
				Eq_4 edx_196 = *((byte) dwLoc24.u0 + 28);
				if ((byte) (SEQ(SLICE(edx_196, word24, 8), edx_196 != 0x00) | SEQ(SLICE(ecx_195, word24, 8), ecx_195 != 0x00)) != 0x00)
				{
					runtime.cputicks();
					*((byte) dwLoc24.u0 + 28) = dwLoc28_383;
					*((byte) dwLoc24.u0 + 32) = dwLoc24;
				}
				Eq_4 eax_227 = *dwLoc24.u0;
				if (g_t81576F0 == 0x00)
					((word32) eax_227 + 0x0044)->u0 = 0x00;
				else
				{
					runtime.writebarrierptr((word32) eax_227 + 0x0044, 0x00);
					dwLoc24.u0 = 0x00;
				}
				*((word32) eax_227 + 0x0068) = eax_113;
				eax_113 = eax_227;
			}
			word32 ebx_468;
			word32 edx_467;
			runtime.unlock(gs, (word32) dwArg04 + 48, out edx_467, out ebx_468);
			Eq_4 eax_152 = eax_113;
			while (eax_152 != 0x00)
			{
				Eq_4 ecx_158 = *((word32) eax_152 + 0x0068);
				((word32) eax_152 + 0x0068)->u0 = 0x00;
				runtime.goready(gs);
				eax_152 = ecx_158;
			}
		}
	}
}

// 0804BF60: Register Eq_4 runtime.chanrecv1(Register Eq_4 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 ediOut)
// Called from:
//      runtime.cgocallbackg1
//      runtime.gcenable
Eq_4 runtime.chanrecv1(Eq_4 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & ediOut)
{
	ptr32 edi_22;
	Eq_4 ebp_20 = runtime.chanrecv(ebp, esi, gs, dwArg04, dwArg08, 0x01, out edi_22);
	ediOut = edi_22;
	return ebp_20;
}

// 0804BF80: Register Eq_4 runtime.chanrecv(Register Eq_4 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C, Register out ptr32 ediOut)
// Called from:
//      runtime.chanrecv1
Eq_4 runtime.chanrecv(Eq_4 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_102 = dwArg04;
	if (dwArg04 == 0x00)
	{
		if ((byte) (word32) bArg0C != 0x00)
		{
			runtime.gopark(gs);
			runtime.throw(gs);
		}
		else
		{
			ediOut = edi;
			return ebp;
		}
	}
	if ((byte) (word32) bArg0C != 0x00)
	{
l0804BFB2:
		Eq_4 ebx_159;
		Eq_4 edx_158;
		up32 edx_106 = g_dw8157668;
		up32 ebx_107 = g_dw815766C;
		Eq_4 eax_149 = eax_102;
		if ((byte) (SEQ(SLICE(ebp, word24, 8), ebx_107 == 0x00) & SEQ(SLICE(edx_106, word24, 8), edx_106 > 0x00) | SEQ(SLICE(edx_106, word24, 8), ebx_107 > 0x00)) == 0x00)
		{
			edx_158.u0 = 0x00;
			ebx_159.u0 = 0x00;
		}
		else
		{
			runtime.cputicks();
			edx_158 = dwLoc54;
			ebx_159 = dwLoc50;
			eax_149 = dwArg04;
		}
		Eq_4 ecx_171 = (word32) eax_149 + 48;
		word32 esi_1152;
		Eq_4 ebp_188;
		ptr32 edi_189;
		runtime.lock(esi, gs, ecx_171, out ebp_188, out esi_1152, out edi_189);
		if (*((word32) dwArg04 + 16) == 0x00 || *dwArg04 != 0x00)
		{
			runtime.(*waitq).dequeue(gs, (word32) dwArg04 + 40);
			if (dwLoc50 != 0x00)
			{
				ptr32 edi_270;
				Eq_4 ebp_267 = runtime.recv(gs, dwArg04, dwLoc50, dwArg08, fp - 0x08, 0x03, out edi_270);
				ediOut = edi_270;
				return ebp_267;
			}
			else if (*dwArg04 <= 0x00)
			{
				if ((byte) (word32) bArg0C != 0x00)
				{
					Eq_4 eax_294 = gs->ptr0000->tFFFFFFFC;
					ui24 edx_24_8_327 = SLICE(runtime.acquireSudog(gs), word24, 8);
					((word32) dwArg04 + 0x0044)->u0 = 0x00;
					*((word32) dwArg04 + 72) = 0x00;
					if ((byte) (SEQ(SLICE(ebp_188, word24, 8), ebx_159 != 0x00) | SEQ(edx_24_8_327, edx_158 != 0x00)) != 0x00)
					{
						((word32) dwArg04 + 0x0044)->u0 = ~0x00;
						*((word32) dwArg04 + 72) = ~0x00;
					}
					if (g_t81576F0 == 0x00)
					{
						*((word32) dwArg04 + 56) = dwArg08;
						((word32) dwArg04 + 84)->u0 = 0x00;
					}
					else
					{
						runtime.writebarrierptr((word32) dwArg04 + 56, dwArg08);
						runtime.writebarrierptr((word32) dwArg04 + 84, 0x00);
					}
					if (g_t81576F0 == 0x00)
					{
						*((word32) eax_294 + 0x00B4) = (word32) dwArg04 + 40;
						*((word32) dwArg04 + 40) = eax_294;
						((word32) dwArg04 + 44)->u0 = 0x00;
						*((word32) dwArg04 + 92) = dwArg04;
						((word32) eax_294 + 0x0044)->u0 = 0x00;
						((word32) dwArg04 + 48)->u0 = 0x00;
					}
					else
					{
						runtime.writebarrierptr((word32) eax_294 + 0x00B4, (word32) dwArg04 + 40);
						runtime.writebarrierptr((word32) dwArg04 + 40, eax_294);
						runtime.writebarrierptr((word32) dwArg04 + 44, 0x00);
						runtime.writebarrierptr((word32) dwArg04 + 92, dwArg04);
						runtime.writebarrierptr((word32) eax_294 + 0x0044, 0x00);
						runtime.writebarrierptr((word32) dwArg04 + 48, 0x00);
					}
					ptr32 * esi_546 = (word32) eax_294 + 0x00B4;
					Eq_4 edi_492 = *((word32) dwArg04 + 36);
					if (edi_492 != 0x00)
					{
						esi_546 = (word32) edi_492 + 8;
						if (g_t81576F0 == 0x00)
						{
							*((word32) dwArg04 + 52) = edi_492;
							*((word32) edi_492 + 8) = (word32) dwArg04 + 40;
							*((word32) dwArg04 + 36) = (word32) dwArg04 + 40;
						}
						else
						{
							runtime.writebarrierptr((word32) dwArg04 + 52, edi_492);
							runtime.writebarrierptr((word32) edi_492 + 8, (word32) dwArg04 + 40);
							runtime.writebarrierptr((word32) dwArg04 + 36, (word32) dwArg04 + 40);
						}
					}
					else if (g_t81576F0 == 0x00)
					{
						((word32) dwArg04 + 52)->u0 = 0x00;
						*((word32) dwArg04 + 32) = (word32) dwArg04 + 40;
						*((word32) dwArg04 + 36) = (word32) dwArg04 + 40;
					}
					else
					{
						runtime.writebarrierptr((word32) dwArg04 + 52, 0x00);
						runtime.writebarrierptr((word32) dwArg04 + 32, (word32) dwArg04 + 40);
						runtime.writebarrierptr((word32) dwArg04 + 36, (word32) dwArg04 + 40);
						esi_546 = (word32) eax_294 + 0x00B4;
					}
					runtime.goparkunlock(gs);
					if ((word32) dwArg04 + 40 != *((word32) eax_294 + 0x00B4))
						runtime.throw(gs);
					else
					{
						if (g_t81576F0 == 0x00)
							*((word32) eax_294 + 0x00B4) = null;
						else
							runtime.writebarrierptr((word32) eax_294 + 0x00B4, 0x00);
						Eq_4 ecx_649 = *((word32) dwArg04 + 0x0044);
						ui24 ebx_24_8_662 = SLICE(dwArg04, word24, 8);
						int32 ebx_650 = *((word32) dwArg04 + 72);
						if ((byte) (SEQ(ebx_24_8_662, ebx_650 > 0x00) | SEQ(SLICE(esi_546, word24, 8), ebx_650 == 0x00) & SEQ(ebx_24_8_662, ecx_649 > 0x00)) != 0x00)
						{
							ui64 ebx_ecx_881 = SEQ(ebx_650, ecx_649) - SEQ(ebx_159, edx_158);
							Eq_3408 ebx_710 = SLICE(ebx_ecx_881, word32, 32);
							runtime.blockevent(SLICE(ebx_710, word24, 8), gs, (word32) ebx_ecx_881, ebx_710);
						}
						if (g_t81576F0 == 0x00)
						{
							((word32) eax_294 + 0x0044)->u0 = 0x00;
							((word32) dwArg04 + 92)->u0 = 0x00;
						}
						else
						{
							runtime.writebarrierptr((word32) eax_294 + 0x0044, 0x00);
							runtime.writebarrierptr((word32) dwArg04 + 92, 0x00);
						}
						ptr32 edi_770;
						word32 esi_1153;
						Eq_4 ebp_767 = runtime.releaseSudog(gs, (word32) dwArg04 + 40, out esi_1153, out edi_770);
						ediOut = edi_770;
						return ebp_767;
					}
				}
				else
				{
					word32 edx_1150;
					word32 ebx_1151;
					runtime.unlock(gs, ecx_171, out edx_1150, out ebx_1151);
					ediOut = edi_189;
					return ebp_188;
				}
			}
			else
			{
				Eq_4 ecx_805 = (word32) *((word32) dwArg04 + 8) + *((word32) dwArg04 + 28) *s (word32) (*((word32) dwArg04 + 0x0C));
				if (dwArg08 != 0x00)
				{
					word32 esi_821;
					word32 edi_1147;
					ebp_188 = runtime.typedmemmove(*((word32) dwArg04 + 20), dwArg08, ecx_805, out esi_821, out edi_1147);
				}
				ptr32 edi_839 = runtime.typedmemclr(*((word32) dwArg04 + 20), ecx_805);
				Eq_4 ecx_846 = *((word32) dwArg04 + 28);
				*((word32) dwArg04 + 28) = (word32) ecx_846 + 1;
				if ((word32) ecx_846 + 1 == *((word32) dwArg04 + 4))
					((word32) dwArg04 + 28)->u0 = 0x00;
				--*dwArg04;
				word32 edx_1148;
				word32 ebx_1149;
				runtime.unlock(gs, ecx_171, out edx_1148, out ebx_1149);
				ediOut = edi_839;
				return ebp_188;
			}
		}
		else
		{
			word32 ebx_207;
			word32 edx_209;
			runtime.unlock(gs, ecx_171, out edx_209, out ebx_207);
			if (dwArg08 != 0x00)
				edi_189 = runtime.typedmemclr(*((word32) dwArg04 + 20), dwArg08);
			ediOut = edi_189;
			return ebp_188;
		}
	}
	Eq_4 edx_62 = *((word32) dwArg04 + 4);
	Eq_3965 CZ_72 = SLICE(cond(edx_62), bool, 2);
	if (edx_62 == 0x00)
	{
		if (*((word32) dwArg04 + 40) == 0x00)
			goto l0804C54A;
		CZ_72.u0 = SLICE(cond(edx_62), bool, 2);
	}
	if (CZ_72)
		goto l0804BFB2;
	runtime/internal/atomic.Loaduint();
	dwLoc54 = dwArg04;
	if (dwLoc50 != 0x00)
	{
		eax_102 = dwArg04;
		goto l0804BFB2;
	}
l0804C54A:
	runtime/internal/atomic.Load();
	dwLoc54 = (word32) dwArg04 + 16;
	if (dwLoc4C == 0x00)
	{
		ediOut = edi;
		return ebp;
	}
	eax_102 = dwArg08;
	goto l0804BFB2;
}

// 0804C610: Register Eq_4 runtime.recv(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 (ptr32 code)) dwArg10, Stack word32 dwArg14, Register out ptr32 ediOut)
// Called from:
//      runtime.chanrecv
Eq_4 runtime.recv(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, <anonymous> ** dwArg10, word32 dwArg14, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 4) == 0x00)
	{
		if (dwArg0C != 0x00)
		{
			Eq_4 eax_88 = *((word32) dwArg04 + 20);
			dwLoc14 = eax_88;
			dwLoc10 = dwArg08;
			ebp = runtime.recvDirect(gs, eax_88, dwArg08, dwArg0C, out edi);
		}
	}
	else
	{
		Eq_4 ecx_26 = (word32) *((word32) dwArg04 + 8) + *((word32) dwArg04 + 28) *s (word32) (*((word32) dwArg04 + 0x0C));
		if (dwArg0C != 0x00)
		{
			word32 esi_313;
			word32 edi_314;
			runtime.typedmemmove(*((word32) dwArg04 + 20), dwArg0C, ecx_26, out esi_313, out edi_314);
		}
		Eq_4 edx_52 = *((word32) dwArg04 + 20);
		word32 esi_315;
		ebp = runtime.typedmemmove(edx_52, ecx_26, *((word32) dwArg08 + 16), out esi_315, out edi);
		Eq_4 ecx_73 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 28) = (word32) ecx_73 + 1;
		dwLoc14 = edx_52;
		dwLoc10 = ecx_26;
		if ((word32) ecx_73 + 1 == *((word32) dwArg04 + 4))
			((word32) dwArg04 + 28)->u0 = 0x00;
		*((word32) dwArg04 + 24) = *((word32) dwArg04 + 28);
	}
	if (g_t81576F0 == 0x00)
		((word32) dwArg08 + 16)->u0 = 0x00;
	else
	{
		runtime.writebarrierptr((word32) dwArg08 + 16, 0x00);
		dwLoc14 = (word32) dwArg08 + 16;
		dwLoc10.u0 = 0x00;
	}
	struct Eq_4484 * ecx_129 = *dwArg08;
	(*dwArg10)();
	if (g_t81576F0 == 0x00)
		ecx_129->t0044 = dwArg08;
	else
	{
		runtime.writebarrierptr(&ecx_129->t0044, dwArg08);
		dwLoc14 = &ecx_129->t0044;
		dwLoc10 = dwArg08;
	}
	Eq_4 edx_167 = *((word32) dwArg08 + 32);
	Eq_4 ebx_168 = *((word32) dwArg08 + 28);
	if ((byte) (SEQ(SLICE(edx_167, word24, 8), edx_167 != 0x00) | SEQ(SLICE(ebx_168, word24, 8), ebx_168 != 0x00)) != 0x00)
	{
		runtime.cputicks();
		*((word32) dwArg08 + 28) = dwLoc14;
		*((word32) dwArg08 + 32) = dwLoc10;
	}
	runtime.goready(gs);
	ediOut = edi;
	return ebp;
}

// 0804C7A0: void reflect.chanlen(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.Len
void reflect.chanlen(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		;
}

// 0804C7E0: void runtime.(*waitq).dequeue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.chansend
//      runtime.closechan
//      runtime.chanrecv
void runtime.(*waitq).dequeue(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		Eq_4 ecx_21 = *dwArg04;
		if (ecx_21 == 0x00)
			return;
		Eq_4 edx_29 = *((word32) ecx_21 + 8);
		if (edx_29 != 0x00)
		{
			if (g_t81576F0 == 0x00)
			{
				((word32) edx_29 + 0x0C)->u0 = 0x00;
				*dwArg04 = edx_29;
				((word32) ecx_21 + 8)->u0 = 0x00;
			}
			else
			{
				runtime.writebarrierptr((word32) edx_29 + 0x0C, 0x00);
				runtime.writebarrierptr(dwArg04, edx_29);
				runtime.writebarrierptr((word32) ecx_21 + 8, 0x00);
			}
		}
		else if (g_t81576F0 == 0x00)
		{
			dwArg04->u0 = 0x00;
			((word32) dwArg04 + 4)->u0 = 0x00;
		}
		else
		{
			runtime.writebarrierptr(dwArg04, 0x00);
			runtime.writebarrierptr((word32) dwArg04 + 4, 0x00);
		}
		Eq_4 edx_112 = *((word32) ecx_21 + 4);
		if (edx_112 == 0x00)
			return;
		if (*edx_112 != 0x00)
			continue;
		runtime/internal/atomic.Cas(edx_112, 0x00, 0x01);
	} while ((byte) (word32) bLoc10 == 0x00);
}

// 0804C930: void runtime.(*cpuProfile).add(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4685) dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 word32) dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sigprof
void runtime.(*cpuProfile).add(struct Eq_2 * gs, struct Eq_4685 * dwArg04, Eq_4 dwArg08, word32 * dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	while (true)
	{
		struct Eq_4685 * dwLoc30_147 = &g_t8157698;
		Eq_4703 ebx_24_8_51 = SLICE(runtime/internal/atomic.Cas(135624344, 0x00, 0x01), word24, 8);
		if ((byte) (word32) bLoc24 != 0x00)
			break;
		runtime.osyield();
	}
	if (g_dw815769C == 0x00)
	{
l0804CA20:
		runtime/internal/atomic.Store(135624344, 0x00);
		return;
	}
	if (dwArg04->t0FAC <= 0x00)
	{
		up32 ecx_41 = dwArg04->dw0FB4;
		up32 edx_42 = dwArg04->dw0FB0;
		ui32 ebx_55 = SEQ(ebx_24_8_51, ecx_41 == 0x00) & SEQ(SLICE(edx_42, word24, 8), edx_42 > 0x00);
		ebx_24_8_51 = SLICE(ebx_55, word24, 8);
		if ((byte) (SEQ(SLICE(ecx_41, word24, 8), ecx_41 > 0x00) | ebx_55) == 0x00)
			goto l0804C99F;
	}
	runtime.(*cpuProfile).addExtra(ebx_24_8_51, gs, dwArg04);
	dwLoc30_147 = dwArg04;
l0804C99F:
	runtime.nanotime();
	runtime.(*profBuf).write(gs, g_t8145928, (word32) dwArg08 + 0x00C4, (uint64) (uint32) dwLoc30_147, fp - 0x08, 0x01, dwArg0C, dwArg10);
	goto l0804CA20;
}

// 0804CA70: void runtime.(*cpuProfile).addNonGo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4788 dwArg0C)
// Called from:
//      runtime.sigprofNonGoPC
void runtime.(*cpuProfile).addNonGo(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4788 dwArg0C)
{
	while (true)
	{
		runtime/internal/atomic.Cas(135624344, 0x00, 0x01);
		if ((byte) (word32) bLoc04 != 0x00)
			break;
		runtime.osyield();
	}
	uint32 eax_21 = g_dw81468CC;
	Eq_4788 ecx_22 = dwArg0C;
	if ((word32) dwArg0C.u0 + 1 + eax_21 < 1000)
	{
		if (eax_21 >= 1000)
			runtime.panicindex(gs);
		g_a814592C[eax_21 * 0x04] = (word32) dwArg0C.u0 + 1;
		if (eax_21 > 999)
			runtime.panicslice(gs);
		Eq_4788 eax_48 = -(eax_21 + ~0x03E6);
		ui32 edx_53 = eax_21 + 0x01 << 0x02 & -eax_48 >> 0x1F;
		if (eax_48 <= dwArg0C)
			ecx_22 = eax_48;
		word32 edi_68;
		word32 esi_69;
		word32 ebp_72;
		runtime.memmove(edx_53 + 135551276, dwArg08, ecx_22 << 0x02, out ebp_72, out esi_69, out edi_68);
		g_dw81468CC = (word32) dwArg0C.u0 + (g_dw81468CC + 0x01);
	}
	else
	{
		up32 eax_26 = g_dw81468D0;
		word32 ecx_29 = g_dw81468D4;
		g_dw81468D0 = eax_26 + 0x01;
		g_dw81468D4 = (word32) ((bool) (eax_26 < 0x01) + ecx_29);
	}
	runtime/internal/atomic.Store(135624344, 0x00);
}

// 0804CB80: void runtime.(*cpuProfile).addExtra(Register Eq_4703 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4685) dwArg04)
// Called from:
//      runtime.(*cpuProfile).add
void runtime.(*cpuProfile).addExtra(Eq_4703 ebx, struct Eq_2 * gs, struct Eq_4685 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4728 eax_192;
	for (eax_192 = 0x00; eax_192 < dwArg04->t0FAC; eax_192 += (dwArg04 + 0x0C)[eax_192 * 0x04])
	{
		if (eax_192 >= 1000)
			runtime.panicindex(gs);
		Eq_4929 edx_132 = (word32) eax_192 + 1;
		word32 ebx_134 = (dwArg04 + 0x0C)[eax_192 * 0x04] + eax_192;
		if (edx_132 > ebx_134 || ebx_134 > 1000)
			runtime.panicslice(gs);
		ebx_24_8 = SLICE(runtime.(*profBuf).write(gs, dwArg04->t0008, null, 0x00, fp - 0x18, 0x01, dwArg04->a000C + (edx_132 << 0x02 & eax_192 - 999 >> 0x1F) / 4, ebx_134 - edx_132), word24, 8);
	}
	dwArg04->t0FAC.u0 = 0x00;
	up32 eax_32 = dwArg04->dw0FB0;
	up32 edx_33 = dwArg04->dw0FB4;
	if ((byte) (SEQ(SLICE(eax_32, word24, 8), edx_33 > 0x00) | SEQ(ebx_24_8, edx_33 == 0x00) & SEQ(SLICE(eax_32, word24, 8), eax_32 > 0x00)) != 0x00)
	{
		runtime.(*profBuf).write(gs, g_t8145928, null, 0x00, fp - 0x20, 0x01, fp - 0x28, 0x02);
		dwArg04->dw0FB0 = 0x00;
		dwArg04->dw0FB4 = 0x00;
	}
}

// 0804CDC0: void runtime.GOMAXPROCS(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Pool).pinSlow
void runtime.GOMAXPROCS(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = dwArg04;
	if (dwArg04 > 0x0400)
		eax_17.u0 = 0x0400;
	word32 esi_139;
	word32 edi_140;
	word32 ebp_138;
	runtime.lock(esi, gs, 135549936, out ebp_138, out esi_139, out edi_140);
	Eq_4 eax_41 = g_t81575F0;
	word32 ebx_142;
	word32 edx_141;
	runtime.unlock(gs, 135549936, out edx_141, out ebx_142);
	if (eax_17 <= 0x00 || eax_17 == eax_41)
		return;
	runtime.stopTheWorld(gs, 135141561, 0x0A);
	g_t8157614 = eax_17;
	runtime.startTheWorld(gs);
}

// 0804CE70: Register Eq_4 runtime.gogetenv(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.GOROOT
//      runtime.readgogc
//      runtime.schedinit
//      runtime.parsedebugvars
Eq_4 runtime.gogetenv(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t814512C;
	Eq_4 ecx_107 = g_t8145128;
	if (ecx_107 == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 edx_110 = 0x00;
		eax_102 = eax_17;
		while (true)
		{
			Eq_4 eax_102;
			if (edx_110 >= eax_102)
				break;
			Eq_4 ebx_46 = *((word32) ecx_107 + 4);
			Eq_4 ebp_47 = *ecx_107;
			if (ebx_46 > dwArg08 && SLICE((word32) Mem45[ebp_47 + dwArg08:byte], byte, 0) == 0x3D)
			{
				Eq_4 esi_71;
				word32 edi_187;
				runtime.eqstring(ebp_47, dwArg08, dwArg04, out esi_71, out edi_187);
				if ((byte) (word32) bLoc18 != 0x00)
				{
					if ((word32) dwArg08 + 1 > ebx_46)
						runtime.panicslice(gs);
					else
						return esi_71;
				}
				eax_102 = eax_17;
			}
			esi = dwArg08;
			ecx_107 = (word32) ecx_107 + 8;
			edx_110 = (word32) edx_110 + 1;
		}
		return esi;
	}
}

// 0804CF80: void runtime.(*TypeAssertionError).Error(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_5113) dwArg04)
void runtime.(*TypeAssertionError).Error(struct Eq_2 * gs, struct Eq_5113 * dwArg04)
{
	while (fp - 0x10 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg04->dw0004 != 0x00;
	if (dwArg04->dw000C == 0x00)
		runtime.concatstring4(gs, 0x00);
	else if (dwArg04->dw001C != 0x00)
	{
		fn08090228(&g_t80F2000, fp - 0x60);
		runtime.concatstrings(gs, 0x00, fp - 100, 0x06);
	}
	else
	{
		fn08090228(&g_t80F1FC0, fp - 0x30);
		runtime.concatstrings(gs, 0x00, fp - 0x34, 0x06);
	}
}

// 0804D150: void runtime.errorString.Error(Register (ptr32 Eq_2) gs)
void runtime.errorString.Error(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.concatstring2(gs, 0x00);
}

// 0804D1B0: void runtime.plainError.Error(Register (ptr32 Eq_5195) gs)
void runtime.plainError.Error(struct Eq_5195 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 0804D1E0: void runtime.typestring(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.printany
void runtime.typestring(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*_type).string(gs, dwArg04);
}

// 0804D220: void runtime.printany(Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm1, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.printpanics
//      runtime.gopanic
void runtime.printany(struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm1, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	else
	{
		Eq_4 ecx_36 = *((word32) dwArg04 + 8);
		runtime.assertE2I2(gs, dwArg04);
		if ((byte) (word32) bLoc68 == 0x00)
		{
			runtime.assertE2I2(gs, dwArg04);
			if ((byte) (word32) bLoc68 != 0x00)
			{
				dwLoc70->ptr0014();
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
			}
			else
			{
				if (ecx_36 <= 3004847213)
				{
					if (ecx_36 <= 2032468620)
					{
						if (ecx_36 <= 0x2EA27FFB)
						{
							bool Z_764;
							if (ecx_36 == 0x13FF06C5)
							{
								uip32 ebx_1302;
								if (dwArg04 == 0x080CE760)
									ebx_1302 = (word32) *dwArg08;
								else
									ebx_1302 = 0x00;
								byte bl_739 = (byte) ebx_1302;
								if (dwArg04 == 0x080CE760)
								{
									runtime.printlock(gs);
									runtime.printbool(gs, (byte) (word32) bl_739);
									runtime.printunlock(gs);
									return;
								}
								Z_764 = SLICE(cond(ecx_36 - 0x2EA27FFB), bool, 2);
							}
							else
								Z_764 = SLICE(cond(ecx_36 - 0x2EA27FFB), bool, 2);
							if (!Z_764)
							{
								Eq_661 xmm0_775;
								if (dwArg04 == 0x080CE860)
									xmm0_775.u0 = (uint128) (uint64) *dwArg08;
								else
									xmm0_775 = __xorps(xmm0, xmm0);
								if (dwArg04 == 0x080CE860)
								{
									runtime.printlock(gs);
									word128 xmm2_1313;
									runtime.printfloat(gs, xmm2, (real64) (uint128) (uint64) (real64) xmm0_775, out xmm2_1313);
									runtime.printunlock(gs);
									return;
								}
							}
						}
						else
						{
							bool Z_674;
							if (ecx_36 == 1715356255)
							{
								uip32 ebx_1304;
								if (dwArg04 == 0x080CF320)
									ebx_1304 = (word32) *dwArg08;
								else
									ebx_1304 = 0x00;
								byte bl_647 = (byte) ebx_1304;
								if (dwArg04 == 0x080CF320)
								{
									runtime.printlock(gs);
									runtime.printint(SLICE(ebx_1304, word24, 8), gs, (word32) (byte) (word32) bl_647);
									runtime.printunlock(gs);
									return;
								}
								Z_674 = SLICE(cond(ecx_36 - 2032468620), bool, 2);
							}
							else
								Z_674 = SLICE(cond(ecx_36 - 2032468620), bool, 2);
							if (!Z_674)
							{
								Eq_661 xmm0_689;
								Eq_661 xmm1_685;
								if (dwArg04 == 0x080CE7E0)
								{
									xmm0_689.u0 = (uint128) (uint32) *((word32) dwArg08 + 4);
									xmm1_685.u0 = (uint128) (uint32) *dwArg08;
								}
								else
								{
									xmm1_685 = __xorps(xmm1, xmm1);
									xmm0_689 = __xorps(xmm0, xmm0);
								}
								if (dwArg04 == 0x080CE7E0)
								{
									runtime.printlock(gs);
									runtime.printcomplex(gs, (real64) (uint128) (uint32) (real32) xmm1_685, (real64) (uint128) (uint32) (real32) xmm0_689);
									runtime.printunlock(gs);
									return;
								}
							}
						}
					}
					else if (ecx_36 <= ~0x69C06400)
					{
						bool Z_586;
						if (ecx_36 == 2251394350)
						{
							Eq_4 ebp_555;
							Eq_4 ebx_554;
							if (dwArg04 == 135066336)
							{
								ebx_554 = *((word32) dwArg08 + 4);
								ebp_555 = *dwArg08;
							}
							else
							{
								ebx_554.u0 = 0x00;
								ebp_555.u0 = 0x00;
							}
							if (dwArg04 == 135066336)
							{
								runtime.printlock(gs);
								runtime.printuint(ebp_555, gs, ebp_555, ebx_554);
								runtime.printunlock(gs);
								return;
							}
							Z_586 = SLICE(cond(ecx_36 - ~0x69C06400), bool, 2);
						}
						else
							Z_586 = SLICE(cond(ecx_36 - ~0x69C06400), bool, 2);
						if (!Z_586)
						{
							Eq_4 ebx_595;
							Eq_4 eax_594;
							if (dwArg04 == 0x080CEC20)
							{
								eax_594 = *dwArg08;
								ebx_595 = *((word32) dwArg08 + 4);
							}
							else
							{
								eax_594.u0 = 0x00;
								ebx_595.u0 = 0x00;
							}
							if (dwArg04 == 0x080CEC20)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx_595, word24, 8), gs, eax_594);
								runtime.printunlock(gs);
								return;
							}
						}
					}
					else
					{
						bool Z_494;
						if (ecx_36 == 0xB0C23ED3)
						{
							if (dwArg04 == 0x080CE820)
								xmm0.u0 = (uint128) (uint32) *dwArg08;
							else
								xmm0 = __xorps(xmm0, xmm0);
							if (dwArg04 == 0x080CE820)
							{
								runtime.printlock(gs);
								word128 xmm2_1314;
								runtime.printfloat(gs, xmm2, (real64) (uint128) (uint32) (real32) xmm0, out xmm2_1314);
								runtime.printunlock(gs);
								return;
							}
							Z_494 = SLICE(cond(ecx_36 - 3004847213), bool, 2);
						}
						else
							Z_494 = SLICE(cond(ecx_36 - 3004847213), bool, 2);
						if (!Z_494)
						{
							Eq_661 xmm1_512;
							Eq_661 xmm0_505;
							if (dwArg04 == 0x080CE7A0)
							{
								xmm0_505.u0 = (uint128) (uint64) *dwArg08;
								xmm1_512.u0 = (uint128) (uint64) *((word32) dwArg08 + 8);
							}
							else
							{
								xmm0_505 = __xorps(xmm0, xmm0);
								xmm1_512 = __xorps(xmm1, xmm1);
							}
							if (dwArg04 == 0x080CE7A0)
							{
								runtime.printlock(gs);
								runtime.printcomplex(gs, (real64) (uint128) (uint64) (real64) xmm0_505, (real64) (uint128) (uint64) (real64) xmm1_512);
								runtime.printunlock(gs);
								return;
							}
						}
					}
				}
				else if (ecx_36 <= 3494570045)
				{
					if (ecx_36 <= 3175798674)
					{
						bool Z_414;
						if (ecx_36 == 0xBBAD4102)
						{
							if (dwArg04 == 0x080CEBE0)
								ebx = *dwArg08;
							else
								ebx.u0 = 0x00;
							if (dwArg04 == 0x080CEBE0)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx, word24, 8), gs, ebx);
								runtime.printunlock(gs);
								return;
							}
							Z_414 = SLICE(cond(ecx_36 - 3175798674), bool, 2);
						}
						else
							Z_414 = SLICE(cond(ecx_36 - 3175798674), bool, 2);
						if (!Z_414)
						{
							Eq_4 eax_422;
							if (dwArg04 == 0x080CF360)
								eax_422 = *dwArg08;
							else
								eax_422.u0 = 0x00;
							if (dwArg04 == 0x080CF360)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx, word24, 8), gs, eax_422);
								runtime.printunlock(gs);
								return;
							}
						}
					}
					else
					{
						bool Z_341;
						if (ecx_36 == 0xCC06C027)
						{
							Eq_4 ebx_1306;
							if (dwArg04 == 0x080CEC60)
								ebx_1306 = (word32) *dwArg08;
							else
								ebx_1306.u0 = 0x00;
							byte bl_314 = (byte) ebx_1306;
							ebx = ebx_1306;
							if (dwArg04 == 0x080CEC60)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx_1306, word24, 8), gs, (int32) (byte) (word32) bl_314);
								runtime.printunlock(gs);
								return;
							}
							Z_341 = SLICE(cond(ecx_36 - 3494570045), bool, 2);
						}
						else
							Z_341 = SLICE(cond(ecx_36 - 3494570045), bool, 2);
						if (!Z_341)
						{
							Eq_4 eax_349;
							if (dwArg04 == 0x080CF2A0)
								eax_349 = *dwArg08;
							else
								eax_349.u0 = 0x00;
							if (dwArg04 == 0x080CF2A0)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx, word24, 8), gs, eax_349);
								runtime.printunlock(gs);
								return;
							}
						}
					}
				}
				else if (ecx_36 <= ~0x1F00A34B)
				{
					bool Z_257;
					if (ecx_36 == 3585636114)
					{
						Eq_4 ebx_232;
						if (dwArg04 == 0x080CF220)
							ebx_232 = *dwArg08;
						else
							ebx_232.u0 = 0x00;
						if (dwArg04 == 0x080CF220)
						{
							runtime.printlock(gs);
							runtime.printint(SLICE(ebx_232, word24, 8), gs, ebx_232);
							runtime.printunlock(gs);
							return;
						}
						Z_257 = SLICE(cond(ecx_36 - ~0x1F00A34B), bool, 2);
					}
					else
						Z_257 = SLICE(cond(ecx_36 - ~0x1F00A34B), bool, 2);
					if (!Z_257 && dwArg04 == 135066016)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						return;
					}
				}
				else
				{
					if (ecx_36 == 0xECD580CE)
					{
						Eq_4 ebx_115;
						if (dwArg04 == 0x080CEBA0)
							ebx_115 = (word32) *dwArg08;
						else
							ebx_115.u0 = 0x00;
						word16 bx_117 = (word16) ebx_115;
						ebx = ebx_115;
						if (dwArg04 == 0x080CEBA0)
						{
							runtime.printlock(gs);
							runtime.printint(SLICE(ebx_115, word24, 8), gs, (int32) (word16) (word32) bx_117);
							runtime.printunlock(gs);
							return;
						}
					}
					if (ecx_36 == ~0x100DF15F)
					{
						Eq_4 ebx_1310;
						if (dwArg04 == 0x080CF260)
							ebx_1310 = (word32) *dwArg08;
						else
							ebx_1310.u0 = 0x00;
						word16 bx_158 = (word16) ebx_1310;
						ebx = ebx_1310;
						if (dwArg04 == 0x080CF260)
						{
							runtime.printlock(gs);
							runtime.printint(SLICE(ebx_1310, word24, 8), gs, (word32) (word16) (word32) bx_158);
							runtime.printunlock(gs);
							return;
						}
					}
					if (ecx_36 == 4149441018)
					{
						Eq_4 eax_192;
						if (dwArg04 == 0x080CEB60)
							eax_192 = *dwArg08;
						else
							eax_192.u0 = 0x00;
						if (dwArg04 == 0x080CEB60)
						{
							runtime.printlock(gs);
							runtime.printint(SLICE(ebx, word24, 8), gs, eax_192);
							runtime.printunlock(gs);
							return;
						}
					}
				}
				runtime.typestring(gs);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printeface(gs);
				runtime.printunlock(gs);
			}
		}
		else
		{
			dwLoc70->ptr0014();
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
	}
}

// 0804DB10: void runtime.panicwrap(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*errorString).Error
//      runtime.(*plainError).Error
//      syscall.(*Errno).Error
//      reflect.(*ChanDir).String
//      reflect.(*Kind).String
//      reflect.(*Value).Kind
//      reflect.(*Value).Len
//      reflect.(*Value).NumMethod
//      reflect.(*Value).NumField
//      reflect.(*Value).String
void runtime.panicwrap(struct Eq_2 * gs)
{
	while (fp - 0x9C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_510;
	runtime.makeslice(gs, 0x080CF360, 0x01, 0x01, out edi_510);
	runtime.Callers(gs, dwLoc010C);
	if (dwLoc010C == 0x00)
		runtime.throw(gs);
	else
	{
		runtime.CallersFrames(gs, dwLoc0110, dwLoc010C, dwLoc0108);
		fn0808FD88(0x00, fp - 0x68);
		runtime.(*Frames).Next(gs, dwLoc0110);
		fn08090250(fp - 0x011C, fp - 0x6C);
		fn08090250(fp - 0x70, fp - 0x90);
		strings.IndexByte(dwLoc8C, dwLoc88, 0x28);
		if (dwLoc0110 < 0x00)
		{
			runtime.concatstring2(gs, fp - 0xCC);
			runtime.throw(gs);
		}
		else if (dwLoc0110 - 0x01 > dwLoc88)
			runtime.panicslice(gs);
		else
		{
			if ((word32) dwLoc0110 + 2 < dwLoc88)
			{
				if (dwLoc0110 - 0x01 > (word32) dwLoc0110 + 2 || (word32) dwLoc0110 + 2 > dwLoc88)
					runtime.panicslice(gs);
				Eq_5873 eax_186 = (word32) dwLoc0110 + 2 - (dwLoc0110 - 0x01);
				Eq_5877 eax_190 = -eax_186 >> 0x1F & dwLoc0110 - 0x01;
				if (eax_186 == 0x03 && (SLICE((word32) Mem129[eax_190 + dwLoc8C:word16], word16, 0) == 0x282E && SLICE((word32) Mem129[(dwLoc8C + 0x02) + eax_190:byte], byte, 0) == 0x2A))
				{
					Eq_4 edx_234 = dwLoc88 - ((word32) dwLoc0110 + 2);
					Eq_5840 (* ecx_242)[] = dwLoc8C + ((word32) dwLoc0110 + 2 & -edx_234 >> 0x1F) / 4;
					strings.IndexByte(ecx_242, edx_234, 0x29);
					if (dwLoc0110 < 0x00)
					{
						runtime.concatstring2(gs, fp - 0xEC);
						runtime.throw(gs);
					}
					else
					{
						if (dwLoc0110 + 0x02 < edx_234)
						{
							if (dwLoc0110 >u dwLoc0110 + 0x02 || dwLoc0110 + 0x02 >u edx_234)
								runtime.panicslice(gs);
							if (SLICE((word32) Mem246[dwLoc0110 + ecx_242:word16], word16, 0) == 11817)
							{
								if (dwLoc0110 > edx_234)
									runtime.panicslice(gs);
								else
								{
									fn080901EC(&g_t80F20C0, fp - 0x54);
									runtime.concatstrings(gs, 0x00, fp - 88, 0x09);
									runtime.convT2Estring(gs, 0x080D1EE0, fp - 0xA0);
									runtime.gopanic(gs);
								}
							}
						}
						runtime.concatstring2(gs, 0x00);
						runtime.throw(gs);
					}
				}
			}
			runtime.concatstring2(gs, 0x00);
			runtime.throw(gs);
		}
	}
}

// 0804DF50: void runtime.Caller(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.methodName
void runtime.Caller(struct Eq_2 * gs)
{
	while (fp - 0x4C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.callers(gs);
	if (dwLocBC < 0x02)
		return;
	Eq_4 edx_67;
	Eq_4 ecx_66;
	fn0808FD82(0x00, fp - 0x38);
	up32 edx_55 = g_dw8157640;
	if (dwLoc8C - edx_55 < 0x0100)
	{
		ecx_66 = fp - 0x88;
		edx_67.u0 = 0x02;
	}
	else
	{
		ecx_66 = fp - 0x8C;
		edx_67.u0 = 0x03;
	}
	runtime.(*stackExpander).next(gs, dwLocD4, fp - 0x3C, ecx_66, edx_67);
	if ((byte) (word32) bLoc90 == 0x00)
		return;
	fn0808FD88(0x00, fp - 88);
	runtime.(*stackExpander).next(gs, dwLocD4, fp - 0x3C, 0x00, dwLocB8);
	fn08090250(fp - 0xA8, fp - 0x50);
	fn08090250(fp - 0x54, fp - 116);
}

// 0804E160: void runtime.Callers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.panicwrap
void runtime.Callers(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
		return;
	runtime.callers(gs);
}

// 0804E1C0: void runtime.GOROOT(Register (ptr32 Eq_2) gs)
// Called from:
//      time.init
void runtime.GOROOT(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gogetenv(gs, 0x080E10E8, 0x06);
	if (dwLoc04 == 0x00)
		;
}

// 0804E220: void runtime.float64frombits(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
void runtime.float64frombits(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0804E250: void runtime.memhash(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      type..hash.sync/atomic.Value
//      runtime.memhash8
//      runtime.memhash16
//      runtime.memhash32
//      runtime.memhash64
//      runtime.memhash128
//      runtime.strhash
//      runtime.f32hash
//      runtime.f64hash
//      runtime.extendRandom
//      runtime.(*traceStackTable).put
//      runtime.memhash_varlen
//      type..hash.runtime._func
//      type..hash.runtime.uncommontype
//      type..hash.runtime.modulehash
//      type..hash.runtime.Frame
//      type..hash.runtime.MemStats
//      type..hash.runtime._panic
//      type..hash.runtime._defer
//      type..hash.runtime.special
//      type..hash.runtime.markBits
//      type..hash.runtime.hchan
//      type..hash.runtime.cpuProfile
//      type..hash.runtime.dbgVar
//      type..hash.runtime.finblock
//      type..hash.runtime.gcControllerState
//      type..hash.runtime.mcentral
//      type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..hash.runtime.mstats
//      type..hash.runtime.sigTabT
//      type..hash.runtime.stackmap
//      type..hash.runtime.sweepdata
//      type..hash.runtime.traceStack
//      type..hash.struct { runtime.cycle uint32; runtime.flushed bool }
//      type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
//      type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }
//      type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }
//      type..hash.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }
//      type..hash.struct { F uintptr; runtime.preemptible bool }
//      type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }
//      type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }
//      type..hash.strconv.decimal
//      type..hash.strconv.extFloat
//      type..hash.strconv.leftCheat
//      type..hash.internal/poll.FD
//      type..hash.os.file
//      type..hash.reflect.uncommonType
//      type..hash.reflect.Method
//      type..hash.reflect.ValueError
//      type..hash.struct { reflect.b bool; reflect.x interface {} }
//      type..hash.struct { F uintptr; reflect.name string }
//      type..hash.fmt.fmt
void runtime.memhash(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b8157582 != 0x00)
		runtime.aeshash(mm0, dwArg08, dwArg0C);
	else
	{
		Eq_4 ecx_146 = dwArg0C;
		Eq_207 edx_139 = dwArg08;
		int32 eax_160 = (word32) dwArg08 + g_dw81576E0 *s dwArg0C;
		Eq_207 ebx_153 = dwArg04;
		while (ecx_146 != 0x00)
		{
			if (ecx_146 < 0x04)
			{
				__rol(((word32) Mem51[ebx_153 + 0x00:byte] ^ eax_160 ^ (word32) Mem51[(ecx_146 >>u 0x01) + ebx_153:byte] << 0x08 ^ (word32) Mem51[(ecx_146 - 0x01) + ebx_153:byte] << 0x10) *s 3168982561, 0x0F);
				return;
			}
			if (ecx_146 == 0x04)
			{
				__rol((*ebx_153 ^ eax_160) *s 3168982561, 0x0F);
				return;
			}
			if (ecx_146 <= 0x08)
			{
				__rol((__rol((*ebx_153 ^ eax_160) *s 3168982561, 0x0F) *s 3339683297 ^ Mem51[(ecx_146 - 0x04) + ebx_153:word32]) *s 3168982561, 0x0F);
				return;
			}
			if (ecx_146 <= 0x10)
			{
				__rol((Mem51[ecx_146 - 0x04 + ebx_153:word32] ^ __rol((Mem51[(ecx_146 - 0x08) + ebx_153:word32] ^ __rol((Mem51[ebx_153 + 0x04:word32] ^ __rol((eax_160 ^ Mem51[ebx_153 + 0x00:word32]) *s 3168982561, 0x0F) *s 3339683297) *s 3168982561, 0x0F) *s 3339683297) *s 3168982561, 0x0F) *s 3339683297) *s 3168982561, 0x0F);
				return;
			}
			int32 ebp_140 = g_dw81576E4 *s edx_139;
			int32 esi_142 = g_dw81576E8 *s edx_139;
			int32 edi_144 = g_dw81576EC *s edx_139;
			for (; ecx_146 >= 0x10; ecx_146 += ~0x0F)
			{
				eax_160 = __rol((eax_160 ^ *ebx_153) *s 3168982561, 0x0F) *s 3339683297;
				ebp_140 = __rol((ebp_140 ^ *((word32) ebx_153 + 4)) *s 3339683297, 0x0F) *s 832293441;
				esi_142 = __rol((esi_142 ^ *((word32) ebx_153 + 8)) *s 832293441, 0x0F) *s 2336365089;
				edi_144 = __rol((*((word32) ebx_153 + 0x0C) ^ edi_144) *s 2336365089, 0x0F) *s 3168982561;
				ebx_153 += 0x10;
				edx_139 = dwArg08;
			}
			eax_160 = eax_160 ^ ebp_140 ^ esi_142 ^ edi_144;
		}
	}
}

// 0804E4A0: Register Eq_4 runtime.(*hmap).newoverflow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.mapassign
//      runtime.evacuate
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
Eq_4 runtime.(*hmap).newoverflow(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_122;
	Eq_4 edx_18 = *((word32) dwArg04 + 24);
	if (edx_18 != 0x00)
	{
		Eq_4 ebp_24 = *((word32) edx_18 + 8);
		esi = (word32) edx_18 + 8;
		if (ebp_24 != 0x00)
		{
			word32 ebx_49 = (word32) *((word32) dwArg08 + 52);
			Eq_4 ebp_51 = (word32) ebp_24 + (ebx_49 - 0x04);
			esi = ebp_24;
			Eq_4 ebx_55 = (word32) ebp_24 + ebx_49;
			if (*ebp_51 != 0x00)
			{
				if (g_t81576F0 == 0x00)
					*ebp_51 = 0x00;
				else
				{
					runtime.writebarrierptr(ebp_51, 0x00);
					dwLoc38.u0 = 0x00;
				}
				Eq_4 edx_98 = *((word32) dwArg04 + 24);
				if (g_t81576F0 == 0x00)
					((word32) edx_98 + 8)->u0 = 0x00;
				else
				{
					runtime.writebarrierptr((word32) edx_98 + 8, 0x00);
					dwLoc38.u0 = 0x00;
				}
			}
			else if (g_t81576F0 == 0x00)
				*((word32) edx_18 + 8) = ebx_55;
			else
			{
				runtime.writebarrierptr((word32) edx_18 + 8, ebx_55);
				dwLoc38 = ebx_55;
			}
			edx_122 = ebp_24;
l0804E53A:
			word32 ebx_126 = (word32) *((word32) dwArg04 + 5);
			if ((byte) ebx_126 < 0x10)
				((word32) dwArg04 + 6)->u1 = (word16) ((word32) *((word32) dwArg04 + 6) + 0x01);
			else
			{
				Eq_4 ebp_135 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
				int32 esi_136 = *((word32) ebp_135 + 0x0094);
				int32 edi_141 = esi_136 << 0x01 ^ esi_136 >> 0x1F & 0xA8888EEF;
				*((word32) ebp_135 + 0x0094) = edi_141;
				cu8 cl_150 = (byte) (ebx_126 + ~0x0E);
				esi = 0x01 << cl_150 & 0x00 - (cl_150 < 0x20);
				if ((esi - (word32 *) 0x01 & edi_141) == 0x00)
					((word32) dwArg04 + 6)->u1 = (word16) ((word32) *((word32) dwArg04 + 6) + 0x01);
			}
			if (((byte) (word32) *((word32) *((word32) dwArg08 + 40) + 0x0F) & 0x80) != 0x00)
			{
				if (*((word32) dwArg04 + 24) == 0x00)
				{
					runtime.newobject(gs, 135085088);
					if (g_t81576F0 == 0x00)
						*((word32) dwArg04 + 24) = dwLoc38;
					else
						runtime.writebarrierptr((word32) dwArg04 + 24, dwLoc38);
				}
				if (**((word32) dwArg04 + 24) == 0x00)
				{
					runtime.newobject(gs, 0x080C9100);
					Eq_4 ecx_253 = *((word32) dwArg04 + 24);
					if (g_t81576F0 == 0x00)
						*ecx_253 = dwLoc38;
					else
						runtime.writebarrierptr(ecx_253, dwLoc38);
				}
				Eq_4 ecx_281 = **((word32) dwArg04 + 24);
				Eq_4 eax_284 = *((word32) ecx_281 + 8);
				Eq_4 ebp_285 = *ecx_281;
				esi = *((word32) ecx_281 + 4);
				if (esi + 0x01 > eax_284)
				{
					word32 esi_585;
					runtime.growslice(gs, 0x080D2120, ebp_285, esi, eax_284, esi + 0x01, out esi_585);
					*((word32) ecx_281 + 8) = dwLoc20;
					if (g_t81576F0 == 0x00)
						*ecx_281 = dwLoc28;
					else
						runtime.writebarrierptr(ecx_281, dwLoc28);
					esi = dwLoc24;
					ebp_285 = dwLoc28;
				}
				Mem349[ecx_281 + 0x04:word32] = esi + 0x01;
				Eq_4 ecx_352 = (word32) ebp_285 + esi * 0x04;
				if (g_t81576F0 == 0x00)
					*((word32) ebp_285 + esi * 0x04) = edx_122;
				else
					runtime.writebarrierptr(ecx_352, edx_122);
			}
			Eq_4 eax_381 = dwArg0C - 0x04 + (word32) (*((word32) dwArg08 + 52));
			if (g_t81576F0 == 0x00)
				*eax_381 = edx_122;
			else
				runtime.writebarrierptr(eax_381, edx_122);
			return esi;
		}
	}
	runtime.newobject(gs, *((word32) dwArg08 + 40));
	edx_122 = dwLoc38;
	goto l0804E53A;
}

// 0804E7F0: Register Eq_4 runtime.makemap(Register Eq_6606 ebx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Register out ptr32 ediOut, Register out Eq_6615 xmm0Out, Register out Eq_6616 xmm1Out)
// Called from:
//      reflect.addReflectOff
//      runtime.typelinksinit
//      sync.(*Map).dirtyLocked
//      syscall.init
//      time.init
//      unicode.init
//      reflect.(*structType).FieldByNameFunc
Eq_4 runtime.makemap(Eq_6606 ebx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, ptr32 & ediOut, union Eq_6615 & xmm0Out, union Eq_6616 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_19 = **((word32) dwArg04 + 44);
	if (edx_19 != 0x1C)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printint(ebx_24_8, gs, 0x1C);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printint(ebx_24_8, gs, (uint64) (uint32) edx_19);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	Eq_4 edx_196;
	Eq_4 eax_195;
	ui32 ebx_125 = SEQ(SLICE(esi, word24, 8), dwArg0C == 0x00);
	if ((byte) (SEQ(SLICE(edi, word24, 8), dwArg0C < 0x00) | SEQ(ebx_24_8, Test(ULT,false)) & ebx_125) == 0x00)
	{
		Eq_4 ebx_166;
		uint32 ebx_156 = **((word32) dwArg04 + 40);
		if (ebx_156 < 33)
			ebx_166 = *((char *) g_a81386E0 + ebx_156 * 0x04);
		else
			ebx_166 = (uint32) (0xFFFFFFFF /u ebx_156);
		if ((byte) (ebx_125 & SEQ(SLICE(ebx_166, word24, 8), dwArg08 > ebx_166) | SEQ(SLICE(ebx_166, word24, 8), dwArg0C > 0x00)) == 0x00)
		{
			eax_195 = dwArg08;
			edx_196 = dwArg0C;
l0804E84C:
			Eq_4 ebx_207 = *((word32) dwArg04 + 32);
			if (**((word32) ebx_207 + 16) == 0x00)
				runtime.throw(gs);
			up32 ebp_228 = *ebx_207;
			Eq_6704 CZ_230 = SLICE(cond(ebp_228 - 0x80), bool, 2);
			if (ebp_228 > 0x80)
			{
				if ((byte) (word32) *((word32) dwArg04 + 49) == 0x00 || (byte) ((word32) (*((word32) dwArg04 + 48))) != 0x04)
				{
l0804ECB6:
					runtime.throw(gs);
				}
				CZ_230.u0 = SLICE(cond(ebp_228 - 0x80), bool, 2);
			}
			if (!CZ_230 && ((byte) ((word32) (*((word32) dwArg04 + 49))) != 0x00 || (byte) ebp_228 != (byte) ((word32) (*((word32) dwArg04 + 48)))))
				goto l0804ECB6;
			Eq_4 esi_308 = *((word32) dwArg04 + 36);
			ptr32 edi_309 = *esi_308;
			Eq_6738 CZ_311 = SLICE(cond(edi_309 - 0x80), bool, 2);
			if (edi_309 > 0x80)
			{
				if ((byte) (word32) *((word32) dwArg04 + 0x0033) == 0x00 || (byte) ((word32) (*((word32) dwArg04 + 50))) != 0x04)
				{
l0804EC9E:
					runtime.throw(gs);
				}
				CZ_311.u0 = SLICE(cond(edi_309 - 0x80), bool, 2);
			}
			if (CZ_311 || (byte) ((word32) (*((word32) dwArg04 + 0x0033))) == 0x00 && (byte) edi_309 == (byte) ((word32) (*((word32) dwArg04 + 50))))
			{
				ptr32 edi_425 = edi_309;
				cu8 dl_364 = (byte) (word32) *((word32) ebx_207 + 0x0D);
				if (dl_364 > 0x08)
					runtime.throw(gs);
				else
				{
					cu8 bl_381 = (byte) (word32) *((word32) esi_308 + 0x0D);
					if (bl_381 > 0x08)
						runtime.throw(gs);
					else
					{
						ui32 edx_393 = (word32) dl_364;
						if (edx_393 == 0x00)
							runtime.panicdivide(gs);
						else
						{
							Eq_4 esi_398 = eax_195;
							ui24 ecx_24_8_496 = SLICE(edx_393, word24, 8);
							if ((uint32) ((uint64) (uint32) ebp_228 % edx_393) != 0x00)
								runtime.throw(gs);
							else
							{
								ui32 edx_421 = (word32) bl_381;
								if (edx_421 == 0x00)
									runtime.panicdivide(gs);
								else
								{
									Eq_363 ebx_24_8_498 = SLICE(edx_421, word24, 8);
									if ((uint32) ((uint64) (uint32) edi_309 % edx_421) != 0x00)
										runtime.throw(gs);
									else if ((uint32) (0x08 % edx_393) != 0x00)
										runtime.throw(gs);
									else if ((uint32) (0x08 % edx_421) != 0x00)
										runtime.throw(gs);
									else
									{
										uip32 eax_1053 = 0x00;
										while (true)
										{
											Eq_6882 cl_581;
											Eq_4 dwLoc30_860 = (word32) rLoc30;
											Eq_4 dwLoc2C_862 = SLICE(rLoc30, word32, 32);
											byte al_485 = (byte) eax_1053;
											uip32 eax_582 = eax_1053;
											if ((byte) (SEQ(ecx_24_8_496, esi_398 >= 0x08) & SEQ(ebx_24_8_498, edx_196 == 0x00) | SEQ(ebx_24_8_498, edx_196 > 0x00)) == 0x00)
											{
												cl_581.u0 = 0x00;
												ecx_24_8_496 = 0x00;
											}
											else
											{
												runtime.int64tofloat64(ebx_24_8_498, gs, SEQ(edx_196, esi_398));
												word32 ecx_525 = (word32) al_485;
												ui32 ebx_543 = 0x01 << (byte) (ecx_525 - 0x20) & 0x00 - ((byte) (ecx_525 - 0x20) < 0x20);
												word32 eax_544 = 0x20 - ecx_525;
												Eq_4 ebp_554 = 0x01 >> (byte) eax_544 & 0x00 - ((byte) eax_544 < 0x20) | ebx_543;
												ecx_24_8_496 = SLICE(runtime.uint64tofloat64(gs, ebp_554), word24, 8);
												Eq_6615 xmm0_567 = (uint128) (uint64) (real64) (uint128) (uint64) rLoc30;
												Eq_6616 xmm1_570 = (uint128) (uint64) rLoc30;
												uint128 xmm2_573 = (uint128) (uint32) g_r80F1808;
												ebx_24_8_498 = SLICE(ebx_543, word24, 8);
												nLoc33 = SLICE(ebp_554, word24, 8);
												xmm0 = xmm0_567;
												xmm1 = xmm1_570;
												cl_581 = (real32) xmm0_567 >= SEQ(SLICE(xmm2_573, uir96, 32), (real32) xmm2_573 * (real32) xmm1_570);
												eax_582 = (word32) al_485;
												esi_398 = eax_195;
											}
											byte al_598 = (byte) eax_582;
											if (cl_581 == 0x00)
												break;
											eax_1053 = eax_582 + 0x01;
										}
										Eq_4 dwLoc34_878;
										Eq_4 ecx_658;
										Eq_4 edx_666;
										if (al_598 == 0x00)
										{
											ecx_658.u0 = 0x00;
											edx_666 = dwArg14;
										}
										else
										{
											esi_398 = runtime.makeBucketArray(gs, dwArg04, al_598, out edi_425);
											dwLoc34_878 = SEQ(nLoc33, al_598);
											if (dwLoc2C_862 == 0x00)
												ecx_658.u0 = 0x00;
											else
											{
												runtime.newobject(gs, 135085088);
												if (g_t81576F0 == 0x00)
													*((word32) dwLoc34_878 + 8) = dwLoc2C_862;
												else
												{
													runtime.writebarrierptr((word32) dwLoc34_878 + 8, dwLoc2C_862);
													dwLoc34_878 = dwLoc2C_862;
												}
												ecx_658 = dwLoc34_878;
											}
											edx_666 = dwLoc30_860;
											al_598 = (byte) (word32) al_485;
										}
										Eq_4 ebx_677 = dwArg10;
										if (dwArg10 == 0x00)
										{
											runtime.newobject(gs, *((word32) dwArg04 + 44));
											ebx_677 = dwLoc34_878;
											al_598 = (byte) (word32) al_485;
										}
										*ebx_677 = 0x00;
										*((word32) ebx_677 + 5) = al_598;
										Eq_4 ebp_711 = (word32) ebx_677 + 24;
										if (g_t81576F0 == 0x00)
											*((word32) ebx_677 + 24) = ecx_658;
										else
											runtime.writebarrierptr(ebp_711, ecx_658);
										*((word32) ebx_677 + 4) = 0x00;
										Eq_4 eax_735 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
										Eq_4 ecx_736 = *((word32) eax_735 + 0x0094);
										Eq_4 ebp_741 = ecx_736 << 0x01 ^ ecx_736 >> 0x1F & 0xA8888EEF;
										*((word32) eax_735 + 0x0094) = ebp_741;
										*((word32) ebx_677 + 8) = ebp_741;
										Eq_4 ecx_745 = (word32) ebx_677 + 0x0C;
										Eq_4 ebp_746 = (word32) ebx_677 + 16;
										if (g_t81576F0 == 0x00)
										{
											*((word32) ebx_677 + 0x0C) = edx_666;
											((word32) ebx_677 + 16)->u0 = 0x00;
										}
										else
										{
											runtime.writebarrierptr(ecx_745, edx_666);
											runtime.writebarrierptr(ebp_746, 0x00);
										}
										((word32) ebx_677 + 20)->u0 = 0x00;
										((word32) ebx_677 + 6)->u1 = 0x00;
										ediOut = edi_425;
										xmm0Out = xmm0;
										xmm1Out = xmm1;
										return esi_398;
									}
								}
							}
						}
					}
				}
			}
			goto l0804EC9E;
		}
	}
	eax_195.u0 = 0x00;
	edx_196.u0 = 0x00;
	goto l0804E84C;
}

// 0804ED80: Register Eq_4 runtime.mapaccess2(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack ptr32 dwArg0C, Register out Eq_7122 esiOut)
// Called from:
//      reflect.mapaccess
//      sync.(*Map).Load
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
Eq_4 runtime.mapaccess2(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 dwArg0C, union Eq_7122 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
	{
		esiOut = esi;
		return ebx;
	}
	else if (((byte) (word32) *((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_47 = *((word32) *((word32) dwArg04 + 32) + 16);
		<anonymous> ** edx_49 = *ecx_47;
		(*edx_49)();
		cu8 cl_67 = (byte) (word32) *((word32) dwArg08 + 5);
		uint32 esi_72 = 0x01 << cl_67 & 0x00 - (cl_67 < 0x20);
		int32 eax_77 = (word32) *((word32) dwArg04 + 52);
		Eq_7122 esi_156 = esi_72 - 0x01;
		Eq_7122 ecx_105 = (word32) *((word32) dwArg08 + 0x0C) + (esi_72 - 0x01 & dwLoc14) *s eax_77;
		Eq_4 ebp_80 = *((word32) dwArg08 + 16);
		if (ebp_80 != 0x00)
		{
			if (((byte) (word32) *((word32) dwArg08 + 4) & 0x08) == 0x00)
				esi_156 = esi_72 - 0x01 >> 0x01;
			esi_156 = (esi_156 & dwLoc14) *s eax_77;
			word32 eax_98 = esi_156 + ebp_80;
			if ((byte) ((word32) *eax_98 - 0x01) >= 0x03)
				ecx_105 = eax_98;
		}
		byte al_113;
		if ((byte) (dwLoc14 >> 0x18) < 0x04)
			al_113 = (byte) ((dwLoc14 >> 0x18) + 0x04);
		else
			al_113 = (byte) (dwLoc14 >> 0x18);
		al_135 = al_113;
		do
		{
			byte al_135;
			Eq_7243 edx_123 = 0x00;
			ecx_133 = ecx_105;
			while (true)
			{
				Eq_7122 ecx_133;
				byte bLoc14_261 = (byte) dwLoc14;
				if (edx_123 >= 0x08)
					break;
				if (al_135 == SLICE((word32) Mem130[ecx_133 + edx_123:byte], byte, 0))
				{
					struct Eq_7267 * ebx_162;
					esi_156 = ecx_133;
					struct Eq_7267 * ebp_157 = (word32) ecx_133 + ((word32) (*((word32) dwArg04 + 48)) *s edx_123 + 0x08);
					if ((byte) (word32) *((word32) dwArg04 + 49) != 0x00)
						ebx_162 = ebp_157->ptr0000;
					else
						ebx_162 = ebp_157;
					<anonymous> ** edx_167 = *((word32) ecx_47 + 4);
					(*edx_167)();
					if ((byte) (word32) bLoc14_261 != 0x00)
					{
						Eq_4 ebx_188 = edx_123 *s (word32) (*((word32) dwArg04 + 50));
						(byte) (word32) *((word32) dwArg04 + 0x0033) == 0x00;
						esiOut = ecx_133;
						return ebx_188;
					}
					al_135 = (byte) (word32) al_113;
					ecx_133 = ecx_105;
				}
				edx_123 = (word32) edx_123 + 1;
			}
			ecx_105 = *((word32) (ecx_133 - 0x04) + (word32) (*((word32) dwArg04 + 52)));
		} while (ecx_105 != 0x00);
		esiOut = esi_156;
		return dwArg04;
	}
}

// 0804EF80: void runtime.mapaccessK(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.mapiternext
void runtime.mapaccessK(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
		return;
	Eq_4 ebx_32 = *((word32) *((word32) dwArg04 + 32) + 16);
	<anonymous> ** edx_34 = *ebx_32;
	(*edx_34)();
	cu8 cl_51 = (byte) (word32) *((word32) dwArg08 + 5);
	uint32 ebp_56 = 0x01 << cl_51 & 0x00 - (cl_51 < 0x20);
	int32 edi_62 = (word32) *((word32) dwArg04 + 52);
	uint32 ebp_59 = ebp_56 - 0x01;
	byte * ecx_101 = (word32) *((word32) dwArg08 + 0x0C) + (ebp_56 - 0x01 & dwLoc18) *s edi_62;
	Eq_4 ebx_65 = *((word32) dwArg08 + 16);
	if (ebx_65 != 0x00)
	{
		if (((byte) (word32) *((word32) dwArg08 + 4) & 0x08) == 0x00)
			ebp_59 = ebp_56 - 0x01 >> 0x01;
		byte * ebx_88 = (word32) ebx_65 + (ebp_59 & dwLoc18) *s edi_62;
		if ((byte) ((word32) *ebx_88 - 0x01) >= 0x03)
			ecx_101 = ebx_88;
	}
	uint32 eax_379 = dwLoc18 >> 0x18;
	if ((byte) (dwLoc18 >> 0x18) < 0x04)
		eax_379 = (dwLoc18 >> 0x18) + 0x04;
	byte al_109 = (byte) eax_379;
	uint32 eax_207 = eax_379;
	do
	{
		Eq_7425 edx_118 = 0x00;
		ecx_128 = ecx_101;
		while (true)
		{
			byte * ecx_128;
			byte bLoc18_268 = (byte) dwLoc18;
			byte al_138 = (byte) eax_207;
			if (edx_118 >= 0x08)
				break;
			if (al_138 == SLICE((word32) Mem125[ecx_128 + edx_118:byte], byte, 0))
			{
				struct Eq_7451 * ebp_150 = ecx_128 + ((word32) (*((word32) dwArg04 + 48)) *s edx_118 + 0x08);
				if ((byte) (word32) *((word32) dwArg04 + 49) != 0x00)
					ebp_150 = ebp_150->ptr0000;
				<anonymous> ** edx_168 = *((word32) ebx_32 + 4);
				(*edx_168)();
				if ((byte) (word32) bLoc18_268 != 0x00)
				{
					(byte) (word32) *((word32) dwArg04 + 0x0033) == 0x00;
					return;
				}
				eax_207 = (word32) al_109;
				ecx_128 = ecx_101;
			}
			edx_118 = (word32) edx_118 + 1;
		}
		ecx_101 = (byte *) (ecx_128 - 0x04 + (word32) (*((word32) dwArg04 + 52)));
	} while (ecx_101 != null);
}

// 0804F150: void runtime.mapassign(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Map).dirtyLocked
void runtime.mapassign(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	Eq_4 dwLoc50 = (word32) rLoc50;
	word32 dwLoc4C = SLICE(rLoc50, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if (((byte) (word32) *((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_53 = *((word32) *((word32) dwArg04 + 32) + 16);
		Eq_4 ebx_56 = *((word32) dwArg08 + 8);
		<anonymous> ** edx_55 = *ecx_53;
		(*edx_55)();
		*((word32) dwArg08 + 4) = (byte) ((word32) *((word32) dwArg08 + 4) | 0x04);
		Eq_4 dwLoc54_808 = ebx_56;
		real64 rLoc50_975 = rLoc50;
		if (*((word32) dwArg08 + 0x0C) == 0x00)
		{
			word32 edi_1134;
			runtime.newarray(gs, *((word32) dwArg04 + 40), 0x01, out edi_1134);
			dwLoc54_808.u0 = 0x01;
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 0x0C) = dwLoc50;
			else
			{
				runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc50);
				dwLoc54_808 = dwLoc50;
			}
		}
		while (true)
		{
			cu8 cl_123 = (byte) (word32) *((word32) dwArg08 + 5);
			word32 dwLoc4C_984 = SLICE(rLoc50_975, word32, 32);
			int32 ebx_131 = (0x00 - (cl_123 < 0x20) & 0x01 << cl_123) - 0x01 & dwLoc50;
			if (*((word32) dwArg08 + 16) != 0x00)
			{
				runtime.growWork(gs, dwArg04, dwArg08, ebx_131);
				dwLoc54_808 = dwArg08;
				rLoc50_975 = SEQ(dwLoc4C_984, ebx_131);
			}
			Eq_4 edx_161 = dwArg08;
			Eq_4 ebx_166 = (word32) *((word32) dwArg08 + 0x0C) + ebx_131 *s (word32) (*((word32) dwArg04 + 52));
			cu8 al_170 = (byte) (dwLoc50 >> 0x18);
			if (al_170 < 0x04)
				al_170 = (byte) ((dwLoc50 >> 0x18) + 0x04);
			Eq_7629 ecx_179 = 0x00;
			Eq_4 esi_180 = 0x00;
			Eq_4 edi_181 = 0x00;
			al_187 = al_170;
			while (true)
			{
				cu8 al_187;
				union Eq_4 * dwLoc44_833 = null;
				word32 eax_1128 = (word32) al_187;
				while (true)
				{
					word32 dwLoc50_943 = (word32) rLoc50_975;
					Eq_7629 dwLoc4C_859 = SLICE(rLoc50_975, word32, 32);
					byte bLoc50_944 = (byte) dwLoc50_943;
					word32 dwLoc4C_1126 = SLICE(rLoc50_975, word32, 32);
					byte al_596 = (byte) eax_1128;
					if (dwLoc44_833 >= (union Eq_4 *) 0x08)
						break;
					word32 eax_1130;
					Eq_4 ebx_717;
					word32 esi_598 = (word32) Mem200[ebx_166 + dwLoc44_833:byte];
					word32 ebx_599 = ebx_166 + dwLoc44_833;
					if (al_596 != (byte) esi_598)
					{
						if ((byte) esi_598 == 0x00)
						{
							if (ecx_179 != 0x00)
							{
								ebx_717 = esi_180;
								eax_1130 = eax_1128;
							}
							else
							{
								int32 esi_737 = (word32) *((word32) dwArg04 + 48);
								ecx_179 = ebx_599;
								ebx_717 = (word32) ebx_166 + (dwLoc44_833 *s esi_737 + 0x08);
								edi_181 = (word32) ebx_166 + (((word32) (*((word32) dwArg04 + 50)) *s dwLoc44_833 + esi_737 * 0x08) + 0x08);
								eax_1130 = eax_1128;
							}
						}
						else
						{
							ebx_717 = esi_180;
							eax_1130 = eax_1128;
						}
					}
					else
					{
						Eq_4 eax_614 = (word32) ebx_166 + ((word32) (*((word32) dwArg04 + 48)) *s dwLoc44_833 + 0x08);
						if ((byte) (word32) *((word32) dwArg04 + 49) != 0x00)
							eax_614 = *eax_614;
						<anonymous> ** edx_624 = *((word32) ecx_53 + 4);
						(*edx_624)();
						dwLoc54_808 = eax_614;
						if ((byte) (word32) bLoc50_944 != 0x00)
						{
							if ((byte) (word32) *((word32) dwArg04 + 55) != 0x00)
							{
								word32 edi_656;
								word32 esi_658;
								runtime.typedmemmove(*((word32) dwArg04 + 32), eax_614, dwArg0C, out esi_658, out edi_656);
							}
							goto l0804F2EF;
						}
						eax_1130 = (word32) al_170;
						edx_161 = dwArg08;
						ebx_717 = esi_180;
					}
					++dwLoc44_833;
					esi_180 = ebx_717;
					eax_1128 = eax_1130;
				}
				Eq_4 eax_210 = *((word32) (ebx_166 - (union Eq_4 *) 0x04) + (word32) (*((word32) dwArg04 + 52)));
				if (eax_210 == 0x00)
					break;
				ebx_166 = eax_210;
				al_187 = (byte) (word32) al_170;
			}
			if (*((word32) edx_161 + 16) != 0x00)
				break;
			Eq_7749 al_348;
			word32 ebp_223 = (word32) *((word32) edx_161 + 5);
			Eq_4 eax_220 = *edx_161;
			ui24 ebx_24_8_239 = SLICE(ebp_223, word24, 8);
			Eq_7761 esi_254 = SEQ(SLICE(esi_180, word24, 8), eax_220 >> 0x1F == 0x00) & SEQ(ebx_24_8_239, eax_220 >= 0x08);
			Eq_7629 ebp_265 = SEQ(ebx_24_8_239, eax_220 >> 0x1F > 0x00) | esi_254;
			byte al_227 = (byte) ebp_223;
			Eq_363 ebx_24_8_278 = SLICE(eax_220, word24, 8);
			Eq_7629 ebp_273 = ebp_265;
			if ((byte) ebp_265 == 0x00)
				al_348.u0 = 0x00;
			else
			{
				runtime.int64tofloat64(ebx_24_8_278, gs, SEQ(eax_220 >> 0x1F, eax_220));
				word32 ecx_293 = (word32) al_227;
				cu8 cl_306 = (byte) -(ecx_293 + ~0x1F);
				Eq_4 edx_321 = 0x01 >> cl_306 & 0x00 - (cl_306 < 0x20) | 0x01 << (byte) (ecx_293 + ~0x1F) & 0x00 - ((byte) (ecx_293 + ~0x1F) < 0x20);
				runtime.uint64tofloat64(gs, edx_321);
				uint128 xmm2_340 = (uint128) (uint32) g_r80F1808;
				dwLoc54_808 = edx_321;
				al_348 = (real32) (uint128) (uint64) (real64) (uint128) (uint64) rLoc50_975 >= SEQ(SLICE(xmm2_340, uir96, 32), (real32) xmm2_340 * (real32) ((uint128) ((uint64) rLoc50_975)));
				edx_161 = dwArg08;
			}
			if (al_348 == 0x00)
			{
				Eq_7839 al_370;
				word32 ebx_363 = (word32) *((word32) edx_161 + 5);
				cup16 ax_367 = (word16) (word32) *((word32) edx_161 + 6);
				if ((byte) ebx_363 < 0x10)
				{
					cu8 cl_376 = (byte) ebx_363;
					esi_254 = 0x01 << cl_376 & 0x00 - (cl_376 < 0x20);
					al_370 = ax_367 >= (word16) esi_254;
				}
				else
					al_370 = ax_367 >= 0x8000;
				ebp_273 = ecx_179;
				if (al_370 == 0x00)
					break;
			}
			runtime.hashGrow(ebp_273, esi_254, gs, dwArg04, edx_161);
			dwLoc54_808 = edx_161;
		}
		Eq_4 eax_429;
		Eq_4 edi_428 = edi_181;
		Eq_7629 ebp_390 = ecx_179;
		if (ecx_179 != 0x00)
			eax_429 = esi_180;
		else
		{
			runtime.(*hmap).newoverflow(gs, edx_161, dwArg04, ebx_166);
			dwLoc54_808 = dwArg04;
			ebp_390 = dwLoc4C_859;
			edi_428 = (word32) dwLoc4C_859 + 8 + (word32) (*((word32) dwArg04 + 48)) * 0x08;
			eax_429 = (word32) dwLoc4C_859 + 8;
		}
		if ((byte) (word32) *((word32) dwArg04 + 49) != 0x00)
		{
			runtime.newobject(gs, *((word32) dwArg04 + 32));
			if (g_t81576F0 == 0x00)
				*eax_429 = dwLoc54_808;
			else
				runtime.writebarrierptr(eax_429, dwLoc54_808);
			eax_429 = dwLoc54_808;
		}
		if ((byte) (word32) *((word32) dwArg04 + 0x0033) != 0x00)
		{
			runtime.newobject(gs, *((word32) dwArg04 + 36));
			if (g_t81576F0 == 0x00)
				*edi_428 = dwLoc54_808;
			else
				runtime.writebarrierptr(edi_428, dwLoc54_808);
		}
		word32 edi_545;
		word32 esi_547;
		runtime.typedmemmove(*((word32) dwArg04 + 32), eax_429, dwArg0C, out esi_547, out edi_545);
		*ebp_390 = (byte) (word32) al_170;
		*dwArg08 = (word32) *dwArg08 + 1;
l0804F2EF:
		ui32 edx_678 = (word32) *((word32) dwArg08 + 4);
		if (((byte) edx_678 & 0x04) == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) dwArg08 + 4) = (byte) (edx_678 & ~0x04);
			(byte) (word32) *((word32) dwArg04 + 0x0033) == 0x00;
		}
	}
}

// 0804F700: Register (ptr32 word32) runtime.mapiterinit(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.mapiterinit
//      sync.(*Map).dirtyLocked
word32 * runtime.mapiterinit(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t81576F0 == 0x00)
	{
		*dwArg0C = 0x00;
		*((word32) dwArg0C + 4) = 0x00;
		((word32) dwArg0C + 8)->u0 = 0x00;
		((word32) dwArg0C + 0x0C)->u0 = 0x00;
		((word32) dwArg0C + 16)->u0 = 0x00;
		((word32) dwArg0C + 20)->u0 = 0x00;
		((word32) dwArg0C + 24)->u0 = 0x00;
		((word32) dwArg0C + 28)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr(dwArg0C, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 4, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 8, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 0x0C, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 16, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 20, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 24, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 28, 0x00);
		dwLoc28.u0 = 0x00;
	}
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
	{
		if (g_t81576F0 == 0x00)
		{
			*dwArg0C = 0x00;
			*((word32) dwArg0C + 4) = 0x00;
		}
		else
		{
			runtime.writebarrierptr(dwArg0C, 0x00);
			runtime.writebarrierptr((word32) dwArg0C + 4, 0x00);
		}
		return (word32) dwArg0C + 4;
	}
	else
	{
		if (g_t81576F0 == 0x00)
		{
			*((word32) dwArg0C + 8) = dwArg04;
			*((word32) dwArg0C + 0x0C) = dwArg08;
		}
		else
		{
			runtime.writebarrierptr((word32) dwArg0C + 8, dwArg04);
			runtime.writebarrierptr((word32) dwArg0C + 0x0C, dwArg08);
			dwLoc28 = dwArg08;
		}
		*((word32) dwArg0C + 38) = (byte) (word32) *((word32) dwArg08 + 5);
		Eq_4 ebp_190 = *((word32) dwArg08 + 0x0C);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg0C + 16) = ebp_190;
		else
		{
			runtime.writebarrierptr((word32) dwArg0C + 16, ebp_190);
			dwLoc28 = ebp_190;
		}
		if (((byte) (word32) *((word32) *((word32) dwArg04 + 40) + 0x0F) & 0x80) != 0x00)
		{
			if (*((word32) dwArg08 + 24) == 0x00)
			{
				runtime.newobject(gs, 135085088);
				if (g_t81576F0 == 0x00)
					*((word32) dwArg08 + 24) = dwLoc28;
				else
					runtime.writebarrierptr((word32) dwArg08 + 24, dwLoc28);
			}
			if (**((word32) dwArg08 + 24) == 0x00)
			{
				runtime.newobject(gs, 0x080C9100);
				Eq_4 ecx_281 = *((word32) dwArg08 + 24);
				if (g_t81576F0 == 0x00)
					*ecx_281 = dwLoc28;
				else
					runtime.writebarrierptr(ecx_281, dwLoc28);
			}
			Eq_4 ebx_307 = *((word32) dwArg08 + 24);
			if (g_t81576F0 == 0x00)
			{
				Eq_4 ebp_348 = *((word32) ebx_307 + 4);
				*((word32) dwArg0C + 24) = *ebx_307;
				*((word32) dwArg0C + 28) = ebp_348;
			}
			else
			{
				word32 esi_648;
				word32 edi_649;
				runtime.typedmemmove(0x080CC320, (word32) dwArg0C + 24, ebx_307, out esi_648, out edi_649);
			}
		}
		Eq_8137 ebx_371;
		Eq_4 ebx_358 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		Eq_8137 ebp_359 = *((word32) ebx_358 + 0x0094);
		Eq_8137 esi_364 = ebp_359 << 0x01 ^ ebp_359 >> 0x1F & 0xA8888EEF;
		*((word32) ebx_358 + 0x0094) = esi_364;
		if ((byte) (word32) *((word32) dwArg08 + 5) > 0x1C)
		{
			Eq_4 ebx_374 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
			int32 ebp_375 = *((word32) ebx_374 + 0x0094);
			int32 edi_380 = ebp_375 << 0x01 ^ ebp_375 >> 0x1F & 0xA8888EEF;
			*((word32) ebx_374 + 0x0094) = edi_380;
			ebx_371 = (word32) esi_364 + (edi_380 << 0x1F);
		}
		else
			ebx_371 = esi_364;
		cu8 cl_389 = (byte) (word32) *((word32) dwArg08 + 5);
		*((word32) dwArg0C + 32) = (0x01 << cl_389 & 0x00 - (cl_389 < 0x20)) - 0x01 & ebx_371;
		cu8 cl_403 = (byte) (word32) *((word32) dwArg08 + 5);
		*((word32) dwArg0C + 36) = (byte) (ebx_371 >> cl_403 & 0x00 - (cl_403 < 0x20) & 0x07);
		*((word32) dwArg0C + 40) = *((word32) dwArg0C + 32);
		*((word32) dwArg0C + 37) = 0x00;
		if (g_t81576F0 == 0x00)
			((word32) dwArg0C + 20)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) dwArg0C + 20, 0x00);
		if ((byte) ((word32) *((word32) dwArg08 + 4) & 0x03) != 0x03)
			runtime/internal/atomic.Or8((word32) dwArg08 + 4, 0x03);
		return runtime.mapiternext(gs, dwArg0C);
	}
}

// 0804FB30: Register Eq_4 runtime.mapiternext(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mapiterinit
//      reflect.mapiternext
//      sync.(*Map).dirtyLocked
Eq_4 runtime.mapiternext(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_18 = *((word32) dwArg04 + 0x0C);
	if (((byte) (word32) *((word32) ebx_18 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ebp_40 = *((word32) dwArg04 + 8);
		Eq_4 edi_229 = *((word32) dwArg04 + 40);
		Eq_4 ecx_138 = ebp_40;
		Eq_4 ebp_232 = *((word32) dwArg04 + 20);
		Eq_4 edx_107 = ebx_18;
		uip32 ebx_1173 = (word32) *((word32) dwArg04 + 39);
		Eq_4 eax_236 = *((word32) dwArg04 + 44);
		Eq_4 esi_49 = *((word32) *((word32) ebp_40 + 32) + 16);
		Eq_4 dwLoc44_1162 = dwLoc44;
		while (true)
		{
			uip32 ebx_1166 = ebx_1173;
			if (ebp_232 == 0x00)
			{
				if (edi_229 == *((word32) dwArg04 + 32))
				{
					Eq_4 ebx_62 = (word32) *((word32) dwArg04 + 37);
					if ((byte) ebx_62 != 0x00)
					{
						if (g_t81576F0 == 0x00)
							dwArg04->u0 = 0x00;
						else
							runtime.writebarrierptr(dwArg04, 0x00);
						if (g_t81576F0 == 0x00)
							((word32) dwArg04 + 4)->u0 = 0x00;
						else
							runtime.writebarrierptr((word32) dwArg04 + 4, 0x00);
						return ebx_62;
					}
				}
				Eq_4 ebx_147;
				Eq_4 ecx_149;
				Eq_4 ebx_109 = *((word32) edx_107 + 16);
				if (ebx_109 != 0x00 && (byte) ((word32) (*((word32) dwArg04 + 38))) == (byte) ((word32) (*((word32) edx_107 + 5))))
				{
					Eq_4 ebp_150 = *((word32) dwArg04 + 0x0C);
					word32 esi_151 = (word32) *((word32) ebp_150 + 5);
					if (((byte) (word32) *((word32) ebp_150 + 4) & 0x08) == 0x00)
						--esi_151;
					cu8 cl_174 = (byte) esi_151;
					int32 esi_183 = (word32) *((word32) ecx_138 + 52);
					Eq_4 eax_186 = (word32) ebx_109 + ((0x01 << cl_174 & 0x00 - (cl_174 < 0x20)) - 0x01 & edi_229) *s esi_183;
					if ((byte) ((word32) *eax_186 - 0x01) < 0x03)
					{
						ebx_147 = (word32) *((word32) dwArg04 + 16) + esi_183 *s edi_229;
						ecx_149.u0 = ~0x00;
					}
					else
					{
						ecx_149 = edi_229;
						ebx_147 = eax_186;
					}
				}
				else
				{
					ebx_147 = (word32) *((word32) dwArg04 + 16) + (word32) (*((word32) ecx_138 + 52)) *s edi_229;
					ecx_149.u0 = ~0x00;
				}
				Eq_4 eax_219;
				cu8 cl_211 = (byte) (word32) *((word32) dwArg04 + 38);
				Eq_4 esi_206 = (word32) edi_229 + 1;
				if (esi_206 == (0x00 - (cl_211 < 0x20) & 0x01 << cl_211))
				{
					*((word32) dwArg04 + 37) = 0x01;
					eax_219.u0 = 0x00;
				}
				else
					eax_219 = esi_206;
				ecx_138 = ebp_40;
				edi_229 = eax_219;
				ebp_232 = ebx_147;
				eax_236 = ecx_149;
				ebx_1166 = 0x00;
			}
			uip32 ebx_1158 = ebx_1166;
			while (true)
			{
				word24 nLoc43_869 = SLICE(dwLoc44_1162, word24, 8);
				byte bLoc44_853 = (byte) dwLoc44_1162;
				cu8 bl_245 = (byte) ebx_1158;
				uip32 ebx_263 = ebx_1158;
				if (bl_245 >= 0x08)
					break;
				ui32 edi_264 = (word32) *((word32) dwArg04 + 36) + ebx_1158;
				ui32 edi_282 = (word32) (byte) edi_264;
				int32 esi_275 = (word32) *((word32) ecx_138 + 48);
				word32 edi_285 = (word32) *((word32) ebp_232 + (edi_282 & 0x07));
				Eq_4 esi_286 = (word32) ebp_232 + (esi_275 *s (edi_264 & 0x07) + 0x08);
				Eq_4 eax_1165 = (word32) ebp_232 + (((word32) (*((word32) ecx_138 + 50)) *s (edi_264 & 0x07) + esi_275 * 0x08) + 0x08);
				if ((byte) edi_285 != 0x00)
				{
					ebx_263 = ebx_1158;
					if ((byte) edi_285 == 0x01)
						goto l0804FB8A;
					word24 nLoc43_1061;
					if (eax_236 != ~0x00 && ((byte) ((word32) (*((word32) edx_107 + 4))) & 0x08) == 0x00)
					{
						Eq_4 edi_339;
						if ((byte) (word32) *((word32) ecx_138 + 49) != 0x00)
							edi_339 = *esi_286;
						else
							edi_339 = esi_286;
						nLoc43_1061 = nLoc43_869;
						byte bLoc44_1152 = (byte) dwLoc44_1162;
						nLoc43_1061 = SLICE(dwLoc44_1162, word24, 8);
						if ((byte) (word32) *((word32) ecx_138 + 54) == 0x00)
						{
							<anonymous> ** edx_352 = *((word32) esi_49 + 4);
							(*edx_352)();
							if ((byte) (word32) bLoc44_853 == 0x00)
							{
								cu8 cl_374 = (byte) ((word32) *((word32) dwArg04 + 38) - 0x01);
								if ((eax_236 >> cl_374 & 0x00 - (cl_374 < 0x20)) == ((word32) (*((word32) ebp_232 + (edi_282 & 0x07))) & 0x01))
									goto l0804FC90;
								ecx_138 = ebp_40;
								edx_107 = ebx_18;
								ebx_263 = (word32) bl_245;
								goto l0804FB8A;
							}
							edx_107 = ebx_18;
						}
						<anonymous> ** ecx_393 = *esi_49;
						(*ecx_393)();
						word32 eax_409 = (word32) *((word32) dwArg04 + 38);
						if ((dwLoc44_1162 & (0x01 << (byte) eax_409 & 0x00 - ((byte) eax_409 < 0x20)) - 0x01) == eax_236)
							goto l0804FC90;
						ecx_138 = ebp_40;
						edx_107 = ebx_18;
						ebx_263 = (word32) bl_245;
						goto l0804FB8A;
					}
l0804FC90:
					byte cl_432 = (byte) (word32) *((word32) ebp_232 + (edi_282 & 0x07));
					if (cl_432 != 0x02 && cl_432 != 0x03)
					{
						Eq_4 edx_443;
						if ((byte) (word32) *((word32) ebp_40 + 49) != 0x00)
							edx_443 = *esi_286;
						else
							edx_443 = esi_286;
						if (g_t81576F0 == 0x00)
							*dwArg04 = edx_443;
						else
							runtime.writebarrierptr(dwArg04, edx_443);
						Eq_4 ecx_483;
						if ((byte) (word32) *((word32) ebp_40 + 0x0033) != 0x00)
							ecx_483 = *eax_1165;
						else
							ecx_483 = eax_1165;
						if (g_t81576F0 == 0x00)
							*((word32) dwArg04 + 4) = ecx_483;
						else
							runtime.writebarrierptr((word32) dwArg04 + 4, ecx_483);
						goto l0804FD2B;
					}
					if ((byte) (word32) *((word32) ebp_40 + 49) != 0x00)
						dwLoc44_1162 = *esi_286;
					else
						dwLoc44_1162 = esi_286;
					if ((byte) (word32) *((word32) ebp_40 + 54) == 0x00)
					{
						<anonymous> ** edx_554 = *((word32) esi_49 + 4);
						(*edx_554)();
						if ((byte) (word32) bLoc44_853 == 0x00)
						{
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc44_1162;
							else
								runtime.writebarrierptr(dwArg04, dwLoc44_1162);
							if ((byte) (word32) *((word32) ebp_40 + 0x0033) != 0x00)
								eax_1165 = *eax_1165;
							if (g_t81576F0 == 0x00)
								*((word32) dwArg04 + 4) = eax_1165;
							else
								runtime.writebarrierptr((word32) dwArg04 + 4, eax_1165);
l0804FD2B:
							*((word32) dwArg04 + 40) = edi_229;
							if (*((word32) dwArg04 + 20) != ebp_232)
							{
								if (g_t81576F0 == 0x00)
									*((word32) dwArg04 + 20) = ebp_232;
								else
									runtime.writebarrierptr((word32) dwArg04 + 20, ebp_232);
							}
							*((word32) dwArg04 + 39) = (byte) ((word32) bl_245 + 0x01);
							*((word32) dwArg04 + 44) = eax_236;
							return ebp_232;
						}
					}
					runtime.mapaccessK(gs, ebp_40, ebx_18, dwLoc44_1162);
					if (dwLoc40 == 0x00)
					{
						ecx_138 = ebp_40;
						edx_107 = ebx_18;
						ebx_263 = (word32) bl_245;
						goto l0804FB8A;
					}
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc40;
					else
						runtime.writebarrierptr(dwArg04, dwLoc40);
					if (g_t81576F0 == 0x00)
						*((word32) dwArg04 + 4) = dwLoc3C;
					else
						runtime.writebarrierptr((word32) dwArg04 + 4, dwLoc3C);
					goto l0804FD2B;
				}
l0804FB8A:
				ebx_1158 = ebx_263 + 0x01;
			}
			ebp_232 = ebp_232 - 0x04 + (word32) (*((word32) ecx_138 + 52));
			ebx_1173 = 0x00;
		}
	}
}

// 080500F0: Register ptr32 runtime.makeBucketArray(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08, Register out ptr32 ediOut)
// Called from:
//      runtime.makemap
//      runtime.hashGrow
ptr32 runtime.makeBucketArray(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_100;
	word32 ecx_17 = (word32) bArg08;
	cu8 cl_19 = (byte) ecx_17;
	Eq_4 ebx_24 = 0x00 - (cl_19 < 0x20) & 0x01 << cl_19;
	if (cl_19 < 0x04)
	{
		eax_100 = ebx_24;
		goto l080501AC;
	}
	Eq_8937 ecx_49;
	cu8 cl_33 = (byte) (ecx_17 + ~0x03);
	Eq_4 esi_39 = (word32) ebx_24 + (0x01 << cl_33 & 0x00 - (cl_33 < 0x20));
	Eq_8951 ebp_40 = **((word32) dwArg04 + 40);
	Eq_8937 ebp_42 = ebp_40 *s esi_39;
	if (ebp_42 >= 0x8000)
	{
		if ((word32) ebp_42 + 0x00002000 < ebp_42)
			ecx_49 = ebp_42;
		else
			ecx_49 = (word32) ebp_42 + 0x00001FFF & ~0x1FFF;
l08050194:
		if (ecx_49 != ebp_42)
		{
			if (ebp_40 == 0x00)
				runtime.panicdivide(gs);
			eax_100 = (uint32) ((uint64) (uint32) ecx_49 /u ebp_40);
		}
		else
			eax_100 = esi_39;
l080501AC:
		ptr32 edi_115;
		ptr32 esi_117 = runtime.newarray(gs, *((word32) dwArg04 + 40), eax_100, out edi_115);
		if (eax_100 != ebx_24)
		{
			int32 ebx_131 = (word32) *((word32) dwArg04 + 52);
			Eq_4 ecx_136 = (word32) dwLoc14 + (eax_100 - 0x01) *s ebx_131 - 0x04 + ebx_131;
			if (g_t81576F0 == 0x00)
				*ecx_136 = dwLoc14;
			else
				runtime.writebarrierptr(ecx_136, dwLoc14);
		}
		ediOut = edi_115;
		return esi_117;
	}
	else
	{
		if (ebp_42 <= 1016)
		{
			struct Eq_8974 * ecx_70 = (word32) ebp_42 + 7 >> 0x03;
			if (ecx_70 < (struct Eq_8974 *) 0x81)
			{
				uint32 ecx_75 = (word32) ecx_70->b8138640;
				if (ecx_75 < 0x43)
				{
					ecx_49 = (word32) g_a8138820[ecx_75 * 0x02];
					goto l08050194;
				}
			}
			runtime.panicindex(gs);
		}
		struct Eq_8967 * ecx_58 = ebp_42 - 0x0381 >> 0x07;
		if (ecx_58 < (struct Eq_8967 *) 0xF9)
		{
			uint32 ecx_63 = (word32) ecx_58->b81396E0;
			if (ecx_63 < 0x43)
			{
				ecx_49 = (word32) g_a8138820[ecx_63 * 0x02];
				goto l08050194;
			}
		}
		runtime.panicindex(gs);
	}
}

// 080502B0: Register uint128 runtime.hashGrow(Register Eq_7629 ebp, Register Eq_7761 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.mapassign
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
uint128 runtime.hashGrow(Eq_7629 ebp, Eq_7761 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 dwLoc28_440 = (word32) rLoc28;
	Eq_4 dwLoc24_443 = SLICE(rLoc28, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uip32 ecx_565;
	word32 ebx_21 = (word32) *((word32) dwArg08 + 5);
	Eq_9078 ecx_18 = *dwArg08;
	ui24 ebx_24_8_44 = SLICE(esi, word24, 8);
	byte bl_70 = (byte) ebx_21;
	Eq_363 ebx_24_8_74 = SLICE(ebx_21, word24, 8);
	if ((byte) (SEQ(ebx_24_8_44, ecx_18 >> 0x1F > 0x00) | SEQ(SLICE(ebp, word24, 8), ecx_18 >> 0x1F == 0x00) & SEQ(ebx_24_8_44, ecx_18 >= 0x08)) == 0x00)
		ecx_565 = 0x00;
	else
	{
		runtime.int64tofloat64(ebx_24_8_74, gs, SEQ(ecx_18 >> 0x1F, ecx_18));
		word32 ecx_88 = (word32) bl_70;
		cu8 cl_99 = (byte) (ecx_88 + ~0x1F);
		cu8 cl_107 = (byte) -(ecx_88 + ~0x1F);
		Eq_4 eax_113 = 0x01 >> cl_107 & 0x00 - (cl_107 < 0x20) | 0x00 - (cl_99 < 0x20) & 0x01 << cl_99;
		word24 ecx_24_8_169 = SLICE(runtime.uint64tofloat64(gs, eax_113), word24, 8);
		uint128 xmm1_129 = (uint128) (uint64) rLoc28;
		uint128 xmm2_132 = (uint128) (uint32) g_r80F1808;
		nLoc2B = SLICE(eax_113, word24, 8);
		xmm1 = xmm1_129;
		ecx_565 = SEQ(ecx_24_8_169, (real32) (uint128) (uint64) (real64) (uint128) (uint64) rLoc28 >= SEQ(SLICE(xmm2_132, uir96, 32), (real32) xmm2_132 * (real32) xmm1_129));
	}
	byte cl_145 = (byte) ecx_565;
	if (cl_145 == 0x00)
		*((word32) dwArg08 + 4) = (byte) ((word32) *((word32) dwArg08 + 4) | 0x08);
	Eq_4 edx_163 = *((word32) dwArg08 + 0x0C);
	byte bl_173 = (byte) ((word32) *((word32) dwArg08 + 5) + ecx_565);
	word32 edi_568;
	runtime.makeBucketArray(gs, dwArg04, bl_173, out edi_568);
	ui32 ebp_195 = (word32) *((word32) dwArg08 + 4);
	ui32 ebp_197 = ebp_195 & ~0x03;
	Eq_4 dwLoc2C_452 = SEQ(nLoc2B, bl_173);
	if (((byte) ebp_195 & 0x01) != 0x00)
		ebp_197 = ebp_195 & ~0x03 | 0x02;
	*((word32) dwArg08 + 5) = (byte) ((word32) *((word32) dwArg08 + 5) + cl_145);
	*((word32) dwArg08 + 4) = (byte) ebp_197;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg08 + 16) = edx_163;
		*((word32) dwArg08 + 0x0C) = dwLoc28_440;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg08 + 16, edx_163);
		runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc28_440);
		dwLoc2C_452 = dwLoc28_440;
	}
	((word32) dwArg08 + 20)->u0 = 0x00;
	((word32) dwArg08 + 6)->u1 = 0x00;
	Eq_4 ecx_273 = *((word32) dwArg08 + 24);
	if (ecx_273 != 0x00)
	{
		Eq_4 ebp_280 = *ecx_273;
		if (ebp_280 != 0x00)
		{
			if (*((word32) ecx_273 + 4) != 0x00)
				runtime.throw(gs);
			if (g_t81576F0 == 0x00)
				*((word32) ecx_273 + 4) = ebp_280;
			else
			{
				runtime.writebarrierptr((word32) ecx_273 + 4, ebp_280);
				dwLoc2C_452 = ebp_280;
			}
			Eq_4 ecx_320 = *((word32) dwArg08 + 24);
			if (g_t81576F0 == 0x00)
				*ecx_320 = 0x00;
			else
			{
				runtime.writebarrierptr(ecx_320, 0x00);
				dwLoc2C_452.u0 = 0x00;
			}
		}
	}
	if (dwLoc24_443 != 0x00)
	{
		if (*((word32) dwArg08 + 24) == 0x00)
		{
			runtime.newobject(gs, 135085088);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 24) = dwLoc2C_452;
			else
				runtime.writebarrierptr((word32) dwArg08 + 24, dwLoc2C_452);
		}
		Eq_4 eax_391 = *((word32) dwArg08 + 24);
		if (g_t81576F0 == 0x00)
			*((word32) eax_391 + 8) = dwLoc24_443;
		else
			runtime.writebarrierptr((word32) eax_391 + 8, dwLoc24_443);
	}
	return xmm1;
}

// 08050590: void runtime.growWork(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg0C)
// Called from:
//      runtime.mapassign
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
void runtime.growWork(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, int32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_18 = (word32) *((word32) dwArg08 + 5);
	if (((byte) (word32) *((word32) dwArg08 + 4) & 0x08) == 0x00)
		--edx_18;
	cu8 cl_35 = (byte) edx_18;
	runtime.evacuate(gs, dwArg04, dwArg08, (0x01 << cl_35 & 0x00 - (cl_35 < 0x20)) - 0x01 & dwArg0C);
	if (*((word32) dwArg08 + 16) != 0x00)
		runtime.evacuate(gs, dwArg04, dwArg08, *((word32) dwArg08 + 20));
}

// 08050620: void runtime.evacuate(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.growWork
void runtime.evacuate(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp - 0x1C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 edi_22 = (word32) *((word32) dwArg04 + 52);
	int32 edi_26 = edi_22 *s dwArg0C;
	word32 edi_30 = (word32) *((word32) dwArg08 + 4);
	byte * ebx_28 = (word32) *((word32) dwArg08 + 16) + edi_26;
	word32 ebp_29 = (word32) *((word32) dwArg08 + 5);
	if (((byte) edi_30 & 0x08) == 0x00)
		--ebp_29;
	cu8 cl_62 = (byte) ebp_29;
	byte al_51 = (byte) edi_30;
	Eq_4 edi_57 = *((word32) *((word32) dwArg04 + 32) + 16);
	Eq_4 edi_67 = 0x01 << cl_62 & 0x00 - (cl_62 < 0x20);
	if ((byte) ((word32) *ebx_28 - 0x01) >= 0x03)
	{
		Eq_4 edx_108;
		Eq_4 ecx_105;
		Eq_4 eax_109;
		Eq_4 ecx_81 = *((word32) dwArg08 + 0x0C);
		Eq_4 esi_84 = (word32) ecx_81 + edi_26;
		ui32 ebp_82 = (word32) *((word32) dwArg04 + 48);
		Eq_4 ebx_260 = esi_84;
		Eq_4 eax_86 = (word32) ecx_81 + 8 + edi_26;
		Eq_4 esi_257 = (word32) esi_84 + 8 + ebp_82 * 0x08;
		if (((byte) (word32) al_51 & 0x08) != 0x00)
		{
			eax_109.u0 = 0x00;
			ecx_105.u0 = 0x00;
			edx_108.u0 = 0x00;
		}
		else
		{
			word32 ebp_98 = (dwArg0C + edi_67) *s edi_22;
			Eq_4 ebp_100 = (word32) ecx_81 + ebp_98;
			ecx_105 = (word32) ecx_81 + (ebp_98 + 0x08);
			edx_108 = (word32) ebp_100 + 8 + ebp_82 * 0x08;
			eax_109 = ebp_100;
		}
		Eq_9592 dwLoc84_1175 = 0x00;
		Eq_4 dwLoc44_1001 = eax_86;
		Eq_9595 dwLoc88_1002 = 0x00;
		Eq_4 eax_128 = eax_109;
		byte * ebp_129 = ebx_28;
		while (ebp_129 != null)
		{
			Eq_4 dwLoc4C_1017 = eax_128;
			Eq_4 eax_197 = ebp_129 + 8;
			Eq_4 ebp_198 = ebp_129 + 8 + (word32) (*((word32) dwArg04 + 48)) * 0x08;
			Eq_9621 edi_199 = 0x00;
			while (true)
			{
				byte bLoc94_1047 = (byte) dwLoc94;
				if (edi_199 >= 0x08)
					break;
				if (edi_199 >= 0x08)
					runtime.panicindex(gs);
				Eq_9592 eax_804;
				byte al_222 = SLICE((word32) Mem219[ebp_129 + edi_199:byte], byte, 0);
				if (al_222 == 0x00)
				{
					Mem817[ebp_129 + edi_199:byte] = 0x01;
					eax_804 = dwLoc84_1175;
					goto l080507EB;
				}
				if (al_222 < 0x04)
					runtime.throw(gs);
				Eq_4 ecx_245;
				if ((byte) (word32) *((word32) dwArg04 + 49) != 0x00)
					ecx_245 = *eax_197;
				else
					ecx_245 = eax_197;
				Eq_9739 cl_386;
				if (((byte) (word32) *((word32) dwArg08 + 4) & 0x08) != 0x00)
				{
					cl_386.u1 = 0x01;
					goto l080508A0;
				}
				uint32 edx_292;
				<anonymous> ** edx_271 = *edi_57;
				(*edx_271)();
				Eq_4 eax_284 = dwLoc94;
				if (((byte) (word32) *((word32) dwArg08 + 4) & 0x01) != 0x00)
				{
					if ((byte) (word32) *((word32) dwArg04 + 54) != 0x00)
					{
l08050CE2:
						eax_284 = dwLoc94;
						edx_292 = (word32) al_222;
						goto l08050CE7;
					}
					<anonymous> ** edx_307 = *((word32) edi_57 + 4);
					(*edx_307)();
					if ((byte) (word32) bLoc94_1047 != 0x00)
						goto l08050CE2;
					Eq_4 eax_330;
					if (((byte) (word32) al_222 & 0x01) != 0x00)
						eax_330 = dwLoc94 | edi_67;
					else
						eax_330 = ~edi_67 & dwLoc94;
					uint32 eax_340 = eax_330 >> 0x18;
					if ((byte) eax_340 < 0x04)
						eax_340 += 0x04;
					edx_292 = eax_340;
					eax_284 = eax_330;
				}
				else
					edx_292 = (word32) al_222;
l08050CE7:
				cl_386 = (edi_67 & eax_284) == 0x00;
				al_222 = (byte) edx_292;
l080508A0:
				Eq_4 dwLoc50_1169;
				Eq_4 ebp_594;
				Eq_4 esi_593;
				Eq_9595 edi_595;
				Eq_4 ebx_598;
				Eq_9592 ecx_597;
				Eq_4 esi_626 = esi_257;
				Eq_4 ebx_607 = ebx_260;
				Eq_4 edx_427 = edx_108;
				if (cl_386 != 0x00)
				{
					Eq_4 dwLoc28_1194;
					byte al_641;
					Mem599[ebp_129 + edi_199:byte] = 0x02;
					Eq_9592 ecx_600 = dwLoc84_1175;
					if (dwLoc84_1175 != 0x08)
					{
						dwLoc28_1194 = dwLoc44_1001;
						al_641 = (byte) (word32) al_222;
					}
					else
					{
						runtime.(*hmap).newoverflow(gs, dwArg08, dwArg04, ebx_260);
						dwLoc94 = ebx_260;
						ebx_607 = dwLoc90;
						esi_626 = (word32) dwLoc90 + 8 + (word32) (*((word32) dwArg04 + 48)) * 0x08;
						al_641 = (byte) (word32) al_222;
						ecx_600.u0 = 0x00;
						dwLoc28_1194 = (word32) dwLoc90 + 8;
					}
					if (ecx_600 >= 0x08)
						runtime.panicindex(gs);
					Mem655[ebx_607 + ecx_600:byte] = al_641;
					if ((byte) (word32) *((word32) dwArg04 + 49) != 0x00)
					{
						if (g_t81576F0 == 0x00)
							*dwLoc28_1194 = ecx_245;
						else
							runtime.writebarrierptr(dwLoc28_1194, ecx_245);
					}
					else
					{
						word32 esi_1436;
						word32 edi_1437;
						runtime.typedmemmove(*((word32) dwArg04 + 32), dwLoc28_1194, eax_197, out esi_1436, out edi_1437);
						dwLoc94 = eax_197;
					}
					if ((byte) (word32) *((word32) dwArg04 + 0x0033) != 0x00)
					{
						Eq_4 ebx_761 = *ebp_198;
						if (g_t81576F0 == 0x00)
							*esi_626 = ebx_761;
						else
							runtime.writebarrierptr(esi_626, ebx_761);
					}
					else
					{
						word32 esi_1438;
						word32 edi_1439;
						runtime.typedmemmove(*((word32) dwArg04 + 36), esi_626, ebp_198, out esi_1438, out edi_1439);
						dwLoc94 = ebp_198;
					}
					ecx_597 = (word32) ecx_600.u0 + 1;
					ebx_598 = (word32) dwLoc28_1194 + (word32) (*((word32) dwArg04 + 48));
					ebp_594 = (word32) esi_626 + (word32) (*((word32) dwArg04 + 50));
					edi_595 = dwLoc88_1002;
					dwLoc50_1169 = ecx_105;
					esi_593 = ebx_607;
				}
				else
				{
					Eq_4 dwLoc34_1113;
					byte al_445;
					Mem395[ebp_129 + edi_199:byte] = 0x03;
					Eq_9595 ecx_396 = dwLoc88_1002;
					if (dwLoc88_1002 != 0x08)
					{
						dwLoc34_1113 = ecx_105;
						al_445 = (byte) (word32) al_222;
					}
					else
					{
						runtime.(*hmap).newoverflow(gs, dwArg08, dwArg04, dwLoc4C_1017);
						dwLoc94 = dwLoc4C_1017;
						edx_427 = (word32) dwLoc90 + 8 + (word32) (*((word32) dwArg04 + 48)) * 0x08;
						dwLoc4C_1017 = dwLoc90;
						ecx_396.u0 = 0x00;
						dwLoc34_1113 = (word32) dwLoc90 + 8;
						al_445 = (byte) (word32) al_222;
					}
					if (ecx_396 >= 0x08)
						runtime.panicindex(gs);
					Mem457[dwLoc4C_1017 + ecx_396:byte] = al_445;
					if ((byte) (word32) *((word32) dwArg04 + 49) != 0x00)
					{
						if (g_t81576F0 == 0x00)
							*dwLoc34_1113 = ecx_245;
						else
							runtime.writebarrierptr(dwLoc34_1113, ecx_245);
					}
					else
					{
						word32 esi_1440;
						word32 edi_1441;
						runtime.typedmemmove(*((word32) dwArg04 + 32), dwLoc34_1113, eax_197, out esi_1440, out edi_1441);
						dwLoc94 = eax_197;
					}
					if ((byte) (word32) *((word32) dwArg04 + 0x0033) != 0x00)
					{
						Eq_4 ebp_557 = *ebp_198;
						if (g_t81576F0 == 0x00)
							*edx_427 = ebp_557;
						else
							runtime.writebarrierptr(edx_427, ebp_557);
					}
					else
					{
						word32 edi_1443;
						word32 esi_1442;
						runtime.typedmemmove(*((word32) dwArg04 + 36), edx_427, ebp_198, out esi_1442, out edi_1443);
						dwLoc94 = ebp_198;
					}
					edx_108 = (word32) edx_427 + (word32) (*((word32) dwArg04 + 50));
					esi_593 = ebx_260;
					ebp_594 = esi_257;
					edi_595 = (word32) ecx_396.u0 + 1;
					dwLoc50_1169 = (word32) dwLoc34_1113 + (word32) (*((word32) dwArg04 + 48));
					ecx_597 = dwLoc84_1175;
					ebx_598 = dwLoc44_1001;
				}
				eax_804 = ecx_597;
				dwLoc44_1001 = ebx_598;
				dwLoc88_1002 = edi_595;
				ecx_105 = dwLoc50_1169;
				ebx_260 = esi_593;
				esi_257 = ebp_594;
l080507EB:
				dwLoc84_1175 = eax_804;
				edi_199 = (word32) edi_199 + 1;
				eax_197 = (word32) eax_197 + (word32) (*((word32) dwArg04 + 48));
				ebp_198 = (word32) ebp_198 + (word32) (*((word32) dwArg04 + 50));
			}
			ebp_129 = (byte *) (ebp_129 - 0x04 + (word32) (*((word32) dwArg04 + 52)));
			eax_128 = dwLoc4C_1017;
		}
		if (((byte) (word32) *((word32) dwArg08 + 4) & 0x02) == 0x00)
		{
			int32 ebp_145 = (word32) *((word32) dwArg04 + 52);
			Eq_4 ebx_144 = *((word32) dwArg08 + 16);
			int32 ebp_148 = ebp_145 *s dwArg0C;
			if (((byte) (word32) *((word32) *((word32) dwArg04 + 40) + 0x0F) & 0x80) == 0x00)
				runtime.memclrHasPointers(gs, (word32) ebx_144 + 8 + ebp_148, ebp_145 + ~0x07);
			else
				runtime.memclrNoHeapPointers((word32) ebx_144 + 8 + ebp_148, ebp_145 + ~0x07);
		}
	}
	Eq_4 edi_847 = edi_67;
	if (dwArg0C == *((word32) dwArg08 + 20))
	{
		*((word32) dwArg08 + 20) = (word32) dwArg0C + 1;
		if ((word32) dwArg0C + 0x0401 <= edi_67)
			edi_847 = (word32) dwArg0C + 0x0401;
		while (true)
		{
			Eq_4 edx_858 = *((word32) dwArg08 + 20);
			if (edx_858 == edi_847 || (byte) ((word32) (*((word32) (*((word32) dwArg08 + 16)) + (word32) (*((word32) dwArg04 + 52)) *s edx_858)) - 0x01) >= 0x03)
				break;
			*((word32) dwArg08 + 20) = (word32) edx_858 + 1;
		}
		if (edi_67 == edx_858)
		{
			if (g_t81576F0 == 0x00)
				((word32) dwArg08 + 16)->u0 = 0x00;
			else
				runtime.writebarrierptr((word32) dwArg08 + 16, 0x00);
			Eq_4 ecx_903 = *((word32) dwArg08 + 24);
			if (ecx_903 != 0x00)
			{
				if (g_t81576F0 == 0x00)
					*((word32) ecx_903 + 4) = 0x00;
				else
					runtime.writebarrierptr((word32) ecx_903 + 4, 0x00);
			}
			*((word32) dwArg08 + 4) = (byte) ((word32) *((word32) dwArg08 + 4) & ~0x08);
		}
	}
}

// 08050EF0: void reflect.mapaccess(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack ptr32 dwArg0C)
// Called from:
//      reflect.Value.MapIndex
void reflect.mapaccess(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_75;
	runtime.mapaccess2(gs, dwArg04, dwArg08, dwArg0C, out esi_75);
}

// 08050F50: void reflect.mapiterinit(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.Value.MapKeys
void reflect.mapiterinit(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080DB6A0);
	runtime.mapiterinit(gs, dwArg04, dwArg08, dwLoc0C);
}

// 08050FB0: void reflect.mapiternext(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.MapKeys
void reflect.mapiternext(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.mapiternext(gs, dwArg04);
}

// 08050FE0: void reflect.mapiterkey(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.Value.MapKeys
void reflect.mapiterkey(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 08051010: void reflect.maplen(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.Len
//      reflect.Value.MapKeys
void reflect.maplen(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		;
}

// 08051050: Register Eq_4 runtime.mapaccess1_fast32(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_10098 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typelinksinit
//      reflect.(*structType).FieldByNameFunc
Eq_4 runtime.mapaccess1_fast32(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_10098 & esiOut, union Eq_4 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
	{
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
	else if (((byte) (word32) *((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_108;
		if ((byte) (word32) *((word32) dwArg08 + 5) == 0x00)
			eax_108 = *((word32) dwArg08 + 0x0C);
		else
		{
			<anonymous> ** edx_50 = **((word32) *((word32) dwArg04 + 32) + 16);
			<anonymous> * ecx_55 = *edx_50;
			ecx_55();
			cu8 cl_67 = (byte) (word32) *((word32) dwArg08 + 5);
			uint32 esi_72 = 0x01 << cl_67 & 0x00 - (cl_67 < 0x20);
			int32 eax_77 = (word32) *((word32) dwArg04 + 52);
			ebx = dwArg08;
			esi = esi_72 - 0x01;
			edi = *((word32) dwArg08 + 16);
			Eq_4 ecx_105 = (word32) *((word32) dwArg08 + 0x0C) + (esi_72 - 0x01 & dwLoc04) *s eax_77;
			if (edi != 0x00)
			{
				ebx = (word32) *((word32) dwArg08 + 4);
				if (((byte) ebx & 0x08) == 0x00)
					esi = esi_72 - 0x01 >> 0x01;
				esi = (esi & dwLoc04) *s eax_77;
				word32 eax_98 = edi + esi;
				if ((byte) ((word32) *eax_98 - 0x01) >= 0x03)
					ecx_105 = eax_98;
			}
			eax_108 = ecx_105;
		}
		do
		{
			Eq_10192 ecx_110 = 0x00;
			while (ecx_110 < 0x08)
			{
				ebx = *((word32) eax_108 + (ecx_110 * 0x04 + 8));
				if (ebx == dwArg0C)
				{
					ebx = (word32) Mem160[ecx_110 + eax_108:byte];
					if ((byte) ebx != 0x00)
					{
						esiOut = esi;
						ediOut = edi;
						return ebx;
					}
				}
				ecx_110 = (word32) ecx_110 + 1;
			}
			eax_108 = *((word32) (eax_108 - 0x04) + (word32) (*((word32) dwArg04 + 52)));
		} while (eax_108 != 0x00);
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
}

// 080511B0: void runtime.mapaccess2_fast32(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_10246) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.addReflectOff
//      runtime.resolveNameOff
void runtime.mapaccess2_fast32(struct Eq_2 * gs, struct Eq_10246 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
		return;
	if (((byte) (word32) *((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_109;
		if ((byte) (word32) *((word32) dwArg08 + 5) == 0x00)
			eax_109 = *((word32) dwArg08 + 0x0C);
		else
		{
			<anonymous> ** edx_51 = *dwArg04->ptr0020->ptr0010;
			<anonymous> * ecx_56 = *edx_51;
			ecx_56();
			cu8 cl_68 = (byte) (word32) *((word32) dwArg08 + 5);
			uint32 esi_73 = 0x01 << cl_68 & 0x00 - (cl_68 < 0x20);
			int32 eax_78 = (word32) dwArg04->w0034;
			uint32 esi_76 = esi_73 - 0x01;
			Eq_4 edi_80 = *((word32) dwArg08 + 16);
			Eq_4 ecx_106 = (word32) *((word32) dwArg08 + 0x0C) + (esi_73 - 0x01 & dwLoc04) *s eax_78;
			if (edi_80 != 0x00)
			{
				if (((byte) (word32) *((word32) dwArg08 + 4) & 0x08) == 0x00)
					esi_76 = esi_73 - 0x01 >> 0x01;
				Eq_4 eax_99 = (word32) edi_80 + (esi_76 & dwLoc04) *s eax_78;
				if ((byte) ((word32) *eax_99 - 0x01) >= 0x03)
					ecx_106 = eax_99;
			}
			eax_109 = ecx_106;
		}
		do
		{
			Eq_10341 ecx_111 = 0x00;
			while (ecx_111 < 0x08)
			{
				if (*((word32) eax_109 + (ecx_111 * 0x04 + 8)) == dwArg0C && SLICE((word32) Mem163[ecx_111 + eax_109:byte], byte, 0) != 0x00)
					return;
				ecx_111 = (word32) ecx_111 + 1;
			}
			eax_109 = *((word32) (eax_109 - 0x04) + (word32) dwArg04->w0034);
		} while (eax_109 != 0x00);
	}
}

// 08051320: Register Eq_4 runtime.mapaccess2_fast64(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_10396) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_4 ediOut)
// Called from:
//      runtime.typesEqual
Eq_4 runtime.mapaccess2_fast64(struct Eq_2 * gs, struct Eq_10396 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_4 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
	{
		ediOut = edi;
		return esi;
	}
	else if (((byte) (word32) *((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_112;
		if ((byte) (word32) *((word32) dwArg08 + 5) == 0x00)
			eax_112 = *((word32) dwArg08 + 0x0C);
		else
		{
			<anonymous> ** edx_53 = *dwArg04->ptr0020->ptr0010;
			<anonymous> * ecx_58 = *edx_53;
			ecx_58();
			cu8 cl_71 = (byte) (word32) *((word32) dwArg08 + 5);
			uint32 esi_76 = 0x01 << cl_71 & 0x00 - (cl_71 < 0x20);
			int32 eax_81 = (word32) dwArg04->w0034;
			esi = esi_76 - 0x01;
			edi = *((word32) dwArg08 + 16);
			Eq_4 ecx_109 = (word32) *((word32) dwArg08 + 0x0C) + (esi_76 - 0x01 & dwLoc04) *s eax_81;
			if (edi != 0x00)
			{
				if (((byte) (word32) *((word32) dwArg08 + 4) & 0x08) == 0x00)
					esi = esi_76 - 0x01 >> 0x01;
				esi = (esi & dwLoc04) *s eax_81;
				word32 eax_102 = edi + esi;
				if ((byte) ((word32) *eax_102 - 0x01) >= 0x03)
					ecx_109 = eax_102;
			}
			eax_112 = ecx_109;
		}
		do
		{
			Eq_10492 ecx_114 = 0x00;
			while (ecx_114 < 0x08)
			{
				word32 ebx_138 = eax_112 + 0x08 + ecx_114 * 0x08;
				Eq_4 ebx_140 = ebx_138->t0000;
				Eq_4 ebp_139 = ebx_138->t0004;
				esi = dwArg0C;
				edi = dwArg10;
				if ((byte) (SEQ(SLICE(ebp_139, word24, 8), ebp_139 != dwArg10) | SEQ(SLICE(ebx_140, word24, 8), ebx_140 != dwArg0C)) == 0x00 && SLICE((word32) Mem193[ecx_114 + eax_112:byte], byte, 0) != 0x00)
				{
					ediOut = dwArg10;
					return dwArg0C;
				}
				ecx_114 = (word32) ecx_114 + 1;
			}
			eax_112 = *((word32) (eax_112 - (struct Eq_10521 *) 0x04) + (word32) dwArg04->w0034);
		} while (eax_112 != 0x00);
		ediOut = edi;
		return esi;
	}
}

// 080514B0: Register int32 runtime.mapassign_fast32(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.addReflectOff
//      runtime.typelinksinit
//      reflect.(*structType).FieldByNameFunc
int32 runtime.mapassign_fast32(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	Eq_4 dwLoc58 = (word32) rLoc58;
	word32 dwLoc54 = SLICE(rLoc58, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if (((byte) (word32) *((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		<anonymous> ** edx_54 = **((word32) *((word32) dwArg04 + 32) + 16);
		(*edx_54)();
		*((word32) dwArg08 + 4) = (byte) ((word32) *((word32) dwArg08 + 4) | 0x04);
		real64 rLoc58_705 = rLoc58;
		if (*((word32) dwArg08 + 0x0C) == 0x00)
		{
			word32 edi_816;
			runtime.newarray(gs, *((word32) dwArg04 + 40), 0x01, out edi_816);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 0x0C) = dwLoc58;
			else
				runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc58);
		}
		while (true)
		{
			cu8 cl_122 = (byte) (word32) *((word32) dwArg08 + 5);
			word32 dwLoc54_715 = SLICE(rLoc58_705, word32, 32);
			int32 edx_130 = (0x01 << cl_122 & 0x00 - (cl_122 < 0x20)) - 0x01 & dwLoc58;
			if (*((word32) dwArg08 + 16) != 0x00)
			{
				runtime.growWork(gs, dwArg04, dwArg08, edx_130);
				rLoc58_705 = SEQ(dwLoc54_715, edx_130);
			}
			int32 edi_162 = (word32) *((word32) dwArg04 + 52);
			Eq_4 ebx_160 = dwArg08;
			Eq_4 ebp_159 = dwArg04;
			Eq_4 edx_165 = (word32) *((word32) dwArg08 + 0x0C) + edx_130 *s edi_162;
			cu8 al_169 = (byte) (dwLoc58 >> 0x18);
			if (al_169 < 0x04)
				al_169 = (byte) ((dwLoc58 >> 0x18) + 0x04);
			Eq_7629 ecx_179 = 0x00;
			Eq_4 dwLoc14_626 = 0x00;
			Eq_4 edx_191 = edx_165;
			byte al_193 = (byte) (word32) al_169;
			edi_208 = edi_162;
			while (true)
			{
				int32 edi_208;
				word32 eax_200 = (word32) al_193;
				Eq_10709 dwLoc4C_630 = 0x00;
				byte al_579 = (byte) eax_200;
				ui24 eax_24_8_586 = SLICE(eax_200, word24, 8);
				while (true)
				{
					int32 esi_430;
					Eq_7629 dwLoc54_655 = SLICE(rLoc58_705, word32, 32);
					Eq_363 ebx_24_8_258 = SLICE(ebx_160, word24, 8);
					al_193 = al_579;
					ui24 edx_24_8_234 = SLICE(edx_191, word24, 8);
					if (dwLoc4C_630 >= 0x08)
						break;
					Eq_4 ebx_530;
					word32 edi_480 = (word32) Mem202[edx_191 + dwLoc4C_630:byte];
					word32 ebx_481 = edx_191 + dwLoc4C_630;
					if (al_579 != (byte) edi_480)
					{
						if ((byte) edi_480 == 0x00)
						{
							if (ecx_179 != 0x00)
								ebx_530 = dwLoc14_626;
							else
							{
								ecx_179 = ebx_481;
								ebx_530 = edx_191 + 0x08 + dwLoc4C_630 * 0x04;
								ebp_159 = dwArg04;
							}
						}
						else
							ebx_530 = dwLoc14_626;
					}
					else
					{
						if (*((word32) edx_191 + (dwLoc4C_630 * 0x04 + 8)) == dwArg0C)
						{
							esi_430 = dwLoc4C_630 *s (word32) (*((word32) ebp_159 + 50));
							goto l080515CB;
						}
						ebx_530 = dwLoc14_626;
					}
					++dwLoc4C_630;
					dwLoc14_626 = ebx_530;
					ebx_160 = dwArg08;
					edi_208 = edi_162;
				}
				Eq_4 esi_210 = (edx_191 - 0x04)[edi_208 / 4];
				if (esi_210 == 0x00)
					break;
				edx_191 = esi_210;
			}
			if (*((word32) ebx_160 + 16) != 0x00)
				break;
			Eq_10777 al_328;
			Eq_7761 ebp_224 = *ebx_160;
			Eq_7761 esi_225 = ebp_224;
			Eq_7629 ebp_226 = ebp_224 >> 0x1F;
			word32 edi_227 = (word32) *((word32) ebx_160 + 5);
			if ((byte) (SEQ(eax_24_8_586, ebp_224 >> 0x1F > 0x00) | SEQ(edx_24_8_234, ebp_224 >> 0x1F == 0x00) & SEQ(eax_24_8_586, ebp_224 >= 0x08)) == 0x00)
				al_328.u0 = 0x00;
			else
			{
				runtime.int64tofloat64(ebx_24_8_258, gs, SEQ(ebp_224 >> 0x1F, ebp_224));
				word32 ecx_273 = (word32) (byte) edi_227;
				cu8 cl_286 = (byte) -(ecx_273 + ~0x1F);
				runtime.uint64tofloat64(gs, 0x01 >> cl_286 & 0x00 - (cl_286 < 0x20) | 0x01 << (byte) (ecx_273 + ~0x1F) & 0x00 - ((byte) (ecx_273 + ~0x1F) < 0x20));
				uint128 xmm2_320 = (uint128) (uint32) g_r80F1808;
				al_328 = (real32) (uint128) (uint64) (real64) (uint128) (uint64) rLoc58_705 >= SEQ(SLICE(xmm2_320, uir96, 32), (real32) xmm2_320 * (real32) ((uint128) ((uint64) rLoc58_705)));
				ebx_160 = dwArg08;
			}
			if (al_328 == 0x00)
			{
				Eq_10860 al_349;
				word32 edx_342 = (word32) *((word32) ebx_160 + 5);
				cup16 ax_346 = (word16) (word32) *((word32) ebx_160 + 6);
				if ((byte) edx_342 < 0x10)
				{
					cu8 cl_355 = (byte) edx_342;
					esi_225 = 0x01 << cl_355 & 0x00 - (cl_355 < 0x20);
					al_349 = ax_346 >= (word16) esi_225;
				}
				else
					al_349 = ax_346 >= 0x8000;
				ebp_226 = ecx_179;
				if (al_349 == 0x00)
					break;
			}
			runtime.hashGrow(ebp_226, esi_225, gs, dwArg04, ebx_160);
		}
		Eq_4 eax_406;
		Eq_7629 ebp_369 = ecx_179;
		if (ecx_179 != 0x00)
			eax_406 = dwLoc14_626;
		else
		{
			runtime.(*hmap).newoverflow(gs, ebx_160, dwArg04, edx_191);
			ebp_369 = dwLoc54_655;
			eax_406 = (word32) dwLoc54_655 + 8;
		}
		word32 edi_817;
		runtime.typedmemmove(*((word32) dwArg04 + 32), eax_406, (word32) fp + 0x0C, out esi_430, out edi_817);
		*ebp_369 = (byte) (word32) al_579;
		*dwArg08 = (word32) *dwArg08 + 1;
l080515CB:
		ui32 edx_507 = (word32) *((word32) dwArg08 + 4);
		if (((byte) edx_507 & 0x04) == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) dwArg08 + 4) = (byte) (edx_507 & ~0x04);
			return esi_430;
		}
	}
}

// 08051910: Register int32 runtime.mapassign_fast64(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_4 ediOut)
// Called from:
//      runtime.typesEqual
int32 runtime.mapassign_fast64(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_4 & ediOut)
{
	Eq_4 dwLoc58 = (word32) rLoc58;
	word32 dwLoc54 = SLICE(rLoc58, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if (((byte) (word32) *((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		<anonymous> ** edx_54 = **((word32) *((word32) dwArg04 + 32) + 16);
		(*edx_54)();
		*((word32) dwArg08 + 4) = (byte) ((word32) *((word32) dwArg08 + 4) | 0x04);
		real64 rLoc58_732 = rLoc58;
		if (*((word32) dwArg08 + 0x0C) == 0x00)
		{
			word32 edi_863;
			runtime.newarray(gs, *((word32) dwArg04 + 40), 0x01, out edi_863);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 0x0C) = dwLoc58;
			else
				runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc58);
		}
		while (true)
		{
			cu8 cl_122 = (byte) (word32) *((word32) dwArg08 + 5);
			word32 dwLoc54_742 = SLICE(rLoc58_732, word32, 32);
			int32 edx_130 = (0x01 << cl_122 & 0x00 - (cl_122 < 0x20)) - 0x01 & dwLoc58;
			if (*((word32) dwArg08 + 16) != 0x00)
			{
				runtime.growWork(gs, dwArg04, dwArg08, edx_130);
				rLoc58_732 = SEQ(dwLoc54_742, edx_130);
			}
			int32 edi_162 = (word32) *((word32) dwArg04 + 52);
			Eq_4 ebx_160 = dwArg08;
			Eq_4 edx_165 = (word32) *((word32) dwArg08 + 0x0C) + edx_130 *s edi_162;
			cu8 al_169 = (byte) (dwLoc58 >> 0x18);
			if (al_169 < 0x04)
				al_169 = (byte) ((dwLoc58 >> 0x18) + 0x04);
			Eq_7629 ecx_182 = 0x00;
			Eq_4 dwLoc14_652 = 0x00;
			Eq_4 edx_192 = edx_165;
			byte al_194 = (byte) (word32) al_169;
			edi_209 = edi_162;
			while (true)
			{
				int32 edi_209;
				struct Eq_11079 * dwLoc4C_656 = null;
				word32 eax_201 = (word32) al_194;
				while (true)
				{
					int32 esi_428;
					Eq_4 edi_426;
					Eq_7629 dwLoc54_680 = SLICE(rLoc58_732, word32, 32);
					al_194 = (byte) eax_201;
					ui24 eax_24_8_235 = SLICE(eax_201, word24, 8);
					Eq_363 ebx_24_8_257 = SLICE(ebx_160, word24, 8);
					ui24 edx_24_8_233 = SLICE(edx_192, word24, 8);
					if (dwLoc4C_656 >= (struct Eq_11079 *) 0x08)
						break;
					word32 eax_550;
					Eq_4 ebx_552;
					word32 edi_479 = (word32) Mem203[edx_192 + dwLoc4C_656:byte];
					word32 ebx_480 = edx_192 + dwLoc4C_656;
					if (al_194 != (byte) edi_479)
					{
						if ((byte) edi_479 == 0x00)
						{
							if (ecx_182 != 0x00)
							{
								ebx_552 = dwLoc14_652;
								eax_550 = eax_201;
							}
							else
							{
								ecx_182 = ebx_480;
								ebx_552 = edx_192 + 0x08 + dwLoc4C_656 * 0x08;
								eax_550 = eax_201;
							}
						}
						else
						{
							ebx_552 = dwLoc14_652;
							eax_550 = eax_201;
						}
					}
					else
					{
						word32 edi_492 = edx_192 + 0x08 + dwLoc4C_656 * 0x08;
						edi_426 = edi_492->t0000;
						if ((byte) (SEQ(SLICE(dwArg10, word24, 8), edi_492->t0004 != dwArg10) | SEQ(SLICE(dwArg0C, word24, 8), edi_426 != dwArg0C)) == 0x00)
						{
							esi_428 = dwLoc4C_656 *s (word32) (*((word32) dwArg04 + 50));
							goto l08051A4F;
						}
						eax_550 = (word32) al_169;
						ebx_552 = dwLoc14_652;
					}
					++dwLoc4C_656;
					dwLoc14_652 = ebx_552;
					ebx_160 = dwArg08;
					edi_209 = edi_162;
					eax_201 = eax_550;
				}
				Eq_4 esi_211 = (edx_192 - 0x04)[edi_209 / 4];
				if (esi_211 == 0x00)
					break;
				edx_192 = esi_211;
			}
			if (*((word32) ebx_160 + 16) != 0x00)
				break;
			Eq_11167 al_326;
			Eq_7761 ebp_223 = *ebx_160;
			Eq_7761 esi_224 = ebp_223;
			Eq_7629 ebp_225 = ebp_223 >> 0x1F;
			word32 edi_226 = (word32) *((word32) ebx_160 + 5);
			if ((byte) (SEQ(edx_24_8_233, ebp_223 >> 0x1F == 0x00) & SEQ(eax_24_8_235, ebp_223 >= 0x08) | SEQ(eax_24_8_235, ebp_223 >> 0x1F > 0x00)) == 0x00)
				al_326.u0 = 0x00;
			else
			{
				runtime.int64tofloat64(ebx_24_8_257, gs, SEQ(ebp_223 >> 0x1F, ebp_223));
				word32 ecx_272 = (word32) (byte) edi_226;
				cu8 cl_288 = (byte) -(ecx_272 + ~0x1F);
				runtime.uint64tofloat64(gs, 0x01 >> cl_288 & 0x00 - (cl_288 < 0x20) | 0x01 << (byte) (ecx_272 + ~0x1F) & 0x00 - ((byte) (ecx_272 + ~0x1F) < 0x20));
				uint128 xmm2_318 = (uint128) (uint32) g_r80F1808;
				al_326 = (real32) (uint128) (uint64) (real64) (uint128) (uint64) rLoc58_732 >= SEQ(SLICE(xmm2_318, uir96, 32), (real32) xmm2_318 * (real32) ((uint128) ((uint64) rLoc58_732)));
				ebx_160 = dwArg08;
			}
			if (al_326 == 0x00)
			{
				Eq_11250 al_347;
				word32 edx_340 = (word32) *((word32) ebx_160 + 5);
				cup16 ax_344 = (word16) (word32) *((word32) ebx_160 + 6);
				if ((byte) edx_340 < 0x10)
				{
					cu8 cl_353 = (byte) edx_340;
					esi_224 = 0x01 << cl_353 & 0x00 - (cl_353 < 0x20);
					al_347 = ax_344 >= (word16) esi_224;
				}
				else
					al_347 = ax_344 >= 0x8000;
				ebp_225 = ecx_182;
				if (al_347 == 0x00)
					break;
			}
			runtime.hashGrow(ebp_225, esi_224, gs, dwArg04, ebx_160);
		}
		Eq_4 eax_404;
		Eq_7629 ebp_367 = ecx_182;
		if (ecx_182 != 0x00)
			eax_404 = dwLoc14_652;
		else
		{
			runtime.(*hmap).newoverflow(gs, ebx_160, dwArg04, edx_192);
			ebp_367 = dwLoc54_680;
			eax_404 = (word32) dwLoc54_680 + 8;
		}
		runtime.typedmemmove(*((word32) dwArg04 + 32), eax_404, (word32) fp + 0x0C, out esi_428, out edi_426);
		*ebp_367 = (byte) (word32) al_169;
		*dwArg08 = (word32) *dwArg08 + 1;
l08051A4F:
		ui32 edx_527 = (word32) *((word32) dwArg08 + 4);
		if (((byte) edx_527 & 0x04) == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) dwArg08 + 4) = (byte) (edx_527 & ~0x04);
			ediOut = edi_426;
			return esi_428;
		}
	}
}

// 08051D90: Register Eq_4 runtime.mapassign_faststr(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_11325) dwArg04, Stack Eq_4 dwArg08, Register out Eq_7761 esiOut, Register out Eq_11328 ediOut, Register out Eq_7861 xmm1Out)
// Called from:
//      time.init
//      unicode.init
Eq_4 runtime.mapassign_faststr(struct Eq_2 * gs, struct Eq_11325 * dwArg04, Eq_4 dwArg08, union Eq_7761 & esiOut, union Eq_11328 & ediOut, union Eq_7861 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_11342 * esp_135 = fp - 0x54;
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if (((byte) (word32) *((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		<anonymous> ** edx_54 = *dwArg04->ptr0020->ptr0010;
		<anonymous> * ecx_59 = *edx_54;
		ecx_59();
		*((word32) dwArg08 + 4) = (byte) ((word32) *((word32) dwArg08 + 4) | 0x04);
		Eq_4 eax_114 = dwLoc4C;
		Eq_4 ecx_115 = dwArg08;
		if (*((word32) dwArg08 + 0x0C) == 0x00)
		{
			word32 edi_751;
			runtime.newarray(gs, dwArg04->t0028, 0x01, out edi_751);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 0x0C) = dwLoc4C;
			else
				runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc4C);
			eax_114 = dwLoc4C;
			ecx_115 = dwArg08;
		}
		while (true)
		{
			cu8 cl_122 = (byte) (word32) *((word32) ecx_115 + 5);
			Eq_4 ebx_119 = ecx_115;
			int32 edx_130 = (0x01 << cl_122 & 0x00 - (cl_122 < 0x20)) - 0x01 & eax_114;
			if (*((word32) ecx_115 + 16) != 0x00)
			{
				esp_135[7] = (struct Eq_11342) edx_130;
				esp_135->dw0000 = (word32) esp_135[22];
				esp_135[1] = (struct Eq_11342) ecx_115;
				esp_135[2] = (struct Eq_11342) edx_130;
				runtime.growWork(gs, esp_135->dw0000, esp_135[1], esp_135[2]);
				eax_114 = esp_135[6];
				edx_130 = (int32) esp_135[7];
				ebx_119 = esp_135[23];
			}
			uint32 eax_168 = eax_114 >> 0x18;
			struct Eq_11472 * edx_165 = (word32) *((word32) ebx_119 + 0x0C) + edx_130 *s (word32) (*((word64) (esp_135)[22].r0030 + 4));
			cu8 al_169 = (byte) eax_168;
			if (al_169 < 0x04)
				al_169 = (byte) (eax_168 + 0x04);
			esp_135->b0012 = al_169;
			Eq_7629 ecx_178 = 0x00;
			Eq_7761 esi_179 = 0x00;
			Eq_11328 edi_180 = 0x00;
			do
			{
				esp_135[0x0011] = (struct Eq_11342) edx_165;
				esp_135[0x0A] = (struct Eq_11342) al_169;
				esp_135[5] = (struct Eq_11342) 0x00;
				al_169 = (byte) (word32) esp_135[0x0A];
				while (true)
				{
					Eq_4 ebx_407;
					esp_135[0x0E] = (struct Eq_11342) edi_180;
					esp_135[0x0F] = (struct Eq_11342) esi_179;
					esp_135[16] = (struct Eq_11342) ecx_178;
					struct Eq_11526 * ebp_200 = esp_135[5];
					if (ebp_200 >= (struct Eq_11526 *) 0x08)
						break;
					Eq_7761 ebx_559;
					byte bl_484 = SLICE((word32) Mem199[edx_165 + ebp_200:byte], byte, 0);
					word32 esi_483 = edx_165 + ebp_200;
					if (al_169 != bl_484)
					{
						if (bl_484 == 0x00)
						{
							if (ecx_178 != 0x00)
								ebx_559 = esp_135[0x0F];
							else
							{
								struct Eq_11577 * esi_570 = esp_135[22];
								int32 esi_572 = (word32) esi_570->b0030;
								esp_135[9] = (struct Eq_11342) (esi_572 *s ebp_200);
								int32 esi_579 = (word32) esi_570->b0032 *s ebp_200 + esi_572 * 0x08;
								esp_135[8] = (struct Eq_11342) edx_165;
								ecx_178 = esi_483;
								ebx_559 = edx_165 + (esp_135)[9].dw0008 / 8;
								edi_180 = (word32) esp_135[8].dw0000 + (esi_579 + 0x08);
							}
						}
						else
							ebx_559 = esp_135[0x0F];
						goto l08051E09;
					}
					word32 ebx_488 = edx_165 + 0x08 + ebp_200 * 0x08;
					esp_135[20] = (struct Eq_11342) ebx_488;
					ebx_407 = esp_135[25];
					if (ebx_488->t0004 != ebx_407)
					{
						ebx_559 = esp_135[0x0F];
						goto l08051E09;
					}
					esi_179 = *esp_135[20].dw0000;
					Eq_7761 eax_496 = esp_135[24];
					if (esi_179 == eax_496)
					{
l08051EFA:
						goto l08051F11;
					}
					esp_135[2] = (struct Eq_11342) ebx_407;
					esp_135->dw0000 = (word32) esi_179;
					esp_135[1] = (struct Eq_11342) eax_496;
					ebx_407 = runtime.memequal(esp_135->dw0000, esp_135[1], esp_135[2], out esi_179, out edi_180);
					++esp_135;
					if ((byte) (word32) esp_135[3] != 0x00)
						goto l08051EFA;
					al_169 = (byte) (word32) esp_135->b0012;
					edx_165 = (struct Eq_11472 *) esp_135[0x0011];
					ebp_200 = (struct Eq_11526 *) esp_135[5];
					ecx_178 = esp_135[16];
					ebx_559 = esp_135[0x0F];
					edi_180 = esp_135[0x0E];
l08051E09:
					Mem595[esp_135 + 0x14:word32] = ebp_200 + 0x01;
					esi_179 = ebx_559;
				}
				edx_165 = (struct Eq_11472 *) *((word32) (edx_165 - (struct Eq_11532 *) 0x04) + (word32) (*((word64) (esp_135)[22].r0030 + 4)));
			} while (edx_165 != null);
			Eq_7629 ebp_218;
			struct Eq_11623 * edx_213 = esp_135[23];
			if (edx_213->dw0010 != 0x00)
				break;
			Eq_11703 al_320;
			Eq_7629 ebx_219 = edx_213->t0000;
			word32 eax_222 = (word32) edx_213->b0005;
			esp_135->b0013 = (byte) eax_222;
			esi_179 = SEQ(SLICE(esi_179, word24, 8), ebx_219 >> 0x1F == 0x00) & SEQ(SLICE(eax_222, word24, 8), ebx_219 >= 0x08);
			ebp_218 = ebx_219;
			Eq_363 ebx_24_8_253 = SLICE(ebx_219 >> 0x1F, word24, 8);
			if ((byte) (SEQ(SLICE(eax_222, word24, 8), ebx_219 >> 0x1F > 0x00) | esi_179) == 0x00)
				al_320.u0 = 0x00;
			else
			{
				esp_135->dw0000 = (word32) ebx_219;
				esp_135[1] = (struct Eq_11342) (ebx_219 >> 0x1F);
				runtime.int64tofloat64(ebx_24_8_253, gs, esp_135->dw0000);
				esp_135[0x0C] = (struct Eq_11342) (real64) (uint128) (uint64) esp_135[2];
				word32 ecx_268 = (word32) esp_135->b0013;
				cu8 cl_270 = (byte) ecx_268;
				esp_135->dw0000 = 0x01 << cl_270 & 0x00 - (cl_270 < 0x20);
				cu8 cl_279 = (byte) (ecx_268 + ~0x1F);
				cu8 cl_287 = (byte) -(ecx_268 + ~0x1F);
				esp_135[1] = (struct Eq_11342) (0x01 >> cl_287 & 0x00 - (cl_287 < 0x20) | 0x01 << cl_279 & 0x00 - (cl_279 < 0x20));
				runtime.uint64tofloat64(gs, esp_135[1]);
				Eq_7861 xmm1_309 = (uint128) (uint64) esp_135[2];
				uint128 xmm2_312 = (uint128) (uint32) g_r80F1808;
				xmm1 = xmm1_309;
				al_320 = (real32) (uint128) (uint64) esp_135[0x0C] >= SEQ(SLICE(xmm2_312, uir96, 32), (real32) xmm2_312 * (real32) xmm1_309);
				ecx_178 = esp_135[16];
				edx_213 = (struct Eq_11623 *) esp_135[23];
				edi_180 = esp_135[0x0E];
			}
			if (al_320 == 0x00)
			{
				Eq_11843 al_342;
				word32 ebx_335 = (word32) edx_213->b0005;
				cup16 ax_339 = (word16) (word32) edx_213->w0006;
				if ((byte) ebx_335 < 0x10)
				{
					cu8 cl_348 = (byte) ebx_335;
					esi_179 = 0x01 << cl_348 & 0x00 - (cl_348 < 0x20);
					al_342 = ax_339 >= (word16) esi_179;
				}
				else
					al_342 = ax_339 >= 0x8000;
				ebp_218 = ecx_178;
				if (al_342 == 0x00)
					goto l08052044;
			}
			esp_135->dw0000 = (word32) esp_135[22];
			esp_135[1] = (struct Eq_11342) edx_213;
			xmm1 = runtime.hashGrow(ebp_218, esi_179, gs, esp_135->dw0000, esp_135[1]);
			eax_114 = esp_135[6];
			ecx_115 = esp_135[23];
		}
		ebp_218 = ecx_178;
l08052044:
		Eq_11881 eax_400;
		if (ebp_218 != 0x00)
			eax_400 = esp_135[0x0F];
		else
		{
			esp_135->dw0000 = edx_213;
			esp_135[1] = esp_135[22];
			esp_135[2] = esp_135[0x0011];
			esi_179 = runtime.(*hmap).newoverflow(gs, esp_135->dw0000, esp_135[1], esp_135[2]);
			ebp_218 = esp_135[3];
			edi_180 = (word32) ebp_218 + 72;
			edx_213 = (struct Eq_11623 *) esp_135[23];
			eax_400 = (word32) ebp_218 + 8;
		}
		ebx_407 = esp_135[24];
		*((word32) eax_400 + 4) = esp_135[25];
		if (g_t81576F0 == 0x00)
			*eax_400 = ebx_407;
		else
		{
			esp_135[16] = (struct Eq_11342) ebp_218;
			esp_135[19] = (struct Eq_11342) edi_180;
			esp_135->dw0000 = (word32) eax_400;
			esp_135[1] = (struct Eq_11342) ebx_407;
			runtime.writebarrierptr(esp_135->dw0000, esp_135[1]);
			edx_213 = (struct Eq_11623 *) esp_135[23];
			ebp_218 = esp_135[16];
			edi_180 = esp_135[19];
		}
		*ebp_218 = (byte) (word32) esp_135->b0012;
		edx_213->t0000 = (word32) edx_213->t0000 + 1;
l08051F11:
		ui32 edx_530 = (word32) *((word32) dwArg08 + 4);
		if (((byte) edx_530 & 0x04) == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) dwArg08 + 4) = (byte) (edx_530 & ~0x04);
			esiOut = esi_179;
			ediOut = edi_180;
			xmm1Out = xmm1;
			return ebx_407;
		}
	}
}

// 08052240: void runtime.getitab(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C)
// Called from:
//      runtime.assertE2I
//      runtime.assertE2I2
void runtime.getitab(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_18 = *((word32) dwArg04 + 36);
	if (*((word32) dwArg04 + 40) == 0x00)
		runtime.throw(gs);
	else if (((byte) (word32) *((word32) dwArg08 + 0x0C) & 0x01) == 0x00)
	{
		if ((byte) (word32) bArg0C != 0x00)
			return;
		Eq_4 eax_49 = *edx_18;
		runtime.(*_type).nameOff(gs);
		runtime.(*_type).string(gs, dwArg08);
		runtime.(*_type).string(gs, dwArg04);
		runtime.name.name(gs, dwLoc40);
		runtime.newobject(gs, 0x080D6BA0);
		*((word32) eax_49 + 0x0C) = dwLoc40;
		if (g_t81576F0 == 0x00)
			*((word32) eax_49 + 8) = eax_49;
		else
			runtime.writebarrierptr((word32) eax_49 + 8, eax_49);
		*((word32) eax_49 + 20) = dwLoc40;
		if (g_t81576F0 == 0x00)
			*((word32) eax_49 + 16) = eax_49;
		else
			runtime.writebarrierptr((word32) eax_49 + 16, eax_49);
		*((word32) eax_49 + 28) = dwLoc40;
		if (g_t81576F0 == 0x00)
			*((word32) eax_49 + 24) = eax_49;
		else
			runtime.writebarrierptr((word32) eax_49 + 24, eax_49);
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 ebp_168 = *((word32) dwArg08 + 8);
		uint32 edx_172 = (word32) *((word32) dwArg04 + 8) + ebp_168 * 0x11;
		word32 edx_177 = SLICE(edx_172 * 63849861, word32, 32) + edx_172;
		Eq_4 esi_169 = ebp_168;
		uint32 ebp_184 = edx_172 - (__rcr(edx_177, 0x01, SLICE(cond(edx_177), bool, 1)) >> 0x09) *s 1009;
		Eq_4 eax_186 = 0x00;
		while (eax_186 < 0x02)
		{
			Eq_12103 dl_273 = eax_186 != 0x00;
			if (eax_186 != 0x00)
			{
				word32 esi_599;
				word32 ebp_598;
				word32 edi_600;
				runtime.lock(esi_169, gs, 0x081575F4, out ebp_598, out esi_599, out edi_600);
			}
			if (ebp_184 >= 1009)
				runtime.panicindex(gs);
			runtime/internal/atomic.Loadp();
			Eq_4 eax_301 = dwLoc44;
			while (eax_301 != 0x00)
			{
				if (*eax_301 == dwArg04 && *((word32) eax_301 + 4) == dwArg08)
				{
					bool Z_356;
					if ((byte) (word32) *((word32) eax_301 + 16) != 0x00)
					{
						if ((byte) (word32) bArg0C != 0x00)
							Z_356 = SLICE(cond(eax_186), bool, 2);
						else
						{
							runtime.additab(gs, eax_301, (byte) (word32) dl_273, 0x00);
							Z_356 = SLICE(cond(eax_186), bool, 2);
						}
					}
					else
						Z_356 = SLICE(cond(eax_186), bool, 2);
					if (Z_356)
					{
						word32 edx_370;
						word32 ebx_601;
						runtime.unlock(gs, 0x081575F4, out edx_370, out ebx_601);
					}
					return;
				}
				eax_301 = *((word32) eax_301 + 8);
			}
			esi_169 = eax_186;
			eax_186 = (word32) eax_186 + 1;
		}
		runtime.persistentalloc(gs);
		if (g_t81576F0 == 0x00)
		{
			*dwLoc3C = dwArg04;
			*((word32) dwLoc3C + 4) = dwArg08;
		}
		else
		{
			runtime.writebarrierptr(dwLoc3C, dwArg04);
			runtime.writebarrierptr((word32) dwLoc3C + 4, dwArg08);
		}
		runtime.additab(gs, dwLoc3C, 0x01, (byte) (word32) bArg0C);
		word32 ebx_603;
		word32 edx_602;
		runtime.unlock(gs, 0x081575F4, out edx_602, out ebx_603);
		if ((byte) (word32) *((word32) dwLoc3C + 16) == 0x00)
			;
	}
}

// 080525C0: void runtime.additab(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08, Stack byte bArg09)
// Called from:
//      runtime.getitab
//      runtime.itabsinit
void runtime.additab(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08, byte bArg09)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = *dwArg04;
	Eq_4 edx_21 = *((word32) dwArg04 + 4);
	runtime.(*_type).uncommon(gs, edx_21);
	struct Eq_12298 * ecx_31 = dwLoc64 + dwLoc64->dw0008 / 0x0C;
	Eq_4 ebx_35 = *((word32) ecx_19 + 40);
	Eq_12308 ebp_36 = (word32) dwLoc64->w0004;
	if (ebp_36 > 0x00010000)
		runtime.panicslice(gs);
	else
	{
		Eq_4 esi_47 = 0x00;
		Eq_12308 edi_496 = 0x00;
l080527AC:
		if (esi_47 < ebx_35)
		{
			Eq_4 ebx_59 = *((word32) ecx_19 + 36);
			if (esi_47 >= *((word32) ecx_19 + 40))
				runtime.panicindex(gs);
			runtime.(*_type).typeOff(gs);
			Eq_4 edx_85 = *((word32) ebx_59 + esi_47 * 0x08);
			runtime.(*_type).nameOff(gs);
			runtime.name.name(gs, dwLoc60);
			word32 edi_805;
			runtime.name.pkgPath(gs, dwLoc60, out edi_805);
			Eq_4 dwLoc64_536 = edx_85;
			if (dwLoc60 == 0x00)
				runtime.name.name(gs, *((word32) ecx_19 + 32));
			Eq_12308 edx_129 = edi_496;
			dwLoc60_562 = dwLoc60;
			while (true)
			{
				Eq_4 dwLoc60_562;
				if (edx_129 >= ebp_36)
					break;
				if (edx_129 >= ebp_36)
					runtime.panicindex(gs);
				runtime.(*_type).nameOff(gs);
				int32 edx_333 = edx_129 << 0x04;
				Eq_4 ebx_349 = ecx_31->a0004[edx_333 / 4];
				runtime.(*_type).typeOff(gs);
				dwLoc64_536 = ebx_349;
				if (dwLoc60_562 == dwLoc60)
				{
					runtime.name.name(gs, dwLoc60_562);
					if (dwLoc60_562 != dwLoc60)
						goto l0805262F;
					word32 edi_377;
					word32 esi_806;
					runtime.eqstring(ebx_349, dwLoc60_562, edx_85, out esi_806, out edi_377);
					dwLoc64_536 = dwLoc60_562;
					dwLoc60_562 = edx_85;
					if ((byte) (word32) bLoc58 == 0x00)
						goto l0805262F;
					word32 edi_807;
					runtime.name.pkgPath(gs, dwLoc60_562, out edi_807);
					Eq_4 eax_398 = dwLoc60_562;
					if (edx_85 == 0x00)
					{
						Eq_4 ecx_404 = dwLoc64->t0000;
						runtime.(*_type).nameOff(gs);
						runtime.name.name(gs, edx_85);
						dwLoc64_536 = ecx_404;
						eax_398 = ecx_404;
					}
					if (((byte) (word32) *dwLoc60_562 & 0x01) == 0x00)
					{
						if (dwLoc60 != edx_85)
						{
l08052721:
							dwLoc60_562 = edx_85;
							goto l0805262F;
						}
						word32 edi_438;
						word32 esi_808;
						runtime.eqstring(eax_398, edx_85, edx_85, out esi_808, out edi_438);
						dwLoc64_536 = edx_85;
						if ((byte) (word32) bLoc58 == 0x00)
							goto l08052721;
					}
					runtime.(*_type).textOff(gs, edx_21, ecx_31->a0008[edx_333 / 4]);
					dwLoc60 = edx_85;
					Eq_4 ecx_470 = (word32) dwArg04 + 20 + esi_47 * 0x04;
					if (g_t81576F0 == 0x00)
						*ecx_470 = edx_85;
					else
						runtime.writebarrierptr(ecx_470, edx_85);
					esi_47 = (word32) esi_47 + 1;
					edi_496 = edx_129;
					goto l080527AC;
				}
l0805262F:
				edx_129 = (word32) edx_129 + 1;
			}
			if ((byte) (word32) bArg09 == 0x00)
			{
				if ((byte) (word32) bArg08 != 0x00)
				{
					word32 ebx_810;
					word32 edx_809;
					runtime.unlock(gs, 0x081575F4, out edx_809, out ebx_810);
				}
				runtime.(*_type).string(gs, edx_21);
				runtime.(*_type).string(gs, ecx_19);
				runtime.newobject(gs, 0x080D6BA0);
				*((word32) dwLoc64_536 + 0x0C) = dwLoc60_562;
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc64_536 + 8) = dwLoc64_536;
				else
					runtime.writebarrierptr((word32) dwLoc64_536 + 8, dwLoc64_536);
				*((word32) dwLoc64_536 + 20) = dwLoc60_562;
				Eq_4 edx_207 = (word32) dwLoc64_536 + 16;
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc64_536 + 16) = dwLoc64_536;
				else
					runtime.writebarrierptr(edx_207, dwLoc64_536);
				*((word32) dwLoc64_536 + 28) = dwLoc60;
				Eq_4 edx_228 = (word32) dwLoc64_536 + 24;
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc64_536 + 24) = edx_85;
				else
					runtime.writebarrierptr(edx_228, edx_85);
				runtime.gopanic(gs);
			}
			((word32) dwArg04 + 16)->u0 = 0x01;
		}
		if ((byte) (word32) bArg08 == 0x00)
			runtime.throw(gs);
		else
		{
			uint32 edx_276 = (word32) *((word32) ecx_19 + 8) + *((word32) edx_21 + 8) * 0x11;
			word32 edx_281 = SLICE(edx_276 * 63849861, word32, 32) + edx_276;
			uint32 ebx_288 = edx_276 - (__rcr(edx_281, 0x01, SLICE(cond(edx_281), bool, 1)) >> 0x09) *s 1009;
			if (ebx_288 >= 1009)
				runtime.panicindex(gs);
			else
			{
				Eq_4 esi_299 = *((char *) g_a81468E0 + ebx_288 * 0x04);
				Eq_4 ebx_300 = ebx_288 * 0x04 + 135555296;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg04 + 8) = esi_299;
				else
					runtime.writebarrierptr((word32) dwArg04 + 8, esi_299);
				*((word32) dwArg04 + 0x0011) = 0x01;
				runtime.atomicstorep(ebx_300, dwArg04);
			}
		}
	}
}

// 08052AC0: void runtime.itabsinit(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.itabsinit(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_26;
	word32 edi_27;
	word32 esi_28;
	runtime.lock(esi, gs, 0x081575F4, out ebp_26, out esi_28, out edi_27);
	runtime.activeModules();
	word32 * eax_40 = &g_dw81575F4;
	int32 ecx_123 = dwLoc20;
	int32 edx_43 = 0x00;
	while (edx_43 < ecx_123)
	{
		struct Eq_12632 * ebx_68 = *eax_40;
		word32 * ebp_116 = ebx_68->ptr0084;
		int32 ebx_70 = ebx_68->dw0088;
		int32 esi_119 = 0x00;
		ebx_112 = ebx_70;
		eax_110 = eax_40;
		edx_111 = edx_43;
		while (true)
		{
			int32 edx_111;
			word32 * eax_110;
			int32 ebx_112;
			if (esi_119 >= ebx_112)
				break;
			Eq_4 edi_87 = *ebp_116;
			if ((byte) (word32) *((word32) edi_87 + 0x0011) == 0x00)
			{
				runtime.additab(gs, edi_87, 0x01, 0x00);
				eax_110 = eax_40;
				edx_111 = edx_43;
				ebx_112 = ebx_70;
			}
			++ebp_116;
			++esi_119;
			ecx_123 = dwLoc20;
		}
		eax_40 = eax_110 + 1;
		edx_43 = edx_111 + 0x01;
	}
	word32 edx_163;
	word32 ebx_164;
	runtime.unlock(gs, 0x081575F4, out edx_163, out ebx_164);
}

// 08052B90: void runtime.panicdottypeE(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.panicdottypeI
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.callMethod
//      reflect.FuncOf.func1
//      fmt.newPrinter
void runtime.panicdottypeE(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_27;
	Eq_4 eax_26;
	if (dwArg04 == 0x00)
	{
		eax_26.u0 = 0x00;
		ecx_27.u0 = 0x00;
	}
	else
	{
		runtime.(*_type).string(gs, dwArg04);
		eax_26 = dwLoc24;
		ecx_27 = dwLoc20;
	}
	runtime.(*_type).string(gs, dwArg0C);
	runtime.(*_type).string(gs, dwArg08);
	runtime.newobject(gs, 0x080D6BA0);
	*((word32) dwLoc24 + 4) = dwLoc20;
	if (g_t81576F0 == 0x00)
		*dwLoc24 = dwLoc24;
	else
		runtime.writebarrierptr(dwLoc24, dwLoc24);
	*((word32) dwLoc24 + 0x0C) = ecx_27;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc24 + 8) = eax_26;
	else
		runtime.writebarrierptr((word32) dwLoc24 + 8, eax_26);
	*((word32) dwLoc24 + 20) = dwLoc20;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc24 + 16) = dwLoc24;
	else
		runtime.writebarrierptr((word32) dwLoc24 + 16, dwLoc24);
	((word32) dwLoc24 + 28)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) dwLoc24 + 24)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) dwLoc24 + 24, 0x00);
	runtime.gopanic(gs);
}

// 08052D10: void runtime.panicdottypeI(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.panicCheckMalloc
//      reflect.makeMethodValue
//      reflect.(*rtype).Method
//      reflect.FuncOf
//      reflect.Zero
//      reflect.New
//      reflect.cvtT2I
//      reflect.init
//      reflect.(*sliceType).Implements
//      reflect.(*sliceType).AssignableTo
//      reflect.(*sliceType).ConvertibleTo
void runtime.panicdottypeI(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_20;
	if (dwArg04 != 0x00)
		eax_20 = *((word32) dwArg04 + 4);
	else
		eax_20.u0 = 0x00;
	runtime.panicdottypeE(gs, eax_20);
}

// 08052D60: void runtime.convT2E(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Map).missLocked
//      reflect.funcLayout
void runtime.convT2E(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebx_83;
	word32 esi_84;
	word32 edi_85;
	runtime.mallocgc(ebx, gs, *dwArg04, dwArg04, 0x01, out ebx_83, out esi_84, out edi_85);
	word32 esi_86;
	word32 edi_87;
	runtime.typedmemmove(dwArg04, dwLoc08, dwArg08, out esi_86, out edi_87);
}

// 08052DD0: Register Eq_4 runtime.convT2E32(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      reflect.FuncOf.func1
Eq_4 runtime.convT2E32(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, word32 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg08 != 0x00)
	{
		word32 edi_32;
		word32 esi_34;
		runtime.mallocgc(ebx, gs, 0x04, dwArg04, 0x00, out ebx, out esi_34, out edi_32);
		*dwLoc04 = *dwArg08;
	}
	return ebx;
}

// 08052E40: void runtime.convT2Estring(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_903) dwArg08)
// Called from:
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.panicwrap
//      runtime.preprintpanics
//      runtime.sigpanic
//      reflect.newName
//      reflect.funcLayout
//      reflect.flag.mustBeAssignable
//      reflect.methodReceiver
//      reflect.Value.assignTo
//      reflect.(*sliceType).Bits
void runtime.convT2Estring(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_903 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08->dw0004 != 0x00)
	{
		word32 ebx_85;
		word32 esi_86;
		word32 edi_87;
		runtime.mallocgc(ebx, gs, *dwArg04, dwArg04, 0x01, out ebx_85, out esi_86, out edi_87);
		Eq_4 ecx_35 = dwArg08->t0000;
		*((word32) dwLoc08 + 4) = dwArg08->dw0004;
		if (g_t81576F0 == 0x00)
			*dwLoc08 = ecx_35;
		else
			runtime.writebarrierptr(dwLoc08, ecx_35);
	}
}

// 08052ED0: void runtime.convT2Eslice(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_12914) dwArg08)
// Called from:
//      reflect.(*rtype).exportedMethods
//      reflect.FuncOf.func1
//      fmt.(*pp).fmtBytes
void runtime.convT2Eslice(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_12914 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08->t0000 != 0x00)
	{
		word32 edi_34;
		word32 esi_36;
		word32 ebx_110;
		runtime.mallocgc(ebx, gs, *dwArg04, dwArg04, 0x01, out ebx_110, out esi_36, out edi_34);
		Eq_4 ebx_44 = dwArg08->t0000;
		Eq_4 ecx_45 = dwArg08->t0008;
		*((word32) dwLoc08 + 4) = dwArg08->dw0004;
		*((word32) dwLoc08 + 8) = ecx_45;
		if (g_t81576F0 == 0x00)
			*dwLoc08 = ebx_44;
		else
			runtime.writebarrierptr(dwLoc08, ebx_44);
	}
}

// 08052F70: Register word32 runtime.convT2I32(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_12974) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      syscall.readlinkat
//      syscall.Close
//      syscall.fcntl
//      syscall.write
//      syscall.munmap
//      syscall.mmap2
//      internal/poll.(*pollDesc).init
word32 runtime.convT2I32(Eq_4 ebx, struct Eq_2 * gs, struct Eq_12974 * dwArg04, word32 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = dwArg04->t0004;
	if (*dwArg08 != 0x00)
	{
		word32 ebx_31;
		word32 edi_33;
		runtime.mallocgc(ebx, gs, 0x04, eax_18, 0x00, out ebx_31, out esi, out edi_33);
		*dwLoc04 = *dwArg08;
	}
	return esi;
}

// 08052FE0: void runtime.assertE2I(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.ifaceE2I
//      runtime.runfinq
void runtime.assertE2I(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.newobject(gs, 0x080D6BA0);
		*((word32) dwLoc18 + 20) = dwLoc14;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc18 + 16) = dwLoc18;
		else
			runtime.writebarrierptr((word32) dwLoc18 + 16, dwLoc18);
		((word32) dwLoc18 + 28)->u0 = 0x00;
		if (g_t81576F0 == 0x00)
			((word32) dwLoc18 + 24)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) dwLoc18 + 24, 0x00);
		runtime.gopanic(gs);
	}
	else
		runtime.getitab(gs, dwArg04, dwArg08, 0x00);
}

// 080530E0: void runtime.assertE2I2(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.printany
//      runtime.SetFinalizer
//      runtime.preprintpanics
//      fmt.(*pp).handleMethods
void runtime.assertE2I2(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return;
	runtime.getitab(gs, dwArg04, dwArg08, 0x01);
	if (dwLoc04 == 0x00)
		;
}

// 08053170: void reflect.ifaceE2I(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      reflect.Value.assignTo
//      reflect.cvtT2I
void reflect.ifaceE2I(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.assertE2I(gs, dwArg04, dwArg08);
	if (g_t81576F0 == 0x00)
	{
		*dwArg10 = dwLoc10;
		*((word32) dwArg10 + 4) = dwLoc0C;
	}
	else
	{
		runtime.writebarrierptr(dwArg10, dwLoc10);
		runtime.writebarrierptr((word32) dwArg10 + 4, dwLoc0C);
	}
}

// 08053200: void runtime.(*lfstack).push(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.putempty
//      runtime.putfull
void runtime.(*lfstack).push(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	word32 dwLoc18 = SLICE(qwLoc1C, word32, 32);
	word32 dwLoc1C = (word32) qwLoc1C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 8);
	*((word32) dwArg08 + 8) = (word32) ecx_18 + 1;
	if (false)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_197;
		runtime.printhex(esi, gs, (word32) ecx_18 + 1, 0x00, out esi_197);
		runtime.printstring(gs);
		word32 esi_198;
		runtime.printhex(esi, gs, (word32) ecx_18 + 1, dwArg08, out esi_198);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		do
		{
			word64 mm0_199;
			runtime/internal/atomic.Load64(dwArg04, out mm0_199);
			*dwArg08 = dwLoc1C;
			*((word32) dwArg08 + 4) = dwLoc18;
			word32 ebx_200;
			word32 ebp_201;
			runtime/internal/atomic.Cas64(dwArg04, qwLoc1C, SEQ(dwArg08, (word32) ecx_18 + 1), out ebx_200, out ebp_201);
		} while ((byte) (word32) bLoc0C == 0x00);
	}
}

// 08053360: void runtime.(*lfstack).pop(Register Eq_13225 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.getempty
//      runtime.trygetfull
//      runtime.getfull
void runtime.(*lfstack).pop(Eq_13225 edx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	word32 dwLoc20 = (word32) qwLoc20;
	Eq_4 dwLoc1C = SLICE(qwLoc20, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx_24_8 = SLICE(runtime.morestack_noctxt(), word24, 8);
	do
	{
		word64 mm0_151;
		if ((byte) (SEQ(edx_24_8, dwLoc1C == 0x00) & SEQ(SLICE(runtime/internal/atomic.Load64(dwArg04, out mm0_151), word24, 8), dwLoc20 == 0x00)) != 0x00)
			return;
		word64 mm0_149;
		runtime/internal/atomic.Load64(dwLoc1C, out mm0_149);
		word32 ebp_75;
		word32 ebx_150;
		edx_24_8 = SLICE(runtime/internal/atomic.Cas64(dwArg04, qwLoc20, qwLoc20, out ebx_150, out ebp_75), word24, 8);
	} while ((byte) (word32) bLoc10 == 0x00);
}

// 08053410: void runtime.(*lfstack).empty(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkWorkAvailable
void runtime.(*lfstack).empty(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 mm0_57;
	runtime/internal/atomic.Load64(dwArg04, out mm0_57);
}

// 08053460: Register Eq_363 runtime.lock(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_4 ebpOut, Register out Eq_4 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.chansend
//      runtime.closechan
//      runtime.chanrecv
//      runtime.GOMAXPROCS
//      runtime.getitab
//      runtime.itabsinit
//      runtime.persistentalloc1
//      runtime.allocmcache
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.queuefinalizer
//      runtime.wakefing
//      runtime.runfinq
//      runtime.findObject
//      runtime/debug.setGCPercent
//      runtime.gcMarkTermination
//      runtime.gcSweep
//      runtime.gcResetMarkState
//      runtime.clearpools
//      runtime.gcMarkRootCheck
//      runtime.markrootFreeGStacks
//      runtime.markrootSpans
//      runtime.gcWakeAllAssists
//      runtime.gcParkAssist
//      runtime.gcFlushBgCredit
//      runtime.bgsweep
//      runtime.(*gcSweepBuf).push
//      runtime.getempty
//      runtime.prepareFreeWorkbufs
//      runtime.freeSomeWbufs
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).reclaim
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocManual
//      runtime.(*mheap).freeManual
//      runtime.(*mheap).scavenge
//      runtime.addspecial
//      runtime.removespecial
//      runtime.addfinalizer
//      runtime.removefinalizer
//      runtime.setprofilebucket
//      runtime.freespecial
//      runtime.newMarkBits
//      runtime.nextMarkBitArenaEpoch
//      runtime.newArenaMayUnlock
//      runtime.mProf_NextCycle
//      runtime.mProf_Flush
//      runtime.mProf_Malloc
//      runtime.mProf_Free
//      runtime.saveblockevent
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      internal/poll.runtime_pollOpen
//      runtime.(*pollCache).free
//      internal/poll.runtime_pollUnblock
//      runtime.(*pollCache).alloc
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.printlock
//      runtime.forcegchelper
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.allgadd
//      runtime.mcommoninit
//      runtime.gcprocs
//      runtime.needaddgcproc
//      runtime.helpgc
//      runtime.stopTheWorldWithSema
//      runtime.startTheWorldWithSema
//      runtime.forEachP
//      runtime.runSafePointFn
//      runtime.stopm
//      runtime.startm
//      runtime.handoffp
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.injectglist
//      runtime.schedule
//      runtime.goschedImpl
//      runtime.entersyscall_sysmon
//      runtime.entersyscall_gcwait
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.gfput
//      runtime.gfget
//      runtime.gfpurge
//      runtime.incidlelocked
//      runtime.checkdead
//      runtime.sysmon
//      runtime.schedtrace
//      runtime.runqputslow
//      runtime.(*rwmutex).runlock
//      runtime.semacquire1
//      runtime.semrelease1
//      runtime.stackcacherefill
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackalloc
//      runtime.stackfree
//      runtime.syncadjustsudogs
//      runtime.freeStackSpans
//      runtime.deltimer
//      runtime.timerproc
//      runtime.timejump
//      runtime.traceReader
//      runtime.traceProcFree
//      runtime.traceAcquireBuffer
//      runtime.traceFlush
//      runtime.(*traceStackTable).put
//      runtime.tracebackothers
//      runtime.reflectOffsLock
//      runtime.freemcache.func1
//      runtime.gcBgMarkWorker.func2
//      runtime.(*mheap).freeSpan.func1
//      runtime.newdefer.func1
//      runtime.freedefer.func1
//      runtime.(*rwmutex).rlock.func1
Eq_363 runtime.lock(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, union Eq_4 & ebpOut, union Eq_4 & esiOut, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_4 ecx_20 = *((word32) eax_19 + 0x0078);
	if (ecx_20 < 0x00)
		runtime.throw(gs);
	else
	{
		*((word32) eax_19 + 0x0078) = (word32) ecx_20 + 1;
		Eq_363 ebx_40 = runtime/internal/atomic.Xchg(dwArg04, 0x01);
		Eq_4 eax_106 = dwLoc18;
		if (dwLoc18 == 0x00)
		{
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return ebx_40;
		}
		else
		{
			int32 ecx_50;
			if (g_t8157608 > 0x01)
				ecx_50 = 0x04;
			else
				ecx_50 = 0x00;
			while (true)
			{
				int32 edx_154 = 0x00;
l08053529:
				if (edx_154 < ecx_50)
					break;
				int32 edx_117 = 0x00;
l08053582:
				Eq_13374 ecx_24_8_92 = SLICE(ecx_50, word24, 8);
				if (edx_117 < 0x01)
				{
					do
					{
						ebp = *dwArg04;
						if (ebp != 0x00)
						{
							runtime.osyield();
							++edx_117;
							goto l08053582;
						}
						dwLoc18 = eax_106;
						Eq_363 ebx_125 = runtime/internal/atomic.Cas(dwArg04, 0x00, eax_106);
					} while ((byte) (word32) bLoc14 == 0x00);
					ebpOut = ebp;
					esiOut = esi;
					ediOut = edi;
					return ebx_125;
				}
				Eq_363 ebx_79 = runtime/internal/atomic.Xchg(dwArg04, 0x02);
				Eq_13382 ebx_24_8_91 = SLICE(ebx_79, word24, 8);
				if (dwLoc18 == 0x00)
				{
					ebpOut = ebp;
					esiOut = esi;
					ediOut = edi;
					return ebx_79;
				}
				dwLoc18.u0 = ~0x00;
				bLoc14 = ~0x00;
				ebp = runtime.futexsleep(ecx_24_8_92, ebx_24_8_91, esi, (struct Eq_13398 *) ~0x00, (struct Eq_13398 *) ~0x00, out esi, out edi);
				eax_106.u0 = 0x02;
			}
			do
			{
				ebp = *dwArg04;
				if (ebp != 0x00)
				{
					runtime.procyield(0x1E);
					++edx_154;
					goto l08053529;
				}
				dwLoc18 = eax_106;
				Eq_363 ebx_162 = runtime/internal/atomic.Cas(dwArg04, 0x00, eax_106);
			} while ((byte) (word32) bLoc14 == 0x00);
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return ebx_162;
		}
	}
}

// 08053620: Register Eq_4 runtime.unlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out ptr32 edxOut, Register out Eq_363 ebxOut)
// Called from:
//      runtime.chansend
//      runtime.closechan
//      runtime.chanrecv
//      runtime.GOMAXPROCS
//      runtime.getitab
//      runtime.additab
//      runtime.itabsinit
//      runtime.persistentalloc1
//      runtime.allocmcache
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.queuefinalizer
//      runtime.wakefing
//      runtime.runfinq
//      runtime.findObject
//      runtime/debug.setGCPercent
//      runtime.gcMarkTermination
//      runtime.gcSweep
//      runtime.gcResetMarkState
//      runtime.clearpools
//      runtime.gcMarkRootCheck
//      runtime.markrootFreeGStacks
//      runtime.markrootSpans
//      runtime.gcWakeAllAssists
//      runtime.gcParkAssist
//      runtime.gcFlushBgCredit
//      runtime.bgsweep
//      runtime.(*gcSweepBuf).push
//      runtime.getempty
//      runtime.prepareFreeWorkbufs
//      runtime.freeSomeWbufs
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).reclaim
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocManual
//      runtime.(*mheap).freeManual
//      runtime.(*mheap).scavenge
//      runtime.addspecial
//      runtime.removespecial
//      runtime.addfinalizer
//      runtime.removefinalizer
//      runtime.setprofilebucket
//      runtime.freespecial
//      runtime.newMarkBits
//      runtime.nextMarkBitArenaEpoch
//      runtime.newArenaMayUnlock
//      runtime.mProf_NextCycle
//      runtime.mProf_Flush
//      runtime.mProf_Malloc
//      runtime.mProf_Free
//      runtime.saveblockevent
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      internal/poll.runtime_pollOpen
//      runtime.(*pollCache).free
//      internal/poll.runtime_pollUnblock
//      runtime.(*pollCache).alloc
//      runtime.dopanic_m
//      runtime.printunlock
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.allgadd
//      runtime.mcommoninit
//      runtime.gcprocs
//      runtime.needaddgcproc
//      runtime.helpgc
//      runtime.stopTheWorldWithSema
//      runtime.startTheWorldWithSema
//      runtime.forEachP
//      runtime.runSafePointFn
//      runtime.stopm
//      runtime.startm
//      runtime.handoffp
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.injectglist
//      runtime.schedule
//      runtime.parkunlock_c
//      runtime.goschedImpl
//      runtime.entersyscall_sysmon
//      runtime.entersyscall_gcwait
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.gfput
//      runtime.gfget
//      runtime.gfpurge
//      runtime.incidlelocked
//      runtime.checkdead
//      runtime.sysmon
//      runtime.schedtrace
//      runtime.runqputslow
//      runtime.(*rwmutex).runlock
//      runtime.semacquire1
//      runtime.semrelease1
//      runtime.stackcacherefill
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackalloc
//      runtime.stackfree
//      runtime.syncadjustsudogs
//      runtime.freeStackSpans
//      runtime.deltimer
//      runtime.timerproc
//      runtime.timejump
//      runtime.traceReader
//      runtime.traceProcFree
//      runtime.traceReleaseBuffer
//      runtime.traceFlush
//      runtime.(*traceStackTable).put
//      runtime.tracebackothers
//      runtime.reflectOffsUnlock
//      runtime.chansend.func1
//      runtime.chanrecv.func1
//      runtime.freemcache.func1
//      runtime.gcBgMarkWorker.func2
//      runtime.(*mheap).freeSpan.func1
//      runtime.newdefer.func1
//      runtime.freedefer.func1
//      runtime.(*rwmutex).rlock.func1
Eq_4 runtime.unlock(struct Eq_2 * gs, Eq_4 dwArg04, ptr32 & edxOut, union Eq_363 & ebxOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_363 ebx_24 = runtime/internal/atomic.Xchg(dwArg04, 0x00);
	if (dwLoc04 == 0x00)
		runtime.throw(gs);
	else
	{
		if (dwLoc04 == 0x02)
			runtime.futexwakeup();
		Eq_4 eax_48 = gs->ptr0000->tFFFFFFFC;
		Eq_4 ecx_49 = *((word32) eax_48 + 24);
		Eq_4 edx_50 = *((word32) ecx_49 + 0x0078);
		*((word32) ecx_49 + 0x0078) = edx_50 - 0x01;
		Eq_4 ecx_54 = *((word32) *((word32) eax_48 + 24) + 0x0078);
		if (ecx_54 < 0x00)
			runtime.throw(gs);
		else
		{
			if (ecx_54 == 0x00)
			{
				ecx_54 = (word32) *((word32) eax_48 + 0x006C);
				if ((byte) ecx_54 != 0x00)
					((word32) eax_48 + 8)->u0 = ~0x0521;
			}
			edxOut = edx_50 - 0x01;
			ebxOut = ebx_24;
			return ecx_54;
		}
	}
}

// 080536F0: Register Eq_363 runtime.notewakeup(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcBgMarkWorker
//      runtime.gchelper
//      runtime.helpgc
//      runtime.startTheWorldWithSema
//      runtime.runSafePointFn
//      runtime.startm
//      runtime.handoffp
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.entersyscall_sysmon
//      runtime.entersyscall_gcwait
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.checkdead
//      runtime.(*profBuf).write
//      runtime.(*profBuf).wakeupExtra
//      runtime.(*rwmutex).runlock
//      runtime.sigsend
Eq_363 runtime.notewakeup(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_363 ebx_23 = runtime/internal/atomic.Xchg(dwArg04, 0x01);
	if (dwLoc08 != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, dwLoc08);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		runtime.futexwakeup();
		return ebx_23;
	}
}

// 080537B0: void runtime.notesleep(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_13530 nArg04)
// Called from:
//      runtime.gcMark
//      runtime.stopm
//      runtime.stoplockedm
//      runtime.(*rwmutex).rlock.func1
void runtime.notesleep(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_13530 nArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (eax_18 != *(*((word32) eax_18 + 24)))
		runtime.throw(gs);
	else
	{
		struct Eq_13398 * edx_36;
		struct Eq_13398 * ecx_35;
		if (*g_ptr81422A4 != null)
		{
			ecx_35 = (struct Eq_13398 *) 10000000;
			edx_36 = null;
		}
		else
		{
			ecx_35 = (struct Eq_13398 *) ~0x00;
			edx_36 = (struct Eq_13398 *) ~0x00;
		}
		while (true)
		{
			runtime/internal/atomic.Load();
			if (dwLoc18 != 0x00)
				break;
			*((word32) *((word32) eax_18 + 24) + 141) = 0x01;
			word32 edi_170;
			runtime.futexsleep(SLICE(dwArg04, word24, 8), SLICE(edx_36, word24, 8), esi, ecx_35, edx_36, out esi, out edi_170);
			<anonymous> * eax_88 = *g_ptr81422A4;
			if (eax_88 != null)
			{
				word32 edi_171;
				runtime.asmcgocall(gs, eax_88, 0x00, out edi_171);
			}
			*((word32) *((word32) eax_18 + 24) + 141) = 0x00;
			dwLoc18 = 0x00;
		}
	}
}

// 080538C0: Register Eq_4 runtime.notetsleep_internal(Register Eq_13613 edx, Register (ptr32 word32) ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack ptr32 dwArg04, Stack (ptr32 Eq_13398) dwArg08, Stack Eq_13619 qwArg0C)
// Called from:
//      runtime.notetsleep
//      runtime.notetsleepg
Eq_4 runtime.notetsleep_internal(Eq_13613 edx, word32 * ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, ptr32 dwArg04, struct Eq_13398 * dwArg08, Eq_13619 qwArg0C)
{
	struct Eq_13398 * dwArg0C = (word32) qwArg0C;
	word32 dwLoc14 = SLICE(qwLoc18, word32, 32);
	word32 dwLoc18 = (word32) qwLoc18;
	struct Eq_13398 * dwArg10 = SLICE(qwArg0C, word32, 32);
	ui24 ebx_24_8_22 = SLICE(ebp, word24, 8);
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	struct Eq_13398 * ecx_10 = dwArg08;
	if ((byte) (SEQ(ebx_24_8_22, dwArg0C < null) | SEQ(edx_24_8, Test(ULT,false)) & SEQ(ebx_24_8_22, dwArg0C == null)) == 0x00)
	{
		runtime/internal/atomic.Load();
		if (dwLoc14 != 0x00)
			return esi;
		runtime.nanotime();
		struct Eq_13398 * ecx_102 = dwArg0C;
		struct Eq_13398 * ebx_125 = dwArg10;
		while (true)
		{
			<anonymous> * ebp_86 = *g_ptr81422A4;
			if (ebp_86 != null)
			{
				ui24 ebx_24_8_98 = SLICE(ebp_86, word24, 8);
				Eq_4 esi_126 = SEQ(SLICE(esi, word24, 8), ecx_102 > (struct Eq_13398 *) 10000000) & SEQ(ebx_24_8_98, ebx_125 == null) | SEQ(ebx_24_8_98, ebx_125 > null);
				esi = esi_126;
				if ((byte) esi_126 != 0x00)
				{
					ecx_102 = (struct Eq_13398 *) 10000000;
					ebx_125 = null;
				}
			}
			dwLoc0C->ptr0018->b008D = 0x01;
			word32 edi_499;
			Eq_4 esi_164;
			runtime.futexsleep(SLICE(ecx_102, word24, 8), SLICE(ebx_125, word24, 8), esi, ecx_102, ebx_125, out esi_164, out edi_499);
			<anonymous> * eax_170 = *g_ptr81422A4;
			if (eax_170 != null)
			{
				word32 edi_500;
				runtime.asmcgocall(gs, eax_170, dwArg04, out edi_500);
			}
			dwLoc0C->ptr0018->b008D = 0x00;
			runtime/internal/atomic.Load();
			if (ecx_102 != null)
				break;
			ui24 ebx_24_8_216 = SLICE(runtime.nanotime(), word24, 8);
			Eq_4 esi_233 = SEQ(SLICE(esi_164, word24, 8), dwLoc10 <= 0x00) & SEQ(ebx_24_8_216, ecx_102 == dwLoc0C) | SEQ(ebx_24_8_216, ecx_102 > dwLoc0C);
			esi_164 = esi_233;
			if ((byte) esi_233 != 0x00)
				break;
			ui64 ebx_ebp_354 = dwLoc10 - ecx_102;
			esi = dwLoc10;
			ebx_125 = SLICE(ebx_ebp_354, word32, 32);
			ecx_102 = (word32) ebx_ebp_354;
		}
		runtime/internal/atomic.Load();
		return esi_164;
	}
	else
	{
		struct Eq_13398 * edx_271;
		if (*g_ptr81422A4 != null)
		{
			ecx_10 = (struct Eq_13398 *) 10000000;
			edx_271 = null;
		}
		else
			edx_271 = dwArg0C;
		while (true)
		{
			runtime/internal/atomic.Load();
			if (dwLoc18 != 0x00)
				break;
			*((word32) *((word32) eax_8 + 24) + 141) = 0x01;
			word32 edi_497;
			runtime.futexsleep(SLICE(dwArg04, word24, 8), SLICE(edx_271, word24, 8), esi, ecx_10, edx_271, out esi, out edi_497);
			<anonymous> * eax_322 = *g_ptr81422A4;
			if (eax_322 != null)
			{
				word32 edi_498;
				runtime.asmcgocall(gs, eax_322, dwArg04, out edi_498);
			}
			*((word32) *((word32) eax_8 + 24) + 141) = 0x00;
		}
		return esi;
	}
}

// 08053B00: Register Eq_4 runtime.notetsleep(Register (ptr32 word32) ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04, Stack (ptr32 Eq_13398) dwArg08, Stack word32 dwArg0C)
// Called from:
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.sysmon
Eq_4 runtime.notetsleep(word32 * ebp, Eq_4 esi, struct Eq_2 * gs, ptr32 dwArg04, struct Eq_13398 * dwArg08, word32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	Eq_4 edx_20 = *ecx_19;
	Eq_13613 edx_24_8_49 = SLICE(edx_20, word24, 8);
	if (eax_18 == edx_20 || *((word32) ecx_19 + 116) == 0x00)
		return runtime.notetsleep_internal(edx_24_8_49, ebp, esi, gs, dwLoc14, dwArg04, dwArg08, SEQ(dwLoc04, dwArg0C));
	runtime.throw(gs);
}

// 08053B80: void runtime.notetsleepg(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcBgMarkStartWorkers
//      runtime.timerproc
void runtime.notetsleepg(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = gs->ptr0000->tFFFFFFFC;
	if (eax_17 == *(*((word32) eax_17 + 24)))
		runtime.throw(gs);
	else
	{
		runtime.entersyscallblock(gs);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.notetsleep_internal(edx, ebp, esi, gs, stackArg0, dwArg04, dwArg08, dwArg0C);
		word32 esi_80;
		runtime.exitsyscall(gs, out esi_80);
	}
}

// 08053C20: void runtime.mallocinit(Register Eq_13897 ebx, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.mallocinit(Eq_13897 ebx, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((word16) (word32) g_w8138824 != 0x10)
		runtime.throw(gs);
	else
	{
		runtime.testdefersizes(gs);
		Eq_13923 eax_38 = 0x00;
		while (eax_38 < 0x43)
		{
			if (eax_38 >= 0x43)
				runtime.panicindex(gs);
			word32 ebx_524 = (word32) g_a8138820[eax_38 * 0x02];
			g_a8159254[eax_38] = (struct Eq_141127) ebx_524;
			ebx_24_8 = SLICE(ebx_524, word24, 8);
			eax_38 = (word32) eax_38 + 1;
		}
		Eq_4 eax_45 = g_t8157620;
		if (eax_45 == 0x00)
			runtime.throw(gs);
		else if (eax_45 < 0x1000)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, (uint64) (uint32) g_t8157620);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, 0x1000);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else if ((eax_45 & eax_45 - 0x01) != 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, (uint64) (uint32) g_t8157620);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			runtime.sbrk0();
			Eq_4 esi_203 = fn08090278(&g_t80F1E40, fp - 0x18);
			Eq_4 ecx_208 = 0x00;
			word32 * edx_209 = fp - 0x18;
			Eq_4 ebx_210 = 0x00;
			word32 ebp_211 = 0x00;
			while (true)
			{
				word32 ecx_220;
				Eq_4 eax_218;
				if (ecx_208 >= 0x04)
					break;
				word32 ebx_225 = *edx_209;
				uint32 ebp_228 = g_dw8139478 + 0x0013FFFF & 0xFFF00000;
				esi_203 = runtime.sysReserve(gs, fp - 0x31);
				eax_218 = dwLoc38;
				if (dwLoc38 != 0x00)
				{
					ecx_220 = ebx_225 + 0x10202000;
					goto l08053D4E;
				}
				++edx_209;
				esi_203 = ecx_208;
				ecx_208 = (word32) ecx_208 + 1;
				ebx_210 = dwLoc38;
				ebp_211 = ebx_225 + 0x10202000;
			}
			eax_218 = ebx_210;
			ecx_220 = ebp_211;
l08053D4E:
			if (eax_218 == 0x00)
				runtime.throw(gs);
			else
			{
				ui32 edx_289 = (word32) eax_218 + 0x00001FFF;
				Eq_4 ebx_291 = (edx_289 & ~0x1FFF) + 0x10200000;
				g_t81493A0 = ebx_291;
				g_t81493A8.u0 = 0x00;
				g_dw81493B4 = (word32) eax_218 + (ecx_220 - ((edx_289 & ~0x1FFF) - eax_218));
				g_t81493AC = ebx_291;
				g_t81493B0 = ebx_291;
				g_b81493B8 = 0x00;
				Eq_4 ecx_305 = g_t81493A8;
				if ((ecx_305 & 0x1FFF) != 0x00)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					Eq_4 esi_345;
					runtime.printhex(esi_203, gs, eax_218, 0x00, out esi_345);
					runtime.printsp(gs);
					Eq_4 esi_365;
					runtime.printhex(esi_345, gs, ebx_291, 0x00, out esi_365);
					runtime.printsp(gs);
					Eq_4 esi_384;
					runtime.printhex(esi_365, gs, 0x00200000, 0x00, out esi_384);
					runtime.printsp(gs);
					Eq_4 esi_403;
					runtime.printhex(esi_384, gs, 0x10000000, 0x00, out esi_403);
					runtime.printsp(gs);
					Eq_4 esi_422;
					runtime.printhex(esi_403, gs, 0x2000, 0x00, out esi_422);
					runtime.printsp(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					word32 esi_615;
					runtime.printhex(esi_422, gs, ecx_305, 0x00, out esi_615);
					runtime.printnl(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				else
				{
					runtime.(*mheap).init(gs, 0x081488E0, edx_289 & ~0x1FFF, 0x00200000);
					Eq_4 eax_500 = gs->ptr0000->tFFFFFFFC;
					runtime.allocmcache(esi_203, gs);
					((word32) *((word32) eax_500 + 24) + 0x00B8)->u0 = 0x081488E0;
				}
			}
		}
	}
}

// 08054040: void runtime.(*mheap).sysAlloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).grow
void runtime.(*mheap).sysAlloc(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 2772);
	if (dwArg08 <= ecx_18 - *((word32) dwArg04 + 0x0AD0))
	{
l0805409E:
		uint32 ebx_109 = *((word32) dwArg04 + 0x0AD0);
		if (dwArg08 <= *((word32) dwArg04 + 2772) - ebx_109)
		{
			runtime.sysMap(gs, ebx_109, (byte) (word32) *((word32) dwArg04 + 2776));
			word32 ecx_133 = Mem123[dwArg04 + 0x0AD0:word32] + dwArg08;
			*((word32) dwArg04 + 0x0AD0) = ecx_133;
			if (ecx_133 > *((word32) dwArg04 + 0x0ACC))
				runtime.(*mheap).setArenaUsed(gs, dwArg04, ecx_133);
			if ((ebx_109 & 0x1FFF) == 0x00)
				return;
			runtime.throw(gs);
		}
		goto l080540B4;
	}
	ui32 ecx_26 = (word32) dwArg08 + 0x10001FFF & 0xF0000000;
	Eq_4 ebp_27 = (word32) ecx_18 + ecx_26;
	if (ecx_18 > ebp_27)
		goto l0805409E;
	esi = ebp_27;
	if (ebp_27 - *((word32) dwArg04 + 0x0AC8) > 0x00)
		goto l0805409E;
	runtime.sysReserve(gs, fp - 33);
	dwLoc2C = fp - 33;
	if (dwLoc28 == 0x00)
	{
l080540B4:
		runtime.sysAlloc();
		int32 dwLoc20_359 = (word32) dwArg08 + 0x00001FFF & ~0x1FFF;
		if (dwLoc2C == 0x00)
			return;
		Eq_4 edx_188 = *((word32) dwArg04 + 0x0AC8);
		if (dwLoc2C >= edx_188 && (((word32) dwLoc2C + 0x00002000) + dwLoc20_359) - edx_188 <= ~0x00)
		{
			uint32 eax_199 = (word32) dwLoc2C + (-dwLoc2C & 0x1FFF);
			uint32 edx_201 = (word32) dwArg08 + eax_199;
			if (edx_201 > *((word32) dwArg04 + 0x0ACC))
				runtime.(*mheap).setArenaUsed(gs, dwArg04, edx_201);
			if ((eax_199 & 0x1FFF) == 0x00)
				return;
			runtime.throw(gs);
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			word32 esi_483;
			runtime.printhex(esi, gs, dwLoc2C, 0x00, out esi_483);
			runtime.printstring(gs);
			word32 esi_484;
			runtime.printhex(esi, gs, edx_188, 0x00, out esi_484);
			runtime.printstring(gs);
			word32 esi_485;
			runtime.printhex(esi, gs, (word32) edx_188 - 1, SLICE(cond((word32) edx_188 - 1), bool, 1), out esi_485);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.sysFree();
			return;
		}
	}
	Eq_4 edx_53 = *((word32) dwArg04 + 2772);
	if (dwLoc28 == edx_53)
	{
		*((word32) dwArg04 + 2772) = ebp_27;
		*((word32) dwArg04 + 2776) = 0x00;
		goto l08054316;
	}
	Eq_4 ebx_56 = *((word32) dwArg04 + 0x0AC8);
	if (ebx_56 <= dwLoc28)
	{
		Eq_4 esi_61 = (word32) dwLoc28 + ecx_26;
		esi = esi_61 - ebx_56;
		if (esi <= 0x00 && edx_53 - *((word32) dwArg04 + 0x0AD0) < 0x01000000)
		{
			*((word32) dwArg04 + 2772) = esi_61;
			*((word32) dwArg04 + 0x0AD0) = (word32) dwLoc28 + 0x00001FFF & ~0x1FFF;
			*((word32) dwArg04 + 2776) = 0x00;
l08054316:
			goto l0805409E;
		}
	}
	runtime.sysFree();
	dwLoc2C = fp - 0x08;
	goto l08054316;
}

// 080543E0: void runtime.nextFreeFast(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mallocgc
void runtime.nextFreeFast(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/sys.Ctz64(*((word32) dwArg04 + 32), *((word32) dwArg04 + 36));
	if (dwLoc10 >= 0x40)
		return;
	Eq_4 ebx_32 = *((word32) dwArg04 + 24);
	Eq_4 esi_34 = *((word32) dwArg04 + 28);
	if (ebx_32 + dwLoc10 >=u esi_34)
		return;
	Eq_4 ebx_41 = (word32) ebx_32 + ((word32) dwLoc10 + 1);
	if ((ebx_41 & 0x3F) == 0x00 && ebx_41 != esi_34)
		return;
	Eq_4 edi_55 = *((word32) dwArg04 + 36);
	Eq_14439 eax_70 = -((word32) dwLoc10 - 31);
	ui32 eax_82 = 0x00 - (dwLoc10 < ~0x1E);
	*((word32) dwArg04 + 32) = edi_55 >> (byte) ((word32) dwLoc10 - 31) & 0x00 - (dwLoc10 < 0x3F) | (*((word32) dwArg04 + 32) >> (byte) ((word32) dwLoc10 + 1) & eax_82 | edi_55 << (byte) eax_70 & 0x00 - (eax_70 < 0x20));
	*((word32) dwArg04 + 36) = edi_55 >> (byte) ((word32) dwLoc10 + 1) & eax_82;
	*((word32) dwArg04 + 24) = ebx_41;
	*((word32) dwArg04 + 56) = (word16) ((word32) *((word32) dwArg04 + 56) + 0x01);
}

// 080544E0: void runtime.(*mcache).nextFree(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.mallocgc
void runtime.(*mcache).nextFree(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 edx_22 = (word32) (byte) (word32) bArg08;
	if (edx_22 >= 0x86)
		runtime.panicindex(gs);
	else
	{
		Eq_4 ecx_30 = *((word32) dwArg04 + (edx_22 * 0x04 + 20));
		runtime.(*mspan).nextFreeIndex(gs, ecx_30);
		Eq_4 ecx_136 = ecx_30;
		Eq_4 edx_39 = *((word32) ecx_30 + 28);
		if (dwLoc20 == edx_39)
		{
			word16 ax_46 = (word16) (word32) *((word32) ecx_30 + 56);
			if ((word32) ax_46 != edx_39)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(ebx, gs, (word32) (word16) (word32) ax_46);
				runtime.printsp(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(ebx, gs, edx_39);
				runtime.printnl(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			word32 ebp_295;
			word32 edi_296;
			runtime.systemstack(gs, fp - 0x0C, out ebp_295, out edi_296);
			Eq_4 eax_128 = *((word32) dwArg04 + (edx_22 * 0x04 + 20));
			runtime.(*mspan).nextFreeIndex(gs, eax_128);
			ecx_136 = eax_128;
		}
		if (dwLoc20 >= *((word32) ecx_136 + 28))
			runtime.throw(gs);
		else
		{
			Eq_4 bp_157 = (word16) ((word32) *((word32) ecx_136 + 56) + 0x01);
			*((word32) ecx_136 + 56) = bp_157;
			Eq_4 esi_162 = *((word32) ecx_136 + 28);
			if ((word32) bp_157 <= esi_162)
				return;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx, gs, (word32) (word16) (word32) bp_157);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx, gs, esi_162);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
	}
}

// 08054730: Register Eq_4 runtime.mallocgc(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C, Register out Eq_4 ebxOut, Register out Eq_4 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.makechan
//      runtime.convT2E
//      runtime.convT2E32
//      runtime.convT2Estring
//      runtime.convT2Eslice
//      runtime.convT2I32
//      runtime.newobject
//      runtime.newarray
//      runtime.runfinq
//      runtime.makeslice
//      runtime.growslice
//      runtime.slicebytetostring
//      runtime.rawstring
//      runtime.rawbyteslice
//      runtime.rawruneslice
//      runtime.newdefer.func2
Eq_4 runtime.mallocgc(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C, union Eq_4 & ebxOut, union Eq_4 & esiOut, union Eq_4 & ediOut)
{
	ui24 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx = runtime.morestack_noctxt();
	if (g_dw81575E4 == 0x02)
		runtime.throw(gs);
	if (dwArg04 == 0x00)
	{
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return edx;
	}
	if (g_dw8157748 != 0x00)
	{
		Eq_4 edx_802 = runtime.persistentalloc(gs);
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return edx_802;
	}
	Eq_4 edx_186;
	if (g_dw81575DC != 0x00)
	{
		Eq_4 ecx_49 = gs->ptr0000->tFFFFFFFC;
		edx_186 = *((word32) *((word32) ecx_49 + 24) + 84);
		if (edx_186 == 0x00)
			edx_186 = ecx_49;
		Eq_14690 ecx_60 = *((byte) edx_186.u0 + 0x00CC) - dwArg04;
		Eq_4 eax_62 = *((byte) edx_186.u0 + 0x00D0);
		*((byte) edx_186.u0 + 0x00CC) = ecx_60;
		Eq_4 eax_65 = eax_62 - (ecx_60 < 0x00);
		*((byte) edx_186.u0 + 0x00D0) = eax_65;
		if ((byte) (SEQ(SLICE(eax_65, word24, 8), eax_65 < 0x00) | SEQ(ebx_24_8, eax_65 == 0x00) & SEQ(SLICE(ecx_60, word24, 8), Test(ULT,false))) != 0x00)
			runtime.gcAssistAlloc(esi, gs, edx_186, dwLoc4C);
	}
	else
		edx_186.u0 = 0x00;
	Eq_4 eax_103 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_104 = *((word32) eax_103 + 24);
	*((word32) ecx_104 + 0x0078) = (word32) *((word32) ecx_104 + 0x0078) + 1;
	Eq_4 ecx_108 = *((word32) eax_103 + 24);
	if (*((word32) ecx_108 + 0x0068) != 0x00)
		runtime.throw(gs);
	if (*((word32) ecx_108 + 44) == (gs->ptr0000)->tFFFFFFFC)
		runtime.throw(gs);
	Eq_4 esi_148;
	((word32) ecx_108 + 0x0068)->u0 = 0x01;
	Eq_4 eax_143 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x00B8);
	if (dwArg08 != 0x00)
	{
		word32 esi_149 = (word32) *((word32) dwArg08 + 0x0F);
		esi_148 = SEQ(SLICE(esi_149, word24, 8), ((byte) esi_149 & 0x80) != 0x00);
	}
	else
		esi_148.u0 = 0x01;
	Eq_4 dwArg04_851;
	byte cl_487;
	Eq_4 eax_228;
	byte al_180 = (byte) esi_148;
	if (dwArg04 <= 0x8000)
	{
		if ((byte) esi_148 != 0x00 && dwArg04 < 0x10)
		{
			edi = *((word32) eax_143 + 0x0C);
			if ((dwArg04 & 0x07) == 0x00)
				edi = (word32) edi + 7 & ~0x07;
			else if ((dwArg04 & 0x03) == 0x00)
				edi = (word32) edi + 3 & ~0x03;
			else if ((dwArg04 & 0x01) == 0x00)
				edi = (word32) edi + 1 & ~0x01;
			word32 edx_418 = edi + dwArg04;
			if (edx_418 <= 0x10)
			{
				Eq_4 ebx_423 = *((word32) eax_143 + 8);
				if (ebx_423 != 0x00)
				{
					*((word32) eax_143 + 0x0C) = edx_418;
					*((word32) eax_143 + 16) = (word32) *((word32) eax_143 + 16) + 1;
					((word32) ecx_108 + 0x0068)->u0 = 0x00;
					Eq_4 eax_768 = gs->ptr0000->tFFFFFFFC;
					Eq_4 edx_769 = *((word32) ecx_108 + 0x0078);
					*((word32) ecx_108 + 0x0078) = edx_769 - 0x01;
					word32 ebx_760 = ebx_423 + edi;
					if (edx_769 == 0x01 && (byte) ((word32) (*((word32) eax_768 + 0x006C))) != 0x00)
						((word32) eax_768 + 8)->u0 = ~0x0521;
					ebxOut = ebx_760;
					esiOut = esi_148;
					ediOut = edi;
					return edx_769;
				}
			}
			runtime.nextFreeFast(gs, *((word32) eax_143 + 40));
			eax_228 = dwLoc4C;
			if (dwLoc4C != 0x00)
				cl_487 = 0x00;
			else
			{
				runtime.(*mcache).nextFree(gs, eax_143, 0x05);
				eax_228 = dwLoc48;
				cl_487 = (byte) (word32) bLoc40;
			}
			*eax_228 = 0x00;
			*((word32) eax_228 + 4) = 0x00;
			((word32) eax_228 + 8)->u0 = 0x00;
			((word32) eax_228 + 0x0C)->u0 = 0x00;
			if (dwArg04 < *((word32) eax_143 + 0x0C) || *((word32) eax_143 + 8) == 0x00)
			{
				*((word32) eax_143 + 8) = eax_228;
				*((word32) eax_143 + 0x0C) = dwArg04;
			}
			dwArg04_851.u0 = 0x10;
		}
		else
		{
			ui32 edx_1269;
			if (dwArg04 <= 1016)
			{
				if ((word32) dwArg04 + 7 >> 0x03 >= 0x81)
					runtime.panicindex(gs);
				edx_1269 = (word32) ((word32) dwArg04 + 7 >> 0x03)->b8138640;
			}
			else
			{
				if (dwArg04 - 0x0381 >> 0x07 >= 0xF9)
					runtime.panicindex(gs);
				edx_1269 = (word32) (dwArg04 - 0x0381 >> 0x07)->b81396E0;
			}
			edi = (word32) (byte) edx_1269;
			if (edi >= 0x43)
				runtime.panicindex(gs);
			Eq_4 ecx_287 = (word32) g_a8138820[edi * 0x02];
			byte dl_317 = (byte) (edx_1269 << 0x01 | (word32) ((byte) esi_148));
			dwArg04_851 = ecx_287;
			uint32 ecx_318 = (word32) dl_317;
			if (ecx_318 >= 0x86)
				runtime.panicindex(gs);
			uip32 edx_1267;
			Eq_4 ecx_347;
			Eq_4 ecx_326 = *((word32) eax_143 + (ecx_318 * 0x04 + 20));
			runtime.nextFreeFast(gs, ecx_326);
			Eq_4 eax_333 = dwLoc4C;
			if (dwLoc4C != 0x00)
			{
				ecx_347 = ecx_326;
				edx_1267 = 0x00;
			}
			else
			{
				runtime.(*mcache).nextFree(gs, eax_143, (byte) (word32) dl_317);
				eax_333 = dwLoc48;
				ecx_347 = dwLoc44;
				edx_1267 = (word32) bLoc40;
			}
			byte dl_368 = (byte) edx_1267;
			uip32 edx_383 = edx_1267;
			if ((byte) (word32) bArg0C != 0x00)
			{
				edx_383 = edx_1267;
				if ((byte) (word32) *((word32) ecx_347 + 61) != 0x00)
				{
					edi = runtime.memclrNoHeapPointers(eax_333, ecx_287);
					edx_383 = (word32) dl_368;
				}
			}
			eax_228 = eax_333;
			cl_487 = (byte) edx_383;
		}
	}
	else
	{
		word32 ebp_1281;
		word32 edi_1282;
		runtime.systemstack(gs, fp - 0x10, out ebp_1281, out edi_1282);
		((union Eq_4 *) 0x18)->u0 = 0x01;
		((union Eq_4 *) 0x38)->u1 = 0x01;
		dwArg04_851 = *(union Eq_4 *) 0x40;
		eax_228 = *(union Eq_4 *) 0x0C;
		cl_487 = 0x01;
	}
	Eq_4 ebp_567;
	Eq_4 edx_563;
	Eq_4 esi_1210 = esi_148;
	if ((byte) (word32) al_180 != 0x00)
	{
		edx_563.u0 = 0x00;
		ebp_567 = dwArg04;
	}
	else
	{
		Eq_4 edx_505;
		if (g_t8144FC4 == dwArg08)
			edx_505.u0 = 0x1C;
		else
			edx_505 = dwArg04;
		Eq_4 ecx_541;
		runtime.heapBitsSetType(gs, eax_228, dwArg04_851, edx_505, dwArg08);
		Eq_4 ecx_537 = *dwArg08;
		if (edx_505 > ecx_537)
		{
			Eq_4 ebx_543 = *((word32) dwArg08 + 4);
			if (ebx_543 != 0x00)
				ecx_541 = (word32) ebx_543 + (edx_505 - ecx_537);
			else
				ecx_541.u0 = 0x00;
		}
		else
			ecx_541 = *((word32) dwArg08 + 4);
		esi_1210 = Mem517[eax_143 + 0x04:word32] + ecx_541;
		*((word32) eax_143 + 4) = esi_1210;
		ebp_567 = edx_505;
		edx_563 = ecx_541;
	}
	runtime.publicationBarrier();
	if (g_dw81575E4 != 0x00)
		runtime.gcmarknewobject(gs, dwArg04_851, edx_563);
	((word32) ecx_108 + 0x0068)->u0 = 0x00;
	Eq_4 ecx_613 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_614 = *((word32) ecx_108 + 0x0078);
	*((word32) ecx_108 + 0x0078) = edx_614 - 0x01;
	if (edx_614 == 0x01 && (byte) ((word32) (*((word32) ecx_613 + 0x006C))) != 0x00)
		((word32) ecx_613 + 8)->u0 = ~0x0521;
	Eq_4 edx_1193;
	edx_1193 = edx_614;
	if (g_dw8157720 != 0x00)
		edx_1193 = runtime.tracealloc(gs, dwArg08);
	Eq_4 eax_646 = g_t8136004;
	Eq_4 ebx_1272 = edx_614 - 0x01;
	if (eax_646 <= 0x00)
	{
l08054A20:
		ebp_567 = ebx_1272;
		if (edx_186 != 0x00)
		{
			Eq_14690 ecx_711 = *((byte) edx_186.u0 + 0x00CC) - (dwArg04_851 - ebp_567);
			Eq_4 edx_713 = *((byte) edx_186.u0 + 0x00D0);
			*((byte) edx_186.u0 + 0x00CC) = ecx_711;
			edx_1193 = edx_713 - (ecx_711 < 0x00);
			*((byte) edx_186.u0 + 0x00D0) = edx_1193;
		}
		if ((byte) (word32) cl_487 != 0x00)
		{
			edx_1193 = runtime.gcTrigger.test(edx_1193, gs, 0x01, 0x00);
			if ((byte) (word32) bLoc40 != 0x00)
			{
				word32 esi_1283;
				edx_1193 = runtime.gcStart(gs, 0x00, 0x01, 0x00, 0x00, out esi_1283);
			}
		}
		ebxOut = ebp_567;
		esiOut = esi_1210;
		ediOut = edi;
		return edx_1193;
	}
	else
	{
		if (dwArg04_851 < eax_646)
		{
			Eq_4 edx_654 = *eax_143;
			if (dwArg04_851 < edx_654)
			{
				edx_1193 = edx_654 - dwArg04_851;
				*eax_143 = edx_1193;
				ebx_1272 = edx_614 - 0x01;
				goto l08054A20;
			}
		}
		Eq_4 eax_662 = gs->ptr0000->tFFFFFFFC;
		Eq_4 ecx_663 = *((word32) eax_662 + 24);
		*((word32) ecx_663 + 0x0078) = (word32) *((word32) ecx_663 + 0x0078) + 1;
		Eq_4 eax_668 = *((word32) eax_662 + 24);
		runtime.profilealloc(gs, eax_668);
		Eq_4 eax_685 = gs->ptr0000->tFFFFFFFC;
		edx_1193 = *((word32) eax_668 + 0x0078);
		*((word32) eax_668 + 0x0078) = edx_1193 - 0x01;
		ebx_1272 = edx_1193 - 0x01;
		if (edx_1193 == 0x01)
		{
			ebx_1272 = edx_1193 - 0x01;
			if ((byte) (word32) *((word32) eax_685 + 0x006C) != 0x00)
			{
				((word32) eax_685 + 8)->u0 = ~0x0521;
				ebx_1272 = edx_1193 - 0x01;
			}
		}
		goto l08054A20;
	}
}

// 08054E90: void runtime.largeAlloc(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm1, Stack uint32 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.mallocgc.func1
void runtime.largeAlloc(Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm1, uint32 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 + 0x2000 < dwArg04)
		runtime.throw(gs);
	else
	{
		uint32 eax_31 = dwArg04 >> 0x0D;
		if ((dwArg04 & 0x1FFF) != 0x00)
			eax_31 = (dwArg04 >> 0x0D) + 0x01;
		Eq_4 esi_58 = runtime.deductSweepCredit(esi, gs, xmm1, eax_31 << 0x0D, eax_31);
		runtime.(*mheap).alloc(gs, (byte) (word32) bArg08);
		if (dwLoc10 == null)
			runtime.throw(gs);
		else
		{
			dwLoc10->dw0050 = (word32) dwLoc10->t000C + dwArg04;
			runtime.heapBitsForSpan(esi_58, gs, dwLoc10->t000C);
			runtime.heapBits.initSpan(esi_58, gs, eax_31, dwLoc10);
		}
	}
}

// 08054FA0: void runtime.newobject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.makechan
//      runtime.(*hmap).newoverflow
//      runtime.makemap
//      runtime.mapassign
//      runtime.mapiterinit
//      runtime.hashGrow
//      reflect.mapiterinit
//      runtime.getitab
//      runtime.additab
//      runtime.panicdottypeE
//      runtime.assertE2I
//      reflect.unsafe_New
//      runtime.gcBgMarkWorker
//      runtime.acquireSudog
//      runtime.mcommoninit
//      runtime.allocm
//      runtime.malg
//      runtime.procresize
//      syscall.runtime_envs
//      os.runtime_args
//      reflect.typelinks
//      runtime.CallersFrames
//      runtime.modulesinit
//      runtime.traceGoCreate
//      errors.New
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*entry).tryLoadOrStore
//      sync.poolCleanup
//      sync.init
//      internal/poll.(*pollDesc).wait
//      os.(*File).Write
//      os.Readlink
//      os.newFile
//      os.(*file).close
//      reflect.makeMethodValue
//      reflect.(*rtype).Method
//      reflect.(*structType).Field
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
//      reflect.methodReceiver
//      reflect.Value.Complex
//      reflect.Value.Elem
//      reflect.Value.Field
//      reflect.Value.Float
//      reflect.Value.Index
//      reflect.Value.Int
//      reflect.Value.CanInterface
//      reflect.valueInterface
//      reflect.Value.IsNil
//      reflect.Value.Len
//      reflect.Value.NumMethod
//      reflect.Value.Pointer
//      reflect.Value.Slice
//      reflect.Value.Type
//      reflect.Value.Uint
//      fmt.glob..func1
void runtime.newobject(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebx_44;
	word32 esi_45;
	word32 edi_46;
	runtime.mallocgc(ebx, gs, *dwArg04, dwArg04, 0x01, out ebx_44, out esi_45, out edi_46);
}

// 08054FE0: void reflect.unsafe_New(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.packEface
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.Zero
//      reflect.New
//      reflect.Value.assignTo
//      reflect.makeInt
//      reflect.makeFloat
//      reflect.makeComplex
//      reflect.cvtDirect
//      reflect.cvtT2I
//      reflect.funcLayout.func1
void reflect.unsafe_New(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, dwArg04);
}

// 08055020: Register word32 runtime.newarray(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 ediOut)
// Called from:
//      runtime.makechan
//      runtime.mapassign
//      runtime.makeBucketArray
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
word32 runtime.newarray(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 >= 0x00)
	{
		Eq_4 eax_29;
		Eq_4 ebx_22 = *dwArg04;
		if (ebx_22 < 33)
			eax_29 = *((char *) g_a81386E0 + ebx_22 * 0x04);
		else
			eax_29 = (uint32) (0xFFFFFFFF /u ebx_22);
		if (dwArg08 <= eax_29)
		{
			Eq_4 ebx_59 = ebx_22 *s dwArg08;
			ptr32 edi_69;
			word32 esi_71;
			word32 ebx_102;
			runtime.mallocgc(ebx_59, gs, ebx_59, dwArg04, 0x01, out ebx_102, out esi_71, out edi_69);
			ediOut = edi_69;
			return esi_71;
		}
	}
	runtime.gopanic(gs);
}

// 080550B0: void runtime.profilealloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mallocgc
void runtime.profilealloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.nextSample(gs);
	**((word32) dwArg04 + 0x00B8) = dwLoc08;
	runtime.mProf_Malloc(gs, dwArg08);
}

// 08055100: void runtime.nextSample(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.profilealloc
//      runtime.allocmcache
void runtime.nextSample(struct Eq_2 * gs)
{
	word32 dwLoc30_177 = SLICE(rLoc34, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t8136004;
	if (eax_17 <= 0x07000000 && eax_17 == 0x00)
		return;
	Eq_4 ecx_33 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	int32 edx_34 = *((word32) ecx_33 + 0x0094);
	*((word32) ecx_33 + 0x0094) = edx_34 << 0x01 ^ edx_34 >> 0x1F & 0xA8888EEF;
	runtime.uint32tofloat64();
	uint32 dwLoc1C_165 = SLICE((real64) (uint128) (uint64) rLoc34, word32, 32);
	uint32 ecx_61 = dwLoc1C_165 >> 0x0F & 0x1F;
	ui32 eax_56 = dwLoc1C_165 >> 0x14 & 0x07FF;
	if (SLICE(cond(ecx_61 + 0x01), bool, 1) == false)
	{
		real64 rLoc30_178 = SEQ(dwLoc2C, dwLoc30_177);
		if (ecx_61 < 0x20)
		{
			real64 rLoc08_170 = (real64) (uint128) (uint64) g_a8139C00[ecx_61 * 0x08];
			real64 rLoc10_171 = (real64) (uint128) (uint64) g_a8139C00[(ecx_61 + 0x01) * 0x08];
			runtime.int64tofloat64(ebx, gs, eax_56 + ~0x03FE);
			runtime.uint64tofloat64(gs, 0x00);
			uint128 xmm0_116 = (uint128) (uint64) (real64) (uint128) (uint64) rLoc30_178;
			uint128 xmm1_117 = (uint128) (uint64) rLoc08_170;
			Eq_661 xmm1_136 = (uint128) (uint64) g_r80F1878;
			Eq_661 v28_137 = (real64) xmm0_116 + (real64) xmm1_117 + (real64) ((uint128) ((uint64) g_r80F1830)) * (((real64) ((uint128) ((uint64) rLoc10_171)) - (real64) xmm1_117) * (real64) ((uint128) ((uint64) rLoc30_178))) - (real64) xmm1_136;
			Eq_661 xmm0_139 = SEQ(SLICE(xmm0_116, word64, 64), v28_137);
			if (v28_137 > __xorps(xmm1_136, xmm1_136))
				__xorps(xmm0_139, xmm0_139);
		}
	}
	runtime.panicindex(gs);
}

// 080552C0: Register Eq_4 runtime.persistentalloc(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.getitab
//      runtime.mallocgc
//      runtime.progToPointerMask
//      runtime.queuefinalizer
//      runtime.(*fixalloc).alloc
//      runtime.(*gcSweepBuf).push
//      runtime.newBucket
//      runtime.(*pollCache).alloc
Eq_4 runtime.persistentalloc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8B(0x00, fp - 0x14);
	word32 ebp_61;
	word32 edi_62;
	runtime.systemstack(gs, fp - 0x14, out ebp_61, out edi_62);
	return <invalid>;
}

// 08055340: void runtime.persistentalloc1(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.persistentalloc.func1
void runtime.persistentalloc1(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if (dwArg04 == 0x00)
		runtime.throw(gs);
	Eq_4 ecx_31 = dwArg08;
	if (dwArg08 != 0x00)
	{
		if ((dwArg08 & dwArg08 - 0x01) != 0x00)
			runtime.throw(gs);
		if (dwArg08 > 0x2000)
			runtime.throw(gs);
	}
	else
		ecx_31.u0 = 0x08;
	if (dwArg04 >= 0x00010000)
	{
		runtime.sysAlloc();
		return;
	}
	Eq_4 ebx_122;
	Eq_4 edx_86 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ebx_87 = *((word32) edx_86 + 24);
	*((word32) ebx_87 + 0x0078) = (word32) *((word32) ebx_87 + 0x0078) + 1;
	Eq_4 edx_91 = *((word32) edx_86 + 24);
	if (edx_91 != 0x00)
	{
		Eq_4 ebx_96 = *((word32) edx_91 + 92);
		if (ebx_96 != 0x00)
		{
			ebx_122 = (word32) ebx_96 + 0x0938;
l080553D0:
			uint32 ecx_135 = ~(ecx_31 - 0x01) & (word32) (*((word32) ebx_122 + 4)) + (ecx_31 - 0x01);
			*((word32) ebx_122 + 4) = ecx_135;
			if ((word32) dwArg04 + ecx_135 > 0x00040000 || *ebx_122 == 0x00)
			{
				runtime.sysAlloc();
				if (g_t81576F0 == 0x00)
					*ebx_122 = dwLoc18;
				else
					runtime.writebarrierptr(ebx_122, dwLoc18);
				if (dwLoc18 == 0x00)
				{
					if (ebx_122 == 0x0814514C)
					{
						word32 ebx_419;
						word32 edx_418;
						runtime.unlock(gs, 0x08145148, out edx_418, out ebx_419);
					}
					runtime.throw(gs);
				}
				*((word32) ebx_122 + 4) = 0x00;
			}
			Mem227[ebx_122 + 0x04:word32] = dwArg04 + Mem220[ebx_122 + 0x04:word32];
			Eq_4 edx_230 = gs->ptr0000->tFFFFFFFC;
			Eq_4 esi_232 = *((word32) edx_91 + 0x0078);
			*((word32) edx_91 + 0x0078) = esi_232 - 0x01;
			if (esi_232 == 0x01 && (byte) ((word32) (*((word32) edx_230 + 0x006C))) != 0x00)
				((word32) edx_230 + 8)->u0 = ~0x0521;
			if (ebx_122 == 0x0814514C)
			{
				word32 ebx_417;
				word32 edx_416;
				runtime.unlock(gs, 0x08145148, out edx_416, out ebx_417);
			}
			if (dwArg0C != 0x08158220)
			{
				runtime.mSysStatInc(dwArg0C, dwArg04);
				Eq_4 esp_283 = <invalid>;
				esp_283->u0 = 0x08158220;
				*((word32) esp_283 + 4) = *((word32) esp_283 + 36);
				runtime.mSysStatDec(*esp_283, *((word32) esp_283 + 4));
			}
			return;
		}
	}
	word32 ebp_413;
	word32 esi_414;
	word32 edi_415;
	runtime.lock(esi, gs, 0x08145148, out ebp_413, out esi_414, out edi_415);
	ebx_122.u0 = 0x0814514C;
	goto l080553D0;
}

// 080555E0: void runtime.gcmarkwb_m(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.writebarrierptr_prewrite1.func1
void runtime.gcmarkwb_m(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if ((byte) (word32) g_t81576F4 == 0x00)
		return;
	if (dwArg04 >= 0x1000)
	{
		Eq_4 eax_27 = *dwArg04;
		if (eax_27 != 0x00)
			runtime.shade(gs, eax_27);
	}
	if (dwArg08 == 0x00)
		return;
	Eq_4 ecx_49 = g_t81493A8;
	if (dwArg08 < ecx_49 || dwArg08 >= g_t81493AC)
		return;
	Eq_4 edx_55 = g_t8149108;
	uint32 eax_58 = dwArg08 - ecx_49;
	if (eax_58 >> 0x0D >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		struct Eq_15915 * eax_63 = *((word32) edx_55 + (eax_58 >> 0x0D) * 0x04);
		if (eax_63 != null && (dwArg08 >= eax_63->t000C && (dwArg08 < eax_63->t0050 && (byte) ((word32) eax_63->b003C) == 0x01)))
			runtime.shade(gs, dwArg08);
	}
}

// 080556A0: void runtime.writebarrierptr_prewrite1(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.writebarrierptr
//      runtime.writebarrierptr_prewrite
//      runtime.bulkBarrierPreWrite
//      runtime.bulkBarrierBitmap
void runtime.writebarrierptr_prewrite1(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_9 = *((word32) eax_8 + 24);
	*((word32) ecx_9 + 0x0078) = (word32) *((word32) ecx_9 + 0x0078) + 1;
	Eq_4 ecx_13 = *((word32) eax_8 + 24);
	if ((byte) (word32) *((word32) ecx_13 + 0x008E) == 0x00 && *((word32) ecx_13 + 0x0080) <= 0x00)
	{
		word32 ebp_113;
		word32 edi_114;
		runtime.systemstack(gs, fp - 0x10, out ebp_113, out edi_114);
		*((word32) ecx_13 + 0x008E) = 0x00;
		Eq_4 ecx_41 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_42 = *((word32) ecx_13 + 0x0078);
		*((word32) ecx_13 + 0x0078) = edx_42 - 0x01;
		if (edx_42 == 0x01 && (byte) ((word32) (*((word32) ecx_41 + 0x006C))) != 0x00)
			((word32) ecx_41 + 8)->u0 = ~0x0521;
	}
	else
	{
		Eq_4 eax_59 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_61 = *((word32) ecx_13 + 0x0078);
		*((word32) ecx_13 + 0x0078) = edx_61 - 0x01;
		if (edx_61 == 0x01 && (byte) ((word32) (*((word32) eax_59 + 0x006C))) != 0x00)
			((word32) eax_59 + 8)->u0 = ~0x0521;
	}
}

// 08055770: void runtime.writebarrierptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.alginit
//      runtime.cgocall
//      runtime.makechan
//      runtime.chansend
//      runtime.send
//      runtime.closechan
//      runtime.chanrecv
//      runtime.recv
//      runtime.(*waitq).dequeue
//      runtime.(*hmap).newoverflow
//      runtime.makemap
//      runtime.mapassign
//      runtime.mapiterinit
//      runtime.mapiternext
//      runtime.makeBucketArray
//      runtime.hashGrow
//      runtime.evacuate
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.getitab
//      runtime.additab
//      runtime.panicdottypeE
//      runtime.convT2Estring
//      runtime.convT2Eslice
//      runtime.assertE2I
//      reflect.ifaceE2I
//      runtime.persistentalloc1
//      runtime.queuefinalizer
//      runtime.runfinq
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      sync.runtime_registerPoolCleanup
//      runtime.clearpools
//      runtime.markrootFreeGStacks
//      runtime.gcAssistAlloc
//      runtime.gcAssistAlloc1
//      runtime.bgsweep
//      runtime.recordspan
//      runtime.(*mheap).init
//      runtime.addfinalizer
//      runtime.stkbucket
//      internal/poll.runtime_pollUnblock
//      runtime.sysauxv
//      runtime.mpreinit
//      runtime.deferproc
//      runtime.init.2
//      runtime.newdefer
//      runtime.freedefer
//      runtime.deferreturn
//      runtime.preprintpanics
//      runtime.gopanic
//      runtime.startpanic_m
//      runtime.main
//      runtime.forcegchelper
//      runtime.gopark
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.allgadd
//      runtime.schedinit
//      runtime.mcommoninit
//      runtime.stopTheWorld
//      runtime.startTheWorld
//      runtime.forEachP
//      runtime.allocm
//      runtime.oneNewExtraM
//      runtime.execute
//      runtime.park_m
//      runtime.goexit0
//      runtime.newproc1
//      runtime.gfput
//      runtime.gfget
//      runtime.gfpurge
//      runtime.unlockOSThread
//      runtime.procresize
//      runtime.(*randomOrder).reset
//      runtime.args
//      runtime.goargs
//      runtime.goenvs_unix
//      reflect.typelinks
//      reflect.addReflectOff
//      runtime.(*semaRoot).queue
//      runtime.(*semaRoot).dequeue
//      runtime.(*semaRoot).rotateLeft
//      runtime.(*semaRoot).rotateRight
//      runtime.newstack
//      runtime.CallersFrames
//      runtime.(*Frames).Next
//      runtime.(*pcExpander).init
//      runtime.(*pcExpander).next
//      runtime.modulesinit
//      runtime.deltimer
//      runtime.timerproc
//      runtime.siftupTimer
//      runtime.siftdownTimer
//      runtime.typelinksinit
//      runtime.persistentalloc.func1
//      runtime.typedslicecopy.func1
//      runtime.markroot.func1
//      runtime.newdefer.func1
//      runtime.newdefer.func2
//      runtime.freedefer.func1
//      errors.New
//      strconv.init
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*entry).tryLoadOrStore
//      sync.(*Map).missLocked
//      sync.(*Map).dirtyLocked
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).pinSlow
//      sync.poolCleanup
//      sync.init
//      io.init
//      syscall.init
//      time.init
//      internal/poll.(*pollDesc).wait
//      internal/poll.init
//      os.(*File).Write
//      os.Readlink
//      os.newFile
//      os.(*file).close
//      os.init.0
//      os.init
//      unicode.init
//      reflect.makeMethodValue
//      reflect.(*rtype).Method
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*rtype).ptrTo
//      reflect.typesByString
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.addTypeBits
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
//      reflect.methodReceiver
//      reflect.callMethod
//      reflect.Value.Complex
//      reflect.Value.Elem
//      reflect.Value.Field
//      reflect.Value.Float
//      reflect.Value.Index
//      reflect.Value.Int
//      reflect.Value.CanInterface
//      reflect.valueInterface
//      reflect.Value.IsNil
//      reflect.Value.Len
//      reflect.Value.MapKeys
//      reflect.Value.NumMethod
//      reflect.Value.Pointer
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.SetString
//      reflect.Value.Slice
//      reflect.Value.Type
//      reflect.Value.Uint
//      reflect.ValueOf
//      reflect.Value.assignTo
//      reflect.cvtT2I
//      reflect.FuncOf.func1
//      reflect.init
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_float
//      fmt.(*buffer).WriteRune
//      fmt.newPrinter
//      fmt.(*pp).free
//      fmt.(*pp).Write
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
//      fmt.(*pp).doPrintln
//      fmt.init
void runtime.writebarrierptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	if ((byte) (word32) g_b81576F5 != 0x00)
		runtime.cgoCheckWriteBarrier(gs);
	if ((byte) (word32) g_t81576F4 == 0x00)
		*dwArg04 = dwArg08;
	else
	{
		if (dwArg08 != 0x00 && dwArg08 < 0x1000)
		{
			word32 ebp_100;
			word32 edi_101;
			runtime.systemstack(gs, fp - 0x0C, out ebp_100, out edi_101);
		}
		runtime.writebarrierptr_prewrite1(gs);
		*dwArg04 = dwArg08;
	}
}

// 08055810: void runtime.writebarrierptr_prewrite(Stack Eq_4 dwArg08)
// Called from:
//      runtime.atomicstorep
//      runtime.casp
//      sync/atomic.StorePointer
//      sync/atomic.CompareAndSwapPointer
//      runtime.typeBitsBulkBarrier
//      runtime.gogo
void runtime.writebarrierptr_prewrite(Eq_4 dwArg08)
{
	if ((byte) (word32) g_b81576F5 != 0x00)
		runtime.cgoCheckWriteBarrier(gs);
	if ((byte) (word32) g_t81576F4 == 0x00)
		return;
	if (dwArg08 != 0x00 && dwArg08 < 0x1000)
	{
		word32 ebp_82;
		word32 edi_83;
		runtime.systemstack(gs, 0x080E7D04, out ebp_82, out edi_83);
	}
	runtime.writebarrierptr_prewrite1(gs);
}

// 08055880: Register word32 runtime.typedmemmove(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_3119 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.recv
//      runtime.mapassign
//      runtime.mapiterinit
//      runtime.evacuate
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.convT2E
//      reflect.typedmemmove
//      runtime.growslice
//      runtime.expandCgoFrames
//      runtime.typedslicecopy.func1
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
word32 runtime.typedmemmove(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_3119 & esiOut, ptr32 & ediOut)
{
	if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x80) == 0x00)
		runtime.bulkBarrierPreWrite(gs, dwArg08, dwArg0C, *dwArg04);
	ptr32 edi_35;
	Eq_3119 esi_36;
	word32 ebp_39;
	runtime.memmove(dwArg08, dwArg0C, *dwArg04, out ebp_39, out esi_36, out edi_35);
	if ((byte) (word32) g_b81576F5 != 0x00)
		runtime.cgoCheckMemmove(dwArg04);
	esiOut = esi_36;
	ediOut = edi_35;
	return ebp_39;
}

// 08055910: void reflect.typedmemmove(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.packEface
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.cvtDirect
void reflect.typedmemmove(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_53;
	word32 edi_54;
	runtime.typedmemmove(dwArg04, dwArg08, dwArg0C, out esi_53, out edi_54);
}

// 08055950: void reflect.typedmemmovepartial(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack int32 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.callMethod
void reflect.typedmemmovepartial(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, int32 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_t81576F4 != 0x00 && ((byte) ((word32) (*((word32) dwArg04 + 0x0F))) & 0x80) == 0x00)
	{
		Eq_4 ecx_31 = dwArg14;
		if (dwArg14 >= 0x04)
		{
			Eq_4 eax_42;
			Eq_4 edi_41;
			ui32 edx_35 = -dwArg10;
			if ((edx_35 & 0x03) != 0x00)
			{
				ecx_31 = dwArg14 - (edx_35 & 0x03);
				edi_41 = (word32) dwArg08 + (edx_35 & 0x03);
				eax_42 = (word32) dwArg0C + (edx_35 & 0x03);
			}
			else
			{
				edi_41 = dwArg08;
				eax_42 = dwArg0C;
			}
			runtime.bulkBarrierPreWrite(gs, edi_41, eax_42, ecx_31 & ~0x03);
		}
	}
	word32 edi_167;
	word32 esi_166;
	word32 ebp_165;
	runtime.memmove(dwArg08, dwArg0C, dwArg14, out ebp_165, out esi_166, out edi_167);
	if ((byte) (word32) g_b81576F5 != 0x00)
		runtime.cgoCheckMemmove(dwArg04);
}

// 08055A50: void runtime.reflectcallmove(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      callRet
void runtime.reflectcallmove(struct Eq_2 * gs, struct Eq_16244 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	if ((byte) (word32) g_t81576F4 != 0x00 && (dwArg04 != null && (((byte) ((word32) dwArg04->b000F) & 0x80) == 0x00 && dwArg10 >= 0x04)))
		runtime.bulkBarrierPreWrite(gs, dwArg08, dwArg0C, dwArg10);
	word32 ebp_84;
	word32 esi_85;
	word32 edi_86;
	runtime.memmove(dwArg08, dwArg0C, dwArg10, out ebp_84, out esi_85, out edi_86);
}

// 08055AD0: Register Eq_4 runtime.typedslicecopy(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.recordspan
//      syscall.runtime_envs
//      os.runtime_args
Eq_4 runtime.typedslicecopy(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg14, Eq_4 dwArg18, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_4 edx_11 = dwArg18;
	if (dwArg0C <= dwArg18)
		edx_11 = dwArg0C;
	if (edx_11 == 0x00)
	{
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
	else
	{
		ptr32 esi_26 = (word32) g_b81576F5;
		ptr32 esi_183 = esi_26;
		if ((byte) esi_26 != 0x00)
			esi_183 = runtime.cgoCheckSliceCopy(dwArg04, dwArg08, dwArg14, edx_11);
		if ((byte) (word32) g_t81576F4 == 0x00)
		{
			ptr32 edi_80;
			ptr32 esi_81;
			word32 ebp_205;
			Eq_4 ebx_79 = runtime.memmove(dwArg08, dwArg14, *dwArg04 *s edx_11, out ebp_205, out esi_81, out edi_80);
			esiOut = esi_81;
			ediOut = edi_80;
			return ebx_79;
		}
		else
		{
			fn0808FD8B(0x00, fp - 0x14);
			ptr32 edi_116;
			word32 ebp_206;
			Eq_4 ebx_114 = runtime.systemstack(gs, fp - 0x14, out ebp_206, out edi_116);
			esiOut = esi_183;
			ediOut = edi_116;
			return ebx_114;
		}
	}
}

// 08055BF0: Register Eq_4 runtime.typedmemclr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.closechan
//      runtime.chanrecv
//      runtime.freedefer
Eq_4 runtime.typedmemclr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x80) == 0x00)
		runtime.bulkBarrierPreWrite(gs, dwArg08, 0x00, *dwArg04);
	return runtime.memclrNoHeapPointers(dwArg08, *dwArg04);
}

// 08055C40: Register word32 runtime.memclrHasPointers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.evacuate
//      runtime.procresize
//      sync.poolCleanup
word32 runtime.memclrHasPointers(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	word32 esi_20 = runtime.bulkBarrierPreWrite(gs, dwArg04, 0x00, dwArg08);
	runtime.memclrNoHeapPointers(dwArg04, dwArg08);
	return esi_20;
}

// 08055C80: void runtime.(*mheap).mapBits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.(*mheap).setArenaUsed
void runtime.(*mheap).mapBits(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_25 = g_t8157620;
	uint32 ebx_29 = ~(ebx_25 - 0x01) & (word32) ebx_25 + (((dwArg08 - g_t81493A8 >> 0x04) + 0x1FFF & ~0x1FFF) - 0x01);
	if (*((word32) dwArg04 + 0x0AC4) >= ebx_29)
		return;
	runtime.sysMap(gs, *((word32) dwArg04 + 2752) - ebx_29, (byte) (word32) *((word32) dwArg04 + 2776));
	*((word32) dwArg04 + 0x0AC4) = ebx_29;
}

// 08055D30: Register ui32 runtime.(*mspan).refillAllocCache(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08, Register out Eq_16423 esiOut)
// Called from:
//      runtime.(*mspan).nextFreeIndex
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mspan).sweep
ui32 runtime.(*mspan).refillAllocCache(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08, union Eq_16423 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_16436 * ecx_20 = (word32) *((word32) dwArg04 + 40) + dwArg08;
	uint32 ebx_22 = (word32) ecx_20->b0001;
	uint32 ebx_26 = (word32) ecx_20->b0002;
	uint32 edx_30 = (word32) ecx_20->b0003;
	ui32 ebx_34 = (word32) ecx_20->b0004;
	ui32 ebx_36 = (word32) ecx_20->b0005;
	ui32 ebx_38 = (word32) ecx_20->b0006;
	ui32 ecx_39 = (word32) ecx_20->b0007;
	*((word32) dwArg04 + 32) = ~(edx_30 << 0x18 | (ebx_26 << 0x10 | ((word32) ecx_20->b0000 | ebx_22 << 0x08)));
	Eq_16423 esi_44 = ebx_26 >> 0x10 | ebx_22 >> 0x18;
	*((word32) dwArg04 + 36) = ~(ebx_34 | (edx_30 >> 0x08 | esi_44) | ebx_36 << 0x08 | ebx_38 << 0x10 | ecx_39 << 0x18);
	esiOut = esi_44;
	return ebx_38 << 0x10;
}

// 08055DD0: Register Eq_4 runtime.(*mspan).nextFreeIndex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*mcache).nextFree
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mspan).sweep
Eq_4 runtime.(*mspan).nextFreeIndex(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 24);
	Eq_4 edx_19 = *((word32) dwArg04 + 28);
	if (edx_19 == ecx_18)
		return esi;
	if (ecx_18 > edx_19)
		runtime.throw(gs);
	else
	{
		runtime/internal/sys.Ctz64(*((word32) dwArg04 + 32), *((word32) dwArg04 + 36));
		Eq_4 ecx_156 = ecx_18;
		while (dwLoc18 == 0x40)
		{
			uint32 eax_130 = (word32) ecx_156 + 64;
			if ((eax_130 & ~0x3F) >= edx_19)
			{
				*((word32) dwArg04 + 24) = edx_19;
				return esi;
			}
			word32 esi_243;
			runtime.(*mspan).refillAllocCache(gs, dwArg04, (eax_130 & ~0x3F) >> 0x03, out esi_243);
			runtime/internal/sys.Ctz64(*((word32) dwArg04 + 32), *((word32) dwArg04 + 36));
			ecx_156 = eax_130 & ~0x3F;
		}
		if ((word32) ecx_156 + dwLoc18 >= edx_19)
		{
			*((word32) dwArg04 + 24) = edx_19;
			return esi;
		}
		else
		{
			up32 edx_70 = 0x1F - dwLoc18;
			Eq_4 edi_66 = *((word32) dwArg04 + 36);
			byte cl_84 = (byte) (dwLoc18 + 0x01);
			ui32 edx_92 = 0x00 - (dwLoc18 < ~0x1E);
			*((word32) dwArg04 + 32) = edi_66 << (byte) edx_70 & 0x00 - (edx_70 < 0x20) | *((word32) dwArg04 + 32) >> cl_84 & edx_92 | edi_66 >> (byte) (dwLoc18 - 0x1F) & 0x00 - (dwLoc18 < 0x3F);
			Eq_4 esi_100 = edi_66 >> cl_84 & edx_92;
			*((word32) dwArg04 + 36) = esi_100;
			Eq_4 eax_103 = (word32) ecx_156 + 1 + dwLoc18;
			if ((eax_103 & 0x3F) == 0x00 && eax_103 != edx_19)
			{
				word32 esi_244;
				runtime.(*mspan).refillAllocCache(gs, dwArg04, eax_103 >> 0x03, out esi_244);
			}
			*((word32) dwArg04 + 24) = eax_103;
			return esi_100;
		}
	}
}

// 08055F70: void runtime.markBitsForAddr(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcmarknewobject
void runtime.markBitsForAddr(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_16664 * eax_38;
	if (dwArg04 != 0x00)
	{
		Eq_4 ebx_21 = g_t81493A8;
		if (dwArg04 >= ebx_21 && dwArg04 < g_t81493AC)
		{
			Eq_4 ebp_27 = g_t8149108;
			uint32 edx_30 = dwArg04 - ebx_21;
			if (edx_30 >> 0x0D >= g_t814910C)
				runtime.panicindex(gs);
			eax_38 = (struct Eq_16664 *) *((word32) ebp_27 + (edx_30 >> 0x0D) * 0x04);
l08055F97:
			if (dwArg04 - eax_38->dw000C != 0x00)
				(word16) (word32) eax_38->w0036 == 0x00;
			return;
		}
	}
	eax_38 = null;
	goto l08055F97;
}

// 08056090: void runtime.markBits.setMarked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.gcmarknewobject
void runtime.markBits.setMarked(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Or8(dwArg04, (byte) (word32) bArg08);
}

// 080560D0: void runtime.heapBitsForSpan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.largeAlloc
//      runtime.(*mcentral).grow
//      runtime.initCheckmarks
//      runtime.clearCheckmarks
void runtime.heapBitsForSpan(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	if (dwArg04 >= eax_17 && dwArg04 < g_t81493AC)
		return;
	Eq_4 eax_26 = g_t81493AC;
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_58;
	runtime.printhex(esi, gs, dwArg04, 0x00, out esi_58);
	runtime.printstring(gs);
	Eq_4 esi_82;
	runtime.printhex(esi_58, gs, eax_17, 0x00, out esi_82);
	runtime.printstring(gs);
	word32 esi_180;
	runtime.printhex(esi_82, gs, eax_26, 0x00, out esi_180);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 08056200: void runtime.heapBitsForObject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanblock
//      runtime.scanobject
//      runtime.shade
//      runtime.gcMarkTinyAllocs
void runtime.heapBitsForObject(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	if (dwArg04 < eax_17 || dwArg04 >= g_t81493AC)
		return;
	uint32 edx_25 = dwArg04 - eax_17;
	Eq_4 esi_28 = g_t8149108;
	if (edx_25 >> 0x0D >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		struct Eq_16808 * ebp_35 = *((word32) esi_28 + (edx_25 >> 0x0D) * 0x04);
		bool Z_137 = SLICE(cond(ebp_35), bool, 2);
		if (ebp_35 != null)
		{
			esi_28 = ebp_35->t000C;
			if (dwArg04 < esi_28)
				Z_137 = SLICE(cond(ebp_35), bool, 2);
			else if (dwArg04 >= ebp_35->t0050)
				Z_137 = SLICE(cond(ebp_35), bool, 2);
			else
			{
				if ((byte) (word32) ebp_35->b003C == 0x01)
				{
					if ((word16) (word32) ebp_35->w0036 == 0x00)
						dwArg04 - esi_28 < ebp_35->dw0040;
					return;
				}
				Z_137 = SLICE(cond(ebp_35), bool, 2);
			}
		}
		if (Z_137 || (byte) ((word32) ebp_35->b003C) == 0x02)
			return;
		if (g_t8157744 == 0x00)
			return;
		runtime.printlock(gs);
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_552;
		runtime.printhex(esi_28, gs, dwArg04, 0x00, out esi_552);
		runtime.printunlock(gs);
		if ((byte) (word32) ebp_35->b003C != 0x01)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		Eq_4 ecx_220 = (word32) ebp_35->b003C;
		Eq_4 edx_222 = ebp_35->t0050;
		Eq_4 eax_224 = ebp_35->t000C;
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_555;
		runtime.printhex(esi_28, gs, edx_25 >> 0x0D, 0x00, out esi_555);
		runtime.printstring(gs);
		word32 esi_556;
		runtime.printhex(esi_28, gs, eax_224, 0x00, out esi_556);
		runtime.printstring(gs);
		word32 esi_557;
		runtime.printhex(esi_28, gs, edx_222, 0x00, out esi_557);
		runtime.printstring(gs);
		runtime.printint(SLICE(dwArg04, word24, 8), gs, ecx_220);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		if (dwArg08 != 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			word32 esi_553;
			runtime.printhex(esi_28, gs, dwArg08, 0x00, out esi_553);
			runtime.printstring(gs);
			word32 esi_554;
			runtime.printhex(esi_28, gs, dwArg0C, 0x00, out esi_554);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.gcDumpObject(gs, dwArg08, dwArg0C);
		}
		*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 461) = 0x02;
		runtime.throw(gs);
	}
}

// 08056610: void runtime.heapBits.setCheckmarked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.greyobject
void runtime.heapBits.setCheckmarked(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C != 0x04)
		runtime/internal/atomic.Or8(dwArg04, (byte) (0x10 << (byte) ((word32) dwArg08 + 1) & 0x00 - (dwArg08 < 0x1F)));
	else
		runtime/internal/atomic.Or8(dwArg04, (byte) (0x00 - (dwArg08 < 0x20) & 0x01 << (byte) dwArg08));
}

// 08056690: Register Eq_4 runtime.bulkBarrierPreWrite(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.typedmemmove
//      reflect.typedmemmovepartial
//      runtime.reflectcallmove
//      runtime.typedmemclr
//      runtime.memclrHasPointers
Eq_4 runtime.bulkBarrierPreWrite(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	Eq_4 ebp_10 = dwArg0C;
	if (((dwArg08 | dwArg04 | dwArg0C) & 0x03) != 0x00)
		runtime.throw(gs);
	if ((byte) (word32) g_t81576F4 == 0x00)
		return esi;
	if (dwArg04 != 0x00)
	{
		Eq_4 eax_32 = g_t81493A8;
		if (dwArg04 >= eax_32)
		{
			esi = g_t81493AC;
			if (dwArg04 < esi)
			{
				esi = g_t814910C;
				Eq_4 edi_41 = g_t8149108;
				uint32 edx_43 = dwArg04 - eax_32;
				if (edx_43 >> 0x0D >= esi)
					runtime.panicindex(gs);
				struct Eq_17062 * edx_52 = *((word32) edi_41 + (edx_43 >> 0x0D) * 0x04);
				if (edx_52 != null)
				{
					esi = edx_52->t000C;
					if (dwArg04 >= esi)
					{
						esi = edx_52->t0050;
						if (dwArg04 < esi && (byte) ((word32) edx_52->b003C) == 0x01)
						{
							Eq_4 esi_203 = g_t81493A0 - (edx_43 >> 0x04);
							Eq_4 edx_204 = esi_203 - 0x01;
							uint32 eax_205 = edx_43 >> 0x02 & 0x03;
							if (dwArg08 == 0x00)
							{
								Eq_4 ebx_270 = 0x00;
								while (ebx_270 < ebp_10)
								{
									esi_203 = (word32) *edx_204 >> (byte) eax_205;
									if ((esi_203 & 0x01) != 0x00)
									{
										runtime.writebarrierptr_prewrite1(gs);
										ebp_10 = dwArg0C;
									}
									if (eax_205 < 0x03)
										++eax_205;
									else
									{
										esi_203 = edx_204 - 0x01;
										edx_204 = esi_203;
										eax_205 = 0x00;
									}
									ebx_270 = (word32) ebx_270 + 4;
								}
							}
							else
							{
								esi_203.u0 = 0x00;
								for (; esi_203 < ebp_10; esi_203 += 0x04)
								{
									if (((word32) *edx_204 >> (byte) eax_205 & 0x01) != 0x00)
									{
										runtime.writebarrierptr_prewrite1(gs);
										ebp_10 = dwArg0C;
									}
									if (eax_205 < 0x03)
										++eax_205;
									else
									{
										edx_204 -= (byte *) 0x01;
										eax_205 = 0x00;
									}
								}
							}
							return esi_203;
						}
					}
				}
l0805681D:
				Eq_4 eax_74 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
				if (eax_74 != 0x00 && (*eax_74 <= dwArg04 && dwArg04 < *((word32) eax_74 + 4)))
					return esi;
				runtime.activeModules();
				word32 * eax_168 = dwLoc2C;
				int32 ebx_101;
				for (ebx_101 = 0x00; ebx_101 < dwLoc28; ++ebx_101)
				{
					struct Eq_17182 * ebp_169 = *eax_168;
					esi = ebp_169->t0040;
					if (esi <= dwArg04 && dwArg04 < ebp_169->t0044)
					{
						runtime.bulkBarrierBitmap(dwArg08, dwArg0C, dwArg04 - esi, ebp_169->t00C8);
						return esi;
					}
					++eax_168;
				}
				runtime.activeModules();
				word32 * ecx_118 = dwLoc2C;
				int32 ebx_120;
				for (ebx_120 = 0x00; ebx_120 < dwLoc28; ++ebx_120)
				{
					struct Eq_17210 * ebp_132 = *ecx_118;
					esi = ebp_132->t0048;
					if (esi <= dwArg04 && dwArg04 < ebp_132->t004C)
					{
						runtime.bulkBarrierBitmap(dwArg08, dwArg0C, dwArg04 - esi, ebp_132->t00D0);
						return esi;
					}
					++ecx_118;
				}
				return esi;
			}
		}
	}
	goto l0805681D;
}

// 08056930: void runtime.bulkBarrierBitmap(Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.bulkBarrierPreWrite
//      runtime.newproc1
void runtime.bulkBarrierBitmap(Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	ui32 edx_13 = 0x01 << (byte) (dwArg10 >> 0x02 & 0x07);
	byte * eax_113 = (word32) dwArg14 + (dwArg10 >> 0x05);
	Eq_4 ecx_104 = 0x00;
	while (true)
	{
		byte dl_27 = (byte) edx_13;
		if (ecx_104 >= dwArg0C)
			break;
		Eq_4 ecx_100;
		if (dl_27 == 0x00)
		{
			byte * eax_32 = eax_113 + 1;
			eax_113 = eax_32;
			if ((byte) (word32) *eax_32 == 0x00)
			{
				ecx_100 = (word32) ecx_104 + 28 + 0x04;
				goto l08056953;
			}
			edx_13 = 0x01;
		}
		byte dl_52 = (byte) edx_13;
		ui32 edx_91 = edx_13;
		if (((byte) (word32) *eax_113 & dl_52) != 0x00)
		{
			if (dwArg08 == 0x00)
				runtime.writebarrierptr_prewrite1(gs);
			else
				runtime.writebarrierptr_prewrite1(gs);
			edx_91 = (word32) dl_52;
		}
		ecx_100 = ecx_104;
		edx_13 = edx_91 << 0x01;
l08056953:
		ecx_104 = ecx_100;
	}
}

// 080569E0: void runtime.typeBitsBulkBarrier(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sendDirect
//      runtime.recvDirect
void runtime.typeBitsBulkBarrier(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	Eq_363 ebx_24_8 = SLICE(ebx, word24, 8);
	Eq_4 eax_257 = dwArg04;
	if (dwArg04 == 0x00)
		runtime.throw(gs);
	else if (dwArg10 != *dwArg04)
	{
		runtime.(*_type).string(gs, dwArg04);
		Eq_4 edx_36 = *dwArg04;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printint(ebx_24_8, gs, (uint64) (uint32) edx_36);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printint(ebx_24_8, gs, (uint64) (uint32) dwArg10);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x40) != 0x00)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		if ((byte) (word32) g_t81576F4 == 0x00)
			return;
		Eq_4 ecx_252 = *((word32) dwArg04 + 20);
		Eq_4 edx_253 = 0x00;
		uint32 ebx_254 = 0x00;
		while (edx_253 < *((word32) eax_257 + 4))
		{
			uint32 ebx_270;
			if ((edx_253 & 0x1F) == 0x00)
			{
				ebx_270 = (word32) *ecx_252;
				ecx_252 = (word32) ecx_252 + 1;
			}
			else
				ebx_270 = ebx_254 >> 0x01;
			if ((ebx_270 & 0x01) != 0x00)
			{
				runtime.writebarrierptr_prewrite(Mem285[edx_253 + dwArg0C:word32]);
				eax_257 = dwArg04;
			}
			ebx_254 = ebx_270;
			edx_253 = (word32) edx_253 + 4;
		}
	}
}

// 08056C00: Register Eq_4 runtime.heapBits.initSpan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack uint32 dwArg04, Stack (ptr32 Eq_15337) dwArg0C)
// Called from:
//      runtime.largeAlloc
//      runtime.(*mcentral).grow
Eq_4 runtime.heapBits.initSpan(Eq_4 esi, struct Eq_2 * gs, uint32 dwArg04, struct Eq_15337 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_26;
	ui32 eax_18 = dwArg0C->dw0010;
	uint32 edx_21 = dwArg0C->dw0040;
	if (edx_21 > 0x00)
		eax_26 = (uint32) ((uint64) (uint32) (eax_18 << 0x0D) /u edx_21);
	else
		eax_26.u0 = 0x00;
	dwArg0C->dw0018 = 0x00;
	dwArg0C->dw0020 = ~0x00;
	dwArg0C->dw0024 = ~0x00;
	dwArg0C->t001C = eax_26;
	dwArg0C->dw0028 = 0x00;
	dwArg0C->dw002C = 0x00;
	Eq_4 esi_58 = runtime.newMarkBits(esi, gs, dwArg0C->t001C);
	dwArg0C->dw002C = dwLoc08;
	Eq_4 esi_74 = runtime.newAllocBits(esi_58, gs, dwArg0C->t001C);
	dwArg0C->dw0028 = dwLoc08;
	if ((eax_18 << 0x0D & 0x0F) != 0x00)
		runtime.throw(gs);
	else
	{
		runtime.memclrNoHeapPointers(dwArg04 - (((eax_18 << 0x0D) >> 0x04) - 0x01), eax_18 << 0x0D >> 0x04);
		return esi_74;
	}
}

// 08056CE0: Register (ptr32 byte) runtime.heapBits.initCheckmarkSpan(Register (ptr32 Eq_2) gs, Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08, Stack (ptr32 byte) dwArg0C, Stack uint32 dwArg10)
// Called from:
//      runtime.initCheckmarks
byte * runtime.heapBits.initCheckmarkSpan(struct Eq_2 * gs, byte * dwArg04, byte * dwArg08, byte * dwArg0C, uint32 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte * ebx_19 = dwArg04;
	byte * ebp_20 = dwArg08;
	uint32 ecx_21;
	for (ecx_21 = 0x00; ecx_21 < dwArg10; ++ecx_21)
	{
		up32 edi_40 = ebp_20 + 1;
		*ebx_19 = (byte) (~(0x00 - (edi_40 < 0x20) & 0x10 << (byte) edi_40) & (word32) ((byte) ((word32) (*ebx_19))));
		uint32 ebp_70 = ebp_20 + (dwArg0C >> 0x02);
		esi = ebx_19 - (ebp_70 >> 0x02);
		ebx_19 = esi;
		ebp_20 = ebp_70 & 0x03;
	}
	return esi;
}

// 08056D70: void runtime.heapBits.clearCheckmarkSpan(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.clearCheckmarks
void runtime.heapBits.clearCheckmarkSpan(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 08056D90: void runtime.(*mspan).countAlloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*mspan).sweep
void runtime.(*mspan).countAlloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_17 = *((word32) dwArg04 + 28);
	uint32 ebx_20;
	for (ebx_20 = 0x00; ebx_20 < ecx_17 >> 0x03; ++ebx_20)
		;
}

// 08056E10: void runtime.heapBitsSetType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.mallocgc
void runtime.heapBitsSetType(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ecx_21 = dwArg04 - g_t81493A8;
	uint32 ecx_29 = ecx_21 >> 0x02 & 0x03;
	Eq_4 ebx_18 = *((word32) dwArg10 + 20);
	struct Eq_17632 * esi_26 = g_t81493A0 - (ecx_21 >> 0x04);
	byte cl_41 = (byte) ecx_29;
	if (dwArg08 == 0x08)
	{
		if (*dwArg10 != 0x04)
			esi_26->bFFFFFFFF = (byte) (((word32) *ebx_18 & 0x03 | 0x10) << cl_41 | ~(0x33 << cl_41) & (word32) esi_26->bFFFFFFFF);
		else if (dwArg0C == 0x04)
			esi_26->bFFFFFFFF = (byte) (~(0x33 << cl_41) & (word32) esi_26->bFFFFFFFF | 0x11 << cl_41);
		else
			esi_26->bFFFFFFFF = (byte) (0x13 << cl_41 | (word32) esi_26->bFFFFFFFF);
	}
	else if (((byte) (word32) *((word32) dwArg10 + 0x0F) & 0x40) != 0x00)
		runtime.heapBitsSetTypeGCProg(gs, esi_26 - 0x01, ecx_29, *((word32) dwArg10 + 4), *dwArg10, dwArg0C, dwArg08);
	else
	{
		Eq_17674 ecx_117;
		Eq_4 ebx_118;
		Eq_4 edx_116;
		Eq_17674 esi_122;
		uint32 ebp_121;
		Eq_4 ecx_110 = *dwArg10;
		if (ecx_110 < dwArg0C)
		{
			Eq_4 ebp_123 = *((word32) dwArg10 + 4);
			if (ebp_123 >> 0x02 <= 0x19)
			{
				uint32 dwLoc48_712 = 0x00;
				uint32 dwLoc50_714 = 0x00;
				ebx_161 = ebx_18;
				while (true)
				{
					Eq_4 ebx_161;
					if (dwLoc48_712 >= ebp_123 >> 0x02)
						break;
					ebx_161 = (word32) ebx_161 + 1;
					dwLoc48_712 += 0x08;
					dwLoc50_714 |= (word32) *ebx_161 << (byte) dwLoc48_712 & 0x00 - (dwLoc48_712 < 0x20);
				}
				ecx_117 = ecx_110 >> 0x02;
				if ((ecx_110 >> 0x02) * 0x02 <= 0x19)
				{
					uint32 ebp_192 = dwLoc50_714;
					while (true)
					{
						byte cl_200 = (byte) ecx_117;
						if (ecx_117 > 0x20)
							break;
						ebp_192 = ebp_192 << cl_200 & 0x00 - (ecx_117 < 0x20) | ebp_192;
						ecx_117 *= 0x02;
					}
					if ((byte) (ecx_110 >> 0x02) == 0x00)
						runtime.panicdivide(gs);
					Eq_17674 edx_255 = (word32) (byte) (uint16) (0x00 /u (word16) ((word32) ((byte) (ecx_110 >> 0x02)))) *s (ecx_110 >> 0x02);
					ecx_117 = edx_255;
					ebp_121 = ebp_192 & (0x00 - (edx_255 < 0x20) & 0x01 << (byte) edx_255) - 0x01;
				}
				else
					ebp_121 = dwLoc50_714;
				edx_116.u0 = 0x00;
				ebx_118.u0 = 0x00;
				esi_122 = ecx_117;
			}
			else
			{
				uint32 edi_127 = (ebp_123 >> 0x02) + 0x07;
				edx_116 = ebx_18;
				ebx_118 = (word32) ebx_18 + ((edi_127 >> 0x03) - 0x01);
				ebp_121 = 0x00;
				esi_122 = (ecx_110 >> 0x02) - ((edi_127 >> 0x03) - 0x01 << 0x03);
				ecx_117.u0 = 0x00;
			}
		}
		else
		{
			edx_116 = ebx_18;
			ecx_117.u0 = 0x00;
			ebx_118.u0 = 0x00;
			ebp_121 = 0x00;
			esi_122.u0 = 0x00;
		}
		uint32 edi_281;
		if (edx_116 != 0x00)
		{
			edi_281 = (word32) *edx_116;
			edx_116 = (word32) edx_116 + 1;
			ecx_117.u0 = 0x08;
		}
		else
			edi_281 = ebp_121;
		uint32 ebp_323;
		if (dwArg0C == ecx_110)
			ebp_323 = *((word32) dwArg10 + 4) >> 0x02;
		else
		{
			if (ecx_110 == 0x00)
				runtime.panicdivide(gs);
			ebp_323 = ((uint32) ((uint64) (uint32) dwArg0C /u ecx_110) - 0x01) *s ecx_110 + Mem312[dwArg10 + 0x04:word32] >>u 0x02;
		}
		Eq_4 edx_467 = edx_116;
		if (ebp_323 == 0x00)
		{
			runtime.(*_type).string(gs, dwArg10);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			uint32 eax_388;
			if (ebp_323 < 0x02)
				eax_388 = 0x02;
			else
				eax_388 = ebp_323;
			if ((ecx_21 >> 0x02 & 0x03) != 0x00)
				runtime.throw(gs);
			else
			{
				byte * edx_592;
				uint32 ecx_596;
				ui32 edi_409 = edi_281 & 0x0F;
				ui32 edi_410 = edi_409 | 0xD0;
				if (eax_388 <= 0x04)
				{
					ecx_596 = 0x04;
					edx_592 = esi_26 - 0x01;
				}
				else
				{
					esi_26->bFFFFFFFF = (byte) (edi_409 | 0xD0);
					uint32 ebp_427 = edi_281 >> 0x04;
					Eq_17846 edi_433 = ecx_117 - 0x08;
					byte * esi_434 = esi_26 - 0x02;
					up32 dwLoc54_809 = 0x04;
					while (true)
					{
						uint32 esi_455;
						byte * ecx_454;
						ui32 ebp_446 = ebp_427 & 0x0F;
						ui32 ebp_447 = ebp_446 | 0xF0;
						if (dwLoc54_809 + 0x04 >= eax_388)
							break;
						Eq_17846 ecx_494;
						*esi_434 = (byte) (ebp_446 | 0xF0);
						uint32 ebp_464 = ebp_427 >> 0x04;
						byte * esi_465 = esi_434 - 0x01;
						if (edx_467 != ebx_118)
						{
							if (edi_433 < 0x08)
							{
								ecx_494 = edi_433;
								ebp_464 = ebp_427 >> 0x04 | (word32) (*edx_467) << (byte) edi_433 & 0x00 - (edi_433 < 0x20);
								edx_467 = (word32) edx_467 + 1;
							}
							else
								ecx_494 = (word32) edi_433 - 8;
						}
						else
						{
							Eq_4 ebx_498;
							if (edx_467 != 0x00)
							{
								ebp_464 = ebp_427 >> 0x04 | (word32) (*edx_467) << (byte) edi_433 & 0x00 - (edi_433 < 0x20);
								word32 edi_512 = edi_433 + esi_122;
								if (edi_512 < 0x08)
								{
									ecx_494 = edi_512;
									ebp_464 |= (word32) *ebx_18 << (byte) edi_512 & 0x00 - (edi_512 < 0x20);
									ebx_498 = (word32) ebx_18 + 1;
								}
								else
								{
									ecx_494 = edi_433 - 0x08 + esi_122;
									ebx_498 = ebx_18;
								}
							}
							else
							{
								uint32 ebx_478;
								Eq_17846 esi_477;
								if (edi_433 < 0x08)
								{
									ebx_478 = ebp_121 << (byte) edi_433 & 0x00 - (edi_433 < 0x20) | ebp_427 >> 0x04;
									esi_477 = edi_433 + esi_122;
								}
								else
								{
									esi_477 = edi_433;
									ebx_478 = ebp_427 >> 0x04;
								}
								ecx_494 = esi_477 - 0x08;
								ebp_464 = ebx_478;
								ebx_498 = edx_467;
							}
							edx_467 = ebx_498;
						}
						ui32 ebp_555 = ebp_464 & 0x0F;
						ebp_447 = ebp_555 | 0xF0;
						esi_455 = dwLoc54_809 + 0x08;
						if (dwLoc54_809 + 0x08 >= eax_388)
						{
							ecx_454 = esi_465;
							goto l0805710D;
						}
						*esi_465 = (byte) (ebp_555 | 0xF0);
						dwLoc54_809 += 0x08;
						edi_433 = ecx_494;
						esi_434 = esi_465 - 0x01;
						ebp_427 = ebp_464 >> 0x04;
					}
					ecx_454 = esi_434;
					esi_455 = dwLoc54_809 + 0x04;
l0805710D:
					edx_592 = ecx_454;
					edi_410 = ebp_447;
					ecx_596 = esi_455;
				}
				if (ecx_596 > eax_388)
				{
					up32 ecx_608 = -(ecx_596 - eax_388 + ~0x03);
					ui32 eax_615 = 0x01 << (byte) ecx_608 & 0x00 - (ecx_608 < 0x20);
					edi_410 &= eax_615 - 0x01 << 0x04 | eax_615 - 0x01;
				}
				ui32 ebx_637;
				uint32 ecx_635;
				if (ecx_596 <= dwArg08 >> 0x02)
				{
					*edx_592 = (byte) edi_410;
					--edx_592;
					for (ecx_635 = ecx_596 + 0x04; ecx_635 <= dwArg08 >> 0x02; ecx_635 += 0x04)
					{
						*edx_592 = 0x00;
						--edx_592;
					}
					ebx_637 = 0x00;
				}
				else
				{
					ecx_635 = ecx_596;
					ebx_637 = edi_410;
				}
				if ((dwArg08 >> 0x02) + 0x02 == ecx_635)
					*edx_592 = (byte) (ebx_637 | (word32) (*edx_592) & ~0x33);
			}
		}
	}
}

// 08057360: void runtime.heapBitsSetTypeGCProg(Register (ptr32 Eq_2) gs, Stack Eq_17659 dwArg04, Stack uint32 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      runtime.heapBitsSetType
void runtime.heapBitsSetTypeGCProg(struct Eq_2 * gs, Eq_17659 dwArg04, uint32 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_231;
	if (dwArg10 != dwArg14)
	{
		if (dwArg10 == 0x00)
			runtime.panicdivide(gs);
		Eq_18143 ecx_128;
		fn0808FD86(0x00, fp - 0x28);
		Eq_18152 eax_116 = (uint32) ((uint64) (uint32) dwArg14 /u dwArg0C);
		uint32 esi_122 = dwArg0C >> 0x02;
		uint32 ecx_123 = (dwArg0C >> 0x02) - (dwArg08 >> 0x02);
		if (ecx_123 > 0x00)
		{
			if (ecx_123 > 0x01)
			{
				uint32 ecx_136 = ecx_123 - 0x01;
				Eq_18174 ebx_138 = 0x03;
				while (true)
				{
					byte cl_151 = (byte) ecx_136;
					if (ecx_136 < 0x80)
						break;
					if (ebx_138 >= 0x28)
						runtime.panicindex(gs);
					*((word32) ebx_138 + (fp - 44)) = (byte) (ecx_136 | 0x80);
					ebx_138 = (word32) ebx_138 + 1;
					ecx_136 >>= 0x07;
				}
				if (ebx_138 >= 0x28)
					runtime.panicindex(gs);
				Mem152[fp - 44 + ebx_138:byte] = cl_151;
				ecx_128 = (word32) ebx_138 + 1;
			}
			else
				ecx_128.u0 = 0x02;
		}
		else
			ecx_128.u0 = 0x00;
		if (ecx_128 >= 0x28)
			runtime.panicindex(gs);
		*((word32) ecx_128.u0 + (fp - 44)) = 0x80;
		byte * ecx_164 = (word32) ecx_128.u0 + 1;
		for (; esi_122 >= 0x80; esi_122 >>= 0x07)
		{
			if (ecx_164 >= (byte *) 0x28)
				runtime.panicindex(gs);
			Mem283[fp - 44 + ecx_164:byte] = SLICE(esi_122 | 0x80, byte, 0);
			++ecx_164;
		}
		if (ecx_164 >= (byte *) 0x28)
			runtime.panicindex(gs);
		Mem183[fp - 44 + ecx_164:byte] = SLICE(esi_122, byte, 0);
		byte * ecx_187 = ecx_164 + 1;
		uint32 eax_188 = eax_116 - 0x01;
		while (true)
		{
			byte al_203 = (byte) eax_188;
			if (eax_188 < 0x80)
				break;
			if (ecx_187 >= (byte *) 0x28)
				runtime.panicindex(gs);
			Mem265[fp - 44 + ecx_187:byte] = SLICE(eax_188 | 0x80, byte, 0);
			++ecx_187;
			eax_188 >>= 0x07;
		}
		if (ecx_187 >= (byte *) 0x28)
			runtime.panicindex(gs);
		Mem204[fp - 44 + ecx_187:byte] = al_203;
		if (ecx_187 >= (byte *) ~0x26)
			runtime.panicindex(gs);
		Mem214[fp - 0x2B + ecx_187:byte] = 0x00;
		runtime.runGCProg(gs, dwArg18, fp - (byte *) 44, dwArg00, 0x02);
		eax_231 = dwArg0C *s (eax_116 - 0x01) + dwArg08 >> 0x02;
	}
	else
	{
		runtime.runGCProg(gs, dwArg1C, 0x00, dwArg04, 0x02);
		if (dwLoc30 << 0x02 != dwArg0C)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx, gs, dwLoc30);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx, gs, dwArg0C);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		eax_231 = dwLoc30;
	}
	word32 ebx_244 = dwArg04 - (dwArg18 >> 0x04);
	runtime.memclrNoHeapPointers(ebx_244 + 0x01, dwArg04 - ((word32) eax_231 + 3 >> 0x02) - ebx_244);
}

// 08057630: void runtime.progToPointerMask(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.modulesinit
void runtime.progToPointerMask(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_19 = (dwArg08 >> 0x02) + 0x07;
	runtime.persistentalloc(gs);
	uint32 ecx_23 = (eax_19 >> 0x03) + 0x01;
	if (ecx_23 > 0x40000000)
		runtime.panicslice(gs);
	else if (eax_19 >> 0x03 >= ecx_23)
		runtime.panicindex(gs);
	else
	{
		Mem46[(eax_19 >>u 0x03) + dwLoc14:byte] = 161;
		if (ecx_23 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			runtime.runGCProg(gs, dwArg04, 0x00, dwLoc14, 0x01);
			if (SLICE((word32) Mem56[(eax_19 >>u 0x03) + dwLoc14:byte], byte, 0) == 161)
				return;
			runtime.throw(gs);
		}
	}
}

// 08057720: void runtime.runGCProg(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_17659 dwArg0C, Stack word32 dwArg10)
// Called from:
//      runtime.heapBitsSetTypeGCProg
//      runtime.progToPointerMask
void runtime.runGCProg(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_17659 dwArg0C, word32 dwArg10)
{
	while (fp - 0x04 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_17659 edx_18 = dwArg0C;
	Eq_4 ebp_20 = dwArg08;
	Eq_4 esi_21 = dwArg04;
	Eq_18407 ecx_23 = 0x00;
	uint32 edi_1028 = 0x00;
	while (true)
	{
		while (ecx_23 >= 0x08)
		{
			if (dwArg10 == 0x01)
			{
				*edx_18 = (byte) edi_1028;
				edi_1028 >>= 0x08;
				edx_18 = (word32) edx_18 + 1;
			}
			else
			{
				*edx_18 = (byte) (edi_1028 & 0x0F | 0xF0);
				byte * edx_928 = edx_18 - 0x01;
				*edx_928 = (byte) (edi_1028 >> 0x04 & 0x0F | 0xF0);
				edi_1028 >>= 0x08;
				edx_18 = edx_928 - 0x01;
			}
			ecx_23 = (word32) ecx_23 - 8;
		}
		Eq_17659 ebx_377;
		Eq_4 edx_382;
		ui32 ebx_38 = (word32) *esi_21;
		Eq_18407 ebx_40 = ebx_38 & 0x7F;
		Eq_4 esi_41 = (word32) esi_21 + 1;
		if ((ebx_38 & 0x80) == 0x00)
		{
			if ((ebx_38 & 0x7F) == 0x00)
			{
				if (ebp_20 == 0x00)
				{
					if (dwArg10 == 0x01)
					{
						Eq_17659 edx_863 = edx_18;
						uint32 ecx_870;
						for (ecx_870 = (word32) ecx_23 + (-ecx_23 & 0x07); ecx_870 > 0x00; ecx_870 += ~0x07)
						{
							*edx_863 = (byte) edi_1028;
							edi_1028 >>= 0x08;
							edx_863 = (word32) edx_863 + 1;
						}
					}
					else
					{
						Eq_17659 edx_828 = edx_18;
						uint32 ecx_835;
						for (ecx_835 = (word32) ecx_23 + (-ecx_23 & 0x03); ecx_835 > 0x00; ecx_835 += ~0x03)
						{
							*edx_828 = (byte) (edi_1028 & 0x0F | 0xF0);
							--edx_828;
							edi_1028 >>= 0x04;
						}
					}
					return;
				}
				edx_382.u0 = 0x00;
				ebx_377 = edx_18;
			}
			else
			{
				uint32 ebx_698 = (ebx_38 & 0x7F) >> 0x03;
				uint32 dwLoc68_1192 = 0x00;
				Eq_17659 dwLoc10_1194 = edx_18;
				while (true)
				{
					byte cl_728 = (byte) ecx_23;
					byte cl_752 = (byte) ecx_23;
					if (dwLoc68_1192 >= ebx_698)
						break;
					Eq_17659 esi_793;
					ui32 edx_759 = (word32) *esi_41 << cl_752 & 0x00 - (ecx_23 < 0x20);
					uint32 edi_760 = edi_1028 | edx_759;
					Eq_4 edx_762 = (word32) esi_41 + 1;
					if (dwArg10 == 0x01)
					{
						*dwLoc10_1194 = (byte) edi_760;
						esi_793 = (word32) dwLoc10_1194 + 1;
					}
					else
					{
						*dwLoc10_1194 = (byte) (edi_760 & 0x0F | 0xF0);
						*((word32) dwLoc10_1194 - 1) = (byte) (edi_760 >> 0x04 & 0x0F | 0xF0);
						esi_793 = dwLoc10_1194 - 0x02;
					}
					edi_1028 = (edi_1028 | edx_759) >> 0x08;
					++dwLoc68_1192;
					dwLoc10_1194 = esi_793;
					esi_41 = edx_762;
				}
				Eq_4 ebx_726;
				Eq_18407 edx_724;
				if ((ebx_38 & 0x07) > 0x00)
				{
					edi_1028 |= (word32) *esi_41 << cl_728 & 0x00 - (ecx_23 < 0x20);
					edx_724 = (word32) ecx_23 + (ebx_38 & 0x07);
					ebx_726 = (word32) esi_41 + 1;
				}
				else
				{
					edx_724 = ecx_23;
					ebx_726 = esi_41;
				}
				ecx_23 = edx_724;
				ebp_20 = ebx_726;
				edx_382 = ebp_20;
				ebx_377 = dwLoc10_1194;
			}
		}
		else
		{
			Eq_4 ebp_105;
			if ((ebx_38 & 0x7F) == 0x00)
			{
				up32 edx_51 = 0x00;
				while (true)
				{
					ui32 ebp_56 = (word32) *esi_41;
					ebx_40 |= 0x00 - (edx_51 < 0x20) & (ebp_56 & 0x7F) << (byte) edx_51;
					ebp_105 = (word32) esi_41 + 1;
					if ((ebp_56 & 0x80) == 0x00)
						break;
					edx_51 += 0x07;
					esi_41 = ebp_105;
				}
			}
			else
				ebp_105 = esi_41;
			int32 ecx_110 = 0x00;
			up32 edx_109 = 0x00;
			while (true)
			{
				ui32 esi_92 = (word32) *ebp_105;
				int32 ebx_104 = ecx_110 | (esi_92 & 0x7F) << (byte) edx_109 & 0x00 - (edx_109 < 0x20);
				ebp_105 = (word32) ebp_105 + 1;
				if ((esi_92 & 0x80) == 0x00)
					break;
				edx_109 += 0x07;
				ecx_110 = ebx_104;
			}
			Eq_18407 edx_113 = ebx_40;
			Eq_18407 ebx_114 = ebx_104 *s ebx_40;
			if (ebx_40 <= 0x19)
			{
				uint32 ebp_424;
				Eq_18407 esi_405;
				if (dwArg10 == 0x01)
				{
					byte * ebp_428 = edx_18 - 0x01;
					Eq_18407 dwLoc58_1107 = ecx_23;
					uint32 dwLoc5C_1109 = edi_1028;
					while (true)
					{
						esi_405 = dwLoc58_1107;
						if (dwLoc58_1107 >= ebx_40)
							break;
						--ebp_428;
						dwLoc58_1107 = (word32) dwLoc58_1107 + 8;
						dwLoc5C_1109 = dwLoc5C_1109 << 0x08 | (word32) (*ebp_428);
					}
					ebp_424 = dwLoc5C_1109;
				}
				else
				{
					byte * ebp_389 = (word32) edx_18 + 1;
					Eq_18407 dwLoc58_1096 = ecx_23;
					uint32 dwLoc5C_1098 = edi_1028;
					while (true)
					{
						esi_405 = dwLoc58_1096;
						if (dwLoc58_1096 >= ebx_40)
							break;
						++ebp_389;
						dwLoc58_1096 = (word32) dwLoc58_1096 + 4;
						dwLoc5C_1098 = dwLoc5C_1098 << 0x04 | (word32) (*ebp_389) & 0x0F;
					}
					ebp_424 = dwLoc5C_1098;
				}
				Eq_17659 edi_1017 = edx_18;
				if (esi_405 > ebx_40)
				{
					Eq_18663 esi_464 = esi_405 - ebx_40;
					ebp_424 = ebp_424 >> (byte) esi_464 & 0x00 - (esi_464 < 0x20);
				}
				else
					edx_113 = esi_405;
				Eq_18407 ecx_481;
				uint32 edx_547;
				if (edx_113 == 0x01)
				{
					if (ebp_424 == 0x01)
					{
						ecx_481.u0 = 0x19;
						edx_547 = 0x01FFFFFF;
					}
					else
					{
						ecx_481 = ebx_114;
						edx_547 = ebp_424;
					}
				}
				else
				{
					if (edx_113 * 0x02 <= 0x19)
					{
						edx_486 = edx_113;
						while (true)
						{
							Eq_18407 edx_486;
							if (edx_486 > 0x20)
								break;
							ebp_424 = ebp_424 << (byte) edx_486 & 0x00 - (edx_486 < 0x20) | ebp_424;
							edx_486 *= 0x02;
						}
						if (edx_113 == 0x00)
							runtime.panicdivide(gs);
						ecx_481 = edx_113 *s (uint32) (0x19 /u edx_113);
						ebp_424 &= (0x01 << (byte) ecx_481 & 0x00 - (ecx_481 < 0x20)) - 0x01;
					}
					else
						ecx_481 = edx_113;
					edx_547 = ebp_424;
				}
				uint32 esi_1023 = edi_1028;
				Eq_18407 dwLoc74_1169 = ecx_23;
				for (; ebx_114 >= ecx_481; ebx_114 -= ecx_481)
				{
					esi_1023 |= edx_547 << (byte) dwLoc74_1169 & 0x00 - (dwLoc74_1169 < 0x20);
					word32 ebx_629 = ecx_481 + dwLoc74_1169;
					if (dwArg10 != 0x01)
					{
						while (ebx_629 >= 0x04)
						{
							*edi_1017 = (byte) (esi_1023 & 0x0F | 0xF0);
							ebx_629 = (word32) ebx_629 - 4;
							--edi_1017;
							esi_1023 >>= 0x04;
						}
					}
					else
					{
						while (ebx_629 >= 0x08)
						{
							*edi_1017 = (byte) esi_1023;
							esi_1023 >>= 0x08;
							ebx_629 = (word32) ebx_629 - 8;
							edi_1017 = (word32) edi_1017 + 1;
						}
					}
					dwLoc74_1169 = ebx_629;
				}
				Eq_18407 edx_586;
				if (ebx_114 > 0x00)
				{
					esi_1023 |= (edx_547 & (0x01 << (byte) ebx_114 & 0x00 - (ebx_114 < 0x20)) - 0x01) << (byte) dwLoc74_1169 & 0x00 - (dwLoc74_1169 < 0x20);
					edx_586 = dwLoc74_1169 + ebx_114;
				}
				else
					edx_586 = dwLoc74_1169;
				ecx_23 = edx_586;
				ebp_20 = ebp_105;
				edx_382 = ebp_20;
				ebx_377 = edi_1017;
				edi_1028 = esi_1023;
			}
			else
			{
				Eq_18407 edx_228;
				Eq_17659 ecx_250;
				Eq_18633 edx_118 = ebx_40 - ecx_23;
				if (dwArg10 == 0x01)
				{
					Eq_18407 ebp_263;
					byte * edx_262;
					byte * ebp_255 = edx_18 - ((word32) edx_118 + 7 >> 0x03);
					if ((edx_118 & 0x07) != 0x00)
					{
						up32 ebx_270 = 0x08 - (edx_118 & 0x07);
						edi_1028 |= ((word32) *ebp_255 >> (byte) ebx_270 & 0x00 - (ebx_270 < 0x20)) << (byte) ecx_23 & 0x00 - (ecx_23 < 0x20);
						ebp_263 = (word32) ecx_23 + (edx_118 & 0x07);
						ebx_114 -= edx_118 & 0x07;
						edx_262 = ebp_255 + 1;
					}
					else
					{
						edx_262 = ebp_255;
						ebp_263 = ecx_23;
					}
					uint32 ebx_300;
					Eq_17659 esi_302 = edx_18;
					for (ebx_300 = ebx_114 >> 0x03; ebx_300 > 0x00; --ebx_300)
					{
						uint32 edi_320 = edi_1028 | (word32) (*edx_262) << (byte) ebp_263 & 0x00 - (ebp_263 < 0x20);
						*esi_302 = (byte) edi_320;
						++edx_262;
						edi_1028 = edi_320 >> 0x08;
						esi_302 = (word32) esi_302 + 1;
					}
					ui32 ecx_345 = ebx_114 & 0x07;
					byte cl_353 = (byte) ecx_345;
					if ((ebx_114 & 0x07) > 0x00)
					{
						edi_1028 |= ((0x01 << cl_353) - 0x01 & (word32) (*edx_262)) << (byte) ebp_263 & 0x00 - (ebp_263 < 0x20);
						edx_228 = (word32) ebp_263 + ecx_345;
					}
					else
						edx_228 = ebp_263;
					ecx_250 = esi_302;
				}
				else
				{
					Eq_18407 ebp_135;
					Eq_18685 edx_134;
					struct Eq_18686 * edi_124 = (word32) edx_118 + 3 >> 0x02;
					word32 ebp_129 = edx_18 + edi_124;
					if ((edx_118 & 0x03) != 0x00)
					{
						up32 ebx_143 = 0x04 - (edx_118 & 0x03);
						edi_1028 |= (((word32) *ebp_129 & 0x0F) >> (byte) ebx_143 & 0x00 - (ebx_143 < 0x20)) << (byte) ecx_23 & 0x00 - (ecx_23 < 0x20);
						ebp_135 = (word32) ecx_23 + (edx_118 & 0x03);
						ebx_114 -= edx_118 & 0x03;
						edx_134 = edi_124 - 0x01 + edx_18;
					}
					else
					{
						edx_134 = ebp_129;
						ebp_135 = ecx_23;
					}
					uint32 ebx_173;
					Eq_17659 esi_175 = edx_18;
					for (ebx_173 = ebx_114 >> 0x02; ebx_173 > 0x00; --ebx_173)
					{
						uint32 edi_194 = edi_1028 | ((word32) (*edx_134) & 0x0F) << (byte) ebp_135 & 0x00 - (ebp_135 < 0x20);
						*esi_175 = (byte) (edi_194 & 0x0F | 0xF0);
						--edx_134;
						--esi_175;
						edi_1028 = edi_194 >> 0x04;
					}
					ui32 ecx_223 = ebx_114 & 0x03;
					byte cl_231 = (byte) ecx_223;
					if ((ebx_114 & 0x03) > 0x00)
					{
						edi_1028 |= ((0x01 << cl_231) - 0x01 & (word32) (*edx_134)) << (byte) ebp_135 & 0x00 - (ebp_135 < 0x20);
						edx_228 = (word32) ebp_135 + ecx_223;
					}
					else
						edx_228 = ebp_135;
					ecx_250 = esi_175;
				}
				ebp_20 = ebp_105;
				ebx_377 = ecx_250;
				ecx_23 = edx_228;
				edx_382 = ebp_20;
			}
		}
		esi_21 = ebp_20;
		ebp_20 = edx_382;
		edx_18 = ebx_377;
	}
}

// 08057E90: Register Eq_4 runtime.allocmcache(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mallocinit
//      runtime.startpanic_m
//      runtime.procresize
Eq_4 runtime.allocmcache(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 edi_111;
	word32 ebp_110;
	runtime.lock(esi, gs, 0x081488E0, out ebp_110, out esi_28, out edi_111);
	runtime.(*fixalloc).alloc(gs, &g_dw814B564);
	word32 ebx_113;
	word32 edx_112;
	runtime.unlock(gs, 0x081488E0, out edx_112, out ebx_113);
	Eq_19075 ecx_58 = 0x00;
	while (ecx_58 < 0x86)
	{
		if (ecx_58 >= 0x86)
			runtime.panicindex(gs);
		dwLoc08->a0014[ecx_58] = 135549664;
		ecx_58 = (word32) ecx_58 + 1;
	}
	runtime.nextSample(gs);
	dwLoc08->ptr0000 = 0x081488E0;
	return esi_28;
}

// 08057F30: void runtime.freemcache(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.procresize
void runtime.freemcache(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_49;
	word32 edi_50;
	runtime.systemstack(gs, fp - 0x08, out ebp_49, out edi_50);
}

// 08057F70: void runtime.(*mcache).refill(Register (ptr32 Eq_2) gs, Register Eq_661 xmm1, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.(*mcache).nextFree.func1
void runtime.(*mcache).refill(struct Eq_2 * gs, Eq_661 xmm1, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	uint32 edx_28 = (word32) (byte) (word32) bArg08;
	if (edx_28 >= 0x86)
		runtime.panicindex(gs);
	else
	{
		Eq_4 ebx_31 = *((word32) dwArg04 + (edx_28 * 0x04 + 20));
		Eq_4 esi_33 = *((word32) ebx_31 + 28);
		if ((word32) *((word32) ebx_31 + 56) != esi_33)
			runtime.throw(gs);
		else
		{
			if (ebx_31 != 135549664)
				*((word32) ebx_31 + 59) = 0x00;
			runtime.(*mcentral).cacheSpan(esi_33, gs, xmm1, (edx_28 << 0x06) + 135566272);
			if (dwLoc0C == 0x00)
				runtime.throw(gs);
			else if ((word32) *((word32) dwLoc0C + 56) == *((word32) dwLoc0C + 28))
				runtime.throw(gs);
			else
			{
				*((word32) dwArg04 + (edx_28 * 0x04 + 20)) = dwLoc0C;
				Eq_4 ecx_109 = *((word32) eax_18 + 24);
				--*((word32) ecx_109 + 0x0078);
			}
		}
	}
}

// 08058090: void runtime.(*mcache).releaseAll(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.flushmcache
//      runtime.freemcache.func1
void runtime.(*mcache).releaseAll(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_19241 eax_17 = 0x00;
	while (eax_17 < 0x86)
	{
		if (eax_17 >= 0x86)
			runtime.panicindex(gs);
		Eq_4 edx_42 = *((word32) dwArg04 + (eax_17 * 0x04 + 20));
		if (edx_42 != 135549664)
		{
			runtime.(*mcentral).uncacheSpan(gs, (eax_17 << 0x06) + 135566272, edx_42);
			((word32) dwArg04 + (eax_17 * 0x04 + 20))->u0 = 135549664;
		}
		eax_17 = (word32) eax_17 + 1;
	}
	((word32) dwArg04 + 8)->u0 = 0x00;
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
}

// 08058130: void runtime.(*mcentral).cacheSpan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm1, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*mcache).refill
void runtime.(*mcentral).cacheSpan(Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm1, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_19295 * ecx_21 = (int32) ((byte) (word32) *((word32) dwArg04 + 4) >> 0x01);
	if (ecx_21 >= (struct Eq_19295 *) 0x43)
		runtime.panicindex(gs);
	else
	{
		ui32 eax_25 = (word32) ecx_21->b8137B00;
		word32 ebp_861;
		word32 edi_862;
		Eq_4 esi_200;
		runtime.lock(runtime.deductSweepCredit(esi, gs, xmm1, eax_25 << 0x0D, 0x00), gs, dwArg04, out ebp_861, out esi_200, out edi_862);
		Eq_4 dwLoc24_673 = 0x00;
		if ((byte) (word32) g_b814F4C8 != 0x00)
			runtime.traceGCSweepStart(gs);
		Eq_4 eax_77 = g_t81490F0;
		eax_205 = eax_77;
l08058538:
		Eq_4 eax_205;
		Eq_4 ecx_207 = dwArg04;
		Eq_4 edx_409 = *((word32) dwArg04 + 8);
		while (true)
		{
			byte al_459;
			Eq_4 ecx_184;
			if (edx_409 == 0x00)
				break;
			Eq_4 ebp_324 = (word32) edx_409 + 48;
			esi_200 = eax_205 - 0x02;
			if (*((word32) edx_409 + 48) == esi_200)
			{
				runtime/internal/atomic.Cas(ebp_324, esi_200, eax_205 - 0x01);
				dwLoc24_673 = esi_200;
				if ((byte) (word32) bLoc1C != 0x00)
				{
					runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 8, edx_409);
					runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 16, edx_409);
					word32 ebx_871;
					word32 edx_870;
					runtime.unlock(gs, dwArg04, out edx_870, out ebx_871);
					runtime.(*mspan).sweep(gs, dwLoc2C, (byte) edx_409);
					Eq_4 esp_389 = <invalid>;
					al_459 = 0x00;
					ecx_184 = *((word32) esp_389 + 32);
					goto l0805820B;
				}
				eax_205 = eax_77;
				ecx_207 = dwArg04;
			}
			if (*((word32) edx_409 + 48) != eax_205 - 0x01)
			{
				runtime.(*mSpanList).remove(gs, (word32) ecx_207 + 8, edx_409);
				runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 16, edx_409);
				word32 ebx_864;
				word32 edx_863;
				runtime.unlock(gs, dwArg04, out edx_863, out ebx_864);
				al_459 = 0x00;
				ecx_184 = edx_409;
				goto l0805820B;
			}
			edx_409 = *edx_409;
		}
		Eq_4 edx_216 = *((word32) ecx_207 + 16);
		while (edx_216 != 0x00)
		{
			Eq_4 ebp_97 = (word32) edx_216 + 48;
			esi_200 = eax_205 - 0x02;
			if (*((word32) edx_216 + 48) == esi_200)
			{
				runtime/internal/atomic.Cas(ebp_97, esi_200, eax_205 - 0x01);
				dwLoc24_673 = esi_200;
				if ((byte) (word32) bLoc1C != 0x00)
				{
					runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 16, edx_216);
					runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 16, edx_216);
					word32 edx_879;
					word32 ebx_880;
					runtime.unlock(gs, dwArg04, out edx_879, out ebx_880);
					runtime.(*mspan).sweep(gs, dwLoc2C, (byte) edx_216);
					Eq_4 esp_164 = <invalid>;
					*esp_164 = *((word32) esp_164 + 32);
					Eq_4 esi_178 = runtime.(*mspan).nextFreeIndex(gs, *esp_164);
					ecx_184 = *((word32) esp_164 + 32);
					Eq_4 eax_183 = *((word32) esp_164 + 4);
					dwLoc24_673 = SEQ(SLICE(edx_216, word24, 8), 0x01);
					if (eax_183 != *((word32) ecx_184 + 28))
					{
						*((word32) ecx_184 + 24) = eax_183;
						al_459 = 0x00;
						goto l0805820B;
					}
					else
					{
						*esp_164 = *((word32) esp_164 + 44);
						word32 ebp_881;
						word32 edi_882;
						runtime.lock(esi_178, gs, *esp_164, out ebp_881, out esi_200, out edi_882);
						eax_205 = *((word32) esp_164 + 28);
						goto l08058538;
					}
				}
				eax_205 = eax_77;
				ecx_207 = dwArg04;
			}
			if (*((word32) edx_216 + 48) != eax_205 - 0x01)
				break;
			edx_216 = *edx_216;
		}
		byte al_219 = (byte) (word32) g_b814F4C8;
		if (al_219 != 0x00)
		{
			esi_200 = runtime.traceGCSweepDone(gs);
			ecx_207 = dwArg04;
		}
		word32 edx_872;
		word32 ebx_873;
		runtime.unlock(gs, ecx_207, out edx_872, out ebx_873);
		Eq_4 esi_270 = runtime.(*mcentral).grow(esi_200, gs, dwArg04);
		if (dwLoc24_673 == 0x00)
			return;
		word32 edi_876;
		word32 ebp_874;
		word32 esi_875;
		runtime.lock(esi_270, gs, dwArg04, out ebp_874, out esi_875, out edi_876);
		runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 16, dwLoc24_673);
		word32 edx_877;
		word32 ebx_878;
		runtime.unlock(gs, dwArg04, out edx_877, out ebx_878);
		al_459 = (byte) (word32) al_219;
		ecx_184 = dwLoc24_673;
l0805820B:
		if ((byte) (word32) g_b814F4C8 != 0x00 && al_459 == 0x00)
			runtime.traceGCSweepDone(gs);
		Eq_4 eax_482 = *((word32) ecx_184 + 16);
		Eq_4 edx_483 = *((word32) ecx_184 + 64);
		if (edx_483 == 0x00)
			runtime.panicdivide(gs);
		else
		{
			word16 dx_495 = (word16) (word32) *((word32) ecx_184 + 56);
			Eq_4 eax_497 = (uint32) ((uint64) (uint32) (eax_482 << 0x0D) /u edx_483) - (word32) dx_495;
			if (eax_497 != 0x00)
			{
				Eq_4 ebp_502 = *((word32) ecx_184 + 28);
				if (*((word32) ecx_184 + 24) != ebp_502 && ebp_502 != (word32) dx_495)
				{
					word32 ebx_865;
					word32 ebp_866;
					runtime/internal/atomic.Xadd64((word32) dwArg04 + 24, eax_497, eax_497 >> 0x1F, out ebx_865, out ebp_866);
					Eq_4 edx_541 = (eax_25 << 0x0D) - (word32) (*((word32) ecx_184 + 56)) *s *((word32) ecx_184 + 64);
					word32 ebx_867;
					Eq_4 ebp_552;
					runtime/internal/atomic.Xadd64(135632816, edx_541, 0x00 - (edx_541 < 0x00), out ebx_867, out ebp_552);
					if ((byte) (word32) g_b814F4C8 != 0x00)
					{
						word32 esi_868;
						ebp_552 = runtime.traceHeapAlloc(gs, out esi_868);
					}
					if (g_dw81575DC != 0x00)
						runtime.(*gcControllerState).revise(ebp_552, gs, &g_dw8157860);
					*((word32) ecx_184 + 59) = 0x01;
					word32 esi_869;
					runtime.(*mspan).refillAllocCache(gs, ecx_184, (*((word32) ecx_184 + 24) & ~0x3F) >> 0x03, out esi_869);
					Eq_4 ebx_624 = *((word32) ecx_184 + 24);
					uint32 ebp_626 = (ebx_624 & 0x3F) - 0x20;
					Eq_4 edx_623 = *((word32) ecx_184 + 36);
					uint32 ecx_636 = -ebp_626;
					byte cl_645 = (byte) (ebx_624 & 0x3F);
					ui32 ebp_649 = 0x00 - ((ebx_624 & 0x3F) < 0x20);
					*((word32) ecx_184 + 32) = edx_623 << (byte) ecx_636 & 0x00 - (ecx_636 < 0x20) | *((word32) ecx_184 + 32) >> cl_645 & ebp_649 | edx_623 >> (byte) ebp_626 & 0x00 - (ebp_626 < 0x20);
					*((word32) ecx_184 + 36) = edx_623 >> cl_645 & ebp_649;
					return;
				}
			}
			runtime.throw(gs);
		}
	}
}

// 08058590: void runtime.(*mcentral).uncacheSpan(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mcache).releaseAll
void runtime.(*mcentral).uncacheSpan(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_179;
	word32 esi_180;
	word32 edi_181;
	runtime.lock(esi, gs, dwArg04, out ebp_179, out esi_180, out edi_181);
	*((word32) dwArg08 + 59) = 0x00;
	word16 cx_29 = (word16) (word32) *((word32) dwArg08 + 56);
	if (cx_29 == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 edx_40 = *((word32) dwArg08 + 16);
		Eq_4 ebx_41 = *((word32) dwArg08 + 64);
		if (ebx_41 == 0x00)
			runtime.panicdivide(gs);
		else
		{
			Eq_19794 eax_58 = (uint32) ((uint64) (uint32) (edx_40 << 0x0D) /u ebx_41) - (word32) cx_29;
			if (eax_58 > 0x00)
			{
				runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 16, dwArg08);
				runtime.(*mSpanList).insert(gs, (word32) dwArg04 + 8, dwArg08);
				Eq_4 ecx_63 = 0x00 - eax_58;
				Eq_4 eax_84 = *((word32) dwArg08 + 64);
				uint64 edx_eax_87 = eax_84 * ecx_63;
				Eq_4 ebp_98 = SLICE(0x00 - SEQ(eax_58 >> 0x1F, eax_58), word32, 32);
				word32 ebx_182;
				word32 ebp_183;
				runtime/internal/atomic.Xadd64(135632816, (word32) edx_eax_87, eax_84 *s ebp_98 + SLICE(edx_eax_87, word32, 32), out ebx_182, out ebp_183);
				word32 ebp_124;
				word32 ebx_125;
				runtime/internal/atomic.Xadd64((word32) dwArg04 + 24, ecx_63, ebp_98, out ebx_125, out ebp_124);
			}
			word32 edx_184;
			word32 ebx_185;
			runtime.unlock(gs, dwArg04, out edx_184, out ebx_185);
		}
	}
}

// 080586D0: Register Eq_4 runtime.(*mcentral).freeSpan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C, Stack Eq_19863 bArg0D)
// Called from:
//      runtime.(*mspan).sweep
Eq_4 runtime.(*mcentral).freeSpan(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C, Eq_19863 bArg0D)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) *((word32) dwArg08 + 59) != 0x00)
		runtime.throw(gs);
	else
	{
		*((word32) dwArg08 + 61) = 0x01;
		if ((byte) (word32) bArg0C == 0x00)
		{
			Eq_4 esi_51;
			word32 edi_251;
			word32 ebp_250;
			runtime.lock(esi, gs, dwArg04, out ebp_250, out esi_51, out edi_251);
			if ((byte) (word32) bArg0D != 0x00)
			{
				runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 16, dwArg08);
				runtime.(*mSpanList).insert(gs, (word32) dwArg04 + 8, dwArg08);
			}
			runtime/internal/atomic.Store((word32) dwArg08 + 48, g_t81490F0);
			if ((word16) (word32) *((word32) dwArg08 + 56) == 0x00)
			{
				runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 8, dwArg08);
				word32 ebx_253;
				word32 edx_252;
				runtime.unlock(gs, dwArg04, out edx_252, out ebx_253);
				runtime.(*mheap).freeSpan(gs);
				return esi_51;
			}
			else
			{
				word32 ebx_255;
				word32 edx_254;
				runtime.unlock(gs, dwArg04, out edx_254, out ebx_255);
				return esi_51;
			}
		}
		else if (*((word32) dwArg08 + 8) == 0x00)
			runtime.throw(gs);
		else
		{
			runtime/internal/atomic.Store((word32) dwArg08 + 48, g_t81490F0);
			return esi;
		}
	}
}

// 08058840: Register Eq_4 runtime.(*mcentral).grow(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*mcentral).cacheSpan
Eq_4 runtime.(*mcentral).grow(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_19971 * eax_22 = (int32) ((byte) (word32) *((word32) dwArg04 + 4) >> 0x01);
	if (eax_22 >= (struct Eq_19971 *) 0x43)
		runtime.panicindex(gs);
	else
	{
		uint32 edx_26 = (word32) eax_22->b8137B00;
		Eq_19989 eax_28 = (word32) g_a8138820[eax_22 * 0x02];
		if (eax_28 == 0x00)
			runtime.panicdivide(gs);
		else
		{
			runtime.(*mheap).alloc(gs, 0x01);
			Eq_20002 eax_56 = (uint32) ((uint64) (uint32) (edx_26 << 0x0D) /u eax_28);
			if (dwLoc10 == null)
				return esi;
			dwLoc10->dw0050 = (word32) dwLoc10->t000C + eax_28 *s eax_56;
			runtime.heapBitsForSpan(esi, gs, dwLoc10->t000C);
			return runtime.heapBits.initSpan(esi, gs, edx_26, dwLoc10);
		}
	}
}

// 08058930: void runtime.addrspace_free(Register (ptr32 Eq_2) gs, Stack up32 dwArg08)
// Called from:
//      runtime.mmap_fixed
void runtime.addrspace_free(struct Eq_2 * gs, up32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 eax_17 = 0x00;
	while (eax_17 < dwArg08)
	{
		runtime.mincore();
		if (dwLoc08 != ~0x15 && dwLoc08 != ~0x0B)
			return;
		eax_17 = (word32) g_t8157620 + eax_17;
	}
}

// 080589B0: void runtime.mmap_fixed(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04, Stack Eq_20057 bArg0C)
// Called from:
//      runtime.sysMap
void runtime.mmap_fixed(struct Eq_2 * gs, uint32 dwArg04, Eq_20057 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.mmap();
	byte bLoc18_132 = (byte) dwArg0C;
	if (dwLoc08 != dwArg04)
	{
		runtime.addrspace_free(gs, dwArg08);
		if ((byte) (word32) bLoc18_132 != 0x00)
		{
			if (dwLoc08 > 0x1000)
				runtime.munmap();
			runtime.mmap();
		}
	}
}

// 08058AA0: Register word32 runtime.sysAlloc()
// Called from:
//      runtime.(*mheap).sysAlloc
//      runtime.persistentalloc1
//      runtime.recordspan
//      runtime.newArenaMayUnlock
//      runtime.stkbucket
//      runtime.stackalloc
//      runtime.traceFlush
//      runtime.(*traceAlloc).alloc
word32 runtime.sysAlloc()
{
	runtime.mmap();
	if (dwLoc08 >= 0x1000)
	{
		runtime.mSysStatInc(dwArg08, dwArg04);
		return;
	}
	else
	{
		if (dwLoc08 == 0x0D)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.exit();
		}
		if (dwLoc08 == 11)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.exit();
		}
		return;
	}
}

// 08058B80: void runtime.sysUnused(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.scavengeTreapNode
//      runtime.scavengelist
void runtime.sysUnused(struct Eq_2 * gs, uint32 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ecx_23;
	if ((dwArg04 & 0x001FFFFF) != 0x00)
		ecx_23 = dwArg04 & 0xFFE00000;
	else
		ecx_23 = 0x00;
	ui32 edx_38;
	if ((dwArg08 + dwArg04 & 0x001FFFFF) != 0x00)
		edx_38 = dwArg08 - 0x01 + dwArg04 & 0xFFE00000;
	else
		edx_38 = 0x00;
	bool Z_49 = SLICE(cond(ecx_23), bool, 2);
	if (ecx_23 != 0x00)
	{
		if (ecx_23 + 0x00200000 == edx_38)
		{
			runtime.madvise();
			goto l08058BEE;
		}
		Z_49 = SLICE(cond(ecx_23), bool, 2);
	}
	if (Z_49)
		runtime.madvise();
	if (edx_38 != 0x00 && ecx_23 != edx_38)
		runtime.madvise();
l08058BEE:
	Eq_4 edx_114 = g_t8157620;
	if ((dwArg04 & edx_114 - 0x01) != 0x00 || (dwArg08 & edx_114 - 0x01) != 0x00)
		runtime.throw(gs);
	else
		runtime.madvise();
}

// 08058CE0: void runtime.sysUsed(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg08)
// Called from:
//      runtime.(*mheap).allocSpanLocked
void runtime.sysUsed(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) dwArg04 + 0x001FFFFF & 0xFFE00000) < ((word32) dwArg04 + dwArg08 & 0xFFE00000))
		runtime.madvise();
}

// 08058D40: void runtime.sysFree()
// Called from:
//      runtime.(*mheap).sysAlloc
//      runtime.recordspan
void runtime.sysFree()
{
	runtime.mSysStatDec(dwArg0C, dwArg08);
	runtime.munmap();
}

// 08058D70: Register word32 runtime.sysFault(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mspan).sweep
//      runtime.stackfree
word32 runtime.sysFault(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.mmap();
}

// 08058DD0: Register word32 runtime.sysReserve(Register (ptr32 Eq_2) gs, Stack (ptr32 byte) dwArg0C)
// Called from:
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
word32 runtime.sysReserve(struct Eq_2 * gs, byte * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.mmap();
	if (dwLoc04 < 0x1000)
		return;
	*dwArg0C = 0x01;
	return;
}

// 08058E50: void runtime.sysMap(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04, Stack byte bArg0C)
// Called from:
//      runtime.(*mheap).sysAlloc
//      runtime.(*mheap).mapBits
//      runtime.(*mheap).mapSpans
void runtime.sysMap(struct Eq_2 * gs, uint32 dwArg04, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.mSysStatInc(dwArg10, dwArg08);
	if ((byte) (word32) bArg0C == 0x00)
	{
		runtime.mmap_fixed(gs, dwArg04, 0x03);
		if (dwLoc08 == 0x0C)
			runtime.throw(gs);
		else
		{
			if (dwLoc08 == dwArg04)
				return;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
	}
	else
	{
		runtime.mmap();
		if (dwLoc08 == 0x0C)
			runtime.throw(gs);
		else
		{
			if (dwLoc08 == dwArg04)
				return;
			runtime.throw(gs);
		}
	}
}

// subject_text_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text_0001.h"

// 08059000: Register Eq_4 runtime.queuefinalizer(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.freespecial
Eq_4 runtime.queuefinalizer(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw81575E4 != 0x00)
		runtime.throw(gs);
	else
	{
		word32 edi_39;
		word32 ebp_312;
		word32 esi_313;
		runtime.lock(esi, gs, 0x081575CC, out ebp_312, out esi_313, out edi_39);
		struct Eq_20353 * eax_45 = g_ptr8144FD0;
		if (eax_45 == null || eax_45->t0008 == 0xCC)
		{
			if (g_ptr8144FC8 == null)
			{
				runtime.persistentalloc(gs);
				g_ptr8144FC8 = dwLoc18;
				dwLoc18->ptr0000 = g_ptr8144FA8;
				g_ptr8144FA8 = g_ptr8144FC8;
				if ((byte) (word32) g_a81577E0[0] == 0x00)
				{
					struct Eq_20411 * eax_237;
					for (eax_237 = null; eax_237 < (struct Eq_20411 *) 0x80; ++eax_237)
					{
						struct Eq_20415 * ebx_227 = eax_237 - ((eax_237 + SLICE(eax_237 *s ~0x33333332, word32, 32) >> 0x02) - (eax_237 >> 0x1F)) * 0x05;
						if (ebx_227 >= (struct Eq_20415 *) 0x05)
						{
l08059222:
							runtime.panicindex(gs);
						}
						byte bl_235 = (byte) (word32) ebx_227->b8136040;
						if (eax_237 >= (struct Eq_20411 *) 0x80)
							goto l08059222;
						eax_237[0x081577E0] = (struct Eq_20411) bl_235;
					}
				}
			}
			struct Eq_20353 * eax_90 = g_ptr8144FC8;
			g_ptr8144FC8 = eax_90->ptr0004;
			eax_90->ptr0004 = g_ptr8144FD0;
			g_ptr8144FD0 = eax_90;
		}
		struct Eq_20353 * eax_97 = g_ptr8144FD0;
		Eq_4 ecx_98 = eax_97->t0008;
		if (ecx_98 >= 0xCC)
			runtime.panicindex(gs);
		else
		{
			runtime/internal/atomic.Xadd(&eax_97->t0008, 0x01);
			Eq_4 edx_122 = eax_97->a0010 + ecx_98 * 5;
			if (g_t81576F0 == 0x00)
				eax_97->a0010[ecx_98 * 5] = dwArg08;
			else
				runtime.writebarrierptr(edx_122, dwArg08);
			eax_97->a0018[ecx_98 * 5] = dwArg0C;
			Eq_4 ebx_150 = eax_97->a001C + ecx_98 * 5;
			Eq_4 ebp_151 = eax_97->a0020 + ecx_98 * 5;
			Eq_4 esi_152 = eax_97->a0014 + ecx_98 * 5;
			if (g_t81576F0 == 0x00)
			{
				eax_97->a001C[ecx_98 * 5].u0 = dwArg10;
				eax_97->a0020[ecx_98 * 5].u0 = dwArg14;
				eax_97->a0014[ecx_98 * 5].u0 = dwArg04;
			}
			else
			{
				runtime.writebarrierptr(ebx_150, dwArg10);
				runtime.writebarrierptr(ebp_151, dwArg14);
				runtime.writebarrierptr(esi_152, dwArg04);
			}
			g_b815756B = 0x01;
			word32 ebx_315;
			word32 edx_314;
			runtime.unlock(gs, 0x081575CC, out edx_314, out ebx_315);
			return esi_152;
		}
	}
}

// 08059250: void runtime.wakefing(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.findrunnable
void runtime.wakefing(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_66;
	word32 esi_67;
	word32 edi_68;
	runtime.lock(esi, gs, 0x081575CC, out ebp_66, out esi_67, out edi_68);
	if ((byte) (word32) g_b815756A != 0x00 && (byte) ((word32) g_b815756B) != 0x00)
	{
		g_b815756A = 0x00;
		g_b815756B = 0x00;
	}
	word32 edx_69;
	word32 ebx_70;
	runtime.unlock(gs, 0x081575CC, out edx_69, out ebx_70);
}

// 080592D0: void runtime.createfing(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.SetFinalizer
void runtime.createfing(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw81575C8 == 0x00)
	{
		runtime/internal/atomic.Cas(0x081575C8, 0x00, 0x01);
		if ((byte) (word32) bLoc04 != 0x00)
			runtime.newproc();
	}
}

// 08059340: void runtime.runfinq(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.runfinq(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 eax_17 = 0x00;
	Eq_4 ecx_18 = 0x00;
	while (true)
	{
		while (true)
		{
			word32 ebp_606;
			word32 edi_607;
			runtime.lock(esi, gs, 0x081575CC, out ebp_606, out esi, out edi_607);
			struct Eq_20353 * eax_41 = g_ptr8144FD0;
			g_ptr8144FD0 = null;
			word24 nLoc3F_596 = SLICE(dwLoc40, word24, 8);
			if (eax_41 != null)
				break;
			Eq_4 eax_431 = gs->ptr0000->tFFFFFFFC;
			if (g_t81576F0 == 0x00)
				g_t8144FCC = eax_431;
			else
				runtime.writebarrierptr(0x08144FCC, eax_431);
			g_b815756A = 0x01;
			runtime.goparkunlock(gs);
			dwLoc3C.u0 = 0x01;
			dwLoc40 = SEQ(nLoc3F_596, 0x14);
		}
		word32 ebx_605;
		word32 edx_604;
		runtime.unlock(gs, 0x081575CC, out edx_604, out ebx_605);
		struct Eq_20353 * eax_117 = eax_41;
		up32 ecx_118 = eax_17;
		Eq_4 edx_119 = ecx_18;
		while (eax_117 != null)
		{
			Eq_4 ebx_427 = eax_117->t0008;
			Eq_4 ebp_72 = &eax_117->t0008;
			while (ebx_427 > 0x00)
			{
				Eq_4 esi_120 = ebx_427 - 0x01;
				if (esi_120 >= 0xCC)
					runtime.panicindex(gs);
				Eq_4 ebx_124 = ebx_427 - 0x05 + ebx_427 * 0x04;
				up32 edi_126 = eax_117->a0018[ebx_124];
				if (ecx_118 < edi_126 + 0x08)
				{
					word32 esi_613;
					word32 edi_614;
					word32 ebx_612;
					runtime.mallocgc(ebx_124, gs, edi_126 + 0x08, 0x00, 0x01, out ebx_612, out esi_613, out edi_614);
					edx_119 = dwLoc40;
					ecx_118 = edi_126 + 0x08;
				}
				if (eax_117->a001C[ebx_124] == 0x00)
					runtime.throw(gs);
				edx_119->u0 = 0x00;
				((word32) edx_119 + 4)->u0 = 0x00;
				Eq_4 ecx_175 = eax_117->a001C[ebx_124];
				ui32 esi_176 = (word32) *((word32) ecx_175 + 0x0F);
				if ((byte) (esi_176 & 0x1F) == 0x14)
				{
					Eq_4 esi_227 = eax_117->a0020[ebx_124];
					if (g_t81576F0 == 0x00)
						*edx_119 = esi_227;
					else
						runtime.writebarrierptr(edx_119, esi_227);
					Eq_4 esi_253 = (word32) edx_119 + 4;
					Eq_4 esi_258 = eax_117->a0014[ebx_124];
					if (g_t81576F0 == 0x00)
						*((word32) edx_119 + 4) = esi_258;
					else
						runtime.writebarrierptr(esi_253, esi_258);
					if (*((word32) ecx_175 + 40) != 0x00)
					{
						runtime.assertE2I(gs, ecx_175, *edx_119);
						if (g_t81576F0 == 0x00)
						{
							*edx_119 = dwLoc40;
							*((word32) edx_119 + 4) = dwLoc3C;
						}
						else
						{
							runtime.writebarrierptr(edx_119, dwLoc40);
							runtime.writebarrierptr(esi_253, dwLoc3C);
						}
					}
				}
				else
				{
					if ((byte) (esi_176 & 0x1F) != 22)
						runtime.throw(gs);
					Eq_4 esi_206 = eax_117->a0014[ebx_124];
					if (g_t81576F0 == 0x00)
						*edx_119 = esi_206;
					else
						runtime.writebarrierptr(edx_119, esi_206);
				}
				g_b8157569 = 0x01;
				runtime.reflectcall(edi_126 + 0x08);
				g_b8157569 = 0x00;
				dwLoc40 = edi_126 + 0x08;
				dwLoc3C = edi_126 + 0x08;
				Eq_4 edx_373 = eax_117->a0010 + ebx_124;
				Eq_4 ebp_375 = eax_117->a0014 + ebx_124;
				esi = eax_117->a0020 + ebx_124;
				if (g_t81576F0 == 0x00)
				{
					eax_117->a0010[ebx_124].u0 = 0x00;
					eax_117->a0014[ebx_124] = 0x00;
					eax_117->a0020[ebx_124] = 0x00;
				}
				else
				{
					runtime.writebarrierptr(edx_373, 0x00);
					runtime.writebarrierptr(ebp_375, 0x00);
					runtime.writebarrierptr(esi, 0x00);
				}
				runtime/internal/atomic.Store(ebp_72, esi_120);
				ebx_427 = esi_120;
			}
			struct Eq_20353 * ecx_85 = eax_117->ptr0004;
			word32 edi_609;
			word32 ebp_608;
			runtime.lock(esi, gs, 0x081575CC, out ebp_608, out esi, out edi_609);
			eax_117->ptr0004 = g_ptr8144FC8;
			g_ptr8144FC8 = eax_117;
			word32 edx_610;
			word32 ebx_611;
			runtime.unlock(gs, 0x081575CC, out edx_610, out ebx_611);
			eax_117 = ecx_85;
		}
		eax_17 = ecx_118;
		ecx_18 = edx_119;
	}
}

// 08059790: void runtime.SetFinalizer(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      os.newFile
//      os.(*file).close
void runtime.SetFinalizer(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw8157748 != 0x00)
		return;
	if (dwArg04 == 0x00)
		runtime.throw(gs);
	if ((byte) ((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 22)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.concatstring3(gs, 0x00);
		runtime.throw(gs);
	}
	if (*((word32) dwArg04 + 32) == 0x00)
		runtime.throw(gs);
	runtime.findObject(esi, gs, dwArg08);
	if (dwLoc70 == 0x00)
	{
		if (dwArg08 == 0x0815765C)
			return;
		struct Eq_21206 * ecx_120;
		for (ecx_120 = &g_t8139420; ecx_120 != null; ecx_120 = ecx_120->ptr00D8)
		{
			if (ecx_120->t0038 <= dwArg08 && dwArg08 < ecx_120->t003C || (ecx_120->t0040 <= dwArg08 && dwArg08 < ecx_120->t0044 || (ecx_120->t0048 <= dwArg08 && dwArg08 < ecx_120->t004C || ecx_120->t0050 <= dwArg08 && dwArg08 < ecx_120->t0054)))
				return;
		}
		runtime.throw(gs);
	}
	if (dwArg08 != dwLoc70)
	{
		Eq_4 edx_186 = *((word32) dwArg04 + 32);
		if (edx_186 == 0x00 || (((byte) ((word32) (*((word32) edx_186 + 0x0F))) & 0x80) == 0x00 || *edx_186 >= 0x10))
			runtime.throw(gs);
	}
	if (dwArg0C == 0x00)
	{
		word32 edi_983;
		word32 ebp_982;
		runtime.systemstack(gs, fp - 0x20, out ebp_982, out edi_983);
		return;
	}
	if ((byte) ((word32) *((word32) dwArg0C + 0x0F) & 0x1F) != 0x13)
	{
		runtime.(*_type).string(gs, dwArg0C);
		runtime.concatstring3(gs, 0x00);
		runtime.throw(gs);
	}
	if (((word16) (word32) *((word32) dwArg0C + 0x0022) & 0x8000) != 0x00)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.(*_type).string(gs, dwArg0C);
		runtime.concatstring5(gs, 0x00);
		runtime.throw(gs);
	}
	word16 bx_345 = (word16) (word32) *((word32) dwArg0C + 32);
	if (bx_345 != 0x01)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.(*_type).string(gs, dwArg0C);
		runtime.concatstring4(gs, 0x00);
		runtime.throw(gs);
	}
	word32 ebp_414;
	if (((byte) (word32) *((word32) dwArg0C + 0x0C) & 0x01) != 0x00)
		ebp_414 = 0x34;
	else
		ebp_414 = 0x24;
	union Eq_4 * ebp_419 = (word32) dwArg0C + ebp_414;
	up32 ebx_425 = (word32) bx_345;
	if (ebx_425 > 0x00100000)
		runtime.panicslice(gs);
	if (ebx_425 <= 0x00)
		runtime.panicindex(gs);
	Eq_4 ebx_433 = *ebp_419;
	if (ebx_433 == dwArg04)
	{
l080598B4:
		((byte) (word32) *((word32) dwArg0C + 0x0C) & 0x01) == 0x00;
		word32 edx_604 = (word32) *((word32) dwArg0C + 32);
		up32 esi_606 = (word32) (word16) edx_604;
		up32 edx_609 = (word32) (word16) (edx_604 + ((word32) (*((word32) dwArg0C + 0x0022)) & 0x7FFF));
		if (esi_606 > edx_609 || edx_609 > 0x00100000)
			runtime.panicslice(gs);
		else
		{
			Eq_21117 edx_617 = edx_609 - esi_606;
			Eq_21117 ebp_639 = 0x00;
			while (ebp_639 < edx_617)
				ebp_639 = (word32) ebp_639.u0 + 1;
			runtime.createfing(gs);
			fn0808FD8A(0x00, fp - 0x18);
			word32 ebp_984;
			word32 edi_985;
			runtime.systemstack(gs, fp - 0x1C, out ebp_984, out edi_985);
			return;
		}
	}
	ui32 ebp_441 = (word32) *((word32) ebx_433 + 0x0F);
	if ((byte) (ebp_441 & 0x1F) != 22)
	{
		if ((byte) (ebp_441 & 0x1F) == 0x14)
		{
			if (*((word32) ebx_433 + 40) == 0x00)
				goto l080598B4;
			runtime.assertE2I2(gs, dwArg04);
			if ((byte) (word32) bLoc64 != 0x00)
				goto l080598B4;
		}
		goto l08059B1B;
	}
	runtime.(*_type).uncommon(gs, ebx_433);
	if (dwLoc74 != 0x00)
	{
		runtime.(*_type).uncommon(gs, dwArg04);
		if (dwLoc74 != 0x00)
			goto l08059B1B;
	}
	if (*((word32) ebx_433 + 32) == *((word32) dwArg04 + 32))
		goto l080598B4;
l08059B1B:
	runtime.(*_type).string(gs, dwArg04);
	runtime.(*_type).string(gs, dwArg0C);
	runtime.concatstring4(gs, 0x00);
	runtime.throw(gs);
}

// 08059E00: void runtime.findObject(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.SetFinalizer
//      runtime.addfinalizer
void runtime.findObject(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x00B8);
	up32 ecx_24 = *((word32) edx_20 + 588);
	*((word32) edx_20 + 588) = ecx_24 + 0x01;
	if (ecx_24 >= 0x3FFFFFFF)
	{
		word32 ebp_38;
		word32 edi_39;
		word32 esi_40;
		runtime.lock(esi, gs, 0x081488E0, out ebp_38, out esi_40, out edi_39);
		runtime.purgecachedstats(gs, edx_20);
		word32 edx_246;
		word32 ebx_247;
		runtime.unlock(gs, 0x081488E0, out edx_246, out ebx_247);
	}
	Eq_4 ecx_66 = g_t81493A8;
	Eq_4 edx_67 = g_t81493AC;
	if (dwArg04 < ecx_66 || dwArg04 >= edx_67)
		return;
	Eq_4 eax_78 = (dwArg04 >> 0x0D) - (ecx_66 >> 0x0D);
	Eq_4 ebx_80 = g_t8149108;
	if (eax_78 >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		struct Eq_21325 * ecx_84 = *((word32) ebx_80 + eax_78 * 0x04);
		if (ecx_84 == null)
			return;
		if (dwArg04 < ecx_84->t000C || (dwArg04 >= ecx_84->t0050 || (byte) ((word32) ecx_84->b003C) != 0x01))
			return;
		word32 esi_110 = ecx_84->dw0040;
		if ((byte) (word32) ecx_84->b003A >> 0x01 == 0x00 || esi_110 != 0x00)
			return;
		runtime.panicdivide(gs);
	}
}

// 08059F80: void runtime.(*fixalloc).alloc(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_19065) dwArg04)
// Called from:
//      runtime.allocmcache
//      runtime.(*mTreap).insert
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).grow
//      runtime.addfinalizer
//      runtime.setprofilebucket
void runtime.(*fixalloc).alloc(struct Eq_2 * gs, struct Eq_19065 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0000;
	if (ecx_18 == 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		Eq_4 ebx_44 = dwArg04->t000C;
		if (ebx_44 == 0x00)
		{
			if (dwArg04->t0014 < ecx_18)
			{
				runtime.persistentalloc(gs);
				dwArg04->dw0010 = dwLoc0C;
				dwArg04->t0014.u0 = 0x4000;
			}
			word32 ecx_66 = dwArg04->dw0010;
			<anonymous> ** edx_67 = dwArg04->ptr0004;
			if (edx_67 != null)
				(*edx_67)();
			dwArg04->dw0010 = (word32) dwArg04->t0000 + dwArg04->dw0010;
			dwArg04->t0014 -= dwArg04->t0000;
			dwArg04->dw0018 = (word32) dwArg04->t0000 + dwArg04->dw0018;
		}
		else
		{
			dwArg04->t000C = *ebx_44;
			dwArg04->dw0018 = (word32) dwArg04->t0000 + dwArg04->dw0018;
			if ((byte) (word32) dwArg04->b0020 != 0x00)
				runtime.memclrNoHeapPointers(ebx_44, dwArg04->t0000);
		}
	}
}

// 0805A0B0: void runtime.gcinit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.gcinit(struct Eq_2 * gs)
{
	Eq_4 dwLoc04_94 = SLICE(rLoc08, word32, 32);
	Eq_4 dwLoc08_95 = (word32) rLoc08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_t81490F4.u0 = 0x01;
	g_r81597A0 = (real64) (uint128) (uint64) g_r80F1848;
	runtime.uint64tofloat64(gs, g_t81360FC);
	uint128 xmm2_36 = (uint128) (uint64) g_r80F1858;
	real64 v11_37 = (real64) xmm2_36 + (real64) ((uint128) ((uint64) g_r81597A0));
	word128 xmm2_39 = SEQ(SLICE(xmm2_36, word64, 64), v11_37);
	real64 v13_40 = (real64) (uint128) (uint64) rLoc08 / v11_37;
	runtime.float64touint64(gs, v13_40);
	g_t81597C0 = dwLoc08_95;
	g_t81597C4 = dwLoc04_94;
	runtime/debug.setGCPercent(runtime.readgogc(gs), gs, xmm2_39, (word32) v13_40);
	g_dw814562C = 0x01;
	g_dw8145630 = 0x01;
}

// 0805A170: Register word32 runtime.readgogc(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcinit
word32 runtime.readgogc(struct Eq_2 * gs)
{
	byte bLoc04_89 = (byte) dwLoc04;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_27 = runtime.gogetenv(gs, 0x080E0ED6, 0x04);
	if (dwLoc04 == 0x03 && ((word16) ((word32) (*dwLoc08)) == 0x666F && (byte) ((word32) (*((word32) dwLoc08 + 2))) == 0x66))
		return esi_27;
	word32 esi_59;
	runtime.atoi32(gs, dwLoc08, dwLoc04, out esi_59);
	if ((byte) (word32) bLoc04_89 == 0x00)
		return esi_59;
	return esi_59;
}

// 0805A200: Register Eq_4 runtime.gcenable(Register Eq_4 ebp, Register word32 edi, Register (ptr32 Eq_2) gs, Register out ptr32 ediOut)
// Called from:
//      runtime.main
Eq_4 runtime.gcenable(Eq_4 ebp, word32 edi, struct Eq_2 * gs, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_32;
	Eq_4 ebp_27 = runtime.makechan(ebp, edi, gs, &g_t80CA680, 0x01, 0x00, out esi_32);
	runtime.newproc();
	ptr32 edi_60;
	Eq_4 ebp_57 = runtime.chanrecv1(ebp_27, esi_32, gs, dwLoc08, 0x00, out edi_60);
	g_b8159250 = 0x01;
	ediOut = edi_60;
	return ebp_57;
}

// 0805A280: void runtime/debug.setGCPercent(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register word128 xmm2, Stack Eq_21547 dwArg04)
// Called from:
//      runtime.gcinit
void runtime/debug.setGCPercent(Eq_4 esi, struct Eq_2 * gs, word128 xmm2, Eq_21547 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_132;
	ui32 edi_27;
	Eq_4 esi_28;
	runtime.lock(esi, gs, 0x081488E0, out ebp_132, out esi_28, out edi_27);
	Eq_21547 ecx_35 = dwArg04;
	if (dwArg04 < 0x00)
		ecx_35.u0 = ~0x00;
	g_t81575E0 = ecx_35;
	runtime.uint64div(gs, ecx_35 << 22, ecx_35 >> 0x1F << 22 | ecx_35 >> 0x0A, 100, 0x00);
	g_t81360F8 = dwLoc0C;
	g_t81360FC = dwLoc08;
	Eq_661 xmm0_68 = (uint128) (uint64) g_r81597A0;
	runtime.gcSetTriggerRatio(esi_28, edi_27, gs, xmm0_68, xmm2, (real64) xmm0_68);
	word32 edx_133;
	word32 ebx_134;
	runtime.unlock(gs, 0x081488E0, out edx_133, out ebx_134);
}

// 0805A340: void runtime.setGCPhase(Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkTermination
//      runtime.gcMarkTermination.func2
void runtime.setGCPhase(Eq_4 dwArg04)
{
	Eq_15876 al_17;
	runtime/internal/atomic.Store(135624164, dwArg04);
	word32 eax_12 = g_dw81575E4;
	if (eax_12 == 0x01)
		al_17.u0 = 0x01;
	else
		al_17 = eax_12 == 0x02;
	uip32 eax_25;
	g_t81576F4 = al_17;
	if (al_17 != 0x00)
		eax_25 = 0x01;
	else
		eax_25 = (word32) g_b81576F5;
	g_t81576F0 = (byte) eax_25;
}

// 0805A3A0: void runtime.(*gcControllerState).startCycle(Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_19505) dwArg04)
// Called from:
//      runtime.gcStart
void runtime.(*gcControllerState).startCycle(Eq_4 edi, struct Eq_2 * gs, struct Eq_19505 * dwArg04)
{
	Eq_4 dwLoc3C_459 = SLICE(rLoc40, word32, 32);
	Eq_4 dwLoc40_460 = (word32) rLoc40;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg04->dw0000 = 0x00;
	dwArg04->dw0004 = 0x00;
	dwArg04->dw0008 = 0x00;
	dwArg04->dw000C = 0x00;
	dwArg04->dw0010 = 0x00;
	dwArg04->dw0014 = 0x00;
	dwArg04->dw0018 = 0x00;
	dwArg04->dw001C = 0x00;
	dwArg04->dw0020 = 0x00;
	dwArg04->dw0024 = 0x00;
	dwArg04->dw0028 = 0x00;
	dwArg04->dw002C = 0x00;
	Eq_4 edx_30 = g_t81597AC;
	Eq_4 ebp_32 = g_t81360FC;
	Eq_4 esi_33 = g_t81360F8;
	if ((byte) (SEQ(SLICE(esi_33, word24, 8), g_t81597A8 <= esi_33) & SEQ(SLICE(edi, word24, 8), edx_30 == ebp_32) | SEQ(SLICE(ebp_32, word24, 8), edx_30 < ebp_32)) != 0x00)
	{
		runtime.uint64tofloat64(gs, edx_30);
		uint128 xmm2_91 = (uint128) (uint64) g_r80F1858;
		real64 v37_92 = (real64) xmm2_91 + (real64) ((uint128) ((uint64) g_r81597A0));
		runtime.float64touint64(gs, (real64) (uint128) (uint64) rLoc40 / v37_92);
		g_t81597C0 = dwLoc40_460;
		g_t81597C4 = dwLoc3C_459;
		xmm2 = SEQ(SLICE(xmm2_91, word64, 64), v37_92);
	}
	Eq_4 eax_108 = g_t81597C0;
	Eq_21547 ecx_111 = g_t81575E0;
	uint64 edx_eax_113 = ecx_111 * eax_108;
	Eq_4 ebp_114 = g_t81597C4;
	runtime.uint64div(gs, (word32) edx_eax_113, (ecx_111 >> 0x1F) *s eax_108 + (SLICE(edx_eax_113, word32, 32) + ecx_111 *s ebp_114), 100, 0x00);
	int64 ecx_ecx_451 = SEQ(ebp_114, dwLoc38) + SEQ(dwLoc34, eax_108);
	g_t8158228 = (word32) ecx_ecx_451;
	g_t815822C = SLICE(ecx_ecx_451, word32, 32);
	if (g_t81575E0 < 0x00)
	{
		g_t8158228.u0 = ~0x00;
		g_t815822C.u0 = ~0x00;
	}
	Eq_4 eax_152 = g_t81597B0;
	Eq_4 ecx_155 = g_t815822C;
	Eq_4 edx_156 = g_t8158228;
	word32 ebx_159 = Mem151[0x081597B4<p32>:word32] + (eax_152 <u 0x00100000);
	if ((byte) (SEQ(SLICE(ebp_114, word24, 8), ecx_155 == ebx_159) & SEQ(SLICE(edx_156, word24, 8), edx_156 < (word32) eax_152 + 0x00100000) | SEQ(SLICE(ecx_155, word24, 8), ecx_155 < ebx_159)) != 0x00)
	{
		g_t8158228 = (word32) eax_152 + 0x00100000;
		g_t815822C = ebx_159;
	}
	real64 v42_206 = (real64) g_t81575F0 * (real64) ((uint128) ((uint64) g_r80F1838));
	word128 xmm0_588;
	runtime.float64toint64(gs, v42_206, out xmm0_588);
	dwArg04->t0038.u0 = 100;
	dwArg04->dw003C = 0x00;
	runtime.int64tofloat64(ebx, gs, 100);
	Eq_661 xmm0_232 = (uint128) (uint64) 100.0;
	Eq_661 v44_234 = (real64) (uint128) (uint64) v42_206 - (real64) xmm0_232;
	dwArg04->t0050 = v44_234;
	if (v44_234 > __xorps(xmm0_232, xmm0_232))
	{
		dwArg04->t0098.u0 = 0x01;
		dwArg04->dw009C = 0x00;
	}
	else
	{
		dwArg04->t0098.u0 = 0x00;
		dwArg04->dw009C = 0x00;
	}
	int32 ecx_250;
	word32 * edx_253 = g_a81478C0;
	for (ecx_250 = 0x00; ecx_250 < 0x0401; ++ecx_250)
	{
		Eq_4 ebx_259 = *edx_253;
		if (ebx_259 == 0x00)
			break;
		*((word32) ebx_259 + 0x0940) = 0x00;
		*((word32) ebx_259 + 0x0944) = 0x00;
		++edx_253;
	}
	runtime.(*gcControllerState).revise(ebp, gs, dwArg04);
	if (g_dw8157730 > 0x00)
	{
		real64 rLoc08_508 = (real64) (uint128) (uint64) dwArg04->r0040;
		uint32 ecx_295 = g_dw81597BC;
		uint32 edx_297 = g_dw81597B8;
		Eq_4 ebx_299 = g_t8145650;
		Eq_4 ebp_301 = g_t814564C;
		Eq_4 esi_303 = g_t815822C;
		Eq_4 edi_305 = g_t8158228;
		Eq_4 esi_309 = dwArg04->t0038;
		Eq_4 eax_313 = dwArg04->t0098;
		runtime.printlock(gs);
		runtime.printstring(gs);
		word128 xmm2_591;
		runtime.printfloat(gs, xmm2, (real64) (uint128) (uint64) rLoc08_508, out xmm2_591);
		runtime.printstring(gs);
		runtime.printuint(ebp, gs, ecx_295 << 0x0C | edx_297 >> 0x14, ecx_295 >> 0x14);
		runtime.printstring(gs);
		runtime.printuint(ebp, gs, ebx_299 << 0x0C | ebp_301 >> 0x14, ebx_299 >> 0x14);
		runtime.printstring(gs);
		runtime.printuint(ebp, gs, esi_303 << 0x0C | edi_305 >> 0x14, esi_303 >> 0x14);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, esi_309);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, eax_313);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 0805A820: void runtime.(*gcControllerState).revise(Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_19505) dwArg04)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.(*gcControllerState).startCycle
//      runtime.gcSetTriggerRatio
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).freeSpan.func1
void runtime.(*gcControllerState).revise(Eq_4 ebp, struct Eq_2 * gs, struct Eq_19505 * dwArg04)
{
	word32 dwLoc20 = SLICE(qwLoc24, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ebx_23 = dwArg04->dw0004;
	ui64 edx_eax_179 = SEQ(edx_22, g_dw81597B8) - SEQ(ebx_23, dwArg04->dw0000);
	Eq_4 eax_20 = (word32) edx_eax_179;
	int32 edx_25 = SLICE(edx_eax_179, word32, 32);
	ui24 ebx_24_8_33 = SLICE(ebx_23, word24, 8);
	uint32 edx_22 = g_dw81597BC;
	Eq_4 eax_59 = eax_20;
	if ((byte) (SEQ(SLICE(ebp, word24, 8), eax_20 < 1000) & SEQ(ebx_24_8_33, edx_25 == 0x00) | SEQ(ebx_24_8_33, edx_25 < 0x00)) != 0x00)
	{
		eax_59.u0 = 1000;
		edx_25 = 0x00;
	}
	word64 mm0_224;
	ui24 ebx_24_8_95 = SLICE(runtime/internal/atomic.Load64(135632816, out mm0_224), word24, 8);
	ui64 ecx_eax_182 = SEQ(ecx_83, g_t8158228) - qwLoc24;
	Eq_4 eax_110 = (word32) ecx_eax_182;
	int32 ecx_86 = SLICE(ecx_eax_182, word32, 32);
	Eq_4 ecx_83 = g_t815822C;
	if ((byte) (SEQ(ebx_24_8_95, eax_110 <= 0x00) & SEQ(SLICE(dwLoc20, word24, 8), ecx_86 == 0x00) | SEQ(SLICE(dwLoc20, word24, 8), ecx_86 < 0x00)) != 0x00)
		eax_110.u0 = 0x01;
	runtime.int64tofloat64(SLICE(edx_25, word24, 8), gs, eax_59);
	runtime.int64tofloat64(ebx, gs, eax_110);
	real64 rLoc20_209 = SEQ(dwLoc1C, dwLoc20);
	dwArg04->r0040 = (real64) (uint128) (uint64) (real64) (uint128) (uint64) rLoc20_209 / (real64) ((uint128) ((uint64) rLoc20_209));
	runtime.int64tofloat64(ebx, gs, eax_110);
	runtime.int64tofloat64(ebx, gs, eax_59);
	dwArg04->r0048 = (real64) (uint128) (uint64) (real64) (uint128) (uint64) rLoc20_209 / (real64) ((uint128) ((uint64) rLoc20_209));
}

// 0805A980: void runtime.(*gcControllerState).endCycle(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_22265) dwArg04)
// Called from:
//      runtime.gcMarkDone
void runtime.(*gcControllerState).endCycle(word32 ebp, struct Eq_2 * gs, struct Eq_22265 * dwArg04)
{
	Eq_4 dwLoc7C_500 = (word32) rLoc7C;
	while (fp - 0x04 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_t8145640 != 0x00)
		return;
	uint128 xmm3_167;
	Eq_21547 eax_27 = g_t81575E0;
	runtime.uint64tofloat64(gs, g_t81597B4);
	Eq_4 eax_39 = g_t81597C4;
	Eq_4 ecx_40 = g_t81597C0;
	runtime.uint64tofloat64(gs, eax_39);
	runtime.nanotime();
	uint128 xmm0_47 = (uint128) (uint64) rLoc7C;
	uint128 xmm1_70 = (uint128) (uint64) (real64) (uint128) (uint64) rLoc7C;
	ui32 ebx_81 = dwArg04->dw0034;
	word64 edx_eax_457 = SEQ(eax_39, ecx_40) - SEQ(ebx_81, dwArg04->dw0030);
	real64 v16_66 = (real64) eax_27 / (real64) ((uint128) ((uint64) g_r80F1880));
	real64 v21_76 = (real64) xmm1_70 / (real64) ((uint128) ((uint64) ((real64) xmm0_47))) - (real64) ((uint128) ((uint64) g_r80F1858));
	int32 edx_83 = SLICE(edx_eax_457, word32, 32);
	uint32 eax_60 = (word32) edx_eax_457;
	ui24 ebx_24_8_100 = SLICE(ebp, word24, 8);
	uint128 xmm0_169 = SEQ(SLICE(xmm0_47, word64, 64), v16_66);
	uint128 xmm1_170 = SEQ(SLICE(xmm1_70, word64, 64), v21_76);
	if ((byte) (SEQ(ebx_24_8_100, edx_83 > 0x00) | SEQ(SLICE(ebx_81, word24, 8), edx_83 == 0x00) & SEQ(ebx_24_8_100, eax_60 > 0x00)) == 0x00)
		xmm3_167 = (uint128) (uint64) g_r80F1838;
	else
	{
		runtime.int64tofloat64(SLICE(ebx_149, word24, 8), gs, dwArg04->t0010);
		Eq_4 eax_136 = g_t81575F0;
		int32 ebx_149 = edx_83 *s eax_136;
		runtime.int64tofloat64(SLICE(ebx_149, word24, 8), gs, (word32) (eax_136 * eax_60));
		uint128 xmm3_160 = (uint128) (uint64) (real64) (uint128) (uint64) rLoc7C;
		xmm3_167 = SEQ(SLICE(xmm3_160, word64, 64), (real64) xmm3_160 / (real64) ((uint128) ((uint64) rLoc7C)) + (real64) ((uint128) ((uint64) g_r80F1838)));
		xmm0_169 = (uint128) (uint64) v16_66;
		xmm1_170 = (uint128) (uint64) v21_76;
	}
	uint128 xmm4_174 = (uint128) (uint64) g_r81597A0;
	real64 v34_176 = (real64) xmm0_169 - (real64) xmm4_174;
	real64 v37_183 = (real64) (uint128) (uint64) g_r80F1860 * (real64) xmm3_167;
	real64 v39_187 = (real64) xmm1_170 - (real64) xmm4_174;
	if (g_dw8157730 > 0x00)
	{
		real64 rLoc28_481 = g_r81597A0;
		Eq_4 eax_211 = g_t81597C4;
		Eq_4 ecx_213 = g_t81597C0;
		Eq_4 edx_215 = g_t81597AC;
		Eq_4 ebx_217 = g_t81597A8;
		Eq_4 ebp_219 = g_t81597B4;
		Eq_4 esi_221 = g_t81597B0;
		runtime.uint64tofloat64(gs, eax_211);
		Eq_661 xmm2_232 = (uint128) (uint64) v16_66;
		word128 xmm0_612;
		runtime.float64toint64(gs, ((real64) (uint128) (uint64) g_r80F1858 + (real64) xmm2_232) * (real64) ((uint128) ((uint64) rLoc7C)), out xmm0_612);
		word32 ebx_249 = dwArg04->dw0004;
		Eq_4 edx_251 = dwArg04->t0000;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printuint(ebp_219, gs, ecx_213, eax_211);
		runtime.printstring(gs);
		word128 xmm2_613;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (uint64) rLoc28_481, out xmm2_613);
		runtime.printstring(gs);
		runtime.printuint(ebp_219, gs, ebx_217, edx_215);
		runtime.printstring(gs);
		word128 xmm2_614;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (uint64) v21_76, out xmm2_614);
		runtime.printstring(gs);
		runtime.printuint(ebp_219, gs, esi_221, ebp_219);
		runtime.printstring(gs);
		word128 xmm2_615;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (uint64) v16_66, out xmm2_615);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_249, word24, 8), gs, dwLoc7C_500);
		runtime.printstring(gs);
		word128 xmm2_616;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (uint64) (real64) xmm3_167, out xmm2_616);
		runtime.printstring(gs);
		word128 xmm2_617;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (uint64) g_r80F1838, out xmm2_617);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_249, word24, 8), gs, edx_251);
		runtime.printstring(gs);
		word128 xmm2_618;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (uint64) v34_176, out xmm2_618);
		runtime.printstring(gs);
		word128 xmm2_619;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (uint64) v39_187, out xmm2_619);
		runtime.printstring(gs);
		word128 xmm2_620;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (uint64) v37_183, out xmm2_620);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 0805AE70: void runtime.(*gcControllerState).enlistWorker(Register Eq_22594 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_22596) dwArg04)
// Called from:
//      runtime.(*gcWork).put
//      runtime.(*gcWork).balance
void runtime.(*gcControllerState).enlistWorker(Eq_22594 ebx, struct Eq_2 * gs, struct Eq_22596 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 ecx_18 = dwArg04->dw0038;
	int32 edx_17 = dwArg04->dw003C;
	if ((byte) (SEQ(SLICE(ecx_18, word24, 8), edx_17 < 0x00) | SEQ(ebx_24_8, edx_17 == 0x00) & SEQ(SLICE(ecx_18, word24, 8), ecx_18 <= 0x00)) != 0x00)
		return;
	if (g_t81575F0 <= 0x01)
		return;
	Eq_4 ecx_47 = gs->ptr0000->tFFFFFFFC;
	if (ecx_47 == 0x00)
		return;
	Eq_4 ecx_51 = *((word32) ecx_47 + 24);
	if (ecx_51 == 0x00)
		return;
	Eq_4 ecx_55 = *((word32) ecx_51 + 92);
	if (ecx_55 == 0x00)
		return;
	Eq_4 ecx_59 = *((word32) ecx_55 + 4);
	int32 eax_160;
	for (eax_160 = 0x00; eax_160 < 0x05; ++eax_160)
	{
		Eq_4 edx_70 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		int32 ebp_72 = *((word32) edx_70 + 0x0094);
		Eq_4 ebx_71 = g_t81575F0;
		int32 esi_77 = ebp_72 << 0x01 ^ ebp_72 >> 0x1F & 0xA8888EEF;
		*((word32) edx_70 + 0x0094) = esi_77;
		if (ebx_71 == 0x01)
			runtime.panicdivide(gs);
		Eq_4 edx_101 = (uint32) ((uint64) (uint32) esi_77 % (ebx_71 - 0x01));
		if (edx_101 >= ecx_59)
			edx_101 = (word32) edx_101 + 1;
		if (edx_101 >= 0x0401)
			runtime.panicindex(gs);
		struct Eq_22710 * edx_116 = *((char *) g_a81478C0 + edx_101 * 0x04);
		if (edx_116->dw0008 == 0x01)
		{
			byte al_146;
			Eq_4 edx_120 = edx_116->t0030;
			if (edx_120 != 0x00 && edx_120 != *((word32) (gs->ptr0000)->tFFFFFFFC + 24))
			{
				struct Eq_22739 * esi_130 = *((word32) edx_120 + 84);
				if (esi_130 != null && esi_130 != *edx_120)
				{
					esi_130->b006C = 0x01;
					esi_130->dw0008 = ~0x0521;
					al_146 = 0x01;
				}
				else
					al_146 = 0x00;
			}
			else
				al_146 = 0x00;
			if (al_146 != 0x00)
				return;
		}
	}
}

// 0805AFC0: void runtime.(*gcControllerState).findRunnableGCWorker(Register Eq_4 esi, Register word32 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_22764) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.schedule
void runtime.(*gcControllerState).findRunnableGCWorker(Eq_4 esi, word32 edi, struct Eq_2 * gs, struct Eq_22764 * dwArg04, Eq_4 dwArg08)
{
	byte bLoc28 = (byte) dwLoc28;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw81575DC == 0x00)
		runtime.throw(gs);
	else
	{
		if (*((word32) dwArg08 + 0x0948) == 0x00)
			return;
		runtime.gcMarkWorkAvailable(gs, dwArg08);
		if ((byte) (word32) bLoc28 == 0x00)
			return;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.(*gcControllerState).findRunnableGCWorker.func1(SLICE(ebx, word24, 8), gs, stackArg0, (char *) &dwArg04->t0020 + 24);
		if ((byte) (word32) bLoc28 != 0x00)
			((word32) dwArg08 + 0x094C)->u0 = 0x00;
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.(*gcControllerState).findRunnableGCWorker.func1(g_t80E7B69, gs, stackArg0, &dwArg04->r0050 + 9);
			if ((byte) (word32) bLoc28 == 0x00)
				return;
			runtime.nanotime();
			ui64 ecx_eax_245 = SEQ(dwLoc28, &dwArg04->r0050 + 9) - SEQ(edx_97, g_t8157890);
			Eq_4 eax_94 = (word32) ecx_eax_245;
			ui24 ebx_24_8_114 = SLICE(esi, word24, 8);
			int32 ecx_99 = SLICE(ecx_eax_245, word32, 32);
			Eq_4 edx_97 = g_t8157894;
			Eq_4 ebx_101 = dwArg04->t0020;
			if ((byte) (SEQ(ebx_24_8_114, ecx_99 > 0x00) | SEQ(SLICE(edi, word24, 8), ecx_99 == 0x00) & SEQ(ebx_24_8_114, eax_94 > 0x00)) != 0x00)
			{
				runtime.int64tofloat64(SLICE(ebx_101, word24, 8), gs, ebx_101);
				runtime.int64tofloat64(SLICE(ebx_101, word24, 8), gs, eax_94);
				if ((real64) (uint128) (uint64) (real64) (uint128) (uint64) rLoc24 / (real64) ((uint128) ((uint64) rLoc24)) > (uint128) ((uint64) dwArg04->r0050))
				{
					word32 ebx_375;
					word32 ebp_376;
					runtime/internal/atomic.Xaddint64(&dwArg04->r0050 + 9, 0x01, 0x00, out ebx_375, out ebp_376);
					return;
				}
			}
			((word32) dwArg08 + 0x094C)->u0 = 0x01;
		}
		Eq_4 eax_207 = *((word32) dwArg08 + 0x0948);
		runtime.casgstatus(eax_207, 0x04, 0x01);
		if ((byte) (word32) g_b814F4C8 != 0x00)
			runtime.traceGoUnpark(gs, eax_207);
	}
}

// 0805B1E0: void runtime.gcSetTriggerRatio(Register Eq_4 esi, Register ui32 edi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register word128 xmm2, Stack Eq_4 rArg04)
// Called from:
//      runtime/debug.setGCPercent
//      runtime.gcMarkTermination
void runtime.gcSetTriggerRatio(Eq_4 esi, ui32 edi, struct Eq_2 * gs, Eq_661 xmm0, word128 xmm2, Eq_4 rArg04)
{
	word32 dwLoc68 = (word32) qwLoc68;
	ui32 dwLoc64 = SLICE(qwLoc68, word32, 32);
	Eq_4 dwLoc6C_834 = SLICE(rLoc70, word32, 32);
	Eq_4 dwLoc70_835 = (word32) rLoc70;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_661 xmm1_51;
	Eq_661 xmm0_21 = __xorps(xmm0, xmm0);
	Eq_661 xmm1_22 = (uint128) (uint64) rArg04;
	if ((real64) xmm0_21 > xmm1_22)
		xmm1_51 = __xorps(xmm1_22, xmm1_22);
	else
	{
		Eq_22960 xmm2_33;
		Eq_21547 ecx_27 = g_t81575E0;
		if (ecx_27 >= 0x00)
		{
			word64 v88_38 = SLICE(xmm2, word64, 64);
			xmm2_33 = SEQ(v88_38, (real64) ecx_27 * (real64) ((uint128) ((uint64) g_r80F1850)) / (real64) ((uint128) ((uint64) g_r80F1880)));
			if ((real64) xmm1_22 <= xmm2_33)
				xmm2_33 = SEQ(v88_38, (real64) xmm1_22);
		}
		else
			xmm2_33 = SEQ(SLICE(xmm2, word64, 64), (real64) xmm1_22);
		xmm1_51 = SEQ(SLICE(xmm1_22, word64, 64), (real64) xmm2_33);
	}
	word64 ecx_eax_1104;
	g_r81597A0 = (real64) xmm1_51;
	if (g_t81575E0 < 0x00)
		ecx_eax_1104 = ~0x00;
	else
	{
		runtime.uint64tofloat64(gs, g_t81597C4);
		real64 rLoc08_822 = (real64) xmm1_51;
		Eq_661 xmm2_79 = (uint128) (uint64) rLoc08_822;
		Eq_661 xmm0_77 = (uint128) (uint64) rLoc70;
		real64 v59_83 = ((real64) (uint128) (uint64) g_r80F1858 + (real64) xmm2_79) * (real64) xmm0_77;
		runtime.float64touint64(gs, v59_83);
		dwLoc74 = SLICE(v59_83, word32, 32);
		Eq_4 edx_141 = g_t81360FC;
		Eq_4 ebx_187 = g_t81360F8;
		Eq_4 ebp_146 = g_t81490F4;
		if (ebp_146 == 0x00)
		{
			word64 mm0_107;
			runtime/internal/atomic.Load64(135632816, out mm0_107);
			Eq_21547 edx_116 = g_t81575E0;
			Eq_4 ebx_124 = edx_116 >> 0x1F << 0x14 | edx_116 >> 0x0C;
			runtime.uint64div(gs, edx_116 << 0x14, ebx_124, 100, 0x00);
			word64 edx_eax_819 = SEQ(dwLoc70_835, dwLoc68) + SEQ(dwLoc64, dwLoc74);
			edx_141 = SLICE(edx_eax_819, word32, 32);
			ui24 ebx_24_8_160 = SLICE(esi, word24, 8);
			Eq_4 ebx_173 = SEQ(ebx_24_8_160, edx_141 > edx_141);
			Eq_4 eax_136 = (word32) edx_eax_819;
			dwLoc74 = ebx_124;
			ebp_146 = ebx_187;
			esi = ebx_173;
			rLoc70 = 4.94065645841247e-322;
			if ((byte) (SEQ(SLICE(ebx_124, word24, 8), edx_141 == edx_141) & SEQ(ebx_24_8_160, eax_136 > ebx_187) | ebx_173) == 0x00)
				eax_136 = ebx_187;
			ebx_187 = eax_136;
		}
		Eq_4 edx_247;
		ui24 ebx_24_8_202 = SLICE(ebp_146, word24, 8);
		Eq_4 ebx_229 = SEQ(ebx_24_8_202, dwLoc6C_834 < edx_141);
		ui32 esi_232 = SEQ(SLICE(esi, word24, 8), dwLoc70_835 < ebx_187) & SEQ(ebx_24_8_202, dwLoc6C_834 == edx_141) | ebx_229;
		Eq_4 ebp_230 = ebx_229;
		Eq_4 ebx_231 = ebx_187;
		if ((byte) esi_232 != 0x00)
			edx_247 = edx_141;
		else
		{
			ebp_230 = dwLoc6C_834;
			ebx_231 = dwLoc70_835;
			edx_247 = dwLoc6C_834;
		}
		ui24 ebx_24_8_260 = SLICE(ebp_230, word24, 8);
		esi = SEQ(SLICE(esi_232, word24, 8), Test(ULT,false)) & SEQ(ebx_24_8_260, edx_247 == 0x00);
		Eq_4 ebp_287 = SEQ(ebx_24_8_260, edx_247 < 0x00) | esi;
		ebp = ebp_287;
		if ((byte) ebp_287 != 0x00)
		{
			Eq_4 eax_304 = g_t815822C;
			Eq_4 ecx_306 = g_t8158228;
			Eq_4 edx_308 = g_t81597C4;
			Eq_4 ebx_310 = g_t81597C0;
			Eq_4 ebp_312 = g_t81597B4;
			Eq_4 esi_314 = g_t81597B0;
			Eq_4 edi_316 = g_t8145650;
			Eq_4 edi_318 = g_t814564C;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, ecx_306, eax_304);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, ebx_310, edx_308);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, esi_314, ebp_312);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, edi_318, edi_316);
			runtime.printstring(gs);
			word128 xmm2_1109;
			runtime.printfloat(gs, xmm2_79, (real64) (uint128) (uint64) rLoc08_822, out xmm2_1109);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, ebx_187, edx_141);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		xmm0_21 = __xorps(xmm0_77, xmm0_77);
		ecx_eax_1104 = SEQ(edx_247, ebx_231);
	}
	Eq_4 edx_558;
	Eq_4 ebx_560;
	Eq_4 eax_446 = (word32) ecx_eax_1104;
	g_t81597A8 = eax_446;
	Eq_4 ecx_449 = SLICE(ecx_eax_1104, word32, 32);
	g_t81597AC = ecx_449;
	Eq_21547 edx_453 = g_t81575E0;
	if (edx_453 < 0x00)
	{
		edx_558.u0 = ~0x00;
		ebx_560.u0 = ~0x00;
	}
	else
	{
		Eq_4 eax_457 = g_t81597C0;
		uint64 edx_eax_461 = edx_453 * eax_457;
		Eq_4 ebp_462 = g_t81597C4;
		Eq_4 ecx_472 = (edx_453 >> 0x1F) *s eax_457 + (SLICE(edx_eax_461, word32, 32) + edx_453 *s ebp_462);
		runtime.uint64div(gs, (word32) edx_eax_461, ecx_472, 100, 0x00);
		ui64 edx_ecx_810 = qwLoc68 + SEQ(ebp_462, eax_457);
		Eq_4 edx_491 = SLICE(edx_ecx_810, word32, 32);
		ui24 ebx_24_8_500 = SLICE(ebp_462, word24, 8);
		Eq_4 ebx_533 = SEQ(ebx_24_8_500, edx_491 < ecx_449);
		Eq_4 ecx_486 = (word32) edx_ecx_810;
		dwLoc74 = ecx_472;
		esi = eax_446;
		ebp = ebx_533;
		Eq_4 ebx_535 = ecx_449;
		rLoc70 = 4.94065645841247e-322;
		if ((byte) (SEQ(SLICE(edi, word24, 8), ecx_486 < eax_446) & SEQ(ebx_24_8_500, edx_491 == ecx_449) | ebx_533) == 0x00)
		{
			esi = ecx_486;
			ebx_535 = edx_491;
		}
		xmm0_21 = __xorps(xmm0_21, xmm0_21);
		edx_558 = ebx_535;
		ebx_560 = esi;
	}
	g_t8158228 = ebx_560;
	g_t815822C = edx_558;
	Eq_4 dwLoc70_966 = (word32) rLoc70;
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		runtime.traceNextGC(gs);
		xmm0_21 = __xorps(xmm0_21, xmm0_21);
	}
	if (g_dw81575E4 != 0x00)
	{
		runtime.(*gcControllerState).revise(ebp, gs, &g_dw8157860);
		xmm0_21 = __xorps(xmm0_21, xmm0_21);
	}
	if (g_t81490F4 != 0x00)
		g_r8149160 = (real64) xmm0_21;
	else
	{
		word64 mm0_1107;
		runtime/internal/atomic.Load64(135632816, out mm0_1107);
		up32 ecx_633 = eax_446 - dwLoc74;
		ui24 ebx_24_8_653 = SLICE(ecx_633 + 0xFFF00000, word24, 8);
		int32 edx_646 = (bool) (ecx_633 < 0xFFF00000) + (SLICE(ecx_eax_1104 - SEQ(dwLoc70_966, dwLoc74), word32, 32) + ~0x00);
		ui32 esi_664 = SEQ(SLICE(esi, word24, 8), ecx_633 < ~0x00101FFF) & SEQ(ebx_24_8_653, edx_646 == 0x00);
		Eq_4 ecx_635 = ecx_633 + 0xFFF00000;
		if ((byte) (SEQ(ebx_24_8_653, edx_646 < 0x00) | esi_664) != 0x00)
			ecx_635.u0 = 0x2000;
		word64 mm0_688;
		runtime/internal/atomic.Load64(0x08149148, out mm0_688);
		ui64 ebx_ecx_816 = SEQ(ebx_698, g_dw8149140) - SEQ(dwLoc70_966, dwLoc74);
		int32 ebx_700 = SLICE(ebx_ecx_816, word32, 32);
		ui24 ebx_24_8_709 = SLICE(dwLoc70_966, word24, 8);
		Eq_4 ecx_695 = (word32) ebx_ecx_816;
		ui32 ebx_698 = g_dw8149144;
		if ((byte) (SEQ(SLICE(esi_664, word24, 8), ecx_695 <= 0x00) & SEQ(ebx_24_8_709, ebx_700 == 0x00) | SEQ(ebx_24_8_709, ebx_700 < 0x00)) != 0x00)
			g_r8149160 = (real64) __xorps(xmm0_21, xmm0_21);
		else
		{
			runtime.int64tofloat64(ebx, gs, ecx_695);
			runtime.int64tofloat64(ebx, gs, ecx_635);
			g_r8149160 = (real64) (uint128) (uint64) (real64) (uint128) (uint64) rLoc70 / (real64) ((uint128) ((uint64) rLoc70));
			g_t8149158 = dwLoc74;
			g_t814915C = dwLoc70_966;
			runtime/internal/atomic.Store64(dwLoc7C, 135565648, SEQ(dwLoc70_966, dwLoc74));
		}
	}
}

// 0805B810: Register Eq_4 runtime.gcTrigger.test(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 qwArg08)
// Called from:
//      runtime.mallocgc
//      runtime.gcStart
//      runtime.sysmon
Eq_4 runtime.gcTrigger.test(Eq_4 edx, struct Eq_2 * gs, word32 dwArg04, Eq_4 qwArg08)
{
	word32 dwLoc04 = SLICE(qwLoc08, word32, 32);
	word32 dwLoc08 = (word32) qwLoc08;
	Eq_4 edx_14 = edx;
	while (true)
	{
		ui24 edx_24_8_106 = SLICE(edx_14, word24, 8);
		if (fp > *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
			break;
		edx_14 = runtime.morestack_noctxt();
	}
	if ((byte) (word32) g_b8159250 == 0x00 || g_dw8157618 != 0x00)
		return edx_14;
	if (dwArg04 == 0x00)
		return edx_14;
	if (g_dw81575E4 != 0x00)
		return edx_14;
	if (dwArg04 == 0x01)
		return SEQ(g_n81597A9, g_t81597B4 == g_t81597AC);
	if (dwArg04 != 0x02)
	{
		if (dwArg04 != 0x03)
			return edx_14;
		return edx_14;
	}
	else
	{
		if (g_t81575E0 < 0x00)
			return edx_14;
		word64 mm0_274;
		Eq_4 edx_112 = SEQ(edx_24_8_106, dwLoc04 != 0x00) | SEQ(SLICE(runtime/internal/atomic.Load64(0x08159790, out mm0_274), word24, 8), dwLoc08 != 0x00);
		if ((byte) edx_112 != 0x00)
		{
			up32 edx_121 = (word32) (qwArg08 - qwLoc08);
			edx_112 = SEQ(SLICE(edx_121, word24, 8), edx_121 > g_dw81360F0);
		}
		return edx_112;
	}
}

// 0805B960: Register Eq_4 runtime.gcStart(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_15280 esiOut)
// Called from:
//      runtime.mallocgc
//      runtime.forcegchelper
Eq_4 runtime.gcStart(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_15280 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	Eq_4 ecx_23 = *((word32) eax_18 + 24);
	Eq_4 eax_27 = gs->ptr0000->tFFFFFFFC;
	if (eax_27 != *ecx_23)
	{
		Eq_4 edx_31 = *((word32) ecx_23 + 0x0078);
		if (edx_31 <= 0x01 && *((word32) ecx_23 + 116) == 0x00)
		{
			*((word32) ecx_23 + 0x0078) = edx_31 - 0x01;
			if (edx_31 == 0x01 && (byte) ((word32) (*((word32) eax_27 + 0x006C))) != 0x00)
				((word32) eax_27 + 8)->u0 = ~0x0521;
			while (true)
			{
				runtime.gcTrigger.test(edx, gs, dwArg08, dwArg0C);
				if ((byte) (word32) bLoc10 == 0x00)
					break;
				runtime.gosweepone(gs);
				if (dwArg08 == ~0x00)
					break;
				++g_dw81451EC;
			}
			runtime.semacquire(gs);
			runtime.gcTrigger.test(edx, gs, dwArg08, dwArg0C);
			if ((byte) (word32) bLoc10 == 0x00)
			{
				Eq_4 edx_126 = runtime.semrelease(gs);
				esiOut = esi;
				return edx_126;
			}
			else
			{
				Eq_22284 al_136;
				if (dwArg08 == 0x00)
					al_136.u0 = 0x01;
				else
					al_136 = dwArg08 == 0x03;
				g_t8145640 = al_136;
				Eq_4 eax_142 = dwArg04;
				if (dwArg04 == 0x00)
				{
					word32 ecx_146 = g_dw815773C;
					if (ecx_146 == 0x01)
						eax_142.u0 = 0x01;
					else if (ecx_146 == 0x02)
						eax_142.u0 = 0x02;
				}
				runtime.semacquire(gs);
				if ((byte) (word32) g_b814F4C8 != 0x00)
					runtime.traceGCStart(gs);
				if (eax_142 == 0x00)
					runtime.gcBgMarkStartWorkers(gs);
				runtime.gcResetMarkState(gs);
				runtime.gcprocs(gs);
				Eq_4 eax_195 = g_t81575F0;
				g_t814566C.u2 = 0x08136024;
				g_t8145670 = eax_195;
				word64 mm0_560;
				runtime/internal/atomic.Load64(135632816, out mm0_560);
				g_t81456A4 = dwArg0C;
				g_t81456A8 = dwArg10;
				g_t8145694.u0 = 0x00;
				g_dw8145698 = 0x00;
				g_t814563C = eax_142;
				runtime.nanotime();
				g_t8145674.u1 = 135632816;
				g_t8145678 = dwArg0C;
				g_t814569C.u1 = 135632816;
				g_t81456A0 = dwArg0C;
				word32 edi_562;
				word32 ebp_561;
				runtime.systemstack(gs, 0x080E7CDC, out ebp_561, out edi_562);
				word32 edi_564;
				word32 ebp_563;
				runtime.systemstack(gs, 0x080E7C0C, out ebp_563, out edi_564);
				runtime.clearpools(gs);
				++g_dw8145668;
				if (eax_142 == 0x00)
				{
					runtime.(*gcControllerState).startCycle(edi_339, gs, &g_dw8157860);
					Eq_4 eax_285 = g_t815822C;
					g_t81456BC = g_t8158228;
					g_t81456C0 = eax_285;
					runtime.setGCPhase(0x01);
					g_t81455F8.u0 = ~0x00;
					g_t8145604.u0 = ~0x00;
					runtime.gcMarkRootPrepare(gs);
					runtime.gcMarkTinyAllocs(gs);
					runtime/internal/atomic.Store(135624156, 0x01);
					g_t8157890.u1 = 135632816;
					g_t8157894 = dwArg0C;
					word32 ebp_565;
					word32 edi_566;
					runtime.systemstack(gs, 135167188, out ebp_565, out edi_566);
					runtime.nanotime();
					Eq_23665 ecx_330 = g_t814569C;
					Eq_23780 eax_332 = 135167188 - ecx_330;
					Eq_23650 ebx_333 = g_t8145694;
					ui32 edi_337 = g_dw8145698;
					Eq_4 edi_339 = g_t81456A0;
					Mem340[0x08145694<p32>:word32] = eax_332 + ebx_333;
					esi = SLICE(4430134484 - SEQ(edi_339, ecx_330), word32, 32);
					g_dw8145698 = SLICE(SEQ(edi_337, eax_332) + SEQ(esi, ebx_333), word32, 32);
					g_t814567C.u1 = 135167188;
					g_t8145680.u0 = 0x01;
				}
				else
				{
					runtime.nanotime();
					g_t814567C.u1 = 0x080E7C0C;
					g_t8145680 = dwArg0C;
					g_t8145684.u1 = 0x080E7C0C;
					g_t8145688 = dwArg0C;
					Eq_4 eax_269 = g_t81456A8;
					g_t81456BC = g_t81456A4;
					g_t81456C0 = eax_269;
					runtime.gcMarkTermination(gs, (real64) (uint128) (uint64) g_r81597A0);
				}
				Eq_4 edx_362 = runtime.semrelease(gs);
				esiOut = esi;
				return edx_362;
			}
		}
	}
	Eq_4 edx_40 = *((word32) ecx_23 + 0x0078);
	*((word32) ecx_23 + 0x0078) = edx_40 - 0x01;
	if (edx_40 == 0x01 && (byte) ((word32) (*((word32) eax_27 + 0x006C))) != 0x00)
		((word32) eax_27 + 8)->u0 = ~0x0521;
	esiOut = esi;
	return edx_40;
}

// 0805BD40: void runtime.gcMarkDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcBgMarkWorker
//      runtime.gcAssistAlloc
void runtime.gcMarkDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime.semacquire(gs);
		if (g_dw81575E4 != 0x01 || g_t81455F8 != g_t8145604)
		{
l0805BF6F:
			runtime.semrelease(gs);
			return;
		}
		runtime.gcMarkWorkAvailable(gs, 0x00);
		if ((byte) (word32) bLoc10 != 0x00)
			goto l0805BF6F;
		word32 ebp_322;
		word32 ebx_321;
		runtime/internal/atomic.Xaddint64(0x08157898, 0x01, ~0x00, out ebx_321, out ebp_322);
		word32 ebp_72;
		word32 ebx_323;
		runtime/internal/atomic.Xaddint64(0x081578F8, 0x01, ~0x00, out ebx_323, out ebp_72);
		bLoc10 = ~0x00;
		if ((byte) (word32) g_b815756D != 0x00)
		{
			runtime.nanotime();
			g_t8145684 = dwLoc1C;
			g_t8145688.u0 = 0x081578F8;
			g_t814569C = dwLoc1C;
			g_t81456A0.u0 = 0x081578F8;
			Eq_4 eax_103 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
			((word32) eax_103 + 116)->u0 = 0x05;
			if (g_t81576F0 == 0x00)
				((word32) eax_103 + 112)->u0 = 135139389;
			else
				runtime.writebarrierptr((word32) eax_103 + 112, 135139389);
			word32 ebp_329;
			word32 edi_330;
			runtime.systemstack(gs, 0x080E7CDC, out ebp_329, out edi_330);
			g_b8145628 = 0x01;
			runtime/internal/atomic.Store(135624156, 0x00);
			runtime.gcWakeAllAssists(gs);
			runtime.semrelease(gs);
			runtime.(*gcControllerState).endCycle(ebp_72, gs, &g_dw8157860);
			runtime.gcMarkTermination(gs, (real64) (uint128) (uint64) 4294967296.0);
			return;
		}
		g_b815756D = 0x01;
		runtime/internal/atomic.Xadd(0x08145604, ~0x00);
		runtime.semrelease(gs);
		word32 ebp_324;
		word32 edi_325;
		runtime.systemstack(gs, 0x080E7C04, out ebp_324, out edi_325);
		runtime.gcMarkRootCheck(gs);
		word32 ebx_326;
		word32 ebp_327;
		runtime/internal/atomic.Xaddint64(0x08157898, ~0x00, 0x00, out ebx_326, out ebp_327);
		word32 ebp_201;
		word32 ebx_328;
		runtime/internal/atomic.Xaddint64(0x081578F8, ~0x00, 0x00, out ebx_328, out ebp_201);
		runtime/internal/atomic.Xadd(0x08145604, 0x01);
		dwLoc1C.u0 = ~0x00;
		if (g_t81455F8 != ~0x00)
			return;
		runtime.gcMarkWorkAvailable(gs, 0x00);
	} while (0x01 == 0x00);
}

// 0805BF90: void runtime.gcMarkTermination(Register (ptr32 Eq_2) gs, Stack real64 rArg04)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkDone
void runtime.gcMarkTermination(struct Eq_2 * gs, real64 rArg04)
{
	while (fp - 0x0130 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Store(135624156, 0x00);
	g_b815756D = 0x00;
	runtime.setGCPhase(0x02);
	Eq_4 eax_32 = g_t81597B4;
	g_t81456AC = g_t81597B0;
	g_t81456B0 = eax_32;
	runtime.nanotime();
	Eq_4 eax_49 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_50 = *((word32) eax_49 + 24);
	*((word32) ecx_50 + 0x0078) = (word32) *((word32) ecx_50 + 0x0078) + 1;
	Eq_4 ecx_54 = *((word32) eax_49 + 24);
	((word32) ecx_54 + 116)->u0 = 0x05;
	Eq_4 dwLoc28_1230 = ecx_54;
	if (g_t81576F0 == 0x00)
		((word32) ecx_54 + 112)->u0 = 135139389;
	else
		runtime.writebarrierptr((word32) ecx_54 + 112, 135139389);
	Eq_4 eax_77 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_77 + 24) + 461) = 0x02;
	Eq_4 ecx_83 = *((word32) *((word32) eax_77 + 24) + 84);
	runtime.casgstatus(ecx_83, 0x02, 0x04);
	((word32) ecx_83 + 100)->u0 = 0x12;
	if (g_t81576F0 == 0x00)
		((word32) ecx_83 + 96)->u0 = 0x080E29E2;
	else
		runtime.writebarrierptr((word32) ecx_83 + 96, 0x080E29E2);
	word32 edi_1673;
	word32 ebp_1672;
	runtime.systemstack(gs, fp - 0x08, out ebp_1672, out edi_1673);
	word32 edi_1675;
	word32 ebp_1674;
	runtime.systemstack(gs, fp - 0x10, out ebp_1674, out edi_1675);
	*((word32) *((word32) eax_77 + 24) + 461) = 0x00;
	runtime.casgstatus(ecx_83, 0x04, 0x02);
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGCDone(gs);
	((word32) ecx_54 + 116)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) ecx_54 + 112)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) ecx_54 + 112, 0x00);
	if (g_dw81575E4 != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_661 xmm0_183 = (uint128) (uint64) rArg04;
		Eq_4 rLoc01B0_1268 = (real64) xmm0_183;
		runtime.gcSetTriggerRatio(esi, edi, gs, xmm0_183, xmm2, rLoc01B0_1268);
		runtime.nanotime();
		time.now(gs);
		uint32 dwLoc01B0_1271 = (word32) rLoc01B0_1268;
		Eq_23665 ebp_216 = g_t814569C;
		uint32 esi_219 = dwLoc01B0_1271 - ebp_216;
		Eq_23650 ebx_221 = g_t8145694;
		ui32 edx_225 = g_dw8145698;
		Eq_4 ecx_226 = g_t81456A0;
		g_t8145694 = (word32) ebx_221.u1 + esi_219;
		g_dw8145698 = SLICE(SEQ(SLICE(rLoc01B0_1268 - SEQ(ecx_226, ebp_216), word32, 32), esi_219) + SEQ(edx_225, ebx_221), word32, 32);
		g_dw814568C = dwLoc01B0_1271;
		int32 dwLoc01AC_1269 = SLICE(rLoc01B0_1268, word32, 32);
		g_dw8145690 = dwLoc01AC_1269;
		uint32 eax_210 = (word32) (dwLoc01B0_1271 * 1000000000);
		word32 ecx_257 = SLICE(SEQ(dwLoc01AC_1269 *s 1000000000 + SLICE(dwLoc01B0_1271 * 1000000000, word32, 32), eax_210) + 2, word32, 32);
		runtime/internal/atomic.Store64(dwLoc01B4, 0x08158230, SEQ(ecx_257, eax_210 + 0x02));
		runtime/internal/atomic.Store64(dwLoc01B4, 0x08159790, rLoc01B0_1268);
		struct Eq_24190 * eax_282 = (g_t8159240 & 0xFF) * 0x08 + 0x08158240;
		ui32 ecx_283 = g_dw8145698;
		eax_282->t0000 = g_t8145694;
		eax_282->dw0004 = ecx_283;
		struct Eq_24210 * eax_290 = (g_t8159240 & 0xFF) * 0x08 + 0x08158A40;
		eax_290->dw0000 = eax_210 + 0x02;
		eax_290->dw0004 = ecx_257;
		ui64 eax_ecx_1188 = SEQ(g_dw815823C, g_t8145694) + SEQ(g_dw8145698, g_dw8158238);
		g_dw8158238 = (word32) eax_ecx_1188;
		g_dw815823C = SLICE(eax_ecx_1188, word32, 32);
		Eq_23698 eax_305 = g_t814567C;
		Eq_23660 ecx_306 = g_t8145674;
		uint32 edx_329 = g_dw814568C;
		Eq_23665 ecx_331 = g_t8145684;
		Eq_24256 eax_309 = eax_305 - ecx_306;
		Eq_23636 ebx_310 = g_t814566C;
		uint32 edi_319 = g_dw8157870;
		uint32 edx_321 = g_dw8157878;
		Eq_24267 edx_333 = edx_329 - ecx_331;
		uint64 edx_eax_314 = ebx_310 * eax_309;
		uint32 edx_323 = edx_321 + edi_319;
		uint32 edi_325 = g_dw8157880;
		uint64 edx_eax_336 = ebx_310 * edx_333;
		uint32 eax_317 = (word32) edx_eax_314;
		uint32 edi_327 = edi_325 + edx_323;
		uint32 eax_339 = (word32) edx_eax_336;
		uint32 edi_342 = edi_327 + eax_317;
		uint32 edi_344 = edi_342 + eax_339;
		Eq_4 eax_346 = g_t8145644;
		Eq_4 eax_348 = (word32) eax_346 + edi_344;
		Eq_4 edi_350 = g_t8145680;
		Eq_4 edx_351 = g_t8145678;
		ui32 ecx_352 = g_dw8157874;
		ui32 ecx_354 = g_dw815787C;
		ui32 ecx_356 = g_dw8157884;
		int32 ecx_358 = g_dw8145690;
		Eq_4 ecx_360 = g_t8145688;
		ui32 ecx_362 = g_dw8145648;
		g_t8145644 = eax_348;
		g_dw8145648 = SLICE(SEQ(ecx_362, eax_346) + SEQ(SLICE(SEQ(SLICE(SEQ(SLICE(SEQ(SLICE(SEQ(ecx_352, edx_321) + SEQ(ecx_354, edi_319), word32, 32), edi_325) + SEQ(ecx_356, edx_323), word32, 32), edi_327) + SEQ((SLICE(edx_eax_314, word32, 32) + SLICE(SEQ(edi_350, eax_305) - SEQ(edx_351, ecx_306), word32, 32) *s ebx_310) + eax_309 *s (ebx_310 >> 0x1F), eax_317), word32, 32), edi_342) + SEQ((SLICE(edx_eax_336, word32, 32) + SLICE(SEQ(ecx_358, edx_329) - SEQ(ecx_360, ecx_331), word32, 32) *s ebx_310) + edx_333 *s (ebx_310 >> 0x1F), eax_339), word32, 32), edi_344), word32, 32);
		uint32 ebx_429 = dwLoc01B0_1271 - g_t8145478;
		Eq_4 eax_441 = (word32) (g_t81575F0 * ebx_429) + g_dw8145480;
		runtime.int64tofloat64(SLICE(ebx_429, word24, 8), gs, eax_348);
		runtime.int64tofloat64(ebx, gs, eax_441);
		real64 rLoc01A8_1338 = SEQ(dwLoc01A4, dwLoc01AC_1269);
		g_r8159248 = (real64) (uint128) (uint64) (real64) (uint128) (uint64) rLoc01A8_1338 / (real64) ((uint128) ((uint64) rLoc01A8_1338));
		g_dw81451EC = 0x00;
		g_dw81451F0 = 0x00;
		if ((byte) (word32) g_t8145640 != 0x00)
			++g_dw8159244;
		word32 ebp_1662;
		word32 esi_1663;
		word32 edi_1664;
		runtime.lock(esi, gs, 135550560, out ebp_1662, out esi_1663, out edi_1664);
		g_t8159240 = (word32) g_t8159240 + 1;
		runtime.injectglist(gs, g_t8145664);
		g_t8145664.u0 = 0x00;
		word32 ebx_1666;
		word32 edx_1665;
		runtime.unlock(gs, 135550560, out edx_1665, out ebx_1666);
		runtime.mProf_NextCycle(gs);
		word32 ebp_1667;
		word32 edi_1668;
		runtime.systemstack(gs, 135167188, out ebp_1667, out edi_1668);
		runtime.mProf_Flush(gs);
		runtime.prepareFreeWorkbufs(gs);
		word32 ebp_1669;
		word32 edi_1670;
		runtime.systemstack(gs, 135166964, out ebp_1669, out edi_1670);
		if (g_dw8157740 > 0x00)
		{
			word32 dwLocE8_1411 = (word32) (real64) (uint128) (uint64) g_r8159248;
			fn0808FD8A(0x00, fp - 0xE0);
			runtime.printlock(gs);
			ui64 edx_ecx_1218 = SEQ(g_t8145678, g_t8145674) - SEQ(g_t81576A4, g_dw81576A0);
			runtime.uint64div(gs, (word32) edx_ecx_1218, SLICE(edx_ecx_1218, word32, 32), 1000000, 0x00);
			runtime.itoaDiv(esi, edi, gs, fp - 228, (Eq_26570 (*)[]) 0x18, dwLoc01A4, dwLoc01A0, 0x03);
			Eq_4 ecx_599 = g_t8159240;
			runtime.slicebytetostring(gs, fp - 116, dwLoc019C, dwLoc0198);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx, gs, ecx_599);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printint(ebx, gs, (int32) ((real64) (uint128) (uint64) SEQ(dwLocE8_1411, 0x00) * (real64) ((uint128) ((uint64) g_r80F1880))));
			runtime.printstring(gs);
			runtime.printunlock(gs);
			Eq_23660 edx_684 = g_t8145674;
			fn0808FD8A(0x00, fp - 0xCC);
			Eq_4 dwLoc01A8_1393 = dwLoc0194;
			int32 ecx_1166;
			struct Eq_24598 * ebx_1078 = fp - 0xD0;
			int64 ebp_edx_1655 = SEQ(dwLoc01AC_1269, edx_684);
			for (ecx_1166 = 0x00; ecx_1166 < 0x03; ++ecx_1166)
			{
				Eq_4 esi_1080 = ebx_1078->dw0004;
				uint32 edi_1082 = ebx_1078->dw0000;
				if (ecx_1166 != 0x00)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
				}
				ui64 esi_edi_1224 = SEQ(esi_1080, edi_1082) - ebp_edx_1655;
				Eq_4 esi_1123 = SLICE(esi_edi_1224, word32, 32);
				runtime.fmtNSAsMS(ebx, esi_1080, gs, fp - 232, (Eq_26570 (*)[]) 0x18, (word32) esi_edi_1224, esi_1123);
				runtime.slicebytetostring(gs, fp - 0x98, dwLoc01A0, 0x03);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				dwLoc01A8_1393 = esi_1123;
				++ebx_1078;
				ebp_edx_1655 = SEQ(esi_1080, edi_1082);
			}
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			fn0808FD86(0x00, fp - 88);
			int32 eax_1075;
			Eq_4 ecx_1073 = fp - 0x5C;
			for (eax_1075 = 0x00; eax_1075 < 0x05; ++eax_1075)
			{
				dwLoc28_1230 = ecx_1073;
				Eq_4 edx_979 = *((word32) ecx_1073 + 4);
				Eq_24647 ebx_981 = *ecx_1073;
				if (eax_1075 == 0x02 || eax_1075 == 0x03)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
				}
				else if (eax_1075 != 0x00)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
				}
				runtime.fmtNSAsMS(ebx, ebp, gs, fp - 0xEC, (Eq_26570 (*)[]) 0x18, ebx_981, edx_979);
				runtime.slicebytetostring(gs, fp - 188, dwLoc01A8_1393, dwLoc01A0);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				ecx_1073 = (word32) ecx_1073 + 8;
			}
			Eq_4 eax_768 = g_t81456A8;
			Eq_4 ecx_771 = g_t81456A4;
			Eq_4 edx_773 = g_t81456B0;
			Eq_4 ebx_775 = g_t81456AC;
			Eq_4 ebp_777 = g_t81456B8;
			Eq_4 esi_779 = g_t81456B4;
			Eq_4 edi_781 = g_t81456C0;
			Eq_4 edi_783 = g_t81456BC;
			Eq_4 edi_785 = g_t8145670;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, eax_768 << 0x0C | ecx_771 >> 0x14, eax_768 >> 0x14);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, edx_773 << 0x0C | ebx_775 >> 0x14, edx_773 >> 0x14);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, ebp_777 << 0x0C | esi_779 >> 0x14, ebp_777 >> 0x14);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, edi_781 << 0x0C | edi_783 >> 0x14, edi_781 >> 0x14);
			runtime.printstring(gs);
			runtime.printint(ebx, gs, edi_785);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			if ((byte) (word32) g_t8145640 != 0x00)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
			}
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.printunlock(gs);
		}
		runtime.semrelease(gs);
		Eq_4 eax_960 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_962 = *((word32) dwLoc28_1230 + 0x0078);
		*((word32) dwLoc28_1230 + 0x0078) = edx_962 - 0x01;
		if (edx_962 == 0x01 && (byte) ((word32) (*((word32) eax_960 + 0x006C))) != 0x00)
			((word32) eax_960 + 8)->u0 = ~0x0521;
	}
}

// 0805CE70: void runtime.gcBgMarkStartWorkers(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
void runtime.gcBgMarkStartWorkers(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	word32 * ecx_20 = g_a81478C0;
	for (eax_17 = 0x00; eax_17 < 0x0401; ++eax_17)
	{
		Eq_4 edx_26 = *ecx_20;
		if (edx_26 == 0x00 || *((word32) edx_26 + 8) == 0x04)
			return;
		if (*((word32) edx_26 + 0x0948) == 0x00)
		{
			runtime.newproc();
			runtime.notetsleepg(gs);
			g_dw8145634 = 0x00;
		}
		++ecx_20;
	}
}

// 0805CF20: void runtime.gcBgMarkWorker(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_24947) dwArg04)
void runtime.gcBgMarkWorker(struct Eq_2 * gs, struct Eq_24947 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = *((word32) eax_18 + 24);
	((word32) ecx_20 + 116)->u0 = 0x0E;
	if (g_t81576F0 == 0x00)
		((word32) ecx_20 + 112)->u0 = 0x080E207E;
	else
	{
		runtime.writebarrierptr((word32) ecx_20 + 112, 0x080E207E);
		dwLoc44 = &g_t80E207E;
	}
	runtime.newobject(gs, 0x080D3CE0);
	Eq_4 ecx_52 = *((word32) eax_18 + 24);
	((word32) ecx_52 + 116)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) ecx_52 + 112)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) ecx_52 + 112, 0x00);
	Eq_4 eax_76 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_77 = *((word32) eax_76 + 24);
	*((word32) ecx_77 + 0x0078) = (word32) *((word32) ecx_77 + 0x0078) + 1;
	dwLoc44->t0000 = *((word32) eax_76 + 24);
	dwLoc44->ptr0004 = dwArg04;
	runtime.notewakeup(gs, 135550516);
	while (true)
	{
		runtime.gopark(gs);
		if (dwArg04->t0948 != eax_18)
			break;
		Eq_4 ecx_135 = gs->ptr0000->tFFFFFFFC;
		Eq_4 ebp_136 = *((word32) ecx_135 + 24);
		*((word32) ebp_136 + 0x0078) = (word32) *((word32) ebp_136 + 0x0078) + 1;
		dwLoc44->t0000 = *((word32) ecx_135 + 24);
		if (g_dw81575DC == 0x00)
			runtime.throw(gs);
		runtime.nanotime();
		Eq_363 ebx_24_8_210 = SLICE(runtime/internal/atomic.Xadd(0x08145604, ~0x00), word24, 8);
		Eq_4 ecx_180 = g_t81455F8;
		if (ecx_180 == 0x080E2499)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8_210, gs, 0x080E2499);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8_210, gs, (uint64) (uint32) ecx_180);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		Eq_4 ebp_285;
		word32 edi_691;
		Eq_363 ebx_24_8_299 = SLICE(runtime.systemstack(gs, fp - 0x0C, out ebp_285, out edi_691), word24, 8);
		Eq_4 esp_286 = <invalid>;
		if ((byte) (word32) g_b815756D != 0x00)
		{
			*esp_286 = (word32) *((word32) esp_286 + 76) + 0x0950;
			runtime.(*gcWork).dispose(ebx_24_8_299, ebp_285, gs, *((word32) esp_286 - 4), *esp_286);
		}
		runtime.nanotime();
		ui64 ecx_eax_614 = SEQ(ecx_323, *esp_286) - SEQ(edx_324, *((word32) esp_286 + 24));
		Eq_4 eax_321 = (word32) ecx_eax_614;
		Eq_4 ecx_326 = SLICE(ecx_eax_614, word32, 32);
		Eq_4 ecx_323 = *((word32) esp_286 + 4);
		Eq_4 edx_324 = *((word32) esp_286 + 28);
		Eq_4 ebx_328 = *((word32) *((word32) esp_286 + 76) + 0x094C);
		if (ebx_328 != 0x00)
		{
			if (ebx_328 != 0x01)
			{
				if (ebx_328 == 0x02)
				{
					esp_286->u0 = 0x08157888;
					*((word32) esp_286 + 4) = eax_321;
					*((word32) esp_286 + 8) = ecx_326;
					word32 ebp_397;
					word32 ebx_698;
					runtime/internal/atomic.Xaddint64(*esp_286, *((word32) esp_286 + 4), *((word32) esp_286 + 8), out ebx_698, out ebp_397);
					esp_286 = (word32) esp_286 - 4;
				}
			}
			else
			{
				esp_286->u0 = 0x08157880;
				*((word32) esp_286 + 4) = eax_321;
				*((word32) esp_286 + 8) = ecx_326;
				word32 ebp_696;
				word32 ebx_695;
				runtime/internal/atomic.Xaddint64(*esp_286, *((word32) esp_286 + 4), *((word32) esp_286 + 8), out ebx_695, out ebp_696);
				((word32) esp_286 - 4)->u0 = 0x081578F8;
				esp_286->u0 = 0x01;
				((word32) esp_286 + 4)->u0 = 0x00;
				word32 ebp_381;
				word32 ebx_697;
				runtime/internal/atomic.Xaddint64(*((word32) esp_286 - 4), *esp_286, *((word32) esp_286 + 4), out ebx_697, out ebp_381);
				esp_286 = (word32) esp_286 - 8;
			}
		}
		else
		{
			esp_286->u0 = 0x08157878;
			*((word32) esp_286 + 4) = eax_321;
			*((word32) esp_286 + 8) = ecx_326;
			word32 ebp_693;
			word32 ebx_692;
			runtime/internal/atomic.Xaddint64(*esp_286, *((word32) esp_286 + 4), *((word32) esp_286 + 8), out ebx_692, out ebp_693);
			((word32) esp_286 - 4)->u0 = 0x08157898;
			esp_286->u0 = 0x01;
			((word32) esp_286 + 4)->u0 = 0x00;
			word32 ebp_351;
			word32 ebx_694;
			runtime/internal/atomic.Xaddint64(*((word32) esp_286 - 4), *esp_286, *((word32) esp_286 + 4), out ebx_694, out ebp_351);
			esp_286 = (word32) esp_286 - 8;
		}
		*esp_286 = 0x08145604;
		((word32) esp_286 + 4)->u0 = 0x01;
		Eq_363 ebx_24_8_455 = SLICE(runtime/internal/atomic.Xadd(*esp_286, *((word32) esp_286 + 4)), word24, 8);
		Eq_4 eax_417 = *((word32) esp_286 + 8);
		Eq_4 ecx_418 = g_t81455F8;
		if (eax_417 > ecx_418)
		{
			*((word32) esp_286 + 32) = eax_417;
			*((word32) esp_286 + 44) = ecx_418;
			*((word32) esp_286 + 40) = *((word32) *((word32) esp_286 + 76) + 0x094C);
			runtime.printlock(gs);
			*esp_286 = 0x080E49C8;
			((word32) esp_286 + 4)->u0 = 0x1C;
			runtime.printstring(gs);
			runtime.printsp(gs);
			Eq_4 eax_450 = *((word32) esp_286 + 40);
			*esp_286 = eax_450;
			*((word32) esp_286 + 4) = eax_450 >> 0x1F;
			runtime.printint(ebx_24_8_455, gs, *esp_286);
			runtime.printsp(gs);
			*esp_286 = 0x080E1BF8;
			((word32) esp_286 + 4)->u0 = 11;
			runtime.printstring(gs);
			runtime.printsp(gs);
			*esp_286 = *((word32) esp_286 + 32);
			((word32) esp_286 + 4)->u0 = 0x00;
			runtime.printint(ebx_24_8_455, gs, *esp_286);
			runtime.printsp(gs);
			*esp_286 = 0x080E1BED;
			((word32) esp_286 + 4)->u0 = 11;
			runtime.printstring(gs);
			runtime.printsp(gs);
			*esp_286 = *((word32) esp_286 + 44);
			((word32) esp_286 + 4)->u0 = 0x00;
			runtime.printint(ebx_24_8_455, gs, *esp_286);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			*esp_286 = 135150409;
			((word32) esp_286 + 4)->u0 = 0x17;
			runtime.throw(gs);
		}
		if (eax_417 == ecx_418)
		{
			*esp_286 = 0x00;
			runtime.gcMarkWorkAvailable(gs, *esp_286);
			if ((byte) (word32) *((word32) esp_286 + 4) == 0x00)
			{
				((word32) *((word32) esp_286 + 76) + 0x0948)->u0 = 0x00;
				Eq_4 ebx_570 = **((word32) esp_286 + 48);
				Eq_4 ebp_572 = gs->ptr0000->tFFFFFFFC;
				Eq_4 esi_573 = *((word32) ebx_570 + 0x0078);
				*((word32) ebx_570 + 0x0078) = esi_573 - 0x01;
				if (esi_573 == 0x01 && (byte) ((word32) (*((word32) ebp_572 + 0x006C))) != 0x00)
					((word32) ebp_572 + 8)->u0 = ~0x0521;
				runtime.gcMarkDone(gs);
				Eq_4 eax_597 = gs->ptr0000->tFFFFFFFC;
				Eq_4 ecx_598 = *((word32) eax_597 + 24);
				*((word32) ecx_598 + 0x0078) = (word32) *((word32) ecx_598 + 0x0078) + 1;
				Eq_4 ecx_605 = *((word32) esp_286 + 48);
				*ecx_605 = *((word32) eax_597 + 24);
				*((word32) ecx_605 + 4) = *((word32) esp_286 + 76);
			}
		}
	}
}

// 0805D440: void runtime.gcMarkWorkAvailable(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcMarkDone
//      runtime.gcBgMarkWorker
//      runtime.gcAssistAlloc1
//      runtime.handoffp
//      runtime.findrunnable
void runtime.gcMarkWorkAvailable(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 != 0x00)
	{
		uip32 eax_124;
		struct Eq_25591 * ecx_23 = *((word32) dwArg04 + 0x0950);
		if (ecx_23 != null)
		{
			if (ecx_23->dw000C == 0x00)
			{
				word32 eax_36 = *((word32) *((word32) dwArg04 + 2388) + 0x0C);
				eax_124 = SEQ(SLICE(eax_36, word24, 8), eax_36 == 0x00);
			}
			else
				eax_124 = 0x00;
		}
		else
			eax_124 = 0x01;
		if ((byte) eax_124 == 0x00)
			return;
	}
	runtime.(*lfstack).empty(gs, 135550336);
	if ((byte) (word32) bLoc04 == 0x00)
		return;
	if (g_t81455F0 >= g_t81455F4)
		;
}

// 0805D4F0: Register Eq_4 runtime.gcMark(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gcMarkTermination.func1
//      runtime.gcMarkTermination.func2
Eq_4 runtime.gcMark(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw8157720 > 0x00)
		esi = runtime.tracegc(esi, gs);
	if (g_dw81575E4 != 0x02)
		runtime.throw(gs);
	else
	{
		g_t81455FC = dwArg04;
		g_t8145600 = dwArg08;
		runtime.gcMarkRootPrepare(gs);
		g_t8145604.u0 = 0x00;
		g_dw8145608 = 0x00;
		runtime.gcprocs(gs);
		g_t81455F8 = dwLoc0C;
		word32 eax_71 = g_dw8145580;
		word32 ecx_72 = g_dw8145584;
		if ((byte) (SEQ(SLICE(ecx_72, word24, 8), ecx_72 == 0x00) & SEQ(SLICE(eax_71, word24, 8), eax_71 == 0x00)) != 0x00 && ((Mem70[0x08145618<p32>:word32] + Mem70[0x0814561C<p32>:word32]) + Mem70[0x08145620<p32>:word32]) + Mem70[0x08145624<p32>:word32] == 0x00)
			g_b8145610 = 0x00;
		else
			g_b8145610 = 0x01;
		if ((byte) (word32) g_b814F4C8 != 0x00)
			runtime.traceGCScanStart(gs);
		if (g_t81455F8 > 0x01)
		{
			g_dw814560C = 0x00;
			runtime.helpgc(esi, gs, g_t81455F8);
		}
		Eq_4 esi_177;
		Eq_363 ebx_24_8_202;
		Eq_4 ebp_172;
		runtime.gchelperstart(gs);
		Eq_4 ecx_157 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		if ((byte) (word32) g_b8145610 != 0x00)
			ebx_24_8_202 = SLICE(runtime.gcDrain(gs, (word32) ecx_157 + 0x0950, 0x00, out ebp_172, out esi_177), word24, 8);
		else
			ebx_24_8_202 = SLICE(runtime.gcDrain(gs, (word32) ecx_157 + 0x0950, 0x02, out ebp_172, out esi_177), word24, 8);
		runtime.(*gcWork).dispose(ebx_24_8_202, ebp_172, gs, dwLoc10, (word32) ecx_157 + 0x0950);
		if (g_dw815772C > 0x00)
			runtime.gcMarkRootCheck(gs);
		word32 eax_227 = g_dw8145580;
		word32 ecx_228 = g_dw8145584;
		if ((byte) (SEQ(SLICE(ecx_228, word24, 8), ecx_228 != 0x00) | SEQ(SLICE(eax_227, word24, 8), eax_227 != 0x00)) != 0x00)
			runtime.throw(gs);
		else
		{
			if (g_t81455F8 > 0x01)
				runtime.notesleep(esi_177, gs, dwLoc10, 135550476);
			g_b8145628 = 0x01;
			Eq_4 eax_270 = 0x00;
			while (eax_270 < g_t81575F0)
			{
				if (eax_270 >= 0x0401)
					runtime.panicindex(gs);
				Eq_25822 bl_357;
				struct Eq_25823 * edx_336 = *((char *) g_a81478C0 + eax_270 * 0x04);
				struct Eq_25828 * ebx_340 = edx_336->ptr0950;
				if (ebx_340 != null)
				{
					if (ebx_340->dw000C == 0x00)
						bl_357 = edx_336->ptr0954->dw000C == 0x00;
					else
						bl_357.u0 = 0x00;
				}
				else
					bl_357.u0 = 0x01;
				if (bl_357 == 0x00)
					runtime.throw(gs);
				word32 ebp_378 = edx_336->dw0964;
				word32 ebx_377 = edx_336->dw0960;
				if ((byte) (SEQ(SLICE(ebx_377, word24, 8), ebx_377 != 0x00) | SEQ(SLICE(ebp_378, word24, 8), ebp_378 != 0x00)) != 0x00)
				{
l0805D7F7:
					runtime.throw(gs);
				}
				word32 ebx_400 = edx_336->dw095C;
				word32 edx_401 = edx_336->dw0958;
				if ((byte) (SEQ(SLICE(edx_401, word24, 8), edx_401 != 0x00) | SEQ(SLICE(ebx_400, word24, 8), ebx_400 != 0x00)) != 0x00)
					goto l0805D7F7;
				eax_270 = (word32) eax_270 + 1;
			}
			if ((byte) (word32) g_b814F4C8 != 0x00)
				runtime.traceGCScanDone(gs);
			runtime.cachestats(gs);
			Eq_4 eax_299 = g_t81455EC;
			g_t81597C0 = g_t81455E8;
			g_t81597C4 = eax_299;
			Eq_4 eax_303 = g_t81455EC;
			g_t81597B0 = g_t81455E8;
			g_t81597B4 = eax_303;
			uint32 eax_307 = g_dw8157864;
			g_dw81597B8 = g_dw8157860;
			g_dw81597BC = eax_307;
			if ((byte) (word32) g_b814F4C8 != 0x00)
				runtime.traceHeapAlloc(gs, out esi_177);
			return esi_177;
		}
	}
}

// 0805D870: Register Eq_661 runtime.gcSweep(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm2, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkTermination.func2
Eq_661 runtime.gcSweep(Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm2, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw81575E4 != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 esi_40;
		word32 edi_295;
		word32 ebp_294;
		runtime.lock(esi, gs, 0x081488E0, out ebp_294, out esi_40, out edi_295);
		g_t81490F0 = (word32) g_t81490F0 + 2;
		g_t81490F4.u0 = 0x00;
		if (g_a8149124[g_t81490F0 >> 0x01 & 0x01] != 0x00)
			runtime.throw(gs);
		else
		{
			g_dw8149148 = 0x00;
			g_t814914C.u0 = 0x00;
			word32 edx_296;
			word32 ebx_297;
			runtime.unlock(gs, 0x081488E0, out edx_296, out ebx_297);
			if (dwArg04 != 0x02)
			{
				word32 edi_300;
				word32 esi_299;
				word32 ebp_298;
				runtime.lock(esi_40, gs, 0x081451E0, out ebp_298, out esi_299, out edi_300);
				if ((byte) (word32) g_b81451E8 != 0x00)
				{
					g_b81451E8 = 0x00;
					runtime.ready(gs, g_t81451E4);
				}
				word32 edx_307;
				word32 ebx_308;
				runtime.unlock(gs, 0x081451E0, out edx_307, out ebx_308);
				return xmm2;
			}
			else
			{
				word32 ebp_301;
				word32 esi_302;
				word32 edi_303;
				runtime.lock(esi_40, gs, 0x081488E0, out ebp_301, out esi_302, out edi_303);
				g_r8149160 = (real64) __xorps(xmm0, xmm0);
				word32 edx_304;
				word32 ebx_305;
				runtime.unlock(gs, 0x081488E0, out edx_304, out ebx_305);
				while (true)
				{
					word128 xmm0_306;
					Eq_4 esi_173 = runtime.sweepone(gs, xmm2, dwLoc10, out xmm0_306, out xmm2);
					if (false)
						break;
					++g_dw81451F0;
				}
				runtime.prepareFreeWorkbufs(gs);
				do
					esi_173 = runtime.freeSomeWbufs(esi_173, gs);
				while ((byte) (word32) bLoc08 != 0x00);
				runtime.mProf_NextCycle(gs);
				runtime.mProf_Flush(gs);
				return xmm2;
			}
		}
	}
}

// 0805DA00: void runtime.gcResetMarkState(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkTermination.func2
void runtime.gcResetMarkState(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_86;
	word32 esi_87;
	word32 edi_88;
	runtime.lock(esi, gs, 0x08157590, out ebp_86, out esi_87, out edi_88);
	Eq_4 eax_24 = g_t8145108;
	Eq_4 ecx_25 = g_t814510C;
	Eq_4 edx_26 = 0x00;
	while (edx_26 < ecx_25)
	{
		struct Eq_26144 * ebx_35 = *eax_24;
		ebx_35->w006F = 0x00;
		ebx_35->dw00CC = 0x00;
		ebx_35->dw00D0 = 0x00;
		eax_24 = (word32) eax_24 + 4;
		edx_26 = (word32) edx_26 + 1;
	}
	word32 edx_89;
	word32 ebx_90;
	runtime.unlock(gs, 0x08157590, out edx_89, out ebx_90);
	g_t81455E8.u0 = 0x00;
	g_t81455EC.u0 = 0x00;
	word64 mm0_91;
	runtime/internal/atomic.Load64(135632816, out mm0_91);
	g_t814564C = dwLoc08;
	g_t8145650 = dwLoc04;
	g_b8145628 = 0x00;
}

// 0805DAC0: void sync.runtime_registerPoolCleanup(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.init.0
void sync.runtime_registerPoolCleanup(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t81576F0 == 0x00)
		g_t8144FE0 = dwArg04;
	else
		runtime.writebarrierptr(0x08144FE0, dwArg04);
}

// 0805DB10: void runtime.clearpools(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
void runtime.clearpools(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_17 = g_t8144FE0;
	if (edx_17 != 0x00)
		(*edx_17)();
	word32 edi_240;
	word32 ebp_238;
	word32 esi_239;
	runtime.lock(esi, gs, 135550004, out ebp_238, out esi_239, out edi_240);
	Eq_4 eax_155 = g_t8145438;
	while (eax_155 != 0x00)
	{
		Eq_4 ecx_139 = *((word32) eax_155 + 8);
		Eq_4 edx_140 = (word32) eax_155 + 8;
		if (g_t81576F0 == 0x00)
			((word32) eax_155 + 8)->u0 = 0x00;
		else
			runtime.writebarrierptr(edx_140, 0x00);
		eax_155 = ecx_139;
	}
	if (g_t81576F0 == 0x00)
		g_t8145438.u0 = 0x00;
	else
		runtime.writebarrierptr(135550008, 0x00);
	word32 edx_243;
	word32 ebx_244;
	runtime.unlock(gs, 135550004, out edx_243, out ebx_244);
	word32 edi_247;
	word32 ebp_245;
	word32 esi_246;
	runtime.lock(esi, gs, 135550012, out ebp_245, out esi_246, out edi_247);
	Eq_26278 eax_117 = 0x00;
	while (eax_117 < 0x05)
	{
		if (eax_117 >= 0x05)
			runtime.panicindex(gs);
		word32 ecx_113[] = g_a8145440;
		struct Eq_26293 * edx_138 = g_a8145440[eax_117 * 0x04];
		Eq_4 ebx_92 = eax_117 * 0x04 + 0x08145440;
		ebx_103 = ebx_92;
		eax_112 = eax_117;
		while (true)
		{
			Eq_26278 eax_112;
			Eq_4 ebx_103;
			if (edx_138 == null)
				break;
			struct Eq_26293 * ebp_119 = edx_138->ptr0018;
			Eq_4 esi_120 = &edx_138->ptr0018;
			if (g_t81576F0 == 0x00)
				edx_138->ptr0018 = null;
			else
			{
				runtime.writebarrierptr(esi_120, 0x00);
				eax_112 = eax_117;
				ecx_113 = g_a8145440;
				ebx_103 = ebx_92;
			}
			edx_138 = ebp_119;
		}
		if (g_t81576F0 == 0x00)
			ecx_113[eax_112] = 0x00;
		else
		{
			runtime.writebarrierptr(ebx_103, 0x00);
			eax_112 = eax_117;
		}
		eax_117 = (word32) eax_112 + 1;
	}
	word32 edx_241;
	word32 ebx_242;
	runtime.unlock(gs, 135550012, out edx_241, out ebx_242);
}

// 0805DCA0: void runtime.gchelper(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.stopm
void runtime.gchelper(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_19 + 24) + 461) = 0x02;
	runtime.gchelperstart(gs);
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGCScanStart(gs);
	if (g_dw81575E4 == 0x02)
	{
		Eq_4 edx_43 = *((word32) *((word32) eax_19 + 24) + 92);
		if ((byte) (word32) g_b8145610 != 0x00)
		{
			word32 esi_178;
			word32 ebp_177;
			runtime.gcDrain(gs, (word32) edx_43 + 0x0950, 0x00, out ebp_177, out esi_178);
		}
		else
		{
			word32 ebp_175;
			word32 esi_176;
			runtime.gcDrain(gs, (word32) edx_43 + 0x0950, 0x02, out ebp_175, out esi_176);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.(*gcWork).dispose(ebx, ebp, gs, stackArg0, (word32) edx_43 + 0x0950);
	}
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGCScanDone(gs);
	runtime/internal/atomic.Load();
	runtime/internal/atomic.Xadd(0x08145608, 0x01);
	if (dwLoc10 - 0x01 == dwLoc0C)
		runtime.notewakeup(gs, 135550476);
	*((word32) *((word32) dwArg00 + 24) + 461) = 0x00;
}

// 0805DDD0: void runtime.gchelperstart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
//      runtime.gchelper
void runtime.gchelperstart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (*((word32) ecx_19 + 0x0088) >= 0x20)
		runtime.throw(gs);
	else
	{
		if (eax_18 == *ecx_19)
			return;
		runtime.throw(gs);
	}
}

// 0805DE50: void runtime.itoaDiv(Register Eq_4 esi, Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_24531 dwArg04, Stack (ptr32 (arr Eq_26570)) dwArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack word32 dwArg18)
// Called from:
//      runtime.gcMarkTermination
//      runtime.fmtNSAsMS
void runtime.itoaDiv(Eq_4 esi, ui32 edi, struct Eq_2 * gs, Eq_24531 dwArg04, Eq_26570 (* dwArg08)[], Eq_4 dwArg10, Eq_4 dwArg14, word32 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_26570 (* ebx_170)[] = dwArg08 - 0x01;
	Eq_26570 (* ecx_21)[] = dwArg08 - 0x01 - dwArg18;
	Eq_4 edx_166 = dwArg14;
	Eq_4 ebp_167 = dwArg10;
	while (true)
	{
		ui24 ebx_24_8_51 = SLICE(edi, word24, 8);
		esi = SEQ(SLICE(esi, word24, 8), edx_166 == 0x00) & SEQ(ebx_24_8_51, ebp_167 >= 0x0A);
		ui32 edi_69 = SEQ(ebx_24_8_51, edx_166 > 0x00) | esi;
		edi = edi_69;
		if ((byte) edi_69 == 0x00 && ebx_170 < ecx_21)
			break;
		runtime.uint64mod(gs, ebp_167, edx_166, 0x0A, 0x00);
		byte al_138 = (byte) ((word32) dwLoc10 + 48);
		if (ebx_170 >= dwArg08)
			runtime.panicindex(gs);
		Mem139[dwArg04 + ebx_170:byte] = al_138;
		Eq_26570 (* eax_140)[] = ebx_170 - (Eq_26570 (*)[]) 0x01;
		if (ebx_170 - (Eq_26570 (*)[]) 0x01 == ecx_21)
		{
			if (ebx_170 - (Eq_26570 (*)[]) 0x01 >= dwArg08)
				runtime.panicindex(gs);
			Mem150[ebx_170 - 0x01 + dwArg04:byte] = 0x2E;
			eax_140 = ebx_170 - (Eq_26570 (*)[]) 0x02;
		}
		runtime.uint64div(gs, ebp_167, edx_166, 0x0A, 0x00);
		edx_166 = dwLoc0C;
		ebp_167 = dwLoc10;
		ebx_170 = eax_140;
	}
	up32 ebp_84 = (word32) ebp_167 + 48;
	if (ebx_170 >= dwArg08)
		runtime.panicindex(gs);
	else
		Mem97[dwArg04 + ebx_170:byte] = SLICE(ebp_84, byte, 0);
}

// 0805DFA0: void runtime.fmtNSAsMS(Register Eq_363 ebx, Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_24531 dwArg04, Stack (ptr32 (arr Eq_26570)) dwArg08, Stack Eq_24647 fArg10, Stack Eq_4 fArg14)
// Called from:
//      runtime.gcMarkTermination
void runtime.fmtNSAsMS(Eq_363 ebx, Eq_4 ebp, struct Eq_2 * gs, Eq_24531 dwArg04, Eq_26570 (* dwArg08)[], Eq_24647 fArg10, Eq_4 fArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_28 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ui32 ebx_37 = SEQ(ebx_24_8, dwArg10 >= 10000000) & SEQ(ecx_24_8_28, dwArg14 == 0x00) | SEQ(ecx_24_8_28, dwArg14 > 0x00);
	ui24 ebx_24_8_46 = SLICE(ebx_37, word24, 8);
	if ((byte) ebx_37 != 0x00)
	{
		runtime.uint64div(gs, dwArg10, dwArg14, 1000000, 0x00);
		runtime.itoaDiv(esi, edi, gs, dwArg04, dwArg08, dwLoc18, dwLoc14, 0x00);
	}
	else if ((byte) (SEQ(SLICE(runtime.uint64div(gs, dwArg10, dwArg14, 1000, 0x00), word24, 8), dwLoc14 == 0x00) & SEQ(ebx_24_8_46, dwLoc18 == 0x00)) != 0x00)
	{
		if (dwArg08 <= null)
			runtime.panicindex(gs);
		else
			*dwArg04 = 0x30;
	}
	else
	{
		word32 edx_115 = 0x03;
		while (true)
		{
			Eq_4 ebp_143 = SEQ(SLICE(ebp, word24, 8), dwLoc18 >= 100) & SEQ(ebx_24_8_46, dwLoc14 == 0x00) | SEQ(ebx_24_8_46, dwLoc14 > 0x00);
			ebp = ebp_143;
			if ((byte) ebp_143 == 0x00)
				break;
			runtime.uint64div(gs, dwLoc18, dwLoc14, 0x0A, 0x00);
			--edx_115;
		}
		runtime.itoaDiv(esi, edi, gs, dwArg04, dwArg08, dwLoc18, dwLoc14, edx_115);
	}
}

// 0805E160: void runtime.(*mTreap).insert(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_26682) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).freeSpanLocked
void runtime.(*mTreap).insert(struct Eq_2 * gs, struct Eq_26682 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 16);
	struct Eq_26682 * edx_19 = dwArg04;
	struct Eq_26682 * ebx_20 = dwArg04->dw0000;
	struct Eq_26682 * esi_22 = null;
	while (ebx_20 != null)
	{
		struct Eq_26682 * ebx_269;
		Eq_4 edx_237 = ebx_20[3];
		if (edx_237 < ecx_18)
			ebx_269 = ebx_20;
		else
		{
			struct Eq_26682 * edx_263;
			if (edx_237 > ecx_18)
				edx_263 = ebx_20 + 1;
			else
			{
				struct Eq_26682 * ebx_257;
				Eq_4 edx_242 = ebx_20[4];
				if (edx_242 < dwArg08)
					ebx_257 = ebx_20;
				else
				{
					if (edx_242 <= dwArg08)
						runtime.throw(gs);
					ebx_257 = ebx_20 + 1;
				}
				edx_263 = ebx_257;
			}
			ebx_269 = edx_263;
		}
		esi_22 = ebx_20;
		edx_19 = ebx_269;
		ebx_20 = ebx_269->dw0000;
	}
	runtime.(*fixalloc).alloc(gs, &g_dw814B588);
	dwLoc18->dw0000 = null;
	dwLoc18[1] = (struct Eq_26682) null;
	dwLoc18[2] = (struct Eq_26682) null;
	dwLoc18[4] = (struct Eq_26682) 0x00;
	dwLoc18[3] = (struct Eq_26682) 0x00;
	dwLoc18[5] = (struct Eq_26682) 0x00;
	dwLoc18[3] = (struct Eq_26682) *((word32) dwArg08 + 16);
	Eq_4 edx_55 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_26733 ebx_56 = *((word32) edx_55 + 0x0094);
	Eq_26733 ebp_61 = ebx_56 << 0x01 ^ ebx_56 >> 0x1F & 0xA8888EEF;
	*((word32) edx_55 + 0x0094) = ebp_61;
	dwLoc18[5] = (struct Eq_26682) ebp_61;
	dwLoc18[4] = (struct Eq_26682) dwArg08;
	dwLoc18[2] = (struct Eq_26682) esi_22;
	edx_19->dw0000 = dwLoc18;
	while (true)
	{
		struct Eq_26682 * ecx_73 = dwLoc18[2];
		if (ecx_73 == null || ecx_73[5] <= dwLoc18[5])
			break;
		Eq_4 ebx_87 = dwLoc18[3];
		if (*dwLoc18[4].dw0010 != ebx_87)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printpointer(gs);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx, gs, ebx_87);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			Eq_4 ecx_146 = *dwLoc18[4].dw0010;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printpointer(gs);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx, gs, ecx_146);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		if (ecx_73[1] != dwLoc18)
		{
			if (ecx_73->dw0000 != dwLoc18)
				runtime.throw(gs);
			runtime.(*mTreap).rotateLeft(gs, dwArg04, ecx_73);
		}
		else
			runtime.(*mTreap).rotateRight(gs, dwArg04, ecx_73);
	}
}

// 0805E400: void runtime.(*mTreap).removeNode(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_26682) dwArg04, Stack (ptr32 Eq_26682) dwArg08)
// Called from:
//      runtime.(*mTreap).remove
//      runtime.(*mTreap).removeSpan
void runtime.(*mTreap).removeNode(struct Eq_2 * gs, struct Eq_26682 * dwArg04, struct Eq_26682 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg08[4].dw0010 != dwArg08[3])
		runtime.throw(gs);
l0805E43C:
	struct Eq_26682 * edx_33 = dwArg08->dw0000;
	bool Z_36 = SLICE(cond(edx_33), bool, 2);
	if (edx_33 == null)
	{
		if (dwArg08[1] == null)
		{
			struct Eq_26682 * edx_41 = dwArg08[2];
			if (edx_41 != null)
			{
				if (edx_41[1] == dwArg08)
					edx_41[1] = (struct Eq_26682) null;
				else
					edx_41->dw0000 = 0x00;
			}
			else
				dwArg04->dw0000 = 0x00;
			dwArg08[4] = (struct Eq_26682) null;
			dwArg08[3] = (struct Eq_26682) 0x00;
			g_dw814B5A0 -= g_dw814B588;
			dwArg08->dw0000 = g_ptr814B594;
			g_ptr814B594 = dwArg08;
			return;
		}
		Z_36 = SLICE(cond(edx_33), bool, 2);
	}
	if (!Z_36)
	{
		struct Eq_26682 * ebx_78 = dwArg08[1];
		if (ebx_78 == null || ebx_78[5] >= edx_33[5])
		{
			runtime.(*mTreap).rotateLeft(gs, dwArg04, dwArg08);
l0805E434:
			goto l0805E43C;
		}
	}
	runtime.(*mTreap).rotateRight(gs, dwArg04, dwArg08);
	goto l0805E434;
}

// 0805E510: void runtime.(*mTreap).remove(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_26682) dwArg04, Stack up32 dwArg08)
// Called from:
//      runtime.(*mheap).allocLarge
void runtime.(*mTreap).remove(struct Eq_2 * gs, struct Eq_26682 * dwArg04, up32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_26682 * ecx_19;
	for (ecx_19 = dwArg04->dw0000; ecx_19 != null; ecx_19 = ecx_19->dw0000)
	{
		if (ecx_19[4] == 0x00)
			runtime.throw(gs);
		if (ecx_19[3] >= dwArg08)
		{
			struct Eq_26682 * ebp_47 = ecx_19[1];
			if (ebp_47 == null || ebp_47[3] < dwArg08)
			{
				runtime.(*mTreap).removeNode(gs, dwArg04, ecx_19);
				return;
			}
			else
			{
				ecx_19 = ebp_47;
				continue;
			}
		}
	}
}

// 0805E5B0: void runtime.(*mTreap).removeSpan(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_26682) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).freeSpanLocked
void runtime.(*mTreap).removeSpan(struct Eq_2 * gs, struct Eq_26682 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = *((word32) dwArg08 + 16);
	struct Eq_26682 * ebx_21 = dwArg04->dw0000;
	while (true)
	{
		Eq_4 ebp_24 = ebx_21[4];
		if (ebp_24 == dwArg08)
			break;
		Eq_4 esi_39 = ebx_21[3];
		if (esi_39 < ecx_19)
			ebx_21 = ebx_21->dw0000;
		else if (esi_39 > ecx_19)
			ebx_21 = (struct Eq_26682 *) ebx_21[1];
		else if (ebp_24 < dwArg08)
			ebx_21 = ebx_21->dw0000;
		else if (ebp_24 > dwArg08)
			ebx_21 = (struct Eq_26682 *) ebx_21[1];
	}
	runtime.(*mTreap).removeNode(gs, dwArg04, ebx_21);
}

// 0805E620: void runtime.scavengetreap(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_27102) dwArg04, Stack Eq_27103 qwArg08, Stack up32 dwArg10, Stack up32 dwArg14)
// Called from:
//      runtime.scavengetreap
//      runtime.(*mheap).scavenge
void runtime.scavengetreap(struct Eq_2 * gs, struct Eq_27102 * dwArg04, Eq_27103 qwArg08, up32 dwArg10, up32 dwArg14)
{
	Eq_27103 dwArg08 = (word32) qwArg08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == null)
		return;
	runtime.scavengeTreapNode(dwArg14, gs, dwArg04, qwArg08, dwArg10, dwArg14);
	runtime.scavengetreap(gs, dwArg04->ptr0004, dwArg08, dwArg10, dwArg14);
	runtime.scavengetreap(gs, dwArg04->ptr0000, dwArg08, dwArg10, dwArg14);
}

// 0805E710: void runtime.(*mTreap).rotateLeft(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_26682) dwArg04, Stack (ptr32 Eq_26682) dwArg08)
// Called from:
//      runtime.(*mTreap).insert
//      runtime.(*mTreap).removeNode
void runtime.(*mTreap).rotateLeft(struct Eq_2 * gs, struct Eq_26682 * dwArg04, struct Eq_26682 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_26682 * ecx_18 = dwArg08->dw0000;
	struct Eq_26682 * edx_19 = dwArg08[2];
	struct Eq_26682 * ebx_20 = dwArg08[1];
	struct Eq_26682 * ebp_21 = ecx_18[1];
	struct Eq_27170 * esi_22 = ecx_18->dw0000;
	ecx_18[1] = (struct Eq_26682) dwArg08;
	dwArg08[2] = (struct Eq_26682) ecx_18;
	ecx_18->dw0000 = esi_22;
	if (esi_22 != null)
		esi_22->ptr0008 = ecx_18;
	dwArg08[1] = (struct Eq_26682) ebx_20;
	if (ebx_20 != null)
		ebx_20[2] = (struct Eq_26682) dwArg08;
	dwArg08->dw0000 = ebp_21;
	if (ebp_21 != null)
		ebp_21[2] = (struct Eq_26682) dwArg08;
	ecx_18[2] = (struct Eq_26682) edx_19;
	if (edx_19 == null)
		dwArg04->dw0000 = ecx_18;
	else if (edx_19[1] != dwArg08)
	{
		if (edx_19->dw0000 != dwArg08)
			runtime.throw(gs);
		else
			edx_19->dw0000 = ecx_18;
	}
	else
		edx_19[1] = (struct Eq_26682) ecx_18;
}

// 0805E7B0: void runtime.(*mTreap).rotateRight(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_26682) dwArg04, Stack (ptr32 Eq_26682) dwArg08)
// Called from:
//      runtime.(*mTreap).insert
//      runtime.(*mTreap).removeNode
void runtime.(*mTreap).rotateRight(struct Eq_2 * gs, struct Eq_26682 * dwArg04, struct Eq_26682 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_26682 * ecx_18 = dwArg08[1];
	struct Eq_26682 * edx_19 = dwArg08[2];
	struct Eq_27248 * ebx_20 = dwArg08->dw0000;
	struct Eq_26682 * ebp_21 = ecx_18[1];
	struct Eq_26682 * esi_22 = ecx_18->dw0000;
	if (ebp_21 != null)
		ebp_21[2] = (struct Eq_26682) ecx_18;
	ecx_18->dw0000 = dwArg08;
	dwArg08[2] = (struct Eq_26682) ecx_18;
	dwArg08[1] = (struct Eq_26682) esi_22;
	if (esi_22 != null)
		esi_22[2] = (struct Eq_26682) dwArg08;
	dwArg08->dw0000 = ebx_20;
	if (ebx_20 != null)
		ebx_20->ptr0008 = dwArg08;
	ecx_18[2] = (struct Eq_26682) edx_19;
	if (edx_19 == null)
		dwArg04->dw0000 = ecx_18;
	else if (edx_19[1] != dwArg08)
	{
		if (edx_19->dw0000 != dwArg08)
			runtime.throw(gs);
		else
			edx_19->dw0000 = ecx_18;
	}
	else
		edx_19[1] = (struct Eq_26682) ecx_18;
}

// 0805E840: void runtime.gcMarkRootPrepare(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMark
void runtime.gcMarkRootPrepare(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw81575E4 == 0x02)
		g_t8145614 = g_t81575F0;
	else
		g_t8145614.u0 = 0x00;
	g_t8145618.u0 = 0x00;
	g_t814561C.u0 = 0x00;
	if ((byte) (word32) g_b8145628 == 0x00)
	{
		runtime.activeModules();
		Eq_4 edx_176 = 0x00;
		while (edx_176 < dwLoc18)
		{
			runtime.gcMarkRootPrepare.func1(gs);
			if (dwLoc18 > g_t8145618)
				g_t8145618 = dwLoc18;
			edx_176 = (word32) edx_176 + 1;
		}
		runtime.activeModules();
		Eq_4 edx_148 = 0x00;
		while (edx_148 < dwLoc18)
		{
			runtime.gcMarkRootPrepare.func1(gs);
			if (dwLoc18 > g_t814561C)
				g_t814561C = dwLoc18;
			edx_148 = (word32) edx_148 + 1;
		}
	}
	if ((byte) (word32) g_b8145628 != 0x00)
	{
		g_t8145620.u0 = 0x00;
		g_t8145624.u0 = 0x00;
		if (g_dw8157738 > 0x00)
		{
			runtime/internal/atomic.Loaduintptr();
			g_t8145624 = dwLoc18;
		}
	}
	else
	{
		runtime.(*gcSweepBuf).numBlocks(gs, (g_t81490F0 >> 0x01 & 0x01) * 0x14 + 135565588);
		g_t8145620 = dwLoc18;
		runtime/internal/atomic.Loaduintptr();
		g_t8145624 = dwLoc18;
	}
	g_t81455F0.u0 = 0x00;
	Mem119[0x081455F4<p32>:word32] = Mem109[0x08145624<p32>:word32] + 0x02 + (((Mem109[0x08145614<p32>:word32] + Mem109[0x08145618<p32>:word32]) + Mem109[0x0814561C<p32>:word32]) + Mem109[0x08145620<p32>:word32]);
}

// 0805EA40: void runtime.gcMarkRootCheck(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkDone
//      runtime.gcMark
void runtime.gcMarkRootCheck(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esp_115 = fp - 0x20;
	Eq_4 eax_17 = g_t81455F0;
	Eq_4 ecx_18 = g_t81455F4;
	if (eax_17 < ecx_18)
	{
		runtime.printlock(gs);
		runtime.printint(ebx, gs, eax_17);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, ecx_18);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		Eq_4 ecx_155;
		word32 ebp_363;
		word32 esi_364;
		word32 edi_365;
		runtime.lock(esi, gs, 0x08157590, out ebp_363, out esi_364, out edi_365);
		if (g_dw81575E4 == 0x02 && g_dw8157738 > 0x00)
		{
			Eq_4 eax_104 = 0x00;
			while (true)
			{
				Eq_4 ecx_108 = g_t8145108;
				Eq_4 edx_109 = g_t814510C;
				if (eax_104 >= edx_109)
					break;
				if (eax_104 >= edx_109)
					runtime.panicindex(gs);
				*((word32) esp_115 + 0x0C) = eax_104;
				Eq_4 ecx_131 = *((word32) ecx_108 + eax_104 * 0x04);
				if ((byte) (word32) *((word32) ecx_131 + 111) == 0x00 || (byte) ((word32) (*((word32) ecx_131 + 112))) == 0x00)
				{
					*((word32) esp_115 + 28) = ecx_131;
					*esp_115 = ecx_131;
					runtime.readgstatus(*esp_115);
					esp_115.u0 = <invalid>;
					if (*((byte) esp_115.u0 + 4) != 0x06)
					{
						ecx_155 = *((byte) esp_115.u0 + 28);
						goto l0805EB28;
					}
					eax_104 = *((byte) esp_115.u0 + 0x0C);
				}
				eax_104 = (word32) eax_104 + 1;
			}
		}
		else
		{
			Eq_4 eax_102 = 0x00;
			while (eax_102 < g_t8145624)
			{
				Eq_4 ecx_86 = g_t8145108;
				if (eax_102 >= g_t814510C)
					runtime.panicindex(gs);
				ecx_155 = *((word32) ecx_86 + eax_102 * 0x04);
				if ((byte) (word32) *((word32) ecx_155 + 111) == 0x00)
				{
l0805EB28:
					*((byte) esp_115.u0 + 28) = ecx_155;
					*esp_115.u0 = ecx_155;
					runtime.readgstatus(*esp_115.u0);
					Eq_4 esp_161 = <invalid>;
					Eq_4 eax_166 = *((word32) esp_161 + 28);
					*((word32) esp_161 + 24) = *((word32) eax_166 + 84);
					*((word32) esp_161 + 20) = *((word32) eax_166 + 80);
					*((word32) esp_161 + 16) = *((word32) esp_161 + 4);
					*((word32) esp_161 + 11) = (byte) (word32) *((word32) eax_166 + 111);
					*((word32) esp_161 + 0x0A) = (byte) (word32) *((word32) eax_166 + 112);
					runtime.printlock(gs);
					esp_161->u0 = 0x080E0E11;
					((word32) esp_161 + 4)->u0 = 0x02;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = *((word32) esp_161 + 28);
					runtime.printpointer(gs);
					runtime.printsp(gs);
					esp_161->u0 = 135139114;
					((word32) esp_161 + 4)->u0 = 0x04;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = *((word32) esp_161 + 20);
					*((word32) esp_161 + 4) = *((word32) esp_161 + 24);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printint(ebx, gs, stackArg4);
					runtime.printsp(gs);
					esp_161->u0 = 0x080E1184;
					((word32) esp_161 + 4)->u0 = 0x06;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = *((word32) esp_161 + 16);
					((word32) esp_161 + 4)->u0 = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printint(ebx, gs, stackArg4);
					runtime.printsp(gs);
					esp_161->u0 = 135141731;
					((word32) esp_161 + 4)->u0 = 0x0A;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = (byte) (word32) *((word32) esp_161 + 11);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printbool(gs, stackArg4);
					runtime.printsp(gs);
					esp_161->u0 = 0x080E1B8A;
					((word32) esp_161 + 4)->u0 = 11;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = (byte) (word32) *((word32) esp_161 + 0x0A);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printbool(gs, stackArg4);
					runtime.printnl(gs);
					runtime.printunlock(gs);
					esp_161->u0 = 0x08157590;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					word32 edx_373;
					word32 ebx_374;
					runtime.unlock(gs, stackArg4, out edx_373, out ebx_374);
					esp_161->u0 = 0x080E23EC;
					((word32) esp_161 + 4)->u0 = 0x0F;
					runtime.throw(gs);
				}
				eax_102 = (word32) eax_102 + 1;
			}
		}
		word32 edx_366;
		word32 ebx_367;
		runtime.unlock(gs, 0x08157590, out edx_366, out ebx_367);
	}
}

// 0805ED10: void runtime.markroot(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gcDrain
//      runtime.gcDrainN
void runtime.markroot(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t8145614;
	Eq_4 edx_19 = g_t8145618;
	word32 ebx_20 = edx_19 + eax_17;
	Eq_4 ebp_21 = g_t814561C;
	word32 esi_22 = (word32) ebp_21 + ebx_20;
	Eq_4 edi_24 = g_t8145620;
	struct Eq_27820 * esp_16 = fp - 0x48;
	up32 esi_25 = (word32) edi_24 + esi_22;
	Eq_4 esi_27 = g_t8145624;
	if (dwArg08 < 0x02 || dwArg08 >= (word32) eax_17 + 2)
	{
		Eq_4 eax_42 = (word32) eax_17 + ((word32) edx_19 + 2);
		if ((word32) eax_17 + 2 > dwArg08 || dwArg08 >= eax_42)
		{
			Eq_4 ecx_102 = (word32) ebp_21 + (ebx_20 + 0x02);
			if (eax_42 > dwArg08 || dwArg08 >= ecx_102)
			{
				if (dwArg08 != 0x00)
				{
					if (dwArg08 != 0x01)
					{
						Eq_4 eax_172 = (word32) edi_24 + (esi_22 + 0x02);
						if (ecx_102 > dwArg08 || dwArg08 >= eax_172)
						{
							if (eax_172 > dwArg08 || dwArg08 >= (word32) esi_27 + (esi_25 + 0x02))
								runtime.throw(gs);
							else
							{
								Eq_4 edx_212 = g_t8145108;
								Eq_4 esi_213 = dwArg08 - eax_172;
								if (esi_213 >= g_t814510C)
									runtime.panicindex(gs);
								else
								{
									Eq_4 eax_234;
									runtime.readgstatus(*((word32) edx_212 + esi_213 * 0x04));
									Eq_4 esp_224 = <invalid>;
									Eq_4 eax_229 = *((word32) esp_224 + 4);
									if (eax_229 == 0x04 || eax_229 == 0x03)
									{
										eax_234 = *((word32) esp_224 + 44);
										Eq_4 ecx_238 = *((word32) eax_234 + 88);
										Eq_4 edx_239 = *((word32) eax_234 + 92);
										if ((byte) (SEQ(SLICE(edx_239, word24, 8), edx_239 == 0x00) & SEQ(SLICE(ecx_238, word24, 8), ecx_238 == 0x00)) != 0x00)
										{
											Eq_4 ecx_255 = g_t8145600;
											*((word32) eax_234 + 88) = g_t81455FC;
											*((word32) eax_234 + 92) = ecx_255;
										}
									}
									else
										eax_234 = *((word32) esp_224 + 44);
									((word32) esp_224 + 60)->u0 = 0x0808C740;
									*((word32) esp_224 + 64) = eax_234;
									*((word32) esp_224 + 0x0044) = *((word32) esp_224 + 76);
									*esp_224 = (word32) esp_224 + 60;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_4 stackArg4 = <invalid>;
									word32 ebp_469;
									word32 edi_470;
									runtime.systemstack(gs, stackArg4, out ebp_469, out edi_470);
								}
							}
						}
						else
							runtime.markrootSpans(gs);
					}
					else if ((byte) (word32) g_b8145628 == 0x00)
					{
						word32 ebp_466;
						word32 edi_467;
						runtime.systemstack(gs, 0x080E7C3C, out ebp_466, out edi_467);
					}
				}
				else if ((byte) (word32) g_b8145628 == 0x00)
				{
					struct Eq_20353 * eax_290 = g_ptr8144FA8;
					while (eax_290 != null)
					{
						esp_16[0x0C] = (struct Eq_27820) eax_290;
						esp_16->dw0000 = &eax_290->t0008;
						runtime/internal/atomic.Load();
						++esp_16;
						ui32 eax_301 = esp_16[1];
						word32 ecx_302 = esp_16[0x0C];
						esp_16[2] = (struct Eq_27820) 0x081577E0;
						esp_16->dw0000 = ecx_302 + 0x10;
						esp_16[1] = (struct Eq_27820) (eax_301 * 0x14);
						esp_16[3] = esp_16[19];
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						Eq_4 stackArg16 = <invalid>;
						word32 ebp_464;
						word32 esi_465;
						runtime.scanblock(gs, stackArg4, dwArg04, dwArg08, stackArg16, out ebp_464, out esi_465);
						eax_290 = (struct Eq_20353 *) *esp_16[0x0C].dw0000;
					}
				}
			}
			else
			{
				runtime.activeModules();
				word32 * eax_118 = dwLoc48;
				int32 edx_121;
				for (edx_121 = 0x00; edx_121 < dwLoc44; ++edx_121)
				{
					struct Eq_27992 * ecx_132 = *eax_118;
					up32 edx_133 = ecx_132->dw0048;
					runtime.markrootBlock(gs, edx_133, ecx_132->dw004C - edx_133, ecx_132->dw00D0, dwArg08 - eax_42);
					++eax_118;
				}
			}
		}
		else
		{
			runtime.activeModules();
			word32 * eax_58 = dwLoc48;
			int32 edx_61;
			for (edx_61 = 0x00; edx_61 < dwLoc44; ++edx_61)
			{
				struct Eq_27944 * ecx_72 = *eax_58;
				up32 edx_73 = ecx_72->dw0040;
				runtime.markrootBlock(gs, edx_73, ecx_72->dw0044 - edx_73, ecx_72->dw00C8, dwArg08 - ((word32) eax_17 + 2));
				++eax_58;
			}
		}
	}
	else
		runtime.flushmcache(gs, dwArg08 - 0x02);
}

// 0805F010: void runtime.markrootBlock(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack uint32 dwArg14)
// Called from:
//      runtime.markroot
void runtime.markrootBlock(struct Eq_2 * gs, up32 dwArg04, word32 dwArg08, word32 dwArg0C, uint32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_21 = (dwArg14 << 0x12) + dwArg04;
	Eq_4 ebp_23 = dwArg08 + dwArg04;
	if (ebx_21 >= ebp_23)
		return;
	Eq_27929 ebp_34;
	Eq_4 ecx_31 = (dwArg14 << 0x0D) + dwArg0C;
	if (dwArg04 + 0x00040000 + (dwArg14 << 0x12) > ebp_23)
		ebp_34 = ebp_23 - ebx_21;
	else
		ebp_34.u0 = 0x00040000;
	word32 esi_95;
	word32 ebp_94;
	runtime.scanblock(gs, ebx_21, ebp_34, ecx_31, dwArg10, out ebp_94, out esi_95);
}

// 0805F090: void runtime.markrootFreeGStacks(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.markrootFreeGStacks(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 edi_191;
	word32 ebp_190;
	runtime.lock(esi, gs, 0x08145424, out ebp_190, out esi_28, out edi_191);
	Eq_4 eax_33 = g_t8145428;
	if (g_t81576F0 == 0x00)
		g_t8145428.u0 = 0x00;
	else
		runtime.writebarrierptr(135549992, 0x00);
	word32 edx_197;
	word32 ebx_198;
	runtime.unlock(gs, 0x08145424, out edx_197, out ebx_198);
	Eq_4 eax_64 = eax_33;
	if (eax_33 == 0x00)
		return;
	Eq_4 edx_71 = eax_33;
	while (eax_64 != 0x00)
	{
		runtime.shrinkstack(gs, eax_64);
		edx_71 = eax_64;
		eax_64 = *((word32) eax_64 + 0x0068);
	}
	word32 edi_194;
	word32 esi_193;
	word32 ebp_192;
	runtime.lock(esi_28, gs, 0x08145424, out ebp_192, out esi_193, out edi_194);
	*((word32) edx_71 + 0x0068) = g_t814542C;
	if (g_t81576F0 == 0x00)
		g_t814542C = eax_33;
	else
		runtime.writebarrierptr(135549996, eax_33);
	word32 edx_195;
	word32 ebx_196;
	runtime.unlock(gs, 0x08145424, out edx_195, out ebx_196);
}

// 0805F1A0: void runtime.markrootSpans(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.markroot
void runtime.markrootSpans(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b8145628 != 0x00)
		runtime.throw(gs);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 eax_29 = g_t81490F0;
		Eq_4 stackArg0 = <invalid>;
		runtime.(*gcSweepBuf).block(gs, stackArg0, (eax_29 >> 0x01 & 0x01) * 0x14 + 135565588, dwArg08, dwLoc2C);
		int32 eax_173 = dwLoc28;
		word32 * ecx_177 = dwLoc2C;
		int32 edx_180;
		for (edx_180 = 0x00; edx_180 < eax_173; ++edx_180)
		{
			struct Eq_28287 * ebx_60 = *ecx_177;
			if ((byte) (word32) ebx_60->b003C == 0x01)
			{
				if ((byte) (word32) g_b8157583 == 0x00)
				{
					Eq_4 ebp_82 = ebx_60->t0030;
					esi = eax_29;
					if (ebp_82 != eax_29)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printint(SLICE(ebx_60, word24, 8), gs, ebp_82);
						runtime.printstring(gs);
						runtime.printint(SLICE(ebx_60, word24, 8), gs, eax_29);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
				}
				if (ebx_60->ptr0058 != null)
				{
					word32 ebp_348;
					word32 edi_350;
					word32 esi_349;
					runtime.lock(esi, gs, (char *) &ebx_60->t0040 + 20, out ebp_348, out esi_349, out edi_350);
					struct Eq_28287 * eax_158 = ebx_60;
					struct Eq_28316 * ecx_159;
					for (ecx_159 = ebx_60->ptr0058; ecx_159 != null; ecx_159 = ecx_159->ptr0000)
					{
						if ((byte) (word32) ecx_159->b0006 == 0x01)
						{
							word32 edx_186 = (word32) ecx_159->w0004;
							Eq_28358 ebx_188 = eax_158->t0040;
							word32 ebp_189 = eax_158->dw000C;
							if (ebx_188 == 0x00)
								runtime.panicdivide(gs);
							word32 ebp_353;
							runtime.scanobject(gs, ebp_189 + (uint32) ((uint64) ((uint32) edx_186) /u ebx_188) *s ebx_188, dwArg04, out ebp_353);
							word32 ebp_354;
							word32 esi_355;
							runtime.scanblock(gs, &ecx_159->b0006 + 2, 0x04, 0x08136000, dwArg04, out ebp_354, out esi_355);
							eax_158 = ebx_60;
						}
					}
					word32 ebx_352;
					word32 edx_351;
					runtime.unlock(gs, (char *) &ebx_60->t0040 + 20, out edx_351, out ebx_352);
					eax_173 = dwLoc28;
				}
			}
			++ecx_177;
		}
	}
}

// 0805F3C0: void runtime.gcAssistAlloc(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.mallocgc
void runtime.gcAssistAlloc(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_20 = gs->ptr0000->tFFFFFFFC;
	if (edx_20 == *(*((word32) dwArg04 + 24)))
		return;
	Eq_4 ecx_26 = *((word32) edx_20 + 24);
	if (*((word32) ecx_26 + 0x0078) > 0x00 || *((word32) ecx_26 + 116) != 0x00)
		return;
	byte cl_37 = 0x00;
	while (true)
	{
		Eq_4 ebx_113;
		int32 edx_112;
		ui64 ebp_ebx_504 = 0x00 - SEQ(edx_46, *((word32) dwArg04 + 0x00CC));
		Eq_4 ebx_43 = (word32) ebp_ebx_504;
		Eq_4 edx_46 = *((word32) dwArg04 + 0x00D0);
		real64 rLoc14_641 = (real64) (uint128) (uint64) g_r81578A0;
		runtime.int64tofloat64(SLICE(ebx_43, word24, 8), gs, ebx_43);
		real64 v17_63 = (real64) (uint128) (uint64) rLoc14_641 * (real64) ((uint128) ((uint64) rLoc4C));
		Eq_4 dwLoc4C_649 = (word32) rLoc4C;
		word128 xmm0_773;
		word32 edx_69 = runtime.float64toint64(gs, v17_63, out xmm0_773);
		int32 dwLoc48_648 = SLICE(rLoc4C, word32, 32);
		byte bLoc45_697 = SLICE(rLoc4C, byte, 56);
		int32 ebp_52 = SLICE(ebp_ebx_504, word32, 32);
		Eq_4 dwLoc50_659 = SLICE(v17_63, word32, 32);
		Eq_4 ecx_114 = dwLoc4C_649;
		Eq_28504 dwLoc40_664 = SEQ(cl_37, nLoc40);
		if ((byte) (SEQ(SLICE(ebx_43, word24, 8), dwLoc4C_649 < 0x00010000) & SEQ(SLICE(edx_69, word24, 8), dwLoc48_648 == 0x00) | SEQ(SLICE(edx_69, word24, 8), dwLoc48_648 < 0x00)) == 0x00)
		{
			edx_112 = ebp_52;
			ebx_113 = ebx_43;
		}
		else
		{
			real64 rLoc14_650 = (real64) (uint128) (uint64) g_r81578A8;
			runtime.int64tofloat64(SLICE(dwLoc4C_649, word24, 8), gs, 0x00010000);
			real64 v22_104 = (real64) (uint128) (uint64) rLoc4C * (real64) ((uint128) ((uint64) rLoc14_650));
			word128 xmm0_774;
			runtime.float64toint64(gs, v22_104, out xmm0_774);
			dwLoc50_659 = SLICE(v22_104, word32, 32);
			edx_112 = dwLoc48_648;
			ebx_113 = dwLoc4C_649;
			ecx_114.u0 = 0x00010000;
		}
		ui32 ebx_158 = SEQ(SLICE(runtime/internal/atomic.Loadint64(0x08157868), word24, 8), false) & SEQ(SLICE(edx_112, word24, 8), dwLoc50_659 == 0x00) | SEQ(SLICE(edx_112, word24, 8), dwLoc50_659 > 0x00);
		ui24 ebx_24_8_172 = SLICE(ebx_158, word24, 8);
		real64 rLoc50_675 = SEQ(dwLoc4C_649, dwLoc50_659);
		word56 nLoc4C_729 = (word56) rLoc4C;
		if ((byte) ebx_158 != 0x00)
		{
			int64 edx_ebp_770;
			nLoc4C_729 = (word56) rLoc4C;
			if ((byte) (SEQ(SLICE(esi, word24, 8), dwLoc40_664 > 0x08157868) & SEQ(ebx_24_8_172, dwLoc50_659 == ecx_114) | SEQ(ebx_24_8_172, dwLoc50_659 < ecx_114)) == 0x00)
			{
				ui64 ecx_ebx_510 = SEQ(*((word32) dwArg08 + 0x00D0), dwLoc30) + SEQ(ebx_113, *((word32) dwArg08 + 0x00CC));
				*((word32) dwArg08 + 0x00CC) = (word32) ecx_ebx_510;
				*((word32) dwArg08 + 0x00D0) = SLICE(ecx_ebx_510, word32, 32);
				edx_ebp_770 = SEQ(ecx_114, dwLoc40_664);
			}
			else
			{
				Eq_4 ebx_203 = *((word32) dwArg08 + 0x00D0);
				Eq_14690 ebp_205 = *((word32) dwArg08 + 0x00CC);
				real64 rLoc18_671 = (real64) (uint128) (uint64) g_r81578A8;
				runtime.int64tofloat64(SLICE(ebx_203, word24, 8), gs, 0x08157868);
				word128 xmm0_777;
				runtime.float64toint64(gs, (real64) (uint128) (uint64) rLoc50_675 * (real64) ((uint128) ((uint64) rLoc18_671)), out xmm0_777);
				word32 eax_229 = dwLoc50_659 + ebp_205;
				*((word32) dwArg08 + 0x00CC) = (word32) eax_229 + 1;
				*((word32) dwArg08 + 0x00D0) = (bool) (eax_229 < 0x01) + SLICE(SEQ(dwLoc4C_649, dwLoc50_659) + SEQ(ebx_203, ebp_205), word32, 32);
				dwLoc24 = ebx_203;
				nLoc4C_729 = (word56) rLoc4C;
				edx_ebp_770 = SEQ(dwLoc50_659, 0x08157868);
			}
			word32 ebx_285;
			word32 ebp_778;
			runtime/internal/atomic.Xaddint64(0x08157868, 0x00 - (word32) edx_ebp_770, SLICE(0x00 - edx_ebp_770, word32, 32), out ebx_285, out ebp_778);
			esi.u0 = 0x08157868;
			if ((byte) (SEQ(SLICE(dwLoc24, word24, 8), SLICE(SEQ(dwLoc40_664, dwLoc44) - SEQ(dwLoc24, SLICE(edx_ebp_770, word32, 32)), word32, 32) == 0x00) & SEQ(SLICE(ebx_285, word24, 8), ecx_114 == 0x00)) != 0x00)
			{
				if ((byte) (word32) bLoc45_697 != 0x00)
					runtime.traceGCMarkAssistDone(gs);
				return;
			}
		}
		byte dl_360;
		if ((byte) (word32) g_b814F4C8 != 0x00)
		{
			if ((byte) (word32) bLoc45_697 != 0x00)
				dl_360 = 0x01;
			else
			{
				runtime.traceGCMarkAssistStart(gs);
				dl_360 = 0x01;
			}
		}
		else
			dl_360 = (byte) (word32) bLoc45_697;
		word32 ebp_775;
		word32 edi_776;
		runtime.systemstack(gs, fp - 0x10, out ebp_775, out edi_776);
		Eq_4 ebx_385 = g_t81576F0;
		byte bLoc5C_718 = (byte) (fp - 0x10);
		Eq_4 ecx_383 = *((word32) dwArg04 + 0x0044);
		ui24 ebx_24_8_425 = SLICE(ebx_385, word24, 8);
		if (ebx_385 == 0x00)
			((word32) dwArg04 + 0x0044)->u0 = 0x00;
		else
		{
			runtime.writebarrierptr((word32) dwArg04 + 0x0044, dwArg04);
			bLoc5C_718 = (byte) ((word32) dwArg04 + 0x0044);
		}
		if (ecx_383 != 0x00)
			runtime.gcMarkDone(gs);
		Eq_4 ecx_414 = *((word32) dwArg04 + 0x00D0);
		if ((byte) (SEQ(*((word32) dwArg04 + 0x00CD), Test(ULT,false)) & SEQ(ebx_24_8_425, ecx_414 == 0x00) | SEQ(SLICE(ecx_414, word24, 8), ecx_414 < 0x00)) == 0x00)
			break;
		if ((byte) (word32) *((word32) dwArg04 + 0x006C) == 0x00)
		{
			runtime.gcParkAssist(gs);
			if ((byte) (word32) bLoc5C_718 != 0x00)
				break;
			cl_37 = (byte) (word32) dl_360;
			continue;
		}
		esi = runtime.Gosched(gs);
		cl_37 = (byte) (word32) dl_360;
		rLoc4C = SEQ(dl_360, nLoc4C_729);
	}
	if ((byte) (word32) dl_360 != 0x00)
		runtime.traceGCMarkAssistDone(gs);
}

// 0805F7E0: void runtime.gcAssistAlloc1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack int32 dwArg10)
// Called from:
//      runtime.gcAssistAlloc.func1
void runtime.gcAssistAlloc1(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, int32 dwArg10)
{
	word32 dwLoc38 = SLICE(qwLoc3C, word32, 32);
	ui32 dwLoc3C = (word32) qwLoc3C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if (g_t81576F0 == 0x00)
		((word32) dwArg04 + 0x0044)->u0 = 0x00;
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 0x0044, 0x00);
		dwLoc48 = 0x00;
	}
	runtime/internal/atomic.Load();
	if (dwLoc44 != 0x00)
	{
		runtime.nanotime();
		Eq_363 ebx_24_8_101 = SLICE(runtime/internal/atomic.Xadd(0x08145604, ~0x00), word24, 8);
		Eq_4 ecx_70 = g_t81455F8;
		if (dwLoc40 == ecx_70)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8_101, gs, (uint64) (uint32) dwLoc40);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8_101, gs, (uint64) (uint32) ecx_70);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			runtime.casgstatus(dwArg08, 0x02, 0x04);
			((word32) dwArg08 + 100)->u0 = 0x11;
			if (g_t81576F0 == 0x00)
				((word32) dwArg08 + 96)->u0 = 0x080E2730;
			else
				runtime.writebarrierptr((word32) dwArg08 + 96, 0x080E2730);
			Eq_4 ecx_204 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
			Eq_4 ebp_218;
			Eq_363 ebx_24_8_240 = SLICE(runtime.gcDrainN(gs, &g_dw81575DC, (word32) ecx_204 + 0x0950, dwArg0C, dwArg10, out ebp_218), word24, 8);
			if ((byte) (word32) g_b815756D != 0x00)
				runtime.(*gcWork).dispose(ebx_24_8_240, ebp_218, gs, 135624156, (word32) ecx_204 + 0x0950);
			runtime.casgstatus(dwArg08, 0x04, 0x02);
			Eq_4 ecx_269 = *((word32) dwArg08 + 0x00D0);
			Eq_4 edx_271 = *((word32) dwArg08 + 0x00CC);
			real64 rLoc10_657 = (real64) (uint128) (uint64) g_r81578A8;
			runtime.int64tofloat64(SLICE(dwLoc38, word24, 8), gs, qwLoc3C);
			word128 xmm0_782;
			runtime.float64toint64(gs, (real64) (uint128) (uint64) rLoc10_657 * (real64) ((uint128) ((uint64) SEQ(dwLoc3C, 0x02))), out xmm0_782);
			*((word32) dwArg08 + 0x00CC) = (word32) edx_271 + 3;
			*((word32) dwArg08 + 0x00D0) = (bool) (edx_271 < 0x01) + SLICE(SEQ(dwLoc3C, 0x02) + SEQ(ecx_269, edx_271), word32, 32);
			Eq_363 ebx_24_8_366 = SLICE(runtime/internal/atomic.Xadd(0x08145604, 0x01), word24, 8);
			Eq_4 ecx_336 = g_t81455F8;
			if (ecx_336 < 0x02)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(ebx_24_8_366, gs, 0x02);
				runtime.printsp(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(ebx_24_8_366, gs, (uint64) (uint32) ecx_336);
				runtime.printsp(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printbool(gs, (byte) (word32) g_b815756D);
				runtime.printnl(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			else
			{
				uip64 qwLoc48_777 = 0x108145604;
				if (ecx_336 == 0x02)
				{
					runtime.gcMarkWorkAvailable(gs, 0x00);
					qwLoc48_777 = 0x100000000;
					if (false)
					{
						if (g_t81576F0 == 0x00)
						{
							*((word32) dwArg08 + 0x0044) = dwArg08;
							qwLoc48_777 = 0x100000000;
						}
						else
						{
							runtime.writebarrierptr(dwArg00, dwArg08);
							qwLoc48_777 = SEQ(dwArg08, dwArg00);
						}
					}
				}
				runtime.nanotime();
				Eq_4 ecx_503 = *((word32) *((word32) dwArg08 + 24) + 92);
				uint32 eax_509 = (word32) qwLoc48_777 - dwLoc48;
				Eq_4 ebp_511 = *((word32) ecx_503 + 0x0940);
				Eq_4 ebp_513 = (word32) ebp_511 + eax_509;
				Eq_4 eax_515 = *((word32) ecx_503 + 0x0944);
				*((word32) ecx_503 + 0x0940) = ebp_513;
				ui64 edi_ebx_581 = qwLoc48_777 - SEQ(dwLoc44, dwLoc48);
				Eq_4 eax_526 = SLICE(SEQ(eax_515, ebp_511) + SEQ(SLICE(edi_ebx_581, word32, 32), eax_509), word32, 32);
				*((word32) ecx_503 + 0x0944) = eax_526;
				word32 ebx_517 = (word32) edi_ebx_581;
				if ((byte) (SEQ(SLICE(ebx_517, word24, 8), eax_526 > 0x00) | SEQ(SLICE(eax_509, word24, 8), eax_526 == 0x00) & SEQ(SLICE(ebx_517, word24, 8), ebp_513 > 5000)) != 0x00)
				{
					word32 ebp_554;
					word32 ebx_555;
					runtime/internal/atomic.Xaddint64(0x08157870, ebp_513, eax_526, out ebx_555, out ebp_554);
					*((word32) ecx_204 + 4752) = 0x00;
					*((word32) ecx_204 + 4756) = 0x00;
				}
			}
		}
	}
	else
	{
		((word32) dwArg08 + 0x00CC)->u0 = 0x00;
		((word32) dwArg08 + 0x00D0)->u0 = 0x00;
	}
}

// 0805FC80: void runtime.gcWakeAllAssists(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkDone
void runtime.gcWakeAllAssists(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_55;
	word32 esi_56;
	word32 edi_57;
	runtime.lock(esi, gs, 135550548, out ebp_55, out esi_56, out edi_57);
	runtime.injectglist(gs, g_t8145658);
	g_t8145658.u0 = 0x00;
	g_t814565C.u0 = 0x00;
	word32 edx_58;
	word32 ebx_59;
	runtime.unlock(gs, 135550548, out edx_58, out ebx_59);
}

// 0805FCF0: void runtime.gcParkAssist(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcAssistAlloc
void runtime.gcParkAssist(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_220;
	word32 esi_219;
	word32 ebp_218;
	runtime.lock(esi, gs, 135550548, out ebp_218, out esi_219, out edi_220);
	runtime/internal/atomic.Load();
	if (dwLoc14 == 0x00)
	{
		word32 ebx_222;
		word32 edx_221;
		runtime.unlock(gs, 135550548, out edx_221, out ebx_222);
	}
	else
	{
		Eq_4 eax_42 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_45 = g_t814565C;
		if (g_t8145658 == 0x00)
			g_t8145658 = eax_42;
		else
			*((word32) edx_45 + 0x0068) = eax_42;
		g_t814565C = eax_42;
		((word32) eax_42 + 0x0068)->u0 = 0x00;
		runtime/internal/atomic.Loadint64(0x08157868);
		if ((byte) (SEQ(0x00081578, dwLoc14 > 0x00) | (uint32) ((uint8) (dwLoc14 == 0x00)) & 0x00) == 0x00)
			runtime.goparkunlock(gs);
		else
		{
			g_t8145658 = edx_45;
			g_t814565C = dwLoc08;
			if (dwLoc08 != 0x00)
				((word32) dwLoc08 + 0x0068)->u0 = 0x00;
			word32 edx_223;
			word32 ebx_224;
			runtime.unlock(gs, 135550548, out edx_223, out ebx_224);
		}
	}
}

// 0805FE60: void runtime.gcFlushBgCredit(Register Eq_363 ebx, Register ui32 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gcDrain
void runtime.gcFlushBgCredit(Eq_363 ebx, ui32 ebp, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t8145658 == 0x00)
	{
		word32 ebx_414;
		word32 ebp_415;
		runtime/internal/atomic.Xaddint64(0x08157868, dwArg04, dwArg08, out ebx_414, out ebp_415);
	}
	else
	{
		runtime.int64tofloat64(ebx, gs, dwArg04);
		word128 xmm0_417;
		runtime.float64toint64(gs, (real64) (uint128) (uint64) g_r81578A8 * (real64) ((uint128) ((uint64) rLoc20)), out xmm0_417);
		word32 ebp_419;
		word32 esi_420;
		word32 edi_421;
		runtime.lock(esi, gs, 135550548, out ebp_419, out esi_420, out edi_421);
		Eq_4 eax_172 = g_t8145658;
		Eq_29316 edx_ecx_408 = rLoc20;
		while (true)
		{
			Eq_4 edx_117;
			Eq_4 ecx_118;
			word56 nLoc1F_349 = SLICE(rLoc20, word56, 8);
			Eq_4 ecx_77 = (word32) edx_ecx_408;
			int32 eax_411 = SLICE(edx_ecx_408, word32, 32);
			if (eax_172 == 0x00)
				break;
			ui32 ebp_104 = SEQ(SLICE(ebp, word24, 8), ecx_77 > 0x00) & SEQ(ebx_24_8, eax_411 == 0x00) | SEQ(ebx_24_8, eax_411 > 0x00);
			if ((byte) ebp_104 == 0x00)
			{
				edx_117 = ecx_77;
				ecx_118 = eax_172;
				goto l0805FFC3;
			}
			Eq_4 ebx_123 = *((word32) eax_172 + 0x00D0);
			ui64 edx_ecx_307 = edx_ecx_408 + SEQ(ebx_123, Mem119[eax_172 + 0xCC:word32]);
			Eq_4 edx_125 = SLICE(edx_ecx_307, word32, 32);
			ui24 ebx_24_8_131 = SLICE(ebx_123, word24, 8);
			ui32 ebp_146 = SEQ(SLICE(ebp_104, word24, 8), Test(UGE,false)) & SEQ(ebx_24_8_131, edx_125 == 0x00) | SEQ(ebx_24_8_131, edx_125 > 0x00);
			Eq_4 ecx_121 = (word32) edx_ecx_307;
			ebx_24_8 = ebx_24_8_131;
			ebp = ebp_146;
			if ((byte) ebp_146 == 0x00)
			{
				*((word32) eax_172 + 0x00CC) = ecx_121;
				*((word32) eax_172 + 0x00D0) = edx_125;
				ecx_118 = *((word32) eax_172 + 0x0068);
				if (ecx_118 != 0x00)
				{
					((word32) eax_172 + 0x0068)->u0 = 0x00;
					*((word32) g_t814565C + 0x0068) = eax_172;
					g_t814565C = eax_172;
				}
				else
					ecx_118 = eax_172;
				edx_117.u0 = 0x00;
				eax_411 = 0x00;
				goto l0805FFC3;
			}
			((word32) eax_172 + 0x00CC)->u0 = 0x00;
			((word32) eax_172 + 0x00D0)->u0 = 0x00;
			Eq_4 ecx_162 = *((word32) eax_172 + 0x0068);
			runtime.ready(gs, eax_172);
			eax_172 = ecx_162;
			rLoc20 = SEQ(nLoc1F_349, 0x00);
			edx_ecx_408 = edx_ecx_307;
		}
		edx_117 = ecx_77;
		ecx_118 = eax_172;
l0805FFC3:
		g_t8145658 = ecx_118;
		Eq_4 dwLoc1C_353 = SLICE(rLoc20, word32, 32);
		Eq_4 dwLoc20_354 = (word32) rLoc20;
		ui24 ecx_24_8_238 = SLICE(ecx_118, word24, 8);
		ui24 ebx_24_8_236 = SLICE(ecx_118, word24, 8);
		if (ecx_118 == 0x00)
		{
			g_t814565C.u0 = 0x00;
			ecx_24_8_238 = 0x00;
		}
		if ((byte) (SEQ(ebx_24_8_236, edx_117 > 0x00) & SEQ(ecx_24_8_238, eax_411 == 0x00) | SEQ(ecx_24_8_238, eax_411 > 0x00)) != 0x00)
		{
			runtime.int64tofloat64(ebx, gs, edx_117);
			word128 xmm0_422;
			runtime.float64toint64(gs, (real64) (uint128) (uint64) g_r81578A0 * (real64) ((uint128) ((uint64) rLoc20)), out xmm0_422);
			word32 ebp_280;
			word32 ebx_281;
			runtime/internal/atomic.Xaddint64(0x08157868, dwLoc20_354, dwLoc1C_353, out ebx_281, out ebp_280);
		}
		word32 edx_423;
		word32 ebx_424;
		runtime.unlock(gs, 135550548, out edx_423, out ebx_424);
	}
}

// 080600B0: void runtime.scanstack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scang
//      runtime.newstack
void runtime.scanstack(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x84 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if ((byte) (word32) *((word32) dwArg04 + 112) != 0x00)
		return;
	runtime.readgstatus(dwArg04);
	Eq_4 esp_26 = <invalid>;
	if ((*((word32) esp_26 + 4) & 0x1000) == 0x00)
	{
		*esp_26 = *((word32) esp_26 + 264);
		runtime.readgstatus(*esp_26);
		Eq_4 esp_38 = <invalid>;
		Eq_4 eax_43 = *((word32) esp_38 + 264);
		*((word32) esp_38 + 52) = *((word32) eax_43 + 84);
		*((word32) esp_38 + 48) = *((word32) eax_43 + 80);
		*((word32) esp_38 + 44) = *((word32) esp_38 + 4);
		runtime.printlock(gs);
		esp_38->u0 = 135149313;
		((word32) esp_38 + 4)->u0 = 22;
		runtime.printstring(gs);
		*esp_38 = *((word32) esp_38 + 264);
		runtime.printpointer(gs);
		esp_38->u0 = 0x080E11ED;
		((word32) esp_38 + 4)->u0 = 0x07;
		runtime.printstring(gs);
		*esp_38 = *((word32) esp_38 + 48);
		*((word32) esp_38 + 4) = *((word32) esp_38 + 52);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.printint(ebx, gs, stackArg4);
		esp_38->u0 = 135146316;
		((word32) esp_38 + 4)->u0 = 0x13;
		runtime.printstring(gs);
		*esp_38 = *((word32) esp_38 + 44);
		((word32) esp_38 + 4)->u0 = 0x00;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		word32 esi_466;
		runtime.printhex(esi, gs, stackArg4, dwArg04, out esi_466);
		esp_38->u0 = 0x080E0D9C;
		((word32) esp_38 + 4)->u0 = 0x01;
		runtime.printstring(gs);
		runtime.printunlock(gs);
		esp_38->u0 = 135149357;
		((word32) esp_38 + 4)->u0 = 22;
		runtime.throw(gs);
	}
	*esp_26 = *((word32) esp_26 + 264);
	runtime.readgstatus(*esp_26);
	if ((dwLocFC & ~0x1000) <= 0x02)
	{
		if ((dwLocFC & ~0x1000) == 0x01)
		{
l0806012A:
			if (dwArg08 == (gs->ptr0000)->tFFFFFFFC)
				runtime.throw(gs);
			else
			{
				Eq_4 ecx_314 = *((word32) dwArg08 + 24);
				if (ecx_314 == 0x00 || *((word32) ecx_314 + 0x0088) == 0x00)
				{
					if ((byte) (word32) g_b8145628 == 0x00)
						runtime.shrinkstack(gs, dwArg08);
					fn0808FD60(0x00, fp - 200);
					runtime.gentraceback(gs, dwArg04, 0x00, dwArg08, 0x00, 0x00, 0x7FFFFFFF, fp - 0x0C, 0x00);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg0 = <invalid>;
					runtime.tracebackdefers(gs, stackArg0, dwArg04, dwArg04);
					((word32) dwArg04 + 112)->u0 = 0x01;
					return;
				}
				else
					runtime.throw(gs);
			}
		}
		if ((dwLocFC & ~0x1000) == 0x02)
		{
			runtime.readgstatus(dwArg08);
			Eq_4 esp_140 = <invalid>;
			Eq_4 eax_145 = *((word32) esp_140 + 264);
			*((word32) esp_140 + 52) = *((word32) eax_145 + 84);
			*((word32) esp_140 + 48) = *((word32) eax_145 + 80);
			*((word32) esp_140 + 44) = *((word32) esp_140 + 4);
			runtime.printlock(gs);
			esp_140->u0 = 0x080E1DFB;
			((word32) esp_140 + 4)->u0 = 0x0C;
			runtime.printstring(gs);
			*esp_140 = *((word32) esp_140 + 264);
			runtime.printpointer(gs);
			esp_140->u0 = 0x080E11ED;
			((word32) esp_140 + 4)->u0 = 0x07;
			runtime.printstring(gs);
			*esp_140 = *((word32) esp_140 + 48);
			*((word32) esp_140 + 4) = *((word32) esp_140 + 52);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.printint(ebx, gs, stackArg4);
			esp_140->u0 = 135146316;
			((word32) esp_140 + 4)->u0 = 0x13;
			runtime.printstring(gs);
			*esp_140 = *((word32) esp_140 + 44);
			((word32) esp_140 + 4)->u0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.printint(ebx, gs, stackArg4);
			esp_140->u0 = 0x080E0D9C;
			((word32) esp_140 + 4)->u0 = 0x01;
			runtime.printstring(gs);
			runtime.printunlock(gs);
			esp_140->u0 = 135156963;
			((word32) esp_140 + 4)->u0 = 0x20;
			runtime.throw(gs);
		}
	}
	else
	{
		if ((dwLocFC & ~0x1000) <= 0x04)
			goto l0806012A;
		if ((dwLocFC & ~0x1000) == 0x06)
			return;
	}
	runtime.readgstatus(dwArg08);
	Eq_4 esp_221 = <invalid>;
	Eq_4 eax_226 = *((word32) esp_221 + 264);
	*((word32) esp_221 + 52) = *((word32) eax_226 + 84);
	*((word32) esp_221 + 48) = *((word32) eax_226 + 80);
	*((word32) esp_221 + 44) = *((word32) esp_221 + 4);
	runtime.printlock(gs);
	esp_221->u0 = 0x080E1DFB;
	((word32) esp_221 + 4)->u0 = 0x0C;
	runtime.printstring(gs);
	*esp_221 = *((word32) esp_221 + 264);
	runtime.printpointer(gs);
	esp_221->u0 = 0x080E11ED;
	((word32) esp_221 + 4)->u0 = 0x07;
	runtime.printstring(gs);
	*esp_221 = *((word32) esp_221 + 48);
	*((word32) esp_221 + 4) = *((word32) esp_221 + 52);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	runtime.printint(ebx, gs, stackArg4);
	esp_221->u0 = 135146316;
	((word32) esp_221 + 4)->u0 = 0x13;
	runtime.printstring(gs);
	*esp_221 = *((word32) esp_221 + 44);
	((word32) esp_221 + 4)->u0 = 0x00;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	runtime.printint(ebx, gs, stackArg4);
	esp_221->u0 = 0x080E0D9C;
	((word32) esp_221 + 4)->u0 = 0x01;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_221->u0 = 0x080E281E;
	((word32) esp_221 + 4)->u0 = 0x11;
	runtime.throw(gs);
}

// 08060530: void runtime.scanframeworker(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_29985) dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scanstack.func1
void runtime.scanframeworker(Eq_4 esi, struct Eq_2 * gs, struct Eq_29985 * dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 ebx_20 = dwArg04->t000C;
	if (ebx_20 == 0x00)
		return;
	if (ebx_20 != *edx_19)
		--ebx_20;
	runtime.pcdatavalue(gs, edx_19, 0x00);
	Eq_4 dwLoc38_760 = ebx_20;
	Eq_4 eax_52 = dwLoc30;
	if (dwLoc30 == ~0x00)
		eax_52.u0 = 0x00;
	Eq_4 edx_64 = dwArg04->dw001C - dwArg04->dw0014;
	if (edx_64 > 0x00)
	{
		Eq_363 ebx_24_8_271 = SLICE(runtime.funcdata(gs, edx_19, 0x01), word24, 8);
		if (ebx_20 != 0x00)
		{
			Eq_4 ecx_88 = *ebx_20;
			if (ecx_88 > 0x00)
			{
				if (eax_52 < 0x00 || eax_52 >= ecx_88)
				{
					runtime.funcname(gs, edx_19, ecx_18);
					Eq_4 eax_243 = *ebx_20;
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_271, gs, SEQ(eax_52 >> 0x1F, eax_52));
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_271, gs, SEQ(eax_243 >> 0x1F, eax_243));
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_271, gs, (uint64) (uint32) ebx_20);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				runtime.stackmapdata(gs, ebx_20, eax_52);
				word32 ebp_978;
				runtime.scanblock(gs, dwArg04->dw001C - 0x04, 0x04, ebx_20, dwArg0C, out ebp_978, out esi);
				dwLoc38_760 = dwArg0C;
				goto l080605B3;
			}
		}
		runtime.funcname(gs, edx_19, ecx_18);
		word32 edx_110 = dwArg04->dw001C;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		Eq_4 esi_166;
		runtime.printhex(esi, gs, edx_110 - edx_64, 0x00, out esi_166);
		runtime.printstring(gs);
		word32 esi_977;
		runtime.printhex(esi_166, gs, edx_64, 0x00, out esi_977);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
l080605B3:
		if (dwArg04->t0024 <= 0x00)
			return;
		Eq_4 edx_719;
		ui32 eax_718;
		struct Eq_30060 * edx_409 = dwArg04->ptr0028;
		if (edx_409 == null)
		{
			Eq_363 ebx_24_8_611 = SLICE(runtime.funcdata(gs, edx_19, 0x00), word24, 8);
			if (dwLoc38_760 != 0x00)
			{
				Eq_4 ecx_432 = *dwLoc38_760;
				if (ecx_432 > 0x00)
				{
					if (eax_52 < 0x00 || eax_52 >= ecx_432)
					{
						runtime.funcname(gs, edx_19, ecx_18);
						Eq_4 eax_583 = *dwLoc38_760;
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_611, gs, SEQ(eax_52 >> 0x1F, eax_52));
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_611, gs, SEQ(eax_583 >> 0x1F, eax_583));
						runtime.printstring(gs);
						runtime.printstring(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_611, gs, (uint64) (uint32) ebx_20);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
					runtime.stackmapdata(gs, dwLoc38_760, eax_52);
					eax_718 = 0x00;
					edx_719 = dwLoc38_760;
l080605C6:
					word32 esi_981;
					word32 ebp_980;
					runtime.scanblock(gs, dwArg04->t0020, eax_718 << 0x02, edx_719, dwArg0C, out ebp_980, out esi_981);
					return;
				}
			}
			runtime.funcname(gs, edx_19, ecx_18);
			Eq_4 ebx_454 = dwArg04->t0020;
			Eq_4 edx_456 = dwArg04->t0024;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			Eq_4 esi_506;
			runtime.printhex(esi, gs, ebx_454, 0x00, out esi_506);
			runtime.printstring(gs);
			word32 esi_979;
			runtime.printhex(esi_506, gs, edx_456, 0x00, out esi_979);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			eax_718 = edx_409->dw0000;
			edx_719 = edx_409->t0004;
			goto l080605C6;
		}
	}
}

// 08060AE0: Register Eq_363 runtime.gcDrain(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg08, Register out Eq_25757 ebpOut, Register out Eq_25758 esiOut)
// Called from:
//      runtime.gcMark
//      runtime.gchelper
//      runtime.gcBgMarkWorker.func2
Eq_363 runtime.gcDrain(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg08, union Eq_25757 & ebpOut, union Eq_25758 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_30290 * esp_16 = fp - 0x40;
	if ((byte) (word32) g_t81576F4 == 0x00)
		runtime.throw(gs);
	Eq_4 ecx_118;
	Eq_4 eax_116;
	Eq_4 esi_102;
	Eq_4 edx_33 = *((word32) dwArg04 + 16);
	Eq_4 ebp_41 = *((word32) dwArg04 + 20);
	Eq_4 eax_39 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
	word32 ebp_45 = ebp_41 + (edx_33 <u 100000);
	Eq_4 edi_112 = g_t81455F0;
	if (edi_112 < g_t81455F4)
	{
		bool Z_57 = SLICE(cond(dwArg08 & 0x01), bool, 2);
		while (true)
		{
			esi_102 = ebp_41;
			if (!Z_57 && (byte) ((word32) (*((word32) eax_39 + 0x006C))) != 0x00)
				break;
			runtime/internal/atomic.Xadd(0x081455F0, 0x01);
			if (dwLoc38 - 0x01 >= g_t81455F4)
				break;
			runtime.markroot(gs, dwLoc38 - 0x01);
			byte bLoc40_686 = (byte) dwArg04;
			if ((dwArg08 & 0x08) == 0x00)
				Z_57 = SLICE(cond(dwArg08 & 0x01), bool, 2);
			else
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.pollWork(gs, stackArg0);
				if ((byte) (word32) bLoc40_686 != 0x00)
				{
					eax_116 = ebp_41;
					ecx_118 = edx_33;
					goto l08060C08;
				}
				Z_57 = SLICE(cond(dwArg08 & 0x01), bool, 2);
			}
		}
	}
	ui32 eax_105 = dwArg08;
	bool Z_608 = SLICE(cond(dwArg08 & 0x01), bool, 2);
	up32 ecx_120 = (word32) edx_33 + 100000;
	Eq_4 edx_128 = ebp_45;
	Eq_4 ebx_115 = ebp_41;
	Eq_4 ebp_117 = edx_33;
l08060CC7:
	if (!Z_608)
	{
		esi_102 = esp_16[0x0F];
		Eq_4 edi_103 = (word32) *((word32) esi_102 + 0x006C);
		edi_112 = edi_103;
		if ((byte) edi_103 != 0x00)
		{
			eax_116 = ebx_115;
			ecx_118 = ebp_117;
			goto l08060C08;
		}
	}
	bool Z_183;
	esp_16[7] = (struct Eq_30290) ecx_120;
	esp_16[0x0E] = (struct Eq_30290) ebx_115;
	esp_16[0x0D] = (struct Eq_30290) ebp_117;
	esp_16[8] = (struct Eq_30290) edx_128;
	word32 edi_130 = g_dw8145580;
	Eq_4 ebx_140 = SEQ(SLICE(edi_130, word24, 8), edi_130 == 0x00);
	word32 esi_131 = g_dw8145584;
	edi_112 = ebx_140;
	Eq_4 ebx_153 = ebx_115;
	if ((byte) (SEQ(SLICE(esi_131, word24, 8), esi_131 == 0x00) & ebx_140) == 0x00)
		Z_183 = SLICE(cond(eax_105 & 11), bool, 2);
	else
	{
		esp_16->dw0000 = (word32) esp_16[0x0011];
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.(*gcWork).balance(gs, stackArg4);
		Z_183 = SLICE(cond(esp_16[18] & 11), bool, 2);
		ebx_153 = esp_16[0x0E];
		ebp_117 = esp_16[0x0D];
	}
	Eq_4 ecx_195;
	if (!Z_183)
	{
		esi_102 = esp_16[0x0011];
		edi_112 = *esi_102;
		if (edi_112 != 0x00)
		{
			Eq_4 ecx_209 = *((word32) edi_112 + 0x0C);
			if (ecx_209 == 0x00)
				ecx_195.u0 = 0x00;
			else
			{
				*((word32) edi_112 + 0x0C) = ecx_209 - 0x01;
				if (ecx_209 >= 0x01FD)
					runtime.panicindex(gs);
				ecx_195 = *((word32) edi_112 + (ecx_209 * 0x04 + 0x0C));
			}
		}
		else
			ecx_195.u0 = 0x00;
		if (ecx_195 == 0x00)
		{
			esp_16->dw0000 = (word32) esi_102;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.(*gcWork).tryGet(gs, stackArg4);
			ecx_195 = esp_16[1];
			ebx_153 = esp_16[0x0E];
			ebp_117 = esp_16[0x0D];
			esi_102 = esp_16[0x0011];
		}
	}
	else
	{
		esp_16->dw0000 = (word32) esp_16[0x0011];
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.(*gcWork).get(gs, stackArg4);
		ecx_195 = esp_16[1];
		ebx_153 = esp_16[0x0E];
		ebp_117 = esp_16[0x0D];
		esi_102 = esp_16[0x0011];
	}
	ui24 ebx_24_8_273 = SLICE(ebx_153, word24, 8);
	if (ecx_195 != 0x00)
	{
		Eq_4 esi_440;
		up32 ebx_436;
		ui32 ecx_441;
		esp_16->dw0000 = (word32) ecx_195;
		esp_16[1] = (struct Eq_30290) esi_102;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		word32 ebp_748;
		runtime.scanobject(gs, stackArg4, dwArg04, out ebp_748);
		struct Eq_30556 * eax_265 = esp_16[0x0011];
		int32 ecx_266 = eax_265->dw0014;
		up32 edx_267 = eax_265->dw0010;
		ui24 ebx_24_8_280 = SLICE(ebp_117, word24, 8);
		if ((byte) (SEQ(ebx_24_8_273, ecx_266 == 0x00) & SEQ(ebx_24_8_280, edx_267 >= 2000) | SEQ(ebx_24_8_280, ecx_266 > 0x00)) == 0x00)
		{
			ecx_441 = (ui32) esp_16[18];
			Z_608 = SLICE(cond(ecx_441 & 0x01), bool, 2);
			edx_128 = esp_16[8];
			ebx_436 = (up32) esp_16[7];
			ebp_117 = esp_16[0x0D];
			esi_440 = esp_16[0x0E];
			goto l08060CC1;
		}
		Eq_4 edx_336;
		Eq_4 ecx_335;
		esp_16[1] = (struct Eq_30290) edx_267;
		esp_16[2] = (struct Eq_30290) ecx_266;
		esp_16->dw0000 = 0x08157860;
		word32 ebp_750;
		word32 ebx_749;
		runtime/internal/atomic.Xaddint64(esp_16->dw0000, esp_16[1], esp_16[2], out ebx_749, out ebp_750);
		esp_16 = (struct Eq_30290 *) ((char *) esp_16 - 4);
		ui32 eax_314 = esp_16[18];
		if ((eax_314 & 0x04) == 0x00)
		{
			ecx_335 = esp_16[0x0D];
			edx_336 = esp_16[0x0E];
		}
		else
		{
			struct Eq_30729 * eax_318 = esp_16[0x0011];
			ui64 edx_ecx_629 = SEQ(eax_318->dw0014, eax_318->dw0010) - SEQ(ecx_325, esp_16[0x0D]);
			esp_16->dw0000 = (word32) edx_ecx_629;
			ui32 ecx_325 = esp_16[0x0E];
			esp_16[1] = (struct Eq_30290) SLICE(edx_ecx_629, word32, 32);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.gcFlushBgCredit(ebx, ebp, gs, stackArg4, dwArg04);
			eax_314 = (ui32) esp_16[18];
			ecx_335.u0 = 0x00;
			edx_336.u0 = 0x00;
		}
		struct Eq_30779 * ebx_343 = esp_16[0x0011];
		ui32 ebp_348 = ebx_343->dw0014;
		ui64 edi_esi_632 = SEQ(edi_351, esp_16[7]) - SEQ(ebp_348, ebx_343->dw0010);
		ebx_343->dw0010 = 0x00;
		ebx_343->dw0014 = 0x00;
		up32 esi_346 = (word32) edi_esi_632;
		edi_112 = SLICE(edi_esi_632, word32, 32);
		ui32 edi_351 = esp_16[8];
		if ((eax_314 & 0x08) == 0x00)
		{
			Z_608 = SLICE(cond(eax_314 & 0x01), bool, 2);
			goto l08060E27;
		}
		ui24 ebx_24_8_367 = SLICE(ebp_348, word24, 8);
		if ((byte) (SEQ(SLICE(ebx_343, word24, 8), esi_346 <= 0x00) & SEQ(ebx_24_8_367, edi_112 == 0x00) | SEQ(ebx_24_8_367, edi_112 < 0x00)) == 0x00)
		{
			Z_608 = SLICE(cond(eax_314 & 0x01), bool, 2);
			goto l08060E27;
		}
		esp_16[0x0C] = (struct Eq_30290) edi_112;
		esp_16[11] = (struct Eq_30290) ecx_335;
		esp_16[0x0A] = (struct Eq_30290) edx_336;
		esp_16[9] = (struct Eq_30290) esi_346;
		esp_16[7] = (struct Eq_30290) (esi_346 + 100000);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.pollWork(gs, stackArg0);
		esi_102 = esi_346 + 100000;
		word32 eax_414 = Mem403[esp_16 + 0x30:word32] + (Mem403[esp_16 + 0x24:word32] <u 100000);
		if ((byte) (word32) esp_16->dw0000 == 0x00)
		{
			Z_608 = SLICE(cond(esp_16[18] & 0x01), bool, 2);
			ecx_335 = esp_16[11];
			edx_336 = esp_16[0x0A];
			esi_346 = (up32) esp_16[7];
			edi_112 = eax_414;
l08060E27:
			ebx_436 = esi_346;
			ebp_117 = ecx_335;
			esi_440 = edx_336;
			ecx_441 = (ui32) esp_16[18];
			edx_128 = edi_112;
l08060CC1:
			eax_105 = ecx_441;
			ecx_120 = ebx_436;
			ebx_115 = esi_440;
			goto l08060CC7;
		}
		eax_116 = esp_16[0x0A];
		ecx_118 = esp_16[11];
	}
	else
	{
		eax_116 = ebx_153;
		ecx_118 = ebp_117;
	}
l08060C08:
	struct Eq_30838 * edx_485 = esp_16[0x0011];
	Eq_25757 ebp_487 = edx_485->t0014;
	ui24 ebx_24_8_498 = SLICE(esi_102, word24, 8);
	Eq_25758 ebx_529 = SEQ(ebx_24_8_498, ebp_487 > 0x00);
	Eq_363 ebx_486 = edx_485->t0010;
	Eq_363 ebx_531 = ebx_486;
	if ((byte) (SEQ(SLICE(edi_112, word24, 8), ebx_486 > 0x00) & SEQ(ebx_24_8_498, ebp_487 == 0x00) | ebx_529) != 0x00)
	{
		esp_16[6] = (struct Eq_30290) eax_116;
		esp_16[5] = (struct Eq_30290) ecx_118;
		esp_16[1] = (struct Eq_30290) ebx_486;
		esp_16[2] = (struct Eq_30290) ebp_487;
		esp_16->dw0000 = 0x08157860;
		runtime/internal/atomic.Xaddint64(esp_16->dw0000, esp_16[1], esp_16[2], out ebx_531, out ebp_487);
		struct Eq_30672 * esp_560 = (char *) esp_16 - 4;
		if ((esp_560->dw0048 & 0x04) != 0x00)
		{
			struct Eq_30683 * eax_565 = esp_560->ptr0044;
			ui64 edx_ecx_626 = SEQ(eax_565->dw0014, eax_565->dw0010) - SEQ(ecx_572, esp_560->dw0014);
			esp_560->dw0000 = (word32) edx_ecx_626;
			ui32 ecx_572 = esp_560->dw0018;
			esp_560->dw0004 = SLICE(edx_ecx_626, word32, 32);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.gcFlushBgCredit(ebx, ebp, gs, stackArg4, dwArg04);
		}
		struct Eq_30683 * eax_584 = esp_560->ptr0044;
		eax_584->dw0010 = 0x00;
		eax_584->dw0014 = 0x00;
	}
	ebpOut = ebp_487;
	esiOut = ebx_529;
	return ebx_531;
}

// 08060FD0: Register uint32 runtime.gcDrainN(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_29118) dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg0C, Register out Eq_4 ebpOut)
// Called from:
//      runtime.gcAssistAlloc1
uint32 runtime.gcDrainN(struct Eq_2 * gs, struct Eq_29118 * dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, int32 dwArg0C, union Eq_4 & ebpOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if ((byte) (word32) g_t81576F4 == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_115 = dwArg04;
		ui64 ebp_ebx_316 = 0x00 - SEQ(*((word32) dwArg04 + 20), *((word32) dwArg04 + 16));
		Eq_4 eax_309 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
		while (true)
		{
			ui24 eax_24_8_73 = SLICE(eax_309, word24, 8);
			uint32 ebx_258 = (word32) ebp_ebx_316;
			struct Eq_30981 * esp_231 = fp - 32;
			Eq_4 ebp_332 = SLICE(ebp_ebx_316, word32, 32);
			if ((byte) (word32) *((word32) eax_309 + 0x006C) != 0x00)
				break;
			ui64 esi_edx_322 = SEQ(esi_62, *((word32) ecx_115 + 16)) + ebp_ebx_316;
			Eq_4 edx_60 = (word32) esi_edx_322;
			int32 esi_64 = SLICE(esi_edx_322, word32, 32);
			Eq_4 esi_62 = *((word32) ecx_115 + 20);
			ebp_332 = dwArg08;
			if ((byte) (SEQ(eax_24_8_73, esi_64 == dwArg0C) & SEQ(SLICE(edx_60, word24, 8), edx_60 < dwArg08) | SEQ(SLICE(edx_60, word24, 8), esi_64 < dwArg0C)) == 0x00)
				break;
			word32 eax_88 = g_dw8145584;
			word32 edx_89 = g_dw8145580;
			if ((byte) (SEQ(SLICE(eax_88, word24, 8), eax_88 == 0x00) & SEQ(SLICE(edx_89, word24, 8), edx_89 == 0x00)) != 0x00)
			{
				runtime.(*gcWork).balance(gs, ecx_115);
				ecx_115 = dwArg04;
			}
			Eq_4 eax_125;
			struct Eq_31041 * eax_121 = *ecx_115;
			if (eax_121 != null)
			{
				uint32 edx_128 = eax_121->a000C[0];
				if (edx_128 == 0x00)
					eax_125.u0 = 0x00;
				else
				{
					eax_121->a000C[0] = edx_128 - 0x01;
					if (edx_128 >= 0x01FD)
						runtime.panicindex(gs);
					eax_125 = eax_121->a000C[edx_128];
				}
			}
			else
				eax_125.u0 = 0x00;
			if (eax_125 == 0x00)
			{
				runtime.(*gcWork).tryGet(gs, ecx_115);
				eax_125 = dwLoc1C;
				ecx_115 = dwArg04;
			}
			uint32 ecx_235;
			Eq_4 eax_247;
			ebp_332 = dwArg08;
			if (eax_125 == 0x00)
			{
				if (g_t81455F0 >= g_t81455F4)
					break;
				ebx_258 = runtime/internal/atomic.Xadd(0x081455F0, 0x01);
				if (dwLoc18 - 0x01 >= g_t81455F4)
					break;
				dwLoc1C = dwLoc18 - 0x01;
				runtime.markroot(gs, dwLoc1C);
				eax_247 = ebp_332;
				ecx_235 = ebx_258;
			}
			else
			{
				Eq_4 edx_242;
				word32 ebp_173;
				ui24 ebx_24_8_191 = SLICE(runtime.scanobject(gs, eax_125, ecx_115, out ebp_173), word24, 8);
				Eq_4 ecx_184 = *((word32) dwArg04 + 20);
				Eq_4 edx_185 = *((word32) dwArg04 + 16);
				dwLoc1C = ecx_115;
				if ((byte) (SEQ(SLICE(ebp_173, word24, 8), edx_185 >= 2000) & SEQ(ebx_24_8_191, ecx_184 == 0x00) | SEQ(ebx_24_8_191, ecx_184 > 0x00)) == 0x00)
				{
					ecx_235 = ebx_258;
					edx_242 = ebp_332;
				}
				else
				{
					word32 ebp_450;
					word32 ebx_449;
					runtime/internal/atomic.Xaddint64(0x08157860, edx_185, ecx_184, out ebx_449, out ebp_450);
					ui64 edx_ecx_325 = SEQ(dwArg00->dw0014, dwArg00->dw0010) + SEQ(ebx_258, dwLoc10);
					dwArg00->dw0010 = 0x00;
					dwArg00->dw0014 = 0x00;
					dwLoc1C = edx_185;
					dwLoc18 = ecx_184;
					esp_231 = fp - 0x24;
					ecx_235 = (word32) edx_ecx_325;
					edx_242 = SLICE(edx_ecx_325, word32, 32);
				}
				eax_247 = edx_242;
			}
			eax_309 = esp_231->t001C;
			ecx_115 = esp_231->t0024;
			ebp_ebx_316 = SEQ(eax_247, ecx_235);
		}
		ebpOut = ebp_332;
		return ebx_258;
	}
}

// 08061240: Register Eq_27929 runtime.scanblock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_27929 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_27929 ebpOut, Register out Eq_4 esiOut)
// Called from:
//      runtime.markroot
//      runtime.markrootBlock
//      runtime.markrootSpans
//      runtime.scanframeworker
//      runtime.addfinalizer
Eq_27929 runtime.scanblock(struct Eq_2 * gs, Eq_4 dwArg04, Eq_27929 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_27929 & ebpOut, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	Eq_4 ecx_19 = g_t81493AC;
	Eq_27929 edx_124 = 0x00;
	eax_108 = eax_17;
	ecx_109 = ecx_19;
	while (true)
	{
		Eq_4 ecx_109;
		Eq_4 eax_108;
		Eq_27929 ebx_111 = dwArg08;
		if (edx_124 >= dwArg08)
			break;
		ebp = edx_124;
		esi = dwArg0C;
		word32 edx_117 = (word32) Mem25[(edx_124 >>u 0x05) + dwArg0C:byte];
		if (edx_117 == 0x00)
			edx_124 = (word32) edx_124.u1 + 32;
		else
		{
			int32 edi_115 = 0x00;
			while (true)
			{
				esi = dwArg0C;
				if (edi_115 >= 0x08 || ebp >= ebx_111)
					break;
				if ((edx_117 & 0x01) != 0x00)
				{
					word32 esi_61 = Mem58[dwArg04 + ebp:word32];
					if (esi_61 != 0x00 && (eax_108 <= esi_61 && esi_61 < ecx_109))
					{
						runtime.heapBitsForObject(gs, esi_61, dwArg04);
						if (dwLoc28 != 0x00)
						{
							word32 ebp_255;
							runtime.greyobject(gs, dwLoc28, dwLoc24, dwLoc20, dwLoc1C, dwArg10, dwLoc18, out ebp_255);
							dwLoc28 = dwLoc24;
							dwLoc24 = dwLoc20;
							dwLoc20 = dwLoc1C;
							dwLoc1C = dwArg10;
						}
						eax_108 = eax_17;
						ecx_109 = ecx_19;
						ebx_111 = dwArg08;
					}
				}
				++edi_115;
				edx_117 >>= 0x01;
				ebp = (word32) ebp + 4;
			}
			edx_124 = ebp;
		}
	}
	ebpOut = ebp;
	esiOut = esi;
	return dwArg08;
}

// 08061370: Register (ptr32 byte) runtime.scanobject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_4 ebpOut)
// Called from:
//      runtime.markrootSpans
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.addfinalizer
byte * runtime.scanobject(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_4 & ebpOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	uint32 ebx_21 = dwArg04 - eax_17;
	Eq_4 esi_23 = g_t81493A0;
	Eq_4 edx_18 = g_t81493AC;
	Eq_4 ebp_179 = dwArg04;
	byte * ebx_123 = esi_23 - (ebx_21 >> 0x04) - 0x01;
	Eq_4 esi_28 = g_t8149108;
	if (ebx_21 >> 0x0D >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		struct Eq_31286 * edx_305 = *((word32) esi_28 + (ebx_21 >> 0x0D) * 0x04);
		ptr32 esi_39 = edx_305->ptr0040;
		if (esi_39 == 0x00)
			runtime.throw(gs);
		else
		{
			ptr32 eax_101;
			if (esi_39 > 0x00020000)
			{
				if (dwArg04 == edx_305->t000C)
				{
					if (((byte) (word32) edx_305->b003A & 0x01) != 0x00)
					{
						Eq_4 ecx_71 = (word32) *((word32) dwArg08 + 8) + esi_39;
						Eq_4 edx_73 = *((word32) dwArg08 + 0x0C);
						*((word32) dwArg08 + 8) = ecx_71;
						Mem77[dwArg08 + 0x0C:word32] = edx_73 + (ecx_71 <u 0x00);
						ebpOut = dwArg04;
						return ebx_123;
					}
					Eq_4 esi_309 = (word32) dwArg04 + 0x00020000;
					while (true)
					{
						ebx_123 = esi_23 - (ebx_21 >> 0x04) - 0x01;
						if (esi_309 >= (word32) edx_305->t000C + edx_305->ptr0040)
							break;
						byte bl_285;
						struct Eq_31358 * edi_259 = *dwArg08;
						if (edi_259 != null)
						{
							uint32 ebx_266 = edi_259->dw000C;
							if (ebx_266 == 0x01FC)
								bl_285 = 0x00;
							else
							{
								if (ebx_266 >= 0x01FC)
									runtime.panicindex(gs);
								edi_259->a0010[ebx_266].t0000 = esi_309;
								++edi_259->dw000C;
								bl_285 = 0x01;
							}
						}
						else
							bl_285 = 0x00;
						if (bl_285 == 0x00)
						{
							runtime.(*gcWork).put(gs, dwArg08, esi_309);
							ebp_179 = dwArg04;
						}
						esi_309 = (word32) esi_309 + 0x00020000;
					}
				}
				eax_101 = (word32) edx_305->t000C + edx_305->ptr0040 - ebp_179;
				if (eax_101 > 0x00020000)
					eax_101 = 0x00020000;
			}
			else
				eax_101 = esi_39;
			uint32 edx_109 = ebx_21 >> 0x02 & 0x03;
			ptr32 esi_110 = 0x00;
			eax_114 = eax_101;
			while (true)
			{
				ptr32 eax_114;
				if (esi_110 >= eax_114)
					break;
				if (esi_110 != 0x00)
				{
					if (edx_109 < 0x03)
						++edx_109;
					else
					{
						--ebx_123;
						edx_109 = 0x00;
					}
				}
				uint32 edi_139 = (word32) *ebx_123 >> (byte) edx_109;
				if (esi_110 != 0x04 && (edi_139 & 0x10) == 0x00)
					break;
				if ((edi_139 & 0x01) != 0x00)
				{
					Eq_4 edi_182 = *((word32) ebp_179 + esi_110);
					if (edi_182 != 0x00 && (eax_17 <= edi_182 && (edi_182 < edx_18 && edi_182 - ebp_179 >= eax_114)))
					{
						runtime.heapBitsForObject(gs, edi_182, ebp_179);
						if (dwLoc40 != 0x00)
						{
							word32 ebp_543;
							runtime.greyobject(gs, dwLoc40, dwLoc3C, dwLoc38, dwLoc34, dwArg08, dwLoc30, out ebp_543);
							dwLoc40 = dwLoc3C;
							dwLoc3C = dwLoc38;
							dwLoc38 = dwLoc34;
							dwLoc34 = dwArg08;
						}
						eax_114 = eax_101;
						ebp_179 = dwArg04;
					}
				}
				esi_110 += 0x04;
			}
			Eq_4 eax_154 = (word32) *((word32) dwArg08 + 8) + eax_114;
			Eq_4 edx_156 = *((word32) dwArg08 + 0x0C);
			*((word32) dwArg08 + 8) = eax_154;
			Mem160[dwArg08 + 0x0C:word32] = edx_156 + (eax_154 <u 0x00);
			Eq_4 eax_163 = (word32) *((word32) dwArg08 + 16) + esi_110;
			Eq_4 edx_165 = *((word32) dwArg08 + 20);
			*((word32) dwArg08 + 16) = eax_163;
			Mem169[dwArg08 + 0x14:word32] = edx_165 + (eax_163 <u 0x00);
			ebpOut = ebp_179;
			return ebx_123;
		}
	}
}

// 08061640: void runtime.shade(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcmarkwb_m
void runtime.shade(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.heapBitsForObject(gs, dwArg04, 0x00);
	if (dwLoc18 != 0x00)
	{
		Eq_4 edi_44 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		Eq_4 ebp_61;
		Eq_363 ebx_24_8_86 = SLICE(runtime.greyobject(gs, dwLoc18, dwLoc14, dwLoc10, dwLoc0C, (word32) edi_44 + 0x0950, dwLoc08, out ebp_61), word24, 8);
		if (g_dw81575E4 == 0x02 || (byte) ((word32) g_b815756D) != 0x00)
			runtime.(*gcWork).dispose(ebx_24_8_86, ebp_61, gs, dwLoc28, (word32) edi_44 + 0x0950);
	}
}

// 08061710: Register Eq_4 runtime.greyobject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C, Stack Eq_4 dwArg20, Register out Eq_4 ebpOut)
// Called from:
//      runtime.scanblock
//      runtime.scanobject
//      runtime.shade
//      runtime.gcMarkTinyAllocs
Eq_4 runtime.greyobject(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C, Eq_4 dwArg20, union Eq_4 & ebpOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg04 & 0x03) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ebx_417;
		byte al_56 = (byte) (0x01 << (byte) (dwArg20 & 0x07));
		Eq_4 ebp_388 = (word32) *((word32) dwArg18 + 44) + (dwArg20 >> 0x03);
		if ((byte) (word32) g_b8157583 != 0x00)
		{
			if (((byte) (word32) *ebp_388 & al_56) == 0x00)
			{
				runtime.printlock(gs);
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_711;
				runtime.printhex(esi, gs, dwArg04, 0x00, out esi_711);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_712;
				runtime.printhex(esi, gs, dwArg08, 0x00, out esi_712);
				runtime.printstring(gs);
				word32 esi_713;
				runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_713);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.gcDumpObject(gs, dwArg08, dwArg0C);
				runtime.gcDumpObject(gs, dwArg04, ~0x00);
				*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 461) = 0x02;
				runtime.throw(gs);
			}
			Eq_4 ebp_340;
			Eq_4 eax_300 = *((word32) dwArg18 + 64);
			if (eax_300 == 0x04)
			{
				word32 ebp_343 = (word32) *dwArg10;
				ui32 ebp_359 = SEQ(SLICE(ebp_343, word24, 8), (byte) ebp_343 >> (byte) dwArg14) & 0x00 - (dwArg14 < 0x08);
				ebp_340 = SEQ(SLICE(ebp_359, word24, 8), ((byte) ebp_359 & 0x01) != 0x00);
			}
			else
			{
				word32 esi_304 = (word32) *dwArg10;
				ebp_340 = SEQ(SLICE(ebp_388, word24, 8), ((byte) (SEQ(SLICE(esi_304, word24, 8), (byte) esi_304 >> (byte) ((word32) dwArg14 + 1)) & 0x00 - (dwArg14 < 0x07)) & 0x10) != 0x00);
			}
			ebx_417 = dwArg18;
			ebp_388 = ebp_340;
			if ((byte) ebp_340 != 0x00)
			{
				ebpOut = ebp_340;
				return dwArg18;
			}
			Eq_31714 al_425;
			runtime.heapBits.setCheckmarked(gs, dwArg10, dwArg14, eax_300);
			if (*((word32) dwArg18 + 64) == 0x04)
			{
				word32 eax_427 = (word32) *dwArg10;
				al_425 = ((byte) (SEQ(SLICE(eax_427, word24, 8), (byte) eax_427 >> (byte) dwArg14) & 0x00 - (dwArg14 < 0x08)) & 0x01) != 0x00;
			}
			else
			{
				word32 edx_409 = (word32) *dwArg10;
				ebx_417 = 0x00 - (dwArg14 < 0x07);
				al_425 = ((byte) (SEQ(SLICE(edx_409, word24, 8), (byte) edx_409 >> (byte) ((word32) dwArg14 + 1)) & ebx_417) & 0x10) != 0x00;
			}
			if (al_425 == 0x00)
				runtime.throw(gs);
		}
		else
		{
			if (g_dw815772C > 0x00 && (dwArg20 >= *((word32) dwArg18 + 24) && (al_56 & SLICE((word32) Mem34[Mem34[dwArg18 + 0x28:word32] + (dwArg20 >>u 0x03):byte], byte, 0)) == 0x00))
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_714;
				runtime.printhex(esi, gs, dwArg04, 0x00, out esi_714);
				runtime.printstring(gs);
				word32 esi_715;
				runtime.printhex(esi, gs, dwArg08, 0x00, out esi_715);
				runtime.printstring(gs);
				word32 esi_716;
				runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_716);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.gcDumpObject(gs, dwArg08, dwArg0C);
				runtime.gcDumpObject(gs, dwArg04, ~0x00);
				*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 461) = 0x02;
				runtime.throw(gs);
			}
			word24 ebx_24_8_653 = SLICE(dwArg18, word24, 8);
			if (((byte) (word32) *ebp_388 & al_56) != 0x00)
			{
				ebpOut = ebp_388;
				return dwArg18;
			}
			runtime/internal/atomic.Or8(ebp_388, al_56);
			ebx_417 = SEQ(ebx_24_8_653, bl_163);
			if (((byte) (word32) *((word32) dwArg18 + 58) & 0x01) != 0x00)
			{
				word32 edx_178 = Mem162[dwArg1C + 0x08:word32] + Mem162[dwArg18 + 0x40:word32];
				Eq_4 eax_180 = *((word32) dwArg1C + 0x0C);
				*((word32) dwArg1C + 8) = edx_178;
				Mem184[dwArg1C + 0x0C:word32] = eax_180 + (edx_178 <u 0x00);
				ebpOut = ebp_388;
				return ebx_417;
			}
		}
		byte cl_487;
		struct Eq_31768 * ecx_460 = *dwArg1C;
		if (ecx_460 != null)
		{
			uint32 edx_467 = ecx_460->dw000C;
			if (edx_467 == 0x01FC)
				cl_487 = 0x00;
			else
			{
				if (edx_467 >= 0x01FC)
					runtime.panicindex(gs);
				ecx_460->a0010[edx_467].t0000 = dwArg04;
				++ecx_460->dw000C;
				ebx_417 = dwArg04;
				cl_487 = 0x01;
			}
		}
		else
			cl_487 = 0x00;
		if (cl_487 == 0x00)
			runtime.(*gcWork).put(gs, dwArg1C, dwArg04);
		ebpOut = ebp_388;
		return ebx_417;
	}
}

// 08061B90: void runtime.gcDumpObject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.heapBitsForObject
//      runtime.greyobject
void runtime.gcDumpObject(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	if (dwArg0C < eax_17 || dwArg0C >= g_t81493AC)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		word32 esi_721;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_721);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		return;
	}
	Eq_4 ecx_69 = (dwArg0C >> 0x0D) - (eax_17 >> 0x0D);
	Eq_4 ebp_71 = g_t8149108;
	if (ecx_69 >= g_t814910C)
		runtime.panicindex(gs);
	struct Eq_31962 * eax_79 = *((word32) ebp_71 + ecx_69 * 0x04);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	word32 esi_722;
	runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_722);
	runtime.printstring(gs);
	word32 esi_723;
	runtime.printhex(esi, gs, dwArg0C >> 0x0D, 0x00, out esi_723);
	runtime.printunlock(gs);
	if (eax_79 == null)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		return;
	}
	Eq_4 ecx_146 = (word32) eax_79->b003A;
	Eq_4 edx_148 = eax_79->t0050;
	Eq_4 ebx_150 = eax_79->t0040;
	Eq_4 ebp_152 = eax_79->t000C;
	runtime.printlock(gs);
	runtime.printstring(gs);
	word32 esi_724;
	runtime.printhex(esi, gs, ebp_152, 0x00, out esi_724);
	runtime.printstring(gs);
	word32 esi_725;
	runtime.printhex(esi, gs, edx_148, 0x00, out esi_725);
	runtime.printstring(gs);
	runtime.printint(SLICE(ebx_150, word24, 8), gs, ecx_146);
	runtime.printstring(gs);
	runtime.printint(SLICE(ebx_150, word24, 8), gs, ebx_150);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	byte cl_227 = (byte) (word32) eax_79->b003C;
	if (Test(UGE,false))
	{
		Eq_4 edx_231 = (word32) cl_227;
		ebx_150 = g_t81426E4;
		if (edx_231 < ebx_150)
		{
			if (edx_231 >= ebx_150)
				runtime.panicindex(gs);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
l08061DCC:
			Eq_4 ecx_305 = eax_79->t0040;
			if ((byte) (word32) eax_79->b003C == 0x02 && ecx_305 == 0x00)
				ecx_305 = (word32) dwArg10 + 4;
			Eq_4 eax_356 = dwArg10;
			Eq_4 edx_322 = 0x00;
			byte bl_330 = 0x00;
			ecx_327 = ecx_305;
			while (true)
			{
				Eq_4 ecx_327;
				if (edx_322 >= ecx_327)
					break;
				if (edx_322 >= 0x0200 && (eax_356 - 0x40 >= edx_322 || edx_322 >= (word32) eax_356 + 64))
					bl_330 = 0x01;
				else
				{
					uint32 ebx_718 = (uint32) (uint8) bl_330;
					if (bl_330 != 0x00)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printunlock(gs);
					}
					word32 ecx_392 = Mem388[edx_322 + dwArg0C:word32];
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printint(SLICE(ebx_718, word24, 8), gs, edx_322);
					runtime.printstring(gs);
					word32 esi_726;
					runtime.printhex(esi, gs, ecx_392, 0x00, out esi_726);
					runtime.printunlock(gs);
					if (edx_322 == dwArg10)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printunlock(gs);
					}
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					eax_356 = dwArg10;
					ecx_327 = ecx_305;
					bl_330 = 0x00;
				}
				edx_322 = (word32) edx_322 + 4;
			}
			if (bl_330 != 0x00)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
			}
			return;
		}
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(SLICE(ebx_150, word24, 8), gs, (word32) (byte) (word32) cl_227);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	goto l08061DCC;
}

// 08062070: void runtime.gcmarknewobject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.mallocgc
void runtime.gcmarknewobject(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	if ((byte) (word32) g_b8157583 == 0x00 || (byte) ((word32) g_b815756D) != 0x00)
	{
		runtime.markBitsForAddr(gs, dwArg04);
		runtime.markBits.setMarked(gs, dwLoc0C, (byte) (word32) bLoc08);
		Eq_4 ecx_48 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		word32 eax_55 = Mem38[ecx_48 + 2392:word32] + dwArg08;
		word32 ebx_57 = *((word32) ecx_48 + 0x095C);
		*((word32) ecx_48 + 2392) = eax_55;
		*((word32) ecx_48 + 0x095C) = (bool) (eax_55 < 0x00) + ebx_57;
		word32 eax_64 = Mem61[ecx_48 + 0x0960:word32] + dwArg0C;
		word32 ebx_66 = *((word32) ecx_48 + 2404);
		*((word32) ecx_48 + 2400) = eax_64;
		*((word32) ecx_48 + 2404) = (bool) (eax_64 < 0x00) + ebx_66;
		if ((byte) (word32) g_b815756D != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.(*gcWork).dispose(ebx, ebp, gs, stackArg0, (word32) ecx_48 + 0x0950);
		}
	}
	else
		runtime.throw(gs);
}

// 08062150: void runtime.gcMarkTinyAllocs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
void runtime.gcMarkTinyAllocs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	word32 * ecx_20 = g_a81478C0;
	for (eax_17 = 0x00; eax_17 < 0x0401; ++eax_17)
	{
		Eq_4 edx_26 = *ecx_20;
		if (edx_26 == 0x00 || *((word32) edx_26 + 8) == 0x04)
			return;
		Eq_4 ebx_37 = *((word32) edx_26 + 52);
		if (ebx_37 != 0x00)
		{
			Eq_4 ebp_41 = *((word32) ebx_37 + 8);
			if (ebp_41 != 0x00)
			{
				runtime.heapBitsForObject(gs, ebp_41, 0x00);
				Eq_4 ebp_62 = *((word32) ebx_37 + 8);
				word32 ebp_173;
				runtime.greyobject(gs, ebp_62, dwLoc24, dwLoc20, dwLoc1C, (word32) edx_26 + 0x0950, dwLoc18, out ebp_173);
				dwLoc24 = dwLoc20;
				dwLoc20 = dwLoc1C;
				dwLoc1C = (word32) edx_26 + 0x0950;
				if ((byte) (word32) g_b815756D != 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg0 = <invalid>;
					runtime.(*gcWork).dispose(SLICE(dwLoc18, word24, 8), ebp_62, gs, stackArg0, (word32) edx_26 + 0x0950);
				}
			}
		}
		++ecx_20;
	}
}

// 08062260: void runtime.initCheckmarks(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination.func2
void runtime.initCheckmarks(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_b8157583 = 0x01;
	word32 * eax_109 = g_ptr81490FC;
	int32 ecx_19 = g_dw8149100;
	int32 edx_112 = 0x00;
	ecx_106 = ecx_19;
	while (true)
	{
		int32 ecx_106;
		if (edx_112 >= ecx_106)
			break;
		struct Eq_32356 * ebx_33 = *eax_109;
		if ((byte) (word32) ebx_33->b003C == 0x01)
		{
			uint32 eax_70;
			runtime.heapBitsForSpan(esi, gs, ebx_33->t000C);
			ui32 ebx_61 = ebx_33->dw0010;
			byte * edx_63 = ebx_33->ptr0040;
			if (edx_63 > null)
				eax_70 = (uint32) ((uint64) (uint32) (ebx_61 << 0x0D) /u edx_63);
			else
				eax_70 = 0x00;
			dwLoc20 = dwLoc1C;
			dwLoc1C = edx_63;
			esi = runtime.heapBits.initCheckmarkSpan(gs, dwLoc20, dwLoc1C, edx_63, eax_70);
			ecx_106 = ecx_19;
		}
		++eax_109;
		++edx_112;
	}
}

// 08062320: void runtime.clearCheckmarks(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination.func2
void runtime.clearCheckmarks(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_b8157583 = 0x00;
	word32 * eax_104 = g_ptr81490FC;
	int32 ecx_19 = g_dw8149100;
	int32 edx_107 = 0x00;
	ecx_101 = ecx_19;
	while (true)
	{
		int32 ecx_101;
		if (edx_107 >= ecx_101)
			break;
		struct Eq_32426 * ebx_33 = *eax_104;
		if ((byte) (word32) ebx_33->b003C == 0x01)
		{
			runtime.heapBitsForSpan(esi, gs, ebx_33->t000C);
			Eq_4 edx_63 = ebx_33->t0040;
			runtime.heapBits.clearCheckmarkSpan(gs);
			esi = edx_63;
			ecx_101 = ecx_19;
		}
		++eax_104;
		++edx_107;
	}
}

// 080623E0: Register word32 runtime.finishsweep_m(Register (ptr32 Eq_2) gs, Register Eq_661 xmm2, Register out Eq_32458 xmm0Out, Register out Eq_661 xmm2Out)
// Called from:
//      runtime.gcStart.func1
//      runtime.gcMarkTermination.func2
word32 runtime.finishsweep_m(struct Eq_2 * gs, Eq_661 xmm2, union Eq_32458 & xmm0Out, union Eq_661 & xmm2Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	while (true)
	{
		Eq_32458 xmm0_27;
		Eq_4 esi_31 = runtime.sweepone(gs, xmm2, dwLoc08, out xmm0_27, out xmm2);
		if (dwLoc04 == ~0x00)
			break;
		++g_dw81451F0;
	}
	word32 esi_51 = runtime.nextMarkBitArenaEpoch(esi_31, gs);
	xmm0Out = xmm0_27;
	xmm2Out = xmm2;
	return esi_51;
}

// 08062430: void runtime.bgsweep(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.bgsweep(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = gs->ptr0000->tFFFFFFFC;
	if (g_t81576F0 == 0x00)
		g_t81451E4 = ecx_19;
	else
		runtime.writebarrierptr(135549412, ecx_19);
	word32 ebp_46;
	Eq_4 esi_48;
	word32 edi_210;
	runtime.lock(esi, gs, 0x081451E0, out ebp_46, out esi_48, out edi_210);
	g_b81451E8 = 0x01;
	Eq_4 esi_104 = runtime.chansend1(ebp_46, esi_48, gs, dwArg04, 0x080F181C);
	runtime.goparkunlock(gs);
	while (true)
	{
		runtime.gosweepone(gs);
		if (false)
		{
			while (true)
			{
				Eq_4 esi_119 = runtime.freeSomeWbufs(esi_104, gs);
				if (false)
					break;
				esi_104 = runtime.Gosched(gs);
			}
			word32 edi_212;
			word32 ebp_211;
			runtime.lock(esi_119, gs, 0x081451E0, out ebp_211, out esi_104, out edi_212);
			if (g_t81490F4 != 0x00)
			{
				g_b81451E8 = 0x01;
				runtime.goparkunlock(gs);
			}
			else
			{
				word32 edx_213;
				word32 ebx_214;
				runtime.unlock(gs, 0x081451E0, out edx_213, out ebx_214);
			}
		}
		else
		{
			++g_dw81451EC;
			esi_104 = runtime.Gosched(gs);
		}
	}
}

// 08062580: Register Eq_4 runtime.sweepone(Register (ptr32 Eq_2) gs, Register Eq_661 xmm2, Stack (ptr32 Eq_26066) dwArg00, Register out Eq_5374 xmm0Out, Register out Eq_661 xmm2Out)
// Called from:
//      runtime.gcSweep
//      runtime.finishsweep_m
//      runtime.(*mheap).reclaim
//      runtime.gosweepone.func1
Eq_4 runtime.sweepone(struct Eq_2 * gs, Eq_661 xmm2, struct Eq_26066 * dwArg00, union Eq_5374 & xmm0Out, union Eq_661 & xmm2Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_21 = *((word32) eax_19 + 24);
	Eq_5374 xmm0_22 = (uint128) (uint64) g_r8149160;
	*((word32) ecx_21 + 0x0078) = (word32) *((word32) ecx_21 + 0x0078) + 1;
	runtime/internal/atomic.Load();
	Eq_4 dwLoc04_453 = eax_19;
	Eq_4 esp_123 = fp - 0x44;
	if (dwLoc40 != 0x00)
	{
		struct Eq_32629 * eax_37 = dwArg00->ptr0018;
		--eax_37->dw0078;
		xmm0Out = xmm0_22;
		xmm2Out = xmm2;
		return esi;
	}
	else
	{
		runtime/internal/atomic.Xadd(135565560, 0x01);
		Eq_4 dwLoc40_462 = 0x01;
		Eq_4 eax_54 = g_t81490F0;
		while (true)
		{
			uint32 eax_60 = 0x01 - (eax_54 >> 0x01 & 0x01);
			if (eax_60 >= 0x02)
				break;
			Eq_4 eax_134;
			Eq_363 ebx_24_8_364 = SLICE(runtime.(*gcSweepBuf).pop(gs, eax_60 * 0x14 + 135565588), word24, 8);
			if (dwLoc40_462 == 0x00)
			{
				runtime/internal/atomic.Store(135565556, 0x01);
				eax_134.u0 = ~0x00;
				goto l080626B3;
			}
			byte cl_88 = (byte) (word32) *((word32) dwLoc40_462 + 60);
			if (cl_88 != 0x01)
			{
				Eq_4 eax_337 = *((word32) dwLoc40_462 + 48);
				if (eax_337 != eax_54)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_364, gs, (uint64) (uint32) (word32) (byte) (word32) cl_88);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_364, gs, (uint64) (uint32) eax_337);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_364, gs, (uint64) (uint32) eax_54);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				goto l080625FE;
			}
			if (*((word32) dwLoc40_462 + 48) == eax_54 - 0x02)
			{
				runtime/internal/atomic.Cas((word32) dwLoc40_462 + 48, eax_54 - 0x02, eax_54 - 0x01);
				dwLoc04_453 = dwLoc40_462;
				dwLoc40_462 = eax_54 - 0x02;
				if ((byte) (word32) bLoc38 == 0x00)
					goto l08062660;
				esi = runtime.(*mspan).sweep(gs, 135565556, (byte) dwLoc40_462);
				esp_123.u0 = <invalid>;
				if ((byte) (word32) *((byte) esp_123.u0 + 8) != 0x00)
					eax_134 = *((byte) esp_123.u0 + 24);
				else
					eax_134.u0 = 0x00;
l080626B3:
				*((word32) esp_123 + 24) = eax_134;
				esp_123->u0 = 135565560;
				((word32) esp_123 + 4)->u0 = ~0x00;
				runtime/internal/atomic.Xadd(*esp_123, *((word32) esp_123 + 4));
				if (*((word32) esp_123 + 8) == 0x00)
				{
					esp_123->u0 = 135565556;
					runtime/internal/atomic.Load();
					struct Eq_32758 * esp_158 = (word32) esp_123 + 4;
					if (esp_158->t0004 != 0x00 && g_dw8157730 > 0x00)
					{
						Eq_4 eax_166 = g_t81597B0;
						esp_158->t0034 = eax_166;
						Eq_4 ecx_168 = g_t8149158;
						esp_158->t0030 = ecx_168;
						esp_158->dw002C = eax_166 - ecx_168;
						esp_158->t0028 = g_t81597B4;
						Eq_4 ebp_175 = g_t814915C;
						esp_158->t0024 = ebp_175;
						esi = g_t814914C;
						esp_158->t0020 = esi;
						esp_158->dw001C = g_dw8149148;
						runtime.printlock(gs);
						esp_158->dw0000 = 135156169;
						esp_158->t0004.u0 = 0x1F;
						runtime.printstring(gs);
						Eq_4 edx_200 = esp_158->t0028;
						esp_158->dw0000 = edx_200 << 0x0C | esp_158->t0034 >> 0x14;
						esp_158->t0004 = edx_200 >> 0x14;
						Eq_4 ebp_209 = runtime.printuint(ebp_175, gs, esp_158->dw0000, esp_158->t0004);
						esp_158->dw0000 = 0x080E208C;
						esp_158->t0004.u0 = 0x0E;
						runtime.printstring(gs);
						uint32 eax_235 = SLICE(SEQ(esp_158->t0028, esp_158->t0034) - SEQ(esp_158->t0024, esp_158->t0030), word32, 32);
						esp_158->dw0000 = eax_235 << 0x0C | esp_158->dw002C >> 0x14;
						esp_158->t0004 = eax_235 >> 0x14;
						Eq_4 ebp_246 = runtime.printuint(ebp_209, gs, esp_158->dw0000, esp_158->t0004);
						esp_158->dw0000 = 0x080E383B;
						esp_158->t0004.u0 = 0x17;
						runtime.printstring(gs);
						esp_158->dw0000 = esp_158->dw001C;
						esp_158->t0004 = esp_158->t0020;
						runtime.printuint(ebp_246, gs, esp_158->dw0000, esp_158->t0004);
						esp_158->dw0000 = 0x080E180F;
						esp_158->t0004.u0 = 0x0A;
						runtime.printstring(gs);
						esp_158->dw0000 = (word32) (real64) (uint128) (uint64) esp_158->r0038;
						xmm0_22 = runtime.printfloat(gs, xmm2, esp_158->dw0000, out xmm2);
						esp_158->dw0000 = 135142463;
						esp_158->t0004.u0 = 0x0C;
						runtime.printstring(gs);
						runtime.printunlock(gs);
					}
				}
				Eq_4 eax_326 = *((word32) dwLoc04_453 + 24);
				--*((word32) eax_326 + 0x0078);
				xmm0Out = xmm0_22;
				xmm2Out = xmm2;
				return esi;
			}
l080625FE:
		}
		runtime.panicindex(gs);
	}
}

// 08062960: void runtime.gosweepone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.bgsweep
//      runtime.deductSweepCredit
void runtime.gosweepone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_42;
	word32 edi_43;
	runtime.systemstack(gs, fp - 0x08, out ebp_42, out edi_43);
}

// 080629B0: Register Eq_4 runtime.(*mspan).ensureSwept(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_33030) dwArg04, Stack Eq_33031 bArg08)
// Called from:
//      runtime.addspecial
//      runtime.removespecial
Eq_4 runtime.(*mspan).ensureSwept(struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_33030 * dwArg04, Eq_33031 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (*((word32) ecx_19 + 0x0078) != 0x00 || (*((word32) ecx_19 + 0x0068) != 0x00 || eax_18 == *ecx_19))
	{
		Eq_4 ecx_46 = g_t81490F0;
		runtime/internal/atomic.Load();
		byte bLoc08_125 = (byte) ecx_46;
		if (dwLoc10 == (char *) (&dwArg04->t000C) + 36)
			return esi;
		runtime/internal/atomic.Cas(dwArg00, (char *) &dwArg04->t000C + 0x0022, (char *) &dwArg04->t000C + 35);
		if ((byte) (word32) bLoc08_125 != 0x00)
			return runtime.(*mspan).sweep(gs, (char *) &dwArg04->t000C + 36, (byte) dwArg08);
		while (true)
		{
			runtime/internal/atomic.Load();
			if (dwArg00 == ecx_46)
				break;
			runtime.osyield();
		}
		return esi;
	}
	else
		runtime.throw(gs);
}

// 08062AA0: Register Eq_4 runtime.(*mspan).sweep(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack byte bArg04)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.sweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*mheap).reclaimList
Eq_4 runtime.(*mspan).sweep(struct Eq_2 * gs, Eq_4 dwArg00, byte bArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8A(0x00, fp - 0x18);
	Eq_4 eax_24 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_25 = *((word32) eax_24 + 24);
	if (*((word32) ecx_25 + 0x0078) == 0x00 && (*((word32) ecx_25 + 0x0068) == 0x00 && eax_24 != *ecx_25))
		runtime.throw(gs);
	word32 ebx_51 = (word32) *((word32) dwArg00 + 60);
	Eq_4 ecx_47 = g_t81490F0;
	byte bl_52 = (byte) ebx_51;
	Eq_363 ebx_24_8_90 = SLICE(ebx_51, word24, 8);
	if (bl_52 != 0x01 || ecx_47 - 0x01 != *((word32) dwArg00 + 48))
	{
		Eq_4 eax_63 = *((word32) dwArg00 + 48);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_90, gs, (uint64) (uint32) (word32) (byte) (word32) bl_52);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_90, gs, (uint64) (uint32) eax_63);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_90, gs, (uint64) (uint32) ecx_47);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGCSweepSpan(gs, *((word32) dwArg00 + 16) << 0x0D);
	Eq_4 eax_191 = *((word32) dwArg00 + 16);
	word32 ebx_1638;
	word32 ebp_1639;
	runtime/internal/atomic.Xadd64(0x08149148, eax_191, 0x00, out ebx_1638, out ebp_1639);
	Eq_4 dwLoc70_1207 = eax_191;
	Eq_4 edx_1135 = (word32) dwArg00 + 88;
	byte bl_214 = (byte) (word32) *((word32) dwArg00 + 58);
	Eq_4 ebp_216 = *((word32) dwArg00 + 64);
	Eq_4 eax_218 = *((word32) *((word32) eax_24 + 24) + 0x00B8);
	Eq_4 esi_1004 = *((word32) dwArg00 + 88);
	ebp_1062 = ebp_216;
	while (true)
	{
		Eq_4 ebp_1062;
		Eq_4 ecx_1140 = dwArg00;
		if (esi_1004 == 0x00)
			break;
		word32 edi_971 = (word32) *((word32) esi_1004 + 4);
		if (ebp_1062 == 0x00)
			runtime.panicdivide(gs);
		Eq_4 edx_1067;
		Eq_33269 eax_982 = (uint32) ((uint64) (uint32) edi_971 /u ebp_1062);
		byte * edx_986 = (word32) *((word32) dwArg00 + 44) + (eax_982 >> 0x03);
		ui32 ebx_993 = 0x01 << (byte) (eax_982 & 0x07);
		ui32 edx_995 = (word32) *edx_986;
		int32 edi_988 = eax_982 *s ebp_1062;
		if (((byte) edx_995 & (byte) ebx_993) != 0x00)
			edx_1067 = *esi_1004;
		else
		{
			Eq_33299 edi_1001 = (word32) ebp_1062 + edi_988;
			Eq_4 ecx_1003 = esi_1004;
			while (true)
			{
				byte al_1044;
				if (esi_1004 == 0x00)
					break;
				if ((word32) *((word32) esi_1004 + 4) >= edi_1001)
				{
					al_1044 = 0x00;
					goto l08062C0F;
				}
				if ((byte) (word32) *((word32) esi_1004 + 6) == 0x01)
				{
					*edx_986 = (byte) (edx_995 | ebx_993);
					al_1044 = 0x01;
					goto l08062C0F;
				}
				esi_1004 = *esi_1004;
			}
			al_1044 = 0x00;
l08062C0F:
			Eq_4 edx_1049 = edx_1135;
			uint32 eax_1073 = (uint32) (uint8) al_1044;
			edi_1056 = edi_1001;
			while (true)
			{
				Eq_33299 edi_1056;
				if (ecx_1003 == 0x00)
					break;
				Eq_33299 ebx_1055 = (word32) *((word32) ecx_1003 + 4);
				if (ebx_1055 >= edi_1056)
					break;
				Eq_4 edx_1117;
				Eq_4 esi_1071 = (word32) *((word32) ecx_1003 + 6);
				word32 ebx_1070 = ebx_1055 + Mem1054[dwArg00 + 0x0C:word32];
				byte al_1082 = (byte) eax_1073;
				if ((byte) esi_1071 != 0x01 && al_1082 != 0x00)
					edx_1117 = *ecx_1003;
				else
				{
					Eq_4 eax_1090 = *ecx_1003;
					*edx_1049 = eax_1090;
					runtime.freespecial(esi_1071, gs, ecx_1003, ebx_1070, ebp_216);
					dwLoc70_1207 = ebx_1070;
					eax_1073 = (word32) al_1044;
					edi_1056 = edi_1001;
					edx_1117 = eax_1090;
					ecx_1003 = edx_1049;
				}
				ecx_1003 = edx_1117;
				edx_1049 = ecx_1003;
			}
			ebp_1062 = ebp_216;
			esi_1004 = edx_1049;
			edx_1067 = ecx_1003;
		}
		esi_1004 = edx_1067;
		edx_1135 = esi_1004;
	}
	if (g_dw8157720 != 0x00)
	{
		Eq_4 dwLoc1C_1215 = *((word32) dwArg00 + 44);
		byte bLoc18_1216 = 0x01;
		Eq_4 dwLoc10_1218 = *((word32) dwArg00 + 40);
		byte bLoc0C_1219 = 0x01;
		Eq_4 dwLoc08_1220 = 0x00;
		Eq_4 edx_240 = 0x00;
		while (edx_240 < *((word32) ecx_1140 + 28))
		{
			if (((byte) (word32) bLoc18_1216 & (byte) ((word32) (*dwLoc1C_1215))) == 0x00 && (dwLoc08_1220 < *((word32) ecx_1140 + 24) || ((byte) ((word32) bLoc0C_1219) & (byte) ((word32) (*dwLoc10_1218))) != 0x00))
			{
				Eq_4 esi_871 = (word32) *((word32) ecx_1140 + 0x0C) + *((word32) ecx_1140 + 64) *s edx_240;
				if (g_dw8157720 != 0x00)
				{
					runtime.tracefree(esi_871, gs, ebp_1062);
					dwLoc70_1207 = ebp_1062;
					ecx_1140 = dwArg00;
					ebp_1062 = ebp_216;
				}
			}
			ui32 esi_903 = (word32) bLoc18_1216;
			if ((byte) esi_903 == 0x80)
			{
				dwLoc1C_1215 = (word32) dwLoc1C_1215 + 1;
				bLoc18_1216 = 0x01;
			}
			else
				bLoc18_1216 = (byte) (esi_903 << 0x01);
			ui32 esi_935 = (word32) bLoc0C_1219;
			if ((byte) esi_935 == 0x80)
			{
				dwLoc10_1218 = (word32) dwLoc10_1218 + 1;
				bLoc0C_1219 = 0x01;
			}
			else
				bLoc0C_1219 = (byte) (esi_935 << 0x01);
			dwLoc08_1220 = (word32) dwLoc08_1220 + 1;
			edx_240 = (word32) edx_240 + 1;
		}
	}
	word32 ebp_276;
	runtime.(*mspan).countAlloc(gs, ecx_1140);
	word16 ax_279 = (word16) dwLoc70_1207;
	bcu8 cl_270 = (byte) (word32) bl_214;
	if (cl_270 >> 0x01 == 0x00)
	{
		if (ax_279 == 0x00)
		{
			*((word32) dwArg00 + 61) = 0x01;
			ebp_276 = 0x01;
		}
		else
			ebp_276 = 0x00;
	}
	else
		ebp_276 = 0x00;
	word32 esi_292 = (word32) *((word32) dwArg00 + 56);
	Eq_363 ebx_24_8_329 = SLICE(dwArg00, word24, 8);
	cup16 di_302 = (word16) esi_292;
	word16 si_298 = (word16) (esi_292 - dwLoc70_1207);
	if ((word16) dwLoc70_1207 > di_302)
	{
		Eq_4 eax_307 = *((word32) dwArg00 + 28);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_329, gs, (uint64) (uint32) eax_307);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_329, gs, (uint64) (uint32) (word32) (word16) dwLoc70_1207);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_329, gs, (uint64) (uint32) (word32) (word16) (word32) di_302);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_329, gs, (uint64) (uint32) (word32) (word16) (word32) si_298);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	*((word32) dwArg00 + 56) = (word16) dwLoc70_1207;
	Eq_4 esi_449 = runtime.(*mspan).nextFreeIndex(gs, dwArg00);
	Eq_4 edx_457 = *((word32) dwArg00 + 28);
	((word32) dwArg00 + 24)->u0 = 0x00;
	byte al_435 = (byte) ebp_276;
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		Eq_4 ebp_468 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		esi_449 = (word32) si_298;
		*((word32) ebp_468 + 0x0934) = (word32) *((word32) ebp_468 + 0x0934) + *((word32) dwArg00 + 64) *s (word32) ((word16) esi_449);
	}
	*((word32) dwArg00 + 40) = *((word32) dwArg00 + 44);
	runtime.newMarkBits(esi_449, gs, *((word32) dwArg00 + 28));
	*((word32) dwArg00 + 44) = dwLoc70_1207;
	Eq_4 esi_1623;
	Eq_363 ebx_24_8_567 = SLICE(runtime.(*mspan).refillAllocCache(gs, dwArg00, 0x00, out esi_1623), word24, 8);
	if ((byte) (word32) al_435 == 0x00 && (word16) ((word32) si_298) != 0x00)
	{
l08062EE4:
		uip32 eax_1635;
		bool Z_671;
		word32 eax_652 = (word32) si_298;
		if ((word16) eax_652 > 0x00)
		{
			byte cl_663 = (byte) (word32) (cl_270 >> 0x01);
			if (cl_663 != 0x00)
			{
				Eq_33662 ecx_731 = (int32) cl_663;
				word16 ax_736 = (word16) eax_652;
				if (ecx_731 >= 0x43)
					runtime.panicindex(gs);
				*((word32) eax_218 + (ecx_731 * 0x04 + 600)) = (word32) *((word32) eax_218 + (ecx_731 * 0x04 + 600)) + (word32) ax_736;
				uint32 eax_742 = (word32) (byte) (word32) bl_214;
				if (eax_742 >= 0x86)
					runtime.panicindex(gs);
				esi_1623 = runtime.(*mcentral).freeSpan(esi_1623, gs, (eax_742 << 0x06) + 135566272, dwArg00, (byte) (word32) bArg04, dwLoc70_1207 == edx_457);
				eax_1635 = (word32) bLoc68;
l08062F76:
				if ((byte) eax_1635 == 0x00)
					esi_1623 = runtime.(*gcSweepBuf).push(esi_1623, gs, dwLoc78, (ecx_47 >> 0x01 & 0x01) * 0x14 + 135565588, dwArg00);
				return esi_1623;
			}
			Z_671 = SLICE(cond((byte) (word32) al_435), bool, 2);
		}
		else
			Z_671 = SLICE(cond((byte) (word32) al_435), bool, 2);
		if (!Z_671)
		{
			if (g_dw8157728 > 0x00)
			{
				((word32) dwArg00 + 80)->u0 = 0x00;
				esi_1623 = runtime.sysFault(gs);
			}
			else
				runtime.(*mheap).freeSpan(gs);
			*((word32) eax_218 + 596) = (word32) *((word32) eax_218 + 596) + 1;
			Mem726[eax_218 + 0x0250:word32] = Mem721[eax_218 + 0x0250:word32] + ebp_216;
			eax_1635 = 0x01;
		}
		else
			eax_1635 = 0x00;
		goto l08062F76;
	}
	else
	{
		byte dl_531 = (byte) (word32) *((word32) dwArg00 + 60);
		if (dl_531 == 0x01)
		{
			Eq_4 ebx_535 = *((word32) dwArg00 + 48);
			ebx_24_8_567 = SLICE(ebx_535, word24, 8);
			if (ecx_47 - 0x01 == ebx_535)
			{
				runtime/internal/atomic.Store((word32) dwArg00 + 48, ecx_47);
				goto l08062EE4;
			}
		}
		Eq_4 eax_541 = *((word32) dwArg00 + 48);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_567, gs, (uint64) (uint32) (word32) (byte) (word32) dl_531);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_567, gs, (uint64) (uint32) eax_541);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_567, gs, (uint64) (uint32) ecx_47);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 08063340: Register Eq_4 runtime.deductSweepCredit(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm1, Stack ui32 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.largeAlloc
//      runtime.(*mcentral).cacheSpan
Eq_4 runtime.deductSweepCredit(Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm1, ui32 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint128 xmm0_17 = (uint128) (uint64) g_r8149160;
	Eq_661 xmm1_22 = __xorps(xmm1, xmm1);
	if ((real64) xmm0_17 == xmm1_22 && !PARITY_EVEN((real64) xmm0_17 - xmm1_22))
		return esi;
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		runtime.traceGCSweepStart(gs);
		__xorps(xmm1_22, xmm1_22);
	}
	while (true)
	{
		word64 mm0_349;
		runtime/internal/atomic.Load64(135565648, out mm0_349);
		word64 mm0_350;
		runtime/internal/atomic.Load64(135632816, out mm0_350);
		real64 rLoc08_246 = (real64) (uint128) (uint64) g_r8149160;
		runtime.uint32tofloat64();
		real64 v21_87 = (real64) (uint128) (uint64) rLoc08_246 * (real64) ((uint128) ((uint64) SEQ(dwLoc20, dwLoc24_353)));
		Eq_661 xmm0_94;
		runtime.float64toint64(gs, v21_87, out xmm0_94);
		up32 eax_101 = dwLoc20 - dwArg08;
		dwLoc24 = SLICE(v21_87, word32, 32);
		int32 edx_106 = dwLoc1C - (eax_101 < 0x00);
		do
		{
			word64 mm0_351;
			runtime/internal/atomic.Load64(0x08149148, out mm0_351);
			ui64 edx_eax_238 = SEQ(dwLoc20, dwLoc24) - SEQ(dwLoc20, dwLoc24_353);
			up32 eax_121 = (word32) edx_eax_238;
			int32 edx_126 = SLICE(edx_eax_238, word32, 32);
			Eq_4 esi_152 = SEQ(SLICE(esi, word24, 8), edx_106 == edx_126) & SEQ(SLICE(eax_121, word24, 8), eax_101 > eax_121) | SEQ(SLICE(eax_121, word24, 8), edx_106 > edx_126);
			esi = esi_152;
			if ((byte) esi_152 == 0x00)
			{
l080634A9:
				if ((byte) (word32) g_b814F4C8 != 0x00)
					esi = runtime.traceGCSweepDone(gs);
				return esi;
			}
			runtime.gosweepone(gs);
			if (0x08149148 == ~0x00)
			{
				g_r8149160 = (real64) __xorps(xmm0_94, xmm0_94);
				goto l080634A9;
			}
			word64 mm0_352;
			runtime/internal/atomic.Load64(135565648, out mm0_352);
			dwLoc24_353 = dwLoc24;
		} while ((byte) (SEQ(SLICE(dwLoc20, word24, 8), dwLoc20 != dwLoc20) | SEQ(SLICE(dwLoc24, word24, 8), dwLoc24 != dwLoc24_353)) == 0x00);
	}
}

// 080634E0: Register Eq_4 runtime.(*gcSweepBuf).push(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mspan).sweep
//      runtime.(*mheap).alloc_m
Eq_4 runtime.(*gcSweepBuf).push(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xadd((word32) dwArg04 + 16, 0x01);
	runtime/internal/atomic.Loaduintptr();
	uint32 eax_42 = dwLoc24 - 0x01 >> 0x09;
	while (true)
	{
		Eq_4 eax_209;
		if (eax_42 < 0x01)
			break;
		word32 ebp_71;
		word32 edi_332;
		runtime.lock(esi, gs, dwArg04, out ebp_71, out esi, out edi_332);
		runtime/internal/atomic.Loaduintptr();
		if (eax_42 >= 0x01)
		{
			Eq_4 ebx_101 = *((word32) dwArg04 + 0x0C);
			if (ebx_101 == 0x01)
			{
				Eq_4 ebx_104 = ebx_101 << 0x01;
				if (ebx_101 << 0x01 == 0x00)
					ebx_104.u0 = 0x0100;
				runtime.persistentalloc(gs);
				Eq_4 edx_129 = *((word32) dwArg04 + 0x0C);
				if (edx_129 != 0x00)
				{
					word32 ebp_145;
					word32 edi_336;
					runtime.memmove(dwLoc20, *((word32) dwArg04 + 4), edx_129 << 0x02, out ebp_145, out esi, out edi_336);
					dwLoc0C = dwLoc20;
				}
				runtime/internal/atomic.StorepNoWB((word32) dwArg04 + 4, dwLoc20);
				*((word32) dwArg04 + 0x0C) = ebx_104;
			}
			runtime.persistentalloc(gs);
			runtime/internal/atomic.StorepNoWB((word32) *((word32) dwArg04 + 4) + eax_42 * 0x04, dwLoc20);
			runtime/internal/atomic.Storeuintptr((word32) dwArg04 + 8, 0x02);
			word32 ebx_201;
			word32 edx_335;
			runtime.unlock(gs, dwArg00, out edx_335, out ebx_201);
			eax_209 = dwLoc0C;
			goto l08063656;
		}
		word32 ebx_334;
		word32 edx_333;
		runtime.unlock(gs, dwArg04, out edx_333, out ebx_334);
	}
	runtime/internal/atomic.Loadp();
	runtime/internal/atomic.Loadp();
	eax_209.u0 = 0x01;
l08063656:
	*((byte) eax_209.u0 + (dwLoc24 - 0x01 & 0x01FF) * 0x04) = dwArg08;
	return esi;
}

// 080636D0: Register uint32 runtime.(*gcSweepBuf).pop(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_32666) dwArg04)
// Called from:
//      runtime.sweepone
uint32 runtime.(*gcSweepBuf).pop(struct Eq_2 * gs, struct Eq_32666 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ebx_26 = runtime/internal/atomic.Xadd((char *) &dwArg04->ptr0004 + 0x0C, ~0x00);
	if (dwLoc08 < 0x00)
		return runtime/internal/atomic.Xadd((char *) &dwArg04->ptr0004 + 0x0C, 0x01);
	*((word32) (&dwArg04->ptr0004[dwLoc08 >> 0x09])[0] + (dwLoc08 & 0x01FF) * 0x04) = 0x00;
	return ebx_26;
}

// 08063760: void runtime.(*gcSweepBuf).numBlocks(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04)
// Called from:
//      runtime.gcMarkRootPrepare
void runtime.(*gcSweepBuf).numBlocks(struct Eq_2 * gs, ui32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Load();
}

// 080637B0: void runtime.(*gcSweepBuf).block(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack ui32 dwArg04, Stack Eq_28268 dwArg08, Stack (ptr32 word32) dwArg0C)
// Called from:
//      runtime.markrootSpans
void runtime.(*gcSweepBuf).block(struct Eq_2 * gs, Eq_4 dwArg00, ui32 dwArg04, Eq_28268 dwArg08, word32 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 >= 0x00)
	{
		runtime/internal/atomic.Loaduintptr();
		if (dwArg08 < dwLoc08)
		{
			Eq_34127 ecx_67;
			runtime/internal/atomic.Loadp();
			runtime/internal/atomic.Loadp();
			runtime/internal/atomic.Load();
			if (dwArg0C < dwLoc08 >> 0x09)
				ecx_67.u0 = 0x0200;
			else
				ecx_67 = dwLoc08 & 0x01FF;
			while (ecx_67 > 0x00)
			{
				Eq_34127 edx_78 = ecx_67 - 0x01;
				if (edx_78 >= ecx_67)
					runtime.panicindex(gs);
				if ((dwArg00 - 0x04)[ecx_67] != 0x00)
					return;
				ecx_67 = edx_78;
			}
			return;
		}
	}
	runtime.throw(gs);
}

// 080638B0: void runtime.init.0(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
void runtime.init.0(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 080638D0: void runtime.(*gcWork).init(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*gcWork).put
//      runtime.(*gcWork).tryGet
//      runtime.(*gcWork).get
void runtime.(*gcWork).init(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.getempty(gs);
	*dwArg04 = dwLoc04;
	runtime.trygetfull(gs);
	if (dwLoc04 == 0x00)
		runtime.getempty(gs);
	*((word32) dwArg04 + 4) = dwLoc04;
}

// 08063920: void runtime.(*gcWork).put(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanobject
//      runtime.greyobject
void runtime.(*gcWork).put(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uip32 edx_123;
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 != 0x00)
	{
		if (*((word32) ecx_18 + 0x0C) == 0x01FC)
		{
			*dwArg04 = *((word32) dwArg04 + 4);
			*((word32) dwArg04 + 4) = ecx_18;
			ecx_18 = *dwArg04;
			Eq_4 edx_42 = *((word32) ecx_18 + 0x0C);
			edx_123 = SEQ(SLICE(edx_42, word24, 8), edx_42 == 0x01FC);
			if (edx_42 == 0x01FC)
			{
				runtime.putfull(gs);
				runtime.getempty(gs);
				*dwArg04 = ecx_18;
				edx_123 = (word32) (edx_42 == 0x01FC);
			}
		}
		else
			edx_123 = 0x00;
	}
	else
	{
		runtime.(*gcWork).init(gs, dwArg04);
		ecx_18 = *dwArg04;
		edx_123 = 0x00;
	}
	byte dl_76 = (byte) edx_123;
	Eq_4 eax_62 = *((word32) ecx_18 + 0x0C);
	if (eax_62 >= 0x01FC)
		runtime.panicindex(gs);
	else
	{
		*((word32) ecx_18 + (eax_62 * 0x04 + 16)) = dwArg08;
		*((word32) ecx_18 + 0x0C) = (word32) *((word32) ecx_18 + 0x0C) + 1;
		if (dl_76 != 0x00 && g_dw81575E4 == 0x01)
			runtime.(*gcControllerState).enlistWorker(ebx, gs, &g_dw8157860);
	}
}

// 080639F0: void runtime.(*gcWork).tryGet(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcDrain
//      runtime.gcDrainN
void runtime.(*gcWork).tryGet(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 == 0x00)
	{
		runtime.(*gcWork).init(gs, dwArg04);
		dwLoc0C = dwArg04;
		ecx_18 = *dwArg04;
	}
	if (*((word32) ecx_18 + 0x0C) == 0x00)
	{
		Eq_4 edx_37 = *dwArg04;
		*dwArg04 = *((word32) dwArg04 + 4);
		*((word32) dwArg04 + 4) = edx_37;
		ecx_18 = *dwArg04;
		if (*((word32) ecx_18 + 0x0C) == 0x00)
		{
			runtime.trygetfull(gs);
			if (dwLoc0C == 0x00)
				return;
			runtime.putempty(gs);
			*dwArg04 = dwLoc0C;
			ecx_18 = dwLoc0C;
		}
	}
	Eq_4 eax_71 = *((word32) ecx_18 + 0x0C);
	*((word32) ecx_18 + 0x0C) = eax_71 - 0x01;
	if (eax_71 < 0x01FD)
		return;
	runtime.panicindex(gs);
}

// 08063AB0: void runtime.(*gcWork).get(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcDrain
void runtime.(*gcWork).get(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 == 0x00)
	{
		runtime.(*gcWork).init(gs, dwArg04);
		dwLoc0C = dwArg04;
		ecx_18 = *dwArg04;
	}
	if (*((word32) ecx_18 + 0x0C) == 0x00)
	{
		Eq_4 edx_37 = *dwArg04;
		*dwArg04 = *((word32) dwArg04 + 4);
		*((word32) dwArg04 + 4) = edx_37;
		ecx_18 = *dwArg04;
		if (*((word32) ecx_18 + 0x0C) == 0x00)
		{
			runtime.getfull(gs);
			if (dwLoc0C == 0x00)
				return;
			runtime.putempty(gs);
			*dwArg04 = dwLoc0C;
			ecx_18 = dwLoc0C;
		}
	}
	Eq_4 eax_71 = *((word32) ecx_18 + 0x0C);
	*((word32) ecx_18 + 0x0C) = eax_71 - 0x01;
	if (eax_71 < 0x01FD)
		return;
	runtime.panicindex(gs);
}

// 08063B70: void runtime.(*gcWork).dispose(Register Eq_363 ebx, Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcBgMarkWorker
//      runtime.gcMark
//      runtime.gchelper
//      runtime.gcAssistAlloc1
//      runtime.shade
//      runtime.gcmarknewobject
//      runtime.gcMarkTinyAllocs
//      runtime.addfinalizer
//      runtime.newstack
//      runtime.gcMarkDone.func1.1
void runtime.(*gcWork).dispose(Eq_363 ebx, Eq_4 ebp, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_34459 * ecx_18 = *dwArg04;
	if (ecx_18 != null)
	{
		if (ecx_18->dw000C == 0x00)
			runtime.putempty(gs);
		else
			runtime.putfull(gs);
		*dwArg04 = null;
		if (*((word32) *((word32) dwArg04 + 4) + 0x0C) == 0x00)
			runtime.putempty(gs);
		else
			runtime.putfull(gs);
		((word32) dwArg04 + 4)->u0 = 0x00;
	}
	Eq_4 edx_63 = *((word32) dwArg04 + 0x0C);
	Eq_4 ecx_62 = *((word32) dwArg04 + 8);
	ui32 ebp_89 = SEQ(SLICE(ebp, word24, 8), ecx_62 != 0x00) | SEQ(ebx_24_8, edx_63 != 0x00);
	ui24 ebx_24_8_127 = ebx_24_8;
	ui32 ebp_106 = ebp_89;
	if ((byte) ebp_89 != 0x00)
	{
		word32 ebx_107;
		runtime/internal/atomic.Xadd64(135550440, ecx_62, edx_63, out ebx_107, out ebp_106);
		((word32) dwArg04 + 8)->u0 = 0x00;
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
		ebx_24_8_127 = SLICE(ebx_107, word24, 8);
	}
	Eq_4 ecx_119 = *((word32) dwArg04 + 20);
	Eq_4 edx_120 = *((word32) dwArg04 + 16);
	if ((byte) (SEQ(SLICE(ebp_106, word24, 8), edx_120 != 0x00) | SEQ(ebx_24_8_127, ecx_119 != 0x00)) != 0x00)
	{
		word32 ebp_157;
		word32 ebx_158;
		runtime/internal/atomic.Xaddint64(0x08157860, edx_120, ecx_119, out ebx_158, out ebp_157);
		((word32) dwArg00 + 16)->u0 = 0x00;
		((word32) dwArg00 + 20)->u0 = 0x00;
	}
}

// 08063C90: void runtime.(*gcWork).balance(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcDrain
//      runtime.gcDrainN
void runtime.(*gcWork).balance(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_34578 * ecx_18 = *dwArg04;
	if (ecx_18 == null)
		return;
	Eq_4 edx_24 = *((word32) dwArg04 + 4);
	Eq_4 ebx_25 = *((word32) edx_24 + 0x0C);
	if (ebx_25 == 0x00)
	{
		if (ecx_18->t000C <= 0x04)
			return;
		runtime.handoff(gs, ecx_18);
		*dwArg04 = dwLoc04;
	}
	else
	{
		runtime.putfull(gs);
		runtime.getempty(gs);
		*((word32) dwArg04 + 4) = edx_24;
	}
	if (g_dw81575E4 == 0x01)
		runtime.(*gcControllerState).enlistWorker(SLICE(ebx_25, word24, 8), gs, &g_dw8157860);
}

// 08063D20: void runtime.(*workbuf).checknonempty(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.putfull
//      runtime.trygetfull
//      runtime.getfull
void runtime.(*workbuf).checknonempty(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 0x0C) != 0x00)
		return;
	runtime.throw(gs);
}

// 08063D70: void runtime.(*workbuf).checkempty(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.getempty
//      runtime.putempty
void runtime.(*workbuf).checkempty(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 0x0C) == 0x00)
		return;
	runtime.throw(gs);
}

// 08063DC0: void runtime.getempty(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).init
//      runtime.(*gcWork).put
//      runtime.(*gcWork).balance
//      runtime.handoff
void runtime.getempty(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_40;
	word32 eax_17 = g_dw8145588;
	word32 ecx_18 = g_dw814558C;
	if ((byte) (SEQ(SLICE(ecx_18, word24, 8), ecx_18 != 0x00) | SEQ(SLICE(eax_17, word24, 8), eax_17 != 0x00)) == 0x00)
		eax_40.u0 = 0x00;
	else
	{
		runtime.(*lfstack).pop(SLICE(edx_38, word24, 8), gs, 0x08145588);
		eax_40 = dwLoc20;
		if (dwLoc20 != 0x00)
		{
			runtime.(*workbuf).checkempty(gs, dwLoc20);
			eax_40 = dwLoc20;
		}
	}
	if (eax_40 != 0x00)
		return;
	Eq_4 dwLoc18_207 = 0x00;
	if (g_t81455D4 != 0x00)
	{
		word32 edi_278;
		word32 esi_277;
		word32 ebp_276;
		runtime.lock(esi, gs, 0x081455D0, out ebp_276, out esi_277, out edi_278);
		Eq_4 eax_72 = g_t81455D4;
		dwLoc18_207 = eax_72;
		if (eax_72 != 0x00)
		{
			runtime.(*mSpanList).remove(gs, 135550420, eax_72);
			runtime.(*mSpanList).insert(gs, 135550428, eax_72);
		}
		word32 edx_286;
		word32 ebx_287;
		runtime.unlock(gs, 0x081455D0, out edx_286, out ebx_287);
	}
	if (dwLoc18_207 == 0x00)
	{
		word32 edi_280;
		word32 ebp_279;
		runtime.systemstack(gs, fp - 0x08, out ebp_279, out edi_280);
		if (dwLoc18_207 == 0x00)
			runtime.throw(gs);
		word32 ebp_281;
		word32 edi_283;
		word32 esi_282;
		runtime.lock(esi, gs, 0x081455D0, out ebp_281, out esi_282, out edi_283);
		runtime.(*mSpanList).insert(gs, 135550428, dwLoc18_207);
		word32 edx_284;
		word32 ebx_285;
		runtime.unlock(gs, 0x081455D0, out edx_284, out ebx_285);
	}
	Eq_34739 ecx_151 = 0x00;
	while (true)
	{
		Eq_34739 edx_155 = (word32) ecx_151 + 0x0800;
		if (edx_155 > 0x8000)
			break;
		Mem171[Mem165[dwLoc18_207 + 0x0C:word32] + ecx_151 + 0x0C:word32] = 0x00;
		if (ecx_151 != 0x00)
			runtime.putempty(gs);
		ecx_151 = edx_155;
	}
}

// 08063F90: void runtime.putempty(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).tryGet
//      runtime.(*gcWork).get
//      runtime.(*gcWork).dispose
//      runtime.getempty
void runtime.putempty(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*workbuf).checkempty(gs, dwArg04);
	runtime.(*lfstack).push(gs, 0x08145588, dwArg04);
}

// 08063FE0: void runtime.putfull(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).put
//      runtime.(*gcWork).dispose
//      runtime.(*gcWork).balance
//      runtime.handoff
void runtime.putfull(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*workbuf).checknonempty(gs, dwArg04);
	runtime.(*lfstack).push(gs, 135550336, dwArg04);
}

// 08064030: void runtime.trygetfull(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).init
//      runtime.(*gcWork).tryGet
void runtime.trygetfull(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*lfstack).pop(edx, gs, 135550336);
	if (dwLoc08 == 0x00)
		return;
	runtime.(*workbuf).checknonempty(gs, dwLoc08);
}

// 08064090: void runtime.getfull(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).get
void runtime.getfull(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*lfstack).pop(edx, gs, 135550336);
	if (dwLoc20 == 0x00)
	{
		uint32 ebx_32 = runtime/internal/atomic.Xadd(0x08145604, 0x01);
		Eq_4 ecx_39 = g_t81455F8;
		if (dwLoc1C > ecx_39)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(SLICE(ebx_32, word24, 8), gs, dwLoc1C);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(SLICE(ebx_32, word24, 8), gs, ecx_39);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			int32 eax_103 = 0x00;
			while (true)
			{
				word32 ecx_109 = g_dw8145584;
				word32 edx_110 = g_dw8145580;
				if ((byte) (SEQ(SLICE(ecx_109, word24, 8), ecx_109 != 0x00) | SEQ(SLICE(edx_110, word24, 8), edx_110 != 0x00)) != 0x00)
				{
					uint32 ebx_130 = runtime/internal/atomic.Xadd(0x08145604, ~0x00);
					Eq_4 ecx_137 = g_t81455F8;
					if (dwLoc1C == ecx_137)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						runtime.printint(SLICE(ebx_130, word24, 8), gs, dwLoc1C);
						runtime.printsp(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						runtime.printint(SLICE(ebx_130, word24, 8), gs, ecx_137);
						runtime.printnl(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
					runtime.(*lfstack).pop(edx, gs, 135550336);
					if (true)
					{
						runtime.(*workbuf).checknonempty(gs, ~0x00);
						return;
					}
					uint32 ebx_226 = runtime/internal/atomic.Xadd(0x08145604, 0x01);
					Eq_4 ecx_233 = g_t81455F8;
					if (dwLoc1C > ecx_233)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						runtime.printint(SLICE(ebx_226, word24, 8), gs, dwLoc1C);
						runtime.printsp(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						runtime.printint(SLICE(ebx_226, word24, 8), gs, ecx_233);
						runtime.printnl(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
				}
				if (g_t81455F8 == g_t8145604 && g_t81455F0 >= g_t81455F4)
					return;
				if (eax_103 >= 0x0A)
				{
					if (eax_103 < 0x14)
						runtime.osyield();
					else
					{
						word32 edi_329;
						runtime.usleep(out edi_329);
					}
				}
				else
					runtime.procyield(0x14);
				++eax_103;
			}
		}
	}
	else
		runtime.(*workbuf).checknonempty(gs, dwLoc20);
}

// 080643D0: void runtime.handoff(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_34578) dwArg04)
// Called from:
//      runtime.(*gcWork).balance
void runtime.handoff(struct Eq_2 * gs, struct Eq_34578 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.getempty(gs);
	Eq_34603 edx_24 = dwArg04->t000C;
	Eq_35049 edx_28 = (word32) edx_24.u0 + ((edx_24 >> 0x1F) >> 0x1F);
	dwArg04->t000C = edx_24 - (edx_28 >> 0x01);
	dwLoc10->dw000C = edx_28 >> 0x01;
	Eq_34603 ebx_33 = dwArg04->t000C;
	if (ebx_33 >= 0x01FC)
		runtime.panicindex(gs);
	else
	{
		word32 ebp_85;
		word32 esi_86;
		word32 edi_87;
		runtime.memmove(&dwLoc10->dw000C + 1, (char *) &dwArg04->t000C + 4 + ebx_33 * 0x04, edx_28 >> 0x01 << 0x02, out ebp_85, out esi_86, out edi_87);
		runtime.putfull(gs);
	}
}

// 08064460: void runtime.prepareFreeWorkbufs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
//      runtime.gcSweep
void runtime.prepareFreeWorkbufs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_74;
	word32 esi_75;
	word32 edi_76;
	runtime.lock(esi, gs, 0x081455D0, out ebp_74, out esi_75, out edi_76);
	word32 eax_22 = g_dw8145580;
	word32 ecx_23 = g_dw8145584;
	if ((byte) (SEQ(SLICE(ecx_23, word24, 8), ecx_23 != 0x00) | SEQ(SLICE(eax_22, word24, 8), eax_22 != 0x00)) != 0x00)
		runtime.throw(gs);
	else
	{
		g_dw8145588 = 0x00;
		g_dw814558C = 0x00;
		runtime.(*mSpanList).takeAll(gs, &g_t81455D4, &g_t81455DC);
		word32 edx_77;
		word32 ebx_78;
		runtime.unlock(gs, 0x081455D0, out edx_77, out ebx_78);
	}
}

// 08064510: Register Eq_4 runtime.freeSomeWbufs(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcSweep
//      runtime.bgsweep
Eq_4 runtime.freeSomeWbufs(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_28;
	word32 ebp_137;
	word32 edi_138;
	runtime.lock(esi, gs, 0x081455D0, out ebp_137, out esi_28, out edi_138);
	if (g_dw81575E4 == 0x00 && g_t81455D4 != 0x00)
	{
		word32 ebp_141;
		word32 edi_142;
		runtime.systemstack(gs, fp - 0x0C, out ebp_141, out edi_142);
		word32 edx_143;
		word32 ebx_144;
		runtime.unlock(gs, 0x081455D0, out edx_143, out ebx_144);
		return;
	}
	else
	{
		word32 edx_139;
		word32 ebx_140;
		runtime.unlock(gs, 0x081455D0, out edx_139, out ebx_140);
		return;
	}
}

// 080645C0: void runtime.recordspan(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_35209) dwArg04, Stack word32 dwArg08)
void runtime.recordspan(struct Eq_2 * gs, struct Eq_35209 * dwArg04, word32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_23 = dwArg04->t0824;
	if (dwArg04->t0820 >= edx_23)
	{
		Eq_35246 ecx_32 = (edx_23 * 0x03 >> 0x1F >> 0x1F) + edx_23 * 0x03;
		Eq_4 ecx_33 = ecx_32 >> 0x01;
		if (ecx_32 >> 0x01 <= 0x4000)
			ecx_33.u0 = 0x4000;
		runtime.sysAlloc();
		if (dwLoc40 == 0x00)
			runtime.throw(gs);
		Eq_4 ecx_75 = dwArg04->t0820;
		Eq_4 ecx_79 = dwArg04->t081C;
		Eq_4 edx_80 = dwArg04->t0820;
		Eq_4 ebx_81 = dwArg04->t0824;
		if (edx_80 > 0x00)
		{
			word32 edi_346;
			word32 esi_345;
			runtime.typedslicecopy(gs, 0x080DB9C0, dwLoc40, ecx_75, ecx_79, edx_80, out esi_345, out edi_346);
			dwLoc34 = edx_80;
			dwLoc30 = ebx_81;
		}
		Eq_4 edx_110 = dwArg04->t0820;
		dwArg04->t0820 = ecx_75;
		dwArg04->t0824 = ecx_33;
		if (g_t81576F0 == 0x00)
			dwArg04->t081C = dwLoc40;
		else
			runtime.writebarrierptr(&dwArg04->t081C, dwLoc40);
		if (edx_110 != 0x00)
			runtime.sysFree();
	}
	Eq_4 ecx_166 = dwArg04->t081C;
	Eq_4 edx_167 = dwArg04->t0824;
	Eq_4 ebx_168 = dwArg04->t0820;
	if ((word32) ebx_168 + 1 > edx_167)
	{
		word32 esi_188;
		runtime.growslice(gs, 0x080DB9C0, ecx_166, ebx_168, edx_167, (word32) ebx_168 + 1, out esi_188);
		dwArg04->t0824 = dwLoc2C;
		if (g_t81576F0 == 0x00)
			dwArg04->t081C = dwLoc34;
		else
			runtime.writebarrierptr(&dwArg04->t081C, dwLoc34);
		ebx_168 = dwLoc30;
		ecx_166 = dwLoc34;
	}
	dwArg04->t0820 = (word32) ebx_168 + 1;
	*((word32) ecx_166 + ebx_168 * 0x04) = dwArg08;
}

// 08064840: void runtime.(*mheap).init(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack uint32 dwArg0C)
// Called from:
//      runtime.mallocinit
void runtime.(*mheap).init(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, uint32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 11432) = 0x18;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 0x00002CAC) = 0x00;
		*((word32) dwArg04 + 11440) = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 0x00002CAC, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 11440, 0x00);
	}
	*((word32) dwArg04 + 11444) = 0x00;
	*((word32) dwArg04 + 11448) = 0x00;
	*((word32) dwArg04 + 0x00002CBC) = 0x00;
	*((word32) dwArg04 + 0x00002CC0) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 0x00002CC4) = 0x08158220;
	else
		runtime.writebarrierptr((word32) dwArg04 + 0x00002CC4, 0x08158220);
	*((word32) dwArg04 + 0x00002CC8) = 0x01;
	*((word32) dwArg04 + 11360) = 0x5C;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 11364) = 0x080E7CA8;
		*((word32) dwArg04 + 11368) = dwArg04;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 11364, 0x080E7CA8);
		runtime.writebarrierptr((word32) dwArg04 + 11368, dwArg04);
	}
	*((word32) dwArg04 + 0x00002C6C) = 0x00;
	*((word32) dwArg04 + 11376) = 0x00;
	*((word32) dwArg04 + 11380) = 0x00;
	*((word32) dwArg04 + 11384) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 0x00002C7C) = 0x081581F8;
	else
		runtime.writebarrierptr((word32) dwArg04 + 0x00002C7C, 0x081581F8);
	*((word32) dwArg04 + 11392) = 0x01;
	*((word32) dwArg04 + 11396) = 868;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 0x00002C88) = 0x00;
		*((word32) dwArg04 + 0x00002C8C) = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 0x00002C88, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 0x00002C8C, 0x00);
	}
	*((word32) dwArg04 + 11408) = 0x00;
	*((word32) dwArg04 + 11412) = 0x00;
	*((word32) dwArg04 + 11416) = 0x00;
	*((word32) dwArg04 + 0x00002C9C) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 11424) = 0x08158208;
	else
		runtime.writebarrierptr((word32) dwArg04 + 11424, 0x08158208);
	*((word32) dwArg04 + 11428) = 0x01;
	*((word32) dwArg04 + 0x00002CCC) = 0x18;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 11472) = 0x00;
		*((word32) dwArg04 + 11476) = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 11472, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 11476, 0x00);
	}
	*((word32) dwArg04 + 11480) = 0x00;
	*((word32) dwArg04 + 0x00002CDC) = 0x00;
	*((word32) dwArg04 + 11488) = 0x00;
	*((word32) dwArg04 + 11492) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 11496) = 0x08158220;
	else
		runtime.writebarrierptr((word32) dwArg04 + 11496, 0x08158220);
	*((word32) dwArg04 + 0x00002CEC) = 0x01;
	*((word32) dwArg04 + 11504) = 0x0C;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 11508) = 0x00;
		*((word32) dwArg04 + 11512) = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 11508, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 11512, 0x00);
	}
	*((word32) dwArg04 + 11516) = 0x00;
	*((word32) dwArg04 + 0x00002D00) = 0x00;
	*((word32) dwArg04 + 11524) = 0x00;
	*((word32) dwArg04 + 11528) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 11532) = 0x08158220;
	else
		runtime.writebarrierptr((word32) dwArg04 + 11532, 0x08158220);
	*((word32) dwArg04 + 11536) = 0x01;
	*((word32) dwArg04 + 11392) = 0x00;
	Eq_35503 ecx_349 = 0x00;
	while (ecx_349 < 0x80)
	{
		if (ecx_349 >= 0x80)
			runtime.panicindex(gs);
		*((word32) dwArg04 + (ecx_349 * 0x08 + 4)) = 0x00;
		((word32) dwArg04 + (ecx_349 * 0x08 + 8))->u0 = 0x00;
		*((word32) dwArg04 + (ecx_349 * 0x08 + 0x0408)) = 0x00;
		*((word32) dwArg04 + (ecx_349 * 0x08 + 0x040C)) = 0x00;
		ecx_349 = (word32) ecx_349 + 1;
	}
	*((word32) dwArg04 + 0x0808) = 0x00;
	*((word32) dwArg04 + 2060) = 0x00;
	Eq_35514 ecx_362 = 0x00;
	while (ecx_362 < 0x86)
	{
		if (ecx_362 >= 0x86)
			runtime.panicindex(gs);
		int32 ecx_416 = ecx_362 << 0x06;
		(word32) dwArg04 + 2788 + ecx_416 = (byte *) (byte) ecx_362;
		(word32) dwArg04 + 2792 + ecx_416 = 0x00;
		(word32) dwArg04 + 0x0AEC + ecx_416 = 0x00;
		(word32) dwArg04 + 2800 + ecx_416 = 0x00;
		(word32) dwArg04 + 0x0AF4 + ecx_416 = 0x00;
		ecx_362 = (word32) ecx_362 + 1;
	}
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 0x0828) = dwArg08;
	else
		runtime.writebarrierptr((word32) dwArg04 + 0x0828, dwArg08);
	*((word32) dwArg04 + 2092) = 0x00;
	*((word32) dwArg04 + 0x0830) = dwArg0C >> 0x02;
	runtime.(*mheap).setArenaUsed(gs, dwArg04, *((word32) dwArg04 + 0x0ACC));
}

// 08064E10: void runtime.(*mheap).setArenaUsed(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.(*mheap).sysAlloc
//      runtime.(*mheap).init
void runtime.(*mheap).setArenaUsed(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*mheap).mapBits(gs, dwArg04, dwArg08);
	runtime.(*mheap).mapSpans(gs, dwArg04, dwArg08);
	*((word32) dwArg04 + 0x0ACC) = dwArg08;
}

// 08064E70: void runtime.(*mheap).mapSpans(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.(*mheap).setArenaUsed
void runtime.(*mheap).mapSpans(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_22 = g_t8157620;
	uint32 edx_26 = ecx_22 - 0x01 + (dwArg08 - *((word32) dwArg04 + 0x0AC8) >> 0x0D) * 0x04 & ~(ecx_22 - 0x01);
	uint32 ecx_28 = *((word32) dwArg04 + 2092);
	uint32 ebx_29 = *((word32) dwArg04 + 0x0830);
	if (ecx_28 >= edx_26 >> 0x02)
		return;
	if (edx_26 >> 0x02 > ebx_29)
		runtime.panicslice(gs);
	else
	{
		*((word32) dwArg04 + 2092) = edx_26 >> 0x02;
		struct Eq_35836 * ebx_41 = *((word32) dwArg04 + 0x0828);
		if (ecx_28 >= edx_26 >> 0x02)
			runtime.panicindex(gs);
		else
			runtime.sysMap(gs, ebx_41 + ecx_28 * 0x04, (byte) (word32) *((word32) dwArg04 + 2776));
	}
}

// 08064F20: void runtime.(*mheap).reclaimList(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*mheap).reclaim
void runtime.(*mheap).reclaimList(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81490F0;
	Eq_4 ecx_145 = 0x00;
l08065026:
	Eq_4 eax_146 = eax_17;
	Eq_4 ebx_157 = *dwArg08;
	while (ebx_157 != 0x00)
	{
		Eq_4 esi_33 = (word32) ebx_157 + 48;
		Eq_4 edi_35 = eax_146 - 0x02;
		if (*((word32) ebx_157 + 48) == edi_35)
		{
			Eq_4 ecx_42 = eax_146 - 0x01;
			runtime/internal/atomic.Cas(esi_33, edi_35, ecx_42);
			byte bLoc18_239 = (byte) ecx_42;
			if ((byte) (word32) bLoc14 != 0x00)
			{
				Eq_4 eax_114;
				runtime.(*mSpanList).remove(gs, dwArg08, ebx_157);
				runtime.(*mSpanList).insertBack(gs, dwArg08, ebx_157);
				word32 edx_275;
				word32 ebx_276;
				runtime.unlock(gs, dwArg04, out edx_275, out ebx_276);
				Eq_4 ecx_92 = *((word32) ebx_157 + 16);
				Eq_4 esi_102 = runtime.(*mspan).sweep(gs, dwLoc24, (byte) ebx_157);
				if ((byte) (word32) bLoc18_239 != 0x00)
					eax_114 = ecx_92 + ecx_145;
				else
					eax_114 = ecx_145;
				word32 esi_278;
				word32 edi_279;
				word32 ebp_277;
				runtime.lock(esi_102, gs, dwArg04, out ebp_277, out esi_278, out edi_279);
				if (eax_114 >= dwArg0C)
					return;
				else
				{
					ecx_145 = eax_114;
					goto l08065026;
				}
			}
			eax_146 = eax_17;
		}
		if (*((word32) ebx_157 + 48) != eax_146 - 0x01)
			return;
		ebx_157 = *ebx_157;
	}
}

// 08065050: void runtime.(*mheap).reclaim(Register (ptr32 Eq_2) gs, Register Eq_661 xmm2, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).alloc_m
void runtime.(*mheap).reclaim(struct Eq_2 * gs, Eq_661 xmm2, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = dwArg08;
	while (eax_18 < 0x80)
	{
		if (eax_18 >= 0x80)
			runtime.panicindex(gs);
		runtime.(*mheap).reclaimList(gs, dwArg04, (word32) dwArg04 + 0x0408 + eax_18 * 0x08, dwArg08);
		if (dwLoc10 != 0x00)
			return;
		eax_18 = (word32) eax_18 + 1;
	}
	runtime.(*mheap).reclaimList(gs, dwArg04, (word32) dwArg04 + 0x0808, dwArg08);
	if (dwLoc10 != 0x00)
		return;
	Eq_4 eax_160 = 0x00;
	Eq_4 ecx_159 = 0x00;
	while (eax_160 < dwArg08 && eax_160 < 0x80)
	{
		if (eax_160 >= 0x80)
			runtime.panicindex(gs);
		runtime.(*mheap).reclaimList(gs, dwArg04, (word32) dwArg04 + 0x0408 + eax_160 * 0x08, dwArg08 - ecx_159);
		Eq_4 eax_152 = (word32) ecx_159 + dwLoc10;
		if (eax_152 >= dwArg08)
			return;
		ecx_159 = eax_152;
		eax_160 = (word32) eax_160 + 1;
	}
	word32 edx_287;
	word32 ebx_288;
	runtime.unlock(gs, dwArg04, out edx_287, out ebx_288);
	Eq_4 eax_106 = ecx_159;
	do
	{
		word128 xmm0_292;
		Eq_4 esi_95 = runtime.sweepone(gs, xmm2, dwLoc20, out xmm0_292, out xmm2);
		if (dwArg04 == ~0x00)
			break;
		eax_106 = dwArg04 + eax_106;
	} while (eax_106 < dwArg08);
	word32 edi_291;
	word32 ebp_289;
	word32 esi_290;
	runtime.lock(esi_95, gs, dwArg04, out ebp_289, out esi_290, out edi_291);
}

// 080651A0: void runtime.(*mheap).alloc_m(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm2, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C, Stack byte bArg0D)
// Called from:
//      runtime.(*mheap).alloc.func1
void runtime.(*mheap).alloc_m(Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm2, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C, byte bArg0D)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (eax_18 != *(*((word32) eax_18 + 24)))
		runtime.throw(gs);
	else
	{
		word32 ebp_504;
		word32 esi_505;
		word32 edi_506;
		runtime.lock(esi, gs, dwArg04, out ebp_504, out esi_505, out edi_506);
		if (*((word32) dwArg04 + 0x0814) == 0x00)
		{
			if ((byte) (word32) g_b814F4C8 != 0x00)
				runtime.traceGCSweepStart(gs);
			runtime.(*mheap).reclaim(gs, xmm2, dwArg04, dwArg08);
			if ((byte) (word32) g_b814F4C8 != 0x00)
				runtime.traceGCSweepDone(gs);
		}
		uint32 edx_116 = (word32) *((word32) *((word32) *((word32) eax_18 + 24) + 0x00B8) + 4) + g_dw81597B8;
		uint32 ecx_118 = g_dw81597BC;
		g_dw81597B8 = edx_116;
		g_dw81597BC = (uint32) ((bool) (edx_116 < 0x00) + ecx_118);
		((word32) *((word32) *((word32) eax_18 + 24) + 0x00B8) + 4)->u0 = 0x00;
		up32 edx_130 = (word32) *((word32) *((word32) *((word32) eax_18 + 24) + 0x00B8) + 16) + g_dw8159798;
		word32 ecx_132 = g_dw815979C;
		g_dw8159798 = edx_130;
		g_dw815979C = (word32) ((bool) (edx_130 < 0x00) + ecx_132);
		((word32) *((word32) *((word32) eax_18 + 24) + 0x00B8) + 16)->u0 = 0x00;
		Eq_4 esi_154;
		Eq_4 ebp_149 = runtime.(*mheap).allocSpanLocked(gs, dwArg04, dwArg08, &g_t81581C8, out esi_154);
		if (dwLoc10 != 0x00)
		{
			runtime/internal/atomic.Store((word32) dwLoc10 + 48, *((word32) dwArg04 + 0x0810));
			runtime.(*gcSweepBuf).push(esi_154, gs, dwLoc20, (word32) dwArg04 + 2100 + (*((word32) dwArg04 + 0x0810) >> 0x01 & 0x01) * 0x14, dwLoc10);
			((word32) dwLoc10 + 60)->u0 = 0x01;
			((word32) dwLoc10 + 56)->u1 = 0x00;
			bcu8 cl_199 = (byte) (word32) bArg0C;
			*((word32) dwLoc10 + 58) = cl_199;
			if (cl_199 >> 0x01 == 0x00)
			{
				*((word32) dwLoc10 + 64) = *((word32) dwLoc10 + 16) << 0x0D;
				*((word32) dwLoc10 + 62) = 0x00;
				((word32) dwLoc10 + 52)->u1 = 0x00;
				*((word32) dwLoc10 + 63) = 0x00;
				((word32) dwLoc10 + 54)->u1 = 0x00;
			}
			else
			{
				Eq_36248 ecx_205 = (int32) (cl_199 >> 0x01);
				if (ecx_205 >= 0x43)
					runtime.panicindex(gs);
				*((word32) dwLoc10 + 64) = (word32) g_a8138820[ecx_205 * 0x02];
				*((word32) dwLoc10 + 62) = (byte) (word32) g_a813A9C0[ecx_205];
				*((word32) dwLoc10 + 52) = (word16) (word32) g_a813A9C2[ecx_205];
				*((word32) dwLoc10 + 63) = (byte) (word32) g_a813A9C1[ecx_205];
				((word32) dwLoc10 + 54)->u1 = (word16) (word32) g_a813A9C4[ecx_205];
			}
			word32 edx_246 = Mem242[dwArg04 + 0x0860:word32] + dwArg08;
			Eq_4 ebp_248 = *((word32) dwArg04 + 0x0864);
			*((word32) dwArg04 + 2144) = edx_246;
			ebp_149 = ebp_248 + (edx_246 <u 0x00);
			*((word32) dwArg04 + 0x0864) = ebp_149;
			if ((byte) (word32) bArg0D != 0x00)
			{
				up32 ecx_258 = g_dw81581D8;
				word32 edx_261 = g_dw81581DC;
				g_dw81581D8 = ecx_258 + 0x01;
				g_dw81581DC = (word32) ((bool) (ecx_258 < 0x01) + edx_261);
				up32 ecx_269 = (word32) *((word32) dwLoc10 + 64) + g_dw8149168;
				word32 edx_271 = g_dw814916C;
				g_dw8149168 = ecx_269;
				g_dw814916C = (word32) ((bool) (ecx_269 < 0x00) + edx_271);
				up32 ecx_276 = g_dw8149170;
				word32 edx_279 = g_dw8149174;
				g_dw8149170 = ecx_276 + 0x01;
				g_dw8149174 = (word32) ((bool) (ecx_276 < 0x01) + edx_279);
				word32 ebx_509;
				runtime/internal/atomic.Xadd64(135632816, dwArg08 << 0x0D, 0x00, out ebx_509, out ebp_149);
				Eq_4 ecx_300 = *((word32) dwLoc10 + 16);
				if (ecx_300 < 0x80)
					runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 0x0408 + ecx_300 * 0x08, dwLoc10);
				else
					runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 0x0808, dwLoc10);
			}
		}
		if (g_dw81575DC != 0x00)
			runtime.(*gcControllerState).revise(ebp_149, gs, &g_dw8157860);
		if ((byte) (word32) g_b814F4C8 != 0x00)
		{
			word32 esi_368;
			runtime.traceHeapAlloc(gs, out esi_368);
		}
		word32 edx_507;
		word32 ebx_508;
		runtime.unlock(gs, dwArg04, out edx_507, out ebx_508);
	}
}

// 08065510: void runtime.(*mheap).alloc(Register (ptr32 Eq_2) gs, Stack byte bArg0E)
// Called from:
//      runtime.largeAlloc
//      runtime.(*mcentral).grow
void runtime.(*mheap).alloc(struct Eq_2 * gs, byte bArg0E)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8B(0x00, fp - 0x14);
	word32 edi_42;
	word32 ebp_130;
	runtime.systemstack(gs, fp - 0x14, out ebp_130, out edi_42);
	if (0x00 != 0x00)
	{
		if ((byte) (word32) bArg0E != 0x00 && (byte) ((word32) (*((byte *) 0x3D))) != 0x00)
			runtime.memclrNoHeapPointers(*(union Eq_4 *) 0x0C, *(union Eq_4 *) 0x10 << 0x0D);
		*(byte *) 0x3D = 0x00;
	}
}

// 080655D0: void runtime.(*mheap).allocManual(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.stackpoolalloc
//      runtime.stackalloc
//      runtime.getempty.func1
void runtime.(*mheap).allocManual(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	word32 edi_106;
	word32 esi_105;
	word32 ebp_104;
	runtime.lock(esi, gs, dwArg04, out ebp_104, out esi_105, out edi_106);
	word32 esi_107;
	runtime.(*mheap).allocSpanLocked(gs, dwArg04, dwArg08, dwArg0C, out esi_107);
	if (dwLoc08 != null)
	{
		dwLoc08->b003C = 0x02;
		dwLoc08->dw0014 = 0x00;
		dwLoc08->w0038 = 0x00;
		dwLoc08->b003A = 0x00;
		dwLoc08->dw001C = 0x00;
		dwLoc08->dw0040 = 0x00;
		dwLoc08->dw0050 = (dwLoc08->dw0010 << 0x0D) + dwLoc08->dw000C;
		Eq_4 ecx_55 = g_t81581B8 - (dwLoc08->dw0010 << 0x0D);
		Eq_4 edx_57 = g_t81581BC;
		g_t81581B8 = ecx_55;
		g_t81581BC = edx_57 - (ecx_55 < 0x00);
	}
	word32 edx_108;
	word32 ebx_109;
	runtime.unlock(gs, dwArg04, out edx_108, out ebx_109);
}

// 080656A0: Register Eq_4 runtime.(*mheap).allocSpanLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_36158) dwArg0C, Register out (ptr32 Eq_35836) esiOut)
// Called from:
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocManual
Eq_4 runtime.(*mheap).allocSpanLocked(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_36158 * dwArg0C, struct Eq_35836 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = dwArg08;
	while (true)
	{
		Eq_4 dwLoc1C_341;
		Eq_4 eax_34;
		byte bLoc18_348 = (byte) dwLoc18;
		if (eax_18 >= 0x80)
			break;
		if (eax_18 >= 0x80)
			runtime.panicindex(gs);
		Eq_4 ebx_80 = (word32) dwArg04 + 4 + eax_18 * 0x08;
		ebp = *((word32) dwArg04 + (eax_18 * 0x08 + 4));
		if (ebp != 0x00)
		{
			runtime.(*mSpanList).remove(gs, ebx_80, ebp);
			dwLoc1C_341 = ebp;
			eax_34 = ebp;
			goto l08065701;
		}
		eax_18 = (word32) eax_18 + 1;
	}
	runtime.(*mheap).allocLarge(gs);
	dwLoc1C_341 = dwArg08;
	eax_34 = dwLoc18;
	if (dwLoc18 == 0x00)
	{
		runtime.(*mheap).grow(gs, dwArg04, dwArg08);
		if ((byte) (word32) bLoc18_348 == 0x00)
		{
			esiOut = esi;
			return ebp;
		}
		runtime.(*mheap).allocLarge(gs);
		dwLoc1C_341 = dwArg08;
		eax_34 = dwLoc18;
		if (dwLoc18 == 0x00)
		{
			esiOut = esi;
			return ebp;
		}
	}
l08065701:
	if ((byte) (word32) *((word32) eax_34 + 60) != 0x03)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_111 = *((word32) eax_34 + 16);
		if (ecx_111 < dwArg08)
			runtime.throw(gs);
		else
		{
			if (*((word32) eax_34 + 76) > 0x00)
			{
				runtime.sysUsed(gs, *((word32) eax_34 + 0x0C), ecx_111 << 0x0D);
				uint32 eax_142 = g_dw81581D0 - (*((word32) eax_34 + 76) << 0x0D);
				uint32 edx_144 = g_dw81581D4;
				g_dw81581D0 = eax_142;
				g_dw81581D4 = edx_144 - (eax_142 < 0x00);
				((word32) eax_34 + 76)->u0 = 0x00;
				dwLoc1C_341 = ecx_111 << 0x0D;
			}
			if (*((word32) eax_34 + 16) > dwArg08)
			{
				runtime.(*fixalloc).alloc(gs, (word32) dwArg04 + 11360);
				Eq_4 edx_173 = *((word32) eax_34 + 16);
				Eq_4 ebx_174 = *((word32) eax_34 + 0x0C);
				*dwLoc1C_341 = 0x00;
				((word32) dwLoc1C_341 + 4)->u0 = 0x00;
				((word32) dwLoc1C_341 + 8)->u0 = 0x00;
				*((word32) dwLoc1C_341 + 0x0C) = (word32) ebx_174 + (dwArg08 << 0x0D);
				*((word32) dwLoc1C_341 + 16) = edx_173 - dwArg08;
				((word32) dwLoc1C_341 + 56)->u0 = 0x00;
				((word32) dwLoc1C_341 + 64)->u0 = 0x00;
				((word32) dwLoc1C_341 + 60)->u0 = 0x00;
				((word32) dwLoc1C_341 + 0x0044)->u0 = 0x00;
				((word32) dwLoc1C_341 + 72)->u0 = 0x00;
				((word32) dwLoc1C_341 + 76)->u0 = 0x00;
				((word32) dwLoc1C_341 + 84)->u0 = 0x00;
				((word32) dwLoc1C_341 + 88)->u0 = 0x00;
				*((word32) dwLoc1C_341 + 61) = 0x00;
				((word32) dwLoc1C_341 + 24)->u0 = 0x00;
				((word32) dwLoc1C_341 + 40)->u0 = 0x00;
				((word32) dwLoc1C_341 + 44)->u0 = 0x00;
				*((word32) eax_34 + 16) = dwArg08;
				uint32 ebp_201 = *((word32) dwLoc1C_341 + 0x0C) - *((word32) dwArg04 + 0x0AC8);
				if (ebp_201 >> 0x0D > 0x00)
				{
					struct Eq_35836 * edi_208 = *((word32) dwArg04 + 0x0828);
					if ((ebp_201 >> 0x0D) - 0x01 >= *((word32) dwArg04 + 2092))
						runtime.panicindex(gs);
					(edi_208 - 0x04)[ebp_201 >> 0x0D] = eax_34;
				}
				struct Eq_35836 * ebx_219 = *((word32) dwArg04 + 0x0828);
				if (ebp_201 >> 0x0D >= *((word32) dwArg04 + 2092))
					runtime.panicindex(gs);
				ebx_219[(ebp_201 >> 0x0D) * 0x04] = (struct Eq_35836) dwLoc1C_341;
				esi = (struct Eq_35836 *) *((word32) dwArg04 + 0x0828);
				uint32 ebp_235 = (word32) *((word32) dwLoc1C_341 + 16) + ((ebp_201 >> 0x0D) - 0x01);
				if (ebp_235 >= *((word32) dwArg04 + 2092))
					runtime.panicindex(gs);
				esi[ebp_235 * 0x04] = (struct Eq_35836) dwLoc1C_341;
				*((word32) dwLoc1C_341 + 61) = (byte) (word32) *((word32) eax_34 + 61);
				((word32) eax_34 + 60)->u0 = 0x02;
				((word32) dwLoc1C_341 + 60)->u0 = 0x02;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg13 = <invalid>;
				runtime.(*mheap).freeSpanLocked(gs, dwArg04, dwLoc1C_341, 0x00, stackArg13, *((word32) eax_34 + 0x0044), *((word32) eax_34 + 72));
				((word32) eax_34 + 60)->u0 = 0x03;
			}
			((word32) eax_34 + 0x0044)->u0 = 0x00;
			((word32) eax_34 + 72)->u0 = 0x00;
			uint32 ebx_268 = *((word32) dwArg04 + 0x0AC8);
			Eq_4 ebp_269 = *((word32) eax_34 + 0x0C);
			uint32 ebp_270 = ebp_269 - ebx_268;
			Eq_4 ebx_273 = 0x00;
			while (true)
			{
				uint32 ebp_319 = ebp_269 - ebx_268 >> 0x0D;
				if (ebx_273 >= dwArg08)
					break;
				struct Eq_35836 * esi_317 = *((word32) dwArg04 + 0x0828);
				uint32 ebp_320 = (word32) ebx_273 + ebp_319;
				if (ebp_320 >= *((word32) dwArg04 + 2092))
					runtime.panicindex(gs);
				esi_317[ebp_320 * 0x04] = (struct Eq_35836) eax_34;
				ebx_273 = (word32) ebx_273 + 1;
				esi = ebp_270 >> 0x0D;
			}
			up32 ebx_285 = dwArg0C->dw0000 + (dwArg08 << 0x0D);
			Eq_4 ebp_287 = dwArg0C->t0004;
			dwArg0C->dw0000 = ebx_285;
			word32 ebp_290 = ebp_287 + (ebx_285 <u 0x00);
			dwArg0C->t0004 = ebp_290;
			uint32 ecx_293 = g_dw81581C0 - (dwArg08 << 0x0D);
			uint32 edx_295 = g_dw81581C4;
			g_dw81581C0 = ecx_293;
			g_dw81581C4 = edx_295 - (ecx_293 < 0x00);
			if (*((word32) eax_34 + 8) != 0x00)
				runtime.throw(gs);
			else
			{
				esiOut = esi;
				return ebp_290;
			}
		}
	}
}

// 08065A40: void runtime.(*mheap).allocLarge(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mheap).allocSpanLocked
void runtime.(*mheap).allocLarge(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*mTreap).remove(gs, dwArg04 + 0x0404, dwArg08);
}

// 08065A90: void runtime.(*mheap).grow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).allocSpanLocked
void runtime.(*mheap).grow(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_24;
	ui32 eax_19 = (word32) dwArg08 + 7 & ~0x07;
	if (eax_19 << 0x0D < 0x00100000)
		ecx_24.u0 = 0x00100000;
	else
		ecx_24 = eax_19 << 0x0D;
	Eq_4 ecx_113;
	runtime.(*mheap).sysAlloc(gs, dwArg04, ecx_24);
	Eq_4 dwLoc2C_222 = ecx_24;
	if (dwLoc28 != 0x00)
		ecx_113 = ecx_24;
	else
	{
		ecx_113 = ecx_24;
		if (ecx_24 > eax_19 << 0x0D)
		{
			runtime.(*mheap).sysAlloc(gs, dwArg04, eax_19 << 0x0D);
			dwLoc2C_222 = eax_19 << 0x0D;
			ecx_113 = eax_19 << 0x0D;
		}
		if (dwLoc28 == 0x00)
		{
			Eq_4 eax_61 = g_t81581B8;
			Eq_4 ecx_63 = g_t81581BC;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(SLICE(ebx, word24, 8), gs, ecx_113);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, eax_61, ecx_63);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			return;
		}
	}
	runtime.(*fixalloc).alloc(gs, (word32) dwArg04 + 11360);
	*dwLoc2C_222 = 0x00;
	((word32) dwLoc2C_222 + 4)->u0 = 0x00;
	((word32) dwLoc2C_222 + 8)->u0 = 0x00;
	*((word32) dwLoc2C_222 + 0x0C) = dwLoc28;
	*((word32) dwLoc2C_222 + 16) = ecx_113 >> 0x0D;
	((word32) dwLoc2C_222 + 56)->u0 = 0x00;
	((word32) dwLoc2C_222 + 64)->u0 = 0x00;
	((word32) dwLoc2C_222 + 60)->u0 = 0x00;
	((word32) dwLoc2C_222 + 0x0044)->u0 = 0x00;
	((word32) dwLoc2C_222 + 72)->u0 = 0x00;
	((word32) dwLoc2C_222 + 76)->u0 = 0x00;
	((word32) dwLoc2C_222 + 84)->u0 = 0x00;
	((word32) dwLoc2C_222 + 88)->u0 = 0x00;
	*((word32) dwLoc2C_222 + 61) = 0x00;
	((word32) dwLoc2C_222 + 24)->u0 = 0x00;
	((word32) dwLoc2C_222 + 40)->u0 = 0x00;
	((word32) dwLoc2C_222 + 44)->u0 = 0x00;
	uint32 ebx_154 = *((word32) dwLoc2C_222 + 0x0C) - *((word32) dwArg04 + 0x0AC8);
	uint32 ebx_155;
	for (ebx_155 = ebx_154 >> 0x0D; ebx_155 < (word32) (*((word32) dwLoc2C_222 + 16)) + (ebx_154 >> 0x0D); ++ebx_155)
	{
		struct Eq_35836 * ebp_201 = *((word32) dwArg04 + 0x0828);
		if (ebx_155 >= *((word32) dwArg04 + 2092))
			runtime.panicindex(gs);
		ebp_201[ebx_155 * 0x04] = (struct Eq_35836) dwLoc2C_222;
	}
	runtime/internal/atomic.Store((word32) dwLoc2C_222 + 48, *((word32) dwArg04 + 0x0810));
	((word32) dwLoc2C_222 + 60)->u0 = 0x01;
	word32 ebx_180 = Mem176[dwLoc2C_222 + 0x10:word32] + Mem176[dwArg04 + 0x0860:word32];
	Eq_4 edx_182 = *((word32) dwArg04 + 0x0864);
	*((word32) dwArg04 + 2144) = ebx_180;
	Mem187[dwArg04 + 0x0864:word32] = edx_182 + (ebx_180 <u 0x00);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg13 = <invalid>;
	runtime.(*mheap).freeSpanLocked(gs, dwArg04, dwLoc2C_222, 0x0100, stackArg13, 0x00, 0x00);
}

// 08065D10: void runtime.(*mheap).freeSpan(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mcentral).freeSpan
//      runtime.(*mspan).sweep
void runtime.(*mheap).freeSpan(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_59;
	word32 edi_60;
	runtime.systemstack(gs, fp - 0x10, out ebp_59, out edi_60);
}

// 08065D60: void runtime.(*mheap).freeManual(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack (ptr32 Eq_37201) dwArg0C)
// Called from:
//      runtime.stackpoolfree
//      runtime.stackfree
//      runtime.freeStackSpans
//      runtime.freeSomeWbufs.func1
void runtime.(*mheap).freeManual(struct Eq_2 * gs, Eq_4 dwArg08, struct Eq_37201 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	*((word32) dwArg08 + 61) = 0x01;
	word32 ebp_89;
	word32 esi_90;
	word32 edi_91;
	runtime.lock(esi, gs, dwArg04, out ebp_89, out esi_90, out edi_91);
	up32 ecx_33 = dwArg0C->dw0000 - (*((word32) dwArg08 + 16) << 0x0D);
	word32 ebx_35 = dwArg0C->dw0004;
	dwArg0C->dw0000 = ecx_33;
	dwArg0C->dw0004 = ebx_35 - (ecx_33 < 0x00);
	Eq_4 eax_43 = (word32) g_t81581B8 + (*((word32) dwArg08 + 16) << 0x0D);
	Eq_4 ecx_45 = g_t81581BC;
	g_t81581B8 = eax_43;
	Mem50[0x081581BC<p32>:word32] = ecx_45 + (eax_43 <u 0x00);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg13 = <invalid>;
	runtime.(*mheap).freeSpanLocked(gs, dwArg04, dwArg08, 0x0100, stackArg13, 0x00, 0x00);
	word32 edx_93;
	word32 ebx_94;
	runtime.unlock(gs, dwArg04, out edx_93, out ebx_94);
}

// 08065E10: void runtime.(*mheap).freeSpanLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_36938 bArg0C, Stack Eq_4 bArg0D, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeManual
//      runtime.(*mheap).freeSpan.func1
void runtime.(*mheap).freeSpanLocked(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_36938 bArg0C, Eq_4 bArg0D, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte cl_19 = (byte) (word32) *((word32) dwArg08 + 60);
	if (cl_19 == 0x01)
	{
		word16 cx_45 = (word16) (word32) *((word32) dwArg08 + 56);
		if (cx_45 != 0x00 || *((word32) dwArg08 + 48) != *((word32) dwArg04 + 0x0810))
		{
			Eq_4 ecx_57 = *((word32) dwArg08 + 48);
			Eq_4 edx_61 = *((word32) dwArg04 + 0x0810);
			Eq_4 ebx_63 = *((word32) dwArg08 + 0x0C);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			word32 esi_684;
			runtime.printhex(esi, gs, ebx_63, 0x00, out esi_684);
			runtime.printstring(gs);
			runtime.printint(ebx, gs, (word32) (word16) (word32) cx_45);
			runtime.printstring(gs);
			runtime.printint(ebx, gs, ecx_57);
			runtime.printstring(gs);
			runtime.printint(ebx, gs, edx_61);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		up32 ecx_161 = *((word32) dwArg04 + 2144) - *((word32) dwArg08 + 16);
		Eq_4 edx_163 = *((word32) dwArg04 + 0x0864);
		*((word32) dwArg04 + 2144) = ecx_161;
		*((word32) dwArg04 + 0x0864) = edx_163 - (ecx_161 < 0x00);
	}
	else
	{
		if (cl_19 != 0x02)
			runtime.throw(gs);
		if ((word16) (word32) *((word32) dwArg08 + 56) != 0x00)
			runtime.throw(gs);
	}
	if ((byte) (word32) bArg0C != 0x00)
	{
		Eq_4 ecx_180 = g_t81581C8 - (*((word32) dwArg08 + 16) << 0x0D);
		uint32 edx_182 = g_dw81581CC;
		g_t81581C8 = ecx_180;
		g_dw81581CC = edx_182 - (ecx_180 < 0x00);
	}
	if ((byte) (word32) bArg0D != 0x00)
	{
		uint32 ecx_199 = g_dw81581C0 + (*((word32) dwArg08 + 16) << 0x0D);
		uint32 edx_201 = g_dw81581C4;
		g_dw81581C0 = ecx_199;
		g_dw81581C4 = (uint32) ((bool) (ecx_199 < 0x00) + edx_201);
	}
	((word32) dwArg08 + 60)->u0 = 0x03;
	if (*((word32) dwArg08 + 8) != 0x00)
	{
		Eq_4 ecx_222;
		Eq_4 ecx_213 = *((word32) dwArg08 + 16);
		if (ecx_213 < 0x80)
			ecx_222 = (word32) dwArg04 + 0x0408 + ecx_213 * 0x08;
		else
			ecx_222 = (word32) dwArg04 + 0x0808;
		runtime.(*mSpanList).remove(gs, ecx_222, dwArg08);
		dwLoc20 = ecx_222;
		dwLoc1C = dwArg08;
	}
	*((word32) dwArg08 + 0x0044) = dwArg10;
	*((word32) dwArg08 + 72) = dwArg14;
	if ((byte) (SEQ(SLICE(dwArg14, word24, 8), dwArg14 == 0x00) & SEQ(SLICE(dwArg10, word24, 8), dwArg10 == 0x00)) != 0x00)
	{
		runtime.nanotime();
		*((word32) dwArg08 + 0x0044) = dwLoc20;
		*((word32) dwArg08 + 72) = dwLoc1C;
	}
	uint32 eax_292;
	((word32) dwArg08 + 76)->u0 = 0x00;
	uint32 ebx_285 = *((word32) dwArg08 + 0x0C) - *((word32) dwArg04 + 0x0AC8);
	if (ebx_285 >> 0x0D > 0x00)
	{
		struct Eq_35836 * edx_293 = *((word32) dwArg04 + 0x0828);
		if ((ebx_285 >> 0x0D) - 0x01 >= *((word32) dwArg04 + 2092))
			runtime.panicindex(gs);
		Eq_4 edx_304 = (edx_293 - 0x04)[ebx_285 >> 0x0D];
		if (edx_304 != 0x00)
		{
			if ((byte) (word32) *((word32) edx_304 + 60) == 0x03)
			{
				*((word32) dwArg08 + 0x0C) = *((word32) edx_304 + 0x0C);
				Mem327[dwArg08 + 0x10:word32] = Mem323[dwArg08 + 0x10:word32] + Mem323[edx_304 + 0x10:word32];
				*((word32) dwArg08 + 76) = *((word32) edx_304 + 76);
				*((word32) dwArg08 + 61) = (byte) ((word32) *((word32) edx_304 + 61) | (word32) (*((word32) dwArg08 + 61)));
				uint32 ebx_341 = (ebx_285 >> 0x0D) - *((word32) edx_304 + 16);
				struct Eq_35836 * esi_343 = *((word32) dwArg04 + 0x0828);
				if (ebx_341 >= *((word32) dwArg04 + 2092))
					runtime.panicindex(gs);
				esi_343[ebx_341 * 0x04] = (struct Eq_35836) dwArg08;
				Eq_4 ebp_353 = *((word32) edx_304 + 16);
				if (ebp_353 >= 0x80)
					runtime.(*mTreap).removeSpan(gs, (word32) dwArg04 + 0x0404, edx_304);
				else
					runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 4 + ebp_353 * 0x08, edx_304);
				((word32) edx_304 + 60)->u0 = 0x00;
				*((word32) dwArg04 + 11384) -= *((word32) dwArg04 + 11360);
				*edx_304 = *((word32) dwArg04 + 0x00002C6C);
				*((word32) dwArg04 + 0x00002C6C) = edx_304;
				eax_292 = ebx_341;
			}
			else
				eax_292 = ebx_285 >> 0x0D;
		}
		else
			eax_292 = ebx_285 >> 0x0D;
	}
	else
		eax_292 = ebx_285 >> 0x0D;
	Eq_4 ebx_390 = *((word32) dwArg08 + 16);
	uint32 ebp_392 = (word32) ebx_390 + eax_292;
	struct Eq_35836 * esi_394 = *((word32) dwArg04 + 0x0828);
	if (ebp_392 < *((word32) dwArg04 + 2092))
	{
		Eq_4 ebp_398 = esi_394[ebp_392 * 0x04];
		if (ebp_398 != 0x00 && (byte) ((word32) (*((word32) ebp_398 + 60))) == 0x03)
		{
			Mem414[dwArg08 + 0x10:word32] = ebx_390 + Mem388[ebp_398 + 0x10:word32];
			Mem418[dwArg08 + 0x4C:word32] = Mem414[dwArg08 + 0x4C:word32] + Mem414[ebp_398 + 0x4C:word32];
			*((word32) dwArg08 + 61) = (byte) ((word32) *((word32) ebp_398 + 61) | (word32) (*((word32) dwArg08 + 61)));
			struct Eq_35836 * esi_430 = *((word32) dwArg04 + 0x0828);
			uint32 eax_432 = *((word32) dwArg08 + 16) - 0x01 + eax_292;
			if (eax_432 >= *((word32) dwArg04 + 2092))
				runtime.panicindex(gs);
			esi_430[eax_432 * 0x04] = (struct Eq_35836) dwArg08;
			Eq_4 eax_443 = *((word32) ebp_398 + 16);
			if (eax_443 >= 0x80)
				runtime.(*mTreap).removeSpan(gs, (word32) dwArg04 + 0x0404, ebp_398);
			else
				runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 4 + eax_443 * 0x08, ebp_398);
			((word32) ebp_398 + 60)->u0 = 0x00;
			*((word32) dwArg04 + 11384) -= *((word32) dwArg04 + 11360);
			*ebp_398 = *((word32) dwArg04 + 0x00002C6C);
			*((word32) dwArg04 + 0x00002C6C) = ebp_398;
		}
	}
	Eq_4 edx_479 = *((word32) dwArg08 + 16);
	if (edx_479 >= 0x80)
		runtime.(*mTreap).insert(gs, (word32) dwArg04 + 0x0404, dwArg08);
	else
		runtime.(*mSpanList).insert(gs, (word32) dwArg04 + 4 + edx_479 * 0x08, dwArg08);
}

// 08066330: void runtime.scavengeTreapNode(Register up32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_27102) dwArg04, Stack Eq_27103 qwArg08, Stack up32 dwArg10, Stack up32 dwArg14)
// Called from:
//      runtime.scavengetreap
void runtime.scavengeTreapNode(up32 ebp, struct Eq_2 * gs, struct Eq_27102 * dwArg04, Eq_27103 qwArg08, up32 dwArg10, up32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_37789 * eax_18 = dwArg04->ptr0010;
	ui64 ebx_edx_151 = qwArg08 - SEQ(ecx_23, eax_18->dw0044);
	up32 ebx_26 = SLICE(ebx_edx_151, word32, 32);
	ui32 ecx_23 = eax_18->dw0048;
	if ((byte) (SEQ(SLICE(dwArg10, word24, 8), ebx_26 > dwArg14) | SEQ(SLICE(ebp, word24, 8), ebx_26 == dwArg14) & SEQ(SLICE(dwArg10, word24, 8), (word32) ebx_edx_151 > dwArg10)) == 0x00)
		return;
	uint32 ecx_61 = eax_18->dw004C;
	uint32 edx_62 = eax_18->dw0010;
	if (ecx_61 == edx_62)
		return;
	uint32 esi_74;
	uint32 ebx_69 = eax_18->dw000C;
	uint32 edx_70 = (edx_62 << 0x0D) + ebx_69;
	Eq_4 ebp_71 = g_t8157620;
	if (ebp_71 > 0x2000)
	{
		uint32 ebx_80 = ~(ebp_71 - 0x01);
		ebx_69 = (word32) ebp_71 + (ebx_69 - 0x01) & ebx_80;
		esi_74 = ebx_80 & edx_70;
		if (esi_74 <= ebx_69)
			return;
	}
	else
		esi_74 = edx_70;
	uint32 esi_93 = esi_74 - ebx_69;
	uint32 esi_97 = esi_93 - (ecx_61 << 0x0D);
	if (ebp_71 > 0x2000 && esi_97 == 0x00)
		return;
	uint32 ecx_112 = g_dw81581D0 + esi_97;
	uint32 ebp_114 = g_dw81581D4;
	g_dw81581D0 = ecx_112;
	g_dw81581D4 = (uint32) ((bool) (ecx_112 < 0x00) + ebp_114);
	eax_18->dw004C = esi_93 >> 0x0D;
	runtime.sysUnused(gs, ebx_69, esi_93);
}

// 08066450: Register uint32 runtime.scavengelist(Register uint32 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_37903)) dwArg04, Stack Eq_27103 qwArg08, Stack up32 dwArg10, Stack up32 dwArg14)
// Called from:
//      runtime.(*mheap).scavenge
uint32 runtime.scavengelist(uint32 edi, struct Eq_2 * gs, struct Eq_37903 ** dwArg04, Eq_27103 qwArg08, up32 dwArg10, up32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_37903 * eax_157 = *dwArg04;
	if (eax_157 == null)
		return edi;
	for (; eax_157 != null; eax_157 = eax_157->ptr0000)
	{
		ui64 esi_ebx_170 = qwArg08 - SEQ(edx_42, eax_157->dw0044);
		up32 esi_45 = SLICE(esi_ebx_170, word32, 32);
		up32 ebx_40 = (word32) esi_ebx_170;
		edi = SEQ(SLICE(edi, word24, 8), esi_45 == dwArg14) & SEQ(SLICE(ebx_40, word24, 8), ebx_40 > dwArg10);
		ui32 edx_42 = eax_157->dw0048;
		if ((byte) (SEQ(SLICE(ebx_40, word24, 8), esi_45 > dwArg14) | edi) != 0x00)
		{
			uint32 ebx_77 = eax_157->dw004C;
			uint32 esi_78 = eax_157->dw0010;
			if (ebx_77 == esi_78)
				goto l08066555;
			uint32 edx_88;
			edi = eax_157->dw000C;
			uint32 esi_84 = (esi_78 << 0x0D) + edi;
			Eq_4 ebp_85 = g_t8157620;
			if (ebp_85 > 0x2000)
			{
				uint32 edx_91 = ~(ebp_85 - 0x01);
				edi = (word32) ebp_85 + (edi - 0x01) & edx_91;
				edx_88 = edx_91 & esi_84;
				if (edx_88 > edi)
					goto l080664F7;
				goto l0806647B;
			}
			edx_88 = esi_84;
l080664F7:
			uint32 edx_101 = edx_88 - edi;
			uint32 edx_105 = edx_101 - (ebx_77 << 0x0D);
			if (ebp_85 > 0x2000 && edx_105 == 0x00)
				goto l0806647B;
			uint32 ecx_116 = g_dw81581D0 + edx_105;
			uint32 ebx_118 = g_dw81581D4;
			g_dw81581D0 = ecx_116;
			g_dw81581D4 = (uint32) ((bool) (ecx_116 < 0x00) + ebx_118);
			eax_157->dw004C = edx_101 >> 0x0D;
			runtime.sysUnused(gs, edi, edx_101);
		}
l08066555:
l0806647B:
	}
	return edi;
}

// 08066590: void runtime.(*mheap).scavenge(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_38008 dwArg08, Stack Eq_27103 qwArg0C, Stack up32 dwArg14, Stack up32 dwArg18)
// Called from:
//      runtime.sysmon
void runtime.(*mheap).scavenge(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_38008 dwArg08, Eq_27103 qwArg0C, up32 dwArg14, up32 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = *((word32) eax_18 + 24);
	*((word32) ecx_20 + 0x0068) = (word32) *((word32) ecx_20 + 0x0068) + 1;
	word32 esi_540;
	word32 ebp_539;
	uint32 edi_36;
	runtime.lock(esi, gs, dwArg04, out ebp_539, out esi_540, out edi_36);
	Eq_38050 eax_42 = 0x00;
	word32 ecx_428 = 0x00;
	while (eax_42 < 0x80)
	{
		if (eax_42 >= 0x80)
			runtime.panicindex(gs);
		edi_36 = runtime.scavengelist(edi_36, gs, (word32) dwArg04 + 4 + eax_42 * 0x08, qwArg0C, dwArg14, dwArg18);
		eax_42 = (word32) eax_42 + 1;
		ecx_428 = dwLoc38 + ecx_428;
	}
	runtime.scavengetreap(gs, *((word32) dwArg04 + 0x0404), qwArg0C, dwArg14, dwArg18);
	word32 ebx_79;
	word32 edx_81;
	runtime.unlock(gs, dwArg04, out edx_81, out ebx_79);
	Eq_4 eax_88 = *((word32) eax_18 + 24);
	--*((word32) eax_88 + 0x0068);
	Eq_363 ebx_24_8_124 = SLICE(ebx_79, word24, 8);
	uint32 eax_94 = dwLoc38 + ecx_428;
	if (g_dw8157740 > 0x00)
	{
		if (eax_94 > 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_124, gs, SEQ(dwArg08 >> 0x1F, dwArg08));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_124, gs, (uint64) (uint32) (eax_94 >> 0x14));
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		Eq_4 eax_172 = g_t81581B8;
		uint32 ecx_175 = g_dw81581D0;
		uint32 ebx_180 = g_dw81581CC;
		Eq_4 ebp_182 = g_t81581C8;
		uint32 esi_184 = g_dw81581C4;
		uint32 edi_186 = g_dw81581C0;
		Eq_4 eax_188 = g_t81581BC;
		uint32 ecx_190 = g_dw81581D4;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_180, word24, 8), gs, SEQ(dwArg08 >> 0x1F, dwArg08));
		runtime.printstring(gs);
		Eq_4 ebp_243 = runtime.printuint(ebp_182, gs, ebx_180 << 0x0C | ebp_182 >> 0x14, ebx_180 >> 0x14);
		runtime.printstring(gs);
		Eq_4 ebp_273 = runtime.printuint(ebp_243, gs, esi_184 << 0x0C | edi_186 >> 0x14, esi_184 >> 0x14);
		runtime.printstring(gs);
		Eq_4 ebp_303 = runtime.printuint(ebp_273, gs, eax_188 << 0x0C | eax_172 >> 0x14, eax_188 >> 0x14);
		runtime.printstring(gs);
		Eq_4 ebp_333 = runtime.printuint(ebp_303, gs, ecx_190 << 0x0C | ecx_175 >> 0x14, ecx_190 >> 0x14);
		runtime.printstring(gs);
		uint32 eax_359 = SLICE(SEQ(eax_188, eax_172) - SEQ(ecx_190, ecx_175), word32, 32);
		runtime.printuint(ebp_333, gs, eax_359 << 0x0C | eax_172 - ecx_175 >> 0x14, eax_359 >> 0x14);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 08066900: void runtime.(*mSpanList).remove(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.getempty
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).freeSpanLocked
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.stackalloc
//      runtime.freeStackSpans
//      runtime.freeSomeWbufs.func1
void runtime.(*mSpanList).remove(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg08 + 8) != dwArg04)
	{
		Eq_4 ecx_23 = *((word32) dwArg08 + 16);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx, word24, 8), gs, ecx_23);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		if (*dwArg04 == dwArg08)
			*dwArg04 = *dwArg08;
		else
			**((word32) dwArg08 + 4) = *dwArg08;
		if (dwArg08 == *((word32) dwArg04 + 4))
			*((word32) dwArg04 + 4) = *((word32) dwArg08 + 4);
		else
			*((word32) *dwArg08 + 4) = *((word32) dwArg08 + 4);
		dwArg08->u0 = 0x00;
		((word32) dwArg08 + 4)->u0 = 0x00;
		((word32) dwArg08 + 8)->u0 = 0x00;
	}
}

// 08066A70: void runtime.(*mSpanList).insert(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.getempty
//      runtime.(*mheap).freeSpanLocked
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.stackfree
void runtime.(*mSpanList).insert(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg08 != 0x00 || (*((word32) dwArg08 + 4) != 0x00 || *((word32) dwArg08 + 8) != 0x00))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		*dwArg08 = *dwArg04;
		Eq_4 edx_108 = *dwArg04;
		if (edx_108 != 0x00)
			*((word32) edx_108 + 4) = dwArg08;
		else
			*((word32) dwArg04 + 4) = dwArg08;
		*dwArg04 = dwArg08;
		*((word32) dwArg08 + 8) = dwArg04;
	}
}

// 08066B60: void runtime.(*mSpanList).insertBack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).alloc_m
void runtime.(*mSpanList).insertBack(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg08 != 0x00 || (*((word32) dwArg08 + 4) != 0x00 || *((word32) dwArg08 + 8) != 0x00))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		*((word32) dwArg08 + 4) = *((word32) dwArg04 + 4);
		Eq_4 edx_136 = *((word32) dwArg04 + 4);
		if (edx_136 != 0x00)
			*edx_136 = dwArg08;
		else
			*dwArg04 = dwArg08;
		*((word32) dwArg04 + 4) = dwArg08;
		*((word32) dwArg08 + 8) = dwArg04;
	}
}

// 08066C50: void runtime.(*mSpanList).takeAll(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_35145) dwArg04, Stack (ptr32 Eq_35146) dwArg08)
// Called from:
//      runtime.prepareFreeWorkbufs
void runtime.(*mSpanList).takeAll(struct Eq_2 * gs, struct Eq_35145 * dwArg04, struct Eq_35146 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_38494 * ecx_17 = dwArg08->ptr0000;
	if (ecx_17 == null)
		return;
	for (; ecx_17 != null; ecx_17 = ecx_17->ptr0000)
		ecx_17->ptr0008 = dwArg04;
	struct Eq_38494 * ecx_30 = dwArg04->ptr0000;
	if (ecx_30 != null)
	{
		dwArg08->ptr0004->ptr0000 = ecx_30;
		dwArg04->ptr0000->ptr0004 = dwArg08->ptr0004;
		dwArg04->ptr0000 = dwArg08->ptr0000;
	}
	else
	{
		struct Eq_38514 * ecx_35 = dwArg08->ptr0004;
		dwArg04->ptr0000 = dwArg08->ptr0000;
		dwArg04->ptr0004 = ecx_35;
	}
	dwArg08->ptr0000 = null;
	dwArg08->ptr0004 = null;
}

// 08066CC0: Register word32 runtime.addspecial(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.addfinalizer
//      runtime.setprofilebucket
word32 runtime.addspecial(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_33030 * ecx_32;
	Eq_4 edx_19 = g_t81493A8;
	if (dwArg04 < edx_19 || dwArg04 >= g_t81493AC)
		ecx_32 = null;
	else
	{
		Eq_4 ebx_25 = g_t8149108;
		uint32 ecx_28 = dwArg04 - edx_19;
		if (ecx_28 >> 0x0D >= g_t814910C)
			runtime.panicindex(gs);
		ecx_32 = (struct Eq_33030 *) *((word32) ebx_25 + (ecx_28 >> 0x0D) * 0x04);
		if (ecx_32 == null || (dwArg04 < ecx_32->t000C || (dwArg04 >= ecx_32->t0050 || (byte) ((word32) ecx_32->b003C) != 0x01)))
			ecx_32 = null;
	}
	if (ecx_32 == null)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_73 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_74 = *((word32) eax_73 + 24);
		*((word32) edx_74 + 0x0078) = (word32) *((word32) edx_74 + 0x0078) + 1;
		Eq_4 eax_79 = *((word32) eax_73 + 24);
		runtime.(*mspan).ensureSwept(gs, dwLoc24, ecx_32, dwLoc1C);
		byte dl_99 = (byte) (word32) *((word32) dwArg08 + 6);
		Eq_4 esi_104 = ecx_32->t000C;
		word32 ebp_111;
		word32 edi_347;
		word32 esi_113;
		runtime.lock(esi_104, gs, (char *) &ecx_32->t0050 + 4, out ebp_111, out esi_113, out edi_347);
		Eq_4 dwLoc04_328 = (char *) &ecx_32->t0050 + 4;
		up32 eax_120 = dwArg04 - esi_104;
		Eq_4 ecx_122 = (char *) &ecx_32->t0050 + 8;
		cu8 dl_248 = (byte) (word32) dl_99;
		while (true)
		{
			Eq_4 ax_203 = (word16) eax_120;
			Eq_4 ebx_127 = *ecx_122;
			if (ebx_127 == 0x00)
				break;
			up32 ebp_131 = (word32) *((word32) ebx_127 + 4);
			byte SCZO_133 = cond(eax_120 - ebp_131);
			bool Z_134 = SLICE(SCZO_133, bool, 2);
			bool C_178 = SLICE(SCZO_133, bool, 1);
			if (eax_120 == ebp_131)
			{
				word32 esi_135 = (word32) *((word32) ebx_127 + 6);
				esi_113 = esi_135;
				if (dl_248 == (byte) esi_135)
				{
					word32 ebx_351;
					word32 edx_350;
					runtime.unlock(gs, dwLoc04_328, out edx_350, out ebx_351);
					Eq_4 eax_160 = gs->ptr0000->tFFFFFFFC;
					Eq_4 edx_162 = *((word32) eax_79 + 0x0078);
					*((word32) eax_79 + 0x0078) = edx_162 - 0x01;
					if (edx_162 == 0x01 && (byte) ((word32) (*((word32) eax_160 + 0x006C))) != 0x00)
						((word32) eax_160 + 8)->u0 = ~0x0521;
					return esi_135;
				}
				byte SCZO_177 = cond(eax_120 - ebp_131);
				C_178 = SLICE(SCZO_177, bool, 1);
				Z_134 = SLICE(SCZO_177, bool, 2);
			}
			ax_203 = (word16) eax_120;
			if (C_178)
				break;
			if (!Z_134)
			{
				ax_203 = (word16) eax_120;
				if (dl_248 < (byte) ((word32) (*((word32) ebx_127 + 6))))
					break;
			}
			ecx_122 = ebx_127;
		}
		*((word32) dwArg08 + 4) = ax_203;
		*dwArg08 = *ecx_122;
		*ecx_122 = dwArg08;
		word32 ebx_349;
		word32 edx_348;
		runtime.unlock(gs, dwLoc04_328, out edx_348, out ebx_349);
		Eq_4 eax_227 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_229 = *((word32) eax_79 + 0x0078);
		*((word32) eax_79 + 0x0078) = edx_229 - 0x01;
		if (edx_229 == 0x01 && (byte) ((word32) (*((word32) eax_227 + 0x006C))) != 0x00)
			((word32) eax_227 + 8)->u0 = ~0x0521;
		return esi_113;
	}
}

// 08066EA0: Register word32 runtime.removespecial(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.removefinalizer
word32 runtime.removespecial(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_33030 * ecx_32;
	Eq_4 edx_19 = g_t81493A8;
	if (dwArg04 < edx_19 || dwArg04 >= g_t81493AC)
		ecx_32 = null;
	else
	{
		Eq_4 ebx_25 = g_t8149108;
		uint32 ecx_28 = dwArg04 - edx_19;
		if (ecx_28 >> 0x0D >= g_t814910C)
			runtime.panicindex(gs);
		ecx_32 = (struct Eq_33030 *) *((word32) ebx_25 + (ecx_28 >> 0x0D) * 0x04);
		if (ecx_32 == null || (dwArg04 < ecx_32->t000C || (dwArg04 >= ecx_32->t0050 || (byte) ((word32) ecx_32->b003C) != 0x01)))
			ecx_32 = null;
	}
	if (ecx_32 == null)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_73 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_74 = *((word32) eax_73 + 24);
		*((word32) edx_74 + 0x0078) = (word32) *((word32) edx_74 + 0x0078) + 1;
		Eq_4 eax_79 = *((word32) eax_73 + 24);
		Eq_4 esi_90 = runtime.(*mspan).ensureSwept(gs, dwLoc24, ecx_32, dwLoc1C);
		Eq_4 ebx_100 = ecx_32->t000C;
		word32 ebp_107;
		word32 esi_109;
		word32 edi_298;
		runtime.lock(esi_90, gs, (char *) &ecx_32->t0050 + 4, out ebp_107, out esi_109, out edi_298);
		Eq_4 dwLoc04_280 = (char *) &ecx_32->t0050 + 4;
		up32 eax_116 = dwArg04 - ebx_100;
		struct Eq_38869 * ecx_118 = (char *) &ecx_32->t0050 + 8;
		byte dl_215 = (byte) (word32) bArg08;
		while (true)
		{
			struct Eq_38869 * ebx_123 = ecx_118->ptr0000;
			if (ebx_123 == null)
				break;
			if ((word32) ebx_123->w0004 == eax_116 && dl_215 == (byte) ((word32) ebx_123->b0006))
			{
				ecx_118->ptr0000 = ebx_123->ptr0000;
				word32 ebx_302;
				word32 edx_301;
				runtime.unlock(gs, dwLoc04_280, out edx_301, out ebx_302);
				Eq_4 eax_190 = gs->ptr0000->tFFFFFFFC;
				Eq_4 edx_192 = *((word32) eax_79 + 0x0078);
				*((word32) eax_79 + 0x0078) = edx_192 - 0x01;
				if (edx_192 == 0x01 && (byte) ((word32) (*((word32) eax_190 + 0x006C))) != 0x00)
					((word32) eax_190 + 8)->u0 = ~0x0521;
				return;
			}
			ecx_118 = ebx_123;
		}
		word32 ebx_300;
		word32 edx_299;
		runtime.unlock(gs, dwLoc04_280, out edx_299, out ebx_300);
		Eq_4 eax_141 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_143 = *((word32) eax_79 + 0x0078);
		*((word32) eax_79 + 0x0078) = edx_143 - 0x01;
		if (edx_143 == 0x01 && (byte) ((word32) (*((word32) eax_141 + 0x006C))) != 0x00)
			((word32) eax_141 + 8)->u0 = ~0x0521;
		return;
	}
}

// 08067070: void runtime.addfinalizer(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.SetFinalizer.func2
void runtime.addfinalizer(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	byte bLoc1C = (byte) dwLoc1C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_386;
	word32 esi_387;
	word32 edi_388;
	runtime.lock(esi, gs, 135575028, out ebp_386, out esi_387, out edi_388);
	runtime.(*fixalloc).alloc(gs, &g_dw814B5AC);
	word32 edx_389;
	word32 ebx_390;
	runtime.unlock(gs, 135575028, out edx_389, out ebx_390);
	*((word32) dwLoc20 + 6) = 0x01;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc20 + 8) = dwArg08;
	else
		runtime.writebarrierptr((word32) dwLoc20 + 8, dwArg08);
	*((word32) dwLoc20 + 0x0C) = dwArg0C;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwLoc20 + 16) = dwArg10;
		*((word32) dwLoc20 + 20) = dwArg14;
	}
	else
	{
		runtime.writebarrierptr((word32) dwLoc20 + 16, dwArg10);
		runtime.writebarrierptr((word32) dwLoc20 + 20, dwArg14);
	}
	Eq_4 esi_133 = runtime.addspecial(gs, dwArg04, dwLoc20);
	if ((byte) (word32) bLoc1C == 0x00)
	{
		word32 ebp_391;
		word32 esi_392;
		word32 edi_393;
		runtime.lock(esi_133, gs, 135575028, out ebp_391, out esi_392, out edi_393);
		g_dw814B5C4 -= g_dw814B5AC;
		*dwLoc20 = g_t814B5B8;
		g_t814B5B8 = dwLoc20;
		word32 edx_394;
		word32 ebx_395;
		runtime.unlock(gs, 135575028, out edx_394, out ebx_395);
	}
	else if (g_dw81575E4 != 0x00)
	{
		runtime.findObject(esi_133, gs, dwArg04);
		Eq_4 eax_202 = gs->ptr0000->tFFFFFFFC;
		Eq_4 ecx_203 = *((word32) eax_202 + 24);
		*((word32) ecx_203 + 0x0078) = (word32) *((word32) ecx_203 + 0x0078) + 1;
		Eq_4 ecx_208 = *((word32) eax_202 + 24);
		Eq_4 ebx_210 = *((word32) ecx_208 + 92);
		word32 ebp_396;
		runtime.scanobject(gs, dwLoc1C, (word32) ebx_210 + 0x0950, out ebp_396);
		Eq_4 ebp_239;
		word32 esi_243;
		Eq_363 ebx_24_8_256 = SLICE(runtime.scanblock(gs, (word32) dwLoc20 + 8, 0x04, 0x08136000, (word32) ebx_210 + 0x0950, out ebp_239, out esi_243), word24, 8);
		if ((byte) (word32) g_b815756D != 0x00)
			runtime.(*gcWork).dispose(ebx_24_8_256, ebp_239, gs, dwLoc28, (word32) ebx_210 + 0x0950);
		Eq_4 eax_269 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_272 = *((word32) ecx_208 + 0x0078);
		*((word32) ecx_208 + 0x0078) = edx_272 - 0x01;
		if (edx_272 == 0x01 && (byte) ((word32) (*((word32) eax_269 + 0x006C))) != 0x00)
			((word32) eax_269 + 8)->u0 = ~0x0521;
	}
}

// 080672B0: void runtime.removefinalizer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.SetFinalizer.func1
void runtime.removefinalizer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_27 = runtime.removespecial(gs, dwArg04, 0x01);
	if (dwLoc08 == 0x00)
		return;
	word32 ebp_110;
	word32 esi_111;
	word32 edi_112;
	runtime.lock(esi_27, gs, 135575028, out ebp_110, out esi_111, out edi_112);
	g_dw814B5C4 -= g_dw814B5AC;
	*dwLoc08 = g_t814B5B8;
	g_t814B5B8 = dwLoc08;
	word32 edx_113;
	word32 ebx_114;
	runtime.unlock(gs, 135575028, out edx_113, out ebx_114);
}

// 08067340: void runtime.setprofilebucket(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.mProf_Malloc.func1
void runtime.setprofilebucket(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_114;
	word32 esi_115;
	word32 edi_116;
	runtime.lock(esi, gs, 135575028, out ebp_114, out esi_115, out edi_116);
	runtime.(*fixalloc).alloc(gs, &g_dw814B5D0);
	word32 edx_117;
	word32 ebx_118;
	runtime.unlock(gs, 135575028, out edx_117, out ebx_118);
	*((word32) dwLoc0C + 6) = 0x02;
	*((word32) dwLoc0C + 8) = dwArg08;
	runtime.addspecial(gs, dwArg04, dwLoc0C);
	if ((byte) (word32) bLoc08 != 0x00)
		return;
	runtime.throw(gs);
}

// 080673E0: void runtime.freespecial(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*mspan).sweep
void runtime.freespecial(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte cl_19 = (byte) (word32) *((word32) dwArg04 + 6);
	if (cl_19 == 0x01)
	{
		word32 ebp_52;
		word32 edi_53;
		word32 esi_54;
		runtime.lock(runtime.queuefinalizer(esi, gs, dwArg08, *((word32) dwArg04 + 8), *((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 16), *((word32) dwArg04 + 20)), gs, 135575028, out ebp_52, out esi_54, out edi_53);
		g_dw814B5C4 -= g_dw814B5AC;
		*dwArg04 = g_t814B5B8;
		g_t814B5B8 = dwArg04;
		word32 ebx_74;
		word32 edx_76;
		runtime.unlock(gs, 135575028, out edx_76, out ebx_74);
	}
	else if (cl_19 != 0x02)
		runtime.throw(gs);
	else
	{
		word32 ebp_115;
		word32 edi_116;
		word32 esi_117;
		runtime.lock(runtime.mProf_Free(esi, gs, *((word32) dwArg04 + 8), dwArg0C), gs, 135575028, out ebp_115, out esi_117, out edi_116);
		g_dw814B5E8 -= g_dw814B5D0;
		*dwArg04 = g_t814B5DC;
		g_t814B5DC = dwArg04;
		word32 ebx_137;
		word32 edx_139;
		runtime.unlock(gs, 135575028, out edx_139, out ebx_137);
	}
}

// 08067510: void runtime.(*gcBitsArena).tryAlloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.newMarkBits
void runtime.(*gcBitsArena).tryAlloc(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	runtime/internal/atomic.Loaduintptr();
	if ((word32) dwArg08 + dwLoc08 > 0xFFF8)
		return;
	runtime/internal/atomic.Xadduintptr(dwArg04, dwArg08);
	if (dwArg08 > 0xFFF8)
		return;
	if (dwArg08 - dwArg04 < 0xFFF8)
		return;
	runtime.panicindex(gs);
}

// 080675B0: Register Eq_4 runtime.newMarkBits(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.heapBits.initSpan
//      runtime.(*mspan).sweep
//      runtime.newAllocBits
Eq_4 runtime.newMarkBits(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Loadp();
	uint32 eax_25 = (word32) dwArg04 + 63 >> 0x06;
	runtime.(*gcBitsArena).tryAlloc(gs, dwLoc1C, eax_25 << 0x03);
	if (dwLoc18 != 0x00)
		return esi;
	Eq_4 esi_56;
	word32 ebp_265;
	word32 edi_266;
	runtime.lock(esi, gs, 0x081451C0, out ebp_265, out esi_56, out edi_266);
	Eq_4 eax_61 = g_t81451C8;
	runtime.(*gcBitsArena).tryAlloc(gs, eax_61, eax_25 << 0x03);
	if (dwLoc18 != 0x00)
	{
		word32 edx_267;
		word32 ebx_268;
		runtime.unlock(gs, 0x081451C0, out edx_267, out ebx_268);
		return esi_56;
	}
	else
	{
		Eq_4 esi_100 = runtime.newArenaMayUnlock(gs);
		runtime.(*gcBitsArena).tryAlloc(gs, g_t81451C8, eax_25 << 0x03);
		if (dwLoc18 != 0x00)
		{
			*((word32) eax_61 + 4) = g_t81451C4;
			g_t81451C4 = eax_61;
			word32 edx_269;
			word32 ebx_270;
			runtime.unlock(gs, 0x081451C0, out edx_269, out ebx_270);
			return esi_100;
		}
		else
		{
			runtime.(*gcBitsArena).tryAlloc(gs, eax_61, eax_25 << 0x03);
			if (dwLoc18 == 0x00)
				runtime.throw(gs);
			else
			{
				*((word32) eax_61 + 4) = g_t81451C8;
				runtime/internal/atomic.StorepNoWB(0x081451C8, eax_61);
				word32 edx_271;
				word32 ebx_272;
				runtime.unlock(gs, 0x081451C0, out edx_271, out ebx_272);
				return esi_100;
			}
		}
	}
}

// 08067740: Register Eq_4 runtime.newAllocBits(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.heapBits.initSpan
Eq_4 runtime.newAllocBits(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.newMarkBits(esi, gs, dwArg04);
}

// 08067780: Register Eq_4 runtime.nextMarkBitArenaEpoch(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.finishsweep_m
Eq_4 runtime.nextMarkBitArenaEpoch(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_96;
	Eq_4 esi_28;
	word32 edi_97;
	runtime.lock(esi, gs, 0x081451C0, out ebp_96, out esi_28, out edi_97);
	Eq_4 eax_33 = g_t81451D0;
	if (eax_33 != 0x00)
	{
		Eq_4 ecx_37 = g_t81451C4;
		if (ecx_37 == 0x00)
			g_t81451C4 = eax_33;
		else
		{
			while (true)
			{
				Eq_4 edx_43 = *((word32) eax_33 + 4);
				if (edx_43 == 0x00)
					break;
				eax_33 = edx_43;
			}
			*((word32) eax_33 + 4) = ecx_37;
			g_t81451C4 = g_t81451D0;
		}
	}
	g_t81451D0 = g_t81451CC;
	g_t81451CC = g_t81451C8;
	runtime/internal/atomic.StorepNoWB(0x081451C8, 0x00);
	word32 ebx_99;
	word32 edx_98;
	runtime.unlock(gs, 0x081451C0, out edx_98, out ebx_99);
	return esi_28;
}

// 08067830: Register word32 runtime.newArenaMayUnlock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.newMarkBits
word32 runtime.newArenaMayUnlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_73;
	Eq_4 eax_17 = g_t81451C4;
	if (eax_17 != 0x00)
	{
		g_t81451C4 = *((word32) eax_17 + 4);
		runtime.memclrNoHeapPointers(eax_17, 0x00010000);
		eax_73 = eax_17;
	}
	else
	{
		word32 ebx_128;
		word32 edx_127;
		runtime.unlock(gs, 0x081451C0, out edx_127, out ebx_128);
		Eq_4 esi_41 = runtime.sysAlloc();
		if (dwLoc0C == 0x00)
			runtime.throw(gs);
		word32 ebp_66;
		word32 edi_67;
		runtime.lock(esi_41, gs, 0x081451C0, out ebp_66, out esi, out edi_67);
		eax_73 = dwLoc0C;
	}
	((word32) eax_73 + 4)->u0 = 0x00;
	*eax_73 = 0x00;
	return esi;
}

// 080678F0: void runtime.newBucket(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.stkbucket
void runtime.newBucket(struct Eq_2 * gs, up32 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 eax_32;
	if (dwArg04 == 0x01)
		eax_32 = (dwArg08 << 0x02) + 88;
	else
	{
		if (dwArg04 > 0x03)
			runtime.throw(gs);
		eax_32 = (dwArg08 << 0x02) + 0x28;
	}
	runtime.persistentalloc(gs);
	g_dw815759C += eax_32;
	dwLoc08->dw0008 = dwArg04;
	dwLoc08->t0014 = dwArg08;
}

// 080679A0: void runtime.(*bucket).mp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mProf_FlushLocked
//      runtime.mProf_Malloc
//      runtime.mProf_Free
void runtime.(*bucket).mp(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 8) == 0x01)
		return;
	runtime.throw(gs);
}

// 080679F0: void runtime.(*bucket).bp(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_39754) dwArg04)
// Called from:
//      runtime.saveblockevent
void runtime.(*bucket).bp(struct Eq_2 * gs, struct Eq_39754 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_17 = dwArg04->dw0008;
	if (ecx_17 == 0x02 || ecx_17 == 0x03)
		return;
	runtime.throw(gs);
}

// 08067A50: void runtime.stkbucket(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack byte bArg18)
// Called from:
//      runtime.mProf_Malloc
//      runtime.saveblockevent
void runtime.stkbucket(struct Eq_2 * gs, up32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, byte bArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t8144FB8 == 0x00)
	{
		runtime.sysAlloc();
		if (g_t81576F0 == 0x00)
			g_t8144FB8 = dwLoc20;
		else
			runtime.writebarrierptr(135548856, dwLoc20);
		if (g_t8144FB8 == 0x00)
			runtime.throw(gs);
	}
	Eq_4 ecx_144 = dwArg10;
	Eq_4 edx_58 = dwArg0C;
	Eq_4 ebx_60 = 0x00;
	ui32 ebp_61 = 0x00;
	while (ebx_60 < dwArg10)
	{
		ui32 esi_74 = (word32) *edx_58 + ebp_61;
		edx_58 = (word32) edx_58 + 4;
		ebx_60 = (word32) ebx_60 + 1;
		ebp_61 = esi_74 * 0x0401 >> 0x06 ^ esi_74 * 0x0401;
	}
	ui32 ebp_89 = (word32) dwArg08 + ebp_61;
	ui32 esi_95 = ebp_89 * 0x0401 ^ ebp_89 * 0x0401 >> 0x06;
	Eq_4 ebp_99 = esi_95 * 0x09 >> 11 ^ esi_95 * 0x09;
	word32 edx_108 = (word32) ebp_99 + SLICE(ebp_99 * 1960066937, word32, 32);
	Eq_4 edx_83 = g_t8144FB8;
	Eq_4 ebx_231 = dwArg08;
	Eq_4 esi_103 = dwArg0C;
	Eq_4 eax_115 = ebp_99;
	uint32 ebp_116 = ebp_99 - (__rcr(edx_108, 0x01, SLICE(cond(edx_108), bool, 1)) >> 0x11) *s 179999;
	if (ebp_116 >= 179999)
		runtime.panicindex(gs);
	else
	{
		struct Eq_39869 * edx_127;
		for (edx_127 = *((word32) edx_83 + ebp_116 * 0x04); edx_127 != null; edx_127 = edx_127->ptr0000)
		{
			if (edx_127->dw0008 == dwArg04 && (eax_115 == edx_127->t000C && ebx_231 == edx_127->t0010))
			{
				word32 * edi_235 = (char *) &edx_127->t0014 + 4;
				Eq_4 ebx_238 = edx_127->t0014;
				if (ebx_238 > 0x20)
					runtime.panicslice(gs);
				runtime.eqslice(gs, edi_235, ebx_238, esi_103, ecx_144);
				dwLoc20 = ebx_238;
				if ((byte) (word32) bLoc10 != 0x00)
					return;
				eax_115 = ebp_99;
				ecx_144 = dwArg10;
				ebx_231 = dwArg08;
				esi_103 = dwArg0C;
			}
		}
		if ((byte) (word32) bArg18 == 0x00)
			return;
		runtime.newBucket(gs, dwArg04, ecx_144);
		Eq_4 edx_156 = *((word32) dwLoc20 + 20);
		if (edx_156 > 0x20)
			runtime.panicslice(gs);
		else
		{
			Eq_4 ebx_164 = dwArg10;
			if (edx_156 <= dwArg10)
				ebx_164 = edx_156;
			word32 ebp_418;
			word32 edi_420;
			word32 esi_419;
			runtime.memmove((word32) dwLoc20 + 24, dwArg0C, ebx_164 << 0x02, out ebp_418, out esi_419, out edi_420);
			*((word32) dwLoc20 + 0x0C) = ebp_99;
			*((word32) dwLoc20 + 16) = dwArg08;
			*dwLoc20 = *((word32) g_t8144FB8 + ebp_116 * 0x04);
			*((word32) g_t8144FB8 + ebp_116 * 0x04) = dwLoc20;
			if (dwArg04 == 0x01)
			{
				*((word32) dwLoc20 + 4) = g_t8144FD8;
				g_t8144FD8 = dwLoc20;
			}
			else if (dwArg04 == 0x03)
			{
				*((word32) dwLoc20 + 4) = g_t8144FE4;
				g_t8144FE4 = dwLoc20;
			}
			else
			{
				*((word32) dwLoc20 + 4) = g_t8144FB4;
				g_t8144FB4 = dwLoc20;
			}
		}
	}
}

// 08067CF0: void runtime.eqslice(Register (ptr32 Eq_2) gs, Stack (ptr32 word32) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.stkbucket
void runtime.eqslice(struct Eq_2 * gs, word32 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 != dwArg14)
		return;
	word32 * ebx_22 = dwArg04;
	Eq_4 ebp_23 = 0x00;
	while (ebp_23 < dwArg08)
	{
		word32 esi_34 = *ebx_22;
		if (ebp_23 >= dwArg14)
			runtime.panicindex(gs);
		if (esi_34 != *((word32) dwArg10 + ebp_23 * 0x04))
			return;
		++ebx_22;
		ebp_23 = (word32) ebp_23 + 1;
	}
}

// 08067D50: void runtime.mProf_NextCycle(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
//      runtime.gcSweep
void runtime.mProf_NextCycle(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_54;
	word32 esi_55;
	word32 edi_56;
	runtime.lock(esi, gs, 135624236, out ebp_54, out esi_55, out edi_56);
	uint32 eax_24 = g_dw8157688;
	uint32 edx_29 = SLICE((eax_24 + 0x01) * ~0x55555554, word32, 32);
	g_dw8157688 = eax_24 + 0x01 - ((edx_29 >> 0x1A) + (edx_29 >> 0x1A) * 0x02 << 0x19);
	g_b815768C = 0x00;
	word32 edx_57;
	word32 ebx_58;
	runtime.unlock(gs, 135624236, out edx_57, out ebx_58);
}

// 08067DC0: void runtime.mProf_Flush(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
//      runtime.gcSweep
void runtime.mProf_Flush(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_50;
	word32 esi_51;
	word32 edi_52;
	runtime.lock(esi, gs, 135624236, out ebp_50, out esi_51, out edi_52);
	if ((byte) (word32) g_b815768C == 0x00)
	{
		runtime.mProf_FlushLocked(gs);
		g_b815768C = 0x01;
	}
	word32 edx_53;
	word32 ebx_54;
	runtime.unlock(gs, 135624236, out edx_53, out ebx_54);
}

// 08067E20: void runtime.mProf_FlushLocked(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mProf_Flush
void runtime.mProf_FlushLocked(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_18 = g_dw8157688;
	Eq_4 ecx_20 = g_t8144FD8;
	while (ecx_20 != 0x00)
	{
		runtime.(*bucket).mp(gs, ecx_20);
		uint32 edx_39 = SLICE(eax_18 * ~0x55555554, word32, 32);
		uint32 ebx_43 = eax_18 - ((edx_39 >> 0x01) + (edx_39 >> 0x01) * 0x02);
		dwLoc0C->dw0000 += dwLoc0C->a0010[ebx_43].dw0000;
		dwLoc0C->dw0004 += dwLoc0C->a0010[ebx_43].dw0004;
		dwLoc0C->dw0008 += dwLoc0C->a0010[ebx_43].dw0008;
		dwLoc0C->dw000C += dwLoc0C->a0010[ebx_43].dw000C;
		dwLoc0C->a0010[ebx_43].dw0000 = 0x00;
		dwLoc0C->a0010[ebx_43].dw0004 = 0x00;
		dwLoc0C->a0010[ebx_43].dw0008 = 0x00;
		dwLoc0C->a0010[ebx_43].dw000C = 0x00;
		ecx_20 = *((word32) ecx_20 + 4);
	}
}

// 08067EF0: void runtime.mProf_Malloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.profilealloc
void runtime.mProf_Malloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp - 0x34 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD70(0x00, fp - 0x90);
	runtime.callers(gs);
	word32 ebp_146;
	word32 esi_147;
	word32 edi_148;
	runtime.lock(esi, gs, 135624236, out ebp_146, out esi_147, out edi_148);
	if (dwLocA8 > 0x20)
		runtime.panicslice(gs);
	else
	{
		runtime.stkbucket(gs, 0x01, dwArg04, fp - 0x94, dwLocA8, 0x01);
		uint32 ecx_62 = g_dw8157688;
		runtime.(*bucket).mp(gs, dwLocA0);
		uint32 edx_78 = SLICE((ecx_62 + 0x02) * ~0x55555554, word32, 32);
		ui32 ecx_81 = ecx_62 + 0x02 - ((edx_78 >> 0x01) + (edx_78 >> 0x01) * 0x02);
		*((word32) dwArg04 + (ecx_81 * 0x10 + 16)) = (word32) *((word32) dwArg04 + (ecx_81 * 0x10 + 16)) + 1;
		(dwArg04 + 0x18)[ecx_81 * 0x10] += dwArg04;
		word32 edx_149;
		word32 ebx_150;
		runtime.unlock(gs, 135624236, out edx_149, out ebx_150);
		word32 ebp_151;
		word32 edi_152;
		runtime.systemstack(gs, fp - 0x10, out ebp_151, out edi_152);
	}
}

// 08068050: Register Eq_4 runtime.mProf_Free(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.freespecial
Eq_4 runtime.mProf_Free(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 ebp_94;
	word32 edi_95;
	runtime.lock(esi, gs, 135624236, out ebp_94, out esi_28, out edi_95);
	uint32 eax_33 = g_dw8157688;
	runtime.(*bucket).mp(gs, dwArg04);
	uint32 edx_52 = SLICE((eax_33 + 0x01) * ~0x55555554, word32, 32);
	ui32 ecx_55 = eax_33 + 0x01 - ((edx_52 >> 0x01) + (edx_52 >> 0x01) * 0x02);
	++dwLoc08->a0014[ecx_55].dw0000;
	dwLoc08->a0014[ecx_55].dw0008 = (word32) dwArg08 + ((dwLoc08->a0014))[ecx_55].dw0008;
	word32 edx_96;
	word32 ebx_97;
	runtime.unlock(gs, 135624236, out edx_96, out ebx_97);
	return esi_28;
}

// 080680E0: void runtime.blockevent(Register Eq_3405 ebx, Register (ptr32 Eq_2) gs, Stack Eq_3407 fArg04, Stack Eq_3408 fArg08)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.semacquire1
void runtime.blockevent(Eq_3405 ebx, struct Eq_2 * gs, Eq_3407 fArg04, Eq_3408 fArg08)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_27 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	int32 ecx_43;
	Eq_40430 eax_42;
	if ((byte) (SEQ(ebx_24_8, dwArg08 < 0x00) | SEQ(ecx_24_8_27, dwArg08 == 0x00) & SEQ(ebx_24_8, dwArg04 <= 0x00)) != 0x00)
	{
		eax_42.u0 = 0x01;
		ecx_43 = 0x00;
	}
	else
	{
		eax_42 = dwArg04;
		ecx_43 = dwArg08;
	}
	runtime.blocksampled(edx, esi, gs, eax_42, ecx_43);
	if ((byte) (word32) bLoc08 != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.saveblockevent(gs, stackArg0, eax_42);
	}
}

// 08068180: void runtime.blocksampled(Register word32 edx, Register word32 esi, Register (ptr32 Eq_2) gs, Stack Eq_40430 dwArg04, Stack int32 dwArg08)
// Called from:
//      runtime.blockevent
void runtime.blocksampled(word32 edx, word32 esi, struct Eq_2 * gs, Eq_40430 dwArg04, int32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx_24_8 = SLICE(runtime.morestack_noctxt(), word24, 8);
	word64 mm0_203;
	ui32 ebx_48 = SEQ(SLICE(runtime/internal/atomic.Load64(0x08157668, out mm0_203), word24, 8), dwLoc14 <= 0x00) & SEQ(edx_24_8, dwLoc10 == 0x00) | SEQ(edx_24_8, dwLoc10 < 0x00);
	ui24 ebx_24_8_62 = SLICE(ebx_48, word24, 8);
	if ((byte) ebx_48 != 0x00)
		return;
	if ((byte) (SEQ(SLICE(esi, word24, 8), dwLoc14 > dwArg04) & SEQ(ebx_24_8_62, dwLoc10 == dwArg08) | SEQ(ebx_24_8_62, dwLoc10 > dwArg08)) != 0x00)
	{
		Eq_4 edx_92 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		Eq_40532 ebx_93 = *((word32) edx_92 + 0x0094);
		ui32 ebx_96 = ebx_93 >> 0x1F & 0xA8888EEF;
		Eq_40532 ebp_98 = ebx_93 << 0x01 ^ ebx_96;
		*((word32) edx_92 + 0x0094) = ebp_98;
		runtime.int64mod(SLICE(ebx_96, word24, 8), edi, gs, ebp_98, dwLoc14);
		if ((byte) (SEQ(SLICE(dwLoc08, word24, 8), dwLoc08 > dwArg04) & SEQ(SLICE(ebx_96, word24, 8), dwLoc04 == dwArg08) | SEQ(SLICE(dwLoc04, word24, 8), dwLoc04 > dwArg08)) != 0x00)
			;
	}
}

// 08068280: void runtime.saveblockevent(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_40430 dwArg04)
// Called from:
//      runtime.blockevent
//      sync.event
void runtime.saveblockevent(struct Eq_2 * gs, Eq_4 dwArg00, Eq_40430 dwArg04)
{
	while (fp - 0x28 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_46;
	fn0808FD70(0x00, fp - 0x88);
	struct Eq_40594 * edx_29 = dwLoc0C->ptr0018->ptr0054;
	if (edx_29 != null && edx_29 != dwLoc0C)
	{
		runtime.gcallers(gs, 0x20);
		eax_46 = dwLoc98;
	}
	else
	{
		runtime.callers(gs);
		eax_46 = dwLoc9C;
	}
	word32 edi_207;
	word32 ebp_205;
	word32 esi_206;
	runtime.lock(esi, gs, 135624236, out ebp_205, out esi_206, out edi_207);
	if (eax_46 > 0x20)
		runtime.panicslice(gs);
	else
	{
		runtime.stkbucket(gs, dwArg0C, 0x00, fp - 0x8C, eax_46, 0x01);
		runtime.(*bucket).bp(gs, dwLoc94);
		Eq_4 ecx_98 = null;
		Eq_4 edx_101 = *(union Eq_4 *) 0x04;
		null = (word32) ecx_98 + 1;
		Mem106[0x04:word32] = edx_101 + (ecx_98 <u 0x01);
		runtime.(*bucket).bp(gs, dwLoc94);
		ui64 ecx_ecx_137 = SEQ(dwArg04, *(union Eq_4 *) 0x08) + SEQ(*((union Eq_4 *) 0x0C), dwArg00);
		*(union Eq_4 *) 0x08 = (word32) ecx_ecx_137;
		*(union Eq_4 *) 0x0C = SLICE(ecx_ecx_137, word32, 32);
		word32 edx_202;
		word32 ebx_203;
		runtime.unlock(gs, 135624236, out edx_202, out ebx_203);
	}
}

// 08068410: void sync.event(Register word32 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 fArg08)
// Called from:
//      runtime.semrelease1
void sync.event(word32 ebx, struct Eq_2 * gs, Eq_4 fArg08)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_27 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_40430 ecx_39;
	if ((byte) (SEQ(ebx_24_8, Test(ULT,false)) & SEQ(ecx_24_8_27, dwArg08 == 0x00) | SEQ(ecx_24_8_27, dwArg08 < 0x00)) != 0x00)
		ecx_39.u0 = 0x00;
	else
		ecx_39 = dwArg04;
	word64 mm0_188;
	if ((byte) (SEQ(SLICE(runtime/internal/atomic.Load64(135624336, out mm0_188), word24, 8), dwLoc14 > 0x00) & SEQ(529782, dwLoc10 == 0x00) | SEQ(529782, dwLoc10 > 0x00)) != 0x00)
	{
		Eq_4 edx_85 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		Eq_40532 ebx_86 = *((word32) edx_85 + 0x0094);
		ui32 ebx_89 = ebx_86 >> 0x1F & 0xA8888EEF;
		Eq_40532 ebp_91 = ebx_86 << 0x01 ^ ebx_89;
		*((word32) edx_85 + 0x0094) = ebp_91;
		runtime.int64mod(SLICE(ebx_89, word24, 8), edi, gs, ebp_91, dwLoc14);
		if ((byte) (SEQ(SLICE(dwLoc04, word24, 8), dwLoc04 == 0x00) & SEQ(SLICE(dwLoc08, word24, 8), dwLoc08 == 0x00)) != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.saveblockevent(gs, stackArg0, ecx_39);
		}
	}
}

// 08068520: Register word32 runtime.tracealloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.mallocgc
word32 runtime.tracealloc(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_307;
	word32 esi_306;
	word32 ebp_305;
	runtime.lock(esi, gs, 0x08157658, out ebp_305, out esi_306, out edi_307);
	Eq_4 eax_25 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_25 + 24) + 461) = 0x02;
	if (dwArg0C != 0x00)
	{
		runtime.(*_type).string(gs, dwArg0C);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_309;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_309);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	else
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_308;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_308);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	Eq_4 ecx_145 = *((word32) *((word32) eax_25 + 24) + 84);
	if (ecx_145 != 0x00 && eax_25 != ecx_145)
	{
		runtime.goroutineheader(gs, ecx_145);
		runtime.traceback(gs);
	}
	else
	{
		runtime.goroutineheader(gs, eax_25);
		runtime.getcallerpc();
		word32 edi_311;
		word32 ebp_310;
		runtime.systemstack(gs, fp - 0x10, out ebp_310, out edi_311);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	*((word32) *((word32) eax_25 + 24) + 461) = 0x00;
	word32 edx_221;
	word32 ebx_312;
	runtime.unlock(gs, 0x08157658, out edx_221, out ebx_312);
	return edx_221;
}

// 08068770: void runtime.tracefree(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mspan).sweep
void runtime.tracefree(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 ebp_215;
	word32 edi_216;
	runtime.lock(esi, gs, 0x08157658, out ebp_215, out esi_28, out edi_216);
	Eq_4 eax_34 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_34 + 24) + 461) = 0x02;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	word32 esi_217;
	runtime.printhex(esi_28, gs, dwArg08, 0x00, out esi_217);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.goroutineheader(gs, eax_34);
	runtime.getcallerpc();
	word32 ebp_218;
	word32 edi_219;
	runtime.systemstack(gs, fp - 0x10, out ebp_218, out edi_219);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	*((word32) *((word32) eax_34 + 24) + 461) = 0x00;
	word32 edx_220;
	word32 ebx_221;
	runtime.unlock(gs, 0x08157658, out edx_220, out ebx_221);
}

// 080688B0: Register Eq_4 runtime.tracegc(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
Eq_4 runtime.tracegc(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 ebp_153;
	word32 edi_154;
	runtime.lock(esi, gs, 0x08157658, out ebp_153, out esi_28, out edi_154);
	Eq_4 eax_34 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_34 + 24) + 461) = 0x02;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 esi_69 = runtime.tracebackothers(esi_28, gs, eax_34);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	*((word32) *((word32) eax_34 + 24) + 461) = 0x00;
	word32 edx_155;
	word32 ebx_156;
	runtime.unlock(gs, 0x08157658, out edx_155, out ebx_156);
	return esi_69;
}

// 08068990: Register Eq_4 runtime.init.1(Register Eq_41072 ebx, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
Eq_4 runtime.init.1(Eq_41072 ebx, struct Eq_2 * gs)
{
	while (true)
	{
		Eq_4 esi_8 = *((word32) gs->ptr0000->tFFFFFFFC + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 6288)
			break;
		runtime.morestack_noctxt();
	}
	word32 * edi_22 = fp - 5528;
	word32 ecx_23;
	for (ecx_23 = 0x0566; ecx_23 != 0x00; --ecx_23)
	{
		*edi_22 = 0x00;
		++edi_22;
	}
	if (g_dw8136018 == 5528)
		return esi_8;
	runtime.printlock(gs);
	runtime.printint(ebx_24_8, gs, (uint64) (uint32) g_dw8136018);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, 5528);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 08068A50: void runtime.cachestats(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
void runtime.cachestats(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	word32 * ecx_20 = g_a81478C0;
	for (eax_17 = 0x00; eax_17 < 0x0401; ++eax_17)
	{
		Eq_4 edx_26 = *ecx_20;
		if (edx_26 == 0x00)
			return;
		Eq_4 edx_34 = *((word32) edx_26 + 52);
		if (edx_34 != 0x00)
			runtime.purgecachedstats(gs, edx_34);
		++ecx_20;
	}
}

// 08068AB0: void runtime.flushmcache(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04)
// Called from:
//      runtime.markroot
void runtime.flushmcache(struct Eq_2 * gs, uint32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 >= 0x0401)
		runtime.panicindex(gs);
	else
	{
		struct Eq_41184 * eax_23 = *((char *) g_a81478C0 + dwArg04 * 0x04);
		if (eax_23 == null)
			return;
		Eq_4 eax_29 = eax_23->t0034;
		if (eax_29 == 0x00)
			return;
		runtime.(*mcache).releaseAll(gs, eax_29);
		runtime.stackcache_clear(gs, eax_29);
	}
}

// 08068B20: void runtime.purgecachedstats(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.findObject
//      runtime.cachestats
//      runtime.freemcache.func1
void runtime.purgecachedstats(struct Eq_2 * gs, Eq_4 dwArg04)
{
	uint32 eax_9 = (word32) *((word32) dwArg04 + 4) + g_dw81597B8;
	uint32 edx_11 = g_dw81597BC;
	g_dw81597B8 = eax_9;
	g_dw81597BC = (uint32) ((bool) (eax_9 < 0x00) + edx_11);
	((word32) dwArg04 + 4)->u0 = 0x00;
	up32 eax_19 = (word32) *((word32) dwArg04 + 16) + g_dw8159798;
	word32 edx_21 = g_dw815979C;
	g_dw8159798 = eax_19;
	g_dw815979C = (word32) ((bool) (eax_19 < 0x00) + edx_21);
	((word32) dwArg04 + 16)->u0 = 0x00;
	up32 eax_29 = (word32) *((word32) dwArg04 + 588) + g_dw8158198;
	word32 edx_31 = g_dw815819C;
	g_dw8158198 = eax_29;
	g_dw815819C = (word32) ((bool) (eax_29 < 0x00) + edx_31);
	*((word32) dwArg04 + 588) = 0x00;
	up32 eax_39 = (word32) *((word32) dwArg04 + 592) + g_dw8149178;
	word32 edx_41 = g_dw814917C;
	g_dw8149178 = eax_39;
	g_dw814917C = (word32) ((bool) (eax_39 < 0x00) + edx_41);
	*((word32) dwArg04 + 592) = 0x00;
	up32 eax_49 = (word32) *((word32) dwArg04 + 596) + g_dw8149180;
	word32 edx_51 = g_dw8149184;
	g_dw8149180 = eax_49;
	g_dw8149184 = (word32) ((bool) (eax_49 < 0x00) + edx_51);
	*((word32) dwArg04 + 596) = 0x00;
	Eq_41310 eax_57 = 0x00;
	while (eax_57 < 0x43)
	{
		if (eax_57 >= 0x43)
			runtime.panicindex(gs);
		struct Eq_41315 * ebx_69 = eax_57 * 0x08 + 0x08149188;
		up32 ebp_71 = ebx_69->dw0000;
		up32 esi_73 = *((word32) dwArg04 + (eax_57 * 0x04 + 600));
		word32 ebx_76 = ebx_69->dw0004;
		g_a8149188[eax_57] = (struct Eq_141248) (ebp_71 + esi_73);
		ebx_69->dw0004 = (word32) ((bool) (ebp_71 + esi_73 < 0x00) + ebx_76);
		*((word32) dwArg04 + (eax_57 * 0x04 + 600)) = 0x00;
		eax_57 = (word32) eax_57 + 1;
	}
}

// 08068C60: void runtime.mSysStatInc(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.persistentalloc1
//      runtime.sysAlloc
//      runtime.sysMap
void runtime.mSysStatInc(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime/internal/atomic.Xadduintptr(dwArg04, dwArg08);
	if (dwArg08 < dwArg04)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, dwArg08);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, dwArg04);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.exit();
	}
}

// 08068D10: void runtime.mSysStatDec(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.persistentalloc1
//      runtime.sysFree
void runtime.mSysStatDec(Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 eax_8 = 0x00 - dwArg08;
	runtime/internal/atomic.Xadduintptr(dwArg04, eax_8);
	if (eax_8 + dwArg04 <u dwArg04)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, eax_8);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, dwArg04);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.exit();
	}
}

// 08068DD0: void internal/poll.runtime_pollServerInit(Register (ptr32 Eq_2) gs)
void internal/poll.runtime_pollServerInit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.netpollinit(gs);
	runtime/internal/atomic.Store(0x0815760C, 0x01);
}

// 08068E10: void runtime.netpollinited(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.findrunnable
//      runtime.pollWork
void runtime.netpollinited(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Load();
}

// 08068E50: Register word32 internal/poll.runtime_pollOpen(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out ptr32 esiOut)
// Called from:
//      internal/poll.(*pollDesc).init
word32 internal/poll.runtime_pollOpen(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_172;
	word32 esi_173;
	word32 edi_174;
	runtime.lock(runtime.(*pollCache).alloc(esi, gs, 0x081450A8), gs, (char *) dwLoc10 + 4, out ebp_172, out esi_173, out edi_174);
	word32 ecx_53 = dwLoc10->dw0044;
	if (ecx_53 == 0x00 || ecx_53 == 0x01)
	{
		word32 ecx_70 = dwLoc10->dw0014;
		if (ecx_70 == 0x00 || ecx_70 == 0x01)
		{
			dwLoc10->t0008 = dwArg04;
			dwLoc10->b000C = 0x00;
			++dwLoc10->dw0010;
			dwLoc10->dw0014 = 0x00;
			dwLoc10->dw003C = 0x00;
			dwLoc10->dw0040 = 0x00;
			dwLoc10->dw0044 = 0x00;
			dwLoc10->dw006C = 0x00;
			dwLoc10->dw0070 = 0x00;
			word32 edx_175;
			word32 ebx_176;
			runtime.unlock(gs, (char *) dwLoc10 + 4, out edx_175, out ebx_176);
			ptr32 esi_123;
			word32 ebx_120 = runtime.netpollopen(gs, out esi_123);
			esiOut = esi_123;
			return ebx_120;
		}
		else
			runtime.throw(gs);
	}
	else
		runtime.throw(gs);
}

// 08068F60: Register word32 internal/poll.runtime_pollClose(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out ptr32 esiOut)
// Called from:
//      internal/poll.(*pollDesc).init
//      internal/poll.(*pollDesc).close
word32 internal/poll.runtime_pollClose(struct Eq_2 * gs, Eq_4 dwArg04, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) *((word32) dwArg04 + 0x0C) == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_32 = *((word32) dwArg04 + 0x0044);
		if (ecx_32 == 0x00 || ecx_32 == 0x01)
		{
			Eq_4 ecx_49 = *((word32) dwArg04 + 20);
			if (ecx_49 == 0x00 || ecx_49 == 0x01)
			{
				ptr32 esi_91;
				word32 ebx_87 = runtime.(*pollCache).free(runtime.netpollclose(gs), gs, 0x081450A8, dwArg04, out esi_91);
				esiOut = esi_91;
				return ebx_87;
			}
			else
				runtime.throw(gs);
		}
		else
			runtime.throw(gs);
	}
}

// subject_text_0002.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text_0002.h"

// 08069020: Register word32 runtime.(*pollCache).free(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 esiOut)
// Called from:
//      internal/poll.runtime_pollClose
word32 runtime.(*pollCache).free(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_30;
	word32 ebp_65;
	word32 edi_66;
	runtime.lock(esi, gs, dwArg04, out ebp_65, out esi_30, out edi_66);
	*dwArg08 = *((word32) dwArg04 + 4);
	*((word32) dwArg04 + 4) = dwArg08;
	word32 ebx_42;
	word32 edx_67;
	runtime.unlock(gs, dwArg04, out edx_67, out ebx_42);
	esiOut = esi_30;
	return ebx_42;
}

// 08069070: Register word32 internal/poll.runtime_pollReset(Register ui32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_41647) dwArg04, Stack word32 dwArg08)
// Called from:
//      internal/poll.(*pollDesc).prepare
word32 internal/poll.runtime_pollReset(ui32 ebp, struct Eq_2 * gs, struct Eq_41647 * dwArg04, word32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_89;
	if ((byte) (word32) dwArg04->b000C != 0x00)
	{
		ecx_89 = 0x01;
		goto l08069097;
	}
	if (dwArg08 == 114)
	{
		int32 ebx_26 = dwArg04->dw0040;
		ui32 ebx_37 = SEQ(SLICE(ebp, word24, 8), ebx_26 == 0x00);
		ebp = ebx_37;
		if ((byte) (SEQ(SLICE(ebx_26, word24, 8), ebx_26 < 0x00) | SEQ(dwArg04->n003D, Test(ULT,false)) & ebx_37) != 0x00)
			goto l080690F1;
	}
	if (dwArg08 == 0x77)
	{
		int32 edx_60 = dwArg04->dw0070;
		if ((byte) (SEQ(SLICE(edx_60, word24, 8), edx_60 < 0x00) | SEQ(SLICE(ebp, word24, 8), edx_60 == 0x00) & SEQ(dwArg04->n006D, Test(ULT,false))) != 0x00)
		{
l080690F1:
			ecx_89 = 0x02;
			goto l08069097;
		}
	}
	ecx_89 = 0x00;
l08069097:
	if (ecx_89 != 0x00)
		return;
	if (dwArg08 == 114)
		dwArg04->dw0014 = 0x00;
	else if (dwArg08 == 0x77)
		dwArg04->dw0044 = 0x00;
	return;
}

// 08069130: Register int32 internal/poll.runtime_pollWait(Register (ptr32 Eq_41738) ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_41740) dwArg04, Stack (ptr32 Eq_41741) dwArg08)
// Called from:
//      internal/poll.(*pollDesc).wait
int32 internal/poll.runtime_pollWait(struct Eq_41738 * ebp, struct Eq_2 * gs, struct Eq_41740 * dwArg04, struct Eq_41741 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_90;
	if ((byte) (word32) dwArg04->b000C != 0x00)
	{
		ecx_90 = 0x01;
		goto l0806915E;
	}
	if (dwArg08 == (struct Eq_41741 *) 114)
	{
		int32 ebx_27 = dwArg04->dw0040;
		struct Eq_41738 * ebx_38 = SEQ(SLICE(ebp, word24, 8), ebx_27 == 0x00);
		ebx = SEQ(SLICE(ebx_27, word24, 8), ebx_27 < 0x00);
		ebp = ebx_38;
		if ((byte) (SEQ(dwArg04->n003D, Test(ULT,false)) & ebx_38 | ebx) != 0x00)
			goto l0806923A;
	}
	if (dwArg08 == (struct Eq_41741 *) 0x77)
	{
		int32 edx_61 = dwArg04->dw0070;
		int32 ebx_69 = SEQ(dwArg04->n006D, Test(ULT,false));
		ebp = SEQ(SLICE(ebp, word24, 8), edx_61 == 0x00) & ebx_69;
		ebx = ebx_69;
		if ((byte) (SEQ(SLICE(edx_61, word24, 8), edx_61 < 0x00) | ebp) != 0x00)
		{
l0806923A:
			ecx_90 = 0x02;
			goto l0806915E;
		}
	}
	ecx_90 = 0x00;
l0806915E:
	if (ecx_90 != 0x00)
		return ebx;
	do
	{
		int32 ebx_115 = runtime.netpollblock(ebp, gs, dwLoc14, dwArg04, dwArg08, SEQ(nLoc07, 0x00), bLoc04);
		if ((byte) (word32) bLoc04 != 0x00)
			return ebx_115;
		word32 ecx_201;
		if ((byte) (word32) dwArg04->b000C != 0x00)
		{
			ecx_201 = 0x01;
			goto l08069195;
		}
		if (dwArg08 == (struct Eq_41741 *) 114)
		{
			int32 edx_139 = dwArg04->dw0040;
			int32 ebx_146 = SEQ(dwArg04->n003D, Test(ULT,false));
			ebp = SEQ(SLICE(ebp, word24, 8), edx_139 == 0x00) & ebx_146;
			ebx_115 = ebx_146;
			if ((byte) (SEQ(SLICE(edx_139, word24, 8), edx_139 < 0x00) | ebp) != 0x00)
				goto l080691CB;
		}
		if (dwArg08 == (struct Eq_41741 *) 0x77)
		{
			word32 edx_172 = dwArg04->dw006C;
			int32 ebx_173 = dwArg04->dw0070;
			ebp = SEQ(SLICE(ebp, word24, 8), ebx_173 == 0x00) & SEQ(SLICE(edx_172, word24, 8), Test(ULT,false));
			ebx_115 = ebx_173;
			if ((byte) (SEQ(SLICE(edx_172, word24, 8), ebx_173 < 0x00) | ebp) == 0x00)
				goto l080691F8;
l080691CB:
			ecx_201 = 0x02;
		}
		else
		{
l080691F8:
			ecx_201 = 0x00;
		}
l08069195:
	} while (ecx_201 == 0x00);
	return ebx_115;
}

// 08069280: void internal/poll.runtime_pollUnblock(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_41907) dwArg04)
// Called from:
//      internal/poll.(*pollDesc).init
//      internal/poll.(*pollDesc).evict
void internal/poll.runtime_pollUnblock(Eq_4 esi, struct Eq_2 * gs, struct Eq_41907 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_30;
	word32 edi_31;
	Eq_4 esi_113;
	runtime.lock(esi, gs, (char *) dwArg04 + 4, out ebp_30, out esi_113, out edi_31);
	if ((byte) (word32) dwArg04->b000C != 0x00)
		runtime.throw(gs);
	else
	{
		dwArg04->b000C = 0x01;
		++dwArg04->dw0010;
		runtime.atomicstorep(fp - 0x0C, 0x00);
		runtime.netpollunblock(gs, dwArg04, 114, 0x00);
		runtime.netpollunblock(gs, dwArg04, 0x77, 0x00);
		if (dwArg04->dw002C != 0x00)
		{
			esi_113 = runtime.deltimer(esi_113, gs, &dwArg04->dw0010 + 2);
			if (g_t81576F0 == 0x00)
				dwArg04->dw002C = 0x00;
			else
				runtime.writebarrierptr(&dwArg04->dw002C, 0x00);
		}
		if (dwArg04->dw005C != 0x00)
		{
			runtime.deltimer(esi_113, gs, &dwArg04->dw002C + 7);
			if (g_t81576F0 == 0x00)
				dwArg04->dw005C = 0x00;
			else
				runtime.writebarrierptr(&dwArg04->dw005C, 0x00);
		}
		word32 ebx_191;
		word32 edx_193;
		runtime.unlock(gs, (char *) dwArg04 + 4, out edx_193, out ebx_191);
		if (dwLoc14 != 0x00)
			runtime.netpollgoready(gs);
		if (dwLoc14 != 0x00)
			runtime.netpollgoready(gs);
	}
}

// 08069430: void runtime.netpollready(Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_42050)) dwArg04, Stack word32 dwArg0C)
// Called from:
//      runtime.netpoll
void runtime.netpollready(struct Eq_2 * gs, struct Eq_42050 ** dwArg04, word32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_42050 * dwLoc04_101 = null;
	struct Eq_42050 * dwLoc08_113 = null;
	if (dwArg0C == 114 || dwArg0C == 233)
	{
		runtime.netpollunblock(gs, dwArg08, 114, 0x01);
		dwLoc04_101 = dwLoc0C;
	}
	if (dwArg0C == 0x77 || dwArg0C == 233)
	{
		runtime.netpollunblock(gs, dwArg08, 0x77, 0x01);
		dwLoc08_113 = dwLoc0C;
	}
	if (dwLoc04_101 != null)
	{
		dwLoc04_101->ptr0068 = (struct Eq_42050 *) *dwArg04;
		*dwArg04 = (struct Eq_42050 **) dwLoc04_101;
	}
	if (dwLoc08_113 != null)
	{
		dwLoc08_113->ptr0068 = (struct Eq_42050 *) *dwArg04;
		*dwArg04 = (struct Eq_42050 **) dwLoc08_113;
	}
}

// 08069510: void runtime.netpollblockcommit(Register (ptr32 Eq_42094) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void runtime.netpollblockcommit(struct Eq_42094 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime/internal/atomic.Casuintptr(dwArg08, 0x02, dwArg04);
	if ((byte) (word32) (byte) dwArg04 != 0x00)
		runtime/internal/atomic.Xadd(0x08157610, 0x01);
}

// 08069590: void runtime.netpollgoready(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.runtime_pollUnblock
void runtime.netpollgoready(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xadd(0x08157610, ~0x00);
	runtime.goready(gs);
}

// 080695E0: Register word32 runtime.netpollblock(Register (ptr32 Eq_41738) ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_41740) dwArg04, Stack (ptr32 Eq_41741) dwArg08, Stack (ptr32 Eq_41741) dwArg0C, Stack byte bArg10)
// Called from:
//      internal/poll.runtime_pollWait
word32 runtime.netpollblock(struct Eq_41738 * ebp, struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_41740 * dwArg04, struct Eq_41741 * dwArg08, struct Eq_41741 * dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = &dwArg04->b000C + 8;
	if (dwArg08 == (struct Eq_41741 *) 0x77)
		ecx_20 = &dwArg04->dw0040 + 1;
	edx_109 = dwArg08;
	while (true)
	{
		struct Eq_41741 * edx_109;
		word32 ebx_30 = *ecx_20;
		if (ebx_30 == 0x01)
			break;
		if (ebx_30 != 0x00)
			runtime.throw(gs);
		runtime/internal/atomic.Casuintptr(ecx_20, 0x00, 0x02);
		if (0x02 != 0x00)
		{
			if ((byte) (word32) bArg10 == 0x00)
			{
				word32 eax_147;
				if ((byte) (word32) dwArg08->b000C != 0x00)
				{
					eax_147 = 0x01;
					goto l080696D2;
				}
				bool Z_115;
				if (dwArg0C == (struct Eq_41741 *) 114)
				{
					int32 ebx_83 = dwArg08->dw0040;
					edx_109 = SEQ(dwArg08->n003D, Test(ULT,false)) & SEQ(SLICE(ebp, word24, 8), ebx_83 == 0x00) | SEQ(SLICE(ebx_83, word24, 8), ebx_83 < 0x00);
					if ((byte) edx_109 != 0x00)
						goto l08069702;
					Z_115 = SLICE(cond(dwArg0C - 0x77), bool, 2);
				}
				else
					Z_115 = SLICE(cond(dwArg0C - 0x77), bool, 2);
				ui24 edx_24_8_129 = SLICE(edx_109, word24, 8);
				if (!Z_115)
				{
					int32 eax_121 = dwArg08->dw0070;
					if ((byte) (SEQ(dwArg08->n006D, Test(ULT,false)) & SEQ(edx_24_8_129, eax_121 == 0x00) | SEQ(SLICE(eax_121, word24, 8), eax_121 < 0x00)) == 0x00)
						goto l0806972B;
l08069702:
					eax_147 = 0x02;
				}
				else
				{
l0806972B:
					eax_147 = 0x00;
				}
l080696D2:
				if (eax_147 != 0x00)
				{
l08069692:
					word32 ebx_195 = runtime/internal/atomic.Xchguintptr(dwArg00, 0x00);
					if (true)
						runtime.throw(gs);
					else
						return ebx_195;
				}
			}
			runtime.gopark(gs);
			goto l08069692;
		}
		ecx_20 = dwArg00;
		edx_109 = dwArg0C;
	}
	*ecx_20 = 0x00;
	return ebx_30;
}

// 08069780: void runtime.netpollunblock(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_41907) dwArg04, Stack word32 dwArg08, Stack byte bArg0C)
// Called from:
//      internal/poll.runtime_pollUnblock
//      runtime.netpollready
void runtime.netpollunblock(struct Eq_2 * gs, struct Eq_41907 * dwArg04, word32 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_24;
	if (dwArg08 == 0x77)
		eax_24 = &dwArg04->dw002C + 6;
	else
		eax_24 = &dwArg04->dw0010 + 1;
	do
	{
		Eq_4 ecx_32 = *eax_24;
		if (ecx_32 == 0x01)
			return;
		word32 edx_148;
		if (ecx_32 == 0x00)
		{
			edx_148 = (word32) bArg0C;
			if ((byte) edx_148 == 0x00)
				return;
		}
		else
			edx_148 = (word32) bArg0C;
		runtime/internal/atomic.Casuintptr(eax_24, ecx_32, (word32) (byte) edx_148);
	} while ((byte) (word32) bLoc0C == 0x00);
}

// 08069830: Register Eq_4 runtime.(*pollCache).alloc(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.runtime_pollOpen
Eq_4 runtime.(*pollCache).alloc(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_28;
	word32 edi_29;
	Eq_4 esi_115;
	runtime.lock(esi, gs, dwArg04, out ebp_28, out esi_115, out edi_29);
	if (*((word32) dwArg04 + 4) == 0x00)
	{
		runtime.persistentalloc(gs);
		Eq_42338 edx_55 = 0x00;
		while (edx_55 < 0x22)
		{
			Eq_4 ebp_65 = dwLoc08 + edx_55 *s 0x78;
			esi_115 = *((word32) dwArg04 + 4);
			*ebp_65 = esi_115;
			*((word32) dwArg04 + 4) = ebp_65;
			edx_55 = (word32) edx_55 + 1;
		}
	}
	*((word32) dwArg04 + 4) = **((word32) dwArg04 + 4);
	word32 edx_120;
	word32 ebx_121;
	runtime.unlock(gs, dwArg04, out edx_120, out ebx_121);
	return esi_115;
}

// 080698E0: void runtime.netpollinit(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.runtime_pollServerInit
void runtime.netpollinit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.epollcreate1();
	g_t813600C = dwLoc08;
	if (dwLoc08 >= 0x00)
		return;
	Eq_363 ebx_24_8_65 = SLICE(runtime.epollcreate(), word24, 8);
	g_t813600C = dwLoc08;
	if (dwLoc08 < 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		Eq_42408 eax_60 = -dwLoc08;
		runtime.printint(ebx_24_8_65, gs, SEQ(eax_60 >> 0x1F, eax_60));
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
		runtime.closeonexec();
}

// 080699B0: Register word32 runtime.netpollopen(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut)
// Called from:
//      internal/poll.runtime_pollOpen
word32 runtime.netpollopen(struct Eq_2 * gs, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_38;
	word32 ebx_35 = runtime.epollctl(out esi_38);
	esiOut = esi_38;
	return ebx_35;
}

// 08069A30: Register word32 runtime.netpollclose(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.runtime_pollClose
word32 runtime.netpollclose(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_32;
	runtime.epollctl(out esi_32);
	return esi_32;
}

// 08069AA0: Register word32 runtime.netpoll(Register (ptr32 Eq_2) gs, Stack Eq_42463 bArg04)
// Called from:
//      runtime.startTheWorldWithSema
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.sysmon
word32 runtime.netpoll(struct Eq_2 * gs, Eq_42463 bArg04)
{
	while (fp - 1444 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t813600C == ~0x00)
		return esi;
	word32 * edi_213 = fp - 0x0600;
	word32 ecx_216;
	for (ecx_216 = 0x0180; ecx_216 != 0x00; --ecx_216)
	{
		*edi_213 = 0x00;
		++edi_213;
	}
	do
	{
		word32 esi_55 = runtime.epollwait();
		Eq_42502 eax_139 = dwLoc0614;
		if (dwLoc0614 >= 0x00)
		{
			Eq_42502 ecx_142 = 0x00;
			while (ecx_142 < eax_139)
			{
				if (ecx_142 >= 0x80)
					runtime.panicindex(gs);
				ui32 ebx_95 = (fp - 0x0600)[ecx_142].dw0000;
				if (ebx_95 != 0x00)
				{
					word32 ebp_102;
					if ((ebx_95 & 0x2019) != 0x00)
						ebp_102 = 114;
					else
						ebp_102 = 0x00;
					word32 ebx_111;
					if ((ebx_95 & 0x1C) != 0x00)
						ebx_111 = ebp_102 + 0x77;
					else
						ebx_111 = ebp_102;
					if (ebx_111 != 0x00)
					{
						runtime.netpollready(gs, fp - 0x0604, ebx_111);
						eax_139 = dwLoc0614;
					}
				}
				ecx_142 = (word32) ecx_142 + 1;
			}
			if ((byte) (word32) bArg04 != 0x00 && true)
				continue;
			return esi_55;
		}
	} while (dwLoc0614 == ~0x03);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(SLICE(ebx_52, word24, 8), gs, g_t813600C);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(SLICE(ebx_52, word24, 8), gs, -dwLoc0614);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 08069CA0: Register word32 runtime.futexsleep(Register Eq_13374 ecx, Register Eq_13382 ebx, Register Eq_4 esi, Stack (ptr32 Eq_13398) dwArg0C, Stack (ptr32 Eq_13398) dwArg10, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.lock
//      runtime.notesleep
//      runtime.notetsleep_internal
word32 runtime.futexsleep(Eq_13374 ecx, Eq_13382 ebx, Eq_4 esi, struct Eq_13398 * dwArg0C, struct Eq_13398 * dwArg10, ptr32 & esiOut, ptr32 & ediOut)
{
	if ((byte) (SEQ(ecx_24_8, dwArg10 < null) | SEQ(ebx_24_8, dwArg10 == null) & SEQ(ecx_24_8, Test(ULT,false))) == 0x00)
	{
		runtime.timediv(esi, dwArg0C, dwArg10, 1000000000, fp - 0x04);
		ptr32 edi_59;
		ptr32 esi_61;
		word32 ebp_56 = runtime.futex(out esi_61, out edi_59);
		esiOut = esi_61;
		ediOut = edi_59;
		return ebp_56;
	}
	else
	{
		ptr32 edi_76;
		ptr32 esi_78;
		word32 ebp_73 = runtime.futex(out esi_78, out edi_76);
		esiOut = esi_78;
		ediOut = edi_76;
		return ebp_73;
	}
}

// 08069D70: void runtime.futexwakeup()
// Called from:
//      runtime.unlock
//      runtime.notewakeup
void runtime.futexwakeup()
{
	word32 edi_78;
	word32 esi_77;
	runtime.futex(out esi_77, out edi_78);
	if (dwLoc10 >= 0x00)
		return;
	word32 edi_81;
	word32 ebp_80;
	runtime.systemstack(gs, fp - 0x0C, out ebp_80, out edi_81);
	*(word32 *) 0x1006 = 0x1006;
}

// 08069DF0: Register Eq_4 runtime.getproccount(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.osinit
Eq_4 runtime.getproccount(struct Eq_2 * gs)
{
	while (true)
	{
		Eq_4 esi_138 = *((word32) gs->ptr0000->tFFFFFFFC + 8);
		if (esi_138 != ~0x0521 && (fp + 880) - esi_138 > 0x2300)
			break;
		runtime.morestack_noctxt();
	}
	word32 * edi_22 = fp - 0x2000;
	word32 ecx_23;
	for (ecx_23 = 0x0800; ecx_23 != 0x00; --ecx_23)
	{
		*edi_22 = 0x00;
		++edi_22;
	}
	runtime.sched_getaffinity();
	if (dwLoc2004 < 0x00)
		return esi_138;
	Eq_42692 eax_47 = dwLoc2004 + ((dwLoc2004 >> 0x1F) >> 0x1E);
	if (eax_47 >> 0x02 > 0x0800)
		runtime.panicslice(gs);
	else
	{
		int32 ecx_52;
		word32 * edx_53 = fp - 0x2000;
		word32 ebx_54 = 0x00;
		for (ecx_52 = 0x00; ecx_52 < eax_47 >> 0x02; ++ecx_52)
		{
			Eq_4 ebp_75 = *edx_53;
			while (ebp_75 != 0x00)
			{
				esi_138 = ebp_75 >> 0x01;
				ebx_54 += ebp_75 & 0x01;
				ebp_75 = esi_138;
			}
			++edx_53;
		}
		return esi_138;
	}
}

// 08069ED0: void runtime.newosproc(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_42731) dwArg04)
// Called from:
//      runtime.newm
void runtime.newosproc(struct Eq_2 * gs, struct Eq_42731 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.sigprocmask();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	runtime.clone(stackArg0, 0x00050F00, dwArg08, dwArg04, dwArg04->dw0000, g_t80E7C84);
	runtime.sigprocmask();
	if (dwLoc1C >= 0x00)
		return;
	Eq_4 eax_78 = g_t8145400;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx, gs, eax_78);
	runtime.printstring(gs);
	runtime.printint(ebx, gs, -dwLoc1C);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	if (dwLoc1C == ~0x0A)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
	}
	runtime.throw(gs);
}

// 0806A070: void runtime.sysargs(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.args
void runtime.sysargs(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x01AC <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 eax_20 = (word32) dwArg04 + 1;
	while (*((word32) dwArg08 + eax_20 * 0x04) != 0x00)
		++eax_20;
	runtime.sysauxv(gs, (word32) dwArg08 + 4 + eax_20 * 0x04, 0x10000000);
	if (dwLoc0220 != 0x00)
		return;
	if (g_dw81426F4 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		runtime.open();
		if (dwLoc0220 >= 0x00)
		{
			runtime.duffzero(0x00, fp - 0x0204);
			runtime.read();
			runtime.closefd();
			if (false)
				return;
			runtime.sysauxv(gs, fp - 0x0208, 0x80);
		}
		else
		{
			runtime.mmap();
			if (dwLoc0214 < 0x1000)
				return;
			Eq_4 ecx_152;
			for (ecx_152 = 0x1000; ecx_152 < 0x00040000; ecx_152 <<= 0x01)
			{
				runtime.mincore();
				if (false)
				{
					g_t8157620 = ecx_152;
					break;
				}
			}
			if (g_t8157620 == 0x00)
				g_t8157620.u0 = 0x00040000;
			runtime.munmap();
		}
	}
}

// 0806A280: void runtime.sysauxv(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_42830) dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.sysargs
void runtime.sysauxv(struct Eq_2 * gs, struct Eq_42830 * dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_17;
	for (eax_17 = 0x00; eax_17 < dwArg08; eax_17 += 0x02)
	{
		word32 ebx_28 = dwArg04[eax_17];
		if (ebx_28 == 0x00)
			return;
		if (eax_17 + 0x01 >= dwArg08)
			runtime.panicindex(gs);
		Eq_4 ebp_43 = dwArg04->a0004[eax_17];
		if (ebx_28 == 0x06)
			g_t8157620 = ebp_43;
		else if (ebx_28 == 0x19)
		{
			g_t814516C.u0 = 0x10;
			g_dw8145170 = 0x10;
			if (g_t81576F0 == 0x00)
				g_t8145168 = ebp_43;
			else
				runtime.writebarrierptr(0x08145168, ebp_43);
		}
	}
	runtime.panicindex(gs);
}

// 0806A360: Register word32 runtime.osinit(Register (ptr32 Eq_2) gs)
// Called from:
//      main
word32 runtime.osinit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_23 = runtime.getproccount(gs);
	g_t8157608 = dwLoc04;
	return esi_23;
}

// 0806A390: void runtime.getRandomData(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.alginit
void runtime.getRandomData(struct Eq_2 * gs, word64 mm0, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t8145168;
	Eq_4 ecx_18 = g_t814516C;
	if (eax_17 == 0x00)
	{
		if (g_dw8142704 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			runtime.open();
			if (dwArg08 <= 0x00)
				runtime.panicindex(gs);
			else
			{
				runtime.read();
				runtime.closefd();
				runtime.extendRandom(gs, mm0, dwArg04, dwArg08, dwLoc10);
			}
		}
	}
	else
	{
		if (dwArg08 <= ecx_18)
			ecx_18 = dwArg08;
		word32 ebp_192;
		word32 esi_193;
		word32 edi_194;
		runtime.memmove(dwArg04, eax_17, ecx_18, out ebp_192, out esi_193, out edi_194);
		runtime.extendRandom(gs, mm0, dwArg04, dwArg08, ecx_18);
	}
}

// 0806A4B0: void runtime.goenvs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.goenvs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.goenvs_unix(gs);
}

// 0806A4D0: void runtime.mpreinit(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mcommoninit
void runtime.mpreinit(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.malg(gs, 0x8000);
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 44) = dwLoc08;
	else
		runtime.writebarrierptr((word32) dwArg04 + 44, dwLoc08);
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc08 + 24) = dwArg04;
	else
		runtime.writebarrierptr((word32) dwLoc08 + 24, dwArg04);
}

// 0806A550: void runtime.minit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart1
//      runtime.needm
void runtime.minit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.minitSignals(gs);
	runtime.gettid();
	Eq_4 eax_30 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_30 + 36) = dwLoc04;
	((word32) eax_30 + 40)->u0 = 0x00;
}

// 0806A5A0: void runtime.unminit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.dropm
void runtime.unminit(struct Eq_2 * gs)
{
	runtime.unminitSignals(gs);
}

// 0806A5B0: Register word32 runtime.sigprocmask()
// Called from:
//      runtime.newosproc
//      runtime.msigsave
//      runtime.msigrestore
//      runtime.sigblock
//      runtime.unblocksig
//      runtime.minitSignalMask
word32 runtime.sigprocmask()
{
	return runtime.rtsigprocmask();
}

// 0806A5E0: void runtime.setsig(Stack word32 dwArg08)
// Called from:
//      runtime.initsig
//      runtime.dieFromSignal
//      runtime.raisebadsignal
void runtime.setsig(word32 dwArg08)
{
	fn0808FD8B(0x00, fp - 0x34);
	runtime.rt_sigaction();
}

// 0806A6F0: void runtime.setsigstack()
// Called from:
//      runtime.initsig
void runtime.setsigstack()
{
	fn0808FD8B(0x00, fp - 0x14);
	runtime.rt_sigaction();
	if ((dwLoc10 & 0x08000000) != 0x00)
		return;
	runtime.rt_sigaction();
}

// 0806A770: void runtime.getsig(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.initsig
void runtime.getsig(struct Eq_2 * gs)
{
	fn0808FD8B(0x00, fp - 0x14);
	runtime.rt_sigaction();
	if (dwLoc18 == 0x00)
		return;
	runtime.throw(gs);
}

// 0806A7D0: void runtime.panicCheckMalloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.panicindex
//      runtime.panicslice
//      runtime.panicdivide
//      runtime.panicoverflow
//      runtime.panicfloat
//      runtime.panicmem
void runtime.panicCheckMalloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = gs->ptr0000->tFFFFFFFC;
	if (eax_17 == 0x00)
		return;
	Eq_4 eax_21 = *((word32) eax_17 + 24);
	if (eax_21 == 0x00 || *((word32) eax_21 + 0x0068) == 0x00)
		return;
	if (dwArg04 != 0x08136690)
		runtime.panicdottypeI(gs, dwArg04);
	else
		runtime.throw(gs);
}

// 0806A860: void runtime.panicindex(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg1
//      runtime.cgoIsGoPointer
//      runtime.cgoCheckTypedBlock
//      runtime.(*cpuProfile).addNonGo
//      runtime.(*cpuProfile).addExtra
//      runtime.makeBucketArray
//      runtime.evacuate
//      runtime.getitab
//      runtime.additab
//      runtime.mallocinit
//      runtime.(*mcache).nextFree
//      runtime.mallocgc
//      runtime.nextSample
//      runtime.gcmarkwb_m
//      runtime.markBitsForAddr
//      runtime.heapBitsForObject
//      runtime.bulkBarrierPreWrite
//      runtime.heapBitsSetTypeGCProg
//      runtime.progToPointerMask
//      runtime.allocmcache
//      runtime.(*mcache).refill
//      runtime.(*mcache).releaseAll
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).grow
//      runtime.queuefinalizer
//      runtime.runfinq
//      runtime.SetFinalizer
//      runtime.findObject
//      runtime.(*gcControllerState).enlistWorker
//      runtime.gcMark
//      runtime.clearpools
//      runtime.itoaDiv
//      runtime.fmtNSAsMS
//      runtime.gcMarkRootCheck
//      runtime.markroot
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.scanobject
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.(*gcSweepBuf).block
//      runtime.(*gcWork).put
//      runtime.(*gcWork).tryGet
//      runtime.(*gcWork).get
//      runtime.handoff
//      runtime.(*mheap).init
//      runtime.(*mheap).mapSpans
//      runtime.(*mheap).reclaim
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.addspecial
//      runtime.removespecial
//      runtime.(*gcBitsArena).tryAlloc
//      runtime.stkbucket
//      runtime.eqslice
//      runtime.flushmcache
//      runtime.purgecachedstats
//      runtime.netpoll
//      runtime.sysargs
//      runtime.sysauxv
//      runtime.getRandomData
//      runtime.testdefersizes
//      runtime.newdefer
//      runtime.printfloat
//      runtime.printuint
//      runtime.printhex
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.helpgc
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.needm
//      runtime.findrunnable
//      runtime.sigprof
//      runtime.procresize
//      runtime.checkdead
//      runtime.retake
//      runtime.preemptall
//      runtime.schedtrace
//      runtime.runqputslow
//      runtime.(*profBuf).write
//      runtime.goargs
//      runtime.goenvs_unix
//      reflect.typelinks
//      runtime.extendRandom
//      runtime.sigInstallGoHandler
//      runtime.unblocksig
//      runtime.minitSignalMask
//      runtime.sigsend
//      runtime.signal_ignored
//      runtime.growslice
//      runtime.stackinit
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.stackcacherefill
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackalloc
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.freeStackSpans
//      runtime.concatstrings
//      runtime.stringtoslicerune
//      runtime.rawbyteslice
//      runtime.rawruneslice
//      runtime.gostring
//      runtime.index
//      runtime.atoi
//      runtime.findnull
//      runtime.(*pcExpander).next
//      runtime.modulesinit
//      runtime.moduledataverify1
//      runtime.findfunc
//      runtime.pcvalue
//      runtime.funcname
//      runtime.funcnameFromNameoff
//      runtime.funcfile
//      runtime.funcline1
//      runtime.step
//      runtime.readvarint
//      runtime.deltimer
//      runtime.timerproc
//      runtime.siftupTimer
//      runtime.siftdownTimer
//      runtime.traceEvent
//      runtime.(*traceBuf).varint
//      runtime.(*traceStackTable).put
//      runtime.(*traceStackTable).find
//      runtime.(*traceAlloc).alloc
//      runtime.traceGoStart
//      runtime.gentraceback
//      runtime.tracebackCgoContext
//      runtime.gcallers
//      runtime.cgoContextPCs
//      runtime.(*_type).textOff
//      runtime.typelinksinit
//      runtime.typesEqual
//      runtime.decoderune
//      runtime.encoderune
//      runtime.writeErr
//      runtime.writebarrierptr_prewrite1.func1
//      runtime.newdefer.func1
//      runtime.newdefer.func2
//      runtime.freedefer.func1
//      runtime.callers.func1
//      unicode/utf8.DecodeRuneInString
//      unicode/utf8.EncodeRune
//      unicode/utf8.RuneCount
//      unicode/utf8.RuneCountInString
//      strconv.(*decimal).String
//      strconv.digitZero
//      strconv.trim
//      strconv.(*decimal).Assign
//      strconv.rightShift
//      strconv.prefixIsLessThan
//      strconv.leftShift
//      strconv.(*decimal).Round
//      strconv.(*decimal).RoundUp
//      strconv.(*extFloat).frexp10
//      strconv.frexp10Many
//      strconv.(*extFloat).FixedDecimal
//      strconv.adjustLastDigitFixed
//      strconv.(*extFloat).ShortestDecimal
//      strconv.adjustLastDigit
//      strconv.roundShortest
//      strconv.fmtE
//      strconv.fmtF
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendEscapedRune
//      strconv.bsearch16
//      strconv.bsearch32
//      strconv.IsPrint
//      strconv.isInGraphicList
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
//      sync.(*Pool).pinSlow
//      sync.poolCleanup
//      syscall.uitoa
//      syscall.ByteSliceFromString
//      syscall.BytePtrFromString
//      reflect.newName
//      reflect.Kind.String
//      reflect.(*rtype).Name
//      reflect.(*rtype).In
//      reflect.(*rtype).Out
//      reflect.(*interfaceType).MethodByName
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.implements
//      reflect.haveIdenticalUnderlyingType
//      reflect.typesByString
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.addTypeBits
//      reflect.methodReceiver
//      reflect.Value.MapKeys
//      reflect.Value.Type
//      reflect.(*sliceType).MethodByName
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_float
//      fmt.(*pp).printValue
void runtime.panicindex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142638);
	runtime.gopanic(gs);
}

// 0806A8C0: void runtime.panicslice(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*cpuProfile).addNonGo
//      runtime.(*cpuProfile).addExtra
//      runtime.gogetenv
//      runtime.panicwrap
//      runtime.additab
//      runtime.progToPointerMask
//      runtime.SetFinalizer
//      runtime.(*mheap).mapSpans
//      runtime.stkbucket
//      runtime.mProf_Malloc
//      runtime.saveblockevent
//      runtime.getproccount
//      runtime.newdefer
//      runtime.recordForPanic
//      runtime.gwrite
//      runtime.printuint
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.forEachP
//      runtime.sigprof
//      runtime.(*profBuf).write
//      syscall.runtime_envs
//      os.runtime_args
//      runtime.parsedebugvars
//      runtime.adjustpointers
//      runtime.concatstrings
//      runtime.rawstringtmp
//      runtime.stringtoslicerune
//      runtime.slicerunetostring
//      runtime.intstring
//      runtime.(*stackExpander).next
//      runtime.(*pcExpander).next
//      runtime.pcvalue
//      runtime.step
//      runtime.deltimer
//      runtime.timerproc
//      runtime.traceStackID
//      runtime.(*traceStackTable).put
//      runtime.(*traceStackTable).find
//      runtime.(*_type).string
//      runtime.typesEqual
//      runtime.decoderune
//      runtime.freedefer.func1
//      strconv.(*decimal).String
//      strconv.leftShift
//      strconv.genericFtoa
//      strconv.fmtE
//      strconv.fmtF
//      strconv.FormatInt
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendEscapedRune
//      strconv.CanBackquote
//      internal/poll.(*FD).Write
//      os.Readlink
//      reflect.newName
//      reflect.(*rtype).String
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).Method
//      reflect.(*rtype).Name
//      reflect.(*rtype).In
//      reflect.(*rtype).NumOut
//      reflect.(*rtype).Out
//      reflect.(*structType).FieldByNameFunc
//      reflect.implements
//      reflect.funcStr
//      reflect.funcLayout
//      reflect.methodReceiver
//      reflect.Value.MapKeys
//      reflect.Value.Type
//      reflect.(*sliceType).MethodByName
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).truncate
//      fmt.(*fmt).fmt_c
//      fmt.(*fmt).fmt_float
//      fmt.(*buffer).WriteRune
//      fmt.(*pp).Write
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printValue
void runtime.panicslice(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142650);
	runtime.gopanic(gs);
}

// 0806A920: void runtime.panicdivide(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.makemap
//      runtime.makeBucketArray
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.runGCProg
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).grow
//      runtime.findObject
//      runtime.(*gcControllerState).enlistWorker
//      runtime.markrootSpans
//      runtime.(*mspan).sweep
//      runtime.findrunnable
//      runtime.globrunqget
//      runtime.(*profBuf).canWriteRecord
//      runtime.(*profBuf).canWriteTwoRecords
//      runtime.(*profBuf).write
//      runtime.sigpanic
//      runtime.uint64div
//      runtime.uint64mod
//      runtime.int64div
//      runtime.int64mod
//      runtime.dodiv
//      runtime.slowdodiv
//      strconv.(*extFloat).FixedDecimal
//      strconv.(*extFloat).ShortestDecimal
//      sync.(*Pool).getSlow
void runtime.panicdivide(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142628);
	runtime.gopanic(gs);
}

// 0806A980: void runtime.panicoverflow(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigpanic
void runtime.panicoverflow(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142648);
	runtime.gopanic(gs);
}

// 0806A9E0: void runtime.panicfloat(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigpanic
void runtime.panicfloat(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142630);
	runtime.gopanic(gs);
}

// 0806AA40: void runtime.panicmem(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigpanic
void runtime.panicmem(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142640);
	runtime.gopanic(gs);
}

// 0806AAA0: void runtime.throwinit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
//      strconv.init
//      sync.init
//      io.init
//      syscall.init
//      time.init
//      internal/poll.init
//      os.init
//      unicode.init
//      reflect.init
//      fmt.init
//      main.init
void runtime.throwinit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806AAE0: Register word32 runtime.deferproc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.cgocallbackg1
//      runtime.preprintpanics
//      runtime.main
//      sync.(*Once).Do
//      sync.(*Pool).pinSlow
//      internal/poll.(*FD).Write
//      reflect.FuncOf
//      fmt.(*pp).handleMethods
word32 runtime.deferproc(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	if (*((word32) *((word32) eax_8 + 24) + 84) != eax_8)
		runtime.throw(gs);
	else
	{
		runtime.getcallerpc();
		runtime.newdefer(gs, dwArg04);
		if (dwLoc18->dw0014 != 0x00)
			runtime.throw(gs);
		else
		{
			if (g_t81576F0 == 0x00)
				dwLoc18->t0010 = dwArg08;
			else
				runtime.writebarrierptr(&dwLoc18->t0010, dwArg08);
			dwLoc18->ptr000C = dwLoc18;
			dwLoc18->ptr0008 = fp + 0x04;
			if (dwArg04 != 0x00)
			{
				if (dwArg04 == 0x04)
				{
					union Eq_4 * eax_118;
					if (dwLoc18->dw0000 == 0x00)
						eax_118 = null;
					else
						eax_118 = (union Eq_4 *) (&dwLoc18->dw0014 + 2);
					*eax_118 = (union Eq_4 *) dwArg0C;
				}
				else
				{
					Eq_4 eax_88;
					if (dwLoc18->dw0000 == 0x00)
						eax_88.u0 = 0x00;
					else
						eax_88 = &dwLoc18->dw0014 + 2;
					runtime.memmove(eax_88, fp + 0x0C, dwArg04, out ebp, out esi, out edi);
				}
			}
			word32 eax_128 = runtime.return0();
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return eax_128;
		}
	}
}

// 0806AC10: void runtime.testdefersizes(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mallocinit
void runtime.testdefersizes(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8B(0x00, fp - 0x14);
	Eq_43484 eax_22 = 0x00;
	while (eax_22 < 0x05)
	{
		if (eax_22 >= 0x05)
			runtime.panicindex(gs);
		(fp - 0x14)[eax_22] = ~0x00;
		eax_22 = (word32) eax_22 + 1;
	}
	up32 eax_215 = 0x00;
	while (true)
	{
		uint32 ecx_35;
		if (eax_215 <= 0x04)
			ecx_35 = 0x00;
		else
			ecx_35 = eax_215 + 11 >> 0x04;
		if (ecx_35 >= 0x05)
			break;
		Eq_43509 edx_107;
		if (eax_215 <= 0x04)
			edx_107.u0 = 0x20;
		else
			edx_107 = eax_215 + 0x1C;
		if (edx_107 < 0x8000)
		{
			if (edx_107 <= 1016)
			{
				uint32 edx_86 = (word32) edx_107.u0 + 7;
				if (edx_86 >> 0x03 >= 0x81)
				{
l0806AE25:
					runtime.panicindex(gs);
				}
				uint32 edx_91 = (word32) (edx_86 >> 0x03)->b8138640;
				if (edx_91 >= 0x43)
					goto l0806AE25;
				edx_107 = (word32) g_a8138820[edx_91 * 0x02];
				goto l0806ACB8;
			}
			uint32 edx_68 = (word32) edx_107.u0 - 897;
			if (edx_68 >> 0x07 >= 0xF9)
			{
l0806AE1E:
				runtime.panicindex(gs);
			}
			uint32 edx_76 = (word32) (edx_68 >> 0x07)->b81396E0;
			if (edx_76 >= 0x43)
				goto l0806AE1E;
			edx_107 = (word32) g_a8138820[edx_76 * 0x02];
		}
		else if ((word32) edx_107.u0 + 0x00002000 >= edx_107)
			edx_107 = (word32) edx_107 + 0x00001FFF & ~0x1FFF;
l0806ACB8:
		Eq_43509 edi_103 = (fp - 0x14)[ecx_35];
		if (edi_103 < 0x00)
			(fp - 0x14)[ecx_35] = edx_107;
		else if (edi_103 != edx_107)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(0x00081386, gs, (uint64) (uint32) eax_215);
			runtime.printstring(gs);
			runtime.printint(0x00081386, gs, (uint64) (uint32) edx_107);
			runtime.printstring(gs);
			runtime.printint(0x00081386, gs, (uint64) (uint32) ecx_35);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		++eax_215;
	}
}

// 0806AE40: void runtime.init.2(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
void runtime.init.2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_24 = g_t80C7160;
	if (g_t81576F0 == 0x00)
		g_t8144FC4 = eax_24;
	else
		runtime.writebarrierptr(0x08144FC4, eax_24);
}

// 0806AEB0: void runtime.newdefer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.deferproc
void runtime.newdefer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	uint32 ecx_10;
	Eq_4 dwLoc24_200 = 0x00;
	if (dwArg04 <= 0x04)
		ecx_10 = 0x00;
	else
		ecx_10 = (word32) dwArg04 + 11 >> 0x04;
	Eq_4 edx_19 = gs->ptr0000->tFFFFFFFC;
	if (ecx_10 < 0x05)
	{
		Eq_4 ebp_26 = *((word32) *((word32) edx_19 + 24) + 92);
		ui32 ebx_33 = ecx_10 * 0x03;
		if (*((word32) ebp_26 + (ebx_33 * 0x04 + 64)) == 0x00 && g_a8145440[ecx_10 * 0x04] != 0x00)
		{
			word32 ebp_263;
			word32 edi_264;
			runtime.systemstack(gs, fp - 0x0C, out ebp_263, out edi_264);
		}
		Eq_4 ecx_62 = *((word32) ebp_26 + (ebx_33 * 0x04 + 60));
		Eq_4 esi_63 = *((word32) ebp_26 + (ebx_33 * 0x04 + 64));
		if (esi_63 > 0x00)
		{
			if (esi_63 - 0x01 >= esi_63)
				runtime.panicindex(gs);
			dwLoc24_200 = (ecx_62 - 0x04)[esi_63];
			Eq_4 ecx_78 = *((word32) ebp_26 + (ebx_33 * 0x04 + 60));
			if (esi_63 - 0x01 >= *((word32) ebp_26 + (ebx_33 * 0x04 + 64)))
				runtime.panicindex(gs);
			Eq_4 edx_86 = ecx_78 - 0x04 + esi_63 * 0x04;
			if (g_t81576F0 == 0x00)
				(ecx_78 - 0x04)[esi_63] = 0x00;
			else
				runtime.writebarrierptr(edx_86, 0x00);
			if (esi_63 - 0x01 > *((word32) ebp_26 + (ebx_33 * 0x04 + 0x0044)))
				runtime.panicslice(gs);
			*((word32) ebp_26 + (ebx_33 * 0x04 + 64)) = esi_63 - 0x01;
		}
	}
	if (dwLoc24_200 == 0x00)
	{
		word32 edi_266;
		word32 ebp_265;
		runtime.systemstack(gs, fp - 0x18, out ebp_265, out edi_266);
	}
	*dwLoc24_200 = dwArg04;
	Eq_4 ebp_159 = *((word32) edx_19 + 20);
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc24_200 + 24) = ebp_159;
	else
		runtime.writebarrierptr((word32) dwLoc24_200 + 24, ebp_159);
	if (g_t81576F0 == 0x00)
		*((word32) edx_19 + 20) = dwLoc24_200;
	else
		runtime.writebarrierptr((word32) edx_19 + 20, dwLoc24_200);
}

// 0806B090: void runtime.freedefer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.deferreturn
//      runtime.gopanic
void runtime.freedefer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	struct Eq_43806 * esp_107 = fp - 0x40;
	if (*((word32) dwArg04 + 20) != 0x00)
		runtime.freedeferpanic(gs);
	if (*((word32) dwArg04 + 16) != 0x00)
		runtime.freedeferfn(gs);
	uint32 eax_35;
	up32 ecx_31 = *dwArg04;
	if (ecx_31 <= 0x04)
		eax_35 = 0x00;
	else
		eax_35 = ecx_31 + 11 >> 0x04;
	if (eax_35 < 0x05)
	{
		Eq_4 edx_51 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		ui32 ecx_60 = eax_35 * 0x03;
		if (*((word32) edx_51 + (ecx_60 * 0x04 + 64)) == *((word32) edx_51 + (ecx_60 * 0x04 + 0x0044)))
		{
			word32 edi_248;
			word32 ebp_247;
			runtime.systemstack(gs, fp - 0x0C, out ebp_247, out edi_248);
		}
		if (g_t81576F0 == 0x00)
		{
			fn0808FD89(0x00, dwArg04);
			esp_107 = fp - 0x44;
		}
		else
			runtime.typedmemclr(0x080D9160, dwArg04);
		ui32 eax_110 = esp_107->dw0024;
		Eq_4 edx_111 = edx_51;
		Eq_4 ecx_113 = *((word32) edx_51 + (eax_110 * 0x04 + 0x0044));
		Eq_4 ebx_114 = *((word32) edx_51 + (eax_110 * 0x04 + 64));
		Eq_4 ebp_115 = *((word32) edx_51 + (eax_110 * 0x04 + 60));
		if ((word32) ebx_114 + 1 > ecx_113)
		{
			esp_107->ptr0000 = 135033152;
			esp_107->t0004 = ebp_115;
			esp_107->t0008 = ebx_114;
			esp_107->t000C = ecx_113;
			esp_107->dw0010 = (word32) ebx_114 + 1;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg12 = <invalid>;
			Eq_4 stackArg16 = <invalid>;
			Eq_4 stackArg20 = <invalid>;
			word32 esi_253;
			runtime.growslice(gs, stackArg4, dwArg04, stackArg12, stackArg16, stackArg20, out esi_253);
			Eq_4 eax_131 = esp_107->t0014;
			Eq_4 ecx_132 = esp_107->t0018;
			ui32 ebx_134 = esp_107->dw0024;
			Eq_4 ebp_135 = esp_107->t0030;
			*((word32) ebp_135 + (ebx_134 * 0x04 + 0x0044)) = esp_107->t001C;
			if (g_t81576F0 == 0x00)
				*((word32) ebp_135 + (ebx_134 * 0x04 + 60)) = eax_131;
			else
			{
				esp_107->t0028 = eax_131;
				esp_107->t0020 = ecx_132;
				esp_107->ptr0000 = esp_107->ptr002C;
				esp_107->t0004 = eax_131;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg4 = <invalid>;
				runtime.writebarrierptr(stackArg4, dwArg04);
				eax_131 = esp_107->t0028;
				ecx_132 = esp_107->t0020;
				ebx_134 = esp_107->dw0024;
				ebp_135 = esp_107->t0030;
			}
			edx_111 = ebp_135;
			ebp_115 = eax_131;
			eax_110 = ebx_134;
			ebx_114 = ecx_132;
		}
		*((word32) edx_111 + (eax_110 * 0x04 + 64)) = (word32) ebx_114 + 1;
		ptr32 ecx_170 = (word32) ebp_115 + ebx_114 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) ebp_115 + ebx_114 * 0x04) = esp_107->t0044;
		else
		{
			esp_107->ptr0000 = ecx_170;
			esp_107->t0004 = esp_107->t0044;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.writebarrierptr(stackArg4, dwArg04);
		}
	}
}

// 0806B250: void runtime.freedeferpanic(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.freedefer
void runtime.freedeferpanic(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806B290: void runtime.freedeferfn(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.freedefer
void runtime.freedeferfn(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806B2D0: Register Eq_4 runtime.deferreturn(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg1
//      runtime.preprintpanics
//      runtime.main
//      sync.(*Once).Do
//      sync.(*Pool).pinSlow
//      internal/poll.(*FD).Write
//      reflect.FuncOf
//      fmt.(*pp).handleMethods
Eq_4 runtime.deferreturn(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_9 = *((word32) eax_8 + 20);
	if (ecx_9 == 0x00)
		return esi;
	if (*((word32) ecx_9 + 8) != fp + 0x04)
		return fp + 0x04;
	Eq_4 ebx_26 = *ecx_9;
	if (ebx_26 != 0x00 && ebx_26 != 0x04)
	{
		word32 edi_189;
		word32 esi_188;
		word32 ebp_187;
		runtime.memmove(fp + 0x04, (word32) ecx_9 + 28, ebx_26, out ebp_187, out esi_188, out edi_189);
	}
	Eq_4 ebx_60 = *((word32) ecx_9 + 16);
	if (g_t81576F0 == 0x00)
		((word32) ecx_9 + 16)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) ecx_9 + 16, 0x00);
	Eq_4 esi_87 = g_t81576F0;
	Eq_4 edi_89 = *((word32) ecx_9 + 24);
	if (esi_87 == 0x00)
		*((word32) eax_8 + 20) = edi_89;
	else
		runtime.writebarrierptr((word32) eax_8 + 20, edi_89);
	runtime.freedefer(gs, ecx_9);
	runtime.jmpdefer(ebx_60, fp + 0x04);
	return esi_87;
}

// 0806B3F0: void runtime.preprintpanics(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gopanic
void runtime.preprintpanics(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg12 = <invalid>;
	word32 esi_258;
	word32 edi_259;
	word32 ebp_257;
	if (runtime.deferproc(gs, 0x00, 0x080E7CA4, stackArg12, out ebp_257, out esi_258, out edi_259) != 0x00)
		runtime.deferreturn(gs);
	else
	{
		Eq_4 eax_169 = dwArg04;
		while (eax_169 != 0x00)
		{
			Eq_4 ecx_48 = *((word32) eax_169 + 8);
			Eq_4 edx_49 = *((word32) eax_169 + 4);
			Eq_4 ebx_50 = (word32) eax_169 + 8;
			if (edx_49 != 0x00)
			{
				runtime.assertE2I2(gs, edx_49);
				if ((byte) (word32) bLoc20 != 0x00)
				{
					(*((word32) dwLoc28 + 20))();
					runtime.convT2Estring(gs, 135066016, fp - 0x08);
					*((word32) eax_169 + 4) = ecx_48;
					if (g_t81576F0 == 0x00)
						*((word32) eax_169 + 8) = dwLoc28;
					else
						runtime.writebarrierptr(ebx_50, dwLoc28);
				}
				else
				{
					runtime.assertE2I2(gs, edx_49);
					if ((byte) (word32) bLoc20 != 0x00)
					{
						(*((word32) dwLoc28 + 20))();
						runtime.convT2Estring(gs, 135066016, fp - 0x10);
						*((word32) eax_169 + 4) = ecx_48;
						if (g_t81576F0 == 0x00)
							*((word32) eax_169 + 8) = dwLoc28;
						else
							runtime.writebarrierptr(ebx_50, dwLoc28);
					}
				}
			}
			eax_169 = *((word32) eax_169 + 0x0C);
		}
		runtime.deferreturn(gs);
	}
}

// 0806B5A0: void runtime.printpanics(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.printpanics
//      runtime.gopanic
void runtime.printpanics(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 0x0C);
	if (ecx_18 != 0x00)
	{
		runtime.printpanics(gs, ecx_18);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.printany(gs, xmm0, xmm1, *((word32) dwArg04 + 4), *((word32) dwArg04 + 8));
	if ((byte) (word32) *((word32) dwArg04 + 16) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806B690: void runtime.gopanic(Register (ptr32 Eq_2) gs)
// Called from:
//      sync/atomic.(*Value).Store
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.makechan
//      runtime.chansend
//      runtime.closechan
//      runtime.panicwrap
//      runtime.mapassign
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.getitab
//      runtime.additab
//      runtime.panicdottypeE
//      runtime.assertE2I
//      runtime.newarray
//      runtime.panicindex
//      runtime.panicslice
//      runtime.panicdivide
//      runtime.panicoverflow
//      runtime.panicfloat
//      runtime.panicmem
//      runtime.badreflectcall
//      runtime.(*semaRoot).queue
//      runtime.sigpanic
//      runtime.makeslice
//      runtime.growslice
//      strconv.(*extFloat).FixedDecimal
//      strconv.adjustLastDigitFixed
//      strconv.genericFtoa
//      strconv.formatBits
//      sync.(*Mutex).Lock
//      sync.(*Mutex).Unlock
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).decref
//      internal/poll.(*fdMutex).rwlock
//      internal/poll.(*fdMutex).rwunlock
//      internal/poll.convertErr
//      reflect.makeMethodValue
//      reflect.newName
//      reflect.(*rtype).Method
//      reflect.(*rtype).ChanDir
//      reflect.(*rtype).Elem
//      reflect.(*rtype).In
//      reflect.(*rtype).Key
//      reflect.(*rtype).Len
//      reflect.(*rtype).NumIn
//      reflect.(*rtype).NumOut
//      reflect.(*rtype).Out
//      reflect.(*structType).Field
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.Value.pointer
//      reflect.packEface
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
//      reflect.Value.Bytes
//      reflect.Value.runes
//      reflect.methodReceiver
//      reflect.Value.Complex
//      reflect.Value.Elem
//      reflect.Value.Field
//      reflect.Value.Float
//      reflect.Value.Index
//      reflect.Value.Int
//      reflect.Value.CanInterface
//      reflect.valueInterface
//      reflect.Value.IsNil
//      reflect.Value.Len
//      reflect.Value.NumMethod
//      reflect.Value.Pointer
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.Slice
//      reflect.Value.Type
//      reflect.Value.Uint
//      reflect.Zero
//      reflect.New
//      reflect.Value.assignTo
//      reflect.(*sliceType).Bits
//      reflect.(*sliceType).IsVariadic
//      reflect.(*sliceType).Field
//      reflect.(*sliceType).FieldByIndex
//      reflect.(*sliceType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
//      reflect.(*sliceType).NumField
//      reflect.(*sliceType).Implements
//      reflect.(*sliceType).AssignableTo
//      reflect.(*sliceType).ConvertibleTo
//      fmt.(*fmt).fmt_integer
//      fmt.(*pp).catchPanic
void runtime.gopanic(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_19 = *((word32) ecx_18 + 24);
	if (*((word32) edx_19 + 84) != ecx_18)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printany(gs, xmm0, xmm1, dwArg04, dwArg08);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else if (*((word32) edx_19 + 0x007C) != 0x00)
	{
		--*((word32) edx_19 + 0x0078);
		((word32) *((word32) ecx_18 + 24) + 0x007C)->u0 = 0x00;
		runtime.throw(gs);
	}
	else if (*((word32) edx_19 + 0x0068) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printany(gs, xmm0, xmm1, dwArg04, dwArg08);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else if (*((word32) edx_19 + 116) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printany(gs, xmm0, xmm1, dwArg04, dwArg08);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else if (*((word32) edx_19 + 0x0078) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printany(gs, xmm0, xmm1, dwArg04, dwArg08);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		fn0808FD8B(0x00, fp - 0x14);
		Eq_4 edx_295 = *((word32) ecx_18 + 16);
		if (g_t81576F0 == 0x00)
			*((word32) ecx_18 + 16) = fp - 0x14;
		else
			runtime.writebarrierptr((word32) ecx_18 + 16, fp - 0x14);
		runtime/internal/atomic.Xadd(0x08157638, 0x01);
		while (true)
		{
			Eq_4 ecx_326 = *((word32) ecx_18 + 20);
			if (ecx_326 == 0x00)
				break;
			if ((byte) (word32) *((word32) ecx_326 + 4) == 0x00)
			{
				((word32) ecx_326 + 4)->u0 = 0x01;
				if (g_t81576F0 == 0x00)
					*((word32) ecx_326 + 20) = fp - 0x14;
				else
					runtime.writebarrierptr((word32) ecx_326 + 20, fp - 0x14);
				runtime.getargp();
				Eq_4 ecx_397 = *ecx_326;
				runtime.reflectcall(ecx_397);
				if (*((word32) ecx_18 + 20) != ecx_326)
					runtime.throw(gs);
				else
				{
					if (g_t81576F0 == 0x00)
					{
						((word32) ecx_326 + 20)->u0 = 0x00;
						((word32) ecx_326 + 16)->u0 = 0x00;
					}
					else
					{
						runtime.writebarrierptr((word32) ecx_326 + 20, 0x00);
						runtime.writebarrierptr((word32) ecx_326 + 16, 0x00);
					}
					Eq_4 ebx_467 = *((word32) ecx_326 + 24);
					if (g_t81576F0 == 0x00)
						*((word32) ecx_18 + 20) = ebx_467;
					else
						runtime.writebarrierptr((word32) ecx_18 + 20, ebx_467);
					Eq_4 ecx_485 = *((word32) ecx_326 + 0x0C);
					Eq_4 edx_488 = *((word32) ecx_326 + 8);
					runtime.freedefer(gs, ecx_326);
					if ((byte) (word32) bLoc04 == 0x00)
						continue;
					runtime/internal/atomic.Xadd(0x08157638, ~0x00);
					if (g_t81576F0 == 0x00)
						*((word32) ecx_18 + 16) = edx_295;
					else
						runtime.writebarrierptr((word32) ecx_18 + 16, edx_295);
					while (true)
					{
						Eq_4 ecx_528 = *((word32) ecx_18 + 16);
						bool Z_531 = SLICE(cond(ecx_528), bool, 2);
						if (ecx_528 == 0x00)
							break;
						if ((byte) (word32) *((word32) ecx_528 + 0x0011) == 0x00)
						{
							Z_531 = SLICE(cond(ecx_528), bool, 2);
							break;
						}
						Eq_4 ecx_579 = *((word32) ecx_528 + 0x0C);
						if (g_t81576F0 == 0x00)
							*((word32) ecx_18 + 16) = ecx_579;
						else
							runtime.writebarrierptr((word32) ecx_18 + 16, ecx_579);
					}
					if (!Z_531)
						((word32) ecx_18 + 0x008C)->u0 = 0x00;
					*((word32) ecx_18 + 0x009C) = edx_488;
					*((word32) ecx_18 + 0x00A0) = ecx_485;
					word32 esi_911;
					runtime.mcall(gs, dwLoc54, &g_dw80E7CAC, out esi_911);
					Eq_4 esp_563 = <invalid>;
					*esp_563 = 0x080E23B0;
					((word32) esp_563 + 4)->u0 = 0x0F;
					runtime.throw(gs);
				}
			}
			Eq_4 ebx_592 = *((word32) ecx_326 + 20);
			if (ebx_592 != 0x00)
				*((word32) ebx_592 + 0x0011) = 0x01;
			if (g_t81576F0 == 0x00)
			{
				((word32) ecx_326 + 20)->u0 = 0x00;
				((word32) ecx_326 + 16)->u0 = 0x00;
			}
			else
			{
				runtime.writebarrierptr((word32) ecx_326 + 20, 0x00);
				runtime.writebarrierptr((word32) ecx_326 + 16, 0x00);
			}
			Eq_4 ebp_630 = *((word32) ecx_326 + 24);
			if (g_t81576F0 == 0x00)
				*((word32) ecx_18 + 20) = ebp_630;
			else
				runtime.writebarrierptr((word32) ecx_18 + 20, ebp_630);
			runtime.freedefer(gs, ecx_326);
		}
		runtime.preprintpanics(gs, *((word32) ecx_18 + 16));
		runtime.startpanic();
		runtime/internal/atomic.Xadd(0x08157638, ~0x00);
		runtime.printpanics(gs, *((word32) ecx_18 + 16));
		runtime.dopanic(gs);
		null = (union Eq_4 *) 0x00;
	}
}

// 0806BCE0: void runtime.getargp()
// Called from:
//      runtime.gopanic
void runtime.getargp()
{
}

// 0806BCF0: void runtime.gorecover(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.preprintpanics.func1
//      fmt.(*pp).catchPanic
void runtime.gorecover(struct Eq_2 * gs, ptr32 dwArg04)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 16);
	if (eax_8 == 0x00 || ((byte) ((word32) (*((word32) eax_8 + 16))) != 0x00 || dwArg04 != *eax_8))
		return;
	((word32) eax_8 + 16)->u0 = 0x01;
}

// 0806BD40: void runtime.startpanic()
// Called from:
//      runtime.gopanic
//      runtime.throw
//      runtime.sighandler
void runtime.startpanic()
{
	word32 ebp_18;
	word32 edi_19;
	runtime.systemstack(gs, 0x080E7CD8, out ebp_18, out edi_19);
}

// 0806BD60: void runtime.dopanic(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gopanic
//      runtime.throw
//      runtime.startpanic_m
void runtime.dopanic(struct Eq_2 * gs)
{
	runtime.getcallerpc();
	word32 ebp_44;
	word32 edi_45;
	runtime.systemstack(gs, fp - 0x10, out ebp_44, out edi_45);
	null = (union Eq_4 *) 0x00;
}

// 0806BDC0: void runtime.throw(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocall
//      runtime.cgoCheckUsingType
//      runtime.makechan
//      runtime.chansend
//      runtime.chanrecv
//      runtime.gogetenv
//      runtime.panicwrap
//      runtime.makemap
//      runtime.mapaccess2
//      runtime.mapassign
//      runtime.mapiternext
//      runtime.hashGrow
//      runtime.evacuate
//      runtime.mapaccess1_fast32
//      runtime.mapaccess2_fast32
//      runtime.mapaccess2_fast64
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.getitab
//      runtime.additab
//      runtime.(*lfstack).push
//      runtime.lock
//      runtime.unlock
//      runtime.notewakeup
//      runtime.notesleep
//      runtime.notetsleep
//      runtime.notetsleepg
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.(*mcache).nextFree
//      runtime.mallocgc
//      runtime.largeAlloc
//      runtime.persistentalloc1
//      runtime.(*mspan).nextFreeIndex
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.bulkBarrierPreWrite
//      runtime.typeBitsBulkBarrier
//      runtime.heapBits.initSpan
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.progToPointerMask
//      runtime.(*mcache).refill
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.sysUnused
//      runtime.sysMap
//      runtime.queuefinalizer
//      runtime.runfinq
//      runtime.SetFinalizer
//      runtime.(*fixalloc).alloc
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.gcMark
//      runtime.gcSweep
//      runtime.gchelperstart
//      runtime.(*mTreap).insert
//      runtime.(*mTreap).removeNode
//      runtime.(*mTreap).remove
//      runtime.(*mTreap).rotateLeft
//      runtime.(*mTreap).rotateRight
//      runtime.gcMarkRootCheck
//      runtime.markroot
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.scanobject
//      runtime.greyobject
//      runtime.gcmarknewobject
//      runtime.sweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*mspan).sweep
//      runtime.(*gcSweepBuf).block
//      runtime.(*workbuf).checknonempty
//      runtime.(*workbuf).checkempty
//      runtime.getempty
//      runtime.getfull
//      runtime.prepareFreeWorkbufs
//      runtime.recordspan
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.addspecial
//      runtime.removespecial
//      runtime.setprofilebucket
//      runtime.freespecial
//      runtime.newMarkBits
//      runtime.newArenaMayUnlock
//      runtime.newBucket
//      runtime.(*bucket).mp
//      runtime.(*bucket).bp
//      runtime.stkbucket
//      runtime.init.1
//      internal/poll.runtime_pollOpen
//      internal/poll.runtime_pollClose
//      internal/poll.runtime_pollUnblock
//      runtime.netpollblock
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.getsig
//      runtime.panicCheckMalloc
//      runtime.throwinit
//      runtime.deferproc
//      runtime.testdefersizes
//      runtime.freedeferpanic
//      runtime.freedeferfn
//      runtime.gopanic
//      runtime.recovery
//      runtime.main
//      runtime.forcegchelper
//      runtime.gopark
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.badmcall
//      runtime.badmcall2
//      runtime.badctxt
//      runtime.allgadd
//      runtime.schedinit
//      runtime.checkmcount
//      runtime.ready
//      runtime.helpgc
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.scang
//      runtime.restartg
//      runtime.stopTheWorldWithSema
//      runtime.startTheWorldWithSema
//      runtime.mstart1
//      runtime.forEachP
//      runtime.newm
//      runtime.stopm
//      runtime.startm
//      runtime.stoplockedm
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.resetspinning
//      runtime.schedule
//      runtime.goschedImpl
//      runtime.goexit0
//      runtime.exitsyscall
//      runtime.newproc1
//      runtime.gfput
//      runtime.badunlockosthread
//      runtime.procresize
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.pidleput
//      runtime.runqputslow
//      runtime.runqsteal
//      runtime.(*profBuf).write
//      runtime.testAtomic64
//      runtime.check
//      runtime.(*rwmutex).runlock
//      runtime.semacquire1
//      runtime.semrelease1
//      runtime.(*semaRoot).rotateLeft
//      runtime.(*semaRoot).rotateRight
//      sync.runtime_notifyListCheck
//      runtime.sigpanic
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.sigsend
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.stackalloc
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.copystack
//      runtime.newstack
//      runtime.shrinkstack
//      runtime.concatstrings
//      runtime.rawruneslice
//      runtime.badsystemstack
//      runtime.moduledataverify1
//      runtime.findfunc
//      runtime.pcvalue
//      runtime.stackmapdata
//      runtime.traceEvent
//      runtime.traceFlush
//      runtime.(*traceAlloc).alloc
//      runtime.traceGCSweepStart
//      runtime.traceGCSweepDone
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.cgoCheckTypedBlock.func2
//      runtime.cgoCheckBits.func1
//      runtime.writebarrierptr_prewrite1.func1
//      runtime.writebarrierptr.func1
//      runtime.writebarrierptr_prewrite.func1
//      runtime.SetFinalizer.func2
//      runtime.gcBgMarkWorker.func2
//      runtime.preprintpanics.func1
//      runtime.casgstatus.func1
//      runtime.casgstatus.func2
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      runtime.exitsyscall.func1
//      runtime.morestackc.func1
void runtime.throw(struct Eq_2 * gs)
{
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 eax_34 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	if (*((word32) eax_34 + 0x006C) == 0x00)
		((word32) eax_34 + 0x006C)->u0 = 0x01;
	runtime.startpanic();
	runtime.dopanic(gs);
	null = (union Eq_4 *) 0x00;
}

// 0806BE50: void runtime.recovery(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_44833) dwArg04)
void runtime.recovery(Eq_4 esi, struct Eq_2 * gs, struct Eq_44833 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t009C;
	word32 edx_19 = dwArg04->dw00A0;
	if (ecx_18 != 0x00)
	{
		Eq_4 ebx_24 = dwArg04->t0000;
		if (ecx_18 < ebx_24 || dwArg04->t0004 < ecx_18)
		{
			Eq_4 eax_33 = dwArg04->t0004;
			runtime.printlock(gs);
			runtime.printstring(gs);
			Eq_4 esi_65;
			runtime.printhex(esi, gs, ecx_18, 0x00, out esi_65);
			runtime.printstring(gs);
			Eq_4 esi_89;
			runtime.printhex(esi_65, gs, ebx_24, 0x00, out esi_89);
			runtime.printstring(gs);
			word32 esi_202;
			runtime.printhex(esi_89, gs, eax_33, 0x00, out esi_202);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
	}
	dwArg04->t001C = ecx_18;
	dwArg04->dw0020 = edx_19;
	dwArg04->dw0030 = 0x00;
	dwArg04->dw002C = 0x01;
	runtime.gogo(gs, &dwArg04->t001C);
}

// 0806BF80: void runtime.startpanic_m(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.startpanic_m(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (g_dw814B564 != 0x00)
	{
		if (*((word32) *((word32) eax_18 + 24) + 0x00B8) == 0x00)
		{
			esi = runtime.allocmcache(esi, gs);
			*((word32) *((word32) eax_18 + 24) + 0x00B8) = dwLoc10;
		}
	}
	else
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		((word32) *((word32) eax_18 + 24) + 0x0068)->u0 = 0x01;
	}
	Eq_4 ecx_76 = *((word32) eax_18 + 24);
	struct Eq_44977 * edx_77 = *((word32) ecx_76 + 0x0080);
	if (edx_77 == null)
	{
		*((word32) ecx_76 + 0x0080) = (struct Eq_44977 *) 0x01;
		((word32) eax_18 + 0x0094)->u0 = 0x00;
		((word32) eax_18 + 0x0098)->u0 = 0x00;
		if (g_t81576F0 == 0x00)
			*((word32) eax_18 + 144) = 0x00;
		else
			runtime.writebarrierptr((word32) eax_18 + 144, 0x00);
		runtime/internal/atomic.Xadd(0x08157618, 0x01);
		Eq_4 esi_204;
		word32 edi_327;
		word32 ebp_326;
		runtime.lock(esi, gs, 135624220, out ebp_326, out esi_204, out edi_327);
		if (g_t8157754 > 0x00 || g_dw8157750 > 0x00)
			runtime.schedtrace(esi_204, gs, (struct Eq_45018 *) 0x76000001, bLoc08);
		runtime.freezetheworld(gs);
		return;
	}
	if (edx_77 != (struct Eq_44977 *) 0x01)
	{
		if (edx_77 != (struct Eq_44977 *) 0x02)
			goto l0806C0B3;
	}
	else
	{
		*((word32) ecx_76 + 0x0080) = (struct Eq_44977 *) 0x02;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.dopanic(gs);
		runtime.exit();
	}
	*((word32) *((word32) eax_18 + 24) + 0x0080) = (struct Eq_44977 *) 0x03;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.exit();
l0806C0B3:
	runtime.exit();
}

// 0806C170: void runtime.dopanic_m(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.dopanic.func1
void runtime.dopanic_m(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 0x008C);
	if (ecx_18 != 0x00)
	{
		word32 ebx_26;
		if (ecx_18 >= 0x41)
			ebx_26 = 0x00;
		else
		{
			esi.u0 = 0x08144820;
			ebx_26 = (word32) g_a8144828[ecx_18];
		}
		if (ebx_26 != 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printhex(esi, gs, ecx_18, 0x00, out esi);
			runtime.printunlock(gs);
		}
		Eq_4 ecx_120 = *((word32) dwArg04 + 0x009C);
		Eq_4 edx_122 = *((word32) dwArg04 + 0x00A0);
		Eq_4 ebx_124 = *((word32) dwArg04 + 0x00A4);
		runtime.printlock(gs);
		runtime.printstring(gs);
		Eq_4 esi_153;
		runtime.printhex(esi, gs, ecx_120, 0x00, out esi_153);
		runtime.printstring(gs);
		Eq_4 esi_177;
		runtime.printhex(esi_153, gs, edx_122, 0x00, out esi_177);
		runtime.printstring(gs);
		runtime.printhex(esi_177, gs, ebx_124, 0x00, out esi);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		dwLoc30.u1 = 0x080E0E0F;
		bLoc2C = 0x02;
		bLoc2B = 0x00;
	}
	runtime.gotraceback(dwLoc34);
	byte cl_243 = (byte) (word32) bLoc2C;
	byte dl_237 = (byte) (word32) bLoc2B;
	Eq_4 ebx_240 = gs->ptr0000->tFFFFFFFC;
	if (dwLoc30 > 0x00)
	{
		Eq_4 esi_246 = *((word32) dwArg04 + 24);
		Eq_4 edi_247 = *((word32) esi_246 + 84);
		esi = *esi_246;
		if (esi == dwArg04)
		{
			if (dwLoc30 >= 0x02 || *((word32) (*((word32) ebx_240 + 24)) + 0x006C) > 0x00)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.traceback(gs);
				dwLoc28 = 0x00;
			}
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			esi = runtime.goroutineheader(gs, dwArg04);
			runtime.traceback(gs);
			dwLoc28 = 0x00;
		}
		if ((byte) (word32) g_b8157568 == 0x00 && (byte) (SEQ(SLICE(edi_247, word24, 8), edi_247 != dwArg04) | (word32) cl_243) != 0x00)
		{
			g_b8157568 = 0x01;
			esi = runtime.tracebackothers(esi, gs, dwArg04);
		}
	}
	word32 edx_390;
	word32 ebx_594;
	runtime.unlock(gs, 135624220, out edx_390, out ebx_594);
	runtime/internal/atomic.Xadd(0x08157618, ~0x00);
	if (dwLoc28 != 0x00)
	{
		Eq_4 esi_420;
		word32 ebp_595;
		word32 edi_596;
		runtime.lock(esi, gs, 0x081575B0, out ebp_595, out esi_420, out edi_596);
		word32 ebp_431;
		word32 edi_432;
		word32 esi_433;
		runtime.lock(esi_420, gs, 0x081575B0, out ebp_431, out esi_433, out edi_432);
	}
	if ((byte) (word32) dl_237 != 0x00)
		runtime.crash(gs);
	runtime.exit();
}

// 0806C4B0: void runtime.canpanic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigpanic
void runtime.canpanic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	Eq_4 eax_9 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	if (dwArg04 == 0x00 || dwArg04 != *((word32) eax_9 + 84))
		return;
	if (*((word32) eax_9 + 0x0078) - *((word32) eax_9 + 0x007C) != 0x00 || (*((word32) eax_9 + 0x0068) != 0x00 || (*((word32) eax_9 + 0x006C) != 0x00 || (*((word32) eax_9 + 116) != 0x00 || *((word32) eax_9 + 0x0080) != null))))
		return;
	runtime.readgstatus(dwArg04);
	if ((dwLoc04 & ~0x1000) == 0x02 && *((word32) dwArg04 + 56) == 0x00)
		;
}

// 0806C550: void runtime.recordForPanic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_45353 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.gwrite
void runtime.recordForPanic(struct Eq_2 * gs, Eq_4 dwArg08, Eq_45353 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime/internal/atomic.Load();
	if (dwLoc0C == 0x00)
	{
		Eq_45353 eax_116;
		for (eax_116 = 0x00; eax_116 < dwArg0C; eax_116 += ecx_66)
		{
			uint32 edx_48 = g_dw8157624;
			if (edx_48 > 0x0200)
			{
l0806C633:
				runtime.panicslice(gs);
			}
			Eq_4 ebx_52 = 0x0200 - edx_48;
			ui32 ebx_56 = -ebx_52 >> 0x1F & edx_48;
			if (eax_116 > dwArg0C)
				goto l0806C633;
			Eq_4 ecx_66 = dwArg0C - eax_116;
			Eq_4 esi_79 = (word32) dwArg08 + (eax_116 - dwArg10 >> 0x1F & eax_116);
			if (ebx_52 <= ecx_66)
				ecx_66 = ebx_52;
			word32 edi_181;
			word32 esi_180;
			word32 ebp_179;
			runtime.memmove(ebx_56 + 0x08157B80, esi_79, ecx_66, out ebp_179, out esi_180, out edi_181);
			Eq_45414 eax_106 = (word32) ecx_66 + g_dw8157624;
			Mem114[0x08157624<p32>:word32] = eax_106 - ((((eax_106 >> 0x1F) >>u 0x17) + eax_106 >> 0x09) << 0x09);
		}
	}
	runtime.printunlock(gs);
}

// 0806C650: void runtime.printlock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg
//      runtime.printany
//      runtime.makemap
//      runtime.(*lfstack).push
//      runtime.notewakeup
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.(*mcache).nextFree
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.sysAlloc
//      runtime.sysMap
//      runtime.(*fixalloc).alloc
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.getfull
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      runtime.init.1
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.testdefersizes
//      runtime.printpanics
//      runtime.gopanic
//      runtime.throw
//      runtime.recovery
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.recordForPanic
//      runtime.printsp
//      runtime.printnl
//      runtime.printbool
//      runtime.printfloat
//      runtime.printcomplex
//      runtime.printint
//      runtime.printslice
//      runtime.printeface
//      runtime.forcegchelper
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.stoplockedm
//      runtime.goexit0
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.schedtrace
//      sync.runtime_notifyListCheck
//      runtime.dumpregs
//      runtime.sighandler
//      runtime.sigpanic
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.newstack
//      runtime.moduledataverify1
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.traceback1
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.writebarrierptr.func1
//      runtime.futexwakeup.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      internal/poll.convertErr
void runtime.printlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_19 + 0x0078) = (word32) *((word32) eax_19 + 0x0078) + 1;
	word32 ecx_23 = (word32) *((word32) eax_19 + 144);
	*((word32) eax_19 + 144) = (byte) (ecx_23 + 0x01);
	if ((byte) ecx_23 == 0x00)
	{
		word32 ebp_58;
		word32 esi_59;
		word32 edi_60;
		runtime.lock(esi, gs, 135624116, out ebp_58, out esi_59, out edi_60);
	}
	--*((word32) eax_19 + 0x0078);
}

// 0806C6C0: Register word32 runtime.printunlock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg
//      runtime.printany
//      runtime.makemap
//      runtime.(*lfstack).push
//      runtime.notewakeup
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.(*mcache).nextFree
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.sysAlloc
//      runtime.sysMap
//      runtime.(*fixalloc).alloc
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.getfull
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      runtime.init.1
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.testdefersizes
//      runtime.printpanics
//      runtime.gopanic
//      runtime.throw
//      runtime.recovery
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.recordForPanic
//      runtime.printsp
//      runtime.printnl
//      runtime.printbool
//      runtime.printfloat
//      runtime.printcomplex
//      runtime.printint
//      runtime.printslice
//      runtime.printeface
//      runtime.forcegchelper
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.stoplockedm
//      runtime.goexit0
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.schedtrace
//      sync.runtime_notifyListCheck
//      runtime.dumpregs
//      runtime.sighandler
//      runtime.sigpanic
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.newstack
//      runtime.moduledataverify1
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.traceback1
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.writebarrierptr.func1
//      runtime.futexwakeup.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      internal/poll.convertErr
word32 runtime.printunlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	word32 ecx_20 = (word32) *((word32) eax_19 + 144);
	*((word32) eax_19 + 144) = (byte) (ecx_20 - 0x01);
	if ((byte) ecx_20 == 0x01)
	{
		word32 edx_31;
		word32 ebx_47;
		ecx_20 = runtime.unlock(gs, 135624116, out edx_31, out ebx_47);
	}
	return ecx_20;
}

// 0806C720: void runtime.gwrite(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.printfloat
//      runtime.printuint
//      runtime.printhex
//      runtime.printstring
void runtime.gwrite(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg16 = <invalid>;
	runtime.recordForPanic(gs, dwArg08, dwArg0C, stackArg16);
	Eq_4 eax_33 = gs->ptr0000->tFFFFFFFC;
	if (eax_33 != 0x00)
	{
		Eq_4 ecx_37 = *((word32) eax_33 + 0x0098);
		Eq_4 edx_38 = *((word32) eax_33 + 0x0094);
		Eq_45006 ebx_39 = *((word32) eax_33 + 144);
		if (ebx_39 != 0x00)
		{
			if (edx_38 > ecx_37)
				runtime.panicslice(gs);
			else
			{
				Eq_4 ecx_65 = ecx_37 - edx_38;
				Eq_4 ecx_70 = (word32) ebx_39.u1 + (edx_38 & -ecx_65 >> 0x1F);
				Eq_4 edx_71 = dwArg08;
				if (ecx_65 <= dwArg08)
					edx_71 = ecx_65;
				word32 edi_179;
				word32 ebp_177;
				word32 esi_178;
				runtime.memmove(ecx_70, dwArg04, edx_71, out ebp_177, out esi_178, out edi_179);
				word32 ecx_98 = Mem82[eax_33 + 0x94:word32] + edx_71;
				if (ecx_98 > *((word32) eax_33 + 0x0098))
					runtime.panicslice(gs);
				else
				{
					*((word32) eax_33 + 0x0094) = ecx_98;
					return;
				}
			}
		}
	}
	runtime.writeErr(gs, dwArg08);
}

// 0806C830: void runtime.printsp(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.makemap
//      runtime.mallocinit
//      runtime.(*mcache).nextFree
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.gcAssistAlloc1
//      runtime.getfull
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.init.1
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.stackfree
//      runtime.moduledataverify1
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      internal/poll.convertErr
void runtime.printsp(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806C870: void runtime.printnl(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg
//      runtime.makemap
//      runtime.mallocinit
//      runtime.(*mcache).nextFree
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.gcAssistAlloc1
//      runtime.getfull
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.init.1
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.forcegchelper
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.stackfree
//      runtime.moduledataverify1
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      internal/poll.convertErr
void runtime.printnl(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806C8B0: void runtime.printbool(Register (ptr32 Eq_2) gs, Stack Eq_4 bArg04)
// Called from:
//      runtime.printany
//      runtime.gcMarkRootCheck
//      runtime.gcAssistAlloc1
//      runtime.schedtrace
void runtime.printbool(struct Eq_2 * gs, Eq_4 bArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) bArg04 != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	else
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 0806C920: Register Eq_45683 runtime.printfloat(Register (ptr32 Eq_2) gs, Register Eq_661 xmm2, Stack Eq_5366 rArg04, Register out Eq_661 xmm2Out)
// Called from:
//      runtime.printany
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.sweepone
//      runtime.printcomplex
Eq_45683 runtime.printfloat(struct Eq_2 * gs, Eq_661 xmm2, Eq_5366 rArg04, union Eq_661 & xmm2Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_45683 xmm0_17 = (uint128) (uint64) rArg04;
	if ((real64) xmm0_17 != xmm0_17 || PARITY_EVEN((real64) xmm0_17 - xmm0_17))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		xmm2Out = xmm2;
		return xmm0_17;
	}
	else
	{
		Eq_661 xmm2_187;
		Eq_45714 xmm1_139 = SEQ(SLICE(xmm1, word64, 64), (real64) xmm0_17);
		Eq_45683 xmm0_47 = SEQ(SLICE(xmm0_17, word64, 64), (real64) xmm0_17 + (real64) xmm0_17);
		byte CZP_48 = cond((real64) xmm0_17 - xmm0_47);
		bool Z_51 = SLICE(CZP_48, bool, 2);
		bool P_52 = SLICE(CZP_48, bool, 5);
		if ((real64) xmm0_17 == xmm0_47 && !PARITY_EVEN((real64) xmm0_17 - xmm0_47))
		{
			xmm2_187 = __xorps(xmm2, xmm2);
			if ((real64) xmm0_17 > xmm2_187)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				xmm2Out = xmm2_187;
				return xmm0_47;
			}
			byte CZP_83 = cond((real64) xmm0_17 - xmm0_47);
			Z_51 = SLICE(CZP_83, bool, 2);
			P_52 = SLICE(CZP_83, bool, 5);
		}
		else
			xmm2_187 = __xorps(xmm2, xmm2);
		if (Z_51 || (P_52 || (real64) xmm2_187 <= xmm1_139))
		{
			Eq_45683 xmm0_144;
			int32 eax_202;
			if ((real64) xmm2_187 == xmm1_139 && !PARITY_EVEN((real64) xmm2_187 - xmm1_139))
			{
				uint128 xmm0_203 = (uint128) (uint64) g_r80F1858;
				xmm0_144 = SEQ(SLICE(xmm0_203, word64, 64), (real64) xmm0_203 / (real64) xmm0_17);
				eax_202 = 0x00;
			}
			else
			{
				if ((real64) xmm2_187 > xmm1_139)
					xmm1_139 = __pxor(xmm1_139, (uint128) (uint64) g_r80F1890);
				int32 eax_140 = 0x00;
				while (true)
				{
					xmm0_144.u0 = (uint128) (uint64) g_r80F1870;
					if ((real64) xmm1_139 < xmm0_144)
						break;
					++eax_140;
					xmm1_139 = SEQ(SLICE(xmm1_139, word64, 64), (real64) xmm1_139 / (real64) xmm0_144);
				}
				while ((real64) (uint128) (uint64) g_r80F1858 > xmm1_139)
				{
					--eax_140;
					xmm1_139 = SEQ(SLICE(xmm1_139, word64, 64), (real64) xmm1_139 * (real64) xmm0_144);
				}
				int32 ecx_170;
				uint128 xmm2_173 = (uint128) (uint64) g_r80F1868;
				for (ecx_170 = 0x00; ecx_170 < 0x07; ++ecx_170)
					xmm2_173 = SEQ(SLICE(xmm2_173, word64, 64), (real64) xmm2_173 / (real64) xmm0_144);
				int32 ecx_193;
				Eq_45683 v39_185 = (real64) xmm2_173 + (real64) xmm1_139;
				word64 v40_186 = SLICE(xmm2_173, word64, 64);
				xmm2_187 = SEQ(v40_186, v39_185);
				if (v39_185 >= xmm0_144)
				{
					ecx_193 = eax_140 + 0x01;
					xmm2_187 = SEQ(v40_186, v39_185 / (real64) xmm0_144);
				}
				else
					ecx_193 = eax_140;
				xmm1_139 = SEQ(SLICE(xmm1_139, word64, 64), (real64) xmm2_187);
				eax_202 = ecx_193;
			}
			byte * ecx_215;
			for (ecx_215 = null; ecx_215 < (byte *) 0x07; ++ecx_215)
			{
				if (ecx_215 >= (byte *) ~0x0B)
					runtime.panicindex(gs);
				int32 edx_294 = (int32) xmm1_139;
				Mem298[ecx_215 + 0x02 + (fp - 0x0E):byte] = SLICE(edx_294 + 0x30, byte, 0);
				xmm0_144.u0 = (uint128) (uint64) g_r80F1870;
				xmm1_139 = SEQ(SLICE(xmm1_139, word64, 64), ((real64) xmm1_139 - (real64) edx_294) * (real64) xmm0_144);
			}
			runtime.gwrite(gs, fp - (byte *) 0x0E, 0x0E);
			xmm2Out = xmm2_187;
			return xmm0_144;
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			xmm2Out = xmm2_187;
			return xmm0_47;
		}
	}
}

// 0806CBB0: void runtime.printcomplex(Register (ptr32 Eq_2) gs, Stack real64 rArg04, Stack real64 rArg0C)
// Called from:
//      runtime.printany
void runtime.printcomplex(struct Eq_2 * gs, real64 rArg04, real64 rArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	word128 xmm2_64;
	runtime.printfloat(gs, xmm2, (real64) (uint128) (uint64) rArg04, out xmm2_64);
	word128 xmm2_65;
	runtime.printfloat(gs, xmm2, (real64) (uint128) (uint64) rArg0C, out xmm2_65);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806CC30: Register Eq_4 runtime.printuint(Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 fArg04, Stack Eq_4 fArg08)
// Called from:
//      runtime.printany
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.sweepone
//      runtime.(*mheap).grow
//      runtime.(*mheap).scavenge
//      runtime.printint
Eq_4 runtime.printuint(Eq_4 ebp, struct Eq_2 * gs, Eq_4 fArg04, Eq_4 fArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD77(0x00, fp - 100);
	Eq_45957 eax_105;
	Eq_4 ecx_108 = dwArg04;
	Eq_4 edx_107 = dwArg08;
	for (eax_105 = 99; eax_105 > 0x00; --eax_105)
	{
		ui24 edx_24_8_72 = SLICE(runtime.uint64mod(gs, ecx_108, edx_107, 0x0A, 0x00), word24, 8);
		byte al_53 = (byte) ((word32) dwLoc70 + 48);
		if (eax_105 >= 100)
			runtime.panicindex(gs);
		Mem54[fp - 100 + eax_105:byte] = al_53;
		ui24 ebx_24_8_68 = SLICE(ebp, word24, 8);
		Eq_4 ebp_85 = SEQ(ebx_24_8_68, Test(ULT,false)) | SEQ(edx_24_8_72, edx_107 == 0x00) & SEQ(ebx_24_8_68, ecx_108 < 0x0A);
		ebp = ebp_85;
		if ((byte) ebp_85 != 0x00)
			break;
		runtime.uint64div(gs, ecx_108, edx_107, 0x0A, 0x00);
		edx_107 = dwLoc6C;
		ecx_108 = dwLoc70;
	}
	if (eax_105 > 100)
		runtime.panicslice(gs);
	else
	{
		Eq_4 eax_119 = 100 - eax_105;
		runtime.gwrite(gs, fp - 100 + (eax_105 & -eax_119 >> 0x1F), eax_119);
		return <invalid>;
	}
}

// 0806CD60: void runtime.printint(Register Eq_363 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 qwArg04)
// Called from:
//      runtime.printany
//      runtime.makemap
//      runtime.notewakeup
//      runtime.mallocinit
//      runtime.(*mcache).nextFree
//      runtime.heapBitsForObject
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetTypeGCProg
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.getfull
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.init.1
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.testdefersizes
//      runtime.printslice
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.goexit0
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.schedtrace
//      sync.runtime_notifyListCheck
//      runtime.sighandler
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.adjustframe
//      runtime.newstack
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.gentraceback
//      runtime.printcreatedby
//      runtime.goroutineheader
//      runtime.printOneCgoTraceback
//      runtime.typesEqual
//      runtime.futexwakeup.func1
//      internal/poll.convertErr
void runtime.printint(Eq_363 ebx, struct Eq_2 * gs, Eq_4 qwArg04)
{
	Eq_4 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_4 dwArg04 = (word32) qwArg04;
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_24 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 eax_17 = dwArg08;
	Eq_4 edx_21 = dwArg04;
	if ((byte) (SEQ(ebx_24_8, dwArg08 < 0x00) | SEQ(ecx_24_8_24, dwArg08 == 0x00) & SEQ(ebx_24_8, Test(ULT,false))) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		eax_17 = SLICE(0x00 - qwArg04, word32, 32);
		edx_21 = 0x00 - dwArg04;
	}
	runtime.printuint(ebp, gs, edx_21, eax_17);
}

// 0806CDF0: Register Eq_4 runtime.printhex(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_4 esiOut)
// Called from:
//      runtime.(*lfstack).push
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.(*mheap).freeSpanLocked
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.recovery
//      runtime.dopanic_m
//      runtime.printpointer
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.dumpregs
//      runtime.sighandler
//      runtime.sigpanic
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.newstack
//      runtime.moduledataverify1
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.writebarrierptr.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
Eq_4 runtime.printhex(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD77(0x00, fp - 100);
	Eq_4 ecx_22 = dwArg08;
	Eq_4 edx_23 = dwArg04;
	byte * eax_24;
	for (eax_24 = (byte *) 99; eax_24 > null; --eax_24)
	{
		word32 edx_33 = (word32) (edx_23 & 0x0F)->b80E2469;
		byte dl_42 = (byte) edx_33;
		ui24 edx_24_8_60 = SLICE(edx_33, word24, 8);
		if (eax_24 >= (byte *) 100)
			runtime.panicindex(gs);
		Mem43[fp - 100 + eax_24:byte] = dl_42;
		ui24 ebx_24_8_56 = SLICE(esi, word24, 8);
		Eq_4 esi_73 = SEQ(ebx_24_8_56, Test(ULT,false)) | SEQ(edx_24_8_60, ecx_22 == 0x00) & SEQ(ebx_24_8_56, edx_23 < 0x10);
		esi = esi_73;
		if ((byte) esi_73 != 0x00)
			break;
		edx_23 = ecx_22 << 0x1C | edx_23 >> 0x04;
		ecx_22 >>= 0x04;
	}
	if (eax_24 >= (byte *) 101)
		runtime.panicindex(gs);
	else
	{
		Mem101[fp - 101 + eax_24:byte] = 0x78;
		byte * ecx_102 = eax_24 - (byte *) 0x02;
		if (ecx_102 >= (byte *) 100)
			runtime.panicindex(gs);
		else
		{
			Mem109[fp - 0x66 + eax_24:byte] = 0x30;
			Eq_4 eax_111 = -(eax_24 + -0x0066);
			runtime.gwrite(gs, fp - 100 + (ecx_102 & -eax_111 >> 0x1F), eax_111);
			esiOut.u0 = <invalid>;
			return <invalid>;
		}
	}
}

// 0806CED0: void runtime.printpointer(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*lfstack).push
//      runtime.sysMap
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.scanstack
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.printslice
//      runtime.printeface
//      runtime.dumpgstatus
//      runtime.casfrom_Gscanstatus
//      runtime.releasep
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.newstack
//      runtime.gentraceback
//      runtime.writebarrierptr.func1
//      runtime.futexwakeup.func1
void runtime.printpointer(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.printhex(esi, gs, dwArg04, 0x00, out esi_36);
}

// 0806CF10: void runtime.printstring(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg
//      runtime.printany
//      runtime.makemap
//      runtime.(*lfstack).push
//      runtime.notewakeup
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.(*mcache).nextFree
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.sysAlloc
//      runtime.sysMap
//      runtime.(*fixalloc).alloc
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.getfull
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.testdefersizes
//      runtime.printpanics
//      runtime.gopanic
//      runtime.throw
//      runtime.recovery
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.printsp
//      runtime.printnl
//      runtime.printbool
//      runtime.printfloat
//      runtime.printcomplex
//      runtime.printint
//      runtime.printslice
//      runtime.printeface
//      runtime.forcegchelper
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.stoplockedm
//      runtime.goexit0
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.schedtrace
//      sync.runtime_notifyListCheck
//      runtime.dumpregs
//      runtime.sighandler
//      runtime.sigpanic
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.newstack
//      runtime.moduledataverify1
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.traceback1
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.writebarrierptr.func1
//      runtime.futexwakeup.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      internal/poll.convertErr
void runtime.printstring(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gwrite(gs, dwArg04, dwArg08);
}

// 0806CF90: void runtime.printslice(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.pcvalue
void runtime.printslice(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx, gs, dwArg08);
	runtime.printstring(gs);
	runtime.printint(ebx, gs, dwArg0C);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.printpointer(gs);
}

// 0806D050: void runtime.printeface(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.printany
void runtime.printeface(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806D0E0: void runtime.main(Register (ptr32 Eq_2) gs)
void runtime.main(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	*((word32) **((word32) eax_19 + 24) + 0x00B0) = 0x00;
	g_t8136014.u0 = 250000000;
	g_b8157574 = 0x01;
	word32 ebp_559;
	word32 edi_560;
	runtime.systemstack(gs, 0x080E7C2C, out ebp_559, out edi_560);
	Eq_4 eax_41 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_41 + 452) = (word32) *((word32) eax_41 + 452) + 2;
	Eq_4 eax_46 = gs->ptr0000->tFFFFFFFC;
	ptr32 dwLoc28_477 = 0x080E7C2C;
	Eq_4 ecx_47 = *((word32) eax_46 + 24);
	if (g_t81576F0 == 0x00)
		*((word32) ecx_47 + 188) = eax_46;
	else
	{
		runtime.writebarrierptr((word32) ecx_47 + 188, eax_46);
		dwLoc28_477 = (word32) ecx_47 + 188;
		dwLoc24 = eax_46;
	}
	Eq_4 ebx_72 = *((word32) eax_46 + 24);
	if (g_t81576F0 == 0x00)
		*((word32) eax_46 + 0x0088) = ebx_72;
	else
	{
		runtime.writebarrierptr((word32) eax_46 + 0x0088, ebx_72);
		dwLoc28_477 = (word32) eax_46 + 0x0088;
		dwLoc24 = ebx_72;
	}
	if (*((word32) eax_19 + 24) != 135550688)
		runtime.throw(gs);
	else
	{
		word32 esi_561;
		word32 edi_562;
		word128 xmm0_563;
		runtime.init(gs, out esi_561, out edi_562, out xmm0_563);
		runtime.nanotime();
		if ((byte) (SEQ(SLICE(dwLoc24, word24, 8), dwLoc24 == 0x00) & SEQ(SLICE(dwLoc28_477, word24, 8), dwLoc28_477 == 0x00)) != 0x00)
			runtime.throw(gs);
		else
		{
			Eq_4 ebp_159;
			word32 edi_162;
			word32 esi_564;
			if (runtime.deferproc(gs, 0x04, 0x080E7C30, fp - 0x0D, out ebp_159, out esi_564, out edi_162) != 0x00)
				runtime.deferreturn(gs);
			else
			{
				runtime.nanotime();
				g_dw81576A0 = 0x04;
				g_t81576A4.u1 = 0x080E7C30;
				word32 edi_202;
				word32 esi_565;
				runtime.makechan(runtime.gcenable(ebp_159, edi_162, gs, out edi_202), edi_202, gs, &g_t80CA640, 0x00, 0x00, out esi_565);
				if (g_t81576F0 == 0x00)
					g_t8144FD4 = dwLoc1C;
				else
					runtime.writebarrierptr(135548884, dwLoc1C);
				if ((byte) (word32) g_b8157571 != 0x00)
				{
					if (g_ptr8144F88 == null)
						runtime.throw(gs);
					if (g_dw8144FA0 == 0x00)
						runtime.throw(gs);
					if (g_dw8144FA4 == 0x00)
						runtime.throw(gs);
					<anonymous> * eax_290 = g_ptr8144F84;
					if (eax_290 == null)
						runtime.throw(gs);
					runtime.cgocall(gs, eax_290, 0x00);
				}
				Eq_661 xmm0_328;
				Eq_661 xmm1_329;
				runtime.closechan(main.init(gs, out xmm0_328, out xmm1_329), gs, g_t8144FD4);
				runtime.unlockOSThread(gs);
				if ((byte) (word32) g_b8157570 != 0x00 || (byte) ((word32) g_b8157572) != 0x00)
					runtime.deferreturn(gs);
				else
				{
					main.main(gs, xmm0_328, xmm1_329);
					runtime/internal/atomic.Load();
					struct Eq_46508 * esp_404 = fp - 0x24;
					if (0x00 != 0x00)
					{
						int32 eax_409 = 0x00;
						while (eax_409 < 1000)
						{
							esp_404[7] = (struct Eq_46508) eax_409;
							esp_404->dw0000 = 0x08157638;
							runtime/internal/atomic.Load();
							++esp_404;
							if (esp_404[1] == 0x00)
								break;
							runtime.Gosched(gs);
							eax_409 = (word32) esp_404[7].dw0000 + 1;
						}
					}
					esp_404->dw0000 = 0x08157618;
					runtime/internal/atomic.Load();
					struct Eq_46520 * esp_442 = esp_404 + 1;
					if (esp_442->dw0004 != 0x00)
					{
						esp_442->dw0000 = 0x00;
						esp_442->dw0004 = 0x00;
						esp_442->ptr0008 = 0x080E16A4;
						esp_442->dw000C = 0x09;
						esp_442->b0010 = 0x10;
						esp_442->dw0014 = 0x01;
						runtime.gopark(gs);
					}
					esp_442->dw0000 = 0x00;
					runtime.exit();
					while (true)
						null = (union Eq_4 *) 0x00;
				}
			}
		}
	}
}

// 0806D4A0: Register word32 runtime.init.3(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
word32 runtime.init.3(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.newproc();
}

// 0806D4E0: void runtime.forcegchelper(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.forcegchelper(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = gs->ptr0000->tFFFFFFFC;
	if (g_t81576F0 == 0x00)
		g_t814513C = ecx_19;
	else
		runtime.writebarrierptr(135549244, ecx_19);
	while (true)
	{
		word32 ebp_170;
		word32 esi_171;
		word32 edi_172;
		runtime.lock(esi, gs, 0x08145138, out ebp_170, out esi_171, out edi_172);
		if (g_dw8145140 != 0x00)
			break;
		runtime/internal/atomic.Store(0x08145140, 0x01);
		runtime.goparkunlock(gs);
		Eq_4 dwLoc14_156 = 0x08145138;
		Eq_4 dwLoc10_157 = 135144218;
		if (g_dw8157740 > 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			dwLoc14_156.u0 = 0x080E15F0;
			dwLoc10_157.u0 = 0x09;
		}
		runtime.nanotime();
		runtime.gcStart(gs, 0x00, 0x02, dwLoc14_156, dwLoc10_157, out esi);
	}
	runtime.throw(gs);
}

// 0806D620: Register word32 runtime.Gosched(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcAssistAlloc
//      runtime.bgsweep
//      runtime.main
word32 runtime.Gosched(struct Eq_2 * gs)
{
	word32 esi_13;
	runtime.mcall(gs, dwLoc08, &g_dw80E7C1C, out esi_13);
	return esi_13;
}

// 0806D640: void runtime.gopark(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.gcBgMarkWorker
//      runtime.netpollblock
//      runtime.main
//      runtime.goparkunlock
void runtime.gopark(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	runtime.readgstatus(*((word32) *((word32) eax_18 + 24) + 84));
	Eq_4 esp_32 = <invalid>;
	Eq_4 eax_37 = *((word32) esp_32 + 4);
	if (eax_37 == 0x02 || eax_37 == 0x1002)
	{
		Eq_4 ecx_104 = *((word32) esp_32 + 8);
		if (g_t81576F0 == 0x00)
			*((word32) ecx_104 + 468) = *((word32) esp_32 + 24);
		else
		{
			*esp_32 = (word32) ecx_104 + 468;
			*((word32) esp_32 + 4) = *((word32) esp_32 + 24);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg8 = <invalid>;
			runtime.writebarrierptr(stackArg4, stackArg8);
			ecx_104 = *((word32) esp_32 + 8);
		}
		word32 * edx_71 = (word32) ecx_104 + 464;
		Eq_4 ebx_73 = *((word32) esp_32 + 20);
		if (g_t81576F0 == 0x00)
			*((word32) ecx_104 + 464) = ebx_73;
		else
		{
			*esp_32 = edx_71;
			*((word32) esp_32 + 4) = ebx_73;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg8 = <invalid>;
			runtime.writebarrierptr(stackArg4, stackArg8);
			ecx_104 = *((word32) esp_32 + 8);
		}
		Eq_4 edx_89 = *((word32) esp_32 + 0x0C);
		*((word32) edx_89 + 100) = *((word32) esp_32 + 32);
		if (g_t81576F0 == 0x00)
			*((word32) edx_89 + 96) = *((word32) esp_32 + 28);
		else
		{
			*esp_32 = (word32) edx_89 + 96;
			*((word32) esp_32 + 4) = *((word32) esp_32 + 28);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg8 = <invalid>;
			runtime.writebarrierptr(stackArg4, stackArg8);
			ecx_104 = *((word32) esp_32 + 8);
		}
		*((word32) ecx_104 + 472) = (byte) (word32) *((word32) esp_32 + 36);
		*((word32) ecx_104 + 476) = *((word32) esp_32 + 40);
		Eq_4 eax_121 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_122 = *((word32) ecx_104 + 0x0078);
		*((word32) ecx_104 + 0x0078) = edx_122 - 0x01;
		if (edx_122 == 0x01 && (byte) ((word32) (*((word32) eax_121 + 0x006C))) != 0x00)
			((word32) eax_121 + 8)->u0 = ~0x0521;
		*esp_32 = &g_dw80E7C9C;
		word32 esi_167;
		runtime.mcall(gs, *((word32) esp_32 - 4), *esp_32, out esi_167);
	}
	else
	{
		*esp_32 = &g_dw80E30AB;
		((word32) esp_32 + 4)->u0 = 0x14;
		runtime.throw(gs);
	}
}

// 0806D7C0: void runtime.goparkunlock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.runfinq
//      runtime.gcParkAssist
//      runtime.bgsweep
//      runtime.forcegchelper
//      runtime.semacquire1
//      runtime.timerproc
void runtime.goparkunlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gopark(gs);
}

// 0806D820: void runtime.goready(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.send
//      runtime.closechan
//      runtime.recv
//      runtime.netpollgoready
//      runtime.readyWithTime
void runtime.goready(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_44;
	word32 edi_45;
	runtime.systemstack(gs, fp - 0x0C, out ebp_44, out edi_45);
}

// 0806D870: Register Eq_4 runtime.acquireSudog(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.semacquire1
Eq_4 runtime.acquireSudog(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_9 = *((word32) eax_8 + 24);
	*((word32) ecx_9 + 0x0078) = (word32) *((word32) ecx_9 + 0x0078) + 1;
	Eq_4 ecx_13 = *((word32) eax_8 + 24);
	Eq_4 edx_15 = *((word32) ecx_13 + 92);
	if (*((word32) edx_15 + 0x0720) == 0x00)
	{
		word32 esi_445;
		word32 ebp_444;
		word32 edi_446;
		runtime.lock(esi, gs, 135550004, out ebp_444, out esi_445, out edi_446);
		while (true)
		{
			Eq_4 ecx_36 = *((word32) edx_15 + 1828);
			if (Mem34[edx_15 + 0x0720:word32] >= ((ecx_36 >> 0x1F) >>u 0x1F) + ecx_36 >> 0x01)
				break;
			Eq_4 ecx_45 = g_t8145438;
			if (ecx_45 == 0x00)
				break;
			Eq_4 ebx_223 = *((word32) ecx_45 + 8);
			if (g_t81576F0 == 0x00)
			{
				g_t8145438 = ebx_223;
				((word32) ecx_45 + 8)->u0 = 0x00;
			}
			else
			{
				runtime.writebarrierptr(135550008, ebx_223);
				runtime.writebarrierptr((word32) ecx_45 + 8, 0x00);
				dwLoc44.u0 = 0x00;
			}
			Eq_4 edx_249 = *((word32) edx_15 + 1828);
			Eq_4 ebx_250 = *((word32) edx_15 + 0x0720);
			Eq_4 ebp_251 = *((word32) edx_15 + 0x071C);
			if ((word32) ebx_250 + 1 > edx_249)
			{
				word32 esi_449;
				runtime.growslice(gs, 0x080C8440, ebp_251, ebx_250, edx_249, (word32) ebx_250 + 1, out esi_449);
				*((word32) edx_15 + 1828) = dwLoc2C;
				dwLoc44 = ebp_251;
				if (g_t81576F0 == 0x00)
					*((word32) edx_15 + 0x071C) = dwLoc34;
				else
				{
					runtime.writebarrierptr((word32) edx_15 + 0x071C, dwLoc34);
					dwLoc44 = dwLoc34;
				}
				ebx_250 = dwLoc30;
				ebp_251 = dwLoc34;
			}
			*((word32) edx_15 + 0x0720) = (word32) ebx_250 + 1;
			Eq_4 esi_304 = (word32) ebp_251 + ebx_250 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ebp_251 + ebx_250 * 0x04) = ecx_45;
			else
			{
				runtime.writebarrierptr(esi_304, ecx_45);
				dwLoc44 = ecx_45;
			}
		}
		word32 ebx_448;
		word32 edx_447;
		runtime.unlock(gs, 135550004, out edx_447, out ebx_448);
		if (*((word32) edx_15 + 0x0720) == 0x00)
		{
			runtime.newobject(gs, 135115232);
			Eq_4 ecx_118 = *((word32) edx_15 + 0x071C);
			Eq_4 edx_73 = *((word32) edx_15 + 1828);
			Eq_4 ebx_116 = *((word32) edx_15 + 0x0720);
			if ((word32) ebx_116 + 1 > edx_73)
			{
				word32 esi_450;
				runtime.growslice(gs, 0x080C8440, ecx_118, ebx_116, edx_73, (word32) ebx_116 + 1, out esi_450);
				*((word32) edx_15 + 1828) = dwLoc2C;
				if (g_t81576F0 == 0x00)
					*((word32) edx_15 + 0x071C) = dwLoc34;
				else
					runtime.writebarrierptr((word32) edx_15 + 0x071C, dwLoc34);
				ebx_116 = dwLoc30;
				ecx_118 = dwLoc34;
			}
			*((word32) edx_15 + 0x0720) = (word32) ebx_116 + 1;
			Eq_4 edx_125 = (word32) ecx_118 + ebx_116 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ecx_118 + ebx_116 * 0x04) = dwLoc44;
			else
				runtime.writebarrierptr(edx_125, dwLoc44);
		}
	}
	Eq_4 ecx_146 = *((word32) edx_15 + 0x0720);
	Eq_4 edx_147 = *((word32) edx_15 + 0x071C);
	if (ecx_146 - 0x01 >= ecx_146)
		runtime.panicindex(gs);
	else
	{
		struct Eq_47105 * ebp_158 = (edx_147 - 0x04)[ecx_146];
		Eq_4 esi_159 = edx_147 - 0x04 + ecx_146 * 0x04;
		if (g_t81576F0 == 0x00)
			(edx_147 - 0x04)[ecx_146] = 0x00;
		else
			runtime.writebarrierptr(esi_159, 0x00);
		if (ecx_146 - 0x01 > *((word32) edx_15 + 1828))
			runtime.panicslice(gs);
		else
		{
			*((word32) edx_15 + 0x0720) = ecx_146 - 0x01;
			if (ebp_158->dw0010 != 0x00)
				runtime.throw(gs);
			else
			{
				Eq_4 eax_203 = gs->ptr0000->tFFFFFFFC;
				Eq_4 edx_205 = *((word32) ecx_13 + 0x0078);
				*((word32) ecx_13 + 0x0078) = edx_205 - 0x01;
				if (edx_205 == 0x01 && (byte) ((word32) (*((word32) eax_203 + 0x006C))) != 0x00)
					((word32) eax_203 + 8)->u0 = ~0x0521;
				return edx_205;
			}
		}
	}
}

// 0806DC00: Register word32 runtime.releaseSudog(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_4 esiOut, Register out Eq_3432 ediOut)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.semacquire1
word32 runtime.releaseSudog(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_4 & esiOut, union Eq_3432 & ediOut)
{
	if (*((word32) dwArg04 + 16) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 4) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 8) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 0x0C) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 44) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 52) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_75 = gs->ptr0000->tFFFFFFFC;
		if (*((word32) ecx_75 + 0x0044) != 0x00)
			runtime.throw(gs);
		else
		{
			Eq_4 edx_87 = *((word32) ecx_75 + 24);
			*((word32) edx_87 + 0x0078) = (word32) *((word32) edx_87 + 0x0078) + 1;
			Eq_4 edx_91 = *((word32) ecx_75 + 24);
			Eq_4 ebx_93 = *((word32) edx_91 + 92);
			Eq_4 esi_101 = *((word32) ebx_93 + 1828);
			if (esi_101 == *((word32) ebx_93 + 0x0720))
			{
				Eq_4 ebp_104 = 0x00;
				esi_101.u0 = 0x00;
				ebx_113 = ebx_93;
				while (true)
				{
					Eq_4 ebx_113;
					Eq_4 edi_114 = *((word32) ebx_113 + 1828);
					edi = edi_114 >> 0x1F >> 0x1F;
					Eq_4 ecx_116 = *((word32) ebx_113 + 0x0720);
					Eq_4 edx_117 = *((word32) ebx_113 + 0x071C);
					if (ecx_116 <= edi_114 + edi >> 0x01)
						break;
					if (ecx_116 - 0x01 >= ecx_116)
						runtime.panicindex(gs);
					Eq_4 edi_269 = (edx_117 - 0x04)[ecx_116];
					Eq_4 edi_271 = edx_117 - 0x04 + ecx_116 * 0x04;
					if (g_t81576F0 == 0x00)
						(edx_117 - 0x04)[ecx_116] = 0x00;
					else
					{
						runtime.writebarrierptr(edi_271, 0x00);
						ebx_113 = ebx_93;
					}
					if (ecx_116 - 0x01 > *((word32) ebx_113 + 1828))
						runtime.panicslice(gs);
					*((word32) ebx_113 + 0x0720) = ecx_116 - 0x01;
					if (ebp_104 != 0x00)
					{
						Eq_4 ecx_314 = (byte) esi_101.u0 + 8;
						if (g_t81576F0 == 0x00)
							*((byte) esi_101.u0 + 8) = edi_269;
						else
						{
							runtime.writebarrierptr(ecx_314, edi_269);
							ebx_113 = ebx_93;
						}
					}
					else
						ebp_104 = edi_269;
					esi_101 = edi_269;
				}
				word32 ebp_468;
				word32 edi_470;
				word32 esi_469;
				runtime.lock(esi, gs, 135550004, out ebp_468, out esi_469, out edi_470);
				Eq_4 ebx_138 = g_t8145438;
				if (g_t81576F0 == 0x00)
				{
					*((byte) esi_101.u0 + 8) = ebx_138;
					g_t8145438 = ebp_104;
				}
				else
				{
					runtime.writebarrierptr((byte) esi_101.u0 + 8, ebx_138);
					runtime.writebarrierptr(135550008, ebp_104);
				}
				word32 ebx_473;
				word32 edx_472;
				runtime.unlock(gs, 135550004, out edx_472, out ebx_473);
			}
			Eq_4 edx_212;
			Eq_4 edx_172 = *((word32) ebx_93 + 0x0720);
			Eq_4 ecx_171 = *((word32) ebx_93 + 0x071C);
			Eq_4 ebx_173 = *((word32) ebx_93 + 1828);
			edx_212 = edx_172;
			if ((word32) edx_172 + 1 > ebx_173)
			{
				word32 esi_471;
				runtime.growslice(gs, 0x080C8440, ecx_171, edx_172, ebx_173, (word32) edx_172 + 1, out esi_471);
				*((word32) ebx_93 + 1828) = dwLoc2C;
				if (g_t81576F0 == 0x00)
					*((word32) ebx_93 + 0x071C) = dwLoc34;
				else
					runtime.writebarrierptr((word32) ebx_93 + 0x071C, dwLoc34);
				edx_212 = dwLoc30;
				ecx_171 = dwLoc34;
			}
			*((word32) ebx_93 + 0x0720) = (word32) edx_212 + 1;
			Eq_4 ebx_223 = (word32) ecx_171 + edx_212 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ecx_171 + edx_212 * 0x04) = dwArg04;
			else
				runtime.writebarrierptr(ebx_223, dwArg04);
			Eq_4 eax_245 = gs->ptr0000->tFFFFFFFC;
			Eq_4 edx_248 = *((word32) edx_91 + 0x0078);
			*((word32) edx_91 + 0x0078) = edx_248 - 0x01;
			if (edx_248 == 0x01 && (byte) ((word32) (*((word32) eax_245 + 0x006C))) != 0x00)
				((word32) eax_245 + 8)->u0 = ~0x0521;
			esiOut = esi_101;
			ediOut = edi;
			return (word32) edx_172 + 1;
		}
	}
}

// 0806DFC0: void runtime.funcPC()
// Called from:
//      runtime.init
void runtime.funcPC()
{
}

// 0806DFE0: void runtime.badmcall(Register (ptr32 Eq_2) gs)
void runtime.badmcall(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806E020: void runtime.badmcall2(Register (ptr32 Eq_2) gs)
void runtime.badmcall2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806E060: void runtime.badreflectcall(Register (ptr32 Eq_2) gs)
void runtime.badreflectcall(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gopanic(gs);
}

// 0806E0A0: Register ui32 runtime.badmorestackg0(Register out ptr32 edxOut, Register out (ptr32 Eq_47576) ebxOut)
// Called from:
//      runtime.morestack
ui32 runtime.badmorestackg0(ptr32 & edxOut, struct Eq_47576 & ebxOut)
{
	struct Eq_47576 * ebx_13;
	ptr32 edx_15;
	ui32 ecx_14 = runtime.write(out edx_15, out ebx_13);
	edxOut = edx_15;
	ebxOut = ebx_13;
	return ecx_14;
}

// 0806E0D0: Register word32 runtime.badmorestackgsignal(Register out (ptr32 Eq_47588) ebxOut)
// Called from:
//      runtime.morestack
word32 runtime.badmorestackgsignal(struct Eq_47588 & ebxOut)
{
	struct Eq_47588 * ebx_13;
	word32 edx_15;
	runtime.write(out edx_15, out ebx_13);
	ebxOut = ebx_13;
	return edx_15;
}

// 0806E100: void runtime.badctxt()
// Called from:
//      runtime.save
//      runtime.gosave
//      gosave
void runtime.badctxt()
{
	runtime.throw(gs);
}

// 0806E120: void runtime.allgadd(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.oneNewExtraM
//      runtime.newproc1
void runtime.allgadd(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg04);
	if (dwLoc24 == 0x00)
		runtime.throw(gs);
	else
	{
		word32 ebp_47;
		word32 edi_48;
		word32 esi_49;
		runtime.lock(esi, gs, 0x08157590, out ebp_47, out esi_49, out edi_48);
		Eq_4 eax_104 = g_t8145108;
		Eq_4 ecx_101 = g_t814510C;
		Eq_4 edx_56 = g_t8145110;
		if ((word32) ecx_101 + 1 > edx_56)
		{
			word32 esi_72;
			runtime.growslice(gs, 0x080C76C0, eax_104, ecx_101, edx_56, (word32) ecx_101 + 1, out esi_72);
			g_t8145110 = dwLoc0C;
			eax_104 = dwLoc14;
			ecx_101 = dwLoc10;
			if (g_t81576F0 == 0x00)
				g_t8145108 = dwLoc14;
			else
			{
				runtime.writebarrierptr(0x08145108, dwLoc14);
				eax_104 = dwLoc14;
				ecx_101 = dwLoc10;
			}
		}
		g_t814510C = (word32) ecx_101 + 1;
		Eq_4 edx_105 = (word32) eax_104 + ecx_101 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) eax_104 + ecx_101 * 0x04) = dwArg04;
		else
			runtime.writebarrierptr(edx_105, dwArg04);
		g_t815758C = g_t814510C;
		word32 ebx_183;
		word32 edx_182;
		runtime.unlock(gs, 0x08157590, out edx_182, out ebx_183);
	}
}

// 0806E260: void runtime.schedinit(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register word64 mm0)
// Called from:
//      main
void runtime.schedinit(Eq_4 esi, struct Eq_2 * gs, word64 mm0)
{
	byte bLoc0C_374 = (byte) dwLoc0C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	g_t8145404.u0 = 10000;
	runtime.tracebackinit(gs);
	Eq_13897 ebx_24_8_49 = SLICE(runtime.moduledataverify(esi, gs), word24, 8);
	runtime.stackinit(gs);
	runtime.mallocinit(ebx_24_8_49, gs);
	runtime.mcommoninit(gs, *((word32) eax_19 + 24));
	runtime.alginit(gs, mm0);
	Eq_4 esi_94;
	runtime.itabsinit(runtime.typelinksinit(runtime.modulesinit(gs, out esi_94), esi_94, gs), gs);
	Eq_4 ecx_130 = *((word32) eax_19 + 24);
	runtime.msigsave();
	Eq_4 eax_142 = *((word32) eax_19 + 24);
	Eq_4 ecx_143 = *((word32) eax_142 + 52);
	g_t8157680 = *((word32) eax_142 + 48);
	g_t8157684 = ecx_143;
	runtime.goargs(gs);
	runtime.goenvs(gs);
	runtime.parsedebugvars(gs);
	runtime.gcinit(gs);
	runtime.nanotime();
	g_t81453E8 = ecx_130;
	g_dw81453EC = dwLoc14;
	Eq_4 eax_212 = g_t8157608;
	runtime.gogetenv(gs, 135141561, 0x0A);
	word32 esi_238;
	word32 ebp_233 = runtime.atoi32(gs, dwLoc10, dwLoc0C, out esi_238);
	Eq_4 eax_243 = dwLoc10;
	if ((byte) (word32) bLoc0C_374 == 0x00 || dwLoc10 <= 0x00)
		eax_243 = eax_212;
	if (eax_243 > 0x0400)
		eax_243.u0 = 0x0400;
	runtime.procresize(ebp_233, esi_238, gs, eax_243);
	if (dwLoc0C != 0x00)
		runtime.throw(gs);
	else if (g_dw8142624 == 0x00)
	{
		g_dw8142624 = 0x07;
		if (g_t81576F0 == 0x00)
			g_ptr8142620 = 135140199;
		else
			runtime.writebarrierptr(0x08142620, 135140199);
	}
}

// 0806E3F0: void runtime.dumpgstatus(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.ready
//      runtime.casfrom_Gscanstatus
//      runtime.scang
//      runtime.restartg
//      runtime.stoplockedm
//      runtime.goschedImpl
void runtime.dumpgstatus(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.readgstatus(dwArg04);
	Eq_4 esp_24 = <invalid>;
	Eq_4 eax_29 = *((word32) esp_24 + 28);
	*((word32) esp_24 + 16) = *((word32) eax_29 + 84);
	*((word32) esp_24 + 0x0C) = *((word32) eax_29 + 80);
	*((word32) esp_24 + 8) = *((word32) esp_24 + 4);
	runtime.printlock(gs);
	esp_24->u0 = 135145001;
	((word32) esp_24 + 4)->u0 = 0x10;
	runtime.printstring(gs);
	*esp_24 = *((word32) esp_24 + 28);
	runtime.printpointer(gs);
	esp_24->u0 = 0x080E11ED;
	((word32) esp_24 + 4)->u0 = 0x07;
	runtime.printstring(gs);
	*esp_24 = *((word32) esp_24 + 0x0C);
	*((word32) esp_24 + 4) = *((word32) esp_24 + 16);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	runtime.printint(ebx, gs, stackArg4);
	esp_24->u0 = 135146316;
	((word32) esp_24 + 4)->u0 = 0x13;
	runtime.printstring(gs);
	*esp_24 = *((word32) esp_24 + 8);
	((word32) esp_24 + 4)->u0 = 0x00;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	runtime.printint(ebx, gs, stackArg4);
	esp_24->u0 = 0x080E0D9C;
	((word32) esp_24 + 4)->u0 = 0x01;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	*esp_24 = *((word32) esp_24 + 20);
	runtime.readgstatus(*esp_24);
	Eq_4 edx_104 = *((word32) eax_19 + 80);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	runtime.printint(ebx, gs, edx_104);
	runtime.printstring(gs);
	runtime.printint(ebx, gs, dwLoc14);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806E5A0: void runtime.checkmcount(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mcommoninit
void runtime.checkmcount(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_17 = g_t8145404;
	if (g_t8145400 <= ecx_17)
		return;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx, gs, ecx_17);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0806E640: void runtime.mcommoninit(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.schedinit
//      runtime.allocm
void runtime.mcommoninit(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (eax_18 != *(*((word32) eax_18 + 24)))
	{
		runtime.callers(gs);
		dwLoc14 = 0x01;
	}
	runtime.cputicks();
	Eq_4 ecx_46 = *((word32) dwArg04 + 100);
	*((word32) dwArg04 + 0x0094) = (word32) ecx_46 + (dwLoc14 + 0x49F6428A);
	if ((word32) ecx_46 + dwLoc14 == ~0x49F64289)
		((word32) dwArg04 + 0x0094)->u0 = 0x49F6428A;
	word32 ebp_191;
	word32 esi_192;
	word32 edi_193;
	runtime.lock(esi, gs, 135549936, out ebp_191, out esi_192, out edi_193);
	*((word32) dwArg04 + 100) = g_t8145400;
	g_t8145400 = (word32) g_t8145400 + 1;
	runtime.checkmcount(gs);
	runtime.mpreinit(gs, dwArg04);
	Eq_4 ecx_81 = *((word32) dwArg04 + 44);
	if (ecx_81 != 0x00)
		*((word32) ecx_81 + 0x0C) = (word32) *ecx_81 + 880;
	Eq_4 edx_91 = g_t8144FAC;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 0x00B0) = edx_91;
	else
		runtime.writebarrierptr((word32) dwArg04 + 0x00B0, edx_91);
	runtime.atomicstorep(135548844, dwArg04);
	word32 edx_194;
	word32 ebx_195;
	runtime.unlock(gs, 135549936, out edx_194, out ebx_195);
	if ((byte) (word32) g_b8157571 != 0x00)
	{
		runtime.newobject(gs, 0x080CFEE0);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 0x00A8) = dwArg04;
		else
			runtime.writebarrierptr((word32) dwArg04 + 0x00A8, dwArg04);
	}
}

// 0806E7D0: void runtime.ready(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcSweep
//      runtime.gcFlushBgCredit
//      runtime.findrunnable
//      runtime.goready.func1
void runtime.ready(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGoUnpark(gs, dwArg04);
	runtime.readgstatus(dwArg04);
	Eq_4 eax_42 = gs->ptr0000->tFFFFFFFC;
	Eq_4 esp_35 = <invalid>;
	Eq_4 ecx_43 = *((word32) eax_42 + 24);
	Eq_4 edx_44 = *((word32) esp_35 + 4);
	*((word32) ecx_43 + 0x0078) = (word32) *((word32) ecx_43 + 0x0078) + 1;
	if ((edx_44 & ~0x1000) != 0x04)
	{
		*esp_35 = *((word32) esp_35 + 20);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.dumpgstatus(gs, stackArg4);
		esp_35->u0 = 0x080E3575;
		((word32) esp_35 + 4)->u0 = 22;
		runtime.throw(gs);
	}
	else
	{
		*((word32) esp_35 + 0x0C) = eax_42;
		*esp_35 = *((word32) esp_35 + 20);
		((word32) esp_35 + 4)->u0 = 0x04;
		((word32) esp_35 + 8)->u0 = 0x01;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.casgstatus(stackArg4, dwArg04, dwArg08);
		*esp_35 = *((word32) *((word32) *((word32) esp_35 + 0x0C) + 24) + 92);
		*((word32) esp_35 + 4) = *((word32) esp_35 + 20);
		*((word32) esp_35 + 8) = (byte) (word32) *((word32) esp_35 + 28);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		runtime.runqput(gs, stackArg0, stackArg4, dwArg04, dwArg08);
		esp_35->u0 = 0x08145410;
		runtime/internal/atomic.Load();
		if (*((word32) esp_35 + 8) != 0x00)
		{
			((word32) esp_35 + 4)->u0 = 0x08145414;
			runtime/internal/atomic.Load();
			if (*((word32) esp_35 + 0x0C) == 0x00)
				runtime.wakep(gs);
		}
		struct Eq_48329 * ecx_110 = dwLoc04->ptr0018;
		--ecx_110->dw0078;
		if (dwLoc04->ptr0018->dw0078 == 0x00 && (byte) ((word32) dwLoc04->b006C) != 0x00)
			dwLoc04->dw0008 = ~0x0521;
	}
}

// 0806E920: void runtime.gcprocs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMark
void runtime.gcprocs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_72;
	word32 edi_73;
	word32 ebp_71;
	runtime.lock(esi, gs, 135549936, out ebp_71, out esi_72, out edi_73);
	Eq_4 eax_22 = g_t81575F0;
	Eq_4 ecx_23 = g_t8157608;
	if (eax_22 <= ecx_23)
		ecx_23 = eax_22;
	Eq_4 eax_30;
	if (ecx_23 > 0x20)
		eax_30.u0 = 0x20;
	else
		eax_30 = ecx_23;
	word32 edx_74;
	word32 ebx_75;
	runtime.unlock(gs, 135549936, out edx_74, out ebx_75);
}

// 0806E9A0: Register Eq_4 runtime.needaddgcproc(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.startTheWorldWithSema
Eq_4 runtime.needaddgcproc(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 ebp_90;
	word32 edi_91;
	runtime.lock(esi, gs, 135549936, out ebp_90, out esi_28, out edi_91);
	Eq_4 eax_33 = g_t81575F0;
	Eq_4 ecx_34 = g_t8157608;
	if (eax_33 <= ecx_34)
		ecx_34 = eax_33;
	word32 edx_92;
	word32 ebx_93;
	runtime.unlock(gs, 135549936, out edx_92, out ebx_93);
	return esi_28;
}

// 0806EA20: void runtime.helpgc(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMark
void runtime.helpgc(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	word32 ebp_29;
	word32 edi_30;
	word32 esi_31;
	runtime.lock(esi, gs, 135549936, out ebp_29, out esi_31, out edi_30);
	Eq_4 eax_132 = 0x01;
	uint32 ecx_105 = 0x00;
	while (eax_132 < dwArg04)
	{
		if (ecx_105 >= 0x0401)
			runtime.panicindex(gs);
		if (*((char *) *((char *) g_a81478C0 + ecx_105 * 0x04) + 52) == *((word32) (*((word32) eax_19 + 24)) + 0x00B8))
			++ecx_105;
		Eq_4 ebp_74 = g_t81453F4;
		bool Z_77 = SLICE(cond(ebp_74), bool, 2);
		if (ebp_74 != 0x00)
		{
			g_t81453F4 = *((word32) ebp_74 + 0x00B4);
			--g_t81453F8;
			Z_77 = SLICE(cond(ebp_74), bool, 2);
		}
		if (Z_77)
			runtime.throw(gs);
		*((word32) ebp_74 + 0x0088) = eax_132;
		if (ecx_105 >= 0x0401)
			runtime.panicindex(gs);
		*((word32) ebp_74 + 92) = *((char *) g_a81478C0 + ecx_105 * 0x04);
		*((word32) ebp_74 + 0x00B8) = *((char *) *((char *) g_a81478C0 + ecx_105 * 0x04) + 52);
		runtime.notewakeup(gs, (word32) ebp_74 + 0x00AC);
		eax_132 = (word32) eax_132 + 1;
		++ecx_105;
	}
	word32 ebx_166;
	word32 edx_165;
	runtime.unlock(gs, 135549936, out edx_165, out ebx_166);
}

// 0806EB50: void runtime.freezetheworld(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.startpanic_m
void runtime.freezetheworld(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Store(0x081575D4, 0x01);
	int32 eax_23;
	for (eax_23 = 0x00; eax_23 < 0x05; ++eax_23)
	{
		g_t8145458.u0 = 0x7FFFFFFF;
		runtime/internal/atomic.Store(0x08145454, 0x01);
		runtime.preemptall(gs);
		if (false)
			break;
		word32 edi_124;
		runtime.usleep(out edi_124);
	}
	word32 edi_122;
	runtime.usleep(out edi_122);
	runtime.preemptall(gs);
	word32 edi_123;
	runtime.usleep(out edi_123);
}

// 0806EC00: void runtime.readgstatus(Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkRootCheck
//      runtime.markroot
//      runtime.scanstack
//      runtime.canpanic
//      runtime.gopark
//      runtime.allgadd
//      runtime.dumpgstatus
//      runtime.ready
//      runtime.scang
//      runtime.restartg
//      runtime.stoplockedm
//      runtime.goschedImpl
//      runtime.newproc1
//      runtime.gfput
//      runtime.checkdead
//      runtime.schedtrace
//      runtime.sighandler
//      runtime.newstack
//      runtime.shrinkstack
//      runtime.traceback1
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.markroot.func1
void runtime.readgstatus(Eq_4 dwArg04)
{
	runtime/internal/atomic.Load();
}

// 0806EC20: void runtime.casfrom_Gscanstatus(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scang
//      runtime.restartg
//      runtime.newstack
void runtime.casfrom_Gscanstatus(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 > ~0x1003)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_258;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_258);
		runtime.printstring(gs);
		word32 esi_259;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_259);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.dumpgstatus(gs, dwArg04);
		runtime.throw(gs);
	}
	else
	{
		uip32 eax_107;
		if (dwArg0C != (dwArg08 & ~0x1000))
			eax_107 = 0x00;
		else
		{
			runtime/internal/atomic.Cas((word32) dwArg04 + 72, dwArg08, dwArg0C);
			eax_107 = (word32) bLoc04;
		}
		if ((byte) eax_107 != 0x00)
			return;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_260;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_260);
		runtime.printstring(gs);
		word32 esi_261;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_261);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.dumpgstatus(gs, dwArg04);
		runtime.throw(gs);
	}
}

// 0806EE10: void runtime.castogscanstatus(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scang
//      runtime.newstack
void runtime.castogscanstatus(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 > 0x04 || dwArg0C != (dwArg08 | 0x1000))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_131;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_131);
		runtime.printstring(gs);
		word32 esi_132;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_132);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
		runtime/internal/atomic.Cas((word32) dwArg04 + 72, dwArg08, dwArg0C);
}

// 0806EF00: Register Eq_4 runtime.casgstatus(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcMarkTermination
//      runtime.gcAssistAlloc1
//      runtime.ready
//      runtime.needm
//      runtime.oneNewExtraM
//      runtime.dropm
//      runtime.execute
//      runtime.findrunnable
//      runtime.injectglist
//      runtime.schedule
//      runtime.park_m
//      runtime.goschedImpl
//      runtime.goexit0
//      runtime.reentersyscall
//      runtime.entersyscallblock
//      runtime.exitsyscall
//      runtime.exitsyscall0
//      runtime.newproc1
//      runtime.procresize
//      runtime.checkdead
//      runtime.newstack
//      runtime.gcBgMarkWorker.func2
//      runtime.markroot.func1
Eq_4 runtime.casgstatus(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	if ((dwArg08 & 0x1000) != 0x00 || ((dwArg0C & 0x1000) != 0x00 || dwArg0C == dwArg08))
	{
		word32 edi_401;
		word32 ebp_400;
		runtime.systemstack(gs, fp - 0x0C, out ebp_400, out edi_401);
	}
	if (dwArg08 != 0x02 || (byte) ((word32) (*((word32) dwArg04 + 112))) == 0x00)
	{
		word32 edx_109 = 0x00;
		Eq_4 ebx_110 = 0x00;
		word32 * ebp_111 = null;
		while (true)
		{
			runtime/internal/atomic.Cas((word32) dwArg04 + 72, dwArg08, dwArg0C);
			ui24 eax_24_8_127 = SLICE(dwArg08, word24, 8);
			word32 * dwLoc30_334 = (word32) dwArg04 + 72;
			if ((byte) (word32) bLoc24 != 0x00)
				break;
			if (dwArg08 == 0x04 && *((word32) dwArg04 + 72) == 0x01)
			{
				word32 edi_407;
				word32 ebp_406;
				runtime.systemstack(gs, 135166888, out ebp_406, out edi_407);
				dwLoc30_334 = &g_dw80E7BA8;
			}
			word32 * ebp_187;
			Eq_4 ebx_185;
			if (edx_109 != 0x00)
			{
				ebx_185 = ebx_110;
				ebp_187 = ebp_111;
			}
			else
			{
				runtime.nanotime();
				ebx_185 = (word32) dwArg08 + (dwLoc30_334 < (word32 *) 5000);
				ebp_187 = dwLoc30_334 + 0x04E2;
			}
			Eq_4 edx_242;
			if ((byte) (SEQ(eax_24_8_127, dwArg08 < ebx_185) | SEQ(SLICE(runtime.nanotime(), word24, 8), dwArg08 == ebx_185) & SEQ(SLICE(dwLoc30_334, word24, 8), dwLoc30_334 < ebp_187)) != 0x00)
			{
				int32 eax_247 = 0x00;
				while (true)
				{
					ebp_111 = ebp_187;
					edx_242 = ebx_185;
					if (eax_247 >= 0x0A || dwArg08 == *((word32) dwArg04 + 72))
						break;
					runtime.procyield(0x01);
					++eax_247;
				}
			}
			else
			{
				runtime.osyield();
				runtime.nanotime();
				edx_242 = (word32) dwArg08 + (dwLoc30_334 < (word32 *) 2500);
				ebp_111 = dwLoc30_334 + 625;
			}
			ebx_110 = edx_242;
			++edx_109;
		}
		if (dwArg0C == 0x02)
			((word32) dwArg04 + 112)->u0 = 0x00;
		return dwArg0C;
	}
	else
	{
		Eq_4 eax_42 = *((word32) dwArg04 + 72);
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_403;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_403);
		runtime.printstring(gs);
		word32 esi_404;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_404);
		runtime.printstring(gs);
		word32 esi_405;
		runtime.printhex(esi, gs, eax_42, 0x00, out esi_405);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 0806F1A0: void runtime.scang(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.markroot.func1
void runtime.scang(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 111) = 0x00;
	Eq_4 esp_16 = fp - 0x1C;
	Eq_4 eax_17 = dwArg04;
	Eq_4 ecx_19 = 0x00;
	Eq_4 edx_20 = 0x00;
	Eq_4 ebx_21 = 0x00;
	while (true)
	{
		word32 ebp_26 = (word32) *((word32) eax_17 + 111);
		if ((byte) ebp_26 != 0x00)
			break;
		*((word32) esp_16 + 20) = edx_20;
		*((word32) esp_16 + 16) = ebx_21;
		*((word32) esp_16 + 24) = ecx_19;
		*esp_16 = eax_17;
		runtime.readgstatus(*esp_16);
		esp_16.u0 = <invalid>;
		Eq_4 eax_51 = *((byte) esp_16.u0 + 4);
		if (eax_51 <= 0x04)
		{
			if (eax_51 == 0x01)
			{
l0806F34E:
				*esp_16.u0 = *((byte) esp_16.u0 + 32);
				*((byte) esp_16.u0 + 8) = eax_51 | 0x1000;
				runtime.castogscanstatus(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
				if ((byte) (word32) *((byte) esp_16.u0 + 0x0C) != 0x00)
				{
					Eq_4 eax_117 = *((byte) esp_16.u0 + 32);
					if ((byte) (word32) *((word32) eax_117 + 111) == 0x00)
					{
						*esp_16.u0 = eax_117;
						*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 36);
						runtime.scanstack(gs, *esp_16.u0, *((byte) esp_16.u0 + 4));
						eax_117 = *((byte) esp_16.u0 + 32);
						*((word32) eax_117 + 111) = 0x01;
					}
					*esp_16.u0 = eax_117;
					runtime.restartg(gs, *esp_16.u0);
					break;
				}
				goto l0806F244;
			}
			if (eax_51 == 0x02)
			{
				Eq_4 eax_155 = *((byte) esp_16.u0 + 32);
				if ((byte) (word32) *((word32) eax_155 + 110) == 0x00 || ((byte) ((word32) (*((word32) eax_155 + 0x006C))) == 0x00 || *((word32) eax_155 + 8) != ~0x0521))
				{
					*esp_16.u0 = eax_155;
					((byte) esp_16.u0 + 4)->u0 = 0x02;
					((byte) esp_16.u0 + 8)->u0 = 0x1002;
					runtime.castogscanstatus(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
					if ((byte) (word32) *((byte) esp_16.u0 + 0x0C) != 0x00)
					{
						Eq_4 eax_188 = *((byte) esp_16.u0 + 32);
						if ((byte) (word32) *((word32) eax_188 + 111) == 0x00)
						{
							*((word32) eax_188 + 110) = 0x01;
							((word32) eax_188 + 0x006C)->u0 = 0x01;
							((word32) eax_188 + 8)->u0 = ~0x0521;
						}
						*esp_16.u0 = eax_188;
						((byte) esp_16.u0 + 4)->u0 = 0x1002;
						((byte) esp_16.u0 + 8)->u0 = 0x02;
						runtime.casfrom_Gscanstatus(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
					}
				}
				goto l0806F244;
			}
			if (eax_51 <= 0x04)
				goto l0806F34E;
l0806F3DC:
			*esp_16.u0 = *((byte) esp_16.u0 + 32);
			runtime.dumpgstatus(gs, *esp_16.u0);
			esp_16.u0->u0 = 0x080E34B0;
			((byte) esp_16.u0 + 4)->u0 = 0x15;
			runtime.throw(gs);
		}
		if (eax_51 == 0x06)
		{
			*((word32) *((byte) esp_16.u0 + 32) + 111) = 0x01;
			break;
		}
		if (eax_51 != 0x08 && eax_51 != 0x1004)
			goto l0806F3DC;
l0806F244:
		Eq_4 ebx_235;
		Eq_4 edx_233;
		if (*((byte) esp_16.u0 + 24) != 0x00)
		{
			edx_233 = *((byte) esp_16.u0 + 20);
			ebx_235 = *((byte) esp_16.u0 + 16);
		}
		else
		{
			runtime.nanotime();
			Eq_4 eax_228 = *esp_16.u0;
			edx_233 = Mem215[esp_16 + 0x04:word32] + (eax_228 <u 10000);
			ebx_235 = (word32) eax_228 + 10000;
		}
		Eq_4 ecx_306;
		Eq_4 eax_305;
		*((byte) esp_16.u0 + 20) = edx_233;
		*((byte) esp_16.u0 + 16) = ebx_235;
		runtime.nanotime();
		Eq_4 eax_251 = *((byte) esp_16.u0 + 4);
		Eq_4 ecx_252 = *esp_16.u0;
		Eq_4 ebx_257 = *((byte) esp_16.u0 + 20);
		if ((byte) (SEQ(SLICE(eax_251, word24, 8), eax_251 < ebx_257) | SEQ(SLICE(ebp_26, word24, 8), eax_251 == ebx_257) & SEQ(SLICE(ecx_252, word24, 8), ecx_252 < *((byte) esp_16.u0 + 16))) != 0x00)
		{
			esp_16.u0->u0 = 0x0A;
			runtime.procyield(*esp_16.u0);
			eax_305 = *((byte) esp_16.u0 + 20);
			ecx_306 = *((byte) esp_16.u0 + 16);
		}
		else
		{
			runtime.osyield();
			runtime.nanotime();
			Eq_4 eax_297 = *esp_16.u0;
			eax_305 = Mem242[esp_16 + 0x04:word32] + (eax_297 <u 5000);
			ecx_306 = (word32) eax_297 + 5000;
		}
		edx_20 = eax_305;
		ebx_21 = ecx_306;
		eax_17 = *((byte) esp_16.u0 + 32);
		ecx_19 = (word32) *((byte) esp_16.u0 + 24) + 1;
	}
	*((word32) dwArg04 + 110) = 0x00;
}

// 0806F410: void runtime.restartg(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.scang
void runtime.restartg(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg04);
	if (dwLoc08 == 0x06)
		return;
	if (dwLoc08 != 0x1001 && dwLoc08 > ~0x1003)
	{
		runtime.dumpgstatus(gs, dwArg04);
		runtime.throw(gs);
	}
	else
		runtime.casfrom_Gscanstatus(gs, dwArg04, dwLoc08, dwLoc08 & ~0x1000);
}

// 0806F4A0: void runtime.stopTheWorld(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.GOMAXPROCS
void runtime.stopTheWorld(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.semacquire(gs);
	Eq_4 eax_29 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_29 + 116) = dwArg08;
	if (g_t81576F0 == 0x00)
		*((word32) eax_29 + 112) = dwArg04;
	else
		runtime.writebarrierptr((word32) eax_29 + 112, dwArg04);
	word32 ebp_82;
	word32 edi_83;
	runtime.systemstack(gs, 0x080E7CDC, out ebp_82, out edi_83);
}

// 0806F520: void runtime.startTheWorld(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.GOMAXPROCS
void runtime.startTheWorld(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_80;
	word32 edi_81;
	runtime.systemstack(gs, 135167188, out ebp_80, out edi_81);
	runtime.semrelease(gs);
	Eq_4 eax_42 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	((word32) eax_42 + 116)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) eax_42 + 112)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) eax_42 + 112, 0x00);
}

// 0806F5A0: void runtime.stopTheWorldWithSema(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.stopTheWorldWithSema(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (*((word32) *((word32) eax_18 + 24) + 0x0078) > 0x00)
		runtime.throw(gs);
	else
	{
		word32 edi_42;
		word32 ebp_435;
		Eq_4 esi_122;
		runtime.lock(esi, gs, 135549936, out ebp_435, out esi_122, out edi_42);
		g_t8145458 = g_t81575F0;
		runtime/internal/atomic.Store(0x08145454, 0x01);
		word32 * ebp_121 = runtime.preemptall(gs);
		((word32) *((word32) *((word32) eax_18 + 24) + 92) + 8)->u0 = 0x03;
		--g_t8145458;
		Eq_4 dwLoc28_345 = 0x08145454;
		Eq_4 eax_321 = 0x00;
		while (eax_321 < g_t81575F0)
		{
			if (eax_321 >= 0x0401)
				runtime.panicindex(gs);
			Eq_4 edx_256 = *((char *) g_a81478C0 + eax_321 * 0x04);
			Eq_4 ebx_257 = *((word32) edx_256 + 8);
			ebp_121 = (word32) edx_256 + 8;
			if (ebx_257 == 0x02)
			{
				runtime/internal/atomic.Cas((word32) edx_256 + 8, ebx_257, 0x03);
				dwLoc28_345 = (word32) edx_256 + 8;
				dwLoc20 = 0x03;
				if ((byte) (word32) bLoc1C != 0x00)
				{
					if ((byte) (word32) g_b814F4C8 != 0x00)
					{
						runtime.traceGoSysBlock(gs, edx_256, out ebp_121, out esi_122);
						runtime.traceProcStop(gs, edx_256);
						dwLoc28_345 = edx_256;
					}
					*((word32) edx_256 + 20) = (word32) *((word32) edx_256 + 20) + 1;
					--g_t8145458;
				}
			}
			eax_321 = (word32) eax_321 + 1;
		}
		while (true)
		{
			runtime.pidleget(gs);
			if (dwLoc28_345 == 0x00)
				break;
			((word32) dwLoc28_345 + 8)->u0 = 0x03;
			--g_t8145458;
		}
		Eq_4 eax_100 = g_t8145458;
		word32 edx_436;
		word32 ebx_105;
		runtime.unlock(gs, 135549936, out edx_436, out ebx_105);
		if (eax_100 > 0x00)
		{
			while (true)
			{
				dwLoc20 = 0x00;
				esi_122 = runtime.notetsleep(ebp_121, esi_122, gs, 135550044, (struct Eq_13398 *) 100000, 0x00);
				if ((byte) (word32) bLoc1C != 0x00)
					break;
				ebp_121 = runtime.preemptall(gs);
			}
			g_dw814545C = 0x00;
		}
		if (g_t8145458 == 0x00)
		{
			Eq_4 eax_161 = 0x00;
			while (eax_161 < g_t81575F0)
			{
				if (eax_161 >= 0x0401)
					runtime.panicindex(gs);
				*((char *) *((char *) g_a81478C0 + eax_161 * 0x04) + 8) == 0x03;
				eax_161 = (word32) eax_161 + 1;
			}
		}
		runtime/internal/atomic.Load();
		if (dwLoc20 != 0x00)
		{
			Eq_4 esi_204;
			word32 edi_438;
			word32 ebp_437;
			runtime.lock(esi_122, gs, 0x081575B0, out ebp_437, out esi_204, out edi_438);
			word32 ebp_215;
			word32 edi_216;
			word32 esi_217;
			runtime.lock(esi_204, gs, 0x081575B0, out ebp_215, out esi_217, out edi_216);
		}
		if (eax_100 == 0x00)
			return;
		runtime.throw(gs);
	}
}

// 0806F850: void runtime.mhelpgc(Register (ptr32 Eq_49638) gs)
void runtime.mhelpgc(struct Eq_49638 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	gs->ptr0000->ptrFFFFFFFC->ptr0018->dw0088 = ~0x00;
}

// 0806F890: void runtime.startTheWorldWithSema(Register (ptr32 Eq_2) gs)
void runtime.startTheWorldWithSema(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_21 = *((word32) eax_19 + 24);
	*((word32) ecx_21 + 0x0078) = (word32) *((word32) ecx_21 + 0x0078) + 1;
	Eq_4 esi_32 = runtime.netpoll(gs, 0x00);
	runtime.injectglist(gs, dwLoc14);
	word32 ebp_67;
	word32 esi_69;
	word32 edi_342;
	runtime.lock(runtime.needaddgcproc(esi_32, gs), gs, 135549936, out ebp_67, out esi_69, out edi_342);
	byte al_59 = (byte) (word32) (byte) dwLoc14;
	Eq_4 eax_74 = g_t81575F0;
	Eq_4 ecx_75 = g_t8157614;
	if (ecx_75 != 0x00)
		g_t8157614.u0 = 0x00;
	else
		ecx_75 = eax_74;
	runtime.procresize(ebp_67, esi_69, gs, ecx_75);
	g_dw8145454 = 0x00;
	if (g_dw8145460 != 0x00)
	{
		g_dw8145460 = 0x00;
		runtime.notewakeup(gs, 135550052);
	}
	word32 ebx_122;
	word32 edx_343;
	runtime.unlock(gs, 135549936, out edx_343, out ebx_122);
	Eq_4 eax_130 = dwLoc14;
	byte cl_132 = (byte) (word32) al_59;
	while (true)
	{
		word32 dwLoc10_281 = SEQ(cl_132, nLoc10);
		if (eax_130 == 0x00)
			break;
		word32 eax_217;
		Eq_4 edx_202 = *((word32) eax_130 + 48);
		Eq_4 ebx_203 = *((word32) eax_130 + 0x0C);
		if (edx_202 != 0x00)
		{
			((word32) eax_130 + 48)->u0 = 0x00;
			if (*((word32) edx_202 + 96) != 0x00)
				runtime.throw(gs);
			*((word32) edx_202 + 96) = eax_130;
			runtime.notewakeup(gs, (word32) edx_202 + 0x00AC);
			eax_217 = (word32) cl_132;
		}
		else
		{
			runtime.newm(gs, eax_130);
			eax_217 = 0x00;
		}
		cl_132 = (byte) eax_217;
		eax_130 = ebx_203;
	}
	runtime/internal/atomic.Load();
	if (dwLoc10_281 != 0x00)
	{
		runtime/internal/atomic.Load();
		if (dwLoc14 == 0x00)
			runtime.wakep(gs);
	}
	if ((byte) (word32) cl_132 != 0x00)
		runtime.newm(gs, 0x00);
	Eq_4 ecx_184 = *((word32) eax_19 + 24);
	--*((word32) ecx_184 + 0x0078);
	if (*((word32) *((word32) eax_19 + 24) + 0x0078) == 0x00 && (byte) ((word32) (*((word32) eax_19 + 0x006C))) != 0x00)
		((word32) eax_19 + 8)->u0 = ~0x0521;
}

// 0806FA80: void runtime.mstart(Register (ptr32 Eq_2) gs)
// Called from:
//      main
void runtime.mstart(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	if (*eax_8 == 0x00)
	{
		Eq_4 ecx_13 = *((word32) eax_8 + 4);
		Eq_4 dwLoc04_51 = ecx_13;
		if (ecx_13 == 0x00)
			dwLoc04_51.u0 = 0x2000;
		*((word32) eax_8 + 4) = fp - 0x04;
		*eax_8 = fp - 0x04 - dwLoc04_51 + 0x0400;
	}
	ptr32 ecx_30 = *eax_8;
	*((word32) eax_8 + 8) = ecx_30 + 880;
	*((word32) eax_8 + 0x0C) = ecx_30 + 880;
	runtime.mstart1(gs);
}

// 0806FAE0: void runtime.mstart1(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart
void runtime.mstart1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = **((word32) eax_18 + 24);
	if (eax_18 != ecx_20)
		runtime.throw(gs);
	else
	{
		runtime.gosave(gs, dwLoc10, (word32) ecx_20 + 28);
		((word32) **((word32) eax_18 + 24) + 32)->u0 = ~0x00;
		runtime.asminit();
		runtime.minit(gs);
		if (*((word32) eax_18 + 24) == 135550688)
		{
			if ((byte) (word32) g_b8157571 != 0x00 && (byte) ((word32) g_b8157567) == 0x00)
			{
				g_b8157567 = 0x01;
				runtime.newextram(gs);
			}
			runtime.initsig(gs, 0x00);
		}
		Eq_4 edx_104 = *((word32) *((word32) eax_18 + 24) + 80);
		if (edx_104 != 0x00)
			(*edx_104)();
		Eq_4 ecx_119 = *((word32) eax_18 + 24);
		if (*((word32) ecx_119 + 0x0088) == 0x00)
		{
			if (ecx_119 != 135550688)
			{
				runtime.acquirep(gs, *((word32) ecx_119 + 96));
				((word32) *((word32) eax_18 + 24) + 96)->u0 = 0x00;
			}
		}
		else
		{
			((word32) ecx_119 + 0x0088)->u0 = 0x00;
			runtime.stopm(gs);
		}
		runtime.schedule(gs);
	}
}

// 0806FC10: void runtime.forEachP(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkDone.func1
void runtime.forEachP(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	Eq_4 eax_20 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_21 = *((word32) eax_20 + 24);
	*((word32) ecx_21 + 0x0078) = (word32) *((word32) ecx_21 + 0x0078) + 1;
	Eq_4 eax_29 = *((word32) eax_20 + 24);
	Eq_4 ecx_31 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	word32 ebp_580;
	word32 edi_581;
	Eq_4 esi_157;
	runtime.lock(esi, gs, 135549936, out ebp_580, out esi_157, out edi_581);
	if (g_dw814546C != 0x00)
		runtime.throw(gs);
	else
	{
		g_dw814546C = g_t81575F0 - 0x01;
		if (g_t81576F0 == 0x00)
			g_t8145468 = dwArg04;
		else
			runtime.writebarrierptr(135550056, dwArg04);
		Eq_4 ecx_84 = g_t81575F0;
		if (ecx_84 > 0x0401)
			runtime.panicslice(gs);
		else
		{
			Eq_4 edx_434 = 0x00;
			word32 * ebx_409 = g_a81478C0;
			ecx_426 = ecx_84;
			while (true)
			{
				Eq_4 ecx_426;
				if (edx_434 >= ecx_426)
					break;
				Eq_4 ebp_410 = *ebx_409;
				if (ebp_410 != ecx_31)
				{
					runtime/internal/atomic.Store((word32) ebp_410 + 0x0968, 0x01);
					ecx_426 = ecx_84;
				}
				esi_157 = ecx_31;
				++ebx_409;
				edx_434 = (word32) edx_434 + 1;
			}
			word32 * ebp_102 = runtime.preemptall(gs);
			Eq_4 eax_109 = g_t814540C;
			while (eax_109 != 0x00)
			{
				runtime/internal/atomic.Cas((word32) eax_109 + 0x0968, 0x01, 0x00);
				if ((byte) (word32) bLoc24 != 0x00)
				{
					(*dwArg04)();
					--g_dw814546C;
				}
				eax_109 = *((word32) eax_109 + 0x0C);
			}
			int32 eax_115 = g_dw814546C;
			word32 ebx_583;
			word32 edx_582;
			runtime.unlock(gs, 135549936, out edx_582, out ebx_583);
			<anonymous> * eax_133 = *dwArg04;
			eax_133();
			Eq_4 eax_139 = 0x00;
			while (eax_139 < g_t81575F0)
			{
				if (eax_139 >= 0x0401)
					runtime.panicindex(gs);
				Eq_4 edx_298 = *((char *) g_a81478C0 + eax_139 * 0x04);
				Eq_4 ebx_299 = *((word32) edx_298 + 8);
				ebp_102 = (word32) edx_298 + 8;
				if (ebx_299 == 0x02)
				{
					esi_157 = *((word32) edx_298 + 0x0968);
					if (esi_157 == 0x01)
					{
						runtime/internal/atomic.Cas((word32) edx_298 + 8, ebx_299, 0x00);
						if ((byte) (word32) bLoc24 != 0x00)
						{
							if ((byte) (word32) g_b814F4C8 != 0x00)
							{
								runtime.traceGoSysBlock(gs, edx_298, out ebp_102, out esi_157);
								runtime.traceProcStop(gs, edx_298);
							}
							*((word32) edx_298 + 20) = (word32) *((word32) edx_298 + 20) + 1;
							runtime.handoffp(gs, edx_298, 0x00);
							Eq_4 esp_363 = <invalid>;
							eax_139 = *((word32) esp_363 + 16);
						}
					}
				}
				eax_139 = (word32) eax_139 + 1;
			}
			if (eax_115 > 0x00)
			{
				while (true)
				{
					esi_157 = runtime.notetsleep(ebp_102, esi_157, gs, 0x08145470, (struct Eq_13398 *) 100000, 0x00);
					if ((byte) (word32) bLoc24 != 0x00)
						break;
					ebp_102 = runtime.preemptall(gs);
				}
				g_dw8145470 = 0x00;
			}
			if (g_dw814546C != 0x00)
				runtime.throw(gs);
			else
			{
				Eq_4 eax_206 = 0x00;
				while (eax_206 < g_t81575F0)
				{
					if (eax_206 >= 0x0401)
						runtime.panicindex(gs);
					if (*((char *) *((char *) g_a81478C0 + eax_206 * 0x04) + 0x0968) != 0x00)
						runtime.throw(gs);
					eax_206 = (word32) eax_206 + 1;
				}
				word32 ebp_584;
				word32 edi_586;
				word32 esi_585;
				runtime.lock(esi_157, gs, 135549936, out ebp_584, out esi_585, out edi_586);
				if (g_t81576F0 == 0x00)
					g_t8145468.u0 = 0x00;
				else
					runtime.writebarrierptr(135550056, 0x00);
				word32 edx_587;
				word32 ebx_588;
				runtime.unlock(gs, 135549936, out edx_587, out ebx_588);
				Eq_4 eax_260 = gs->ptr0000->tFFFFFFFC;
				Eq_4 edx_262 = *((word32) eax_29 + 0x0078);
				*((word32) eax_29 + 0x0078) = edx_262 - 0x01;
				if (edx_262 == 0x01 && (byte) ((word32) (*((word32) eax_260 + 0x006C))) != 0x00)
					((word32) eax_260 + 8)->u0 = ~0x0521;
			}
		}
	}
}

// 0806FFE0: void runtime.runSafePointFn(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.findrunnable
//      runtime.schedule
void runtime.runSafePointFn(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	runtime/internal/atomic.Cas((word32) ecx_20 + 0x0968, 0x01, 0x00);
	if ((byte) (word32) bLoc08 == 0x00)
		return;
	Eq_4 edx_41 = g_t8145468;
	<anonymous> * eax_44 = *edx_41;
	eax_44();
	word32 ebp_112;
	word32 esi_113;
	word32 edi_114;
	runtime.lock(esi, gs, 135549936, out ebp_112, out esi_113, out edi_114);
	int32 eax_55 = g_dw814546C;
	g_dw814546C = eax_55 - 0x01;
	if (eax_55 == 0x01)
		runtime.notewakeup(gs, 0x08145470);
	word32 edx_115;
	word32 ebx_116;
	runtime.unlock(gs, 135549936, out edx_115, out ebx_116);
}

// 080700A0: void runtime.allocm(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.oneNewExtraM
//      runtime.newm
void runtime.allocm(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = *((word32) eax_18 + 24);
	*((word32) ecx_20 + 0x0078) = (word32) *((word32) ecx_20 + 0x0078) + 1;
	if (*((word32) *((word32) eax_18 + 24) + 92) == 0x00)
		runtime.acquirep(gs, dwArg04);
	Eq_4 dwLoc0C_192;
	runtime.newobject(gs, 0x080DFD60);
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwLoc0C + 80) = dwArg08;
		dwLoc0C_192 = dwLoc0C;
	}
	else
	{
		runtime.writebarrierptr((word32) dwLoc0C + 80, dwArg08);
		dwLoc0C_192 = dwArg08;
	}
	runtime.mcommoninit(gs, dwLoc0C);
	if ((byte) (word32) g_b8157571 != 0x00)
	{
		runtime.malg(gs, ~0x00);
		if (g_t81576F0 == 0x00)
			*dwLoc0C = dwLoc0C_192;
		else
			runtime.writebarrierptr(dwLoc0C, dwLoc0C_192);
	}
	else
	{
		runtime.malg(gs, 0x2000);
		if (g_t81576F0 == 0x00)
			*dwLoc0C = dwLoc0C_192;
		else
			runtime.writebarrierptr(dwLoc0C, dwLoc0C_192);
	}
	Eq_4 ecx_117 = *dwLoc0C;
	if (g_t81576F0 == 0x00)
		*((word32) ecx_117 + 24) = dwLoc0C;
	else
		runtime.writebarrierptr((word32) ecx_117 + 24, dwLoc0C);
	if (dwArg04 == *((word32) (*((word32) eax_18 + 24)) + 92))
		runtime.releasep(gs);
	Eq_4 edx_152 = *((word32) eax_18 + 24);
	--*((word32) edx_152 + 0x0078);
	if (*((word32) *((word32) eax_18 + 24) + 0x0078) == 0x00 && (byte) ((word32) (*((word32) eax_18 + 0x006C))) != 0x00)
		((word32) eax_18 + 8)->u0 = ~0x0521;
}

// 08070240: Register uint32 runtime.needm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigtrampgo
//      runtime.badsignal
//      runtime.cgocallback_gofunc
uint32 runtime.needm(struct Eq_2 * gs)
{
	struct Eq_50568 * dwLoc10_168 = dwLoc10;
	if ((byte) (word32) g_b8157571 != 0x00)
	{
		dwLoc10_168 = dwLoc10;
		if ((byte) (word32) g_b8157567 == 0x00)
		{
			dwLoc10_168 = g_ptr81426D0;
			if (g_dw81426D4 <= 0x00)
				runtime.panicindex(gs);
			word32 edx_172;
			word32 ebx_173;
			runtime.write(out edx_172, out ebx_173);
			runtime.exit();
		}
	}
	runtime.lockextra((byte) dwLoc10_168);
	dwLoc10_168->t01CC = dwLoc10_168->t00B4 == 0x00;
	--g_dw81575BC;
	runtime.unlockextra(dwLoc10_168->t00B4);
	runtime.msigsave();
	runtime.sigblock();
	runtime.setg(gs, dwLoc10_168->t0000);
	Eq_4 eax_95 = gs->ptr0000->tFFFFFFFC;
	*((word32) eax_95 + 4) = fp + 0x0404;
	*eax_95 = fp + ~0x7FFB;
	*((word32) eax_95 + 8) = fp + ~0x7C8B;
	runtime.asminit();
	runtime.minit(gs);
	runtime.casgstatus(dwLoc10_168->t0054, 0x06, 0x03);
	return runtime/internal/atomic.Xadd(0x08145408, ~0x00);
}

// 08070370: void runtime.newextram(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart1
void runtime.newextram(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xchg(0x081575C0, 0x00);
	if (dwLoc10 > 0x00)
	{
		up32 ecx_64;
		for (ecx_64 = 0x00; ecx_64 < dwLoc10; ++ecx_64)
			runtime.oneNewExtraM(gs);
	}
	else
	{
		runtime.lockextra(0x00);
		runtime.unlockextra(0x00);
		Eq_4 esp_42 = <invalid>;
		if (*((word32) esp_42 + 20) == 0x00)
			runtime.oneNewExtraM(gs);
	}
}

// 08070400: void runtime.oneNewExtraM(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.newextram
void runtime.oneNewExtraM(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.allocm(gs, 0x00, 0x00);
	runtime.malg(gs, 0x1000);
	*(word32 *) 0x20 = (word32) g_t80E7C14 + 1;
	*(union Eq_4 *) 0x1C = (word32) *(union Eq_4 *) 0x04 - 16;
	*(word32 *) 0x30 = 0x00;
	*(word32 *) 0x24 = 0x00;
	*(word32 *) 0x3C = *(word32 *) 0x20;
	*(union Eq_4 *) 0x38 = *(union Eq_4 *) 0x1C;
	*(union Eq_4 *) 0x40 = *(union Eq_4 *) 0x1C;
	*(byte *) 0x70 = 0x01;
	*(byte *) 111 = 0x01;
	Eq_4 esi_75 = runtime.casgstatus(0x00, 0x00, 0x06);
	if (g_t81576F0 == 0x00)
		*(union Eq_4 *) 0x18 = dwLoc20;
	else
		runtime.writebarrierptr(0x18, dwLoc20);
	if (g_t81576F0 == 0x00)
		((word32) dwLoc20 + 84)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) dwLoc20 + 84, 0x00);
	*((word32) dwLoc20 + 452) = 0x02;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwLoc20 + 188)->u0 = 0x00;
		*(union Eq_4 *) 0x88 = dwLoc20;
	}
	else
	{
		runtime.writebarrierptr((word32) dwLoc20 + 188, 0x00);
		runtime.writebarrierptr(0x88, dwLoc20);
	}
	word32 ebx_292;
	word32 ebp_293;
	runtime/internal/atomic.Xadd64(0x081453E0, 0x01, 0x00, out ebx_292, out ebp_293);
	*(word32 *) 0x50 = dwLoc1C;
	*(word32 *) 0x54 = dwLoc18;
	runtime.allgadd(esi_75, gs, 0x00);
	runtime/internal/atomic.Xadd(0x08145408, 0x01);
	runtime.lockextra(0x01);
	((word32) dwLoc20 + 0x00B4)->u0 = 0x01;
	++g_dw81575BC;
	runtime.unlockextra(dwLoc20);
}

// 08070610: void runtime.dropm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigtrampgo
//      runtime.badsignal
//      runtime.cgocallback_gofunc
void runtime.dropm(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_20 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	runtime.casgstatus(*((word32) eax_20 + 84), 0x03, 0x06);
	runtime/internal/atomic.Xadd(0x08145408, 0x01);
	runtime.sigblock();
	runtime.unminit(gs);
	runtime.lockextra(0x01);
	++g_dw81575BC;
	((word32) eax_20 + 0x00B4)->u0 = 0x01;
	runtime.setg(gs, 0x00);
	runtime.unlockextra(eax_20);
	runtime.msigrestore();
}

// 080706F0: void runtime.lockextra(Stack byte bArg08)
// Called from:
//      runtime.needm
//      runtime.newextram
//      runtime.oneNewExtraM
//      runtime.dropm
void runtime.lockextra(byte bArg08)
{
	byte al_8 = 0x00;
	while (true)
	{
		while (true)
		{
			while (true)
			{
				runtime/internal/atomic.Loaduintptr();
				if (dwLoc10 != 0x01)
					break;
				runtime.osyield();
				al_8 = (byte) (word32) al_8;
			}
			if (dwLoc10 != 0x00 || (byte) ((word32) bArg08) != 0x00)
				break;
			if ((byte) (word32) al_8 == 0x00)
			{
				runtime/internal/atomic.Xadd(0x081575C0, 0x01);
				dwLoc10.u0 = 0x01;
			}
			word32 edi_133;
			runtime.usleep(out edi_133);
			al_8 = 0x01;
		}
		runtime/internal/atomic.Casuintptr(135624132, dwLoc10, 0x01);
		if (true)
			break;
		runtime.osyield();
		al_8 = (byte) (word32) bLoc05;
	}
}

// 080707C0: void runtime.unlockextra(Stack Eq_4 dwArg04)
// Called from:
//      runtime.needm
//      runtime.newextram
//      runtime.oneNewExtraM
//      runtime.dropm
void runtime.unlockextra(Eq_4 dwArg04)
{
	runtime/internal/atomic.Storeuintptr(135624132, dwArg04);
}

// 080707F0: void runtime.newm(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.startTheWorldWithSema
//      runtime.startm
//      runtime.main.func1
void runtime.newm(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.allocm(gs, dwArg08, dwArg04);
	dwLoc1C->t0060 = dwArg08;
	Eq_4 edx_33 = g_t8157684;
	dwLoc1C->t0030 = g_t8157680;
	dwLoc1C->t0034 = edx_33;
	if ((byte) (word32) g_b8157571 == 0x00)
	{
		runtime.(*rwmutex).rlock(gs, 0x08157700);
		runtime.newosproc(gs, dwLoc1C);
		runtime.(*rwmutex).runlock(gs, 0x08157700);
	}
	else if (g_ptr8144F88 == null)
		runtime.throw(gs);
	else
	{
		runtime.(*rwmutex).rlock(gs, 0x08157700);
		word32 edi_169;
		runtime.asmcgocall(gs, g_ptr8144F88, fp - 0x0C, out edi_169);
		runtime.(*rwmutex).runlock(gs, 0x08157700);
	}
}

// 08070940: void runtime.stopm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart1
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.exitsyscall0
void runtime.stopm(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (*((word32) ecx_19 + 0x0078) != 0x00)
		runtime.throw(gs);
	else if (*((word32) ecx_19 + 92) != 0x00)
		runtime.throw(gs);
	else if ((byte) (word32) *((word32) ecx_19 + 0x008C) != 0x00)
		runtime.throw(gs);
	else
	{
		while (true)
		{
			word32 ebp_141;
			word32 esi_142;
			word32 edi_143;
			runtime.lock(esi, gs, 135549936, out ebp_141, out esi_142, out edi_143);
			runtime.mput(gs, *((word32) eax_18 + 24));
			word32 edx_144;
			word32 ebx_145;
			runtime.unlock(gs, 135549936, out edx_144, out ebx_145);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.notesleep(esi, gs, stackArg0, (word32) *((word32) eax_18 + 24) + 0x00AC);
			((word32) *((word32) eax_18 + 24) + 0x00AC)->u0 = 0x00;
			Eq_4 ecx_93 = *((word32) eax_18 + 24);
			if (*((word32) ecx_93 + 0x0088) == 0x00)
				break;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.gchelper(gs, stackArg0);
			((word32) *((word32) eax_18 + 24) + 0x0088)->u0 = 0x00;
			((word32) *((word32) eax_18 + 24) + 0x00B8)->u0 = 0x00;
			((word32) *((word32) eax_18 + 24) + 92)->u0 = 0x00;
		}
		runtime.acquirep(gs, *((word32) ecx_93 + 96));
		((word32) *((word32) eax_18 + 24) + 96)->u0 = 0x00;
	}
}

// 08070AA0: void runtime.mspinning(Register (ptr32 Eq_51166) gs)
void runtime.mspinning(struct Eq_51166 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	gs->ptr0000->ptrFFFFFFFC->ptr0018->b008C = 0x01;
}

// 08070AE0: void runtime.startm(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.handoffp
//      runtime.wakep
//      runtime.injectglist
void runtime.startm(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_278;
	word32 edi_279;
	word32 ebp_277;
	runtime.lock(esi, gs, 135549936, out ebp_277, out esi_278, out edi_279);
	Eq_4 eax_24 = dwArg04;
	if (dwArg04 == 0x00)
	{
		runtime.pidleget(gs);
		eax_24.u0 = 135549936;
		if (false)
		{
			word32 edx_283;
			word32 ebx_284;
			runtime.unlock(gs, 135549936, out edx_283, out ebx_284);
			if ((byte) (word32) bArg08 == 0x00)
				return;
			runtime/internal/atomic.Xadd(0x08145414, ~0x00);
			if (dwLoc10 >= 0x00)
				return;
			runtime.throw(gs);
		}
	}
	Eq_4 ecx_74 = g_t81453F4;
	if (ecx_74 != 0x00)
	{
		g_t81453F4 = *((word32) ecx_74 + 0x00B4);
		--g_t81453F8;
	}
	word32 edx_280;
	word32 ebx_281;
	runtime.unlock(gs, 135549936, out edx_280, out ebx_281);
	if (ecx_74 == 0x00)
		runtime.newm(gs, eax_24);
	else if ((byte) (word32) *((word32) ecx_74 + 0x008C) != 0x00)
		runtime.throw(gs);
	else if (*((word32) ecx_74 + 96) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 cl_144 = (byte) (word32) bArg08;
		if (cl_144 != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.runqempty(gs, stackArg0);
			if ((byte) (word32) bLoc14 == 0x00)
				runtime.throw(gs);
			cl_144 = (byte) (word32) bArg08;
		}
		*((word32) ecx_74 + 0x008C) = cl_144;
		*((word32) ecx_74 + 96) = eax_24;
		runtime.notewakeup(gs, (word32) ecx_74 + 0x00AC);
	}
}

// 08070CB0: void runtime.handoffp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.forEachP
//      runtime.stoplockedm
//      runtime.entersyscallblock_handoff
//      runtime.retake
void runtime.handoffp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	runtime.runqempty(gs, stackArg0);
	if ((byte) (word32) bLoc10 == 0x00 || g_t8145420 != 0x00)
		runtime.startm(gs, dwArg04, 0x00);
	else
	{
		if (g_dw81575DC != 0x00)
		{
			runtime.gcMarkWorkAvailable(gs, dwArg04);
			if ((byte) (word32) bLoc10 != 0x00)
			{
				runtime.startm(gs, dwArg04, 0x00);
				return;
			}
		}
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Load();
		byte bArg00_295 = (byte) dwLoc0C;
		if ((word32) dwArg04 + dwLoc08 == 0x00)
		{
			runtime/internal/atomic.Cas(0x08145414, 0x00, 0x01);
			dwLoc08 = 0x00;
			dwLoc04 = 0x01;
			if ((byte) (word32) bArg00_295 != 0x00)
			{
				runtime.startm(gs, dwArg0C, 0x01);
				return;
			}
		}
		word32 ebp_421;
		word32 edi_423;
		word32 esi_422;
		runtime.lock(esi, gs, 135549936, out ebp_421, out esi_422, out edi_423);
		if (g_dw8145454 == 0x00)
		{
			if (*((word32) dwArg0C + 0x0968) != 0x00)
			{
				runtime/internal/atomic.Cas((word32) dwArg0C + 0x0968, 0x01, 0x00);
				dwLoc08 = 0x01;
				dwLoc04 = 0x00;
				if ((byte) (word32) bArg00_295 != 0x00)
				{
					Eq_4 edx_127 = g_t8145468;
					(*edx_127)();
					int32 eax_135 = g_dw814546C;
					g_dw814546C = eax_135 - 0x01;
					if (eax_135 == 0x01)
						runtime.notewakeup(gs, 0x08145470);
				}
			}
			if (g_t8145420 != 0x00)
			{
				word32 edx_426;
				word32 ebx_427;
				runtime.unlock(gs, 135549936, out edx_426, out ebx_427);
				runtime.startm(gs, dwArg0C, 0x00);
			}
			else
			{
				if (g_t81575F0 - 0x01 == g_dw8145410)
				{
					word64 mm0_182;
					runtime/internal/atomic.Load64(135549928, out mm0_182);
					if ((byte) (SEQ(SLICE(dwLoc04, word24, 8), dwLoc04 != 0x00) | SEQ(SLICE(dwLoc08, word24, 8), dwLoc08 != 0x00)) != 0x00)
					{
						word32 ebx_431;
						word32 edx_430;
						runtime.unlock(gs, 135549936, out edx_430, out ebx_431);
						runtime.startm(gs, dwArg0C, 0x00);
						return;
					}
				}
				runtime.pidleput(gs, dwArg0C);
				word32 ebx_429;
				word32 edx_428;
				runtime.unlock(gs, 135549936, out edx_428, out ebx_429);
			}
		}
		else
		{
			((word32) dwArg0C + 8)->u0 = 0x03;
			Eq_4 eax_239 = g_t8145458;
			g_t8145458 = eax_239 - 0x01;
			if (eax_239 == 0x01)
				runtime.notewakeup(gs, 135550044);
			word32 edx_424;
			word32 ebx_425;
			runtime.unlock(gs, 135549936, out edx_424, out ebx_425);
		}
	}
}

// 08070F40: void runtime.wakep(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.ready
//      runtime.startTheWorldWithSema
//      runtime.resetspinning
//      runtime.newproc1
void runtime.wakep(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Cas(0x08145414, 0x00, 0x01);
	if ((byte) (word32) bLoc04 == 0x00)
		return;
	runtime.startm(gs, 0x00, 0x01);
}

// 08070FA0: void runtime.stoplockedm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedule
//      runtime.exitsyscall0
void runtime.stoplockedm(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	Eq_4 edx_20 = *((word32) ecx_19 + 188);
	if (edx_20 == 0x00 || *((word32) edx_20 + 0x0088) != ecx_19)
		runtime.throw(gs);
	else
	{
		if (*((word32) ecx_19 + 92) != 0x00)
		{
			runtime.releasep(gs);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg12 = <invalid>;
			runtime.handoffp(gs, stackArg4, stackArg12);
		}
		runtime.incidlelocked(gs, 0x01);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.notesleep(esi, gs, stackArg0, (word32) *((word32) eax_18 + 24) + 0x00AC);
		((word32) *((word32) eax_18 + 24) + 0x00AC)->u0 = 0x00;
		runtime.readgstatus(*((word32) *((word32) eax_18 + 24) + 188));
		if ((dwLoc08 & ~0x1000) != 0x01)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.dumpgstatus(gs, eax_18);
			runtime.throw(gs);
		}
		else
		{
			runtime.acquirep(gs, *((word32) *((word32) eax_18 + 24) + 96));
			((word32) *((word32) eax_18 + 24) + 96)->u0 = 0x00;
		}
	}
}

// 080710F0: void runtime.startlockedm(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.schedule
void runtime.startlockedm(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) dwArg04 + 0x0088);
	if (ecx_20 == *((word32) (gs->ptr0000)->tFFFFFFFC + 24))
		runtime.throw(gs);
	else if (*((word32) ecx_20 + 96) != 0x00)
		runtime.throw(gs);
	else
	{
		runtime.incidlelocked(gs, ~0x00);
		runtime.releasep(gs);
		((word32) ecx_20 + 96)->u0 = ~0x00;
		runtime.notewakeup(gs, (word32) ecx_20 + 0x00AC);
		runtime.stopm(gs);
	}
}

// 080711B0: void runtime.gcstopm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.findrunnable
//      runtime.schedule
void runtime.gcstopm(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = gs->ptr0000->tFFFFFFFC;
	if (g_dw8145454 == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_28 = *((word32) eax_17 + 24);
		if ((byte) (word32) *((word32) eax_28 + 0x008C) != 0x00)
		{
			((word32) eax_28 + 0x008C)->u0 = 0x00;
			runtime/internal/atomic.Xadd(0x08145414, ~0x00);
			dwLoc10 = (struct Eq_51746 *) &g_dw8145414;
			if (dwLoc08 < 0x00)
				runtime.throw(gs);
		}
		runtime.releasep(gs);
		word32 ebp_122;
		word32 esi_123;
		word32 edi_124;
		runtime.lock(esi, gs, 135549936, out ebp_122, out esi_123, out edi_124);
		dwLoc10->dw0008 = 0x03;
		Eq_4 eax_70 = g_t8145458;
		g_t8145458 = eax_70 - 0x01;
		if (eax_70 == 0x01)
			runtime.notewakeup(gs, 135550044);
		word32 edx_125;
		word32 ebx_126;
		runtime.unlock(gs, 135549936, out edx_125, out ebx_126);
		runtime.stopm(gs);
	}
}

// 080712C0: void runtime.execute(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.schedule
//      runtime.park_m
//      runtime.exitsyscall0
void runtime.execute(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.casgstatus(dwArg04, 0x01, 0x02);
	((word32) dwArg04 + 88)->u0 = 0x00;
	((word32) dwArg04 + 92)->u0 = 0x00;
	((word32) dwArg04 + 0x006C)->u0 = 0x00;
	*((word32) dwArg04 + 8) = (word32) *dwArg04 + 880;
	if ((byte) (word32) bArg08 == 0x00)
	{
		Eq_4 ebx_43 = *((word32) *((word32) eax_19 + 24) + 92);
		*((word32) ebx_43 + 16) = (word32) *((word32) ebx_43 + 16) + 1;
	}
	Eq_4 edx_55 = *((word32) eax_19 + 24);
	if (g_t81576F0 == 0x00)
		*((word32) edx_55 + 84) = dwArg04;
	else
		runtime.writebarrierptr((word32) edx_55 + 84, dwArg04);
	Eq_4 ebp_81 = *((word32) eax_19 + 24);
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 24) = ebp_81;
	else
		runtime.writebarrierptr((word32) dwArg04 + 24, ebp_81);
	Eq_4 edx_99 = g_t8145474;
	if (*((word32) *((word32) eax_19 + 24) + 0x0084) != edx_99)
		runtime.setThreadCPUProfiler(gs, edx_99);
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		if (*((word32) dwArg04 + 56) != 0x00 && (byte) ((word32) (*((word32) dwArg04 + 115))) != 0x00)
		{
			Eq_4 edx_129 = *((word32) dwArg04 + 116);
			runtime.traceGoSysExit(SLICE(edx_129, word24, 8), ebp, gs, edx_129, *((word32) dwArg04 + 0x0078));
		}
		runtime.traceGoStart(gs);
	}
	runtime.gogo(gs, (word32) dwArg04 + 28);
}

// 08071420: void runtime.findrunnable(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.schedule
void runtime.findrunnable(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	eax_21 = eax_19;
l08071766:
	while (true)
	{
		Eq_4 eax_21;
		Eq_4 ecx_25 = *((word32) *((word32) eax_21 + 24) + 92);
		if (g_dw8145454 == 0x00)
			break;
		runtime.gcstopm(gs);
		eax_21 = eax_19;
	}
	if (*((word32) ecx_25 + 0x0968) != 0x00)
		runtime.runSafePointFn(gs);
	if ((byte) (word32) g_b815756A != 0x00 && (byte) ((word32) g_b815756B) != 0x00)
	{
		runtime.wakefing(gs);
		if (dwLoc58 != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.ready(gs, stackArg4);
			dwLoc54.u0 = 0x00;
			bLoc50.u0 = 0x01;
		}
	}
	<anonymous> * edx_75 = *g_ptr81422A4;
	if (edx_75 != null)
	{
		word32 edi_1659;
		runtime.asmcgocall(gs, edx_75, 0x00, out edi_1659);
		dwLoc54.u0 = 0x00;
	}
	runtime.runqget(gs, ecx_25);
	byte bLoc58_1183 = (byte) ecx_25;
	word32 dwLoc50_1178 = SEQ(nLoc4F, bLoc50);
	if (dwLoc54 != 0x00)
		return;
	if (g_t8145420 != 0x00)
	{
		word32 ebp_1660;
		word32 edi_1662;
		word32 esi_1661;
		runtime.lock(esi, gs, 135549936, out ebp_1660, out esi_1661, out edi_1662);
		runtime.globrunqget(gs, 0x00);
		word32 ebx_1664;
		word32 edx_1663;
		runtime.unlock(gs, 135549936, out edx_1663, out ebx_1664);
		dwLoc54.u0 = 0x00;
		bLoc58_1183 = 0xF0;
		if (dwLoc50_1178 != 0x00)
			return;
	}
	runtime.netpollinited(gs);
	if ((byte) (word32) bLoc58_1183 != 0x00)
	{
		Eq_4 eax_154 = g_t81453E8;
		word32 ecx_155 = g_dw81453EC;
		if ((byte) (SEQ(SLICE(ecx_155, word24, 8), ecx_155 != 0x00) | SEQ(SLICE(eax_154, word24, 8), eax_154 != 0x00)) != 0x00)
		{
			runtime.netpoll(gs, 0x00);
			if (dwLoc54 != 0x00)
			{
				runtime.injectglist(gs, *((byte) dwLoc54.u0 + 0x0068));
				runtime.casgstatus(dwLoc54, 0x04, 0x01);
				if ((byte) (word32) g_b814F4C8 != 0x00)
					runtime.traceGoUnpark(gs, dwLoc54);
				return;
			}
		}
	}
	Eq_4 eax_228;
	runtime/internal/atomic.Load();
	Eq_4 dwLoc58_1199 = 0x08145410;
	if (dwLoc30 - 0x01 == dwLoc50_1178)
	{
		eax_228 = dwArg00;
		goto l08071680;
	}
	Eq_4 edx_229 = ecx_25;
	if ((byte) (word32) *((word32) *((word32) ecx_25 + 24) + 0x008C) == 0x00)
	{
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Load();
		dwLoc54.u0 = 0x08145414;
		bLoc50.u0 = 0x10;
		nLoc4F = 529492;
		if (dwLoc30 << 0x01 >= dwLoc28 - dwLoc48)
		{
			eax_228 = dwArg08;
			goto l08071680;
		}
		edx_229 = dwArg04;
	}
	Eq_4 ecx_258 = *((word32) edx_229 + 24);
	if ((byte) (word32) *((word32) ecx_258 + 0x008C) == 0x00)
	{
		((word32) ecx_258 + 0x008C)->u0 = 0x01;
		runtime/internal/atomic.Xadd(0x08145414, 0x01);
		dwLoc58_1199.u0 = 0x08145414;
		dwLoc54.u0 = 0x01;
	}
	int32 eax_277;
	Eq_4 dwLoc58_1389 = dwLoc58_1199;
	for (eax_277 = 0x00; eax_277 < 0x04; ++eax_277)
	{
		Eq_4 ecx_800 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		Eq_4 ebx_801 = *((word32) ecx_800 + 0x0094);
		Eq_4 ebp_806 = ebx_801 << 0x01 ^ ebx_801 >> 0x1F & 0xA8888EEF;
		*((word32) ecx_800 + 0x0094) = ebp_806;
		ui32 ecx_808 = g_dw81451B0;
		word32 ebx_809[] = g_ptr81451B4;
		esi = g_t81451B8;
		if (ecx_808 == 0x00)
			runtime.panicdivide(gs);
		uint32 edx_824 = (uint32) ((uint64) (uint32) ebp_806 % ecx_808);
		if (esi == 0x00)
			runtime.panicdivide(gs);
		word32 edx_842 = ebx_809[(uint32) ((uint64) (uint32) ebp_806 % esi)];
		dwLoc30 = 0x00;
		dwLoc28 = edx_824;
		while (true)
		{
			dwLoc58 = dwLoc58_1389;
			if (dwLoc30 == ecx_808)
				break;
			if (g_dw8145454 != 0x00)
			{
				eax_21 = eax_19;
				goto l08071766;
			}
			if (dwLoc28 >= 0x0401)
				runtime.panicindex(gs);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_52029 dl_876 = eax_277 > 0x02;
			dwLoc54 = *((char *) g_a81478C0 + dwLoc28 * 0x04);
			Eq_4 stackArg0 = <invalid>;
			runtime.runqsteal(gs, stackArg0, ecx_25, dl_876);
			dwLoc58_1389 = ecx_25;
			bLoc50 = dl_876;
			if (dwLoc4C != 0x00)
				return;
			++dwLoc30;
			uint32 eax_895 = dwLoc28 + edx_842;
			if (ecx_808 == 0x00)
				runtime.panicdivide(gs);
			dwLoc28 = (uint32) ((uint64) (uint32) eax_895 % ecx_808);
		}
	}
	eax_228 = ecx_25;
	dwLoc58_1199 = dwLoc58_1389;
l08071680:
	while (true)
	{
		word24 nLoc48_1643 = (word24) dwLoc48;
		byte bLoc58_1266 = (byte) dwLoc58_1199;
		struct Eq_52157 * esp_287 = fp - 92;
		if (g_dw81575DC != 0x00 && *((word32) eax_228 + 0x0948) != 0x00)
		{
			runtime.gcMarkWorkAvailable(gs, eax_228);
			if ((byte) (word32) bLoc58_1266 != 0x00)
			{
				((word32) eax_228 + 0x094C)->u0 = 0x02;
				Eq_4 eax_310 = *((word32) eax_228 + 0x0948);
				runtime.casgstatus(eax_310, 0x04, 0x01);
				if ((byte) (word32) g_b814F4C8 != 0x00)
					runtime.traceGoUnpark(gs, eax_310);
				return;
			}
		}
		word32 ebp_1665;
		word32 edi_1667;
		word32 esi_1666;
		runtime.lock(esi, gs, 135549936, out ebp_1665, out esi_1666, out edi_1667);
		dwLoc58 = dwLoc58_1199;
		if (g_dw8145454 != 0x00 || *((word32) eax_228 + 0x0968) != 0x00)
			break;
		if (g_t8145420 != 0x00)
		{
			runtime.globrunqget(gs, 0x00);
			word32 ebx_1671;
			word32 edx_1670;
			runtime.unlock(gs, 135549936, out edx_1670, out ebx_1671);
			return;
		}
		runtime.releasep(gs);
		if (eax_228 != 135549936)
			runtime.throw(gs);
		runtime.pidleput(gs, eax_228);
		word32 ebx_1673;
		word32 edx_1672;
		runtime.unlock(gs, 135549936, out edx_1672, out ebx_1673);
		Eq_4 ecx_414 = *((word32) dwLoc0C + 24);
		byte bLoc5C_1316 = 0xF0;
		byte dl_416 = (byte) (word32) *((word32) ecx_414 + 0x008C);
		if (dl_416 != 0x00)
		{
			((word32) ecx_414 + 0x008C)->u0 = 0x00;
			runtime/internal/atomic.Xadd(0x08145414, ~0x00);
			bLoc5C_1316 = 0x14;
			dwLoc58_1199.u0 = ~0x00;
			if (dwLoc54 < 0x00)
				runtime.throw(gs);
		}
		byte bLoc58_1628 = (byte) dwLoc58_1199;
		Eq_4 ecx_445 = 0x00;
		while (true)
		{
			dwLoc48 = SEQ(dl_416, nLoc48_1643);
			if (ecx_445 >= g_t81575F0)
				break;
			if (ecx_445 >= 0x0401)
				runtime.panicindex(gs);
			word32 ebp_462 = *((char *) g_a81478C0 + ecx_445 * 0x04);
			if (ebp_462 != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.runqempty(gs, stackArg0);
				bLoc5C_1316 = (byte) ebp_462;
				if ((byte) (word32) bLoc58_1628 == 0x00)
				{
					word32 ebp_1676;
					word32 edi_1678;
					word32 esi_1677;
					runtime.lock(esi, gs, 135549936, out ebp_1676, out esi_1677, out edi_1678);
					runtime.pidleget(gs);
					word32 edx_1679;
					word32 ebx_1680;
					runtime.unlock(gs, 135549936, out edx_1679, out ebx_1680);
					bLoc5C_1316 = 0xF0;
					if (false)
						break;
					runtime.acquirep(gs, 135549936);
					dwLoc58 = dwLoc58_1427;
					if ((byte) (word32) dl_416 != 0x00)
					{
						((word32) *((word32) dwLoc0C + 24) + 0x008C)->u0 = 0x01;
						runtime/internal/atomic.Xadd(0x08145414, 0x01);
						dwLoc58.u0 = 0x01;
					}
					eax_21 = dwLoc0C;
					goto l08071766;
				}
			}
			ecx_445 = (word32) ecx_445 + 1;
		}
		dwLoc58_1427 = dwLoc58_1199;
		if (g_dw81575DC == 0x00)
		{
l0807174C:
			runtime.netpollinited(gs);
			dwLoc58 = dwLoc58_1427;
			if ((byte) (word32) bLoc5C_1316 != 0x00)
			{
				runtime/internal/atomic.Load();
				esp_287 = fp - 88;
				dwLoc58 = dwLoc58_1427;
				if (dwLoc54 > 0x00)
				{
					runtime/internal/atomic.Xchg64(135549928, 0x00);
					dwLoc58.u0 = 135549928;
					dwLoc54.u0 = 0x00;
					bLoc50.u0 = 0x00;
					nLoc4F = 0x00;
					if ((byte) (SEQ(SLICE(dwLoc48, word24, 8), dwLoc48 != 0x00) | SEQ(SLICE(dwLoc4C, word24, 8), dwLoc4C != 0x00)) != 0x00)
					{
						Eq_4 ecx_633 = *((word32) eax_19 + 24);
						if (*((word32) ecx_633 + 92) != 0x00)
							runtime.throw(gs);
						if ((byte) (word32) *((word32) ecx_633 + 0x008C) != 0x00)
							runtime.throw(gs);
						runtime.netpoll(gs, 0x01);
						runtime.nanotime();
						runtime/internal/atomic.Store64(0x08157610, 135549928, 0x53000001);
						dwLoc58.u0 = 135549928;
						dwLoc54.u0 = 0x53000001;
						bLoc50.u0 = 0x00;
						nLoc4F = 0x00;
						if (0x00 != 0x00)
						{
							word32 ebp_1687;
							word32 esi_1688;
							word32 edi_1689;
							runtime.lock(esi, gs, 135549936, out ebp_1687, out esi_1688, out edi_1689);
							runtime.pidleget(gs);
							word32 edx_1690;
							word32 ebx_1691;
							runtime.unlock(gs, 135549936, out edx_1690, out ebx_1691);
							if (true)
							{
								runtime.acquirep(gs, 135549936);
								runtime.injectglist(gs, *(union Eq_4 *) 0x68);
								runtime.casgstatus(0x00, 0x04, 0x01);
								if ((byte) (word32) g_b814F4C8 != 0x00)
									runtime.traceGoUnpark(gs, 0x00);
								return;
							}
							runtime.injectglist(gs, 0x00);
							dwLoc58.u0 = 0x00;
						}
					}
				}
			}
			runtime.stopm(gs);
			eax_21 = esp_287->t0050;
			goto l08071766;
		}
		runtime.gcMarkWorkAvailable(gs, 0x00);
		bLoc5C_1316 = 0x00;
		if ((byte) (word32) bLoc58_1628 == 0x00)
			goto l0807174C;
		word32 esi_1682;
		word32 edi_1683;
		word32 ebp_1681;
		runtime.lock(esi, gs, 135549936, out ebp_1681, out esi_1682, out edi_1683);
		runtime.pidleget(gs);
		Eq_4 eax_552 = 135549936;
		if (135549936 != 0x00 && g_dw8145D38 == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.pidleput(gs, stackArg4);
			eax_552.u0 = 0x00;
		}
		word32 ebx_1685;
		word32 edx_1684;
		runtime.unlock(gs, 135549936, out edx_1684, out ebx_1685);
		bLoc5C_1316 = 0xF0;
		if (eax_552 == 0x00)
			goto l0807174C;
		runtime.acquirep(gs, eax_552);
		if ((byte) (word32) dl_416 != 0x00)
		{
			((word32) *((word32) dwLoc0C + 24) + 0x008C)->u0 = 0x01;
			runtime/internal/atomic.Xadd(0x08145414, 0x01);
			dwLoc58_1199.u0 = 0x01;
		}
		eax_228 = eax_552;
	}
	word32 edx_1668;
	word32 ebx_1669;
	runtime.unlock(gs, 135549936, out edx_1668, out ebx_1669);
	eax_21 = dwLoc0C;
	goto l08071766;
}

// 08071D50: void runtime.pollWork(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.gcDrain
void runtime.pollWork(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t8145420 != 0x00)
		return;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 bLoc08_99 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	Eq_4 stackArg0 = <invalid>;
	runtime.runqempty(gs, stackArg0);
	if ((byte) (word32) bLoc04 == 0x00)
		return;
	runtime.netpollinited(gs);
	if ((byte) (word32) bLoc08_99 == 0x00)
		return;
	runtime/internal/atomic.Load();
	if (dwArg00 <= 0x00)
		return;
	Eq_4 eax_56 = g_t81453E8;
	word32 ecx_57 = g_dw81453EC;
	if ((byte) (SEQ(SLICE(ecx_57, word24, 8), ecx_57 != 0x00) | SEQ(SLICE(eax_56, word24, 8), eax_56 != 0x00)) == 0x00)
		return;
	runtime.netpoll(gs, 0x00);
	if (dwArg00 == 0x00)
		return;
	runtime.injectglist(gs, dwArg00);
}

// 08071E30: void runtime.resetspinning(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedule
void runtime.resetspinning(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	if ((byte) (word32) *((word32) eax_18 + 0x008C) == 0x00)
		runtime.throw(gs);
	else
	{
		((word32) eax_18 + 0x008C)->u0 = 0x00;
		runtime/internal/atomic.Xadd(0x08145414, ~0x00);
		if (dwLoc04 < 0x00)
			runtime.throw(gs);
		else if (dwLoc04 == 0x00)
		{
			runtime/internal/atomic.Load();
			if (dwLoc04 > 0x00)
				runtime.wakep(gs);
		}
	}
}

// 08071EF0: void runtime.injectglist(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkTermination
//      runtime.gcWakeAllAssists
//      runtime.startTheWorldWithSema
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.sysmon
void runtime.injectglist(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = dwArg04;
	if (dwArg04 == 0x00)
		return;
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		while (eax_17 != 0x00)
		{
			runtime.traceGoUnpark(gs, eax_17);
			eax_17 = *((word32) eax_17 + 0x0068);
		}
	}
	word32 edi_202;
	word32 esi_201;
	word32 ebp_200;
	runtime.lock(esi, gs, 135549936, out ebp_200, out esi_201, out edi_202);
	Eq_4 eax_142 = dwArg04;
	word32 ecx_141 = 0x00;
	while (eax_142 != 0x00)
	{
		Eq_4 ecx_97 = *((word32) eax_142 + 0x0068);
		runtime.casgstatus(eax_142, 0x04, 0x01);
		((word32) eax_142 + 0x0068)->u0 = 0x00;
		Eq_4 ecx_108 = g_t814541C;
		if (ecx_108 != 0x00)
			*((word32) ecx_108 + 0x0068) = eax_142;
		else
			g_t8145418 = eax_142;
		g_t814541C = eax_142;
		g_t8145420 = (word32) g_t8145420 + 1;
		++ecx_141;
		eax_142 = ecx_97;
	}
	word32 edx_69;
	word32 ebx_203;
	runtime.unlock(gs, 135549936, out edx_69, out ebx_203);
	word32 eax_71 = ecx_141;
	while (eax_71 != 0x00 && g_dw8145410 != 0x00)
	{
		runtime.startm(gs, 0x00, 0x00);
		--eax_71;
	}
}

// 08072040: void runtime.schedule(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart1
//      runtime.park_m
//      runtime.goschedImpl
//      runtime.goexit0
//      runtime.exitsyscall0
void runtime.schedule(struct Eq_2 * gs)
{
	word24 nLoc17_397 = SLICE(dwLoc18, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_19 = *((word32) ecx_18 + 24);
	if (*((word32) edx_19 + 0x0078) != 0x00)
		runtime.throw(gs);
	else
	{
		if (*((word32) edx_19 + 188) != 0x00)
		{
			runtime.stoplockedm(gs);
			Eq_4 ecx_42 = *((word32) *((word32) ecx_18 + 24) + 188);
			runtime.execute(gs, ecx_42, 0x00);
			dwLoc1C = ecx_42;
			dwLoc18 = SEQ(nLoc17_397, 0x00);
		}
		while (true)
		{
			while (g_dw8145454 != 0x00)
				runtime.gcstopm(gs);
			if (*((word32) *((word32) *((word32) ecx_18 + 24) + 92) + 0x0968) != 0x00)
				runtime.runSafePointFn(gs);
			Eq_4 eax_100;
			if ((byte) (word32) g_b814F4C8 != 0x00 || (byte) ((word32) g_b814F4C9) != 0x00)
			{
				runtime.traceReader(gs);
				eax_100 = dwLoc1C;
				if (dwLoc1C != 0x00)
				{
					runtime.casgstatus(dwLoc1C, 0x04, 0x01);
					runtime.traceGoUnpark(gs, dwLoc1C);
					dwLoc14.u0 = 0x01;
					dwLoc18.u0 = 0x00;
					eax_100 = dwLoc1C;
				}
			}
			else
				eax_100.u0 = 0x00;
			Eq_4 dwLoc1C_331 = dwLoc1C;
			byte bLoc14_359 = (byte) dwLoc14;
			if (eax_100 == 0x00 && g_dw81575DC != 0x00)
			{
				Eq_4 ecx_131 = *((word32) *((word32) ecx_18 + 24) + 92);
				runtime.(*gcControllerState).findRunnableGCWorker(esi, edi, gs, &g_dw8157860, ecx_131);
				dwLoc1C_331.u0 = 0x08157860;
				dwLoc18 = ecx_131;
				eax_100 = dwLoc14;
			}
			if (eax_100 == 0x00)
			{
				Eq_4 edx_152 = *((word32) *((word32) *((word32) ecx_18 + 24) + 92) + 16);
				Eq_4 ebx_155 = eax_100;
				if (edx_152 - (SLICE(edx_152 * 2253097598, word32, 32) >> 0x05) *s 0x3D == 0x00 && g_t8145420 > 0x00)
				{
					word32 ebp_425;
					word32 esi_426;
					word32 edi_427;
					runtime.lock(esi, gs, 135549936, out ebp_425, out esi_426, out edi_427);
					runtime.globrunqget(gs, 0x01);
					word32 ebx_429;
					word32 edx_428;
					runtime.unlock(gs, 135549936, out edx_428, out ebx_429);
					dwLoc18.u0 = 0x01;
					dwLoc1C_331.u0 = 135549936;
					ebx_155 = dwLoc14;
				}
				eax_100 = ebx_155;
			}
			byte cl_260;
			byte bLoc18_371 = (byte) dwLoc18;
			if (eax_100 != 0x00)
				cl_260 = 0x00;
			else
			{
				Eq_4 ecx_207 = *((word32) *((word32) ecx_18 + 24) + 92);
				runtime.runqget(gs, ecx_207);
				dwLoc1C_331 = ecx_207;
				eax_100 = dwLoc18;
				cl_260 = (byte) (word32) bLoc14_359;
				if (dwLoc18 != 0x00 && (byte) ((word32) (*((word32) (*((word32) ecx_18 + 24)) + 0x008C))) != 0x00)
					runtime.throw(gs);
			}
			if (eax_100 == 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.findrunnable(gs, stackArg0, dwLoc1C_331, dwLoc18);
				eax_100 = dwLoc1C_331;
				cl_260 = (byte) (word32) bLoc18_371;
			}
			if ((byte) (word32) *((word32) *((word32) ecx_18 + 24) + 0x008C) != 0x00)
			{
				runtime.resetspinning(gs);
				cl_260 = (byte) (word32) cl_260;
			}
			if (*((word32) eax_100 + 0x0088) == 0x00)
			{
				runtime.execute(gs, eax_100, cl_260);
				return;
			}
			runtime.startlockedm(gs, eax_100);
			dwLoc1C = eax_100;
		}
	}
}

// 08072310: void runtime.parkunlock_c(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void runtime.parkunlock_c(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_42;
	word32 ebx_43;
	runtime.unlock(gs, dwArg08, out edx_42, out ebx_43);
}

// 08072350: void runtime.park_m(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.park_m(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		Eq_4 ecx_25 = *((word32) eax_18 + 24);
		runtime.traceGoPark(gs, (byte) (word32) *((word32) ecx_25 + 472), *((word32) ecx_25 + 476));
	}
	runtime.casgstatus(dwArg04, 0x02, 0x04);
	Eq_4 eax_63 = gs->ptr0000->tFFFFFFFC;
	((word32) *((word32) *((word32) eax_63 + 24) + 84) + 24)->u0 = 0x00;
	((word32) *((word32) eax_63 + 24) + 84)->u0 = 0x00;
	Eq_4 ecx_80 = *((word32) eax_18 + 24);
	if (*((word32) ecx_80 + 464) != 0x00)
	{
		Eq_4 edx_89 = *((word32) ecx_80 + 464);
		(*edx_89)();
		Eq_4 ecx_100 = *((word32) eax_18 + 24);
		if (g_t81576F0 == 0x00)
			((word32) ecx_100 + 464)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) ecx_100 + 464, 0x00);
		Eq_4 eax_126 = *((word32) eax_18 + 24);
		if (g_t81576F0 == 0x00)
			((word32) eax_126 + 468)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) eax_126 + 468, 0x00);
		if (false)
		{
			if ((byte) (word32) g_b814F4C8 != 0x00)
				runtime.traceGoUnpark(gs, dwArg04);
			runtime.casgstatus(dwArg04, 0x04, 0x01);
			runtime.execute(gs, dwArg04, 0x01);
		}
	}
	runtime.schedule(gs);
}

// 08072520: void runtime.goschedImpl(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gosched_m
//      runtime.gopreempt_m
void runtime.goschedImpl(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg04);
	if ((dwLoc08 & ~0x1000) != 0x02)
	{
		runtime.dumpgstatus(gs, dwArg04);
		runtime.throw(gs);
	}
	else
	{
		runtime.casgstatus(dwArg04, dwArg04, 0x01);
		Eq_4 eax_52 = gs->ptr0000->tFFFFFFFC;
		((word32) *((word32) *((word32) eax_52 + 24) + 84) + 24)->u0 = 0x00;
		((word32) *((word32) eax_52 + 24) + 84)->u0 = 0x00;
		word32 ebp_144;
		word32 esi_145;
		word32 edi_146;
		runtime.lock(esi, gs, 135549936, out ebp_144, out esi_145, out edi_146);
		((word32) dwArg04 + 0x0068)->u0 = 0x00;
		Eq_4 ecx_78 = g_t814541C;
		if (ecx_78 != 0x00)
			*((word32) ecx_78 + 0x0068) = dwArg04;
		else
			g_t8145418 = dwArg04;
		g_t814541C = dwArg04;
		g_t8145420 = (word32) g_t8145420 + 1;
		word32 edx_147;
		word32 ebx_148;
		runtime.unlock(gs, 135549936, out edx_147, out ebx_148);
		runtime.schedule(gs);
	}
}

// 08072640: void runtime.gosched_m(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.gosched_m(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGoSched(gs);
	runtime.goschedImpl(gs, dwArg04);
}

// 08072680: void runtime.gopreempt_m(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.newstack
void runtime.gopreempt_m(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGoPreempt(gs);
	runtime.goschedImpl(gs, dwArg04);
}

// 080726C0: void runtime.goexit1(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.goexit
void runtime.goexit1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGoEnd(gs);
	word32 esi_66;
	runtime.mcall(gs, dwLoc08, &g_dw80E7C10, out esi_66);
}

// 08072700: void runtime.goexit0(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.goexit0(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_53449 cl_62;
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.casgstatus(dwArg04, 0x02, 0x06);
	Eq_4 ecx_38 = *((word32) dwArg04 + 0x00AC);
	if (g_t8157634 == ecx_38 && (byte) ((word32) g_b8157569) == 0x00)
		cl_62.u0 = 0x01;
	else if (g_t8157598 == ecx_38)
		cl_62.u0 = 0x01;
	else if (g_t81575D0 == ecx_38)
		cl_62.u0 = 0x01;
	else if (g_t8157650 == ecx_38)
		cl_62.u0 = 0x01;
	else
		cl_62 = g_t81575D8 == ecx_38;
	if (cl_62 != 0x00)
		runtime/internal/atomic.Xadd(0x08145408, ~0x00);
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 24)->u0 = 0x00;
		((word32) dwArg04 + 0x0088)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 24, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 0x0088, 0x00);
	}
	Eq_4 edx_127 = *((word32) eax_19 + 24);
	if (g_t81576F0 == 0x00)
		((word32) edx_127 + 188)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) edx_127 + 188, 0x00);
	*((word32) dwArg04 + 0x006D) = 0x00;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 16)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 16, 0x00);
	}
	((word32) dwArg04 + 0x0094)->u0 = 0x00;
	((word32) dwArg04 + 0x0098)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 144) = 0x00;
	else
		runtime.writebarrierptr((word32) dwArg04 + 144, 0x00);
	((word32) dwArg04 + 100)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 96)->u0 = 0x00;
		((word32) dwArg04 + 0x0044)->u0 = 0x00;
		((word32) dwArg04 + 0x00C4)->u0 = 0x00;
		((word32) dwArg04 + 200)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 96, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 0x0044, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 0x00C4, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 200, 0x00);
	}
	((word32) dwArg04 + 112)->u0 = 0x01;
	Eq_4 edx_285 = gs->ptr0000->tFFFFFFFC;
	((word32) *((word32) *((word32) edx_285 + 24) + 84) + 24)->u0 = 0x00;
	((word32) *((word32) edx_285 + 24) + 84)->u0 = 0x00;
	Eq_4 edx_304 = *((word32) eax_19 + 24);
	uint32 ebx_305 = *((word32) edx_304 + 452);
	Eq_363 ebx_24_8_330 = SLICE(ebx_305, word24, 8);
	if ((ebx_305 & ~0x01) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_330, gs, (uint64) (uint32) ebx_305);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		*((word32) edx_304 + 452) = 0x00;
		runtime.gfput((word32) dwArg04 + 0x00C4, gs, *((word32) *((word32) eax_19 + 24) + 92), dwArg04);
		runtime.schedule(gs);
	}
}

// 08072AC0: void runtime.save(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.reentersyscall
//      runtime.entersyscallblock
void runtime.save(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 eax_7 = gs->ptr0000->tFFFFFFFC;
	*((word32) eax_7 + 32) = dwArg04;
	*((word32) eax_7 + 28) = dwArg08;
	((word32) eax_7 + 48)->u0 = 0x00;
	((word32) eax_7 + 44)->u0 = 0x00;
	*((word32) eax_7 + 36) = eax_7;
	if (*((word32) eax_7 + 40) != 0x00)
		runtime.badctxt();
}

// 08072B00: void runtime.reentersyscall(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.cgocallbackg
//      runtime.entersyscall
void runtime.reentersyscall(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 eax_9 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_11 = *((word32) eax_9 + 24);
	*((word32) ecx_11 + 0x0078) = (word32) *((word32) ecx_11 + 0x0078) + 1;
	((word32) eax_9 + 8)->u0 = ~0x0521;
	*((word32) eax_9 + 113) = 0x01;
	runtime.save(gs, dwArg04, dwArg08);
	*((word32) eax_9 + 56) = dwArg08;
	*((word32) eax_9 + 60) = dwArg04;
	runtime.casgstatus(eax_9, 0x02, 0x03);
	Eq_4 esp_107 = fp - 0x18;
	Eq_4 ecx_49 = *((word32) eax_9 + 56);
	if (ecx_49 < *eax_9 || *((word32) eax_9 + 4) < ecx_49)
	{
		word32 edi_67;
		word32 ebp_69;
		runtime.systemstack(gs, fp - 0x08, out ebp_69, out edi_67);
		esp_107.u0 = <invalid>;
	}
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		esp_107.u0->u0 = 0x080E7CFC;
		word32 edi_88;
		word32 ebp_90;
		runtime.systemstack(gs, *esp_107.u0, out ebp_90, out edi_88);
		esp_107.u0 = <invalid>;
		*esp_107.u0 = *((byte) esp_107.u0 + 28);
		*((byte) esp_107.u0 + 4) = *((byte) esp_107.u0 + 32);
		runtime.save(gs, *esp_107.u0, *((byte) esp_107.u0 + 4));
	}
	esp_107.u0->u0 = 0x08145460;
	runtime/internal/atomic.Load();
	Eq_4 esp_110 = (byte) esp_107.u0 + 4;
	if (*((word32) esp_110 + 4) != 0x00)
	{
		*esp_110 = 0x080E7BD0;
		word32 edi_121;
		word32 ebp_123;
		runtime.systemstack(gs, *esp_110, out ebp_123, out edi_121);
		esp_110.u0 = <invalid>;
		*esp_110.u0 = *((byte) esp_110.u0 + 28);
		*((byte) esp_110.u0 + 4) = *((byte) esp_110.u0 + 32);
		runtime.save(gs, *esp_110.u0, *((byte) esp_110.u0 + 4));
	}
	Eq_4 eax_141 = *((byte) esp_110.u0 + 0x0C);
	if (*((word32) *((word32) *((word32) eax_141 + 24) + 92) + 0x0968) != 0x00)
	{
		*esp_110.u0 = 135167156;
		word32 edi_156;
		word32 ebp_158;
		runtime.systemstack(gs, *esp_110.u0, out ebp_158, out edi_156);
		esp_110.u0 = <invalid>;
		*esp_110.u0 = *((byte) esp_110.u0 + 28);
		*((byte) esp_110.u0 + 4) = *((byte) esp_110.u0 + 32);
		runtime.save(gs, *esp_110.u0, *((byte) esp_110.u0 + 4));
		eax_141 = *((byte) esp_110.u0 + 0x0C);
	}
	Eq_4 ecx_177 = *((word32) eax_141 + 24);
	*((word32) ecx_177 + 484) = *((word32) *((word32) ecx_177 + 92) + 20);
	*((word32) eax_141 + 115) = 0x01;
	((word32) *((word32) eax_141 + 24) + 0x00B8)->u0 = 0x00;
	((word32) *((word32) *((word32) eax_141 + 24) + 92) + 48)->u0 = 0x00;
	*esp_110.u0 = (word32) *((word32) *((word32) eax_141 + 24) + 92) + 8;
	((byte) esp_110.u0 + 4)->u0 = 0x02;
	runtime/internal/atomic.Store(*esp_110.u0, *((byte) esp_110.u0 + 4));
	if (g_dw8145454 != 0x00)
	{
		*esp_110.u0 = 0x080E7BCC;
		word32 edi_210;
		word32 ebp_212;
		runtime.systemstack(gs, *esp_110.u0, out ebp_212, out edi_210);
		Eq_4 esp_213 = <invalid>;
		*esp_213 = *((word32) esp_213 + 28);
		*((word32) esp_213 + 4) = *((word32) esp_213 + 32);
		runtime.save(gs, *esp_213, *((word32) esp_213 + 4));
	}
	((word32) eax_9 + 8)->u0 = ~0x0521;
	Eq_4 eax_232 = *((word32) eax_9 + 24);
	--*((word32) eax_232 + 0x0078);
}

// 08072D00: void runtime.entersyscall(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocall
//      syscall.Syscall
//      syscall.Syscall6
void runtime.entersyscall(struct Eq_2 * gs)
{
	runtime.getcallerpc();
	runtime.reentersyscall(gs, dwLoc04, fp + 0x04);
}

// 08072D30: void runtime.entersyscall_sysmon(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack word32 dwArg00)
void runtime.entersyscall_sysmon(Eq_4 esi, struct Eq_2 * gs, word32 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_90;
	word32 esi_89;
	word32 ebp_88;
	runtime.lock(esi, gs, 135549936, out ebp_88, out esi_89, out edi_90);
	runtime/internal/atomic.Load();
	if (dwArg00 != 0x00)
	{
		runtime/internal/atomic.Store(0x08145460, 0x00);
		runtime.notewakeup(gs, 135550052);
	}
	word32 edx_91;
	word32 ebx_92;
	runtime.unlock(gs, 135549936, out edx_91, out ebx_92);
}

// 08072DB0: void runtime.entersyscall_gcwait(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.entersyscall_gcwait(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_21 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	word32 ebp_31;
	word32 edi_32;
	word32 esi_33;
	runtime.lock(esi, gs, 135549936, out ebp_31, out esi_33, out edi_32);
	if (g_t8145458 > 0x00)
	{
		runtime/internal/atomic.Cas((word32) eax_21 + 8, 0x02, 0x03);
		if ((byte) (word32) bLoc08 != 0x00)
		{
			if ((byte) (word32) g_b814F4C8 != 0x00)
			{
				word32 ebp_66;
				word32 esi_70;
				runtime.traceGoSysBlock(gs, eax_21, out ebp_66, out esi_70);
				runtime.traceProcStop(gs, eax_21);
			}
			*((word32) eax_21 + 20) = (word32) *((word32) eax_21 + 20) + 1;
			Eq_4 eax_94 = g_t8145458;
			g_t8145458 = eax_94 - 0x01;
			if (eax_94 == 0x01)
				runtime.notewakeup(gs, 135550044);
		}
	}
	word32 edx_149;
	word32 ebx_150;
	runtime.unlock(gs, 135549936, out edx_149, out ebx_150);
}

// 08072EA0: void runtime.entersyscallblock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.notetsleepg
void runtime.entersyscallblock(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_10 = *((word32) eax_8 + 24);
	*((word32) ecx_10 + 0x0078) = (word32) *((word32) ecx_10 + 0x0078) + 1;
	*((word32) eax_8 + 113) = 0x01;
	((word32) eax_8 + 8)->u0 = ~0x0521;
	Eq_4 ecx_16 = *((word32) eax_8 + 24);
	*((word32) ecx_16 + 484) = *((word32) *((word32) ecx_16 + 92) + 20);
	*((word32) eax_8 + 115) = 0x01;
	Eq_4 edx_22 = *((word32) *((word32) eax_8 + 24) + 92);
	*((word32) edx_22 + 20) = (word32) *((word32) edx_22 + 20) + 1;
	runtime.getcallerpc();
	runtime.save(gs, dwLoc34, fp + 0x04);
	*((word32) eax_8 + 56) = *((word32) eax_8 + 28);
	*((word32) eax_8 + 60) = *((word32) eax_8 + 32);
	Eq_4 ecx_52 = *((word32) eax_8 + 56);
	if (ecx_52 < *eax_8 || *((word32) eax_8 + 4) < ecx_52)
	{
		fn0808FD8B(0x00, fp - 0x14);
		word32 edi_199;
		word32 ebp_198;
		runtime.systemstack(gs, fp - 0x14, out ebp_198, out edi_199);
	}
	runtime.casgstatus(eax_8, 0x02, 0x03);
	Eq_4 ecx_99 = *((word32) eax_8 + 56);
	if (ecx_99 < *eax_8 || *((word32) eax_8 + 4) < ecx_99)
	{
		word32 edi_201;
		word32 ebp_200;
		runtime.systemstack(gs, fp - 0x20, out ebp_200, out edi_201);
	}
	word32 ebp_202;
	word32 edi_203;
	runtime.systemstack(gs, 135166932, out ebp_202, out edi_203);
	runtime.getcallerpc();
	runtime.save(gs, 0x02, fp + 0x04);
	Eq_4 eax_146 = *((word32) eax_8 + 24);
	--*((word32) eax_146 + 0x0078);
}

// 08073020: void runtime.entersyscallblock_handoff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.entersyscallblock_handoff(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		runtime.traceGoSysCall(gs);
		Eq_4 eax_37 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		word32 ebp_92;
		word32 esi_93;
		runtime.traceGoSysBlock(gs, eax_37, out ebp_92, out esi_93);
		dwLoc04 = eax_37;
	}
	runtime.releasep(gs);
	runtime.handoffp(gs, dwLoc04, dwArg04);
}

// 08073080: Register Eq_4 runtime.exitsyscall(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut)
// Called from:
//      runtime.cgocall
//      runtime.cgocallbackg
//      runtime.notetsleepg
//      syscall.Syscall
//      syscall.Syscall6
Eq_4 runtime.exitsyscall(struct Eq_2 * gs, ptr32 & esiOut)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_10 = *((word32) eax_8 + 24);
	*((word32) ecx_10 + 0x0078) = (word32) *((word32) ecx_10 + 0x0078) + 1;
	Eq_4 dwLoc14_292 = dwLoc14;
	if (fp + 0x04 > *((word32) eax_8 + 56))
	{
		word32 ebp_297;
		word32 edi_298;
		runtime.systemstack(gs, 135166936, out ebp_297, out edi_298);
		dwLoc14_292.u0 = 0x7B0000D8;
	}
	((word32) eax_8 + 88)->u0 = 0x00;
	((word32) eax_8 + 92)->u0 = 0x00;
	Eq_4 ecx_29 = *((word32) *((word32) eax_8 + 24) + 92);
	runtime.exitsyscallfast(gs);
	if ((byte) (word32) (byte) dwLoc14_292 != 0x00)
	{
		Eq_4 ecx_44 = *((word32) eax_8 + 24);
		if (*((word32) ecx_44 + 0x00B8) == 0x00)
			runtime.throw(gs);
		else
		{
			if ((byte) (word32) g_b814F4C8 != 0x00)
			{
				Eq_4 edx_61 = *((word32) ecx_44 + 92);
				ebx = ecx_29;
				if (ecx_29 != edx_61 || *((word32) ecx_44 + 484) != *((word32) edx_61 + 20))
				{
					word32 ebp_299;
					word32 edi_300;
					runtime.systemstack(gs, 0x080E7CF8, out ebp_299, out edi_300);
				}
			}
			Eq_4 edx_82 = *((word32) *((word32) eax_8 + 24) + 92);
			*((word32) edx_82 + 20) = (word32) *((word32) edx_82 + 20) + 1;
			runtime.casgstatus(eax_8, 0x03, 0x02);
			((word32) eax_8 + 56)->u0 = 0x00;
			Eq_4 ecx_101 = *((word32) eax_8 + 24);
			--*((word32) ecx_101 + 0x0078);
			if ((byte) (word32) *((word32) eax_8 + 0x006C) != 0x00)
				((word32) eax_8 + 8)->u0 = ~0x0521;
			else
				*((word32) eax_8 + 8) = (word32) *eax_8 + 880;
			*((word32) eax_8 + 113) = 0x00;
			esiOut = esi;
			return ebx;
		}
	}
	else
	{
		((word32) eax_8 + 116)->u0 = 0x00;
		((word32) eax_8 + 0x0078)->u0 = 0x00;
		if ((byte) (word32) g_b814F4C8 != 0x00)
		{
			while (ecx_29 != 0x00 && *((word32) ecx_29 + 20) == *((word32) (*((word32) eax_8 + 24)) + 484))
				runtime.osyield();
			runtime.cputicks();
			*((word32) eax_8 + 116) = dwLoc14_292;
			*((word32) eax_8 + 0x0078) = dwLoc10;
		}
		Eq_4 eax_158 = *((word32) eax_8 + 24);
		--*((word32) eax_158 + 0x0078);
		ptr32 esi_173;
		Eq_4 ebx_170 = runtime.mcall(gs, dwLoc18, &g_dw80E7BDC, out esi_173);
		if (*((word32) *((word32) eax_8 + 24) + 0x00B8) == 0x00)
			runtime.throw(gs);
		else
		{
			((word32) eax_8 + 56)->u0 = 0x00;
			Eq_4 edx_197 = *((word32) *((word32) eax_8 + 24) + 92);
			*((word32) edx_197 + 20) = (word32) *((word32) edx_197 + 20) + 1;
			*((word32) eax_8 + 113) = 0x00;
			esiOut = esi_173;
			return ebx_170;
		}
	}
}

// 08073280: void runtime.exitsyscallfast(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.exitsyscall
void runtime.exitsyscallfast(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	if (g_t8145458 == 0x7FFFFFFF)
	{
		((word32) *((word32) eax_8 + 24) + 0x00B8)->u0 = 0x00;
		((word32) *((word32) eax_8 + 24) + 92)->u0 = 0x00;
	}
	else
	{
		Eq_4 ecx_20 = *((word32) *((word32) eax_8 + 24) + 92);
		if (ecx_20 != 0x00 && *((word32) ecx_20 + 8) == 0x02)
		{
			runtime/internal/atomic.Cas((word32) ecx_20 + 8, 0x02, 0x01);
			if ((byte) (word32) bLoc1C != 0x00)
			{
				runtime.exitsyscallfast_reacquired(gs);
				return;
			}
		}
		((word32) *((word32) eax_8 + 24) + 0x00B8)->u0 = 0x00;
		((word32) *((word32) eax_8 + 24) + 92)->u0 = 0x00;
		if (g_t814540C == 0x00)
			return;
		word32 ebp_138;
		word32 edi_139;
		runtime.systemstack(gs, fp - 0x10, out ebp_138, out edi_139);
		if (0x00 == 0x00)
			;
	}
}

// 08073380: void runtime.exitsyscallfast_reacquired(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.exitsyscallfast
void runtime.exitsyscallfast_reacquired(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_9 = *((word32) eax_8 + 24);
	*((word32) ecx_9 + 0x00B8) = *((word32) *((word32) ecx_9 + 92) + 52);
	Eq_4 ecx_13 = *((word32) eax_8 + 24);
	*((word32) *((word32) ecx_13 + 92) + 48) = ecx_13;
	Eq_4 ecx_21 = *((word32) eax_8 + 24);
	if (*((word32) ecx_21 + 484) != *((word32) (*((word32) ecx_21 + 92)) + 20))
	{
		if ((byte) (word32) g_b814F4C8 != 0x00)
		{
			word32 ebp_74;
			word32 edi_75;
			runtime.systemstack(gs, fp - 0x08, out ebp_74, out edi_75);
		}
		Eq_4 ecx_46 = *((word32) *((word32) eax_8 + 24) + 92);
		*((word32) ecx_46 + 20) = (word32) *((word32) ecx_46 + 20) + 1;
	}
}

// 08073410: Register word32 runtime.exitsyscallfast_pidle(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register out ptr32 ebpOut)
// Called from:
//      runtime.exitsyscallfast.func1
word32 runtime.exitsyscallfast_pidle(Eq_4 esi, struct Eq_2 * gs, ptr32 & ebpOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_26;
	word32 edi_139;
	word32 esi_138;
	runtime.lock(esi, gs, 135549936, out ebp_26, out esi_138, out edi_139);
	runtime.pidleget(gs);
	Eq_4 dwLoc04_101 = 135549936;
	if (true)
	{
		runtime/internal/atomic.Load();
		if (true)
		{
			runtime/internal/atomic.Store(0x08145460, 0x00);
			runtime.notewakeup(gs, 135550052);
			dwLoc04_101.u0 = 0x00;
		}
	}
	word32 edx_75;
	word32 ebx_140;
	runtime.unlock(gs, 135549936, out edx_75, out ebx_140);
	if (dwLoc04_101 == 0x00)
		return;
	runtime.acquirep(gs, dwLoc04_101);
	return;
}

// 080734D0: void runtime.exitsyscall0(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.exitsyscall0(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	Eq_4 esi_31 = runtime.casgstatus(dwArg04, 0x03, 0x01);
	Eq_4 eax_38 = gs->ptr0000->tFFFFFFFC;
	((word32) *((word32) *((word32) eax_38 + 24) + 84) + 24)->u0 = 0x00;
	((word32) *((word32) eax_38 + 24) + 84)->u0 = 0x00;
	word32 esi_262;
	word32 edi_263;
	word32 ebp_261;
	runtime.lock(esi_31, gs, 135549936, out ebp_261, out esi_262, out edi_263);
	runtime.pidleget(gs);
	if (false)
	{
		((word32) dwArg04 + 0x0068)->u0 = 0x00;
		Eq_4 edx_105 = g_t814541C;
		if (edx_105 != 0x00)
			*((word32) edx_105 + 0x0068) = dwArg04;
		else
			g_t8145418 = dwArg04;
		g_t814541C = dwArg04;
		g_t8145420 = (word32) g_t8145420 + 1;
	}
	else
	{
		runtime/internal/atomic.Load();
		if (0x01 != 0x00)
		{
			runtime/internal/atomic.Store(0x08145460, 0x00);
			runtime.notewakeup(gs, 135550052);
		}
	}
	word32 ebx_265;
	word32 edx_264;
	runtime.unlock(gs, 135549936, out edx_264, out ebx_265);
	if (true)
	{
		runtime.acquirep(gs, 135549936);
		runtime.execute(gs, dwArg04, 0x00);
	}
	if (*((word32) *((word32) eax_19 + 24) + 188) != 0x00)
	{
		runtime.stoplockedm(gs);
		runtime.execute(gs, dwArg04, 0x00);
	}
	runtime.stopm(gs);
	runtime.schedule(gs);
}

// 08073670: void runtime.malg(Register (ptr32 Eq_2) gs, Stack int32 dwArg04)
// Called from:
//      runtime.mpreinit
//      runtime.allocm
//      runtime.oneNewExtraM
//      runtime.newproc1
void runtime.malg(struct Eq_2 * gs, int32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080DD7C0);
	if (dwArg04 >= 0x00)
	{
		runtime.round2(gs, dwArg04);
		word32 ebp_74;
		word32 edi_75;
		runtime.systemstack(gs, fp - 0x0C, out ebp_74, out edi_75);
		dwLoc14->dw0008 = dwLoc14->dw0000 + 880;
		dwLoc14->dw000C = ~0x00;
	}
}

// 08073700: Register Eq_4 runtime.newproc()
// Called from:
//      runtime.createfing
//      runtime.gcenable
//      runtime.gcBgMarkStartWorkers
//      runtime.init.3
//      main
Eq_4 runtime.newproc()
{
	runtime.getcallerpc();
	Eq_4 edi_23 = fn0808FD8B(0x00, fp - 0x14);
	word32 ebp_57;
	word32 edi_58;
	runtime.systemstack(gs, fp - 0x14, out ebp_57, out edi_58);
	return edi_23;
}

// 08073770: void runtime.newproc1(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      runtime.newproc.func1
void runtime.newproc1(Eq_4 esi, struct Eq_2 * gs, word32 dwArg04, word32 dwArg0C, word32 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (dwArg04 == 0x00)
	{
		((word32) *((word32) eax_18 + 24) + 0x006C)->u0 = ~0x00;
		runtime.throw(gs);
	}
	else
	{
		Eq_4 edx_34 = *((word32) eax_18 + 24);
		*((word32) edx_34 + 0x0078) = (word32) *((word32) edx_34 + 0x0078) + 1;
		if ((dwArg10 + 0x07 + dwArg0C & ~0x07) >= 2028)
			runtime.throw(gs);
		else
		{
			runtime.gfget(esi, gs, *((word32) *((word32) eax_18 + 24) + 92));
			if (dwLoc34 == 0x00)
			{
				runtime.malg(gs, 0x0800);
				runtime.allgadd(runtime.casgstatus(dwLoc34, 0x00, 0x06), gs, dwLoc34);
			}
			if (*((word32) dwLoc34 + 4) == 0x00)
				runtime.throw(gs);
			else
			{
				runtime.readgstatus(dwLoc34);
				Eq_4 esp_135 = <invalid>;
				if (*((word32) esp_135 + 4) != 0x06)
				{
					esp_135->u0 = 0x080E48CC;
					((word32) esp_135 + 4)->u0 = 0x1C;
					runtime.throw(gs);
				}
				else
				{
					Eq_4 ecx_154 = *((word32) esp_135 + 32);
					Eq_4 edx_156 = *((word32) ecx_154 + 4) - ((word32) (*((word32) esp_135 + 24)) + 16);
					*((word32) esp_135 + 20) = edx_156;
					Eq_4 eax_158 = *((word32) esp_135 + 0x0044);
					if (eax_158 > 0x00)
					{
						*esp_135 = edx_156;
						*((word32) esp_135 + 4) = *((word32) esp_135 + 64);
						*((word32) esp_135 + 8) = eax_158;
						word32 ebp_662;
						word32 esi_663;
						word32 edi_664;
						runtime.memmove(*esp_135, *((word32) esp_135 + 4), *((word32) esp_135 + 8), out ebp_662, out esi_663, out edi_664);
						if ((byte) (word32) g_t81576F4 != 0x00 && (byte) ((word32) (*((word32) (*((word32) (*((word32) (*((word32) esp_135 + 36)) + 24)) + 84)) + 111))) == 0x00)
						{
							*esp_135 = **((word32) esp_135 + 60);
							runtime.findfunc(gs, *esp_135);
							Eq_4 ecx_205 = *((word32) esp_135 + 8);
							*esp_135 = *((word32) esp_135 + 4);
							*((word32) esp_135 + 4) = ecx_205;
							((word32) esp_135 + 8)->u0 = 0x00;
							runtime.funcdata(gs, *esp_135, *((word32) esp_135 + 8));
							*esp_135 = *((word32) esp_135 + 0x0C);
							((word32) esp_135 + 4)->u0 = 0x00;
							runtime.stackmapdata(gs, *esp_135, *((word32) esp_135 + 4));
							Eq_4 eax_228 = *((word32) esp_135 + 0x0C);
							Eq_4 ecx_229 = *((word32) esp_135 + 20);
							*esp_135 = ecx_229;
							*((word32) esp_135 + 4) = ecx_229;
							*((word32) esp_135 + 8) = *((word32) esp_135 + 0x0044);
							((word32) esp_135 + 0x0C)->u0 = 0x00;
							*((word32) esp_135 + 16) = eax_228;
							runtime.bulkBarrierBitmap(*((word32) esp_135 + 4), *((word32) esp_135 + 8), *((word32) esp_135 + 0x0C), *((word32) esp_135 + 16));
						}
						ecx_154 = *((word32) esp_135 + 32);
					}
					Eq_4 eax_252 = (word32) ecx_154 + 28;
					*((word32) esp_135 + 40) = eax_252;
					*esp_135 = eax_252;
					((word32) esp_135 + 4)->u0 = 0x1C;
					runtime.memclrNoHeapPointers(*esp_135, *((word32) esp_135 + 4));
					Eq_4 eax_264 = *((word32) esp_135 + 20);
					Eq_4 ecx_265 = *((word32) esp_135 + 32);
					*((word32) ecx_265 + 28) = eax_264;
					*((word32) ecx_265 + 64) = eax_264;
					((word32) esp_135 + 48)->u0 = 0x080CAAC0;
					((word32) esp_135 + 52)->u0 = 135166996;
					*((word32) ecx_265 + 32) = (word32) **((word32) esp_135 + 52) + 1;
					*((word32) ecx_265 + 36) = ecx_265;
					Eq_4 ebx_288 = *((word32) esp_135 + 60);
					Eq_4 eax_285 = *((word32) ecx_265 + 28);
					Eq_4 ebp_289 = *ebx_288;
					*((word32) eax_285 - 4) = *((word32) ecx_265 + 32);
					*((word32) ecx_265 + 28) = (word32) eax_285 - 4;
					*((word32) ecx_265 + 32) = ebp_289;
					if (g_t81576F0 == 0x00)
						*((word32) ecx_265 + 40) = ebx_288;
					else
					{
						*esp_135 = (word32) ecx_265 + 40;
						*((word32) esp_135 + 4) = ebx_288;
						runtime.writebarrierptr(*esp_135, *((word32) esp_135 + 4));
						ecx_265 = *((word32) esp_135 + 32);
						ebx_288 = *((word32) esp_135 + 60);
					}
					*((word32) ecx_265 + 0x00A8) = *((word32) esp_135 + 76);
					*((word32) ecx_265 + 0x00AC) = *ebx_288;
					Eq_4 edx_323 = *((word32) *((word32) *((word32) esp_135 + 36) + 24) + 84);
					if (edx_323 != 0x00)
					{
						Eq_4 ebp_328 = (word32) ecx_265 + 0x00C4;
						Eq_4 edx_329 = *((word32) edx_323 + 0x00C4);
						if (g_t81576F0 == 0x00)
							*((word32) ecx_265 + 0x00C4) = edx_329;
						else
						{
							*esp_135 = ebp_328;
							*((word32) esp_135 + 4) = edx_329;
							runtime.writebarrierptr(*esp_135, *((word32) esp_135 + 4));
							ecx_265 = *((word32) esp_135 + 32);
						}
					}
					Eq_55298 dl_372;
					Eq_4 edx_348 = *((word32) ecx_265 + 0x00AC);
					if (g_t8157634 == edx_348 && (byte) ((word32) g_b8157569) == 0x00)
						dl_372.u0 = 0x01;
					else if (g_t8157598 == edx_348)
						dl_372.u0 = 0x01;
					else if (g_t81575D0 == edx_348)
						dl_372.u0 = 0x01;
					else if (g_t8157650 == edx_348)
						dl_372.u0 = 0x01;
					else
						dl_372 = g_t81575D8 == edx_348;
					if (dl_372 != 0x00)
					{
						esp_135->u0 = 0x08145408;
						((word32) esp_135 + 4)->u0 = 0x01;
						runtime/internal/atomic.Xadd(*esp_135, *((word32) esp_135 + 4));
						ecx_265 = *((word32) esp_135 + 32);
					}
					((word32) ecx_265 + 112)->u0 = 0x00;
					*esp_135 = ecx_265;
					((word32) esp_135 + 4)->u0 = 0x06;
					((word32) esp_135 + 8)->u0 = 0x01;
					runtime.casgstatus(*esp_135, *((word32) esp_135 + 4), *((word32) esp_135 + 8));
					Eq_4 eax_418 = *((word32) esp_135 + 44);
					Eq_4 ecx_419 = *((word32) eax_418 + 764);
					Eq_4 edx_420 = *((word32) eax_418 + 760);
					if ((byte) (SEQ(SLICE(ecx_419, word24, 8), ecx_419 == *((word32) eax_418 + 772)) & SEQ(SLICE(edx_420, word24, 8), edx_420 == *((word32) eax_418 + 0x0300))) != 0x00)
					{
						esp_135->u0 = 0x081453E0;
						((word32) esp_135 + 4)->u0 = 0x10;
						((word32) esp_135 + 8)->u0 = 0x00;
						word32 ebx_665;
						word32 ebp_666;
						runtime/internal/atomic.Xadd64(*esp_135, *((word32) esp_135 + 4), *((word32) esp_135 + 8), out ebx_665, out ebp_666);
						Eq_4 eax_451 = *((word32) esp_135 + 0x0C);
						Eq_4 ebx_456 = *((word32) esp_135 + 16);
						Eq_4 ebp_457 = *((word32) esp_135 + 44);
						*((word32) ebp_457 + 764) = ebx_456;
						*((word32) ebp_457 + 760) = (word32) eax_451 - 0x0F;
						*((word32) ebp_457 + 764) = (bool) (eax_451 < ~0x0E) + ((word32) ebx_456 - 1);
						*((word32) ebp_457 + 0x0300) = (word32) eax_451 + 1;
						Mem473[ebp_457 + 772:word32] = ebx_456 + (eax_451 <u 0x01);
						eax_418 = ebp_457;
					}
					Eq_4 edx_478 = *((word32) eax_418 + 764);
					Eq_4 ebx_480 = *((word32) esp_135 + 32);
					*((word32) ebx_480 + 80) = *((word32) eax_418 + 760);
					*((word32) ebx_480 + 84) = edx_478;
					Eq_4 ecx_483 = *((word32) eax_418 + 760);
					Eq_4 edx_486 = *((word32) eax_418 + 764);
					*((word32) eax_418 + 760) = (word32) ecx_483 + 1;
					Mem490[eax_418 + 0x02FC:word32] = edx_486 + (ecx_483 <u 0x01);
					if ((byte) (word32) g_b814F4C8 != 0x00)
					{
						*((word32) esp_135 + 4) = *((word32) ebx_480 + 0x00AC);
						*esp_135 = ebx_480;
						runtime.traceGoCreate(gs, *esp_135, *((word32) esp_135 + 4));
						eax_418 = *((word32) esp_135 + 44);
						ebx_480 = *((word32) esp_135 + 32);
					}
					*esp_135 = eax_418;
					*((word32) esp_135 + 4) = ebx_480;
					((word32) esp_135 + 8)->u0 = 0x01;
					runtime.runqput(gs, *((word32) esp_135 - 4), *esp_135, *((word32) esp_135 + 4), *((word32) esp_135 + 8));
					esp_135->u0 = 0x08145410;
					runtime/internal/atomic.Load();
					if (*((word32) esp_135 + 8) != 0x00)
					{
						((word32) esp_135 + 4)->u0 = 0x08145414;
						runtime/internal/atomic.Load();
						if (*((word32) esp_135 + 0x0C) == 0x00 && (byte) ((word32) g_b8157574) != 0x00)
							runtime.wakep(gs);
					}
					Eq_4 ecx_568 = *((word32) eax_18 + 24);
					--*((word32) ecx_568 + 0x0078);
					if (*((word32) *((word32) eax_18 + 24) + 0x0078) == 0x00 && (byte) ((word32) (*((word32) eax_18 + 0x006C))) != 0x00)
						((word32) eax_18 + 8)->u0 = ~0x0521;
				}
			}
		}
	}
}

// 08073CD0: void runtime.gfput(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.goexit0
void runtime.gfput(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg08);
	if (dwLoc0C != 0x06)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_39 = *((word32) dwArg08 + 4);
		Eq_4 edx_40 = *dwArg08;
		if (ecx_39 - edx_40 != 0x0800)
		{
			esi = runtime.stackfree(gs, edx_40, ecx_39);
			dwArg08->u0 = 0x00;
			((word32) dwArg08 + 4)->u0 = 0x00;
			((word32) dwArg08 + 8)->u0 = 0x00;
		}
		*((word32) dwArg08 + 0x0068) = *((word32) dwArg04 + 1812);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 1812) = dwArg08;
		else
			runtime.writebarrierptr((word32) dwArg04 + 1812, dwArg08);
		int32 eax_92 = *((word32) dwArg04 + 1816);
		*((word32) dwArg04 + 1816) = eax_92 + 0x01;
		if (eax_92 >= 0x3F)
		{
			word32 ebp_110;
			word32 esi_291;
			word32 edi_292;
			runtime.lock(esi, gs, 0x08145424, out ebp_110, out esi_291, out edi_292);
			while (true)
			{
				int32 ecx_120 = *((word32) dwArg04 + 1816);
				if (ecx_120 < 0x20)
					break;
				*((word32) dwArg04 + 1816) = ecx_120 - 0x01;
				Eq_4 ecx_140 = *((word32) dwArg04 + 1812);
				Eq_4 ebx_142 = *((word32) ecx_140 + 0x0068);
				if (g_t81576F0 == 0x00)
					*((word32) dwArg04 + 1812) = ebx_142;
				else
					runtime.writebarrierptr((word32) dwArg04 + 1812, ebx_142);
				if (*ecx_140 == 0x00)
				{
					*((word32) ecx_140 + 0x0068) = g_t814542C;
					if (g_t81576F0 == 0x00)
						g_t814542C = ecx_140;
					else
						runtime.writebarrierptr(135549996, ecx_140);
				}
				else
				{
					*((word32) ecx_140 + 0x0068) = g_t8145428;
					if (g_t81576F0 == 0x00)
						g_t8145428 = ecx_140;
					else
						runtime.writebarrierptr(135549992, ecx_140);
				}
				++g_dw8145430;
			}
			word32 ebx_294;
			word32 edx_293;
			runtime.unlock(gs, 0x08145424, out edx_293, out ebx_294);
		}
	}
}

// 08073ED0: void runtime.gfget(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.newproc1
void runtime.gfget(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	while (true)
	{
		Eq_4 ecx_21 = *((word32) dwArg04 + 1812);
		bool Z_25 = SLICE(cond(ecx_21), bool, 2);
		if (ecx_21 != 0x00)
			break;
		if (g_t8145428 == 0x00 && g_t814542C == 0x00)
		{
			Z_25 = SLICE(cond(ecx_21), bool, 2);
			break;
		}
		word32 edi_295;
		word32 ebp_294;
		runtime.lock(esi, gs, 0x08145424, out ebp_294, out esi, out edi_295);
		while (*((word32) dwArg04 + 1816) < 0x20)
		{
			Eq_4 ecx_125 = g_t8145428;
			if (ecx_125 != 0x00)
			{
				Eq_4 ebx_168 = *((word32) ecx_125 + 0x0068);
				if (g_t81576F0 == 0x00)
					g_t8145428 = ebx_168;
				else
					runtime.writebarrierptr(135549992, ebx_168);
			}
			else
			{
				ecx_125 = g_t814542C;
				if (ecx_125 == 0x00)
					break;
				Eq_4 ebx_148 = *((word32) ecx_125 + 0x0068);
				if (g_t81576F0 == 0x00)
					g_t814542C = ebx_148;
				else
					runtime.writebarrierptr(135549996, ebx_148);
			}
			*((word32) dwArg04 + 1816) = (word32) *((word32) dwArg04 + 1816) + 1;
			--g_dw8145430;
			*((word32) ecx_125 + 0x0068) = *((word32) dwArg04 + 1812);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg04 + 1812) = ecx_125;
			else
				runtime.writebarrierptr((word32) dwArg04 + 1812, ecx_125);
		}
		word32 ebx_299;
		word32 edx_298;
		runtime.unlock(gs, 0x08145424, out edx_298, out ebx_299);
	}
	if (!Z_25)
	{
		Eq_4 ebp_43 = *((word32) ecx_21 + 0x0068);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 1812) = ebp_43;
		else
			runtime.writebarrierptr((word32) dwArg04 + 1812, ebp_43);
		--*((word32) dwArg04 + 1816);
		if (*ecx_21 == 0x00)
		{
			word32 edi_297;
			word32 ebp_296;
			runtime.systemstack(gs, fp - 0x08, out ebp_296, out edi_297);
			Eq_4 esp_87 = <invalid>;
			Eq_4 ecx_92 = *((word32) esp_87 + 8);
			*((word32) ecx_92 + 8) = (word32) *ecx_92 + 880;
		}
	}
}

// 080740B0: Register Eq_4 runtime.gfpurge(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.procresize
Eq_4 runtime.gfpurge(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_26;
	word32 edi_168;
	Eq_4 esi_163;
	runtime.lock(esi, gs, 0x08145424, out ebp_26, out esi_163, out edi_168);
	while (true)
	{
		int32 ecx_36 = *((word32) dwArg04 + 1816);
		if (ecx_36 == 0x00)
			break;
		*((word32) dwArg04 + 1816) = ecx_36 - 0x01;
		Eq_4 ecx_56 = *((word32) dwArg04 + 1812);
		Eq_4 ebp_59 = *((word32) ecx_56 + 0x0068);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 1812) = ebp_59;
		else
			runtime.writebarrierptr((word32) dwArg04 + 1812, ebp_59);
		esi_163 = (word32) ecx_56 + 0x0068;
		if (*ecx_56 == 0x00)
		{
			*((word32) ecx_56 + 0x0068) = g_t814542C;
			if (g_t81576F0 == 0x00)
				g_t814542C = ecx_56;
			else
				runtime.writebarrierptr(135549996, ecx_56);
		}
		else
		{
			*((word32) ecx_56 + 0x0068) = g_t8145428;
			if (g_t81576F0 == 0x00)
				g_t8145428 = ecx_56;
			else
				runtime.writebarrierptr(135549992, ecx_56);
		}
		++g_dw8145430;
	}
	word32 edx_169;
	word32 ebx_170;
	runtime.unlock(gs, 0x08145424, out edx_169, out ebx_170);
	return esi_163;
}

// 080741E0: void runtime.unlockOSThread(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.endcgo
//      runtime.main
//      runtime.main.func2
void runtime.unlockOSThread(struct Eq_2 * gs)
{
	Eq_4 eax_27 = gs->ptr0000->tFFFFFFFC;
	if (*((word32) *((word32) eax_27 + 24) + 452) < 0x02)
	{
		word32 edi_19;
		word32 ebp_21;
		runtime.systemstack(gs, 0x080E7B90, out ebp_21, out edi_19);
		Eq_4 esp_22 = <invalid>;
		eax_27 = *((word32) esp_22 + 0x0C);
	}
	Eq_4 eax_30 = *((word32) eax_27 + 24);
	*((word32) eax_30 + 452) = (word32) *((word32) eax_30 + 452) - 2;
	Eq_4 eax_36 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_37 = *((word32) eax_36 + 24);
	if (*((word32) ecx_37 + 452) == 0x00)
	{
		if (g_t81576F0 == 0x00)
			((word32) ecx_37 + 188)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) ecx_37 + 188, 0x00);
		if (g_t81576F0 == 0x00)
			((word32) eax_36 + 0x0088)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) eax_36 + 0x0088, 0x00);
	}
}

// 080742C0: void runtime.badunlockosthread(Register (ptr32 Eq_2) gs)
void runtime.badunlockosthread(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 08074300: void runtime._System(Register (ptr32 Eq_56318) gs)
// Called from:
//      runtime._System
void runtime._System(struct Eq_56318 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime._System(gs);
}

// 08074320: void runtime._ExternalCode(Register (ptr32 Eq_56334) gs)
// Called from:
//      runtime._ExternalCode
void runtime._ExternalCode(struct Eq_56334 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime._ExternalCode(gs);
}

// 08074340: void runtime._LostExternalCode(Register (ptr32 Eq_56350) gs)
// Called from:
//      runtime._LostExternalCode
void runtime._LostExternalCode(struct Eq_56350 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime._LostExternalCode(gs);
}

// 08074360: void runtime._GC(Register (ptr32 Eq_56366) gs)
// Called from:
//      runtime._GC
void runtime._GC(struct Eq_56366 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime._GC(gs);
}

// 08074380: void runtime.sigprof(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_56386) dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.sighandler
void runtime.sigprof(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_56386 * dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	byte bLoc0148 = (byte) dwLoc0148;
	while (fp - 200 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8A(0x00, fp - 0x18);
	if (g_dw815769C == 0x00)
		return;
	word32 eax_67;
	Eq_4 ecx_32 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) ecx_32 + 0x0068) = (word32) *((word32) ecx_32 + 0x0068) + 1;
	if (dwArg0C != null && (dwArg04 >= dwArg0C->t0000 && dwArg0C->t0004 >= dwArg04))
	{
		runtime.setsSP(gs, dwArg00);
		if ((byte) (word32) bLoc0148 == 0x00)
		{
			eax_67 = 0x01;
l080743F8:
			Eq_4 eax_138;
			fn0808FD50(0x00, fp - 0x011C);
			byte dl_102 = (byte) eax_67;
			if (dwArg0C->dw00A0 > 0x00)
			{
				struct Eq_56447 * eax_89 = dwArg0C->ptr0054;
				if (eax_89 != null && (eax_89->dw003C != 0x00 && eax_89->dw0038 != 0x00))
				{
					Eq_56463 ecx_161;
					runtime/internal/atomic.Load();
					if (dwLoc0148 == 0x00)
					{
						Eq_4 ecx_153 = *((word32) dwArg10 + 0x00A8);
						if (ecx_153 != 0x00 && *ecx_153 != 0x00)
						{
							Eq_56463 edx_164 = 0x00;
							while (true)
							{
								Eq_56482 CZ_181 = SLICE(cond(edx_164 - 0x20), bool, 2);
								if (edx_164 >= 0x20)
									break;
								if (edx_164 >= 0x20)
									runtime.panicindex(gs);
								if (*((word32) ecx_153 + edx_164 * 0x04) == 0x00)
								{
									CZ_181.u0 = SLICE(cond(edx_164 - 0x20), bool, 2);
									break;
								}
								edx_164 = (word32) edx_164 + 1;
							}
							if (CZ_181)
								runtime.panicslice(gs);
							Eq_56463 edx_191;
							edx_191 = edx_164;
							if (edx_164 >= 0x40)
								edx_191.u0 = 0x40;
							word32 edi_596;
							word32 ebp_594;
							word32 esi_595;
							runtime.memmove(fp - 0x011C, ecx_153, edx_191 << 0x02, out ebp_594, out esi_595, out edi_596);
							**((word32) dwArg10 + 0x00A8) = 0x00;
							ecx_161 = edx_164;
l080744CF:
							Eq_4 edx_221 = *((word32) dwArg10 + 84);
							Eq_4 ebp_223 = *((word32) edx_221 + 56);
							if (ecx_161 >= 0x40)
								runtime.panicindex(gs);
							runtime.gentraceback(gs, ebp_223, 0x00, edx_221, 0x00, fp - 0x011C + ecx_161 * 0x04, 0x40 - ecx_161, 0x00, 0x00);
							eax_138 = dwLoc0124;
l0807452E:
							if (eax_138 <= 0x00)
							{
								if (*((word32) dwArg14 + 116) != 0x00 || *((word32) dwArg14 + 0x0088) != 0x00)
									;
								eax_138.u0 = 0x02;
							}
							if (g_dw815769C != 0x00)
							{
								if (eax_138 > 0x40)
									runtime.panicslice(gs);
								runtime.(*cpuProfile).add(gs, &g_t8145920, dwArg10, fp - 0x0118, eax_138);
							}
							Eq_4 eax_366 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
							--*((word32) eax_366 + 0x0068);
							return;
						}
					}
					ecx_161.u0 = 0x00;
					goto l080744CF;
				}
			}
			if (dl_102 == 0x00)
				eax_138.u0 = 0x00;
			else
			{
				runtime.gentraceback(gs, dwArg04, dwArg04, dwArg08, 0x00, fp - 288, 0x40, 0x00, 0x00);
				eax_138 = dwLoc0128;
			}
			goto l0807452E;
		}
	}
	eax_67 = 0x00;
	goto l080743F8;
}

// 08074780: void runtime.sigprofNonGoPC(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigtrampgo
void runtime.sigprofNonGoPC(struct Eq_2 * gs)
{
	if (g_dw815769C != 0x00)
		runtime.(*cpuProfile).addNonGo(gs, fp - 0x10, 0x02);
}

// 08074800: void runtime.setsSP(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigprof
void runtime.setsSP(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findfunc(gs, dwArg04);
	if (dwLoc08 == null)
		return;
	Eq_4 eax_37 = *dwLoc08;
	if (g_t81575EC != eax_37 && (g_t8157648 != eax_37 && (g_t81575FC != eax_37 && g_t8157600 != eax_37)))
		;
}

// 08074880: void runtime.procresize(Register word32 ebp, Register word32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.schedinit
//      runtime.startTheWorldWithSema
void runtime.procresize(word32 ebp, word32 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81575F0;
	if (eax_17 > 0x0400 || (dwArg04 <= 0x00 || dwArg04 > 0x0400))
		runtime.throw(gs);
	if ((byte) (word32) g_b814F4C8 != 0x00)
	{
		dwLoc58 = dwArg04;
		ebp = runtime.traceGomaxprocs(gs, out esi);
	}
	runtime.nanotime();
	Eq_4 ebx_69 = g_t814547C;
	Eq_4 edx_68 = g_t8145478;
	if ((byte) (SEQ(SLICE(ebp, word24, 8), ebx_69 != 0x00) | SEQ(SLICE(esi, word24, 8), edx_68 != 0x00)) != 0x00)
	{
		Eq_56736 ecx_114 = dwLoc58 - edx_68;
		uint64 edx_eax_118 = eax_17 * ecx_114;
		uint32 eax_123 = (word32) edx_eax_118;
		uint32 edx_121 = g_dw8145480;
		ui32 ebx_125 = g_dw8145484;
		g_dw8145480 = edx_121 + eax_123;
		g_dw8145484 = SLICE(SEQ(ebx_125, edx_121) + SEQ((ecx_114 *s (eax_17 >> 0x1F) + SLICE(edx_eax_118, word32, 32)) + SLICE(SEQ(dwLoc54, dwLoc58) - SEQ(ebx_69, edx_68), word32, 32) *s eax_17, eax_123), word32, 32);
	}
	g_t8145478 = dwLoc58;
	g_t814547C = dwLoc54;
	Eq_4 edx_165 = eax_17;
	Eq_4 eax_154 = 0x00;
	while (true)
	{
		byte bLoc54_1057 = (byte) dwLoc54;
		Eq_4 ecx_159 = dwArg04;
		if (eax_154 >= dwArg04)
			break;
		if (eax_154 >= 0x0401)
			runtime.panicindex(gs);
		Eq_4 ebp_690 = *((char *) g_a81478C0 + eax_154 * 0x04);
		Eq_4 esi_691 = eax_154 * 0x04 + 0x081478C0;
		if (ebp_690 == 0x00)
		{
			runtime.newobject(gs, 0x080DC7A0);
			*((word32) dwLoc54 + 4) = eax_154;
			((word32) dwLoc54 + 8)->u0 = 0x03;
			*((word32) dwLoc54 + 0x0720) = 0x00;
			*((word32) dwLoc54 + 1828) = 0x80;
			if (g_t81576F0 == 0x00)
				*((word32) dwLoc54 + 0x071C) = (word32) dwLoc54 + 0x0728;
			else
				runtime.writebarrierptr((word32) dwLoc54 + 0x071C, (word32) dwLoc54 + 0x0728);
			Eq_4 eax_743 = dwLoc54;
			Eq_56864 edx_733 = 0x00;
			while (edx_733 < 0x05)
			{
				if (edx_733 >= 0x05)
					runtime.panicindex(gs);
				ui32 ebx_761 = edx_733 * 0x03;
				((word32) eax_743 + (ebx_761 * 0x04 + 64))->u0 = 0x00;
				((word32) eax_743 + (ebx_761 * 0x04 + 0x0044))->u0 = 0x20;
				Eq_4 ebp_764 = (word32) eax_743 + 60 + ebx_761 * 0x04;
				Eq_4 edx_768 = (word32) eax_743 + 0x0078 + (edx_733 << 0x07);
				if (g_t81576F0 == 0x00)
					*((word32) eax_743 + (ebx_761 * 0x04 + 60)) = edx_768;
				else
				{
					runtime.writebarrierptr(ebp_764, edx_768);
					eax_743 = dwLoc54;
				}
				edx_733 = (word32) edx_733 + 1;
			}
			runtime.atomicstorep(esi_691, eax_743);
			dwLoc58 = esi_691;
			dwLoc54 = eax_743;
			edx_165 = eax_17;
			ebp_690 = dwLoc54;
		}
		Eq_4 esi_791 = *((word32) ebp_690 + 52);
		if (esi_791 == 0x00)
		{
			if (edx_165 == 0x00 && eax_154 == 0x00)
			{
				Eq_4 esi_834 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x00B8);
				if (esi_834 == 0x00)
					runtime.throw(gs);
				*((word32) ebp_690 + 52) = esi_834;
			}
			else
			{
				runtime.allocmcache(esi_791, gs);
				*((word32) ebp_690 + 52) = dwLoc58;
				edx_165 = eax_17;
			}
		}
		eax_154 = (word32) eax_154 + 1;
	}
	while (ecx_159 < edx_165)
	{
		if (ecx_159 >= 0x0401)
			runtime.panicindex(gs);
		Eq_4 ebp_346 = *((char *) g_a81478C0 + ecx_159 * 0x04);
		if ((byte) (word32) g_b814F4C8 != 0x00 && ebp_346 == *((word32) (*((word32) (gs->ptr0000)->tFFFFFFFC + 24)) + 92))
		{
			runtime.traceGoSched(gs);
			runtime.traceProcStop(gs, ebp_346);
		}
		while (true)
		{
			Eq_4 edi_396 = *((word32) ebp_346 + 780);
			if (*((word32) ebp_346 + 776) == edi_396)
				break;
			*((word32) ebp_346 + 780) = edi_396 - 0x01;
			Eq_4 esi_665 = *((word32) ebp_346 + ((edi_396 - 0x01 & 0xFF) * 0x04 + 784));
			*((word32) esi_665 + 0x0068) = g_t8145418;
			g_t8145418 = esi_665;
			if (g_t814541C == 0x00)
				g_t814541C = esi_665;
			g_t8145420 = (word32) g_t8145420 + 1;
		}
		Eq_4 esi_399 = *((word32) ebp_346 + 1808);
		if (esi_399 != 0x00)
		{
			*((word32) esi_399 + 0x0068) = g_t8145418;
			g_t8145418 = esi_399;
			if (g_t814541C == 0x00)
				g_t814541C = esi_399;
			g_t8145420 = (word32) g_t8145420 + 1;
			((word32) ebp_346 + 1808)->u0 = 0x00;
		}
		Eq_4 esi_427 = *((word32) ebp_346 + 0x0948);
		if (esi_427 != 0x00)
		{
			runtime.casgstatus(esi_427, 0x04, 0x01);
			if ((byte) (word32) g_b814F4C8 != 0x00)
				runtime.traceGoUnpark(gs, esi_427);
			((word32) esi_427 + 0x0068)->u0 = 0x00;
			Eq_4 ecx_476 = g_t814541C;
			if (ecx_476 != 0x00)
				*((word32) ecx_476 + 0x0068) = esi_427;
			else
				g_t8145418 = esi_427;
			g_t814541C = esi_427;
			g_t8145420 = (word32) g_t8145420 + 1;
			((word32) ebp_346 + 0x0948)->u0 = 0x00;
		}
		Eq_4 esi_528 = runtime.memclrHasPointers(gs, (word32) ebp_346 + 0x0728, 0x0200);
		*((word32) ebp_346 + 0x0720) = 0x00;
		*((word32) ebp_346 + 1828) = 0x80;
		bLoc54_1057 = 0x00;
		if (g_t81576F0 == 0x00)
			*((word32) ebp_346 + 0x071C) = (word32) ebp_346 + 0x0728;
		else
		{
			runtime.writebarrierptr((word32) ebp_346 + 0x071C, (word32) ebp_346 + 0x0728);
			bLoc54_1057 = (byte) ((word32) ebp_346 + 0x0728);
		}
		Eq_57203 ecx_556 = 0x00;
		while (ecx_556 < 0x05)
		{
			if (ecx_556 >= 0x05)
				runtime.panicindex(gs);
			int32 ecx_616 = ecx_556 << 0x07;
			runtime.memclrHasPointers(gs, (word32) ebp_346 + 0x0078 + ecx_616, 0x80);
			((word32) ebp_346 + (ecx_556 * 0x0C + 64))->u0 = 0x00;
			((word32) ebp_346 + (ecx_556 * 0x0C + 0x0044))->u0 = 0x20;
			bLoc54_1057 = 0x80;
			Eq_4 ebx_639 = (word32) ebp_346 + 0x0078 + ecx_616;
			esi_528 = (word32) ebp_346 + 60 + ecx_556 * 0x0C;
			if (g_t81576F0 == 0x00)
				*((word32) ebp_346 + (ecx_556 * 0x0C + 60)) = ebx_639;
			else
			{
				runtime.writebarrierptr(esi_528, ebx_639);
				bLoc54_1057 = (byte) ebx_639;
			}
			ecx_556 = (word32) ecx_556 + 1;
		}
		runtime.freemcache(gs);
		((word32) ebp_346 + 52)->u0 = 0x00;
		runtime.traceProcFree(runtime.gfpurge(esi_528, gs, ebp_346), gs, ebp_346);
		((word32) ebp_346 + 8)->u0 = 0x04;
		ecx_159 = (word32) ecx_159 + 1;
		edx_165 = eax_17;
	}
	Eq_4 ecx_171 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_175 = *((word32) *((word32) ecx_171 + 24) + 92);
	bool Z_178 = SLICE(cond(edx_175), bool, 2);
	if (edx_175 != 0x00)
	{
		if (*((word32) edx_175 + 4) < dwArg04)
		{
			((word32) edx_175 + 8)->u0 = 0x01;
			goto l08074E65;
		}
		Z_178 = SLICE(cond(edx_175), bool, 2);
	}
	if (!Z_178)
		((word32) edx_175 + 48)->u0 = 0x00;
	((word32) *((word32) ecx_171 + 24) + 92)->u0 = 0x00;
	((word32) *((word32) ecx_171 + 24) + 0x00B8)->u0 = 0x00;
	Eq_4 eax_198 = g_a81478C0[0];
	((word32) eax_198 + 48)->u0 = 0x00;
	((word32) eax_198 + 8)->u0 = 0x00;
	runtime.acquirep(gs, eax_198);
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceGoStart(gs);
l08074E65:
	Eq_4 ecx_269 = ecx_171;
	Eq_4 eax_233 = dwArg04;
	Eq_57050 edx_234;
	Eq_4 ebx_235 = 0x00;
	for (edx_234 = dwArg04 - 0x01; edx_234 >= 0x00; --edx_234)
	{
		if (edx_234 >= 0x0401)
			runtime.panicindex(gs);
		Eq_4 edi_272 = *((char *) g_a81478C0 + edx_234 * 0x04);
		if (*((word32) *((word32) ecx_269 + 24) + 92) != edi_272)
		{
			Eq_4 ecx_301;
			((word32) edi_272 + 8)->u0 = 0x00;
			runtime.runqempty(gs, dwLoc5C);
			if ((byte) (word32) bLoc54_1057 == 0x00)
			{
				Eq_4 eax_302 = g_t81453F4;
				if (eax_302 != 0x00)
				{
					g_t81453F4 = *((word32) eax_302 + 0x00B4);
					--g_t81453F8;
				}
				*((word32) edi_272 + 48) = eax_302;
				*((word32) edi_272 + 0x0C) = ebx_235;
				ecx_301 = edi_272;
			}
			else
			{
				runtime.pidleput(gs, edi_272);
				ecx_301 = ebx_235;
			}
			eax_233 = dwArg04;
			ebx_235 = ecx_301;
			ecx_269 = ecx_171;
		}
	}
	runtime.(*randomOrder).reset(gs, &g_dw81451B0, eax_233);
	runtime/internal/atomic.Store(0x081575F0, dwArg04);
}

// 08075030: void runtime.acquirep(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mstart1
//      runtime.allocm
//      runtime.stopm
//      runtime.stoplockedm
//      runtime.findrunnable
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.procresize
void runtime.acquirep(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.acquirep1(gs, dwArg04);
	*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x00B8) = *((word32) dwArg04 + 52);
	if ((byte) (word32) g_b814F4C8 != 0x00)
		runtime.traceProcStart(gs);
}

// 08075090: void runtime.acquirep1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.acquirep
void runtime.acquirep1(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (*((word32) ecx_19 + 92) != 0x00 || *((word32) ecx_19 + 0x00B8) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ebp_39 = *((word32) dwArg04 + 48);
		bool Z_43 = SLICE(cond(ebp_39), bool, 2);
		if (ebp_39 == 0x00)
		{
			if (*((word32) dwArg04 + 8) == 0x00)
			{
				*((word32) ecx_19 + 92) = dwArg04;
				*((word32) dwArg04 + 48) = *((word32) eax_18 + 24);
				((word32) dwArg04 + 8)->u0 = 0x01;
				return;
			}
			Z_43 = SLICE(cond(ebp_39), bool, 2);
		}
		Eq_4 eax_55;
		if (!Z_43)
			eax_55 = *((word32) ebp_39 + 100);
		else
			eax_55.u0 = 0x00;
		Eq_4 ecx_65 = *((word32) dwArg04 + 8);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, ebp_39);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, eax_55);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, ecx_65);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 08075200: void runtime.releasep(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.allocm
//      runtime.stoplockedm
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.entersyscallblock_handoff
void runtime.releasep(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	Eq_4 edx_20 = *((word32) ecx_19 + 92);
	if (edx_20 != 0x00)
	{
		Eq_4 ebx_24 = *((word32) ecx_19 + 0x00B8);
		if (ebx_24 != 0x00)
		{
			Eq_4 ebp_40 = *((word32) edx_20 + 48);
			if (ebp_40 != ecx_19 || (*((word32) edx_20 + 52) != ebx_24 || *((word32) edx_20 + 8) != 0x01))
			{
				Eq_4 ecx_56 = *((word32) edx_20 + 8);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printint(ebx, gs, ebp_40);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printint(ebx, gs, ecx_56);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			else
			{
				if ((byte) (word32) g_b814F4C8 != 0x00)
					runtime.traceProcStop(gs, edx_20);
				((word32) *((word32) eax_18 + 24) + 92)->u0 = 0x00;
				((word32) *((word32) eax_18 + 24) + 0x00B8)->u0 = 0x00;
				((word32) edx_20 + 48)->u0 = 0x00;
				((word32) edx_20 + 8)->u0 = 0x00;
				return;
			}
		}
	}
	runtime.throw(gs);
}

// 08075400: void runtime.incidlelocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stoplockedm
//      runtime.startlockedm
//      runtime.sysmon
//      runtime.retake
void runtime.incidlelocked(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_53;
	word32 esi_54;
	word32 edi_55;
	runtime.lock(esi, gs, 135549936, out ebp_53, out esi_54, out edi_55);
	Mem25[0x081453FC<p32>:word32] = Mem18[0x081453FC<p32>:word32] + dwArg04;
	if (dwArg04 > 0x00)
		runtime.checkdead(gs);
	word32 edx_56;
	word32 ebx_57;
	runtime.unlock(gs, 135549936, out edx_56, out ebx_57);
}

// 08075460: void runtime.checkdead(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.incidlelocked
//      runtime.mput
void runtime.checkdead(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b8157572 != 0x00 || (byte) ((word32) g_b8157570) != 0x00)
		return;
	if (g_dw8157618 > 0x00)
		return;
	Eq_4 eax_37 = g_t8145400;
	Eq_4 ecx_38 = g_t81453F8;
	Eq_4 ebx_41 = g_t81453FC;
	int32 eax_42 = eax_37 - ecx_38 - ebx_41;
	if (eax_42 > 0x01)
		return;
	if (eax_42 < 0x01)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_41, word24, 8), gs, ecx_38);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_41, word24, 8), gs, ebx_41);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_41, word24, 8), gs, eax_37);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		word32 ebp_536;
		word32 esi_537;
		word32 edi_538;
		runtime.lock(esi, gs, 0x08157590, out ebp_536, out esi_537, out edi_538);
		Eq_4 eax_128 = 0x00;
		Eq_4 ecx_131 = 0x00;
		while (true)
		{
			Eq_4 edx_135 = g_t814510C;
			Eq_4 ebx_136 = g_t8145108;
			if (eax_128 >= edx_135)
				break;
			if (eax_128 >= edx_135)
				runtime.panicindex(gs);
			uip32 ebx_529;
			Eq_4 edx_280 = *((word32) ebx_136 + eax_128 * 0x04);
			Eq_4 ebx_281 = *((word32) edx_280 + 0x00AC);
			word24 ebx_24_8_527 = SLICE(ebx_281, word24, 8);
			if (g_t8157634 == ebx_281)
			{
				Eq_4 ebp_285 = (word32) g_b8157569;
				ebp = ebp_285;
				if ((byte) ebp_285 != 0x00)
					goto l08075523;
				ebx_529 = 0x01;
			}
			else
			{
l08075523:
				ebp = g_t8157598;
				if (ebp == ebx_281)
					ebx_529 = 0x01;
				else
				{
					ebp = g_t81575D0;
					if (ebp == ebx_281)
						ebx_529 = 0x01;
					else
					{
						ebp = g_t8157650;
						if (ebp == ebx_281)
							ebx_529 = 0x01;
						else
						{
							ebp = g_t81575D8;
							ebx_529 = SEQ(ebx_24_8_527, ebp == ebx_281);
						}
					}
				}
			}
			Eq_4 eax_323 = eax_128;
			if ((byte) ebx_529 == 0x00)
			{
				runtime.readgstatus(edx_280);
				Eq_4 esp_333 = <invalid>;
				Eq_4 eax_338 = *((word32) esp_333 + 4);
				if ((eax_338 & ~0x1000) <= 0x03)
				{
					*((word32) esp_333 + 36) = eax_338;
					esp_333->u0 = 0x08157590;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					word32 edx_542;
					word32 ebx_543;
					runtime.unlock(gs, stackArg4, out edx_542, out ebx_543);
					Eq_4 eax_353 = *((word32) esp_333 + 40);
					*((word32) esp_333 + 32) = *((word32) eax_353 + 80);
					*((word32) esp_333 + 28) = *((word32) eax_353 + 84);
					runtime.printlock(gs);
					esp_333->u0 = 0x080E44E9;
					((word32) esp_333 + 4)->u0 = 0x1B;
					runtime.printstring(gs);
					*esp_333 = *((word32) esp_333 + 32);
					*((word32) esp_333 + 4) = *((word32) esp_333 + 28);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printint(SLICE(ebx_529, word24, 8), gs, stackArg4);
					esp_333->u0 = 0x080E19FE;
					((word32) esp_333 + 4)->u0 = 11;
					runtime.printstring(gs);
					*esp_333 = *((word32) esp_333 + 36);
					((word32) esp_333 + 4)->u0 = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printint(SLICE(ebx_529, word24, 8), gs, stackArg4);
					esp_333->u0 = 0x080E0D9C;
					((word32) esp_333 + 4)->u0 = 0x01;
					runtime.printstring(gs);
					runtime.printunlock(gs);
					esp_333->u0 = 0x080E3321;
					((word32) esp_333 + 4)->u0 = 0x15;
					runtime.throw(gs);
				}
				Eq_4 eax_411;
				if ((eax_338 & ~0x1000) == 0x04)
					eax_411 = (word32) *((word32) esp_333 + 16) + 1;
				else
					eax_411 = *((word32) esp_333 + 16);
				ecx_131 = eax_411;
				eax_323 = *((word32) esp_333 + 0x0C);
			}
			eax_128 = (word32) eax_323 + 1;
		}
		word32 edx_539;
		word32 ebx_540;
		runtime.unlock(gs, 0x08157590, out edx_539, out ebx_540);
		if (ecx_131 == 0x00)
			runtime.throw(gs);
		else
		{
			runtime.timejump(ebp, gs);
			if (0x08157590 == 0x00)
			{
				((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x006C)->u0 = ~0x00;
				runtime.throw(gs);
			}
			else
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg4 = <invalid>;
				runtime.casgstatus(stackArg4, 0x04, 0x01);
				g_dw81575F8 = 0x00;
				Eq_4 ecx_187 = g_t814541C;
				if (ecx_187 != 0x00)
					((word32) ecx_187 + 0x0068)->u0 = 0x08157590;
				else
					g_t8145418.u0 = 0x08157590;
				g_t814541C.u0 = 0x08157590;
				g_t8145420 = (word32) g_t8145420 + 1;
				runtime.pidleget(gs);
				if (0x08157590 == 0x00)
					runtime.throw(gs);
				else
				{
					Eq_4 ecx_234 = g_t81453F4;
					bool Z_237 = SLICE(cond(ecx_234), bool, 2);
					if (ecx_234 != 0x00)
					{
						g_t81453F4 = *((word32) ecx_234 + 0x00B4);
						--g_t81453F8;
						Z_237 = SLICE(cond(ecx_234), bool, 2);
					}
					if (Z_237)
						runtime.throw(gs);
					else
					{
						((word32) ecx_234 + 96)->u0 = 0x08157590;
						runtime.notewakeup(gs, (word32) ecx_234 + 0x00AC);
					}
				}
			}
		}
	}
}

// 08075890: void runtime.sysmon(Register (ptr32 Eq_2) gs)
void runtime.sysmon(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esp_108 = fp - 0x50;
	if (g_dw815774C > 0x00)
	{
		g_dw81360F0 = 10000000;
		g_dw81360F4 = 0x00;
	}
	runtime.nanotime();
	word32 eax_41 = dwLoc50;
	word32 ecx_42 = dwLoc4C;
	int32 edx_43 = 0x00;
	uint32 ebx_44 = 0x00;
	word32 ebp_45 = 0x00;
	uint32 esi_46 = 0x00;
	Eq_4 edi_47 = 0x00;
l0807590A:
	if (edx_43 == 0x00)
		ebx_44 = 0x14;
	else if (edx_43 > 0x32)
		ebx_44 <<= 0x01;
	*((word32) esp_108 + 44) = esi_46;
	*((word32) esp_108 + 48) = edi_47;
	*((word32) esp_108 + 56) = ecx_42;
	*((word32) esp_108 + 40) = ebp_45;
	*((word32) esp_108 + 52) = eax_41;
	*((word32) esp_108 + 64) = edx_43;
	if (ebx_44 > 10000)
		ebx_44 = 10000;
	word32 eax_115;
	word32 ecx_116;
	*((word32) esp_108 + 0x0044) = ebx_44;
	*esp_108 = ebx_44;
	word32 edi_130;
	Eq_4 esi_131 = runtime.usleep(out edi_130);
	if (g_t8157754 <= 0x00)
	{
		if (g_dw8145454 != 0x00)
		{
l08075964:
			uint32 eax_152;
			word32 ecx_153;
			*esp_108 = 135549936;
			word32 ebp_775;
			runtime.lock(esi_131, gs, *esp_108, out ebp_775, out esi_131, out edi_130);
			*esp_108 = 0x08145454;
			runtime/internal/atomic.Load();
			esp_108 = (word32) esp_108 + 4;
			if (*((word32) esp_108 + 4) == 0x00)
			{
				*esp_108 = 0x08145410;
				runtime/internal/atomic.Load();
				esp_108 = (word32) esp_108 + 4;
				if (g_t81575F0 != *((word32) esp_108 + 8))
				{
					eax_152 = (uint32) *((word32) esp_108 + 72);
					ecx_153 = (word32) *((word32) esp_108 + 0x0044);
					goto l08075A68;
				}
			}
			int32 ebx_217;
			ui32 eax_218;
			*esp_108 = 0x08145460;
			*((word32) esp_108 + 4) = 0x01;
			runtime/internal/atomic.Store(*esp_108, *((word32) esp_108 + 4));
			*esp_108 = 135549936;
			word32 ebx_777;
			word32 edx_776;
			runtime.unlock(gs, *esp_108, out edx_776, out ebx_777);
			up32 eax_172 = g_dw81360F0;
			int32 ecx_173 = g_dw81360F4;
			uint32 ecx_177 = (ecx_173 >> 0x1F >> 0x1F) + eax_172;
			int32 ecx_187 = *((word32) esp_108 + 36);
			int32 edx_181 = ecx_173 + (ecx_177 < 0x00);
			up32 edi_200 = *((word32) esp_108 + 32);
			Eq_4 ebx_197 = SEQ(SLICE(esi_131, word24, 8), ecx_187 == ecx_173);
			ui32 edx_185 = edx_181 << 0x1F | ecx_177 >> 0x01;
			if ((byte) (SEQ(SLICE(eax_172, word24, 8), edi_200 < eax_172) & ebx_197 | SEQ(SLICE(ecx_173, word24, 8), ecx_187 < ecx_173)) != 0x00)
			{
				uint32 ecx_222 = (ecx_187 >> 0x1F >> 0x1F) + edi_200;
				int32 eax_225 = ecx_187 + (ecx_222 < 0x00);
				eax_218 = eax_225 << 0x1F | ecx_222 >> 0x01;
				ebx_217 = eax_225 >> 0x01;
			}
			else
			{
				ebx_217 = edx_181 >> 0x01;
				eax_218 = edx_185;
			}
			*esp_108 = 135550052;
			*((word32) esp_108 + 4) = eax_218;
			*((word32) esp_108 + 8) = ebx_217;
			Eq_4 esi_248 = runtime.notetsleep(edx_181 >> 0x01, ebx_197, gs, *esp_108, *((word32) esp_108 + 4), *((word32) esp_108 + 8));
			*esp_108 = 135549936;
			word32 ebp_786;
			runtime.lock(esi_248, gs, *esp_108, out ebp_786, out esi_131, out edi_130);
			*esp_108 = 0x08145460;
			*((word32) esp_108 + 4) = 0x00;
			runtime/internal/atomic.Store(*esp_108, *((word32) esp_108 + 4));
			g_dw8145464 = 0x00;
			eax_152 = 0x14;
			ecx_153 = 0x00;
l08075A68:
			*((word32) esp_108 + 64) = ecx_153;
			*((word32) esp_108 + 0x0044) = eax_152;
			*esp_108 = 135549936;
			word32 ebx_788;
			word32 edx_787;
			runtime.unlock(gs, *esp_108, out edx_787, out ebx_788);
			eax_115 = (word32) *((word32) esp_108 + 0x0044);
			ecx_116 = (word32) *((word32) esp_108 + 64);
l08075A86:
			*((word32) esp_108 + 64) = ecx_116;
			*((word32) esp_108 + 0x0044) = eax_115;
			<anonymous> * edx_304 = *g_ptr81422A4;
			if (edx_304 != null)
			{
				*esp_108 = edx_304;
				*((word32) esp_108 + 4) = 0x00;
				esi_131 = runtime.asmcgocall(gs, *esp_108, *((word32) esp_108 + 4), out edi_130);
				esp_108.u0 = <invalid>;
			}
			*esp_108.u0 = 135549928;
			word64 mm0_778;
			runtime/internal/atomic.Load64(*esp_108.u0, out mm0_778);
			*((byte) esp_108.u0 + 72) = *((byte) esp_108.u0 + 8);
			*((byte) esp_108.u0 + 60) = *((byte) esp_108.u0 + 4);
			ui24 ebx_24_8_361 = SLICE(runtime.nanotime(), word24, 8);
			up32 eax_346 = *esp_108.u0;
			*((byte) esp_108.u0 + 24) = eax_346;
			int32 ecx_348 = *((byte) esp_108.u0 + 4);
			*((byte) esp_108.u0 + 28) = ecx_348;
			word32 edx_350 = *((byte) esp_108.u0 + 72);
			up32 ebp_354 = *((byte) esp_108.u0 + 60);
			if ((byte) (SEQ(ebx_24_8_361, edx_350 != 0x00) | SEQ(SLICE(esi_131, word24, 8), ebp_354 != 0x00)) != 0x00)
			{
				int32 edx_382 = (bool) (ebp_354 < 10000000) + edx_350;
				if ((byte) (SEQ(SLICE(ebp_354 + 10000000, word24, 8), ebp_354 + 10000000 < eax_346) & SEQ(SLICE(edi_130, word24, 8), edx_382 == ecx_348) | SEQ(SLICE(edx_382, word24, 8), edx_382 < ecx_348)) != 0x00)
				{
					*esp_108.u0 = 135549928;
					*((byte) esp_108.u0 + 4) = ebp_354;
					*((byte) esp_108.u0 + 8) = edx_350;
					*((byte) esp_108.u0 + 0x0C) = eax_346;
					*((byte) esp_108.u0 + 16) = ecx_348;
					word32 ebp_780;
					word32 ebx_779;
					runtime/internal/atomic.Cas64(*esp_108.u0, *((byte) esp_108.u0 + 4), *((byte) esp_108.u0 + 0x0C), out ebx_779, out ebp_780);
					*esp_108.u0 = 0x00;
					runtime.netpoll(gs, *esp_108.u0);
					word32 eax_453 = *((byte) esp_108.u0 + 4);
					if (eax_453 != 0x00)
					{
						*((word32) esp_108 + 76) = eax_453;
						*esp_108 = ~0x00;
						runtime.incidlelocked(gs, *esp_108);
						*esp_108 = *((word32) esp_108 + 76);
						runtime.injectglist(gs, *esp_108);
						*esp_108 = 0x01;
						runtime.incidlelocked(gs, *esp_108);
					}
					eax_346 = (up32) *((word32) esp_108 + 24);
					ecx_348 = (int32) *((word32) esp_108 + 28);
				}
			}
			word32 eax_510;
			*esp_108.u0 = eax_346;
			*((byte) esp_108.u0 + 4) = ecx_348;
			Eq_4 esi_500;
			runtime.retake(gs, *((byte) esp_108.u0 - 4), *esp_108.u0, *((byte) esp_108.u0 + 4), *((byte) esp_108.u0 + 8), *((byte) esp_108.u0 + 0x0C), out esi_500);
			if (*((byte) esp_108.u0 + 8) != 0x00)
				eax_510 = 0x00;
			else
				eax_510 = (word32) *((byte) esp_108.u0 + 64) + 1;
			*((word32) esp_108 + 64) = eax_510;
			*esp_108 = 0x02;
			*((word32) esp_108 + 4) = *((word32) esp_108 + 24);
			Eq_4 edx_520 = *((word32) esp_108 + 28);
			*((word32) esp_108 + 8) = edx_520;
			*((word32) esp_108 + 0x0C) = 0x00;
			runtime.gcTrigger.test(edx_520, gs, *esp_108, *((word32) esp_108 + 4));
			if ((byte) (word32) *((word32) esp_108 + 16) != 0x00)
			{
				*esp_108.u0 = 0x08145140;
				runtime/internal/atomic.Load();
				esp_108 = (byte) esp_108.u0 + 4;
				if (*((word32) esp_108 + 4) != 0x00)
				{
					*esp_108 = 0x08145138;
					word32 esi_782;
					word32 edi_783;
					word32 ebp_781;
					runtime.lock(esi_500, gs, *esp_108, out ebp_781, out esi_782, out edi_783);
					g_dw8145140 = 0x00;
					((word32) g_t814513C + 0x0068)->u0 = 0x00;
					*esp_108 = g_t814513C;
					runtime.injectglist(gs, *esp_108);
					*esp_108 = 0x08145138;
					word32 ebx_785;
					word32 edx_784;
					runtime.unlock(gs, *esp_108, out edx_784, out ebx_785);
				}
			}
			word32 ebx_657;
			int32 ecx_661;
			int32 ecx_587 = *((word32) esp_108 + 36);
			word32 ebx_591 = *((word32) esp_108 + 32);
			uint32 ecx_592 = (ecx_587 >> 0x1F >> 0x1F) + ebx_591;
			int32 edx_596 = ecx_587 + (ecx_592 < 0x00);
			word32 ecx_601 = *((word32) esp_108 + 52);
			ui32 edx_600 = edx_596 << 0x1F | ecx_592 >> 0x01;
			up32 ecx_603 = ecx_601 + edx_600;
			int32 esi_609 = (word32) *((word32) esp_108 + 56) + (edx_596 >> 0x01) + (edx_600 + ecx_601 < 0x00);
			int32 ebp_611 = *((word32) esp_108 + 28);
			up32 edx_615 = *((word32) esp_108 + 24);
			word32 edi_602 = ecx_601;
			if ((byte) (SEQ(SLICE(ecx_603, word24, 8), ecx_603 < edx_615) & SEQ(SLICE(ebx_591, word24, 8), esi_609 == ebp_611) | SEQ(SLICE(ebx_591, word24, 8), esi_609 < ebp_611)) == 0x00)
			{
				ecx_661 = (int32) *((word32) esp_108 + 56);
				ebx_657 = (word32) *((word32) esp_108 + 40);
			}
			else
			{
				*esp_108 = 0x081488E0;
				*((word32) esp_108 + 4) = *((word32) esp_108 + 40);
				*((word32) esp_108 + 8) = edx_615;
				*((word32) esp_108 + 0x0C) = ebp_611;
				Eq_4 esi_640 = *((word32) esp_108 + 32);
				*((word32) esp_108 + 16) = esi_640;
				*((word32) esp_108 + 20) = ecx_587;
				runtime.(*mheap).scavenge(esi_640, gs, *esp_108, *((word32) esp_108 + 4), *((word32) esp_108 + 8), *((word32) esp_108 + 16), *((word32) esp_108 + 20));
				ebp_611 = (int32) *((word32) esp_108 + 28);
				ebx_657 = (word32) *((word32) esp_108 + 40) + 1;
				ecx_661 = ebp_611;
				edi_602 = (word32) *((word32) esp_108 + 24);
			}
			uint32 ecx_676;
			Eq_4 esi_675;
			*((word32) esp_108 + 56) = ecx_661;
			*((word32) esp_108 + 52) = edi_602;
			*((word32) esp_108 + 40) = ebx_657;
			ui24 ebx_24_8_701 = SLICE(ebx_657, word24, 8);
			Eq_45041 esi_672 = g_t8157754;
			if (esi_672 > 0x00)
			{
				up32 eax_680 = (word32) (esi_672 * 1000000);
				*((word32) esp_108 + 72) = eax_680;
				ecx_676 = (uint32) *((word32) esp_108 + 44);
				esi_675 = *((word32) esp_108 + 48);
				int32 edx_693 = SLICE(SEQ(SLICE(esi_672 * 1000000, word32, 32) + (esi_672 >> 0x1F) *s 1000000, *((word32) esp_108 + 72)) + SEQ(esi_675, ecx_676), word32, 32);
				up32 edi_698 = *((word32) esp_108 + 24);
				if ((byte) (SEQ(SLICE(edi_698, word24, 8), eax_680 + ecx_676 <= edi_698) & SEQ(ebx_24_8_701, edx_693 == ebp_611) | SEQ(SLICE(edx_693, word24, 8), edx_693 < ebp_611)) != 0x00)
				{
					*esp_108 = g_dw8157750 > 0x00;
					runtime.schedtrace(esi_675, gs, *esp_108, *((word32) esp_108 + 8));
					esi_675 = *((word32) esp_108 + 28);
					ecx_676 = (uint32) *((word32) esp_108 + 24);
				}
			}
			else
			{
				esi_675 = *((word32) esp_108 + 48);
				ecx_676 = (uint32) *((word32) esp_108 + 44);
			}
			edx_43 = (int32) *((word32) esp_108 + 64);
			ebx_44 = (uint32) *((word32) esp_108 + 0x0044);
			eax_41 = (word32) *((word32) esp_108 + 52);
			ebp_45 = (word32) *((word32) esp_108 + 40);
			edi_47 = esi_675;
			esi_46 = ecx_676;
			ecx_42 = (word32) *((word32) esp_108 + 56);
			goto l0807590A;
		}
		*esp_108 = 0x08145410;
		runtime/internal/atomic.Load();
		esp_108 = (word32) esp_108 + 4;
		if (g_t81575F0 == *((word32) esp_108 + 4))
			goto l08075964;
	}
	eax_115 = (word32) *((word32) esp_108 + 0x0044);
	ecx_116 = (word32) *((word32) esp_108 + 64);
	goto l08075A86;
}

// 08075E20: Register Eq_4 runtime.retake(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_58297) dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_4 esiOut)
// Called from:
//      runtime.sysmon
Eq_4 runtime.retake(struct Eq_2 * gs, struct Eq_58297 * dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_103 = 0x00;
	while (true)
	{
		Eq_4 esp_164 = fp - 44;
		if (eax_103 >= g_t81575F0)
			break;
		if (eax_103 >= 0x0401)
			runtime.panicindex(gs);
		struct Eq_58895 * ebx_35 = *((char *) g_a81478C0 + eax_103 * 0x04);
		if (ebx_35 != null)
		{
			word32 esi_43 = ebx_35->dw0008;
			if (esi_43 == 0x02)
			{
				word32 ebp_135 = ebx_35->dw0014;
				if (ebx_35->dw0024 != ebp_135)
				{
					ebx_35->dw0024 = ebp_135;
					ebx_35->t0028 = dwArg04;
					ebx_35->t002C = dwArg08;
					ebp = dwArg04;
					esi = dwArg08;
					goto l08075E3F;
				}
				runtime.runqempty(gs, dwLoc30);
				if ((byte) (word32) bLoc28 == 0x00)
				{
l08075EC5:
					Eq_4 eax_240;
					esp_164->u0 = ~0x00;
					runtime.incidlelocked(gs, *esp_164);
					*esp_164 = *((word32) esp_164 + 40);
					*((word32) esp_164 + 4) = *((word32) esp_164 + 16);
					((word32) esp_164 + 8)->u0 = 0x00;
					runtime/internal/atomic.Cas(*esp_164, *((word32) esp_164 + 4), *((word32) esp_164 + 8));
					if ((byte) (word32) *((word32) esp_164 + 0x0C) != 0x00)
					{
						if ((byte) (word32) g_b814F4C8 != 0x00)
						{
							*esp_164 = *((word32) esp_164 + 36);
							word32 ebp_477;
							word32 esi_478;
							runtime.traceGoSysBlock(gs, *esp_164, out ebp_477, out esi_478);
							*esp_164 = *((word32) esp_164 + 36);
							runtime.traceProcStop(gs, *esp_164);
						}
						Eq_4 eax_273 = *((word32) esp_164 + 36);
						*((word32) eax_273 + 20) = (word32) *((word32) eax_273 + 20) + 1;
						*esp_164 = eax_273;
						runtime.handoffp(gs, *esp_164, *((word32) esp_164 + 8));
						esp_164.u0 = <invalid>;
						eax_240 = (word32) *((byte) esp_164.u0 + 20) + 1;
					}
					else
						eax_240 = *((word32) esp_164 + 20);
					*((byte) esp_164.u0 + 32) = eax_240;
					esp_164.u0->u0 = 0x01;
					runtime.incidlelocked(gs, *esp_164.u0);
					goto l08075F2D;
				}
				runtime/internal/atomic.Load();
				runtime/internal/atomic.Load();
				bLoc28 = 0x10;
				esp_164 = fp - 0x24;
				if (ebx_35 + dwLoc20 / 52 <= 0x00)
					goto l08075EC5;
				up32 ecx_176 = dwArg00->dw0028;
				Eq_4 edx_181 = (bool) (ecx_176 < 10000000) + dwArg00->dw002C;
				if ((byte) (SEQ(SLICE(edx_181, word24, 8), edx_181 > dwArg10) | SEQ(SLICE(ecx_176 + 10000000, word24, 8), ecx_176 + 10000000 > dwArg0C) & SEQ(SLICE(ebp_135, word24, 8), edx_181 == dwArg10)) == 0x00)
					goto l08075EC5;
				eax_103 = dwLoc24;
				ebp = dwArg0C;
				esi = dwArg10;
				goto l08075E3F;
			}
			if (esi_43 == 0x01)
			{
				word32 ebp_52 = ebx_35->dw0010;
				if (ebx_35->dw0018 != ebp_52)
				{
					ebx_35->dw0018 = ebp_52;
					ebx_35->t001C = dwArg04;
					ebx_35->t0020 = dwArg08;
					ebp = dwArg04;
					esi = dwArg08;
					goto l08075E3F;
				}
				Eq_4 ebp_56 = ebx_35->t001C;
				ui24 ebx_24_8_70 = SLICE((word32) ebp_56 + 10000000, word24, 8);
				word32 esi_61 = Mem41[ebx_35 + 0x20:word32] + (ebp_56 <u 10000000);
				if ((byte) (SEQ(ebx_24_8_70, esi_61 > dwArg08) | SEQ(529528, esi_61 == dwArg08) & SEQ(ebx_24_8_70, (word32) ebp_56 + 10000000 > dwArg04)) != 0x00)
				{
					ebp = dwArg04;
					esi = dwArg08;
					goto l08075E3F;
				}
				Eq_4 edx_105 = ebx_35->t0030;
				if (edx_105 != 0x00 && *((word32) (gs->ptr0000)->tFFFFFFFC + 24) != edx_105)
				{
					Eq_4 ebx_114 = *((word32) edx_105 + 84);
					if (ebx_114 != 0x00 && ebx_114 != *edx_105)
					{
						((word32) ebx_114 + 0x006C)->u0 = 0x01;
						((word32) ebx_114 + 8)->u0 = ~0x0521;
					}
				}
			}
l08075F2D:
			ebp = *((byte) esp_164.u0 + 48);
			esi = *((byte) esp_164.u0 + 52);
			eax_103 = *((byte) esp_164.u0 + 24);
		}
		else
		{
			ebp = dwArg04;
			esi = dwArg08;
		}
l08075E3F:
		eax_103 = (word32) eax_103 + 1;
	}
	esiOut = esi;
	return ebp;
}

// 080760E0: Register Eq_4 runtime.preemptall(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.freezetheworld
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
Eq_4 runtime.preemptall(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = 0x00;
	while (eax_16 < g_t81575F0)
	{
		if (eax_16 >= 0x0401)
			runtime.panicindex(gs);
		struct Eq_59205 * ebx_32 = *((char *) g_a81478C0 + eax_16 * 0x04);
		if (ebx_32 != null)
		{
			ebp = ebx_32->t0008;
			if (ebp != 0x01)
				goto l080760F8;
			Eq_4 ebx_39 = ebx_32->t0030;
			if (ebx_39 != 0x00)
			{
				ebp = *((word32) gs->ptr0000->tFFFFFFFC + 24);
				if (ebp == ebx_39)
					goto l0807613A;
				ebp = *((word32) ebx_39 + 84);
				if (ebp != 0x00 && ebp != *ebx_39)
				{
					((word32) ebp + 0x006C)->u0 = 0x01;
					((word32) ebp + 8)->u0 = ~0x0521;
				}
			}
			else
			{
l0807613A:
			}
		}
l080760F8:
		eax_16 = (word32) eax_16 + 1;
	}
	return ebp;
}

// 08076180: void runtime.schedtrace(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_45018) dwArg04, Stack Eq_45019 bArg0C)
// Called from:
//      runtime.startpanic_m
//      runtime.sysmon
void runtime.schedtrace(Eq_4 esi, struct Eq_2 * gs, struct Eq_45018 * dwArg04, Eq_45019 bArg0C)
{
	ui32 dwLoc8C = SLICE(qwLoc90, word32, 32);
	uint32 dwLoc90 = (word32) qwLoc90;
	byte bArg04 = (byte) dwArg04;
	while (fp - 0x10 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.nanotime();
	ui32 edx_31 = g_dw81576B4;
	uint32 ebx_32 = g_dw81576B0;
	if ((byte) (SEQ(SLICE(edx_31, word24, 8), edx_31 == 0x00) & SEQ(SLICE(ebx_32, word24, 8), ebx_32 == 0x00)) != 0x00)
	{
		g_dw81576B0 = dwLoc90;
		g_dw81576B4 = dwLoc8C;
	}
	ui32 edi_62;
	word32 esi_1695;
	word32 ebp_1694;
	runtime.int64div(SLICE(runtime.lock(esi, gs, 135549936, out ebp_1694, out esi_1695, out edi_62), word24, 8), edi_62, gs, qwLoc90 - SEQ(g_dw81576B4, g_dw81576B0), 1000000);
	Eq_4 ebx_99 = g_t8145400;
	word32 edx_97 = g_dw8145410;
	word32 ebp_101 = g_dw8145414;
	Eq_4 esi_103 = g_t81453F8;
	Eq_51345 edi_105 = g_t8145420;
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_363 ebx_24_8_127 = SLICE(ebx_99, word24, 8);
	runtime.printint(ebx_24_8_127, gs, qwLoc80);
	runtime.printstring(gs);
	Eq_4 eax_145 = g_t81575F0;
	runtime.printint(ebx_24_8_127, gs, SEQ(eax_145 >> 0x1F, eax_145));
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_127, gs, (uint64) (uint32) edx_97);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_127, gs, SEQ(ebx_99 >> 0x1F, ebx_99));
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_127, gs, (uint64) (uint32) ebp_101);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_127, gs, SEQ(esi_103 >> 0x1F, esi_103));
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_127, gs, SEQ(edi_105 >> 0x1F, edi_105));
	runtime.printunlock(gs);
	Eq_4 dwLoc88_1377 = 1000000;
	word32 dwLoc84_1378 = 0x00;
	byte al_1348 = (byte) (word32) bArg04;
	if (al_1348 != 0x00)
	{
		word32 ebx_281 = g_dw8145460;
		word32 eax_275 = g_dw8145454;
		Eq_4 ecx_277 = g_t81453FC;
		Eq_4 edx_279 = g_t8145458;
		runtime.printlock(gs);
		runtime.printstring(gs);
		Eq_363 ebx_24_8_302 = SLICE(ebx_281, word24, 8);
		runtime.printint(ebx_24_8_302, gs, (uint64) (uint32) eax_275);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_302, gs, SEQ(ecx_277 >> 0x1F, ecx_277));
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_302, gs, SEQ(edx_279 >> 0x1F, edx_279));
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_302, gs, (uint64) (uint32) ebx_281);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		al_1348 = (byte) (word32) bArg04;
	}
	Eq_4 ecx_1339 = 0x00;
	while (ecx_1339 < g_t81575F0)
	{
		if (ecx_1339 >= 0x0401)
			runtime.panicindex(gs);
		struct Eq_59458 * ebx_1008 = *((char *) g_a81478C0 + ecx_1339 * 0x04);
		Eq_363 ebx_24_8_1100 = SLICE(ebx_1008, word24, 8);
		if (ebx_1008 != null)
		{
			struct Eq_59469 * ecx_1015 = ebx_1008->ptr0030;
			runtime/internal/atomic.Load();
			runtime/internal/atomic.Load();
			if ((byte) (word32) bArg0C != 0x00)
			{
				Eq_59489 edx_1148;
				if (dwArg04 != null)
					edx_1148 = dwArg04->t0064;
				else
					edx_1148.u0 = ~0x00;
				word32 ebx_1156 = ecx_1015->dw0010;
				word32 ecx_1154 = ecx_1015->dw0008;
				word32 ebp_1158 = ecx_1015->dw0014;
				Eq_59695 eax_1160 = ecx_1015->t0718;
				runtime.printlock(gs);
				runtime.printstring(gs);
				Eq_363 ebx_24_8_1184 = SLICE(ebx_1156, word24, 8);
				runtime.printint(ebx_24_8_1184, gs, SEQ(dwLoc88_1377 >> 0x1F, dwLoc88_1377));
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1184, gs, (uint64) (uint32) ecx_1154);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1184, gs, (uint64) (uint32) ebx_1156);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1184, gs, (uint64) (uint32) ebp_1158);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1184, gs, SEQ(edx_1148 >> 0x1F, edx_1148));
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1184, gs, (uint64) (uint32) (dwLoc84_1378 - dwLoc3C));
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1184, gs, SEQ(eax_1160 >> 0x1F, eax_1160));
				runtime.printstring(gs);
				runtime.printunlock(gs);
				dwLoc88_1377.u0 = 0x080E0D9C;
				dwLoc84_1378 = 0x01;
			}
			else
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				if (dwLoc88_1377 == 0x00)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
				}
				runtime.printlock(gs);
				Eq_4 eax_1095 = dwLoc84_1378 - dwLoc3C;
				runtime.printint(ebx_24_8_1100, gs, (uint64) (uint32) eax_1095);
				runtime.printunlock(gs);
				dwLoc88_1377 = eax_1095;
				dwLoc84_1378 = 0x00;
				if (g_t81575F0 - 0x01 == dwLoc88_1377)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					dwLoc88_1377.u0 = 0x080E0E0F;
					dwLoc84_1378 = 0x02;
				}
			}
			al_1348 = (byte) (word32) bArg0C;
			ecx_1339 = dwLoc88_1377;
		}
		ecx_1339 = (word32) ecx_1339 + 1;
	}
	if (al_1348 == 0x00)
	{
		word32 edx_1696;
		word32 ebx_1697;
		runtime.unlock(gs, 135549936, out edx_1696, out ebx_1697);
	}
	else
	{
		Eq_4 eax_1004 = g_t8144FAC;
		while (eax_1004 != 0x00)
		{
			Eq_4 ebx_661;
			Eq_4 ecx_655 = *((word32) eax_1004 + 84);
			Eq_4 edx_656 = *((word32) eax_1004 + 188);
			Eq_4 ebx_657 = *((word32) eax_1004 + 92);
			if (ebx_657 != 0x00)
				ebx_661 = *((word32) ebx_657 + 4);
			else
				ebx_661.u0 = ~0x00;
			Eq_4 ebp_668;
			Eq_4 ecx_667;
			if (ecx_655 != 0x00)
			{
				ebp_668 = *((word32) ecx_655 + 84);
				ecx_667 = *((word32) ecx_655 + 80);
			}
			else
			{
				ecx_667.u0 = ~0x00;
				ebp_668.u0 = ~0x00;
			}
			Eq_4 esi_687;
			Eq_4 edx_686;
			if (edx_656 != 0x00)
			{
				esi_687 = *((word32) edx_656 + 84);
				edx_686 = *((word32) edx_656 + 80);
			}
			else
			{
				edx_686.u0 = ~0x00;
				esi_687.u0 = ~0x00;
			}
			Eq_4 ebx_701 = *((word32) eax_1004 + 0x0068);
			Eq_4 ecx_699 = *((word32) eax_1004 + 100);
			Eq_4 ebp_703 = *((word32) eax_1004 + 0x006C);
			esi_103 = *((word32) eax_1004 + 112);
			Eq_4 edx_709 = *((word32) eax_1004 + 0x0078);
			struct Eq_44977 * edx_711 = *((word32) eax_1004 + 0x0080);
			Eq_4 edx_713 = *((word32) eax_1004 + 0x0088);
			byte dl_716 = (byte) (word32) *((word32) eax_1004 + 0x008C);
			byte al_719 = (byte) (word32) *((word32) eax_1004 + 141);
			runtime.printlock(gs);
			runtime.printstring(gs);
			Eq_363 ebx_24_8_745 = SLICE(ebx_701, word24, 8);
			runtime.printint(ebx_24_8_745, gs, SEQ(ecx_699 >> 0x1F, ecx_699));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_745, gs, SEQ(ebx_661 >> 0x1F, ebx_661));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_745, gs, SEQ(ebp_668, ecx_667));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_745, gs, SEQ(ebx_701 >> 0x1F, ebx_701));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_745, gs, SEQ(ebp_703 >> 0x1F, ebp_703));
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_745, gs, SEQ(edx_709 >> 0x1F, edx_709));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_745, gs, SEQ(edx_711 >> 0x1F, edx_711));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_745, gs, SEQ(edx_713 >> 0x1F, edx_713));
			runtime.printstring(gs);
			runtime.printbool(gs, (byte) (word32) dl_716);
			runtime.printstring(gs);
			runtime.printbool(gs, (byte) (word32) al_719);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_745, gs, SEQ(esi_687, edx_686));
			runtime.printstring(gs);
			runtime.printunlock(gs);
			eax_1004 = *((word32) eax_1004 + 0x00B0);
		}
		word32 ebp_433;
		word32 edi_1699;
		word32 esi_1698;
		runtime.lock(esi_103, gs, 0x08157590, out ebp_433, out esi_1698, out edi_1699);
		Eq_4 eax_440 = 0x00;
		while (true)
		{
			Eq_4 ecx_444 = g_t8145108;
			Eq_4 edx_445 = g_t814510C;
			if (eax_440 >= edx_445)
				break;
			if (eax_440 >= edx_445)
				runtime.panicindex(gs);
			Eq_4 ecx_476 = *((word32) ecx_444 + eax_440 * 0x04);
			Eq_4 ebx_478 = *((word32) ecx_476 + 0x0088);
			*((word32) ecx_476 + 24) == 0x00;
			runtime.readgstatus(ecx_476);
			Eq_4 esp_503 = <invalid>;
			struct Eq_44977 * eax_508 = *((word32) esp_503 + 0x0080);
			*((word32) esp_503 + 0x0078) = eax_508->t0054;
			*((word32) esp_503 + 116) = eax_508->t0050;
			Eq_4 ebx_513 = *((word32) esp_503 + 4);
			*((word32) esp_503 + 112) = ebx_513;
			*((word32) esp_503 + 0x0088) = eax_508->t0060;
			*((word32) esp_503 + 92) = eax_508->t0064;
			runtime.printlock(gs);
			esp_503->u0 = 0x080E0E1F;
			((word32) esp_503 + 4)->u0 = 0x03;
			runtime.printstring(gs);
			*esp_503 = *((word32) esp_503 + 116);
			*((word32) esp_503 + 4) = *((word32) esp_503 + 0x0078);
			Eq_363 ebx_24_8_541 = SLICE(ebx_513, word24, 8);
			runtime.printint(ebx_24_8_541, gs, *esp_503);
			esp_503->u0 = 135140803;
			((word32) esp_503 + 4)->u0 = 0x09;
			runtime.printstring(gs);
			*esp_503 = *((word32) esp_503 + 112);
			((word32) esp_503 + 4)->u0 = 0x00;
			runtime.printint(ebx_24_8_541, gs, *esp_503);
			esp_503->u0 = 0x080E0D85;
			((word32) esp_503 + 4)->u0 = 0x01;
			runtime.printstring(gs);
			*esp_503 = *((word32) esp_503 + 0x0088);
			*((word32) esp_503 + 4) = *((word32) esp_503 + 92);
			runtime.printstring(gs);
			esp_503->u0 = 0x080E0EB2;
			((word32) esp_503 + 4)->u0 = 0x04;
			runtime.printstring(gs);
			Eq_4 eax_600 = *((word32) esp_503 + 64);
			*esp_503 = eax_600;
			*((word32) esp_503 + 4) = eax_600 >> 0x1F;
			runtime.printint(ebx_24_8_541, gs, *esp_503);
			esp_503->u0 = 0x080E1533;
			((word32) esp_503 + 4)->u0 = 0x09;
			runtime.printstring(gs);
			Eq_4 eax_622 = *((word32) esp_503 + 56);
			*esp_503 = eax_622;
			*((word32) esp_503 + 4) = eax_622 >> 0x1F;
			runtime.printint(ebx_24_8_541, gs, *esp_503);
			esp_503->u0 = 0x080E0D9C;
			((word32) esp_503 + 4)->u0 = 0x01;
			runtime.printstring(gs);
			runtime.printunlock(gs);
			eax_440 = (word32) *((word32) esp_503 + 80) + 1;
		}
		word32 edx_1700;
		word32 ebx_1701;
		runtime.unlock(gs, 0x08157590, out edx_1700, out ebx_1701);
		word32 edx_1702;
		word32 ebx_1703;
		runtime.unlock(gs, 135549936, out edx_1702, out ebx_1703);
	}
}

// 08076C40: void runtime.mput(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stopm
void runtime.mput(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 0x00B4) = g_t81453F4;
	g_t81453F4 = dwArg04;
	g_t81453F8 = (word32) g_t81453F8 + 1;
	runtime.checkdead(gs);
}

// 08076C90: void runtime.globrunqget(Register (ptr32 Eq_2) gs, Stack Eq_51345 dwArg08)
// Called from:
//      runtime.findrunnable
//      runtime.schedule
void runtime.globrunqget(struct Eq_2 * gs, Eq_51345 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_51345 eax_17 = g_t8145420;
	if (eax_17 == 0x00)
		return;
	Eq_4 ecx_24 = g_t81575F0;
	if (ecx_24 == 0x00)
		runtime.panicdivide(gs);
	else
	{
		int32 eax_35;
		Eq_51345 ebx_32 = eax_17;
		if (ecx_24 != ~0x00)
			eax_35 = (int32) ((int64) eax_17 / ecx_24);
		else
			eax_35 = -eax_17;
		Eq_51345 ecx_46 = eax_35 + 0x01;
		if (ecx_46 <= eax_17)
			ebx_32 = ecx_46;
		Eq_51345 ecx_57 = dwArg08;
		if (dwArg08 <= 0x00 || ebx_32 <= dwArg08)
			ecx_57 = ebx_32;
		if (ecx_57 > 0x80)
			ecx_57.u0 = 0x80;
		Eq_51345 eax_74 = eax_17 - ecx_57;
		g_t8145420 = eax_74;
		if (eax_74 == 0x00)
			g_t814541C.u0 = 0x00;
		g_t8145418 = *((word32) g_t8145418 + 0x0068);
		int32 ecx_110;
		for (ecx_110 = ecx_57 - 0x01; ecx_110 > 0x00; --ecx_110)
		{
			Eq_4 eax_97 = g_t8145418;
			g_t8145418 = *((word32) eax_97 + 0x0068);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.runqput(gs, stackArg0, dwArg04, eax_97, 0x00);
		}
	}
}

// 08076D90: void runtime.pidleput(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.handoffp
//      runtime.findrunnable
//      runtime.procresize
void runtime.pidleput(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	runtime.runqempty(gs, stackArg0);
	if ((byte) (word32) bLoc08 == 0x00)
		runtime.throw(gs);
	else
	{
		*((word32) dwArg04 + 0x0C) = g_t814540C;
		g_t814540C = dwArg04;
		runtime/internal/atomic.Xadd(0x08145410, 0x01);
	}
}

// 08076E10: void runtime.pidleget(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.stopTheWorldWithSema
//      runtime.startm
//      runtime.findrunnable
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.checkdead
void runtime.pidleget(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = g_t814540C;
	if (eax_16 != 0x00)
	{
		g_t814540C = *((word32) eax_16 + 0x0C);
		runtime/internal/atomic.Xadd(0x08145410, ~0x00);
	}
}

// 08076E70: void runtime.runqempty(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.startm
//      runtime.handoffp
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.procresize
//      runtime.retake
//      runtime.pidleput
//      sync.runtime_canSpin
void runtime.runqempty(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Loaduintptr();
		runtime/internal/atomic.Load();
	} while (dwLoc18 != dwLoc18);
}

// 08076F20: void runtime.runqput(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 bArg0C)
// Called from:
//      runtime.ready
//      runtime.newproc1
//      runtime.globrunqget
void runtime.runqput(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_22;
	if ((byte) (word32) bArg0C != 0x00)
	{
		do
		{
			Eq_4 ecx_26 = *((word32) dwArg04 + 1808);
			runtime.(*guintptr).cas((word32) dwArg04 + 1808, ecx_26, dwArg08);
			dwLoc18 = ecx_26;
		} while ((byte) (word32) bLoc10 == 0x00);
		eax_22 = ecx_26;
		if (ecx_26 == 0x00)
			return;
	}
	else
		eax_22 = dwArg08;
	do
	{
		runtime/internal/atomic.Load();
		Eq_4 edx_68 = *((word32) dwArg04 + 780);
		if (edx_68 - dwLoc18 < 0x0100)
		{
			*((word32) dwArg04 + ((edx_68 & 0xFF) * 0x04 + 784)) = eax_22;
			runtime/internal/atomic.Store((word32) dwArg04 + 780, (word32) edx_68 + 1);
			return;
		}
		runtime.runqputslow(gs, dwArg04, eax_22, dwArg08, bArg0C);
		dwLoc18 = eax_22;
	} while ((byte) (word32) bLoc0C == 0x00);
}

// 08077020: void runtime.runqputslow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.runqput
void runtime.runqputslow(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp - 0x0198 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 * edi_175 = fp - 0x0204;
	word32 ecx_178;
	for (ecx_178 = 0x81; ecx_178 != 0x00; --ecx_178)
	{
		*edi_175 = 0x00;
		++edi_175;
	}
	uint32 edx_28 = dwArg10 - dwArg0C;
	if (edx_28 >> 0x01 != 0x80)
		runtime.throw(gs);
	else
	{
		uint32 ecx_167;
		for (ecx_167 = 0x00; ecx_167 < edx_28 >> 0x01; ++ecx_167)
		{
			Eq_4 ebp_162 = *((word32) dwArg04 + (((word32) dwArg0C + ecx_167 & 0xFF) * 0x04 + 784));
			if (ecx_167 >= 0x81)
				runtime.panicindex(gs);
			(fp - 0x0204)[ecx_167] = ebp_162;
			esi = fp - 0x0204;
		}
		runtime/internal/atomic.Cas((word32) dwArg04 + 776, dwArg0C, (word32) dwArg0C + (edx_28 >> 0x01));
		if ((byte) (word32) bLoc020C == 0x00)
			return;
		(fp - 0x0204)[edx_28 >> 0x01] = dwArg08;
		uint32 ecx_152 = 0x00;
		while (ecx_152 < edx_28 >> 0x01)
		{
			if (ecx_152 >= 0x81)
				runtime.panicindex(gs);
			struct Eq_60394 * ebx_141 = (fp - 0x0204)[ecx_152];
			uint32 ebp_144 = ecx_152 + 0x01;
			if (ebp_144 >= 0x81)
				runtime.panicindex(gs);
			esi = (fp - 0x0200)[ecx_152];
			ebx_141->t0068 = esi;
			ecx_152 = ebp_144;
		}
		word32 ebp_271;
		word32 edi_273;
		word32 esi_272;
		runtime.lock(esi, gs, 135549936, out ebp_271, out esi_272, out edi_273);
		Eq_4 ecx_93 = (fp - 0x0204)[edx_28 >> 0x01];
		((word32) ecx_93 + 0x0068)->u0 = 0x00;
		Eq_4 ebx_96 = g_t814541C;
		if (ebx_96 != 0x00)
			*((word32) ebx_96 + 0x0068) = dwLoc0204;
		else
			g_t8145418 = dwLoc0204;
		g_t814541C = ecx_93;
		g_t8145420 = (word32) g_t8145420 + 1 + (edx_28 >> 0x01);
		word32 edx_274;
		word32 ebx_275;
		runtime.unlock(gs, 135549936, out edx_274, out ebx_275);
	}
}

// 080771E0: void runtime.runqget(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.findrunnable
//      runtime.schedule
//      runtime.gcBgMarkWorker.func2
void runtime.runqget(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		Eq_4 ecx_21 = *((word32) dwArg04 + 1808);
		if (ecx_21 == 0x00)
		{
			do
			{
				runtime/internal/atomic.Load();
				if (*((word32) dwArg04 + 780) == dwLoc18)
					return;
				runtime/internal/atomic.Cas(dwLoc04, dwLoc18, (word32) dwLoc18 + 1);
			} while ((byte) (word32) bLoc10 == 0x00);
			return;
		}
		runtime.(*guintptr).cas((word32) dwArg04 + 1808, ecx_21, 0x00);
		dwLoc18 = ecx_21;
	} while ((byte) (word32) bLoc10 == 0x00);
}

// 080772C0: void runtime.runqgrab(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_60483) dwArg04, Stack (arr Eq_4) dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10)
// Called from:
//      runtime.runqsteal
void runtime.runqgrab(struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_60483 * dwArg04, Eq_4 dwArg08[], Eq_4 dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Load();
		uint32 eax_38 = dwLoc24 - dwLoc10;
		up32 edx_41 = eax_38 - (eax_38 >> 0x01);
		if (edx_41 != 0x00)
		{
			if (edx_41 > 0x80)
				continue;
			up32 esi_107;
			for (esi_107 = 0x00; esi_107 < edx_41; ++esi_107)
				dwArg08[(word32) dwArg0C + esi_107 & 0xFF] = dwArg04->a0310[(word32) dwLoc10 + esi_107 & 0xFF];
			runtime/internal/atomic.Cas(dwLoc04, dwLoc10, (word32) dwLoc10 + edx_41);
			dwLoc24 = dwLoc10;
			if ((byte) (word32) bLoc1C == 0x00)
				continue;
			return;
		}
		if ((byte) (word32) bArg10 == 0x00)
			return;
		Eq_4 edx_51 = dwArg04->t0710;
		if (edx_51 == 0x00)
			return;
		word32 edi_260;
		runtime.usleep(out edi_260);
		runtime.(*guintptr).cas(&dwArg04->t0710, edx_51, 0x00);
		dwLoc24 = edx_51;
	} while ((byte) (word32) bLoc1C == 0x00);
	dwArg08[dwArg0C & 0xFF] = edx_51;
}

// 08077430: void runtime.runqsteal(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_52029 bArg0C)
// Called from:
//      runtime.findrunnable
void runtime.runqsteal(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_52029 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 ecx_19 = *((word32) dwArg04 + 780);
	Eq_4 stackArg0 = <invalid>;
	runtime.runqgrab(gs, stackArg0, dwArg08, (word32) dwArg04 + 784, ecx_19, (byte) (word32) bArg0C);
	if (dwLoc18 == 0x00)
		return;
	uint32 ebp_43 = (word32) ecx_19 + (dwLoc18 - 0x01);
	Eq_4 ebp_46 = *((word32) dwArg04 + ((ebp_43 & 0xFF) * 0x04 + 784));
	if (dwLoc18 == 0x01)
		return;
	runtime/internal/atomic.Load();
	if (dwLoc18 - ecx_19 - 0x01 + ebp_43 >= 0x0100)
		runtime.throw(gs);
	else
		runtime/internal/atomic.Store(dwArg00, ebp_46);
}

// 08077540: void sync.runtime_procPin(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.(*Pool).getSlow
//      sync.(*Pool).pin
//      sync.(*Pool).pinSlow
void sync.runtime_procPin(struct Eq_2 * gs)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_8 + 0x0078) = (word32) *((word32) eax_8 + 0x0078) + 1;
}

// 08077570: void sync.runtime_procUnpin(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
//      sync.(*Pool).pinSlow
void sync.runtime_procUnpin(struct Eq_2 * gs)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	--*((word32) eax_8 + 0x0078);
}

// 08077590: void sync/atomic.runtime_procPin(Register (ptr32 Eq_2) gs)
// Called from:
//      sync/atomic.(*Value).Store
void sync/atomic.runtime_procPin(struct Eq_2 * gs)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_8 + 0x0078) = (word32) *((word32) eax_8 + 0x0078) + 1;
}

// 080775C0: void sync/atomic.runtime_procUnpin(Register (ptr32 Eq_2) gs)
// Called from:
//      sync/atomic.(*Value).Store
void sync/atomic.runtime_procUnpin(struct Eq_2 * gs)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	--*((word32) eax_8 + 0x0078);
}

// 080775E0: void sync.runtime_canSpin(Register (ptr32 Eq_2) gs, Stack int32 dwArg04)
// Called from:
//      sync.(*Mutex).Lock
void sync.runtime_canSpin(struct Eq_2 * gs, int32 dwArg04)
{
	if (dwArg04 >= 0x04 || (g_t8157608 <= 0x01 || g_t81575F0 <= (g_dw8145410 + 0x01) + g_dw8145414))
		return;
	runtime.runqempty(gs, dwLoc0C);
	if ((byte) (word32) bLoc04 == 0x00)
		;
}

// 08077650: void sync.runtime_doSpin()
// Called from:
//      sync.(*Mutex).Lock
void sync.runtime_doSpin()
{
	runtime.procyield(0x1E);
}

// 08077670: void runtime.(*randomOrder).reset(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_57056) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.procresize
void runtime.(*randomOrder).reset(struct Eq_2 * gs, struct Eq_57056 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg04->t0000 = dwArg08;
	dwArg04->t0008.u0 = 0x00;
	Eq_4 edx_115 = 0x01;
	while (edx_115 <= dwArg08)
	{
		runtime.gcd(gs, edx_115, dwArg08);
		if (dwLoc28 == 0x01)
		{
			Eq_4 ecx_48 = dwArg04->t000C;
			Eq_4 edx_102 = dwArg04->t0004;
			Eq_4 ebx_100 = dwArg04->t0008;
			if ((word32) ebx_100 + 1 > ecx_48)
			{
				word32 esi_208;
				runtime.growslice(gs, 0x080CF2A0, edx_102, ebx_100, ecx_48, (word32) ebx_100 + 1, out esi_208);
				dwArg04->t000C = dwLoc14;
				dwLoc28 = ebx_100;
				if (g_t81576F0 == 0x00)
					dwArg04->t0004 = dwLoc1C;
				else
					runtime.writebarrierptr(&dwArg04->t0004, dwLoc1C);
				ebx_100 = dwLoc18;
				edx_102 = dwLoc1C;
			}
			dwArg04->t0008 = (word32) ebx_100 + 1;
			*((word32) edx_102 + ebx_100 * 0x04) = edx_115;
		}
		edx_115 = (word32) edx_115 + 1;
	}
}

// 08077790: void runtime.gcd(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*randomOrder).reset
void runtime.gcd(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_16 = dwArg04;
	Eq_4 edx_17 = dwArg08;
	while (edx_17 != 0x00)
	{
		edx_17 = (uint32) ((uint64) (uint32) ecx_16 % edx_17);
		ecx_16 = edx_17;
	}
}

// 080777D0: void runtime.(*profAtomic).load(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*profBuf).canWriteRecord
//      runtime.(*profBuf).canWriteTwoRecords
//      runtime.(*profBuf).write
//      runtime.(*profBuf).wakeupExtra
void runtime.(*profAtomic).load(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 mm0_51;
	runtime/internal/atomic.Load64(dwArg04, out mm0_51);
}

// 08077810: Register word32 runtime.(*profAtomic).cas(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_136 qwArg08, Stack Eq_136 qwArg10)
// Called from:
//      runtime.(*profBuf).write
//      runtime.(*profBuf).wakeupExtra
word32 runtime.(*profAtomic).cas(struct Eq_2 * gs, Eq_4 dwArg04, Eq_136 qwArg08, Eq_136 qwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebx_30;
	word32 ebp_71;
	runtime/internal/atomic.Cas64(dwArg04, qwArg08, qwArg10, out ebx_30, out ebp_71);
	return ebx_30;
}

// 08077870: void runtime.(*profBuf).hasOverflow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).hasOverflow(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 mm0_56;
	runtime/internal/atomic.Load64((word32) dwArg04 + 16, out mm0_56);
}

// 080778B0: void runtime.(*profBuf).takeOverflow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).takeOverflow(struct Eq_2 * gs, Eq_4 dwArg04)
{
	word32 dwLoc28 = SLICE(qwLoc2C, word32, 32);
	word32 dwLoc2C = (word32) qwLoc2C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 mm0_179;
	runtime/internal/atomic.Load64((word32) dwArg04 + 16, out mm0_179);
	word64 mm0_42;
	runtime/internal/atomic.Load64((word32) dwArg04 + 24, out mm0_42);
	while (dwLoc2C != 0x00)
	{
		word32 ebp_76;
		word32 ebx_77;
		runtime/internal/atomic.Cas64((word32) dwArg04 + 16, qwLoc2C, SEQ(dwLoc28 + 0x01, 0x00), out ebx_77, out ebp_76);
		if ((byte) (word32) bLoc1C != 0x00)
			return;
		word64 mm0_180;
		runtime/internal/atomic.Load64((word32) dwArg04 + 16, out mm0_180);
		word64 mm0_181;
		runtime/internal/atomic.Load64((word32) dwArg04 + 24, out mm0_181);
	}
}

// 080779C0: void runtime.(*profBuf).incrementOverflow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).incrementOverflow(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 qwArg08)
{
	up32 dwLoc20 = (word32) qwLoc20;
	word32 dwLoc1C = SLICE(qwLoc20, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		word64 mm0_168;
		runtime/internal/atomic.Load64((word32) dwArg04 + 16, out mm0_168);
		if (dwLoc20 == 0x00)
		{
			runtime/internal/atomic.Store64(dwLoc28, (word32) dwArg04 + 24, qwArg08);
			runtime/internal/atomic.Store64(dwLoc28, (word32) dwArg04 + 16, SEQ(dwLoc1C + 0x01, 0x01));
			return;
		}
		if (dwLoc20 == ~0x00)
			return;
		word32 ebp_88;
		word32 ebx_167;
		runtime/internal/atomic.Cas64((word32) dwArg04 + 16, qwLoc20, SEQ((bool) (dwLoc20 < 0x01) + dwLoc1C, dwLoc20 + 0x01), out ebx_167, out ebp_88);
	} while ((byte) (word32) bLoc10 == 0x00);
}

// 08077A90: void runtime.(*profBuf).canWriteRecord(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).canWriteRecord(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*profAtomic).load(gs, dwArg04);
	runtime.(*profAtomic).load(gs, (word32) dwArg04 + 8);
	if ((word32) *((word32) dwArg04 + 56) + (((dwLoc0C >> 0x02) - (dwLoc0C >> 0x02) << 0x02) >> 0x02) < 0x01)
		return;
	Eq_4 ebx_63 = *((word32) dwArg04 + 44);
	word32 edi_71 = Mem37[dwArg04 + 0x24:word32] + dwArg08;
	if (ebx_63 != 0x00)
		return;
	runtime.panicdivide(gs);
}

// 08077B60: void runtime.(*profBuf).canWriteTwoRecords(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).canWriteTwoRecords(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*profAtomic).load(gs, dwArg04);
	runtime.(*profAtomic).load(gs, (word32) dwArg04 + 8);
	if ((word32) *((word32) dwArg04 + 56) + (((dwLoc10 >> 0x02) - (dwLoc10 >> 0x02) << 0x02) >> 0x02) < 0x02)
		return;
	Eq_4 edx_69 = *((word32) dwArg04 + 36);
	Eq_4 ebx_63 = *((word32) dwArg04 + 44);
	word32 edi_71 = (word32) edx_69 + dwArg08;
	if (ebx_63 == 0x00)
		runtime.panicdivide(gs);
	else
	{
		uint32 edx_80 = (uint32) ((uint64) (uint32) dwLoc14 % ebx_63);
		if (edi_71 + 0x02 + edx_80 > ebx_63)
			edx_80 = 0x00;
	}
}

// 08077C60: Register word32 runtime.(*profBuf).write(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 word32) dwArg08, Stack Eq_4 qwArg0C, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack (ptr32 word32) dwArg20, Stack Eq_4 dwArg24)
// Called from:
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addExtra
//      runtime.(*profBuf).write
word32 runtime.(*profBuf).write(struct Eq_2 * gs, Eq_4 dwArg04, word32 * dwArg08, Eq_4 qwArg0C, Eq_4 dwArg14, Eq_4 dwArg18, word32 * dwArg20, Eq_4 dwArg24)
{
	byte bLoc44 = (byte) dwLoc44;
	word32 dwArg0C = (word32) qwArg0C;
	word32 dwArg10 = SLICE(qwArg0C, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return ebx;
	if (dwArg18 > *((word32) dwArg04 + 36))
		runtime.throw(gs);
	Eq_4 dwLoc48_472;
	Eq_4 dwLoc4C_469;
	runtime.(*profBuf).hasOverflow(gs, dwArg04);
	byte al_47 = (byte) (word32) bLoc4C;
	bool Z_116 = SLICE(cond(al_47), bool, 2);
	Eq_4 dwLoc48_675 = dwLoc48;
	if (al_47 != 0x00)
	{
		runtime.(*profBuf).canWriteTwoRecords(gs, dwArg04, 0x01, dwArg24);
		dwLoc4C_469.u0 = 0x01;
		dwLoc48_472 = dwArg24;
		if ((byte) (word32) bLoc44 != 0x00)
		{
			runtime.(*profBuf).takeOverflow(gs, dwArg04);
			if (true)
			{
				runtime.(*profBuf).write(gs, dwArg04, null, dwArg24, 0x00, 0x00, fp - 0x20, 0x01);
				dwLoc4C_469.u0 = 0x00;
				dwLoc48_472 = dwArg24;
				bLoc3C = 0x00;
			}
l08077CD0:
			runtime.(*profAtomic).load(gs, dwArg04);
			runtime.(*profAtomic).load(gs, (word32) dwArg04 + 8);
			Eq_4 ebx_206 = *((word32) dwArg04 + 52);
			Eq_4 ebp_207 = *((word32) dwArg04 + 56);
			if (ebp_207 == 0x00)
				runtime.panicdivide(gs);
			else
			{
				uint32 edx_218 = (uint32) ((uint64) (uint32) (dwLoc48_472 >> 0x02) % ebp_207);
				if (dwArg08 != null)
					*((word32) ebx_206 + edx_218 * 0x04) = *dwArg08;
				Eq_4 edx_228 = *((word32) dwArg04 + 44);
				Eq_4 ebx_229 = *((word32) dwArg04 + 40);
				if (edx_228 == 0x00)
					runtime.panicdivide(gs);
				else
				{
					Eq_61247 eax_249;
					Eq_4 edx_240 = (uint32) ((uint64) (uint32) dwLoc4C_469 % edx_228);
					if (Mem227[dwArg04 + 0x24:word32] + edx_240 + 0x02 + dwArg24 > edx_228)
					{
						struct Eq_61262 * eax_252 = (word32) ebx_229 + edx_240 * 0x08;
						eax_252->dw0000 = 0x00;
						eax_252->dw0004 = 0x00;
						eax_249 = *((word32) dwArg04 + 44) - edx_240;
						edx_240.u0 = 0x00;
					}
					else
						eax_249.u0 = 0x00;
					Eq_4 ebx_262 = *((word32) dwArg04 + 48);
					Eq_4 ebp_263 = *((word32) dwArg04 + 44);
					Eq_4 esi_264 = *((word32) dwArg04 + 40);
					if (edx_240 > ebp_263)
						runtime.panicslice(gs);
					else
					{
						Eq_61281 ebx_273 = ebx_262 - edx_240;
						int32 ebx_278 = -ebx_273 >> 0x1F & edx_240 << 0x03;
						Eq_61291 ebp_272 = ebp_263 - edx_240;
						ui32 edx_279 = (word32) esi_264 + ebx_278;
						Eq_4 eax_280 = *((word32) dwArg04 + 36);
						if (ebp_272 <= 0x00)
							runtime.panicindex(gs);
						else
						{
							*((word32) esi_264 + ebx_278) = (word32) eax_280 + ((word32) dwArg24 + 2);
							(word32) esi_264 + 4 + ebx_278 = 0x00;
							if (ebp_272 <= 0x01)
								runtime.panicindex(gs);
							else
							{
								(word32) esi_264 + 8 + ebx_278 = dwArg0C;
								(word32) esi_264 + 0x0C + ebx_278 = dwArg10;
								Eq_4 eax_295 = *((word32) dwArg04 + 36);
								if (eax_295 < 0x00 || (word32) eax_295 + 2 > ebx_273)
									runtime.panicslice(gs);
								else
								{
									Eq_4 ebx_309 = (0x02 - ebx_273 >> 0x1F & 0x10) + edx_279;
									Eq_4 esi_310 = dwArg18;
									if (eax_295 <= dwArg18)
										esi_310 = eax_295;
									Eq_4 esi_321 = esi_310 << 0x03;
									word32 esi_679;
									word32 ebp_678;
									word32 edi_680;
									runtime.memmove(ebx_309, dwArg14, esi_321, out ebp_678, out esi_679, out edi_680);
									Eq_4 ebx_338 = esi_310;
									while (ebx_338 < *((word32) dwArg04 + 36))
									{
										if ((word32) ebx_338 + 2 >= ebp_272)
											runtime.panicindex(gs);
										struct Eq_61370 * ebp_450 = edx_279 + 0x10 + ebx_338 * 0x08;
										ebp_450->dw0000 = 0x00;
										ebp_450->dw0004 = 0x00;
										ebx_338 = (word32) ebx_338 + 1;
									}
									word32 * ebp_347 = dwArg20;
									Eq_4 esi_348 = 0x00;
									while (esi_348 < dwArg24)
									{
										word32 edi_422 = *ebp_347;
										Eq_61291 edx_425 = (word32) esi_348 + ((word32) (*((word32) dwArg04 + 36)) + 2);
										if (edx_425 >= ebp_272)
											runtime.panicindex(gs);
										struct Eq_61430 * edi_432 = edx_279 + edx_425 * 0x08;
										edi_432->dw0000 = edi_422;
										edi_432->dw0004 = 0x00;
										++ebp_347;
										esi_348 = (word32) esi_348 + 1;
									}
									do
									{
										runtime.(*profAtomic).load(gs, (word32) dwArg04 + 8);
										word32 ebx_389 = runtime.(*profAtomic).cas(gs, (word32) dwArg04 + 8, SEQ(esi_321, dwArg14), SEQ((esi_321 >>u 0x02) + 0x01 << 0x02, dwArg24 + eax_249 + Mem370[dwArg04 + 0x24:word32] + 0x02 + dwArg14));
									} while ((byte) (word32) bLoc3C == 0x00);
									if ((esi_321 & 0x01) != 0x00)
										ebx_389 = runtime.notewakeup(gs, (word32) dwArg04 + 84);
									return ebx_389;
								}
							}
						}
					}
				}
			}
		}
		Z_116 = SLICE(cond((byte) (word32) al_47), bool, 2);
		dwLoc48_675 = dwArg24;
	}
	byte bLoc48_496 = (byte) dwLoc48_675;
	if (!Z_116)
	{
		runtime.(*profBuf).canWriteRecord(gs, dwArg04, dwArg24);
		dwLoc4C_469 = dwArg24;
		dwLoc48_472 = dwLoc48_675;
		if ((byte) (word32) bLoc48_496 != 0x00)
			goto l08077CD0;
	}
	runtime.(*profBuf).incrementOverflow(gs, dwArg04, qwArg0C);
	return runtime.(*profBuf).wakeupExtra(gs, dwArg04);
}

// 08078060: Register word32 runtime.(*profBuf).wakeupExtra(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*profBuf).write
word32 runtime.(*profBuf).wakeupExtra(struct Eq_2 * gs, Eq_4 dwArg04)
{
	ui32 dwLoc18 = SLICE(qwLoc1C, word32, 32);
	uint32 dwLoc1C = (word32) qwLoc1C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime.(*profAtomic).load(gs, (word32) dwArg04 + 8);
		word32 ebx_106 = runtime.(*profAtomic).cas(gs, (word32) dwArg04 + 8, qwLoc1C, SEQ(dwLoc18 | 0x02, dwLoc1C));
	} while ((byte) (word32) bLoc0C == 0x00);
	if ((dwLoc18 & 0x01) != 0x00)
		ebx_106 = runtime.notewakeup(gs, (word32) dwArg04 + 84);
	return ebx_106;
}

// 080780E0: Register word32 syscall.runtime_envs(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      syscall.init
word32 syscall.runtime_envs(struct Eq_2 * gs, ptr32 & esiOut, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_50;
	runtime.newobject(gs, 0x080CAE20);
	Eq_4 eax_27 = dwLoc28;
	Eq_4 ecx_28 = g_t814512C;
	if (ecx_28 <= 0x00)
		edx_50.u0 = 0x00;
	else
	{
		word32 esi_129;
		runtime.growslice(gs, 135066016, dwLoc28, 0x00, 0x00, ecx_28, out esi_129);
		edx_50 = dwLoc10;
		eax_27 = dwLoc18;
	}
	if (ecx_28 > edx_50)
		runtime.panicslice(gs);
	else
	{
		ptr32 edi_81;
		ptr32 esi_82;
		word32 ebx_80 = runtime.typedslicecopy(gs, 135066016, eax_27, ecx_28, g_t8145128, g_t814512C, out esi_82, out edi_81);
		esiOut = esi_82;
		ediOut = edi_81;
		return ebx_80;
	}
}

// 080781D0: void os.runtime_args(Register (ptr32 Eq_2) gs)
// Called from:
//      os.init.0
void os.runtime_args(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_50;
	runtime.newobject(gs, 0x080CAE20);
	Eq_4 eax_27 = dwLoc28;
	Eq_4 ecx_28 = g_t814511C;
	if (ecx_28 <= 0x00)
		edx_50.u0 = 0x00;
	else
	{
		word32 esi_127;
		runtime.growslice(gs, 135066016, dwLoc28, 0x00, 0x00, ecx_28, out esi_127);
		edx_50 = dwLoc10;
		eax_27 = dwLoc18;
	}
	if (ecx_28 > edx_50)
		runtime.panicslice(gs);
	else
	{
		word32 esi_128;
		word32 edi_129;
		runtime.typedslicecopy(gs, 135066016, eax_27, ecx_28, g_t8145118, g_t814511C, out esi_128, out edi_129);
	}
}

// 080782C0: void runtime.gotraceback(Stack Eq_4 dwArg00)
// Called from:
//      runtime.dopanic_m
//      runtime.sighandler
//      runtime.gentraceback
//      runtime.showframe
//      runtime.tracebackothers
void runtime.gotraceback(Eq_4 dwArg00)
{
	runtime/internal/atomic.Load();
	Eq_4 eax_16 = *((word32) dwArg00 + 24);
	*((word32) eax_16 + 0x006C) <= 0x00;
	(byte) (word32) *((word32) eax_16 + 461) == 0x00;
}

// 08078340: void runtime.args(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      main
void runtime.args(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_t8157594 = dwArg04;
	if (g_t81576F0 == 0x00)
		g_t8144FB0 = dwArg08;
	else
		runtime.writebarrierptr(135548848, dwArg08);
	runtime.sysargs(gs, dwArg04, dwArg08);
}

// 080783B0: void runtime.goargs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.goargs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_20 = g_t8157594;
	Eq_4 eax_22 = g_t8157594;
	word32 edi_158;
	runtime.makeslice(gs, 135066016, eax_20, eax_22, out edi_158);
	g_t814511C = dwLoc0C;
	g_dw8145120 = dwLoc08;
	Eq_4 dwLoc18_116 = eax_20;
	if (g_t81576F0 == 0x00)
		g_t8145118 = dwLoc10;
	else
	{
		runtime.writebarrierptr(0x08145118, dwLoc10);
		dwLoc18_116 = dwLoc10;
	}
	Eq_4 eax_106 = 0x00;
	while (eax_106 < g_t8157594)
	{
		runtime.gostringnocopy();
		Eq_4 eax_78 = g_t8145118;
		if (eax_106 >= g_t814511C)
			runtime.panicindex(gs);
		*((word32) eax_78 + (eax_106 * 0x08 + 4)) = eax_22;
		Eq_4 eax_89 = (word32) eax_78 + eax_106 * 0x08;
		if (g_t81576F0 == 0x00)
			*eax_89 = dwLoc18_116;
		else
			runtime.writebarrierptr(eax_89, dwLoc18_116);
		eax_106 = (word32) eax_106 + 1;
	}
}

// 080784B0: void runtime.goenvs_unix(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.goenvs
void runtime.goenvs_unix(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = 0x00;
	while (*((word32) g_t8144FB0 + ((word32) g_t8157594 + ((word32) eax_17 + 1)) * 0x04) != 0x00)
		eax_17 = (word32) eax_17 + 1;
	word32 edi_43;
	Eq_4 ebx_105 = runtime.makeslice(gs, 135066016, eax_17, eax_17, out edi_43);
	g_t814512C = dwLoc10;
	g_dw8145130 = dwLoc0C;
	Eq_4 dwLoc1C_142 = eax_17;
	if (g_t81576F0 == 0x00)
		g_t8145128 = dwLoc14;
	else
	{
		runtime.writebarrierptr(0x08145128, dwLoc14);
		dwLoc1C_142 = dwLoc14;
	}
	Eq_4 eax_129 = 0x00;
	while (eax_129 < eax_17)
	{
		runtime.gostring(ebx_105, gs, *((word32) g_t8144FB0 + ((word32) eax_129 + ((word32) g_t8157594 + 1)) * 0x04));
		Eq_4 eax_102 = g_t8145128;
		ebx_105 = eax_17;
		if (eax_129 >= g_t814512C)
			runtime.panicindex(gs);
		*((word32) eax_102 + (eax_129 * 0x08 + 4)) = eax_17;
		Eq_4 eax_111 = (word32) eax_102 + eax_129 * 0x08;
		if (g_t81576F0 == 0x00)
			*eax_111 = dwLoc1C_142;
		else
			runtime.writebarrierptr(eax_111, dwLoc1C_142);
		eax_129 = (word32) eax_129 + 1;
	}
}

// 080785D0: Register word64 runtime.testAtomic64(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.check
word64 runtime.testAtomic64(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_dw81576C0 = 0x2A;
	g_dw81576C4 = 0x00;
	g_dw81576B8 = 0x00;
	g_dw81576BC = 0x00;
	runtime.prefetcht0();
	runtime.prefetcht1();
	runtime.prefetcht2();
	runtime.prefetchnta();
	word32 ebx_471;
	word32 ebp_472;
	runtime/internal/atomic.Cas64(0x081576C0, SEQ(g_dw81576BC, g_dw81576B8), 0x01, out ebx_471, out ebp_472);
	if ((byte) (word32) bLoc14 != 0x00)
		runtime.throw(gs);
	else
	{
		word32 eax_69 = g_dw81576BC;
		word32 ecx_70 = g_dw81576B8;
		if ((byte) (SEQ(SLICE(ecx_70, word24, 8), ecx_70 != 0x00) | SEQ(SLICE(eax_69, word24, 8), eax_69 != 0x00)) != 0x00)
			runtime.throw(gs);
		else
		{
			g_dw81576B8 = 0x2A;
			g_dw81576BC = 0x00;
			word32 ecx_99 = g_dw81576BC;
			word32 edx_100 = g_dw81576B8;
			word32 ebx_473;
			word32 ebp_474;
			runtime/internal/atomic.Cas64(0x081576C0, SEQ(ecx_99, edx_100), 0x01, out ebx_473, out ebp_474);
			if ((byte) (word32) bLoc14 == 0x00)
				runtime.throw(gs);
			else
			{
				word32 eax_128 = g_dw81576BC;
				word32 ecx_129 = g_dw81576B8;
				if ((byte) (SEQ(SLICE(ecx_129, word24, 8), ecx_129 != 0x2A) | SEQ(SLICE(eax_128, word24, 8), eax_128 != 0x00)) == 0x00)
				{
					word32 eax_145 = g_dw81576C4;
					word32 ecx_146 = g_dw81576C0;
					if ((byte) (SEQ(SLICE(ecx_146, word24, 8), ecx_146 != 0x01) | SEQ(SLICE(eax_145, word24, 8), eax_145 != 0x00)) == 0x00)
					{
						word64 mm0_475;
						runtime/internal/atomic.Load64(0x081576C0, out mm0_475);
						if ((byte) (SEQ(SLICE(ecx_99, word24, 8), ecx_99 != 0x00) | SEQ(SLICE(edx_100, word24, 8), edx_100 != 0x01)) != 0x00)
							runtime.throw(gs);
						else
						{
							runtime/internal/atomic.Store64(dwLoc2C, 0x081576C0, 0x10000000001);
							word64 mm0_476;
							runtime/internal/atomic.Load64(0x081576C0, out mm0_476);
							if (false)
								runtime.throw(gs);
							else
							{
								word32 ebx_477;
								word32 ebp_478;
								runtime/internal/atomic.Xadd64(0x081576C0, 0x01, 0x0100, out ebx_477, out ebp_478);
								if (true)
									runtime.throw(gs);
								else
								{
									word64 mm0_479;
									runtime/internal/atomic.Load64(0x081576C0, out mm0_479);
									if (true)
										runtime.throw(gs);
									else
									{
										runtime/internal/atomic.Xchg64(0x081576C0, 0x30000000003);
										if (true)
											runtime.throw(gs);
										else
										{
											word64 mm0_370;
											runtime/internal/atomic.Load64(0x081576C0, out mm0_370);
											if (true)
												return mm0_370;
											runtime.throw(gs);
										}
									}
								}
							}
						}
					}
				}
				runtime.throw(gs);
			}
		}
	}
}

// 080789A0: Register word64 runtime.check(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm0)
// Called from:
//      main
word64 runtime.check(Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm0)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_661 xmm0_23 = __xorps(xmm0, xmm0);
	__xorps(xmm0_23, xmm0_23);
	runtime.timediv(esi, (struct Eq_13398 *) 1264045617, (struct Eq_13398 *) 0x0B3A, 1000000000, fp - 0x1C);
	byte bLoc34_486 = (byte) (fp - 0x1C);
	if (dwLoc30 != 0x3039 || true)
		runtime.throw(gs);
	else
	{
		runtime/internal/atomic.Cas(fp - 44, 0x01, 0x02);
		if ((byte) (word32) bLoc34_486 == 0x00)
			runtime.throw(gs);
		else if (true)
			runtime.throw(gs);
		else
		{
			runtime/internal/atomic.Cas(fp - 44, 0x05, 0x06);
			if ((byte) (word32) bLoc34_486 != 0x00)
				runtime.throw(gs);
			else if (false)
				runtime.throw(gs);
			else
			{
				runtime/internal/atomic.Cas(fp - 44, ~0x00, ~0x01);
				if ((byte) (word32) bLoc34_486 == 0x00)
					runtime.throw(gs);
				else if (true)
					runtime.throw(gs);
				else
				{
					runtime.casp(fp - 0x04, 0x00, 0x00);
					if ((byte) (word32) bLoc34_486 != 0x00)
						runtime.throw(gs);
					else
					{
						runtime.casp(fp - 0x04, 4275876131, 4275876132);
						if ((byte) (word32) bLoc34_486 == 0x00)
							runtime.throw(gs);
						else if (true)
							runtime.throw(gs);
						else
						{
							runtime/internal/atomic.Or8(fp - 0x27, 0xF0);
							if (false || (true || (false || false)))
								runtime.throw(gs);
							else
							{
								runtime/internal/atomic.And8(fp - 0x27, 0x01);
								if (false || (true || (false || false)))
									runtime.throw(gs);
								else
								{
									Eq_62189 xmm0_320 = (uint128) (uint64) 1.84467440737096e+19;
									if ((real64) xmm0_320 == xmm0_320)
									{
										if (!PARITY_EVEN((real64) xmm0_320 - xmm0_320))
											runtime.throw(gs);
										if (!PARITY_EVEN((real64) xmm0_320 - xmm0_320))
											runtime.throw(gs);
									}
									uint128 xmm0_347 = (uint128) (uint64) 1.84467440737096e+19;
									Eq_62208 xmm1_348 = (uint128) (uint64) 1.84467440737096e+19;
									if ((real64) xmm0_347 == xmm1_348)
									{
										if (!PARITY_EVEN((real64) xmm0_347 - xmm1_348))
											runtime.throw(gs);
										if (!PARITY_EVEN((real64) xmm0_347 - xmm1_348))
											runtime.throw(gs);
									}
									Eq_62232 xmm0_375 = (uint128) (uint32) 4.294967e+09F;
									if ((real32) xmm0_375 != xmm0_375 || PARITY_EVEN((real32) xmm0_375 - xmm0_375))
									{
										uint128 xmm0_393 = (uint128) (uint32) 4.294967e+09F;
										Eq_62251 xmm1_394 = (uint128) (uint32) 4.294967e+09F;
										if ((real32) xmm0_393 != xmm1_394 || PARITY_EVEN((real32) xmm0_393 - xmm1_394))
										{
											word64 mm0_416 = runtime.testAtomic64(gs);
											runtime.round2(gs, 0x0800);
											if (true)
												runtime.throw(gs);
											else
											{
												runtime.checkASM();
												if (0x00 != 0x00)
													return mm0_416;
												runtime.throw(gs);
											}
										}
										else
											runtime.throw(gs);
									}
									else
										runtime.throw(gs);
								}
							}
						}
					}
				}
			}
		}
	}
}

// 08078EC0: void runtime.parsedebugvars(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.parsedebugvars(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_dw8157724 = 0x01;
	g_t8157744.u0 = 0x01;
	runtime.gogetenv(gs, 135139898, 0x07);
	Eq_4 eax_238 = dwLoc34;
	Eq_4 ecx_239 = dwLoc38;
	while (true)
	{
		byte bLoc30_362 = (byte) dwLoc30;
		if (eax_238 == 0x00)
			break;
		Eq_4 ecx_120;
		Eq_4 eax_122;
		Eq_4 edx_121;
		runtime.index(gs, ecx_239, eax_238, 0x080E0D89, 0x01);
		if (dwLoc30 < 0x00)
		{
			eax_122.u0 = 0x00;
			ecx_120.u0 = 0x00;
			edx_121 = eax_238;
		}
		else
		{
			if (dwLoc30 > eax_238 || (word32) dwLoc30 + 1 > eax_238)
				runtime.panicslice(gs);
			Eq_4 ecx_111 = eax_238 - ((word32) dwLoc30 + 1);
			ecx_120 = ecx_111;
			edx_121 = dwLoc30;
			eax_122 = (word32) ecx_239 + (-ecx_111 >> 0x1F & (word32) dwLoc30 + 1);
		}
		runtime.index(gs, ecx_239, edx_121, 0x080E0D91, 0x01);
		dwLoc38.u0 = 0x080E0D91;
		dwLoc34.u0 = 0x01;
		if (dwLoc30 >= 0x00)
		{
			if (dwLoc30 > edx_121 || (word32) dwLoc30 + 1 > edx_121)
				runtime.panicslice(gs);
			Eq_4 ecx_165 = edx_121 - ((word32) dwLoc30 + 1);
			Eq_4 ecx_172 = (word32) ecx_239 + (-ecx_165 >> 0x1F & (word32) dwLoc30 + 1);
			if (dwLoc30 != 0x0E)
			{
l08078FCA:
				Eq_4 edx_252 = ecx_239;
				Eq_4 eax_245 = dwLoc30;
				struct Eq_62393 * ebp_223 = g_ptr81426C0;
				int32 esi_224 = g_dw81426C4;
				int32 edi_227 = 0x00;
				esi_231 = esi_224;
				while (true)
				{
					int32 esi_231;
					if (edi_227 >= esi_231)
						break;
					union Eq_4 * ebx_241 = ebp_223->dw0008;
					Eq_4 ebx_243 = ebp_223->dw0000;
					Eq_4 ecx_244 = ebp_223->dw0004;
					if (ecx_244 == eax_245)
					{
						word32 esi_457;
						word32 edi_458;
						runtime.eqstring(ebx_243, ecx_244, edx_252, out esi_457, out edi_458);
						dwLoc38 = edx_252;
						dwLoc34 = eax_245;
						byte bLoc34_383 = (byte) eax_245;
						if ((byte) (word32) bLoc30_362 == 0x00)
						{
							eax_245 = dwLoc30;
							edx_252 = ecx_239;
							esi_231 = esi_224;
						}
						else
						{
							word32 esi_459;
							runtime.atoi32(gs, ecx_172, ecx_165, out esi_459);
							dwLoc34 = eax_245;
							if ((byte) (word32) bLoc34_383 != 0x00)
								*ebx_241 = (union Eq_4 *) edx_252;
							eax_245 = dwLoc30;
							edx_252 = ecx_239;
							esi_231 = esi_224;
						}
					}
					++ebp_223;
					++edi_227;
				}
				goto l08078F0D;
			}
			word32 esi_455;
			word32 edi_456;
			runtime.eqstring(ecx_239, dwLoc30, 0x080E2188, out esi_455, out edi_456);
			dwLoc38.u0 = 0x080E2188;
			dwLoc34.u0 = 0x0E;
			if ((byte) (word32) bLoc30_362 == 0x00)
				goto l08078FCA;
			word32 esi_460;
			runtime.atoi(gs, ecx_172, ecx_165, out esi_460);
			dwLoc34.u0 = 0x0E;
			if (0x0E != 0x00)
				g_t8136004.u0 = 0x080E2188;
		}
l08078F0D:
		eax_238 = ecx_120;
		ecx_239 = eax_122;
	}
	runtime.gogetenv(gs, 0x080E1A82, 11);
	runtime/debug.SetTraceback(gs, dwLoc38, dwLoc34);
	g_dw8157654 = g_dw8136020;
	if (g_dw8157724 > 0x01)
	{
		g_b81576F5 = 0x01;
		g_t81576F0.u0 = 0x01;
	}
}

// subject_text_0003.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text_0003.h"

// 08079190: void runtime/debug.SetTraceback(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.parsedebugvars
void runtime/debug.SetTraceback(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 eax_148;
	if (dwArg08 >= 0x04)
	{
		if (dwArg08 == 0x04)
		{
			runtime.cmpstring(dwArg04, dwArg08, 0x080E0F3E, 0x04);
			dwLoc0C.u1 = 0x080E0F3E;
			bLoc08 = 0x04;
			if (dwLoc04 <= 0x00)
				goto l080791B6;
		}
		if (dwArg08 == 0x05 && (*dwArg04 == 1935766115 && (byte) ((word32) (*((word32) dwArg04 + 4))) == 0x68))
		{
			eax_148 = 11;
			goto l080791BF;
		}
		bool Z_59 = SLICE(cond(dwArg08 - 0x06), bool, 2);
		if (dwArg08 == 0x06)
		{
			if (*dwArg04 == 0x676E6973)
			{
				if ((word16) (word32) *((word32) dwArg04 + 4) == 0x656C)
				{
l080791BA:
					eax_148 = 0x04;
					goto l080791BF;
				}
				Z_59 = SLICE(cond(dwArg08 - 0x06), bool, 2);
			}
			else
				Z_59 = SLICE(cond(dwArg08 - 0x06), bool, 2);
		}
		if (!Z_59 && (*dwArg04 == 0x74737973 && (word16) ((word32) (*((word32) dwArg04 + 4))) == 0x6D65))
		{
			eax_148 = 0x0A;
			goto l080791BF;
		}
l0807922E:
		word32 esi_276;
		runtime.atoi(gs, dwArg04, dwArg08, out esi_276);
		if ((byte) (word32) bLoc08 != 0x00)
			eax_148 = dwLoc0C << 0x02 | 0x02;
		else
			eax_148 = 0x02;
l080791BF:
		if ((byte) (word32) g_b8157572 != 0x00 || (byte) ((word32) g_b8157570) != 0x00)
			eax_148 |= 0x01;
		runtime/internal/atomic.Store(0x08136020, g_dw8157654 | eax_148);
	}
	else
	{
l080791B6:
		if (dwArg08 == 0x00)
			goto l080791BA;
		bool Z_106;
		if (dwArg08 == 0x03)
		{
			if ((word16) (word32) *dwArg04 == 0x6C61)
			{
				if ((byte) (word32) *((word32) dwArg04 + 2) == 0x6C)
				{
					eax_148 = 0x06;
					goto l080791BF;
				}
				Z_106 = SLICE(cond(dwArg08 - 0x04), bool, 2);
			}
			else
				Z_106 = SLICE(cond(dwArg08 - 0x04), bool, 2);
		}
		else
			Z_106 = SLICE(cond(dwArg08 - 0x04), bool, 2);
		if (!Z_106 && *dwArg04 == 0x656E6F6E)
		{
			eax_148 = 0x00;
			goto l080791BF;
		}
		goto l0807922E;
	}
}

// 08079340: void runtime.timediv(Register Eq_4 esi, Stack (ptr32 Eq_13398) dwArg04, Stack (ptr32 Eq_13398) dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_4) dwArg10)
// Called from:
//      runtime.futexsleep
//      runtime.check
void runtime.timediv(Eq_4 esi, struct Eq_13398 * dwArg04, struct Eq_13398 * dwArg08, Eq_4 dwArg0C, union Eq_4 * dwArg10)
{
	Eq_62645 ecx_13 = 0x1E;
	int64 edx_ebx_239 = dwArg04;
	while (true)
	{
		Eq_4 ebx_24 = (word32) edx_ebx_239;
		int32 edx_20 = SLICE(edx_ebx_239, word32, 32);
		if (ecx_13 < 0x00)
			break;
		Eq_62673 edi_83 = ecx_13 - 0x20;
		Eq_62676 ebx_88 = -edi_83;
		ui32 edi_104 = 0x00 - (ecx_13 < 0x20);
		ui32 ebx_115 = 0x00 - (edi_83 < 0x20);
		int32 esi_117 = dwArg0C >> (byte) ebx_88 & 0x00 - (ebx_88 < 0x20) | (dwArg0C >> 0x1F) << (byte) ecx_13 & edi_104 | dwArg0C << (byte) edi_83 & ebx_115;
		Eq_4 edx_126 = dwArg0C << (byte) ecx_13 & edi_104;
		Eq_4 ebp_121 = ebx_24;
		int32 edi_141 = edx_20;
		if ((byte) (SEQ(SLICE(ebx_115, word24, 8), edx_20 == esi_117) & SEQ(SLICE(edi_104, word24, 8), ebx_24 >= edx_126) | SEQ(SLICE(ecx_13, word24, 8), edx_20 > esi_117)) != 0x00)
		{
			ui64 edi_ebp_184 = edx_ebx_239 - SEQ(esi_117, edx_126);
			ebp_121 = (word32) edi_ebp_184;
			edi_141 = SLICE(edi_ebp_184, word32, 32);
		}
		--ecx_13;
		esi = dwArg0C;
		edx_ebx_239 = SEQ(edi_141, ebp_121);
	}
	if ((byte) (SEQ(SLICE(esi, word24, 8), edx_20 == dwArg0C >> 0x1F) & SEQ(SLICE(dwArg0C, word24, 8), ebx_24 >= dwArg0C) | SEQ(SLICE(dwArg0C >> 0x1F, word24, 8), edx_20 > dwArg0C >> 0x1F)) == 0x00)
	{
		if (dwArg10 != null)
			*dwArg10 = (union Eq_4 *) ebx_24;
	}
	else if (dwArg10 != null)
		*dwArg10 = (union Eq_4 *) 0x00;
}

// 08079460: void reflect.typelinks(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.typesByString
void reflect.typelinks(struct Eq_2 * gs)
{
	while (fp - 0x0C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.activeModules();
	runtime.newobject(gs, 0x080CBE60);
	if (dwLoc88 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		Eq_4 dwLoc88_351;
		Eq_4 ebx_50 = *((char *) *dwLoc8C + 100);
		word32 * esi_63 = (char *) dwLoc8C + (0x01 - dwLoc84 >> 0x1F & 0x04);
		if (g_t81576F0 == 0x00)
		{
			*dwLoc88 = ebx_50;
			dwLoc88_351 = dwLoc88;
		}
		else
		{
			runtime.writebarrierptr(dwLoc88, ebx_50);
			dwLoc88_351 = ebx_50;
		}
		runtime.newobject(gs, 0x080CBC20);
		struct Eq_62775 * eax_97 = *dwLoc8C;
		Eq_4 edx_99 = eax_97->t0080;
		Eq_4 eax_101 = eax_97->t0078;
		*((word32) dwLoc88_351 + 4) = eax_97->t007C;
		*((word32) dwLoc88_351 + 8) = edx_99;
		if (g_t81576F0 == 0x00)
			*dwLoc88_351 = eax_101;
		else
			runtime.writebarrierptr(dwLoc88_351, eax_101);
		Eq_4 ecx_121 = dwLoc88_351;
		Eq_62803 edx_131 = 0x00;
		Eq_4 ebp_135 = 0x01;
		Eq_4 esi_136 = 0x01;
		Eq_4 edi_137 = 0x01;
		Eq_4 dwLoc6C_363 = 0x01;
		Eq_4 dwLoc0C_366 = dwLoc88;
		word32 * ebx_141 = esi_63;
		while (edx_131 < dwLoc88 - (Eq_4 (*)[]) 0x01)
		{
			Eq_4 dwLoc30_390;
			struct Eq_62808 * eax_168 = *ebx_141;
			Eq_4 ebx_171 = (word32) dwLoc6C_363 + 1;
			Eq_4 ecx_172 = eax_168->t0064;
			if ((word32) dwLoc6C_363 + 1 <= edi_137)
				dwLoc30_390 = dwLoc0C_366;
			else
			{
				word32 esi_479;
				runtime.growslice(gs, 0x080CF3A0, dwLoc0C_366, dwLoc6C_363, edi_137, (word32) dwLoc6C_363 + 1, out esi_479);
				edi_137 = dwLoc70;
				ebx_171 = dwLoc74 + 0x01;
				dwLoc30_390 = dwLoc78;
			}
			dwLoc6C_363 = ebx_171;
			Eq_4 esi_217 = (word32) dwLoc30_390 + dwLoc6C_363 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) dwLoc30_390 + dwLoc6C_363 * 0x04) = ecx_172;
			else
				runtime.writebarrierptr(esi_217, ecx_172);
			Eq_4 dwLoc2C_420;
			Eq_4 ecx_238 = (word32) ebp_135 + 1;
			Eq_4 edx_242 = eax_168->t0078;
			Eq_4 ebx_243 = eax_168->t007C;
			Eq_4 eax_244 = eax_168->t0080;
			Eq_4 esi_246 = esi_136;
			if (ecx_238 <= esi_136)
				dwLoc2C_420 = ecx_121;
			else
			{
				word32 esi_480;
				runtime.growslice(gs, 0x080C9640, ecx_121, ebp_135, esi_136, ecx_238, out esi_480);
				esi_246 = dwLoc70;
				ecx_238 = dwLoc74 + 0x01;
				dwLoc2C_420 = dwLoc78;
			}
			ui32 ebp_291 = ebp_135 * 0x03;
			*((word32) dwLoc2C_420 + (ebp_291 * 0x04 + 4)) = ebx_243;
			*((word32) dwLoc2C_420 + (ebp_291 * 0x04 + 8)) = eax_244;
			Eq_4 ebx_298 = (word32) dwLoc2C_420 + ebp_291 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) dwLoc2C_420 + ebp_291 * 0x04) = edx_242;
			else
				runtime.writebarrierptr(ebx_298, edx_242);
			esi_136 = esi_246;
			ecx_121 = dwLoc2C_420;
			++ebx_141;
			edx_131 = (word32) edx_131.u0 + 1;
			ebp_135 = ecx_238;
			dwLoc0C_366 = dwLoc30_390;
		}
	}
}

// 080797C0: Register word32 reflect.resolveNameOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).nameOff
word32 reflect.resolveNameOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.resolveNameOff(gs, dwArg04, dwArg08);
}

// 08079800: void reflect.resolveTypeOff(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.name.pkgPath
//      reflect.(*rtype).typeOff
void reflect.resolveTypeOff(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*_type).typeOff(gs);
}

// 08079840: void reflect.resolveTextOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).textOff
void reflect.resolveTextOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*_type).textOff(gs, dwArg04, dwArg08);
}

// 08079880: void reflect.addReflectOff(Register Eq_62993 ebx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.resolveReflectName
void reflect.addReflectOff(Eq_62993 ebx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.reflectOffsLock(gs);
	if (g_t81451A8 == 0x00)
	{
		Eq_4 edi_44;
		word128 xmm0_311;
		word128 xmm1_312;
		Eq_4 esi_46 = runtime.makemap(ebx_24_8, esi, edi, gs, 0x080CFA40, 0x00, 0x00, 0x00, 0x00, out edi_44, out xmm0_311, out xmm1_312);
		if (g_t81576F0 == 0x00)
			g_t81451A8 = dwLoc0C;
		else
			runtime.writebarrierptr(135549352, dwLoc0C);
		word128 xmm1_315;
		word128 xmm0_314;
		word32 edi_313;
		runtime.makemap(ebx_24_8, esi_46, edi_44, gs, 0x080CFC40, 0x00, 0x00, 0x00, 0x00, out edi_313, out xmm0_314, out xmm1_315);
		dwLoc14.u0 = 0x00;
		bLoc10 = 0x00;
		if (g_t81576F0 == 0x00)
			g_t81451AC = dwLoc0C;
		else
			runtime.writebarrierptr(135549356, dwLoc0C);
		g_t81451A4.u0 = ~0x00;
	}
	runtime.mapaccess2_fast32(gs, &g_t80CFC40, g_t81451AC, dwArg04);
	if ((byte) (word32) bLoc10 == 0x00)
	{
		Eq_4 eax_145 = g_t81451A4;
		g_t81451A4 = eax_145 - 0x01;
		runtime.mapassign_fast32(gs, 0x080CFA40, g_t81451A8, eax_145);
		if (g_t81576F0 == 0x00)
			*dwLoc14 = dwArg04;
		else
			runtime.writebarrierptr(dwLoc14, dwArg04);
		runtime.mapassign_fast32(gs, 0x080CFC40, g_t81451AC, dwArg04);
		*dwLoc14 = eax_145;
	}
	runtime.reflectOffsUnlock(gs);
}

// 08079A40: void runtime.(*guintptr).cas(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.runqput
//      runtime.runqget
//      runtime.runqgrab
//      runtime.gcBgMarkWorker.func1
void runtime.(*guintptr).cas(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	runtime/internal/atomic.Casuintptr(dwArg04, dwArg08, dwArg0C);
}

// 08079A70: void runtime.extendRandom(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      runtime.getRandomData
void runtime.extendRandom(struct Eq_2 * gs, word64 mm0, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = dwArg10;
	if (dwArg10 < 0x00)
		eax_17.u0 = 0x00;
	while (eax_17 < dwArg08)
	{
		Eq_4 edx_35;
		if (eax_17 > 0x10)
			edx_35.u0 = 0x10;
		else
			edx_35 = eax_17;
		runtime.nanotime();
		Eq_4 eax_50 = eax_17 - edx_35;
		if (eax_50 >= dwArg08)
			runtime.panicindex(gs);
		word32 eax_58 = eax_50 + dwArg04;
		runtime.memhash(gs, mm0, eax_58, dwLoc18, edx_35);
		dwLoc18 = eax_58;
		Eq_4 ebx_78 = eax_17;
		int32 ebp_79 = 0x00;
		eax_174 = dwLoc0C;
		while (true)
		{
			uint32 eax_174;
			byte al_92 = (byte) eax_174;
			if (ebp_79 >= 0x04 || ebx_78 >= dwArg08)
				break;
			if (ebx_78 >= dwArg08)
				runtime.panicindex(gs);
			Mem94[dwArg04 + ebx_78:byte] = al_92;
			++ebp_79;
			ebx_78 = (word32) ebx_78 + 1;
			eax_174 >>= 0x08;
		}
		eax_17 = ebx_78;
	}
}

// 08079B30: void runtime.(*rwmutex).rlock(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.newm
void runtime.(*rwmutex).rlock(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	runtime/internal/atomic.Xadd(dwArg04 + 0x14, 0x01);
	if (dwLoc0C < 0x00)
	{
		word32 edi_76;
		word32 ebp_75;
		runtime.systemstack(gs, fp - 0x08, out ebp_75, out edi_76);
	}
}

// 08079BB0: void runtime.(*rwmutex).runlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.newm
void runtime.(*rwmutex).runlock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xadd((word32) dwArg04 + 20, ~0x00);
	if (dwLoc04 < 0x00)
	{
		if (dwLoc04 == ~0x00 || dwLoc04 == ~0x40000000)
			runtime.throw(gs);
		runtime/internal/atomic.Xadd((word32) dwArg04 + 24, ~0x00);
		if (dwLoc04 == 0x00)
		{
			word32 edi_143;
			word32 esi_142;
			word32 ebp_141;
			runtime.lock(esi, gs, dwArg04, out ebp_141, out esi_142, out edi_143);
			Eq_4 ecx_70 = *((word32) dwArg04 + 16);
			if (ecx_70 != 0x00)
				runtime.notewakeup(gs, (word32) ecx_70 + 0x00AC);
			word32 edx_144;
			word32 ebx_145;
			runtime.unlock(gs, dwArg04, out edx_144, out ebx_145);
		}
	}
	Eq_4 eax_93 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_94 = *((word32) eax_93 + 24);
	Eq_4 edx_95 = *((word32) ecx_94 + 0x0078);
	*((word32) ecx_94 + 0x0078) = edx_95 - 0x01;
	if (edx_95 == 0x01 && (byte) ((word32) (*((word32) eax_93 + 0x006C))) != 0x00)
		((word32) eax_93 + 8)->u0 = ~0x0521;
}

// 08079CB0: Register ui32 internal/poll.runtime_Semacquire(Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*fdMutex).rwlock
ui32 internal/poll.runtime_Semacquire(ui32 edi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 edi_28;
	runtime.semacquire1(edi, gs, dwArg04, 0x00, 0x01, out edi_28);
	return edi_28;
}

// 08079CF0: void sync.runtime_Semrelease(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Mutex).Unlock
void sync.runtime_Semrelease(word32 ebp, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	Eq_4 bArg04_49 = (byte) dwArg04;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.semrelease1(ebp, gs, dwLoc0C, dwArg04, dwArg00, bArg04_49);
}

// 08079D30: Register word32 sync.runtime_SemacquireMutex(Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08, Register out ptr32 ediOut)
// Called from:
//      sync.(*Mutex).Lock
word32 sync.runtime_SemacquireMutex(ui32 edi, struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 edi_30;
	word32 ebp_27 = runtime.semacquire1(edi, gs, dwArg04, (byte) (word32) bArg08, 0x03, out edi_30);
	ediOut = edi_30;
	return ebp_27;
}

// 08079D70: Register Eq_4 internal/poll.runtime_Semrelease(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).rwunlock
Eq_4 internal/poll.runtime_Semrelease(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx = runtime.morestack_noctxt();
	runtime.semrelease(gs);
	return edx;
}

// 08079DA0: void runtime.readyWithTime(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_63407) dwArg04)
// Called from:
//      runtime.semrelease1
void runtime.readyWithTime(struct Eq_2 * gs, struct Eq_63407 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_18 = dwArg04->dw001C;
	word32 edx_19 = dwArg04->dw0020;
	if ((byte) (SEQ(SLICE(edx_19, word24, 8), edx_19 != 0x00) | SEQ(SLICE(ecx_18, word24, 8), ecx_18 != 0x00)) != 0x00)
	{
		runtime.cputicks();
		dwArg04->dw001C = dwLoc08;
		dwArg04->dw0020 = dwLoc04;
	}
	runtime.goready(gs);
}

// 08079E10: void runtime.semacquire(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.stopTheWorld
void runtime.semacquire(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_38;
	runtime.semacquire1(edi, gs, dwArg04, 0x00, 0x00, out edi_38);
}

// 08079E50: Register ui32 runtime.semacquire1(Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08, Stack ui32 dwArg0C, Register out Eq_4 ediOut)
// Called from:
//      internal/poll.runtime_Semacquire
//      sync.runtime_SemacquireMutex
//      runtime.semacquire
ui32 runtime.semacquire1(ui32 edi, struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08, ui32 dwArg0C, union Eq_4 & ediOut)
{
	byte bLoc30 = (byte) dwLoc30;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (eax_18 != *((word32) (*((word32) eax_18 + 24)) + 84))
		runtime.throw(gs);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.cansemacquire(gs, stackArg0, dwArg04);
		if ((byte) (word32) bLoc30 != 0x00)
		{
			ediOut.u0 = <invalid>;
			return ebp;
		}
		else
		{
			int64 edx_esi_554;
			runtime.acquireSudog(gs);
			((word32) dwArg04 + 28)->u0 = 0x00;
			((word32) dwArg04 + 32)->u0 = 0x00;
			((word32) dwArg04 + 20)->u0 = 0x00;
			((word32) dwArg04 + 24)->u0 = 0x00;
			((word32) dwArg04 + 36)->u0 = 0x00;
			ui24 ecx_24_8_163 = SLICE(dwArg04, word24, 8);
			uint32 ebp_64 = (dwArg04 >> 0x03) - (SLICE((dwArg04 >> 0x03) * 2190262207, word32, 32) >> 0x07) *s 0xFB;
			if ((dwArg0C & 0x01) != 0x00)
			{
				up32 edx_74 = g_dw815766C;
				up32 esi_75 = g_dw8157668;
				if ((byte) (SEQ(SLICE(esi_75, word24, 8), esi_75 > 0x00) & SEQ(SLICE(edi, word24, 8), edx_74 == 0x00) | SEQ(SLICE(edx_74, word24, 8), edx_74 > 0x00)) == 0x00)
					edx_esi_554 = 0x00;
				else
				{
					runtime.cputicks();
					((word32) dwArg04 + 28)->u0 = ~0x00;
					((word32) dwArg04 + 32)->u0 = ~0x00;
					ecx_24_8_163 = SLICE(dwArg04, word24, 8);
					edx_esi_554 = SEQ(dwLoc30, dwArg04);
				}
			}
			else
				edx_esi_554 = 0x00;
			word32 esi_190 = (word32) edx_esi_554;
			word32 edx_186 = SLICE(edx_esi_554, word32, 32);
			int64 edx_esi_550 = edx_esi_554;
			if ((dwArg0C & 0x02) != 0x00)
			{
				up32 eax_144 = g_dw8157694;
				up32 edi_145 = g_dw8157690;
				ui24 eax_24_8_173 = SLICE(eax_144, word24, 8);
				edx_esi_550 = edx_esi_554;
				if ((byte) (SEQ(SLICE(edi_145, word24, 8), edi_145 > 0x00) & SEQ(ecx_24_8_163, eax_144 == 0x00) | SEQ(eax_24_8_173, eax_144 > 0x00)) != 0x00)
				{
					if ((byte) (SEQ(eax_24_8_173, edx_186 == 0x00) & SEQ(ecx_24_8_163, esi_190 == 0x00)) != 0x00)
					{
						runtime.cputicks();
						edx_esi_554 = SEQ(dwLoc30, dwArg04);
					}
					*((word32) dwArg04 + 20) = (word32) edx_esi_554;
					*((word32) dwArg04 + 24) = SLICE(edx_esi_554, word32, 32);
					edx_esi_550 = edx_esi_554;
				}
			}
			Eq_4 esi_218 = (word32) edx_esi_550;
			do
			{
				ui24 ebx_24_8_346;
				word32 esi_563;
				word32 ebp_562;
				word32 edi_564;
				runtime.lock(esi_218, gs, (ebp_64 << 0x06) + 0xB6000000, out ebp_562, out esi_563, out edi_564);
				runtime/internal/atomic.Xadd((ebp_64 << 0x06) + 0x0814B608, 0x01);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.cansemacquire(gs, stackArg0, dwArg04);
				if (true)
				{
					ebx_24_8_346 = SLICE(runtime/internal/atomic.Xadd((ebp_64 << 0x06) + 0x0814B608, ~0x00), word24, 8);
					word32 ebx_567;
					word32 edx_566;
					runtime.unlock(gs, (ebp_64 << 0x06) + 0xB6000000, out edx_566, out ebx_567);
					break;
				}
				word32 ebx_297 = (word32) bArg08;
				runtime.(*semaRoot).queue(gs, (ebp_64 << 0x06) + 0x0814B600, dwArg04, dwArg04, (byte) ebx_297);
				runtime.goparkunlock(gs);
				ebx_24_8_346 = SLICE(ebx_297, word24, 8);
				if (*((word32) dwArg04 + 36) != 0x00)
					break;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.cansemacquire(gs, stackArg0, dwArg04);
			} while (~0x60 == 0x00);
			Eq_4 ecx_337 = *((word32) dwArg04 + 32);
			Eq_4 edx_338 = *((word32) dwArg04 + 28);
			ui32 ebp_360 = SEQ(SLICE(ebp_64 << 0x06, word24, 8), edx_338 > 0x00) & SEQ(ebx_24_8_346, ecx_337 == 0x00);
			ui32 ebx_365 = SEQ(ebx_24_8_346, ecx_337 > 0x00) | ebp_360;
			if ((byte) ebx_365 != 0x00)
			{
				int64 ecx_edx_412 = SEQ(ecx_337, edx_338) - edx_esi_550;
				runtime.blockevent(SLICE(ebx_365, word24, 8), gs, (word32) ecx_edx_412, SLICE(ecx_edx_412, word32, 32));
			}
			word32 esi_569;
			word32 edi_570;
			runtime.releaseSudog(gs, dwArg04, out esi_569, out edi_570);
			ediOut.u0 = <invalid>;
			return ebp_360;
		}
	}
}

// 0807A160: Register Eq_4 runtime.semrelease(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.startTheWorld
//      internal/poll.runtime_Semrelease
Eq_4 runtime.semrelease(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	Eq_4 stackArg12 = <invalid>;
	runtime.semrelease1(ebp, gs, stackArg0, dwArg04, stackArg12, dwArg04);
	return <invalid>;
}

// 0807A1A0: void runtime.semrelease1(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 bArg0C, Stack Eq_4 bArg10)
// Called from:
//      sync.runtime_Semrelease
//      runtime.semrelease
void runtime.semrelease1(word32 ebp, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 bArg0C, Eq_4 bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xadd(dwArg04, 0x01);
	runtime/internal/atomic.Load();
	uint32 ebx_104 = ((dwArg04 >> 0x03) - (SLICE((dwArg04 >> 0x03) * 2190262207, word32, 32) >> 0x07) *s 0xFB << 0x06) + 0x0814B608;
	if (dwLoc2C == 0x00)
		return;
	word32 ebp_340;
	word32 esi_341;
	word32 edi_342;
	runtime.lock(esi, gs, (word32) dwArg04 + 135575040, out ebp_340, out esi_341, out edi_342);
	runtime/internal/atomic.Load();
	if (dwLoc28 == 0x00)
	{
		word32 edx_343;
		word32 ebx_344;
		runtime.unlock(gs, dwArg00, out edx_343, out ebx_344);
	}
	else
	{
		runtime.(*semaRoot).dequeue(gs, (word32) dwArg04 + 135575040, dwArg0C);
		Eq_4 dwLoc28_247 = dwArg0C;
		if (dwLoc24 != null)
		{
			dwLoc28_247.u0 = ~0x00;
			ebx_104 = runtime/internal/atomic.Xadd(dwArg04, ~0x00);
		}
		word32 edx_117;
		word32 ebx_345;
		runtime.unlock(gs, dwArg00, out edx_117, out ebx_345);
		ui24 ebx_24_8_133 = SLICE(ebx_104, word24, 8);
		if (dwLoc24 == null)
			return;
		uint32 ecx_123 = dwLoc24->dw0014;
		ui32 edx_124 = dwLoc24->dw0018;
		if ((byte) (SEQ(SLICE(ebp, word24, 8), edx_124 != 0x00) | SEQ(ebx_24_8_133, ecx_123 != 0x00)) != 0x00)
		{
			Eq_4 eax_163 = SLICE(qwLoc20 - SEQ(edx_124, ecx_123), word32, 32);
			sync.event(ebx, gs, eax_163);
			dwLoc28_247 = eax_163;
		}
		byte bLoc28_289 = (byte) dwLoc28_247;
		if (dwLoc24->dw0024 != 0x00)
			runtime.throw(gs);
		else
		{
			if ((byte) (word32) bArg10 != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.cansemacquire(gs, stackArg0, dwArg0C);
				if ((byte) (word32) bLoc28_289 != 0x00)
					dwLoc24->dw0024 = 0x01;
			}
			runtime.readyWithTime(gs, dwLoc24);
		}
	}
}

// 0807A380: void runtime.cansemacquire(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      runtime.semacquire1
//      runtime.semrelease1
void runtime.cansemacquire(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime/internal/atomic.Load();
		if (dwLoc0C == 0x00)
			return;
		runtime/internal/atomic.Cas(dwArg04, dwLoc0C, dwLoc0C - 0x01);
	} while ((byte) (word32) bLoc04 == 0x00);
}

// 0807A3E0: void runtime.(*semaRoot).queue(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_63689) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10)
// Called from:
//      runtime.semacquire1
void runtime.(*semaRoot).queue(struct Eq_2 * gs, struct Eq_63689 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_22 = gs->ptr0000->tFFFFFFFC;
	if (g_t81576F0 == 0x00)
	{
		*dwArg0C = edx_22;
		*((word32) dwArg0C + 16) = dwArg08;
		((word32) dwArg0C + 8)->u0 = 0x00;
		((word32) dwArg0C + 0x0C)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr(dwArg0C, edx_22);
		runtime.writebarrierptr((word32) dwArg0C + 16, dwArg08);
		runtime.writebarrierptr((word32) dwArg0C + 8, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 0x0C, 0x00);
	}
	Eq_4 ebx_111 = &dwArg04->t0004;
	Eq_4 edi_554 = dwArg04->t0004;
	Eq_4 dwLoc20_590 = 0x00;
	while (edi_554 != 0x00)
	{
		Eq_4 ebp_198 = *((word32) edi_554 + 16);
		if (dwArg08 == ebp_198)
		{
			if ((byte) (word32) bArg10 != 0x00)
			{
				if (g_t81576F0 == 0x00)
					*ebx_111 = dwArg0C;
				else
					runtime.writebarrierptr(ebx_111, dwArg0C);
				*((word32) dwArg0C + 36) = *((word32) edi_554 + 36);
				Eq_4 ecx_294 = *((word32) edi_554 + 24);
				*((word32) dwArg0C + 20) = *((word32) edi_554 + 20);
				*((word32) dwArg0C + 24) = ecx_294;
				Eq_4 ebx_300 = *((word32) edi_554 + 40);
				Eq_4 ebp_301 = (word32) edi_554 + 40;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 40) = ebx_300;
				else
					runtime.writebarrierptr((word32) dwArg0C + 40, ebx_300);
				Eq_4 edx_322 = *((word32) edi_554 + 0x0C);
				Eq_4 ebx_323 = (word32) edi_554 + 0x0C;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 0x0C) = edx_322;
				else
					runtime.writebarrierptr((word32) dwArg0C + 0x0C, edx_322);
				Eq_4 edx_348 = *((word32) edi_554 + 8);
				Eq_4 esi_349 = (word32) edi_554 + 8;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 8) = edx_348;
				else
					runtime.writebarrierptr((word32) dwArg0C + 8, edx_348);
				Eq_4 ecx_372 = *((word32) dwArg0C + 0x0C);
				if (ecx_372 != 0x00)
				{
					if (g_t81576F0 == 0x00)
						*((word32) ecx_372 + 40) = dwArg0C;
					else
						runtime.writebarrierptr((word32) ecx_372 + 40, dwArg0C);
				}
				Eq_4 ecx_396 = *((word32) dwArg0C + 8);
				if (ecx_396 != 0x00)
				{
					if (g_t81576F0 == 0x00)
						*((word32) ecx_396 + 40) = dwArg0C;
					else
						runtime.writebarrierptr((word32) ecx_396 + 40, dwArg0C);
				}
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 44) = edi_554;
				else
					runtime.writebarrierptr((word32) dwArg0C + 44, edi_554);
				Eq_4 esi_446 = *((word32) edi_554 + 48);
				Eq_4 ebx_447 = (word32) edi_554 + 48;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 48) = esi_446;
				else
					runtime.writebarrierptr((word32) dwArg0C + 48, esi_446);
				if (esi_446 == 0x00)
				{
					if (g_t81576F0 == 0x00)
						*((word32) dwArg0C + 48) = edi_554;
					else
						runtime.writebarrierptr((word32) dwArg0C + 48, edi_554);
				}
				if (g_t81576F0 == 0x00)
				{
					*((word32) edi_554 + 40) = 0x00;
					*((word32) edi_554 + 0x0C) = 0x00;
					*((word32) edi_554 + 8) = 0x00;
					*((word32) edi_554 + 48) = 0x00;
				}
				else
				{
					runtime.writebarrierptr(ebp_301, 0x00);
					runtime.writebarrierptr(ebx_323, 0x00);
					runtime.writebarrierptr(esi_349, 0x00);
					runtime.writebarrierptr(ebx_447, 0x00);
				}
			}
			else
			{
				struct Eq_64065 * ecx_208 = *((word32) edi_554 + 48);
				Eq_4 edx_209 = (word32) edi_554 + 48;
				if (ecx_208 != null)
				{
					if (g_t81576F0 == 0x00)
						ecx_208->t002C = dwArg0C;
					else
						runtime.writebarrierptr(&ecx_208->t002C, dwArg0C);
				}
				else
				{
					Eq_4 ebx_215 = (word32) edi_554 + 44;
					if (g_t81576F0 == 0x00)
						*((word32) edi_554 + 44) = dwArg0C;
					else
						runtime.writebarrierptr(ebx_215, dwArg0C);
				}
				if (g_t81576F0 == 0x00)
				{
					*((word32) edi_554 + 48) = dwArg0C;
					((word32) dwArg0C + 44)->u0 = 0x00;
				}
				else
				{
					runtime.writebarrierptr(edx_209, dwArg0C);
					runtime.writebarrierptr((word32) dwArg0C + 44, 0x00);
				}
			}
			return;
		}
		if (dwArg08 < ebp_198)
			ebx_111 = (word32) edi_554 + 0x0C;
		else
			ebx_111 = (word32) edi_554 + 8;
		dwLoc20_590 = edi_554;
		edi_554 = *ebx_111;
	}
	Eq_4 ecx_96 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_4 ebp_97 = *((word32) ecx_96 + 0x0094);
	Eq_4 esi_102 = ebp_97 << 0x01 ^ ebp_97 >> 0x1F & 0xA8888EEF;
	*((word32) ecx_96 + 0x0094) = esi_102;
	*((word32) dwArg0C + 36) = esi_102;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg0C + 40) = dwLoc20_590;
	else
		runtime.writebarrierptr((word32) dwArg0C + 40, dwLoc20_590);
	if (g_t81576F0 == 0x00)
		*ebx_111 = dwArg0C;
	else
		runtime.writebarrierptr(ebx_111, dwArg0C);
	while (true)
	{
		Eq_4 ecx_154 = *((word32) dwArg0C + 40);
		if (ecx_154 == 0x00 || *((word32) ecx_154 + 36) <= *((word32) dwArg0C + 36))
			break;
		if (dwArg0C != *((word32) ecx_154 + 0x0C))
		{
			if (*((word32) ecx_154 + 8) != dwArg0C)
				runtime.gopanic(gs);
			runtime.(*semaRoot).rotateLeft(gs, dwArg04, ecx_154);
		}
		else
			runtime.(*semaRoot).rotateRight(gs, dwArg04, ecx_154);
	}
}

// 0807A950: void runtime.(*semaRoot).dequeue(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_63689) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.semrelease1
void runtime.(*semaRoot).dequeue(struct Eq_2 * gs, struct Eq_63689 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = &dwArg04->t0004;
	Eq_4 edx_22 = dwArg04->t0004;
	while (true)
	{
		if (edx_22 == 0x00)
			return;
		Eq_4 esi_36 = *((word32) edx_22 + 16);
		Eq_4 edi_37 = (word32) edx_22 + 16;
		if (dwArg08 == esi_36)
			break;
		if (dwArg08 < esi_36)
			ecx_18 = (word32) edx_22 + 0x0C;
		else
			ecx_18 = (word32) edx_22 + 8;
		edx_22 = *ecx_18;
	}
	Eq_4 esi_84;
	Eq_4 ebx_83;
	word32 esi_46 = *((word32) edx_22 + 24);
	word32 ebx_45 = *((word32) edx_22 + 20);
	if ((byte) (SEQ(SLICE(esi_46, word24, 8), esi_46 != 0x00) | SEQ(SLICE(ebx_45, word24, 8), ebx_45 != 0x00)) == 0x00)
	{
		ebx_83.u0 = 0x00;
		esi_84.u0 = 0x00;
	}
	else
	{
		runtime.cputicks();
		ebx_83 = dwLoc2C;
		esi_84 = dwLoc28;
	}
	Eq_4 edi_100 = *((word32) edx_22 + 44);
	Eq_4 ebp_101 = (word32) edx_22 + 44;
	if (edi_100 == 0x00)
	{
l0807A9F9:
		struct Eq_64404 * ecx_341 = *((word32) edx_22 + 8);
		bool Z_344 = SLICE(cond(ecx_341), bool, 2);
		if (ecx_341 != null)
		{
l0807AA00:
			if (!Z_344)
			{
				struct Eq_64429 * ebp_471 = *((word32) edx_22 + 0x0C);
				if (ebp_471 == null || ebp_471->dw0024 >= ecx_341->dw0024)
				{
					runtime.(*semaRoot).rotateLeft(gs, dwArg04, edx_22);
l0807A9E9:
					goto l0807A9F9;
				}
			}
			runtime.(*semaRoot).rotateRight(gs, dwArg04, edx_22);
			goto l0807A9E9;
		}
		if (*((word32) edx_22 + 0x0C) != 0x00)
		{
			Z_344 = SLICE(cond(ecx_341), bool, 2);
			goto l0807AA00;
		}
		struct Eq_64631 * ecx_349 = *((word32) edx_22 + 40);
		if (ecx_349 != null)
		{
			if (edx_22 == ecx_349->t000C)
			{
				if (g_t81576F0 == 0x00)
					ecx_349->t000C.u0 = 0x00;
				else
					runtime.writebarrierptr(&ecx_349->t000C, 0x00);
			}
			else if (g_t81576F0 == 0x00)
				ecx_349->dw0008 = 0x00;
			else
				runtime.writebarrierptr(&ecx_349->dw0008, 0x00);
		}
		else if (g_t81576F0 == 0x00)
			dwArg04->t0004.u0 = 0x00;
		else
			runtime.writebarrierptr(&dwArg04->t0004, 0x00);
	}
	else
	{
		if (g_t81576F0 == 0x00)
			*ecx_18 = edi_100;
		else
			runtime.writebarrierptr(ecx_18, edi_100);
		*((word32) edi_100 + 36) = *((word32) edx_22 + 36);
		Eq_4 ebp_137 = *((word32) edx_22 + 40);
		if (g_t81576F0 == 0x00)
			*((word32) edi_100 + 40) = ebp_137;
		else
			runtime.writebarrierptr((word32) edi_100 + 40, ebp_137);
		Eq_4 ebp_159 = *((word32) edx_22 + 0x0C);
		if (g_t81576F0 == 0x00)
			*((word32) edi_100 + 0x0C) = ebp_159;
		else
			runtime.writebarrierptr((word32) edi_100 + 0x0C, ebp_159);
		if (ebp_159 != 0x00)
		{
			if (g_t81576F0 == 0x00)
				*((word32) ebp_159 + 40) = edi_100;
			else
				runtime.writebarrierptr((word32) ebp_159 + 40, edi_100);
		}
		Eq_4 ebp_208 = *((word32) edx_22 + 8);
		if (g_t81576F0 == 0x00)
			*((word32) edi_100 + 8) = ebp_208;
		else
			runtime.writebarrierptr((word32) edi_100 + 8, ebp_208);
		if (ebp_208 != 0x00)
		{
			if (g_t81576F0 == 0x00)
				*((word32) ebp_208 + 40) = edi_100;
			else
				runtime.writebarrierptr((word32) ebp_208 + 40, edi_100);
		}
		if (*((word32) edi_100 + 44) != 0x00)
		{
			Eq_4 ebp_279 = *((word32) edx_22 + 48);
			if (g_t81576F0 == 0x00)
				*((word32) edi_100 + 48) = ebp_279;
			else
				runtime.writebarrierptr((word32) edi_100 + 48, ebp_279);
		}
		else if (g_t81576F0 == 0x00)
			((word32) edi_100 + 48)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) edi_100 + 48, 0x00);
		*((word32) edi_100 + 20) = ebx_83;
		*((word32) edi_100 + 24) = esi_84;
		Eq_4 ecx_313 = (word32) edx_22 + 48;
		if (g_t81576F0 == 0x00)
		{
			*((word32) edx_22 + 44) = 0x00;
			*((word32) edx_22 + 48) = 0x00;
		}
		else
		{
			runtime.writebarrierptr(ebp_101, 0x00);
			runtime.writebarrierptr(ecx_313, 0x00);
		}
	}
	Eq_4 ecx_407 = (word32) edx_22 + 40;
	Eq_4 ebp_408 = (word32) edx_22 + 8;
	Eq_4 edi_409 = (word32) edx_22 + 0x0C;
	if (g_t81576F0 == 0x00)
	{
		*((word32) edx_22 + 40) = 0x00;
		*((word32) edx_22 + 16) = 0x00;
		*((word32) edx_22 + 8) = 0x00;
		*((word32) edx_22 + 0x0C) = 0x00;
	}
	else
	{
		runtime.writebarrierptr(ecx_407, 0x00);
		runtime.writebarrierptr(edi_37, 0x00);
		runtime.writebarrierptr(ebp_408, 0x00);
		runtime.writebarrierptr(edi_409, 0x00);
	}
	*((word32) edx_22 + 36) = 0x00;
}

// 0807AE50: void runtime.(*semaRoot).rotateLeft(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_63689) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*semaRoot).queue
//      runtime.(*semaRoot).dequeue
void runtime.(*semaRoot).rotateLeft(struct Eq_2 * gs, struct Eq_63689 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 8);
	Eq_4 edx_20 = *((word32) dwArg08 + 40);
	Eq_4 ebp_24 = *((word32) dwArg08 + 0x0C);
	Eq_4 ebx_30 = *((word32) ecx_18 + 0x0C);
	Eq_4 esi_33 = *((word32) ecx_18 + 8);
	if (g_t81576F0 == 0x00)
	{
		*((word32) ecx_18 + 0x0C) = dwArg08;
		*((word32) dwArg08 + 40) = ecx_18;
		*((word32) ecx_18 + 8) = esi_33;
	}
	else
	{
		runtime.writebarrierptr((word32) ecx_18 + 0x0C, dwArg08);
		runtime.writebarrierptr((word32) dwArg08 + 40, ecx_18);
		runtime.writebarrierptr((word32) ecx_18 + 8, esi_33);
	}
	if (esi_33 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) esi_33 + 40) = ecx_18;
		else
			runtime.writebarrierptr((word32) esi_33 + 40, ecx_18);
	}
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 0x0C) = ebp_24;
	else
		runtime.writebarrierptr((word32) dwArg08 + 0x0C, ebp_24);
	if (ebp_24 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) ebp_24 + 40) = dwArg08;
		else
			runtime.writebarrierptr((word32) ebp_24 + 40, dwArg08);
	}
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 8) = ebx_30;
	else
		runtime.writebarrierptr((word32) dwArg08 + 8, ebx_30);
	if (ebx_30 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) ebx_30 + 40) = dwArg08;
		else
			runtime.writebarrierptr((word32) ebx_30 + 40, dwArg08);
	}
	if (g_t81576F0 == 0x00)
		*((word32) ecx_18 + 40) = edx_20;
	else
		runtime.writebarrierptr((word32) ecx_18 + 40, edx_20);
	if (edx_20 == 0x00)
	{
		if (g_t81576F0 == 0x00)
			dwArg04->t0004 = ecx_18;
		else
			runtime.writebarrierptr(&dwArg04->t0004, ecx_18);
	}
	else if (*((word32) edx_20 + 0x0C) != dwArg08)
	{
		if (*((word32) edx_20 + 8) != dwArg08)
			runtime.throw(gs);
		else if (g_t81576F0 == 0x00)
			*((word32) edx_20 + 8) = ecx_18;
		else
			runtime.writebarrierptr((word32) edx_20 + 8, ecx_18);
	}
	else if (g_t81576F0 == 0x00)
		*((word32) edx_20 + 0x0C) = ecx_18;
	else
		runtime.writebarrierptr((word32) edx_20 + 0x0C, ecx_18);
}

// 0807B100: void runtime.(*semaRoot).rotateRight(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_63689) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*semaRoot).queue
//      runtime.(*semaRoot).dequeue
void runtime.(*semaRoot).rotateRight(struct Eq_2 * gs, struct Eq_63689 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 0x0C);
	Eq_4 edx_20 = *((word32) dwArg08 + 40);
	Eq_4 esi_26 = *((word32) dwArg08 + 8);
	Eq_4 ebp_30 = *((word32) ecx_18 + 0x0C);
	Eq_4 ebx_31 = *((word32) ecx_18 + 8);
	if (ebp_30 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) ebp_30 + 40) = ecx_18;
		else
			runtime.writebarrierptr((word32) ebp_30 + 40, ecx_18);
	}
	if (g_t81576F0 == 0x00)
	{
		*((word32) ecx_18 + 8) = dwArg08;
		*((word32) dwArg08 + 40) = ecx_18;
		*((word32) dwArg08 + 0x0C) = ebx_31;
	}
	else
	{
		runtime.writebarrierptr((word32) ecx_18 + 8, dwArg08);
		runtime.writebarrierptr((word32) dwArg08 + 40, ecx_18);
		runtime.writebarrierptr((word32) dwArg08 + 0x0C, ebx_31);
	}
	if (ebx_31 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) ebx_31 + 40) = dwArg08;
		else
			runtime.writebarrierptr((word32) ebx_31 + 40, dwArg08);
	}
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 8) = esi_26;
	else
		runtime.writebarrierptr((word32) dwArg08 + 8, esi_26);
	if (esi_26 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) esi_26 + 40) = dwArg08;
		else
			runtime.writebarrierptr((word32) esi_26 + 40, dwArg08);
	}
	if (g_t81576F0 == 0x00)
		*((word32) ecx_18 + 40) = edx_20;
	else
		runtime.writebarrierptr((word32) ecx_18 + 40, edx_20);
	if (edx_20 == 0x00)
	{
		if (g_t81576F0 == 0x00)
			dwArg04->t0004 = ecx_18;
		else
			runtime.writebarrierptr(&dwArg04->t0004, ecx_18);
	}
	else if (*((word32) edx_20 + 0x0C) != dwArg08)
	{
		if (*((word32) edx_20 + 8) != dwArg08)
			runtime.throw(gs);
		else if (g_t81576F0 == 0x00)
			*((word32) edx_20 + 8) = ecx_18;
		else
			runtime.writebarrierptr((word32) edx_20 + 8, ecx_18);
	}
	else if (g_t81576F0 == 0x00)
		*((word32) edx_20 + 0x0C) = ecx_18;
	else
		runtime.writebarrierptr((word32) edx_20 + 0x0C, ecx_18);
}

// 0807B370: void sync.runtime_notifyListCheck(Register Eq_65018 ebx, Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
// Called from:
//      sync.init.1
void sync.runtime_notifyListCheck(Eq_65018 ebx, struct Eq_2 * gs, word32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x14)
		return;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, (uint64) (uint32) dwArg04);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, 0x14);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0807B430: void sync.runtime_nanotime(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.(*Mutex).Lock
void sync.runtime_nanotime(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.nanotime();
}

// 0807B470: void runtime.dumpregs(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sighandler
void runtime.dumpregs(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_24 = *((word32) *((word32) dwArg04 + 4) + 64);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_53;
	runtime.printhex(esi, gs, ecx_24, 0x00, out esi_53);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_81 = *((word32) *((word32) dwArg04 + 4) + 52);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_108;
	runtime.printhex(esi_53, gs, ecx_81, 0x00, out esi_108);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_136 = *((word32) *((word32) dwArg04 + 4) + 60);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_163;
	runtime.printhex(esi_108, gs, ecx_136, 0x00, out esi_163);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_191 = *((word32) *((word32) dwArg04 + 4) + 56);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_218;
	runtime.printhex(esi_163, gs, ecx_191, 0x00, out esi_218);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_246 = *((word32) *((word32) dwArg04 + 4) + 36);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_273;
	runtime.printhex(esi_218, gs, ecx_246, 0x00, out esi_273);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_301 = *((word32) *((word32) dwArg04 + 4) + 40);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_328;
	runtime.printhex(esi_273, gs, ecx_301, 0x00, out esi_328);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_356 = *((word32) *((word32) dwArg04 + 4) + 44);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_383;
	runtime.printhex(esi_328, gs, ecx_356, 0x00, out esi_383);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_411 = *((word32) *((word32) dwArg04 + 4) + 48);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_438;
	runtime.printhex(esi_383, gs, ecx_411, 0x00, out esi_438);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_466 = *((word32) *((word32) dwArg04 + 4) + 76);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_493;
	runtime.printhex(esi_438, gs, ecx_466, 0x00, out esi_493);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_521 = *((word32) *((word32) dwArg04 + 4) + 84);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_548;
	runtime.printhex(esi_493, gs, ecx_521, 0x00, out esi_548);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_576 = (word32) *((word32) *((word32) dwArg04 + 4) + 80);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_603;
	runtime.printhex(esi_548, gs, ecx_576, 0x00, out esi_603);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_631 = (word32) *((word32) *((word32) dwArg04 + 4) + 24);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_658;
	runtime.printhex(esi_603, gs, ecx_631, 0x00, out esi_658);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 eax_686 = (word32) *((word32) *((word32) dwArg04 + 4) + 20);
	runtime.printlock(gs);
	runtime.printstring(gs);
	word32 esi_837;
	runtime.printhex(esi_658, gs, eax_686, 0x00, out esi_837);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0807B960: void runtime.(*sigctxt).preparePanic(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_65349) dwArg04)
// Called from:
//      runtime.sighandler
void runtime.(*sigctxt).preparePanic(struct Eq_2 * gs, struct Eq_65349 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_65362 * ecx_18 = dwArg04->ptr0004;
	Eq_4 edx_23 = ecx_18->t004C;
	struct Eq_65370 * ecx_24 = ecx_18->ptr0030;
	if (edx_23 != 0x00)
	{
		runtime.findfunc(gs, edx_23);
		if (dwLoc18 == 0x00)
		{
			runtime.findfunc(gs, ecx_24->dw0000);
			if (dwLoc18 != 0x00)
				edx_23.u0 = 0x00;
		}
	}
	if (edx_23 != 0x00)
	{
		ecx_24->tFFFFFFFC = edx_23;
		dwArg04->ptr0004->ptr0030 = (struct Eq_65370 *) &ecx_24->tFFFFFFFC;
	}
	dwArg04->ptr0004->t004C = g_t80E7CC0;
}

// 0807BA40: void runtime.sighandler(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_65413) dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sigtrampgo
void runtime.sighandler(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_65413 * dwArg0C, Eq_4 dwArg10)
{
	byte bLoc38_889 = (byte) dwLoc38;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (dwArg04 == 0x1B)
	{
		runtime.sigprof(gs, dwLoc40, dwArg0C->t004C, dwArg0C->t0030, null, dwArg10, *((word32) eax_18 + 24));
		return;
	}
	ui32 ecx_60;
	if (dwArg04 < 0x41)
		ecx_60 = (ui32) g_a8144820[dwArg04];
	else
		ecx_60 = 0x04;
	Eq_4 ebp_67 = *((word32) dwArg08 + 8);
	bool Z_116 = SLICE(cond(ebp_67), bool, 2);
	if (ebp_67 != 0x00)
	{
		if ((ecx_60 & 0x08) != 0x00)
		{
			*((word32) dwArg10 + 0x008C) = dwArg04;
			*((word32) dwArg10 + 0x009C) = *((word32) dwArg08 + 8);
			*((word32) dwArg10 + 0x00A0) = *((word32) dwArg08 + 0x0C);
			*((word32) dwArg10 + 0x00A4) = dwArg0C->t004C;
			runtime.(*sigctxt).preparePanic(gs, fp - 0x08);
			return;
		}
		Z_116 = SLICE(cond(ebp_67), bool, 2);
	}
	if (!Z_116 || (ecx_60 & 0x01) != 0x00)
	{
		runtime.sigsend(gs, dwLoc40, dwArg04, dwLoc38);
		if ((byte) (word32) bLoc38_889 != 0x00)
			return;
	}
	if (*((word32) dwArg08 + 8) == 0x00)
	{
		runtime.signal_ignored(gs, dwArg04);
		if ((byte) (word32) bLoc38_889 != 0x00)
			return;
	}
	if ((ecx_60 & 0x02) != 0x00)
		esi = runtime.dieFromSignal(gs, dwArg04);
	if ((ecx_60 & 0x04) == 0x00)
		return;
	bool C_224;
	((word32) *((word32) eax_18 + 24) + 0x006C)->u0 = 0x01;
	*((word32) *((word32) eax_18 + 24) + 88) = dwArg10;
	Eq_363 ebx_24_8_250 = SLICE(dwArg10, word24, 8);
	if (g_dw81575AC != 0x00)
		C_224 = SLICE(cond(dwArg04 - 0x41), bool, 1);
	else
	{
		runtime.startpanic();
		C_224 = SLICE(cond(dwArg04 - 0x41), bool, 1);
	}
	if (!C_224)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	else
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_250, gs, (uint64) (uint32) dwArg04);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	Eq_4 ecx_327 = *((word32) *((word32) eax_18 + 24) + 100);
	Eq_4 edx_329 = dwArg0C->t004C;
	Eq_4 ebx_331 = *((word32) dwArg08 + 8);
	runtime.printlock(gs);
	runtime.printstring(gs);
	word32 esi_980;
	Eq_363 ebx_24_8_389 = SLICE(runtime.printhex(esi, gs, edx_329, 0x00, out esi_980), word24, 8);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_389, gs, SEQ(ecx_327 >> 0x1F, ecx_327));
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_389, gs, (uint64) (uint32) ebx_331);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_435 = *((word32) eax_18 + 24);
	if (*((word32) ecx_435 + 188) != 0x00 && (*((word32) ecx_435 + 0x00A0) > 0x00 && dwArg10 == *ecx_435))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.gotraceback(dwLoc40);
	Eq_4 esp_505 = <invalid>;
	word32 ecx_511 = (word32) *((word32) esp_505 + 5);
	byte cl_514 = (byte) ecx_511;
	if (*esp_505 <= 0x00)
	{
l0807BCB0:
		if ((byte) ecx_511 != 0x00)
		{
			int32 eax_673 = g_dw81575AC;
			g_dw81575AC = eax_673 + 0x01;
			if (eax_673 + 0x01 < g_t8145400 - g_dw81575BC)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.raiseproc();
				word32 edi_979;
				runtime.usleep(out edi_979);
			}
			runtime.crash(gs);
		}
		runtime.exit();
		return;
	}
	Eq_4 edx_554;
	*((word32) esp_505 + 23) = cl_514;
	*esp_505 = *((word32) esp_505 + 76);
	Eq_4 esi_524 = runtime.goroutineheader(gs, *esp_505);
	Eq_4 eax_530 = *((word32) esp_505 + 56);
	Eq_4 eax_536 = *((word32) eax_530 + 48);
	*esp_505 = *((word32) eax_530 + 76);
	*((word32) esp_505 + 4) = eax_536;
	((word32) esp_505 + 8)->u0 = 0x00;
	*((word32) esp_505 + 0x0C) = *((word32) esp_505 + 76);
	runtime.tracebacktrap(gs, *((word32) esp_505 + 8), *((word32) esp_505 + 0x0C));
	if (g_dw81575AC > 0x00)
	{
		Eq_4 ecx_557 = *((word32) *((word32) *((word32) esp_505 + 44) + 24) + 84);
		edx_554 = *((word32) esp_505 + 76);
		if (edx_554 != ecx_557 && ecx_557 != 0x00)
		{
			*esp_505 = ecx_557;
			runtime.readgstatus(*esp_505);
			esp_505.u0 = <invalid>;
			if ((*((byte) esp_505.u0 + 4) & ~0x1000) == 0x02)
			{
				*esp_505.u0 = *((word32) *((word32) *((byte) esp_505.u0 + 44) + 24) + 84);
				esi_524 = runtime.goroutineheader(gs, *esp_505.u0);
				*((byte) esp_505.u0 + 0x0C) = *((word32) *((word32) *((byte) esp_505.u0 + 44) + 24) + 84);
				esp_505.u0->u0 = ~0x00;
				((byte) esp_505.u0 + 4)->u0 = ~0x00;
				((byte) esp_505.u0 + 8)->u0 = 0x00;
				runtime.traceback(gs);
l0807BD8B:
				*esp_505.u0 = (byte) esp_505.u0 + 52;
				runtime.dumpregs(esi_524, gs, *esp_505.u0);
				ecx_511 = (word32) *((byte) esp_505.u0 + 23);
				goto l0807BCB0;
			}
			edx_554 = *((byte) esp_505.u0 + 76);
		}
	}
	else
		edx_554 = *((word32) esp_505 + 76);
	if (g_dw81575AC == 0x00)
	{
		*esp_505.u0 = edx_554;
		esi_524 = runtime.tracebackothers(esi_524, gs, *esp_505.u0);
		runtime.printlock(gs);
		esp_505.u0->u0 = 0x080E0D9C;
		((byte) esp_505.u0 + 4)->u0 = 0x01;
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	goto l0807BD8B;
}

// 0807BFD0: void os.sigpipe(Register (ptr32 Eq_2) gs)
// Called from:
//      os.epipecheck
void os.sigpipe(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_41;
	word32 edi_42;
	runtime.systemstack(gs, 0x080E7CC4, out ebp_41, out edi_42);
}

// 0807C000: void runtime.init.4(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
void runtime.init.4(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0807C020: void runtime.initsig(Register (ptr32 Eq_2) gs, Stack byte bArg04)
// Called from:
//      runtime.mstart1
void runtime.initsig(struct Eq_2 * gs, byte bArg04)
{
	byte al_9 = (byte) (word32) bArg04;
	if (al_9 == 0x00)
		g_b8157575 = 0x01;
	bool Z_30;
	if ((byte) (word32) g_b8157570 != 0x00)
		Z_30 = SLICE(cond(al_9), bool, 2);
	else
	{
		if ((byte) (word32) g_b8157572 == 0x00)
			goto l0807C051;
		Z_30 = SLICE(cond(al_9), bool, 2);
	}
	if (Z_30)
		return;
l0807C051:
	uint32 eax_138 = 0x00;
	while (true)
	{
		byte bLoc10_160 = (byte) dwLoc10;
		if (eax_138 >= 0x41)
			break;
		ui32 ecx_49 = g_a8144820[eax_138];
		if (ecx_49 != 0x00 && (ecx_49 & 0x10) == 0x00)
		{
			runtime.getsig(gs);
			g_a8157940[eax_138 * 0x04] = dwLoc10;
			runtime.sigInstallGoHandler(gs, eax_138);
			if ((byte) (word32) bLoc10_160 == 0x00)
			{
				word32 edx_116 = g_a8157940[eax_138 * 0x04];
				if (edx_116 != 0x00 && edx_116 != 0x01)
					runtime.setsigstack();
			}
			else
			{
				g_a8157A60[eax_138 * 0x04] = 0x01;
				word32 ebp_99 = g_dw80E7CBC;
				runtime.setsig(ebp_99);
				dwLoc10 = ebp_99;
			}
		}
		++eax_138;
	}
}

// 0807C150: void runtime.sigInstallGoHandler(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04)
// Called from:
//      runtime.initsig
void runtime.sigInstallGoHandler(struct Eq_2 * gs, uint32 dwArg04)
{
	if (dwArg04 <= 0x02)
	{
		if (dwArg04 >= 0x41)
			runtime.panicindex(gs);
		runtime/internal/atomic.Loaduintptr();
		if (dwLoc04 == 0x01)
			return;
	}
	if (dwArg04 >= 0x41)
		runtime.panicindex(gs);
	else
	{
		ui32 ecx_31 = g_a8144820[dwArg04];
		if ((ecx_31 & 0x40) != 0x00)
			return;
		if ((byte) (word32) g_b8157570 == 0x00 && (byte) ((word32) g_b8157572) == 0x00 || ((ecx_31 & 0x08) != 0x00 || dwArg04 == 0x0D))
			;
	}
}

// 0807C200: void runtime.setThreadCPUProfiler(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.execute
void runtime.setThreadCPUProfiler(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.setitimer();
	else
		runtime.setitimer();
	*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x0084) = dwArg04;
}

// 0807C2E0: void runtime.sigpipe(Register (ptr32 Eq_2) gs)
void runtime.sigpipe(struct Eq_2 * gs)
{
	byte bLoc04_84 = (byte) dwLoc04;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.sigsend(gs, dwLoc0C, 0x0D, dwLoc04);
	if ((byte) (word32) bLoc04_84 != 0x00)
		return;
	runtime.dieFromSignal(gs, 0x0D);
}

// 0807C330: void runtime.sigtrampgo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_65413) dwArg0C)
// Called from:
//      runtime.cgoSigtramp
void runtime.sigtrampgo(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_65413 * dwArg0C)
{
	fn0808FD8A(0x00, fp - 0x18);
	runtime.sigfwdgo(gs, dwArg00, dwArg04, dwArg08, dwLoc50);
	if ((byte) (word32) bLoc4C != 0x00)
		return;
	Eq_4 ecx_39 = gs->ptr0000->tFFFFFFFC;
	if (ecx_39 == 0x00)
	{
		if (dwArg04 != 0x1B)
			runtime.badsignal(gs, dwArg04, fp - 0x20);
		else
			runtime.sigprofNonGoPC(gs);
	}
	else
	{
		byte al_286;
		fn0808FD8B(0x00, fp - 0x40);
		Eq_4 edx_93 = *((word32) ecx_39 + 24);
		Eq_4 ebx_94 = *((word32) edx_93 + 44);
		if (fp + 0x04 < *ebx_94 || fp + 0x04 >= *((word32) ebx_94 + 4))
		{
			struct Eq_66174 * eax_110 = *edx_93;
			if (fp + 0x04 >= eax_110->ptr0000 && fp + 0x04 < eax_110->ptr0004)
			{
				Eq_4 eax_245 = gs->ptr0000->tFFFFFFFC;
				struct Eq_66200 * eax_232 = **((word32) ecx_39 + 24);
				Eq_4 edx_247 = *((word32) *((word32) eax_245 + 24) + 44);
				word32 edx_235 = eax_232->dw0004 - eax_232->dw0000;
				ptr32 eax_242 = ***((word32) ecx_39 + 24);
				dwLoc40 = (word32) *edx_247;
				dwLoc3C = *((word32) edx_247 + 4);
				dwLoc38 = *((word32) *((word32) *((word32) eax_245 + 24) + 44) + 8);
				dwLoc34 = *((word32) *((word32) *((word32) eax_245 + 24) + 44) + 0x0C);
				dwLoc30 = *((word32) *((word32) *((word32) eax_245 + 24) + 44) + 64);
				**((word32) *((word32) eax_245 + 24) + 44) = eax_242;
				*((word32) *((word32) *((word32) eax_245 + 24) + 44) + 4) = edx_235 + eax_242;
				*((word32) *((word32) *((word32) eax_245 + 24) + 44) + 8) = eax_242 + 880;
				*((word32) *((word32) *((word32) eax_245 + 24) + 44) + 0x0C) = eax_242 + 880;
				*((word32) *((word32) *((word32) ecx_39 + 24) + 44) + 64) = fp + 0x04;
			}
			else
			{
				runtime.sigaltstack();
				if (false)
				{
					runtime.setg(gs, 0x00);
					runtime.noSignalStack(SLICE(runtime.needm(gs), word24, 8), gs, dwArg04);
				}
				if (fp < 0x04 || fp >= 0x04)
				{
					runtime.setg(gs, 0x00);
					runtime.sigNotOnStack(SLICE(runtime.needm(gs), word24, 8), gs, dwArg04);
				}
				Eq_4 eax_186 = gs->ptr0000->tFFFFFFFC;
				Eq_4 edx_188 = *((word32) *((word32) eax_186 + 24) + 44);
				dwLoc40 = (word32) *edx_188;
				dwLoc3C = *((word32) edx_188 + 4);
				dwLoc38 = *((word32) *((word32) *((word32) eax_186 + 24) + 44) + 8);
				dwLoc34 = *((word32) *((word32) *((word32) eax_186 + 24) + 44) + 0x0C);
				dwLoc30 = *((word32) *((word32) *((word32) eax_186 + 24) + 44) + 64);
				**((word32) *((word32) eax_186 + 24) + 44) = 0x00;
				((word32) *((word32) *((word32) eax_186 + 24) + 44) + 4)->u0 = 0x00;
				((word32) *((word32) *((word32) eax_186 + 24) + 44) + 8)->u0 = 880;
				((word32) *((word32) *((word32) eax_186 + 24) + 44) + 0x0C)->u0 = 880;
				*((word32) *((word32) *((word32) ecx_39 + 24) + 44) + 64) = fp + 0x04;
			}
			al_286 = 0x01;
		}
		else
			al_286 = 0x00;
		Eq_66323 ebx_24_8_307 = SLICE(runtime.setg(gs, *((word32) *((word32) ecx_39 + 24) + 44)), word24, 8);
		if (*((word32) ecx_39 + 8) == ~0x04D1)
			runtime.signalDuringFork(ebx_24_8_307, gs, dwArg04);
		else
		{
			runtime.sighandler(fp + 0x04, gs, dwArg04, dwArg08, dwArg0C, ecx_39);
			runtime.setg(gs, ecx_39);
			if ((byte) (word32) al_286 != 0x00)
			{
				Eq_4 eax_345 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 44);
				*eax_345 = dwLoc40;
				*((word32) eax_345 + 4) = dwLoc3C;
				*((word32) eax_345 + 8) = dwLoc38;
				*((word32) eax_345 + 0x0C) = dwLoc34;
				*((word32) eax_345 + 64) = dwLoc30;
			}
		}
	}
}

// 0807C6D0: void runtime.sigpanic(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.sigpanic(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.canpanic(gs, eax_19);
	if ((byte) (word32) bLoc1C == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_45 = *((word32) eax_19 + 0x008C);
		if (ecx_45 != 0x07)
		{
			if (ecx_45 != 0x08)
			{
				if (ecx_45 != 11)
				{
					if (*((word32) eax_19 + 0x008C) >= 0x41)
						runtime.throw(gs);
					else
					{
						runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
						runtime.gopanic(gs);
					}
				}
				else
				{
					Eq_4 ecx_52 = *((word32) eax_19 + 0x009C);
					if (ecx_52 != 0x00 && (ecx_52 != 0x01 && ecx_52 != 0x02) || *((word32) eax_19 + 0x00A0) >= 0x1000)
					{
						if ((byte) (word32) *((word32) eax_19 + 0x006D) == 0x00)
						{
							Eq_4 eax_77 = *((word32) eax_19 + 0x00A0);
							runtime.printlock(gs);
							runtime.printstring(gs);
							word32 esi_307;
							runtime.printhex(esi, gs, eax_77, 0x00, out esi_307);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							runtime.throw(gs);
						}
						else
							runtime.panicmem(gs);
					}
					else
						runtime.panicmem(gs);
				}
			}
			else
			{
				Eq_4 ecx_139 = *((word32) eax_19 + 0x009C);
				if (ecx_139 == 0x01)
					runtime.panicdivide(gs);
				else if (ecx_139 == 0x02)
					runtime.panicoverflow(gs);
				else
					runtime.panicfloat(gs);
			}
		}
		else if (*((word32) eax_19 + 0x009C) != 0x02 || *((word32) eax_19 + 0x00A0) >= 0x1000)
		{
			if ((byte) (word32) *((word32) eax_19 + 0x006D) == 0x00)
			{
				Eq_4 eax_206 = *((word32) eax_19 + 0x00A0);
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_306;
				runtime.printhex(esi, gs, eax_206, 0x00, out esi_306);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			else
				runtime.panicmem(gs);
		}
		else
			runtime.panicmem(gs);
	}
}

// 0807C940: Register word32 runtime.dieFromSignal(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sighandler
//      runtime.sigpipe
//      runtime.crash
//      runtime.sigfwdgo
word32 runtime.dieFromSignal(struct Eq_2 * gs, Eq_4 dwArg04)
{
	runtime.setsig(0x00);
	word32 esi_28 = runtime.unblocksig(gs, dwArg04);
	runtime.raise();
	runtime.osyield();
	runtime.osyield();
	runtime.osyield();
	runtime.exit();
	return esi_28;
}

// 0807C990: void runtime.raisebadsignal(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 (ptr32 Eq_66739)) dwArg08)
// Called from:
//      runtime.badsignal
void runtime.raisebadsignal(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_66739 ** dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x1B)
		return;
	word32 ecx_28;
	if (dwArg04 >= 0x41)
		ecx_28 = 0x00;
	else
	{
		runtime/internal/atomic.Loaduintptr();
		ecx_28 = dwLoc10;
	}
	runtime.unblocksig(gs, dwArg04);
	runtime.setsig(ecx_28);
	if (((byte) (word32) g_b8157570 != 0x00 || (byte) ((word32) g_b8157572) != 0x00) && (ecx_28 == 0x00 && *((char *) (*dwArg08) + 8) != 0x00))
		return;
	runtime.raise();
	word32 edi_207;
	runtime.usleep(out edi_207);
	runtime.setsig(g_dw80E7CBC);
}

// 0807CA90: void runtime.crash(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.dopanic_m
//      runtime.sighandler
void runtime.crash(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.dieFromSignal(gs, 0x06);
}

// 0807CAC0: void runtime.noSignalStack(Register Eq_66371 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigtrampgo
void runtime.noSignalStack(Eq_66371 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, (uint64) (uint32) dwArg04);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0807CB50: void runtime.sigNotOnStack(Register Eq_66388 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigtrampgo
void runtime.sigNotOnStack(Eq_66388 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, (uint64) (uint32) dwArg04);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0807CBE0: void runtime.signalDuringFork(Register Eq_66323 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigtrampgo
void runtime.signalDuringFork(Eq_66323 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, (uint64) (uint32) dwArg04);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0807CC70: void runtime.badsignal(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 (ptr32 Eq_66739)) dwArg08)
// Called from:
//      runtime.sigtrampgo
void runtime.badsignal(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_66739 ** dwArg08)
{
	byte bLoc04_77 = (byte) dwLoc04;
	runtime.needm(gs);
	runtime.sigsend(gs, dwLoc0C, dwArg04, dwLoc04);
	if ((byte) (word32) bLoc04_77 == 0x00)
		runtime.raisebadsignal(gs, dwArg04, dwArg08);
	runtime.dropm(gs);
}

// 0807CCB0: void runtime.sigfwdgo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sigtrampgo
void runtime.sigfwdgo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	if (dwArg04 >= 0x41)
		return;
	runtime/internal/atomic.Loaduintptr();
	if ((byte) (word32) g_b8157575 == 0x00)
	{
		if (dwLoc18 == null)
			runtime.dieFromSignal(gs, dwArg04);
		else
			runtime.sigfwd(dwLoc18, dwArg04, dwArg08, dwArg0C);
	}
	else
	{
		if (dwLoc18 == null)
			return;
		runtime/internal/atomic.Load();
		if (dwLoc14 == 0x00)
			runtime.sigfwd(dwLoc08, dwArg08, dwArg0C, dwArg10);
		else
		{
			ui32 ecx_99 = g_a8144820[dwArg08];
			if ((*((word32) dwArg0C + 8) == 0x00 || (ecx_99 & 0x08) == 0x00) && dwArg08 != 0x0D)
				return;
			Eq_4 ecx_124 = gs->ptr0000->tFFFFFFFC;
			if (ecx_124 != 0x00)
			{
				Eq_4 ecx_128 = *((word32) ecx_124 + 24);
				if (ecx_128 != 0x00 && (*((word32) ecx_128 + 84) != 0x00 && (byte) ((word32) (*((word32) ecx_128 + 0x0091))) == 0x00))
					return;
			}
			if (dwLoc08 != (<anonymous> *) 0x01)
				runtime.sigfwd(dwLoc08, dwArg08, dwArg0C, dwArg10);
		}
	}
}

// 0807CE30: void runtime.msigsave()
// Called from:
//      runtime.schedinit
//      runtime.needm
void runtime.msigsave()
{
	runtime.sigprocmask();
}

// 0807CE60: void runtime.msigrestore()
// Called from:
//      runtime.dropm
void runtime.msigrestore()
{
	runtime.sigprocmask();
}

// 0807CE90: void runtime.sigblock()
// Called from:
//      runtime.needm
//      runtime.dropm
void runtime.sigblock()
{
	runtime.sigprocmask();
}

// 0807CEC0: Register word32 runtime.unblocksig(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.dieFromSignal
//      runtime.raisebadsignal
word32 runtime.unblocksig(struct Eq_2 * gs, Eq_4 dwArg04)
{
	Eq_66972 edx_11 = (word32) dwArg04 + (((dwArg04 - 0x01 >> 0x1F) >> 0x1B) - 0x01);
	if (edx_11 >> 0x05 >= 0x02)
		runtime.panicindex(gs);
	else
	{
		(fp - 0x08)[edx_11 >> 0x05] |= 0x01 << (byte) (dwArg04 - 0x01);
		return runtime.sigprocmask();
	}
}

// 0807CF30: void runtime.minitSignals(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.minit
void runtime.minitSignals(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.minitSignalStack(gs);
	runtime.minitSignalMask(gs);
}

// 0807CF60: void runtime.minitSignalStack(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.minitSignals
void runtime.minitSignalStack(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.sigaltstack();
	if (true)
	{
		Eq_4 eax_59 = gs->ptr0000->tFFFFFFFC;
		**((word32) *((word32) eax_59 + 24) + 44) = 0x00;
		((word32) *((word32) *((word32) eax_59 + 24) + 44) + 4)->u0 = 0x00;
		((word32) *((word32) *((word32) eax_59 + 24) + 44) + 8)->u0 = 880;
		((word32) *((word32) *((word32) eax_59 + 24) + 44) + 0x0C)->u0 = 880;
		*((word32) *((word32) eax_19 + 24) + 0x008F) = 0x00;
	}
	else
	{
		runtime.signalstack();
		*((word32) *((word32) eax_19 + 24) + 0x008F) = 0x01;
	}
}

// 0807D050: void runtime.minitSignalMask(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.minitSignals
void runtime.minitSignalMask(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_67123 eax_24 = 0x00;
	while (eax_24 < 0x41)
	{
		if (eax_24 >= 0x41)
			runtime.panicindex(gs);
		if ((g_a8144820[eax_24] & 0x80) != 0x00)
		{
			Eq_67140 edx_59 = (word32) eax_24 + (((eax_24 - 0x01 >> 0x1F) >> 0x1B) - 0x01);
			if (edx_59 >> 0x05 >= 0x02)
				runtime.panicindex(gs);
			(fp - 0x08)[edx_59 >> 0x05] = ~(0x01 << (byte) (eax_24 - 0x01)) & (fp - 0x08)[edx_59 >> 0x05];
		}
		eax_24 = (word32) eax_24 + 1;
	}
	runtime.sigprocmask();
}

// 0807D120: void runtime.unminitSignals(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.unminit
void runtime.unminitSignals(struct Eq_2 * gs)
{
	if ((byte) (word32) *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x008F) != 0x00)
		runtime.sigaltstack();
}

// 0807D170: void runtime.signalstack()
// Called from:
//      runtime.minitSignalStack
void runtime.signalstack()
{
	runtime.sigaltstack();
}

// 0807D1C0: void runtime.sigsend(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_65416 bArg08)
// Called from:
//      runtime.sighandler
//      runtime.sigpipe
//      runtime.badsignal
void runtime.sigsend(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_65416 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) g_b8157798 == 0x00 || dwArg04 >= 0x60)
		return;
	if (dwArg04 >> 0x05 >= 0x03)
		runtime.panicindex(gs);
	else
	{
		runtime/internal/atomic.Load();
		ui32 eax_37 = 0x01 << (byte) dwArg08;
		if ((dwLoc10 & eax_37) == 0x00)
			return;
		do
		{
			Eq_4 ebx_50 = *((char *) g_a8157764 + dwArg00 * 0x04);
			Eq_4 edx_51 = dwArg00 * 0x04 + 135624548;
			if ((ebx_50 & eax_37) != 0x00)
				return;
			Eq_4 ebx_61 = ebx_50 | eax_37;
			runtime/internal/atomic.Cas(edx_51, ebx_50, ebx_61);
			Eq_4 dwLoc14_157 = edx_51;
			byte bLoc0C_226 = (byte) ebx_61;
		} while ((byte) (word32) bLoc08 == 0x00);
		do
		{
			runtime/internal/atomic.Load();
			if (dwLoc14_157 != 0x00)
			{
				if (dwLoc14_157 != 0x01)
				{
					if (dwLoc14_157 == 0x02)
						return;
					runtime.throw(gs);
				}
				else
				{
					runtime/internal/atomic.Cas(135624596, 0x01, 0x00);
					dwLoc14_157.u0 = 0x01;
					if ((byte) (word32) bLoc0C_226 == 0x00)
						continue;
					runtime.notewakeup(gs, 135624544);
					return;
				}
			}
			runtime/internal/atomic.Cas(135624596, 0x00, 0x02);
			dwLoc14_157.u0 = 0x00;
		} while ((byte) (word32) bLoc0C_226 == 0x00);
	}
}

// 0807D340: void runtime.signal_ignored(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sighandler
void runtime.signal_ignored(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 >> 0x05 >= 0x03)
		runtime.panicindex(gs);
	else
		runtime/internal/atomic.Load();
}

// 0807D3A0: Register word32 runtime.makeslice(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ediOut)
// Called from:
//      runtime.panicwrap
//      runtime.goargs
//      runtime.goenvs_unix
//      strconv.(*decimal).String
//      sync.(*Pool).pinSlow
//      syscall.ByteSliceFromString
//      os.Readlink
//      reflect.newName
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).Method
//      reflect.Value.MapKeys
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*pp).printValue
word32 runtime.makeslice(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_26;
	Eq_67324 edx_18 = *dwArg04;
	if (edx_18 < 33)
		eax_26 = *((char *) g_a81386E0 + edx_18 * 0x04);
	else
		eax_26 = (uint32) (0xFFFFFFFF /u edx_18);
	if (dwArg08 < 0x00 || dwArg08 > eax_26)
		runtime.gopanic(gs);
	else if (dwArg0C < dwArg08 || dwArg0C > eax_26)
		runtime.gopanic(gs);
	else
	{
		word32 esi_138;
		word32 ebx_91;
		ptr32 edi_93;
		runtime.mallocgc(dwArg08, gs, edx_18 *s dwArg0C, dwArg04, 0x01, out ebx_91, out esi_138, out edi_93);
		ediOut = edi_93;
		return ebx_91;
	}
}

// 0807D470: Register Eq_4 runtime.growslice(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Register out Eq_4 esiOut)
// Called from:
//      runtime.cgocallbackg1
//      runtime.(*hmap).newoverflow
//      runtime.recordspan
//      runtime.freedefer
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.allgadd
//      runtime.(*randomOrder).reset
//      syscall.runtime_envs
//      os.runtime_args
//      reflect.typelinks
//      runtime.expandCgoFrames
//      runtime.modulesinit
//      runtime.typelinksinit
//      runtime.newdefer.func1
//      strconv.genericFtoa
//      strconv.formatDigits
//      strconv.fmtE
//      strconv.fmtF
//      strconv.fmtB
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendQuotedRuneWith
//      strconv.appendEscapedRune
//      sync.(*Pool).Put
//      sync.(*Pool).pinSlow
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).Method
//      reflect.(*structType).FieldByNameFunc
//      reflect.typesByString
//      reflect.FuncOf
//      reflect.funcStr
//      reflect.funcLayout
//      reflect.addTypeBits
//      reflect.FuncOf.func1
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_float
//      fmt.(*buffer).WriteRune
//      fmt.(*pp).Write
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printValue
//      fmt.(*pp).doPrintln
Eq_4 runtime.growslice(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_18 = *dwArg04;
	if (edx_18 == 0x00)
	{
		if (dwArg14 < dwArg10)
			runtime.gopanic(gs);
		else
		{
			esiOut = esi;
			return ebp;
		}
	}
	Eq_4 ebx_152 = dwArg10;
	Eq_4 esi_206 = dwArg14;
	if (dwArg14 <= dwArg10 * 0x02)
	{
		if (dwArg0C >= 0x0400)
		{
			while (ebx_152 < dwArg14)
				ebx_152 = (ebx_152 + ((ebx_152 >> 0x1F) >>u 0x1E) >> 0x02) + ebx_152;
		}
		else
			ebx_152 = dwArg10 * 0x02;
	}
	else
		ebx_152 = dwArg14;
	Eq_4 dwLoc18_476;
	Eq_4 edi_204 = dwArg0C;
	if (edx_18 == 0x01)
	{
		if (ebx_152 >= 0x8000)
		{
			if ((word32) ebx_152 + 0x00002000 >= ebx_152)
				ebx_152 = (word32) ebx_152 + 0x00001FFF & ~0x1FFF;
			goto l0807D52C;
		}
		if (ebx_152 > 1016)
		{
			Eq_67406 ebx_225 = (word32) ebx_152 - 897;
			if (ebx_225 >> 0x07 < 0xF9)
			{
				uint32 ebx_230 = (word32) (ebx_225 >> 0x07)->b81396E0;
				if (ebx_230 < 0x43)
				{
					ebx_152 = (word32) g_a8138820[ebx_230 * 0x02];
l0807D52C:
					dwLoc18_476 = ebx_152;
					goto l0807D532;
				}
			}
			runtime.panicindex(gs);
		}
		else
		{
			Eq_67413 ebx_241 = (word32) ebx_152 + 7;
			if (ebx_241 >> 0x03 < 0x81)
			{
				uint32 ebx_246 = (word32) (ebx_241 >> 0x03)->b8138640;
				if (ebx_246 < 0x43)
				{
					ebx_152 = (word32) g_a8138820[ebx_246 * 0x02];
					goto l0807D52C;
				}
			}
			runtime.panicindex(gs);
		}
	}
	if (edx_18 == 0x04)
	{
		Eq_4 ebx_155 = ebx_152 << 0x02;
		if (ebx_155 >= 0x8000)
		{
			if ((word32) ebx_155 + 0x00002000 >= ebx_155)
				ebx_155 = (word32) ebx_155 + 0x00001FFF & ~0x1FFF;
			goto l0807D72A;
		}
		if (ebx_155 > 1016)
		{
			struct Eq_67552 * ebx_168 = (word32) ebx_155 - 897 >> 0x07;
			if (ebx_168 < (struct Eq_67552 *) 0xF9)
			{
				uint32 ebx_172 = (word32) ebx_168->b81396E0;
				if (ebx_172 < 0x43)
				{
					ebx_155 = (word32) g_a8138820[ebx_172 * 0x02];
l0807D72A:
					edi_204 = dwArg0C << 0x02;
					esi_206 = dwArg14 << 0x02;
					ebx_152 = ebx_155 >> 0x02;
					dwLoc18_476 = ebx_155;
					goto l0807D532;
				}
			}
			runtime.panicindex(gs);
		}
		else
		{
			struct Eq_67559 * ebx_184 = (word32) ebx_155 + 7 >> 0x03;
			if (ebx_184 < (struct Eq_67559 *) 0x81)
			{
				uint32 ebx_188 = (word32) ebx_184->b8138640;
				if (ebx_188 < 0x43)
				{
					ebx_155 = (word32) g_a8138820[ebx_188 * 0x02];
					goto l0807D72A;
				}
			}
			runtime.panicindex(gs);
		}
	}
	edi_204 = dwArg0C *s edx_18;
	esi_206 = dwArg14 *s edx_18;
	Eq_4 ebx_114 = ebx_152 *s edx_18;
	if (ebx_114 >= 0x8000)
	{
		if ((word32) ebx_114 + 0x00002000 >= ebx_114)
			ebx_114 = (word32) ebx_114 + 0x00001FFF & ~0x1FFF;
		goto l0807D7E8;
	}
	if (ebx_114 > 1016)
	{
		struct Eq_67610 * ebx_95 = (word32) ebx_114 - 897 >> 0x07;
		if (ebx_95 < (struct Eq_67610 *) 0xF9)
		{
			uint32 ebx_101 = (word32) ebx_95->b81396E0;
			if (ebx_101 < 0x43)
			{
				ebx_114 = (word32) g_a8138820[ebx_101 * 0x02];
l0807D7E8:
				dwLoc18_476 = ebx_114;
				ebx_152 = (uint32) ((uint64) (uint32) ebx_114 /u edx_18);
l0807D532:
				Eq_4 ebp_342 = dwArg0C;
				Eq_4 esi_267 = dwArg14;
				if (dwArg14 >= dwArg10)
				{
					Eq_4 eax_283;
					if (edx_18 < 33)
						eax_283 = *((char *) g_a81386E0 + edx_18 * 0x04);
					else
					{
						esi_267 = edx_18;
						eax_283 = (uint32) (0xFFFFFFFF /u edx_18);
					}
					if (ebx_152 <= eax_283)
					{
						if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x80) == 0x00)
						{
							word32 edi_686;
							word32 esi_685;
							word32 ebx_684;
							runtime.mallocgc(ebx_152, gs, dwLoc18_476, dwArg04, 0x01, out ebx_684, out esi_685, out edi_686);
							if ((byte) (word32) g_t81576F0 != 0x00)
							{
								Eq_4 ecx_398;
								for (ecx_398 = 0x00; ecx_398 < edi_204; ecx_398 += Mem418[dwArg04 + 0x00:word32])
								{
									esi_267 = dwArg08 + ecx_398;
									word32 edi_688;
									word32 esi_687;
									runtime.typedmemmove(dwArg04, dwLoc30 + ecx_398, esi_267, out esi_687, out edi_688);
									ebp_342 = dwArg08;
								}
							}
							else
							{
								word32 edi_387;
								runtime.memmove(dwLoc30, dwArg08, edi_204, out ebp_342, out esi_267, out edi_387);
							}
						}
						else
						{
							word32 edi_682;
							word32 esi_681;
							word32 ebx_680;
							runtime.mallocgc(ebx_358, gs, dwLoc18_476, 0x00, 0x00, out ebx_680, out esi_681, out edi_682);
							word32 edi_683;
							runtime.memmove(dwLoc30, dwArg08, edi_204, out ebp_342, out esi_267, out edi_683);
							runtime.memclrNoHeapPointers(dwLoc30 + esi_206, dwLoc18_476 - esi_206);
						}
						esiOut = esi_267;
						return ebp_342;
					}
				}
				runtime.gopanic(gs);
			}
		}
		runtime.panicindex(gs);
	}
	else
	{
		struct Eq_67617 * ebx_116 = (word32) ebx_114 + 7 >> 0x03;
		if (ebx_116 < (struct Eq_67617 *) 0x81)
		{
			uint32 ebx_120 = (word32) ebx_116->b8138640;
			if (ebx_120 < 0x43)
			{
				ebx_114 = (word32) g_a8138820[ebx_120 * 0x02];
				goto l0807D7E8;
			}
		}
		runtime.panicindex(gs);
	}
}

// 0807D900: void runtime.stackinit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.stackinit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_67675 eax_16 = 0x00;
	while (eax_16 < 0x04)
	{
		if (eax_16 >= 0x04)
			runtime.panicindex(gs);
		g_a8145280[eax_16] = (struct Eq_141364) 0x00;
		g_a8145284[eax_16] = (struct Eq_141365) 0x00;
		eax_16 = (word32) eax_16 + 1;
	}
	Eq_67679 eax_22 = 0x00;
	while (eax_22 < 0x13)
	{
		if (eax_22 >= 0x13)
			runtime.panicindex(gs);
		g_a8145344[eax_22] = (struct Eq_141366) 0x00;
		g_a8145348[eax_22] = (struct Eq_141367) 0x00;
		eax_22 = (word32) eax_22 + 1;
	}
}

// 0807D980: void runtime.stacklog2(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stackalloc
//      runtime.stackfree
void runtime.stacklog2(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_15;
	for (eax_15 = dwArg04; eax_15 > 0x01; eax_15 >>= 0x01)
		;
}

// 0807D9B0: void runtime.stackpoolalloc(Register (ptr32 Eq_2) gs, Stack byte bArg04)
// Called from:
//      runtime.stackcacherefill
//      runtime.stackalloc
void runtime.stackpoolalloc(struct Eq_2 * gs, byte bArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ecx_19 = (word32) (byte) (word32) bArg04;
	if (ecx_19 >= 0x04)
		runtime.panicindex(gs);
	else
	{
		Eq_4 eax_114;
		Eq_4 ebx_27 = ecx_19 * 0x08 + 0x08145280;
		Eq_4 ecx_30 = g_a8145280[ecx_19];
		if (ecx_30 == 0x00)
		{
			runtime.(*mheap).allocManual(gs);
			if (dwLoc10 == 0x00)
				runtime.throw(gs);
			if ((word16) (word32) *((word32) dwLoc10 + 56) != 0x00)
				runtime.throw(gs);
			if (*((word32) dwLoc10 + 20) != 0x00)
				runtime.throw(gs);
			cu8 cl_80 = (byte) (word32) bArg04;
			*((word32) dwLoc10 + 64) = 0x0800 << cl_80 & 0x00 - (cl_80 < 0x20);
			up32 ecx_102 = 0x00;
			while (ecx_102 < 0x8000)
			{
				Eq_4 edx_96 = (word32) *((word32) dwLoc10 + 0x0C) + ecx_102;
				*edx_96 = *((word32) dwLoc10 + 20);
				*((word32) dwLoc10 + 20) = edx_96;
				ecx_102 = (word32) *((word32) dwLoc10 + 64) + ecx_102;
			}
			runtime.(*mSpanList).insert(gs, ebx_27, dwLoc10);
			eax_114 = dwLoc10;
		}
		else
			eax_114 = ecx_30;
		Eq_4 ecx_117 = *((word32) eax_114 + 20);
		if (ecx_117 == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) eax_114 + 20) = *ecx_117;
			*((word32) eax_114 + 56) = (word16) ((word32) *((word32) eax_114 + 56) + 0x01);
			if (*((word32) eax_114 + 20) == 0x00)
				runtime.(*mSpanList).remove(gs, ebx_27, eax_114);
		}
	}
}

// 0807DB40: void runtime.stackpoolfree(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackfree
void runtime.stackpoolfree(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ecx_20 = dwArg04 - g_t81493A8;
	Eq_4 ebx_22 = g_t8149108;
	if (ecx_20 >> 0x0D >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		Eq_4 eax_30 = *((word32) ebx_22 + (ecx_20 >> 0x0D) * 0x04);
		if ((byte) (word32) *((word32) eax_30 + 60) != 0x02)
			runtime.throw(gs);
		else
		{
			if (*((word32) eax_30 + 20) == 0x00)
			{
				uint32 ebx_49 = (word32) (byte) (word32) bArg08;
				if (ebx_49 >= 0x04)
					runtime.panicindex(gs);
				runtime.(*mSpanList).insert(gs, ebx_49 * 0x08 + 0x08145280, eax_30);
			}
			*dwArg04 = *((word32) eax_30 + 20);
			*((word32) eax_30 + 20) = dwArg04;
			word32 ecx_73 = (word32) *((word32) eax_30 + 56);
			*((word32) eax_30 + 56) = (word16) (ecx_73 - 0x01);
			word16 cx_81 = (word16) ecx_73;
			if (g_dw81575E4 != 0x00 || cx_81 != 0x01)
				return;
			uint32 ecx_87 = (word32) (byte) (word32) bArg08;
			if (ecx_87 >= 0x04)
				runtime.panicindex(gs);
			else
			{
				runtime.(*mSpanList).remove(gs, ecx_87 * 0x08 + 0x08145280, eax_30);
				((word32) eax_30 + 20)->u0 = 0x00;
				runtime.(*mheap).freeManual(gs, eax_30, &g_t81581E0);
			}
		}
	}
}

// 0807DC80: void runtime.stackcacherefill(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.stackalloc
void runtime.stackcacherefill(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	word32 ebp_108;
	word32 esi_109;
	word32 edi_110;
	runtime.lock(esi, gs, 0x08157644, out ebp_108, out esi_109, out edi_110);
	uint32 eax_24 = 0x00;
	struct Eq_67998 * ecx_25 = null;
	while (eax_24 < 0x4000)
	{
		runtime.stackpoolalloc(gs, (byte) (word32) bArg08);
		dwLoc0C->ptr0000 = ecx_25;
		cu8 cl_49 = (byte) (word32) bArg08;
		ecx_25 = dwLoc0C;
		eax_24 = (0x0800 << cl_49 & 0x00 - (cl_49 < 0x20)) + eax_24;
	}
	word32 edx_111;
	word32 ebx_112;
	runtime.unlock(gs, 0x08157644, out edx_111, out ebx_112);
	uint32 ecx_71 = (word32) (byte) (word32) bArg08;
	if (ecx_71 >= 0x04)
		runtime.panicindex(gs);
	else
	{
		*((word32) dwArg04 + (ecx_71 * 0x08 + 556)) = ecx_25;
		*((word32) dwArg04 + (ecx_71 * 0x08 + 560)) = eax_24;
	}
}

// 0807DD50: void runtime.stackcacherelease(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.stackfree
void runtime.stackcacherelease(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	uint32 edx_22 = (word32) (byte) (word32) bArg08;
	if (edx_22 >= 0x04)
		runtime.panicindex(gs);
	else
	{
		struct Eq_68070 * ecx_30 = (word32) dwArg04 + 556 + edx_22 * 0x08;
		Eq_4 ebx_31 = ecx_30->t0000;
		up32 ecx_33 = ecx_30->dw0004;
		word32 ebp_127;
		word32 esi_128;
		word32 edi_129;
		runtime.lock(esi, gs, 0x08157644, out ebp_127, out esi_128, out edi_129);
		union Eq_4 * edx_43 = (word32) dwArg04 + 556 + edx_22 * 0x08;
		up32 ebx_48;
		Eq_4 ebp_49 = ebx_31;
		for (ebx_48 = ecx_33; ebx_48 > 0x4000; ebx_48 -= 0x0800 << cl_70 & 0x00 - (cl_70 < 0x20))
		{
			Eq_4 eax_57 = *ebp_49;
			runtime.stackpoolfree(gs, ebp_49, (byte) (word32) bArg08);
			cu8 cl_70 = (byte) (word32) bArg08;
			ebp_49 = eax_57;
		}
		word32 edx_130;
		word32 ebx_131;
		runtime.unlock(gs, 0x08157644, out edx_130, out ebx_131);
		*edx_43 = (union Eq_4 *) ebp_49;
		*((word32) dwArg04 + (edx_22 * 0x08 + 560)) = ebx_48;
	}
}

// 0807DE60: Register Eq_4 runtime.stackcache_clear(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.flushmcache
//      runtime.freemcache.func1
Eq_4 runtime.stackcache_clear(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	word32 ebp_132;
	word32 esi_133;
	word32 edi_134;
	runtime.lock(esi, gs, 0x08157644, out ebp_132, out esi_133, out edi_134);
	uip32 eax_129 = 0x00;
	while (true)
	{
		cu8 al_27 = (byte) eax_129;
		if (al_27 >= 0x04)
			break;
		uint32 edx_43 = (word32) al_27;
		if (edx_43 >= 0x04)
			runtime.panicindex(gs);
		union Eq_4 * ebx_51 = (word32) dwArg04 + 556 + edx_43 * 0x08;
		Eq_4 ebp_53 = *ebx_51;
		uip32 eax_127 = eax_129;
		while (true)
		{
			byte al_67 = (byte) eax_127;
			esi = ebp_53;
			if (ebp_53 == 0x00)
				break;
			Eq_4 ecx_63 = *ebp_53;
			runtime.stackpoolfree(gs, ebp_53, al_67);
			eax_127 = (word32) al_27;
			ebp_53 = ecx_63;
		}
		*ebx_51 = (union Eq_4 *) 0x00;
		*((word32) dwArg04 + (edx_43 * 0x08 + 560)) = 0x00;
		eax_129 = eax_127 + 0x01;
	}
	word32 edx_135;
	word32 ebx_136;
	runtime.unlock(gs, 0x08157644, out edx_135, out ebx_136);
	return esi;
}

// 0807DF20: void runtime.stackalloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.copystack
//      runtime.malg.func1
//      runtime.gfget.func1
void runtime.stackalloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (eax_18 != *ecx_19)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_166 = dwArg04;
		if ((dwArg04 & dwArg04 - 0x01) != 0x00)
			runtime.throw(gs);
		else if (g_dw8157728 != 0x00)
		{
			runtime.sysAlloc();
			if (dwLoc2C != 0x00)
				return;
			runtime.throw(gs);
		}
		else if (dwArg04 >= 0x8000)
		{
			runtime.stacklog2(gs, dwArg04 >> 0x0D);
			word32 edi_392;
			word32 esi_391;
			word32 ebp_390;
			runtime.lock(esi, gs, 0x08145340, out ebp_390, out esi_391, out edi_392);
			if (dwLoc30 >= 0x13)
				runtime.panicindex(gs);
			else
			{
				Eq_4 eax_117;
				Eq_4 edx_104 = dwLoc30 * 0x08 + 0x08145344;
				Eq_4 eax_106 = g_a8145344[dwLoc30];
				if (eax_106 == 0x00)
					eax_117.u0 = 0x00;
				else
				{
					runtime.(*mSpanList).remove(gs, edx_104, eax_106);
					eax_117 = eax_106;
				}
				word32 ebx_398;
				word32 edx_397;
				runtime.unlock(gs, 0x08145340, out edx_397, out ebx_398);
				if (eax_117 != 0x00)
					return;
				runtime.(*mheap).allocManual(gs);
				if (dwLoc28 == null)
					runtime.throw(gs);
				else
					dwLoc28->t0040 = dwArg04;
			}
		}
		else
		{
			word32 ebx_163 = 0x00;
			while (true)
			{
				byte bl_173 = (byte) ebx_163;
				if (eax_166 <= 0x0800)
					break;
				++ebx_163;
				eax_166 >>= 0x01;
			}
			Eq_4 eax_177 = *((word32) ecx_19 + 0x00B8);
			if (eax_177 == 0x00 || (*((word32) ecx_19 + 116) != 0x00 || *((word32) ecx_19 + 0x0088) != 0x00))
			{
				word32 esi_394;
				word32 edi_395;
				word32 ebp_393;
				runtime.lock(esi, gs, 0x08157644, out ebp_393, out esi_394, out edi_395);
				runtime.stackpoolalloc(gs, (byte) (word32) bl_173);
				word32 edx_251;
				word32 ebx_396;
				runtime.unlock(gs, 0x08157644, out edx_251, out ebx_396);
			}
			else
			{
				uint32 ecx_189 = (word32) bl_173;
				if (ecx_189 >= 0x04)
					runtime.panicindex(gs);
				else
				{
					struct Eq_68358 * ebp_197 = (word32) eax_177 + 556 + ecx_189 * 0x08;
					struct Eq_68364 * esi_198 = ebp_197->ptr0000;
					struct Eq_68364 ** ecx_199 = (word32) eax_177 + 556 + ecx_189 * 0x08;
					if (esi_198 == null)
					{
						runtime.stackcacherefill(gs, eax_177, bl_173);
						esi_198 = (struct Eq_68364 *) *ecx_199;
					}
					*ecx_199 = (struct Eq_68364 **) esi_198->ptr0000;
					ebp_197->dw0004 -= dwArg04;
				}
			}
		}
	}
}

// 0807E1C0: Register Eq_4 runtime.stackfree(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gfput
//      runtime.copystack
//      runtime.shrinkstack
Eq_4 runtime.stackfree(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	uint32 ebx_23 = dwArg08 - dwArg04;
	if ((ebx_23 & ebx_23 - 0x01) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 esi_190 = (word32) dwArg04 + ebx_23;
		if (esi_190 < dwArg08)
			runtime.throw(gs);
		else if (g_dw8157728 != 0x00)
		{
			runtime.sysFault(gs);
			return esi_190;
		}
		else if (ebx_23 >= 0x8000)
		{
			uint32 ecx_60 = dwArg04 - g_t81493A8;
			Eq_4 ebx_62 = g_t8149108;
			if (ecx_60 >> 0x0D >= g_t814910C)
				runtime.panicindex(gs);
			else
			{
				Eq_4 eax_70 = *((word32) ebx_62 + (ecx_60 >> 0x0D) * 0x04);
				if ((byte) (word32) *((word32) eax_70 + 60) != 0x02)
				{
					Eq_4 eax_76 = *((word32) eax_70 + 0x0C);
					runtime.printlock(gs);
					word32 esi_376;
					runtime.printhex(esi, gs, eax_76, 0x00, out esi_376);
					runtime.printsp(gs);
					runtime.printpointer(gs);
					runtime.printnl(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				else if (g_dw81575E4 != 0x00)
				{
					runtime.stacklog2(gs, *((word32) eax_70 + 16));
					word32 edi_379;
					word32 ebp_377;
					word32 esi_378;
					runtime.lock(esi, gs, 0x08145340, out ebp_377, out esi_378, out edi_379);
					if (dwLoc28 >= 0x13)
						runtime.panicindex(gs);
					else
					{
						runtime.(*mSpanList).insert(gs, dwLoc28 * 0x08 + 0x08145344, eax_70);
						word32 edx_380;
						word32 ebx_381;
						runtime.unlock(gs, 0x08145340, out edx_380, out ebx_381);
						return esi_190;
					}
				}
				else
				{
					runtime.(*mheap).freeManual(gs, eax_70, &g_t81581E0);
					return esi_190;
				}
			}
		}
		else
		{
			word32 ebp_165 = 0x00;
			ebx_168 = ebx_23;
			while (true)
			{
				uint32 ebx_168;
				if (ebx_168 <= 0x0800)
					break;
				++ebp_165;
				ebx_168 >>= 0x01;
			}
			Eq_4 eax_185 = *((word32) eax_18 + 24);
			byte al_179 = (byte) ebp_165;
			Eq_4 ebx_186 = *((word32) eax_185 + 0x00B8);
			if (ebx_186 != 0x00)
			{
				esi_190 = *((word32) eax_185 + 116);
				if (esi_190 == 0x00 && *((word32) eax_185 + 0x0088) == 0x00)
				{
					uint32 eax_202 = (word32) (byte) ebp_165;
					if (eax_202 >= 0x04)
						runtime.panicindex(gs);
					else
					{
						up32 * eax_214 = (word32) ebx_186 + 560 + eax_202 * 0x08;
						Eq_4 esi_213 = (word32) ebx_186 + 556 + eax_202 * 0x08;
						if (*eax_214 >= 0x8000)
							runtime.stackcacherelease(gs, ebx_186, (byte) ebp_165);
						*dwArg04 = *esi_213;
						*esi_213 = dwArg04;
						*eax_214 += ebx_23;
						esi_190 = esi_213;
						return esi_190;
					}
				}
			}
			word32 edi_374;
			word32 ebp_372;
			word32 esi_373;
			runtime.lock(esi, gs, 0x08157644, out ebp_372, out esi_373, out edi_374);
			runtime.stackpoolfree(gs, dwArg04, (byte) (word32) al_179);
			word32 edx_274;
			word32 ebx_375;
			runtime.unlock(gs, 0x08157644, out edx_274, out ebx_375);
			return esi_190;
		}
	}
}

// 0807E460: void runtime.adjustpointers(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Stack (ptr32 Eq_68633) dwArg08, Stack (ptr32 Eq_68634) dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.adjustframe
void runtime.adjustpointers(struct Eq_2 * gs, up32 dwArg04, struct Eq_68633 * dwArg08, struct Eq_68634 * dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_21 = dwArg08->dw0000;
	byte (* edx_18)[] = dwArg08->ptr0004;
	Eq_68657 ebx_25 = (eax_21 + 0x07 >> 0x1F >> 0x1D) + 0x07 + eax_21;
	if (ebx_25 >> 0x03 > 0x40000000)
		runtime.panicslice(gs);
	else
	{
		Eq_4 edx_34 = dwArg0C->t0000;
		Eq_4 ebx_36 = dwArg0C->t0004;
		up32 ebp_38 = dwArg0C->dw0008;
		up32 eax_46 = dwArg0C->dw00CC;
		uint32 dwLoc40_296;
		for (dwLoc40_296 = 0x00; dwLoc40_296 < eax_21; ++dwLoc40_296)
		{
			if (dwLoc40_296 >> 0x03 >= ebx_25 >> 0x03)
				runtime.panicindex(gs);
			word32 eax_68 = (word32) Mem55[edx_18 + (dwLoc40_296 >>u 0x03):byte];
			if ((byte) (SEQ(SLICE(eax_68, word24, 8), (byte) eax_68 >> (byte) (dwLoc40_296 & 0x07)) & 0x01) == 0x01)
			{
				union Eq_4 * eax_84 = dwArg04 + dwLoc40_296 * 0x04;
				do
				{
					byte bLoc48_338 = (byte) dwLoc48;
					Eq_4 ebx_88 = *eax_84;
					if (dwArg10 != 0x00 && (ebx_88 > 0x00 && ebx_88 < 0x1000))
					{
						Eq_4 esi_102 = g_t8157744;
						if (esi_102 != 0x00)
						{
							*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 461) = 0x02;
							runtime.funcname(gs, dwArg10, dwArg14);
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printpointer(gs);
							runtime.printstring(gs);
							word32 esi_404;
							runtime.printhex(esi_102, gs, ebx_88, 0x00, out esi_404);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							runtime.throw(gs);
						}
					}
					if (edx_34 > ebx_88 || ebx_88 >= ebx_36)
						break;
					if (dwArg04 >= eax_46)
					{
						*eax_84 = (word32) ebx_88 + ebp_38;
						break;
					}
					runtime/internal/atomic.Casp1(eax_84, ebx_88, (word32) ebx_88 + ebp_38);
				} while ((byte) (word32) bLoc48_338 == 0x00);
			}
		}
	}
}

// 0807E700: void runtime.adjustframe(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_68791) dwArg04, Stack (ptr32 Eq_68634) dwArg08)
void runtime.adjustframe(struct Eq_2 * gs, struct Eq_68791 * dwArg04, struct Eq_68634 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_21 = dwArg04->t000C;
	if (ecx_21 == 0x00)
		return;
	Eq_4 edx_28 = dwArg04->t0000;
	Eq_4 ebx_29 = dwArg04->t0004;
	Eq_4 ebp_30 = *edx_28;
	Eq_4 esi_31 = g_t815764C;
	if (ebp_30 == esi_31)
		return;
	if (ecx_21 != ebp_30)
		--ecx_21;
	runtime.pcdatavalue(gs, edx_28, 0x00);
	Eq_4 dwLoc48_784 = ecx_21;
	Eq_4 eax_66 = dwLoc40;
	if (dwLoc40 == ~0x00)
		eax_66.u0 = 0x00;
	Eq_4 edx_78 = dwArg04->dw001C - dwArg04->dw0014;
	if (edx_78 > 0x00)
	{
		Eq_363 ebx_24_8_285 = SLICE(runtime.funcdata(gs, edx_28, 0x01), word24, 8);
		if (ecx_21 != 0x00)
		{
			Eq_4 ecx_104 = *ecx_21;
			if (ecx_104 > 0x00)
			{
				if (eax_66 < 0x00 || eax_66 >= ecx_104)
				{
					runtime.funcname(gs, edx_28, ebx_29);
					Eq_4 eax_257 = *ecx_21;
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_285, gs, SEQ(eax_66 >> 0x1F, eax_66));
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_285, gs, SEQ(eax_257 >> 0x1F, eax_257));
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_285, gs, (uint64) (uint32) ecx_21);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				runtime.stackmapdata(gs, ecx_21, eax_66);
				runtime.adjustpointers(gs, dwArg04->dw001C - 0x04, fp - 0x10, dwArg08, edx_28, ebx_29);
				dwLoc48_784 = edx_28;
				goto l0807E7A0;
			}
		}
		runtime.funcname(gs, edx_28, ebx_29);
		word32 edx_126 = dwArg04->dw001C;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		Eq_4 esi_180;
		runtime.printhex(esi_31, gs, edx_126 - edx_78, 0x00, out esi_180);
		runtime.printstring(gs);
		word32 esi_1022;
		runtime.printhex(esi_180, gs, edx_78, 0x00, out esi_1022);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
l0807E7A0:
		if (dwArg04->dw0024 <= 0x00)
			return;
		if (dwArg04->dw0028 == 0x00)
		{
			Eq_363 ebx_24_8_625 = SLICE(runtime.funcdata(gs, edx_28, 0x00), word24, 8);
			if (dwLoc48_784 != 0x00)
			{
				Eq_4 ecx_455 = *dwLoc48_784;
				if (ecx_455 > 0x00)
				{
					if (eax_66 < 0x00 || eax_66 >= ecx_455)
					{
						runtime.funcname(gs, edx_28, ebx_29);
						Eq_4 eax_597 = *dwLoc48_784;
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_625, gs, SEQ(eax_66 >> 0x1F, eax_66));
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_625, gs, SEQ(eax_597 >> 0x1F, eax_597));
						runtime.printstring(gs);
						runtime.printstring(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_625, gs, (uint64) (uint32) ecx_21);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
					runtime.stackmapdata(gs, dwLoc48_784, eax_66);
					goto l0807E7CB;
				}
			}
			runtime.funcname(gs, edx_28, ebx_29);
			up32 ebx_477 = dwArg04->dw0020;
			up32 edx_479 = dwArg04->dw0024;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			Eq_363 ebx_24_8_521 = SLICE(ebx_477, word24, 8);
			runtime.printint(ebx_24_8_521, gs, (uint64) (uint32) ebx_477);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_521, gs, (uint64) (uint32) edx_479);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
l0807E7CB:
			runtime.adjustpointers(gs, dwArg04->dw0020, fp - 0x08, dwArg08, 0x00, 0x00);
		}
	}
}

// 0807ED40: void runtime.adjustctxt(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_69061) dwArg08)
// Called from:
//      runtime.copystack
void runtime.adjustctxt(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_69061 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) dwArg04 + 40);
	if (dwArg08->t0000 <= ecx_20 && ecx_20 < dwArg08->t0004)
		*((word32) dwArg04 + 40) = (word32) ecx_20 + dwArg08->dw0008;
	if ((byte) (word32) g_b815756C == 0x00)
		return;
	Eq_4 ecx_42 = *((word32) dwArg04 + 52);
	if (dwArg08->t0000 <= ecx_42 && ecx_42 < dwArg08->t0004)
		*((word32) dwArg04 + 52) = (word32) ecx_42 + dwArg08->dw0008;
}

// 0807EDB0: void runtime.adjustdefers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_69120) dwArg08)
// Called from:
//      runtime.copystack
void runtime.adjustdefers(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_69120 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	runtime.tracebackdefers(gs, stackArg0, dwArg04, 0x080E7B7C);
	Eq_4 eax_29 = *((word32) dwArg04 + 20);
	while (eax_29 != 0x00)
	{
		Eq_4 edx_42 = *((word32) eax_29 + 16);
		if (dwArg08->t0000 <= edx_42 && edx_42 < dwArg08->t0004)
			*((word32) eax_29 + 16) = (word32) edx_42 + dwArg08->dw0008;
		Eq_4 edx_59 = *((word32) eax_29 + 8);
		if (dwArg08->t0000 <= edx_59 && edx_59 < dwArg08->t0004)
			*((word32) eax_29 + 8) = (word32) edx_59 + dwArg08->dw0008;
		Eq_4 edx_76 = *((word32) eax_29 + 20);
		if (dwArg08->t0000 <= edx_76 && edx_76 < dwArg08->t0004)
			*((word32) eax_29 + 20) = (word32) edx_76 + dwArg08->dw0008;
		eax_29 = *((word32) eax_29 + 24);
	}
}

// 0807EE70: void runtime.adjustsudogs(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_69205) dwArg08)
// Called from:
//      runtime.syncadjustsudogs
//      runtime.copystack
void runtime.adjustsudogs(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_69205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = *((word32) dwArg04 + 0x00B4);
	while (eax_17 != 0x00)
	{
		Eq_4 edx_27 = *((word32) eax_17 + 16);
		if (dwArg08->t0000 <= edx_27 && edx_27 < dwArg08->t0004)
			*((word32) eax_17 + 16) = (word32) edx_27 + dwArg08->dw0008;
		Eq_4 edx_44 = *((word32) eax_17 + 4);
		if (dwArg08->t0000 <= edx_44 && edx_44 < dwArg08->t0004)
			*((word32) eax_17 + 4) = (word32) edx_44 + dwArg08->dw0008;
		eax_17 = *((word32) eax_17 + 44);
	}
}

// 0807EEE0: void runtime.findsghi(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.copystack
void runtime.findsghi(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = *((word32) dwArg04 + 0x00B4);
	Eq_4 ebx_20 = 0x00;
	while (eax_17 != 0x00)
	{
		Eq_4 ebp_34 = (word32) *((word32) eax_17 + 16) + (word32) (*((word32) (*((word32) eax_17 + 52)) + 0x0C));
		if (dwArg08 > ebp_34 || (ebp_34 >= dwArg0C || ebp_34 <= ebx_20))
			ebp_34 = ebx_20;
		Eq_4 ebx_49 = *((word32) eax_17 + 4);
		ebx_20 = (word32) ebx_49 + 4;
		if (dwArg08 > (word32) ebx_49 + 4 || ((word32) ebx_49 + 4 >= dwArg0C || (word32) ebx_49 + 4 <= ebp_34))
			ebx_20 = ebp_34;
		eax_17 = *((word32) eax_17 + 44);
	}
}

// 0807EF50: void runtime.syncadjustsudogs(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_69205) dwArg0C)
// Called from:
//      runtime.copystack
void runtime.syncadjustsudogs(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_69205 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_129 = dwArg04;
	Eq_4 ecx_135 = *((word32) dwArg04 + 0x00B4);
	if (ecx_135 == 0x00)
		return;
	Eq_4 edx_116 = 0x00;
	while (ecx_135 != 0x00)
	{
		Eq_4 ebx_115 = *((word32) ecx_135 + 52);
		if (edx_116 != ebx_115)
		{
			word32 esi_240;
			word32 ebp_239;
			word32 edi_241;
			runtime.lock(esi, gs, (word32) ebx_115 + 48, out ebp_239, out esi_240, out edi_241);
			eax_129 = dwArg04;
		}
		edx_116 = *((word32) ecx_135 + 52);
		ecx_135 = *((word32) ecx_135 + 44);
	}
	runtime.adjustsudogs(gs, eax_129, dwArg0C);
	word32 ecx_43 = dwArg0C->dw00CC;
	if (ecx_43 != 0x00)
	{
		Eq_4 edx_49 = dwArg0C->t0004 - dwArg08;
		word32 edi_60;
		word32 esi_61;
		word32 ebp_64;
		runtime.memmove((word32) edx_49 + dwArg0C->dw0008, edx_49, ecx_43 - edx_49, out ebp_64, out esi_61, out edi_60);
	}
	Eq_4 ecx_113 = *((word32) dwArg04 + 0x00B4);
	Eq_4 edx_112 = 0x00;
	while (ecx_113 != 0x00)
	{
		Eq_4 ebx_92 = *((word32) ecx_113 + 52);
		if (edx_112 != ebx_92)
		{
			word32 ebx_243;
			word32 edx_242;
			runtime.unlock(gs, (word32) ebx_92 + 48, out edx_242, out ebx_243);
		}
		edx_112 = *((word32) ecx_113 + 52);
		ecx_113 = *((word32) ecx_113 + 44);
	}
}

// 0807F060: void runtime.copystack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 bArg08)
// Called from:
//      runtime.newstack
//      runtime.shrinkstack
void runtime.copystack(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 bArg08)
{
	byte bArg08_250 = (byte) dwArg08;
	while (fp - 0x94 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 56) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_30 = *((word32) dwArg04 + 4);
		Eq_4 edx_31 = *dwArg04;
		if (edx_31 == 0x00)
			runtime.throw(gs);
		else
		{
			Eq_4 eax_102;
			runtime.stackalloc(gs, dwArg08);
			fn0808FD5C(0x00, fp - 0xD0);
			up32 edx_67 = dwLoc010C - edx_31;
			Eq_4 ecx_71 = edx_31 - dwLocD8;
			if ((byte) (word32) bArg08_250 != 0x00)
			{
				runtime.adjustsudogs(gs, dwArg00, fp - 212);
				eax_102 = ecx_71;
			}
			else
			{
				runtime.findsghi(gs, dwArg00, dwLocEC, edx_31);
				runtime.syncadjustsudogs(gs, dwArg00, ecx_71, fp - 212);
				dwLoc08 = dwLoc010C;
				eax_102 = ecx_71 - dwLoc010C;
			}
			word32 esi_336;
			word32 ebp_335;
			word32 edi_337;
			runtime.memmove(dwLoc0110 - eax_102, edx_31 - eax_102, eax_102, out ebp_335, out esi_336, out edi_337);
			runtime.adjustctxt(gs, dwArg00, fp - 212);
			runtime.adjustdefers(gs, dwArg00, fp - 212);
			Eq_4 ecx_155 = *((word32) dwArg00 + 16);
			if (dwLocEC <= ecx_155 && ecx_155 < edx_31)
				*((word32) dwArg00 + 16) = (word32) ecx_155 + edx_67;
			*dwArg00 = ecx_30;
			*((word32) dwArg00 + 4) = dwLoc0110;
			*((word32) dwArg00 + 8) = (word32) ecx_30 + 880;
			*((word32) dwArg00 + 28) = dwLoc0110 - ecx_71;
			*((word32) dwArg00 + 64) = (word32) *((word32) dwArg00 + 64) + edx_67;
			runtime.gentraceback(gs, ~0x00, 0x00, dwArg00, 0x00, 0x00, 0x7FFFFFFF, 0x080E7B7C, fp - 212);
			runtime.stackfree(gs, dwLocEC, edx_31);
		}
	}
}

// 0807F2E0: void runtime.round2(Register (ptr32 Eq_2) gs, Stack int32 dwArg04)
// Called from:
//      runtime.malg
//      runtime.check
void runtime.round2(struct Eq_2 * gs, int32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 ecx_50 = 0x00;
	while ((0x01 << (byte) ecx_50 & 0x00 - (ecx_50 < 0x20)) < dwArg04)
		++ecx_50;
}

// 0807F320: void runtime.newstack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.morestack
void runtime.newstack(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp - 0x34 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = *((word32) eax_19 + 24);
	Eq_4 edx_21 = *((word32) ecx_20 + 0x0C);
	if (*((word32) edx_21 + 8) == ~0x04D1)
		runtime.throw(gs);
	else
	{
		Eq_4 ebp_36 = *((word32) ecx_20 + 84);
		if (edx_21 != ebp_36)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			word32 esi_1432;
			runtime.printhex(esi, gs, edx_21, 0x00, out esi_1432);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			fn0809025A((word32) *((word32) eax_19 + 24) + 4, fp - 0x54);
			runtime.traceback(gs);
			runtime.throw(gs);
		}
		else
		{
			if (g_t81576F0 == 0x00)
				*((word32) ebp_36 + 40) = dwArg04;
			else
			{
				runtime.writebarrierptr((word32) ebp_36 + 40, dwArg04);
				dwLocB0 = dwArg04;
			}
			Eq_4 ecx_183 = *((word32) eax_19 + 24);
			if ((byte) (word32) *((word32) *((word32) ecx_183 + 84) + 113) != 0x00)
			{
				fn0809025A((word32) ecx_183 + 4, fp - 0x38);
				*((word32) ebp_36 + 56) = dwLoc38;
				*((word32) ebp_36 + 60) = dwLoc34;
				Eq_4 eax_205 = *ebp_36;
				Eq_4 ecx_207 = *((word32) ebp_36 + 4);
				Eq_4 ebx_215 = *((word32) ebp_36 + 32);
				Eq_4 ebx_217 = *((word32) ebp_36 + 28);
				Eq_4 edx_219 = *((word32) ebp_36 + 48);
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_1433;
				runtime.printhex(esi, gs, ebx_217, 0x00, out esi_1433);
				runtime.printstring(gs);
				word32 esi_1434;
				runtime.printhex(esi, gs, eax_205, 0x00, out esi_1434);
				runtime.printstring(gs);
				word32 esi_1435;
				runtime.printhex(esi, gs, ecx_207, 0x00, out esi_1435);
				runtime.printstring(gs);
				runtime.printstring(gs);
				word32 esi_1436;
				runtime.printhex(esi, gs, dwLoc34, 0x00, out esi_1436);
				runtime.printstring(gs);
				word32 esi_1437;
				runtime.printhex(esi, gs, dwLoc38, 0x00, out esi_1437);
				runtime.printstring(gs);
				word32 esi_1438;
				runtime.printhex(esi, gs, dwLoc24, 0x00, out esi_1438);
				runtime.printstring(gs);
				runtime.printstring(gs);
				word32 esi_1439;
				runtime.printhex(esi, gs, ebx_215, 0x00, out esi_1439);
				runtime.printstring(gs);
				word32 esi_1440;
				runtime.printhex(esi, gs, ebx_217, 0x00, out esi_1440);
				runtime.printstring(gs);
				word32 esi_1441;
				runtime.printhex(esi, gs, edx_219, 0x00, out esi_1441);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.traceback(gs);
				runtime.throw(gs);
			}
			else
			{
				fn0809025A((word32) ecx_183 + 4, fp - 0x1C);
				((word32) *((word32) eax_19 + 24) + 8)->u0 = 0x00;
				((word32) *((word32) eax_19 + 24) + 24)->u0 = 0x00;
				((word32) *((word32) eax_19 + 24) + 4)->u0 = 0x00;
				((word32) *((word32) eax_19 + 24) + 0x0C)->u0 = 0x00;
				runtime/internal/atomic.Loaduintptr();
				if (dwLocB0 == ~0x0521)
				{
					Eq_4 edx_436 = *((word32) eax_19 + 24);
					if (*((word32) edx_436 + 0x0078) != 0x00 || (*((word32) edx_436 + 0x0068) != 0x00 || (*((word32) edx_436 + 116) != 0x00 || *((word32) (*((word32) edx_436 + 92)) + 8) != 0x01)))
					{
						*((word32) ebp_36 + 8) = (word32) *ebp_36 + 880;
						runtime.gogo(gs, (word32) ebp_36 + 28);
					}
				}
				Eq_4 ecx_470 = *ebp_36;
				if (ecx_470 == 0x00)
					runtime.throw(gs);
				else
				{
					Eq_4 edx_482 = *((word32) ebp_36 + 28);
					if (edx_482 - 0x04 < ecx_470)
					{
						Eq_4 ecx_489 = *((word32) ebp_36 + 4);
						Eq_4 esi_497 = *((word32) ebp_36 + 32);
						Eq_4 edi_499 = *((word32) ebp_36 + 48);
						runtime.printlock(gs);
						runtime.printstring(gs);
						word32 esi_1442;
						runtime.printhex(esi, gs, edx_482 - 0x04, 0x00, out esi_1442);
						runtime.printstring(gs);
						word32 esi_1443;
						runtime.printhex(esi, gs, ecx_470, 0x00, out esi_1443);
						runtime.printstring(gs);
						word32 esi_1444;
						runtime.printhex(esi, gs, ecx_489, 0x00, out esi_1444);
						runtime.printstring(gs);
						runtime.printstring(gs);
						word32 esi_1445;
						runtime.printhex(esi, gs, dwLoc18, 0x00, out esi_1445);
						runtime.printstring(gs);
						word32 esi_1446;
						runtime.printhex(esi, gs, dwLoc1C, 0x00, out esi_1446);
						runtime.printstring(gs);
						word32 esi_1447;
						runtime.printhex(esi, gs, dwLoc08, 0x00, out esi_1447);
						runtime.printstring(gs);
						runtime.printstring(gs);
						word32 esi_1448;
						runtime.printhex(esi, gs, esi_497, 0x00, out esi_1448);
						runtime.printstring(gs);
						word32 esi_1449;
						runtime.printhex(esi, gs, edx_482, 0x00, out esi_1449);
						runtime.printstring(gs);
						word32 esi_1450;
						runtime.printhex(esi, gs, edi_499, 0x00, out esi_1450);
						runtime.printstring(gs);
						runtime.printpointer(gs);
						runtime.printstring(gs);
						runtime.printunlock(gs);
					}
					if (edx_482 - 0x04 < *ebp_36)
					{
						runtime.readgstatus(ebp_36);
						Eq_4 esp_682 = <invalid>;
						*((word32) esp_682 + 28) = *((word32) esp_682 + 4);
						runtime.printlock(gs);
						esp_682->u0 = 0x080E1DFB;
						((word32) esp_682 + 4)->u0 = 0x0C;
						runtime.printstring(gs);
						*esp_682 = *((word32) esp_682 + 92);
						runtime.printpointer(gs);
						esp_682->u0 = 0x080E1E94;
						((word32) esp_682 + 4)->u0 = 0x0D;
						runtime.printstring(gs);
						*esp_682 = *((word32) esp_682 + 28);
						((word32) esp_682 + 4)->u0 = 0x00;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						word32 esi_1452;
						runtime.printhex(esi, gs, stackArg4, dwArg04, out esi_1452);
						esp_682->u0 = 0x080E0E0D;
						((word32) esp_682 + 4)->u0 = 0x02;
						runtime.printstring(gs);
						runtime.printunlock(gs);
						*((word32) esp_682 + 64) = **((word32) esp_682 + 92);
						runtime.printlock(gs);
						esp_682->u0 = 135156324;
						((word32) esp_682 + 4)->u0 = 0x1F;
						runtime.printstring(gs);
						*esp_682 = *((word32) esp_682 + 16);
						((word32) esp_682 + 4)->u0 = 0x00;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						word32 esi_1454;
						runtime.printhex(esi, gs, stackArg4, dwArg04, out esi_1454);
						esp_682->u0 = 0x080E0E2B;
						((word32) esp_682 + 4)->u0 = 0x03;
						runtime.printstring(gs);
						*esp_682 = *((word32) esp_682 + 64);
						((word32) esp_682 + 4)->u0 = 0x00;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						word32 esi_1456;
						runtime.printhex(esi, gs, stackArg4, dwArg04, out esi_1456);
						esp_682->u0 = 0x080E0D9C;
						((word32) esp_682 + 4)->u0 = 0x01;
						runtime.printstring(gs);
						runtime.printunlock(gs);
						esp_682->u0 = 0x080E4C60;
						((word32) esp_682 + 4)->u0 = 0x1D;
						runtime.throw(gs);
					}
					else
					{
						if (dwLocB0 == ~0x0521)
						{
							Eq_4 ecx_789 = *((word32) eax_19 + 24);
							if (ebp_36 == *ecx_789)
								runtime.throw(gs);
							if (*((word32) ecx_789 + 92) == 0x00 && *((word32) ecx_789 + 0x0078) == 0x00)
								runtime.throw(gs);
							runtime.casgstatus(ebp_36, 0x02, 0x04);
							if ((byte) (word32) *((word32) ebp_36 + 110) != 0x00)
							{
								do
									runtime.castogscanstatus(gs, ebp_36, 0x04, 0x1004);
								while ((byte) (word32) bLocA8 == 0x00);
								if ((byte) (word32) *((word32) ebp_36 + 111) == 0x00)
								{
									Eq_4 edx_854 = *((word32) *((word32) ebp_36 + 24) + 92);
									runtime.scanstack(gs, ebp_36, (word32) edx_854 + 0x0950);
									if ((byte) (word32) g_b815756D != 0x00)
									{
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_4 stackArg0 = <invalid>;
										runtime.(*gcWork).dispose(ebx, ebp, gs, stackArg0, (word32) edx_854 + 0x0950);
									}
									*((word32) ebp_36 + 111) = 0x01;
								}
								*((word32) ebp_36 + 110) = 0x00;
								((word32) ebp_36 + 0x006C)->u0 = 0x00;
								runtime.casfrom_Gscanstatus(gs, ebp_36, 0x1004, 0x04);
								runtime.casgstatus(ebp_36, 0x04, 0x02);
								*((word32) ebp_36 + 8) = (word32) *ebp_36 + 880;
								runtime.gogo(gs, (word32) ebp_36 + 28);
							}
							runtime.casgstatus(ebp_36, 0x04, 0x02);
							runtime.gopreempt_m(gs);
						}
						ui32 ecx_936 = *((word32) ebp_36 + 4) - *ebp_36;
						if (ecx_936 << 0x01 > g_t8136014)
						{
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printint(ebx, gs, g_t8136014);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							runtime.throw(gs);
						}
						else
						{
							runtime.casgstatus(ebp_36, 0x02, 0x08);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_4 stackArg0 = <invalid>;
							runtime.copystack(gs, stackArg0, ebp_36, ecx_936 << 0x01);
							runtime.casgstatus(ebp_36, 0x08, 0x02);
							runtime.gogo(gs, (word32) ebp_36 + 28);
						}
					}
				}
			}
		}
	}
}

// 0807FE60: void runtime.shrinkstack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.markrootFreeGStacks
//      runtime.scanstack
void runtime.shrinkstack(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg04);
	if ((dwLoc08 & ~0x1000) != 0x06)
	{
		Eq_4 edx_32 = *dwArg04;
		if (edx_32 == 0x00)
			runtime.throw(gs);
		else if ((dwLoc08 & 0x1000) == 0x00)
			runtime.throw(gs);
		else
		{
			if (g_dw8157734 > 0x00)
				return;
			if (*((word32) dwArg04 + 0x00AC) == g_t81575D8)
				return;
			Eq_4 ecx_64 = *((word32) dwArg04 + 4);
			uint32 ecx_66 = ecx_64 - edx_32;
			if (ecx_66 >> 0x01 < 0x0800)
				return;
			if (ecx_64 - *((word32) dwArg04 + 28) + 0x02F0 >= ecx_66 >> 0x02)
				return;
			if (*((word32) dwArg04 + 56) != 0x00)
				return;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.copystack(gs, stackArg0, dwArg04, dwArg04);
		}
	}
	else
	{
		Eq_4 ecx_97 = *dwArg04;
		if (ecx_97 != 0x00)
		{
			runtime.stackfree(gs, ecx_97, dwArg04);
			dwArg04->u0 = 0x00;
			((word32) dwArg04 + 4)->u0 = 0x00;
		}
	}
}

// 0807FF90: void runtime.freeStackSpans(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.freeStackSpans(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_237;
	word32 edi_238;
	Eq_4 esi_149;
	runtime.lock(esi, gs, 0x08157644, out ebp_237, out esi_149, out edi_238);
	Eq_70426 eax_145 = 0x00;
	while (eax_145 < 0x04)
	{
		if (eax_145 >= 0x04)
			runtime.panicindex(gs);
		Eq_4 edx_136 = eax_145 * 0x08 + 0x08145280;
		Eq_4 ebx_139 = g_a8145280[eax_145];
		eax_144 = eax_145;
		edx_157 = edx_136;
		while (true)
		{
			Eq_4 edx_157;
			Eq_70426 eax_144;
			if (ebx_139 == 0x00)
				break;
			esi_149 = (word32) *((word32) ebx_139 + 56);
			Eq_4 ebp_148 = *ebx_139;
			if ((word16) esi_149 == 0x00)
			{
				runtime.(*mSpanList).remove(gs, edx_157, ebx_139);
				((word32) ebx_139 + 20)->u0 = 0x00;
				runtime.(*mheap).freeManual(gs, ebx_139, &g_t81581E0);
				eax_144 = eax_145;
				edx_157 = edx_136;
			}
			ebx_139 = ebp_148;
		}
		eax_145 = (word32) eax_144 + 1;
	}
	word32 ebx_240;
	word32 edx_239;
	runtime.unlock(gs, 0x08157644, out edx_239, out ebx_240);
	word32 esi_242;
	word32 ebp_241;
	word32 edi_243;
	runtime.lock(esi_149, gs, 0x08145340, out ebp_241, out esi_242, out edi_243);
	Eq_70446 eax_131 = 0x00;
	while (eax_131 < 0x13)
	{
		if (eax_131 >= 0x13)
			runtime.panicindex(gs);
		Eq_4 ecx_90 = eax_131 * 0x08 + 0x08145344;
		Eq_4 edx_129 = *ecx_90;
		while (edx_129 != 0x00)
		{
			Eq_4 eax_99 = *edx_129;
			runtime.(*mSpanList).remove(gs, ecx_90, edx_129);
			runtime.(*mheap).freeManual(gs, edx_129, &g_t81581E0);
			edx_129 = eax_99;
		}
		eax_131 = (word32) eax_131 + 1;
	}
	word32 edx_244;
	word32 ebx_245;
	runtime.unlock(gs, 0x08145340, out edx_244, out ebx_245);
}

// 080800F0: void runtime.morestackc()
// Called from:
//      runtime.cgoCheckUsingType
//      runtime.persistentalloc1
//      runtime.gcmarkwb_m
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.gcDrainN
//      runtime.(*mheap).allocManual
//      runtime.(*mheap).freeManual
//      runtime.forEachP
//      runtime.stackcacherefill
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackalloc
//      runtime.stackfree
void runtime.morestackc()
{
	word32 ebp_18;
	word32 edi_19;
	runtime.systemstack(gs, 0x080E7C78, out ebp_18, out edi_19);
}

// 08080110: Register Eq_4 runtime.concatstrings(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04, Stack (ptr32 Eq_5156) dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*TypeAssertionError).Error
//      runtime.panicwrap
//      runtime.concatstring2
//      runtime.concatstring3
//      runtime.concatstring4
//      runtime.concatstring5
Eq_4 runtime.concatstrings(struct Eq_2 * gs, ptr32 dwArg04, struct Eq_5156 * dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_70542 * eax_20 = &dwArg08->dw0004;
	Eq_4 ebx_106 = 0x00;
	word32 ebp_224 = 0x00;
	Eq_4 esi_226 = 0x00;
	Eq_4 edi_103 = 0x00;
	while (ebx_106 < dwArg0C)
	{
		word32 edx_208 = eax_20->dw0000;
		if (edx_208 != 0x00)
		{
			Eq_4 edx_212 = (word32) edi_103 + edx_208;
			if (edx_212 < edi_103)
				runtime.throw(gs);
			++ebp_224;
			esi_226 = ebx_106;
			edi_103 = edx_212;
		}
		++eax_20;
		ebx_106 = (word32) ebx_106 + 1;
	}
	if (ebp_224 == 0x00)
		return ebx_106;
	if (ebp_224 != 0x01)
	{
l080801CC:
		runtime.rawstringtmp(ebx_106, gs, dwArg04, edi_103);
		Eq_4 eax_120 = dwLoc30;
		Eq_4 ecx_121 = dwLoc34;
		word32 ebp_126 = dwLoc2C;
		Eq_4 esi_127 = 0x00;
		struct Eq_5156 * edi_130 = dwArg08;
		while (esi_127 < dwArg0C)
		{
			Eq_4 edx_154;
			Eq_4 edx_149 = edi_130->dw0004;
			Eq_4 ebx_151 = edi_130->a0000[0];
			edx_154 = edx_149;
			if (eax_120 <= edx_149)
				edx_154 = eax_120;
			word32 ebp_372;
			word32 edi_374;
			word32 esi_373;
			runtime.memmove(ecx_121, ebx_151, edx_154, out ebp_372, out esi_373, out edi_374);
			if (edx_149 > eax_120)
				runtime.panicslice(gs);
			word32 ebp_185 = ebp_126 - edx_149;
			++edi_130;
			esi_127 = (word32) esi_127 + 1;
			ebp_126 = ebp_185;
			ecx_121 = (word32) ecx_121 + (edx_149 & -ebp_185 >> 0x1F);
			eax_120 -= edx_149;
		}
		return dwLoc3C;
	}
	else
	{
		if (dwArg04 == 0x00)
		{
			if (esi_226 >= dwArg0C)
				runtime.panicindex(gs);
			uip32 edx_369;
			Eq_4 ebp_62 = gs->ptr0000->tFFFFFFFC;
			Eq_4 ebx_57 = dwArg08[esi_226];
			Eq_4 edx_63 = *((word32) ebp_62 + 4);
			ebx_106 = ebx_57;
			word24 edx_24_8_343 = SLICE(edx_63, word24, 8);
			if (*ebp_62 <= ebx_57)
				edx_369 = SEQ(edx_24_8_343, ebx_57 < edx_63);
			else
				edx_369 = 0x00;
			if ((byte) edx_369 != 0x00)
				goto l080801CC;
		}
		if (esi_226 < dwArg0C)
			return ebx_106;
		runtime.panicindex(gs);
	}
}

// 08080310: void runtime.concatstring2(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.errorString.Error
//      runtime.panicwrap
//      runtime.(*errorString).Error
//      syscall.itoa
//      syscall.Errno.Error
//      time.init
//      reflect.newName
//      reflect.Kind.String
//      reflect.ChanDir.String
//      reflect.(*rtype).ptrTo
//      reflect.funcLayout
//      reflect.(*sliceType).Bits
void runtime.concatstring2(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.concatstrings(gs, dwArg04, (word32) fp + 8, 0x02);
}

// 08080370: Register word32 runtime.concatstring3(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.SetFinalizer
//      reflect.funcLayout
//      reflect.(*ValueError).Error
//      reflect.flag.mustBeAssignable
//      reflect.methodReceiver
//      reflect.Value.String
//      fmt.(*fmt).fmt_q
word32 runtime.concatstring3(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.concatstrings(gs, dwArg04, (word32) fp + 8, 0x03);
}

// 080803D0: void runtime.concatstring4(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.(*TypeAssertionError).Error
//      runtime.SetFinalizer
void runtime.concatstring4(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.concatstrings(gs, dwArg04, (word32) fp + 8, 0x04);
}

// 08080430: void runtime.concatstring5(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.SetFinalizer
//      os.(*PathError).Error
//      reflect.funcLayout
//      reflect.(*ValueError).Error
//      reflect.Value.assignTo
void runtime.concatstring5(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.concatstrings(gs, dwArg04, (word32) fp + 8, 0x05);
}

// 08080490: Register word32 runtime.slicebytetostring(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.gcMarkTermination
//      strconv.(*decimal).String
//      strconv.formatBits
//      syscall.uitoa
//      os.Readlink
//      reflect.funcStr
//      reflect.cvtBytesString
//      fmt.(*pp).fmtBytes
word32 runtime.slicebytetostring(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
		return esi;
	Eq_4 ecx_27 = dwArg04;
	if (dwArg04 == 0x00 || dwArg0C > 0x20)
	{
		word32 ebx_132;
		word32 esi_133;
		word32 edi_134;
		runtime.mallocgc(ebx, gs, dwArg0C, 0x00, 0x00, out ebx_132, out esi_133, out edi_134);
		ecx_27 = dwLoc04;
	}
	word32 esi_56;
	word32 edi_136;
	word32 ebp_135;
	runtime.memmove(ecx_27, dwArg08, dwArg0C, out ebp_135, out esi_56, out edi_136);
	return esi_56;
}

// 08080530: void runtime.rawstringtmp(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.concatstrings
//      runtime.slicerunetostring
void runtime.rawstringtmp(Eq_4 ebx, struct Eq_2 * gs, ptr32 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00 || dwArg08 > 0x20)
		runtime.rawstring(ebx, gs, dwArg08);
	else
	{
		if (dwArg08 <= 0x20)
			return;
		runtime.panicslice(gs);
	}
}

// 080805B0: void runtime.stringtoslicebyte(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_4) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtStringBytes
void runtime.stringtoslicebyte(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg00, union Eq_4 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_43;
	Eq_4 ecx_42;
	if (dwArg04 != null && dwArg0C <= 0x20)
	{
		fn0808FD88(0x00, dwArg04);
		ecx_42 = dwArg08;
		edx_43 = dwArg00;
	}
	else
	{
		runtime.rawbyteslice(ebx, gs, dwArg0C);
		ecx_42 = dwLoc14;
		edx_43 = dwLoc18;
	}
	Eq_4 ebx_58 = dwArg0C;
	if (ecx_42 <= dwArg0C)
		ebx_58 = ecx_42;
	word32 edi_136;
	word32 esi_135;
	word32 ebp_134;
	runtime.memmove(edx_43, dwArg08, ebx_58, out ebp_134, out esi_135, out edi_136);
}

// 08080660: void runtime.stringtoslicerune(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_40254) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtStringRunes
void runtime.stringtoslicerune(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_40254 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_157 = 0x00;
	Eq_70860 ecx_154 = 0x00;
	while (eax_157 < dwArg0C)
	{
		Eq_4 ebp_148;
		if ((word32) Mem23[dwArg08 + eax_157:byte] < 0x80)
			ebp_148 = (word32) eax_157 + 1;
		else
		{
			runtime.decoderune(gs, dwArg08, dwArg0C, eax_157);
			dwLoc20 = dwArg0C;
			dwLoc1C = eax_157;
			ebp_148 = dwLoc14;
		}
		ebx = dwArg08;
		ecx_154 = (word32) ecx_154 + 1;
		eax_157 = ebp_148;
	}
	Eq_4 ebx_53;
	Eq_4 eax_54;
	if (dwArg04 != null && ecx_154 <= 0x20)
	{
		fn0808FD70(0x00, dwArg04);
		if (ecx_154 > 0x20)
			runtime.panicslice(gs);
		eax_54 = dwLoc10;
		ebx_53 = dwArg00;
	}
	else
	{
		runtime.rawruneslice(ebx, gs, ecx_154);
		ebx_53 = dwLoc20;
		eax_54 = dwLoc1C;
	}
	Eq_4 edx_112 = dwArg0C;
	Eq_4 ebp_110 = 0x00;
	Eq_4 esi_125 = 0x00;
	ebx_113 = ebx_53;
	eax_111 = eax_54;
	while (true)
	{
		Eq_4 eax_111;
		Eq_4 ebx_113;
		if (ebp_110 >= edx_112)
			break;
		word32 ecx_109 = (word32) Mem87[dwArg08 + ebp_110:byte];
		if (ecx_109 < 0x80)
			ebp_110 = (word32) ebp_110 + 1;
		else
		{
			runtime.decoderune(gs, dwArg08, edx_112, ebp_110);
			ecx_109 = dwLoc18;
			ebp_110 = dwLoc14;
			eax_111 = eax_54;
			edx_112 = dwArg0C;
			ebx_113 = ebx_53;
		}
		if (esi_125 >= eax_111)
			runtime.panicindex(gs);
		*((word32) ebx_113 + esi_125 * 0x04) = ecx_109;
		esi_125 = (word32) esi_125 + 1;
	}
}

// 080807B0: void runtime.slicerunetostring(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04, Stack (ptr32 word32) dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtRunesString
void runtime.slicerunetostring(struct Eq_2 * gs, ptr32 dwArg04, word32 * dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = 0x00;
	word32 * ecx_21 = dwArg08;
	Eq_4 edx_22 = 0x00;
	while (eax_18 < dwArg0C)
	{
		Eq_4 eax_33 = *ecx_21;
		runtime.encoderune(gs, fp - 0x1C, 0x04, eax_33);
		dwLoc38 = eax_33;
		++ecx_21;
		eax_18 = (word32) eax_18 + 1;
		edx_22 = (word32) edx_22 + dwLoc34;
	}
	runtime.rawstringtmp(dwArg0C, gs, dwArg04, (word32) edx_22 + 3);
	Eq_4 esi_143 = 0x00;
	Eq_4 dwLoc28_191 = 0x00;
	word32 * edi_141 = dwArg08;
	while (esi_143 < dwArg0C)
	{
		Eq_4 ebx_97 = *edi_141;
		if (dwLoc28_191 >= edx_22)
			break;
		if (dwLoc28_191 > dwLoc30)
			runtime.panicslice(gs);
		runtime.encoderune(gs, (dwLoc28_191 - dwLoc2C >> 0x1F & dwLoc28_191) + dwLoc34, dwLoc30 - dwLoc28_191, ebx_97);
		++edi_141;
		esi_143 = (word32) esi_143 + 1;
		dwLoc28_191 = (word32) dwLoc28_191 + dwLoc34;
	}
	if (dwLoc28_191 <= dwLoc38)
		return;
	runtime.panicslice(gs);
}

// 08080920: void runtime.intstring(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_70958) dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg0C)
// Called from:
//      reflect.cvtIntString
//      reflect.cvtUintString
void runtime.intstring(Eq_4 ebx, struct Eq_2 * gs, struct Eq_70958 * dwArg04, Eq_4 dwArg08, int32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 ecx_38;
	up32 ebx_36;
	struct Eq_70958 * eax_17 = dwArg04;
	if (dwArg04 != null)
	{
		ecx_38 = 0x04;
		ebx_36 = 0x04;
	}
	else
	{
		runtime.rawstring(ebx, gs, 0x04);
		ebx_36 = dwLoc18;
		eax_17 = dwLoc14;
		ecx_38 = dwLoc10;
	}
	Eq_4 ebp_55;
	if (dwArg08 >> 0x1F != dwArg0C)
		ebp_55.u0 = 0xFFFD;
	else
		ebp_55 = dwArg08;
	runtime.encoderune(gs, eax_17, ecx_38, ebp_55);
	if (dwLoc10 <= ebx_36)
		return;
	runtime.panicslice(gs);
}

// 080809E0: void runtime.rawstring(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.rawstringtmp
//      runtime.intstring
//      runtime.gostring
void runtime.rawstring(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebx_73;
	word32 esi_74;
	word32 edi_75;
	runtime.mallocgc(ebx, gs, dwArg04, 0x00, 0x00, out ebx_73, out esi_74, out edi_75);
}

// 08080A60: void runtime.rawbyteslice(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stringtoslicebyte
void runtime.rawbyteslice(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_27;
	if (dwArg04 >= 0x8000)
	{
		if ((word32) dwArg04 + 0x00002000 < dwArg04)
			ecx_27 = dwArg04;
		else
			ecx_27 = (word32) dwArg04 + 0x00001FFF & ~0x1FFF;
l08080ADA:
		word32 ebx_139;
		word32 esi_140;
		word32 edi_141;
		runtime.mallocgc(ebx, gs, ecx_27, 0x00, 0x00, out ebx_139, out esi_140, out edi_141);
		if (ecx_27 != dwArg04)
			runtime.memclrNoHeapPointers((word32) dwArg04 + dwLoc0C, ecx_27 - dwArg04);
	}
	else
	{
		if (dwArg04 <= 1016)
		{
			struct Eq_71097 * ecx_45 = (word32) dwArg04 + 7 >> 0x03;
			if (ecx_45 < (struct Eq_71097 *) 0x81)
			{
				uint32 ecx_49 = (word32) ecx_45->b8138640;
				if (ecx_49 < 0x43)
				{
					ecx_27 = (word32) g_a8138820[ecx_49 * 0x02];
					goto l08080ADA;
				}
			}
			runtime.panicindex(gs);
		}
		struct Eq_71090 * ecx_34 = dwArg04 - 0x0381 >> 0x07;
		if (ecx_34 < (struct Eq_71090 *) 0xF9)
		{
			uint32 ecx_38 = (word32) ecx_34->b81396E0;
			if (ecx_38 < 0x43)
			{
				ecx_27 = (word32) g_a8138820[ecx_38 * 0x02];
				goto l08080ADA;
			}
		}
		runtime.panicindex(gs);
	}
}

// 08080BA0: void runtime.rawruneslice(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_70860 dwArg04)
// Called from:
//      runtime.stringtoslicerune
void runtime.rawruneslice(Eq_4 ebx, struct Eq_2 * gs, Eq_70860 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 > 0x3FFFFFFF)
		runtime.throw(gs);
	Eq_4 edx_40;
	if (dwArg04 << 0x02 >= 0x8000)
	{
		if ((dwArg04 << 0x02) + 0x2000 < dwArg04 << 0x02)
			edx_40 = dwArg04 << 0x02;
		else
			edx_40 = (dwArg04 << 0x02) + 0x1FFF & ~0x1FFF;
l08080C2C:
		word32 ebx_159;
		word32 esi_160;
		word32 edi_161;
		runtime.mallocgc(ebx, gs, edx_40, 0x00, 0x00, out ebx_159, out esi_160, out edi_161);
		if (edx_40 != dwArg04 << 0x02)
			runtime.memclrNoHeapPointers(dwLoc10 + dwArg04 * 0x04, edx_40 - (dwArg04 << 0x02));
	}
	else
	{
		if (dwArg04 << 0x02 <= 1016)
		{
			uint32 edx_57 = (dwArg04 << 0x02) + 0x07;
			if (edx_57 >> 0x03 < 0x81)
			{
				uint32 edx_62 = (word32) (edx_57 >> 0x03)->b8138640;
				if (edx_62 < 0x43)
				{
					ebx.u0 = 0x08138820;
					edx_40 = (word32) g_a8138820[edx_62 * 0x02];
					goto l08080C2C;
				}
			}
			runtime.panicindex(gs);
		}
		uint32 edx_46 = (dwArg04 << 0x02) - 0x0381;
		if (edx_46 >> 0x07 < 0xF9)
		{
			uint32 edx_51 = (word32) (edx_46 >> 0x07)->b81396E0;
			if (edx_51 < 0x43)
			{
				ebx.u0 = 0x08138820;
				edx_40 = (word32) g_a8138820[edx_51 * 0x02];
				goto l08080C2C;
			}
		}
		runtime.panicindex(gs);
	}
}

// 08080D20: Register Eq_4 runtime.gostring(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.goenvs_unix
//      runtime.expandCgoFrames
Eq_4 runtime.gostring(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findnull(dwArg04);
	if (dwLoc20 == 0x00)
		return ebx;
	runtime.rawstring(ebx, gs, dwLoc20);
	if (dwLoc14 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		word32 edi_136;
		word32 ebp_134;
		word32 esi_135;
		return runtime.memmove(dwLoc18, dwArg04, dwLoc20, out ebp_134, out esi_135, out edi_136);
	}
}

// 08080DD0: void runtime.index(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.parsedebugvars
//      runtime.contains
void runtime.index(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_118 = dwArg10;
	if (dwArg10 == 0x00)
		return;
	Eq_4 ecx_105 = 0x00;
	while (ecx_105 < dwArg08)
	{
		if (ecx_105 >= dwArg08)
			runtime.panicindex(gs);
		if (SLICE((word32) Mem28[dwArg04 + ecx_105:byte], byte, 0) == SLICE((word32) Mem28[dwArg0C + 0x00:byte], byte, 0))
		{
			uip32 edx_207;
			Eq_4 edx_65 = dwArg08 - ecx_105;
			Eq_4 edx_70 = (word32) dwArg04 + (-edx_65 >> 0x1F & ecx_105);
			if (edx_65 < eax_118)
				edx_207 = 0x00;
			else
			{
				word32 edi_78;
				word32 esi_209;
				runtime.eqstring(edx_70, eax_118, dwArg0C, out esi_209, out edi_78);
				edx_207 = (word32) bLoc08;
				eax_118 = dwArg10;
			}
			if ((byte) edx_207 != 0x00)
				return;
		}
		ecx_105 = (word32) ecx_105 + 1;
	}
}

// 08080EB0: void runtime.contains(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.showframe
void runtime.contains(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.index(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
}

// 08080F10: Register Eq_62452 runtime.atoi(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_62452 esiOut)
// Called from:
//      runtime.parsedebugvars
//      runtime/debug.SetTraceback
//      runtime.atoi32
Eq_62452 runtime.atoi(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_62452 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
	{
		esiOut = esi;
		return ebp;
	}
	else
	{
		Eq_4 eax_138;
		byte cl_133;
		Eq_4 edx_132;
		if ((byte) (word32) *dwArg04 == 0x2D)
		{
			edx_132 = dwArg08 - 0x01;
			eax_138 = (word32) dwArg04 + (0x01 - dwArg08 >> 0x1F & 0x01);
			cl_133 = 0x01;
		}
		else
		{
			eax_138 = dwArg04;
			edx_132 = dwArg08;
			cl_133 = 0x00;
		}
		Eq_4 ebx_125 = 0x00;
		Eq_62452 ebp_127 = 0x00;
		while (ebx_125 < edx_132)
		{
			if (ebx_125 >= edx_132)
				runtime.panicindex(gs);
			word32 esi_94 = (word32) Mem0[eax_138 + ebx_125:byte];
			if ((byte) (esi_94 - 0x30) > 0x09)
			{
				esiOut = esi_94;
				return ebp_127;
			}
			if (ebp_127 > 0x19999999)
			{
				esiOut = esi_94;
				return ebp_127;
			}
			ui32 ebp_111 = ebp_127 * 0x05;
			esi = (word32) (byte) esi_94 - 0x30 + ebp_111 * 0x02;
			if (esi < ebp_111 << 0x01)
			{
				esiOut = esi;
				return ebp_111 << 0x01;
			}
			ebx_125 = (word32) ebx_125 + 1;
			ebp_127 = esi;
		}
		bool Z_51 = SLICE(cond(cl_133), bool, 2);
		if (cl_133 == 0x00)
		{
			if (ebp_127 > 0x7FFFFFFF)
			{
				esiOut = esi;
				return ebp_127;
			}
			Z_51 = SLICE(cond(cl_133), bool, 2);
		}
		if (!Z_51)
		{
			if (ebp_127 > 0x80000000)
			{
				esiOut = esi;
				return ebp_127;
			}
			Z_51 = SLICE(cond(cl_133), bool, 2);
		}
		if (!Z_51)
			ebp_127 = -ebp_127;
		esiOut = esi;
		return ebp_127;
	}
}

// 08081040: Register word32 runtime.atoi32(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 esiOut)
// Called from:
//      runtime.readgogc
//      runtime.schedinit
//      runtime.parsedebugvars
word32 runtime.atoi32(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_28;
	word32 ebp_25 = runtime.atoi(gs, dwArg04, dwArg08, out esi_28);
	esiOut = esi_28;
	return ebp_25;
}

// 08081090: void runtime.findnull(Stack Eq_4 dwArg04)
// Called from:
//      runtime.gostring
//      runtime.gostringnocopy
void runtime.findnull(Eq_4 dwArg04)
{
	if (dwArg04 == 0x00)
		return;
	Eq_71469 ecx_10 = 0x00;
	while (ecx_10 < 0x7FFFFFFE)
	{
		if (SLICE((word32) Mem0[dwArg04 + ecx_10:byte], byte, 0) == 0x00)
			return;
		ecx_10 = (word32) ecx_10 + 1;
	}
	runtime.panicindex(gs);
}

// 080810D0: void runtime.gostringnocopy()
// Called from:
//      runtime.goargs
//      runtime.funcname
//      runtime.funcnameFromNameoff
//      runtime.funcfile
//      runtime.funcline1
//      runtime.printOneCgoTraceback
void runtime.gostringnocopy()
{
	runtime.findnull(dwArg04);
}

// 08081100: Register word32 runtime.badsystemstack(Register (ptr32 Eq_2) gs, Register out (ptr32 Eq_71489) edxOut)
// Called from:
//      runtime.systemstack
word32 runtime.badsystemstack(struct Eq_2 * gs, struct Eq_71489 & edxOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 08081140: void reflect.memclrNoHeapPointers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.callMethod
void reflect.memclrNoHeapPointers(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memclrNoHeapPointers(dwArg04, dwArg08);
}

// 08081180: void runtime.CallersFrames(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.panicwrap
void runtime.CallersFrames(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_41;
	Eq_4 ebp_54;
	runtime.newobject(gs, 0x080D36E0);
	Eq_4 ecx_28 = dwArg08;
	if (dwArg08 >= 0x01 && *dwArg04 - g_dw8157640 < 0x0100)
	{
		ebp_54 = dwArg0C - 0x01;
		edx_41 = (word32) dwArg04 + (0x01 - dwArg0C >> 0x1F & 0x04);
		ecx_28 = dwArg08 - 0x01;
	}
	else
	{
		edx_41 = dwArg04;
		if (dwArg08 >= 0x02)
		{
			Eq_4 ebx_45 = *((word32) dwArg04 + 4) - g_dw8157640;
			if (ebx_45 < 0x0100)
				*((word32) dwLoc08 + 64) = ebx_45;
		}
		ebp_54 = dwArg0C;
	}
	*((word32) dwLoc08 + 4) = ecx_28;
	*((word32) dwLoc08 + 8) = ebp_54;
	if (g_t81576F0 == 0x00)
		*dwLoc08 = edx_41;
	else
		runtime.writebarrierptr(dwLoc08, edx_41);
}

// 08081240: void runtime.(*Frames).Next(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.panicwrap
void runtime.(*Frames).Next(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD88(0x00, (word32) fp + 8);
	fn0808FD88(0x00, fp - 0x24);
	runtime.(*stackExpander).next(gs, dwLoc74, (char *) &dwLoc04->t0004 + 8, dwLoc04->t0000, dwLoc04->t0004);
	fn08090250(fp - 0x44, fp - 0x18);
	*((word32) dwArg08 + 4) = dwLoc4C;
	*((word32) dwArg08 + 8) = dwLoc48;
	if (g_t81576F0 == 0x00)
		*dwArg08 = dwLoc20;
	else
		runtime.writebarrierptr(dwArg08, dwLoc20);
	fn08090250(fp - 0x1C, (word32) fp + 0x0C);
}

// 08081310: void runtime.(*stackExpander).next(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.Caller
//      runtime.(*Frames).Next
void runtime.(*stackExpander).next(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_114;
	Eq_4 edx_151;
	Eq_4 ecx_111;
	Eq_4 eax_172;
	fn0808FD88(0x00, (word32) fp + 32);
	Eq_4 esp_119 = fp - 0x38;
	if ((byte) (word32) *dwArg00 == 0x00)
	{
		if (dwArg08 == 0x00)
		{
			((word32) dwArg00 + 48)->u0 = 0x00;
			fn08090250(0x080F1E80, (word32) fp + 28);
			return;
		}
		Eq_4 al_97;
		runtime.(*pcExpander).init(gs, dwArg00, *dwArg04, (byte) (word32) *((word32) dwArg00 + 48));
		edx_151 = dwArg0C - 0x01;
		Eq_4 ecx_140 = (word32) dwArg04 + (0x01 - dwArg0C >> 0x1F & 0x04);
		ebx_114 = dwArg00;
		Eq_4 ebp_84 = *((word32) dwArg00 + 20);
		if (ebp_84 != 0x00)
			al_97 = *ebp_84 == g_t815763C;
		else
			al_97.u0 = 0x00;
		Eq_4 eax_110;
		*((word32) dwArg00 + 48) = al_97;
		Eq_4 esi_142 = dwArg0C;
		Eq_4 ebp_104 = dwArg08 - 0x01;
		Eq_4 edi_105 = dwArg08;
		if (*((word32) dwArg00 + 52) > 0x00)
		{
			while (*((word32) ebx_114 + 52) > 0x00)
			{
				*esp_119 = ebx_114;
				runtime.(*pcExpander).next(gs, *((word32) esp_119 - 4));
				esp_119.u0 = <invalid>;
				ebx_114 = *((byte) esp_119.u0 + 56);
				--*((word32) ebx_114 + 52);
				ecx_140 = *((byte) esp_119.u0 + 48);
				ebp_104 = *((byte) esp_119.u0 + 40);
				esi_142 = *((byte) esp_119.u0 + 0x0044);
				edi_105 = *((byte) esp_119.u0 + 64);
			}
			((word32) ebx_114 + 52)->u0 = 0x00;
			if (ebp_104 < 0x01)
				runtime.panicslice(gs);
			Eq_4 eax_150 = esi_142 - 0x02;
			edx_151 = eax_150;
			eax_110 = (word32) ecx_140 + (-eax_150 >> 0x1F & 0x04);
			ecx_111 = edi_105 - 0x02;
		}
		else
		{
			eax_110 = ecx_140;
			ecx_111 = dwArg08 - 0x01;
		}
		esp_119 = fp - 48;
		eax_172 = eax_110;
		if ((byte) (word32) *ebx_114 == 0x00)
		{
			fn08090250(0x080F1EA0, (word32) fp + 36);
			return;
		}
	}
	else
	{
		ebx_114 = dwArg00;
		eax_172 = dwArg04;
		ecx_111 = dwArg08;
		edx_151 = dwArg0C;
	}
	*((byte) esp_119.u0 + 44) = eax_172;
	*((byte) esp_119.u0 + 40) = ecx_111;
	*((byte) esp_119.u0 + 36) = edx_151;
	*esp_119.u0 = ebx_114;
	runtime.(*pcExpander).next(gs, *((byte) esp_119.u0 - 4));
	fn08090250(fp - 44, (word32) fp + 36);
	(byte) (word32) *dwArg04 == 0x00;
}

// 08081510: void runtime.(*pcExpander).init(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C)
// Called from:
//      runtime.(*stackExpander).next
void runtime.(*pcExpander).init(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*dwArg04 = 0x00;
	runtime.findfunc(gs, dwArg08);
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 20) = dwLoc24;
		*((word32) dwArg04 + 24) = dwLoc20;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, dwLoc24);
		runtime.writebarrierptr((word32) dwArg04 + 24, dwLoc20);
	}
	if (*((word32) dwArg04 + 20) == 0x00)
	{
		if (g_ptr8144FBC != null)
		{
			runtime.expandCgoFrames(gs);
			Eq_4 esp_86 = <invalid>;
			Eq_4 eax_95 = *((word32) esp_86 + 0x0C);
			Eq_4 edx_97 = *((word32) esp_86 + 4);
			Eq_4 ebx_116 = *((word32) esp_86 + 44);
			*((word32) ebx_116 + 0x0C) = *((word32) esp_86 + 8);
			*((word32) ebx_116 + 16) = eax_95;
			if (g_t81576F0 == 0x00)
				*((word32) ebx_116 + 8) = edx_97;
			else
			{
				*esp_86 = (word32) ebx_116 + 8;
				*((word32) esp_86 + 4) = edx_97;
				runtime.writebarrierptr(*esp_86, *((word32) esp_86 + 4));
				ebx_116 = *((word32) esp_86 + 44);
			}
			*ebx_116 = *((word32) ebx_116 + 0x0C) > 0x00;
		}
	}
	else
	{
		*dwArg04 = 0x01;
		Eq_4 eax_131 = **((word32) dwArg04 + 20);
		*((word32) dwArg04 + 4) = dwArg08;
		if (dwArg08 > eax_131 && (byte) ((word32) bArg0C) == 0x00)
			*((word32) dwArg04 + 4) = dwArg08 - 0x01;
		runtime.funcline1(gs, *((word32) dwArg04 + 20), *((word32) dwArg04 + 24), 0x00);
		*((word32) dwArg04 + 36) = dwLoc14;
		Eq_4 dwLoc1C_324 = SEQ(nLoc1B, 0x00);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 32) = dwLoc18;
		else
			runtime.writebarrierptr((word32) dwArg04 + 32, dwLoc18);
		*((word32) dwArg04 + 40) = dwLoc10;
		runtime.funcdata(gs, *((word32) dwArg04 + 20), 0x02);
		if (dwLoc1C_324 != 0x00)
		{
			if (g_t81576F0 == 0x00)
				*((word32) dwArg04 + 28) = dwLoc1C_324;
			else
				runtime.writebarrierptr((word32) dwArg04 + 28, dwLoc1C_324);
			runtime.pcdatavalue(gs, *((word32) dwArg04 + 20), 0x01);
			*((word32) dwArg04 + 44) = dwLoc14;
		}
		else
		{
			if (g_t81576F0 == 0x00)
				((word32) dwArg04 + 28)->u0 = 0x00;
			else
				runtime.writebarrierptr((word32) dwArg04 + 28, 0x00);
			((word32) dwArg04 + 44)->u0 = ~0x00;
		}
	}
}

// 08081750: void runtime.(*pcExpander).next(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.(*stackExpander).next
void runtime.(*pcExpander).next(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp - 0x08 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD88(0x00, (word32) fp + 8);
	if ((byte) (word32) *dwArg00 == 0x00)
		fn08090250(0x080F1EC0, (word32) fp + 4);
	else
	{
		Eq_4 esi_43 = *((word32) dwArg00 + 8);
		if (*((word32) dwArg00 + 0x0C) <= 0x00)
		{
			Eq_4 eax_47 = *((word32) dwArg00 + 44);
			if (eax_47 < 0x00)
			{
				*dwArg00 = 0x00;
				runtime.funcname(gs, *((word32) dwArg00 + 20), *((word32) dwArg00 + 24));
				fn08090250(0x080F1F00, fp - 0x24);
				fn08090250(fp - 0x28, fp);
			}
			else
			{
				Eq_4 edx_106 = *((word32) dwArg00 + 28);
				if (eax_47 >= 0x00100000)
					runtime.panicindex(gs);
				else
				{
					Eq_4 ebp_117 = *((word32) edx_106 + (eax_47 * 0x10 + 8));
					word32 esi_119 = *((word32) edx_106 + eax_47 * 0x10);
					Eq_4 eax_121 = *((word32) edx_106 + (eax_47 * 0x10 + 0x0C));
					runtime.funcnameFromNameoff(gs, *((word32) dwArg00 + 20), *((word32) dwArg00 + 24), eax_121);
					fn08090250(0x080F1EE0, fp - 100);
					runtime.funcfile(gs, dwLoc04->t0014, dwLoc04->t0018, ebp_117);
					dwLoc04->dw0024 = dwLoc80;
					if (g_t81576F0 == 0x00)
						dwLoc04->t0020 = eax_121;
					else
						runtime.writebarrierptr(&dwLoc04->t0020, eax_121);
					dwLoc04->dw0028 = esi_119;
					dwLoc04->dw002C = dwLoc7C;
					fn08090250(fp - 0x68, fp);
				}
			}
		}
		else
		{
			fn08090250(esi_43, fp - 0x44);
			int32 ecx_228 = dwLoc04->dw0010;
			Eq_4 ebx_229 = dwLoc04->t0008;
			Eq_72123 ebp_230 = dwLoc04->t000C;
			if (ebp_230 < 0x01)
				runtime.panicslice(gs);
			else
			{
				dwLoc04->t000C = ebp_230 - 0x01;
				dwLoc04->dw0010 = ecx_228 - 0x01;
				Eq_4 ecx_241 = (word32) ebx_229 + (0x01 - ecx_228 >> 0x1F & 0x20);
				if (g_t81576F0 == 0x00)
					dwLoc04->t0008 = ecx_241;
				else
					runtime.writebarrierptr((word32) dwArg00 + 8, ecx_241);
				dwLoc04->t0000 = dwLoc04->t000C > 0x00;
				fn08090250(fp - 0x48, fp);
			}
		}
	}
}

// 08081A00: void runtime.expandCgoFrames(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*pcExpander).init
void runtime.expandCgoFrames(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD89(0x00, fp - 0x3C);
	runtime.callCgoSymbolizer(gs);
	struct Eq_72294 * esp_190 = fp - 0x7C;
	if (dwLoc3C == 0x00 && dwLoc34 == 0x00)
		return;
	word32 eax_207 = 0x00;
	word32 ecx_208 = 0x00;
	word32 edx_209 = 0x00;
	while (true)
	{
		Eq_4 ebp_140;
		esp_190->dw0024 = eax_207;
		esp_190->dw0020 = ecx_208;
		esp_190->dw0038 = edx_209;
		Eq_4 ebx_59 = esp_190->t0048;
		esp_190->t0000 = ebx_59;
		Eq_4 ebx_66 = runtime.gostring(ebx_59, gs, esp_190->t0000);
		esp_190->dw0034 = esp_190->dw0004;
		esp_190->dw002C = esp_190->dw0008;
		esp_190->t0000 = esp_190->t0040;
		runtime.gostring(ebx_66, gs, esp_190->t0000);
		word32 eax_90 = esp_190->dw0004;
		esp_190->dw0028 = esp_190->dw0008;
		fn08090250(0x080F1F20, (char *) &esp_190->t0048 + 16);
		struct Eq_72370 * esp_102 = (char *) esp_190 - 4;
		esp_102->dw0058 = esp_102->dw007C;
		esp_102->dw005C = 0x00;
		esp_102->dw0060 = esp_102->dw0034;
		esp_102->dw0064 = esp_102->dw002C;
		esp_102->dw0068 = eax_90;
		esp_102->dw006C = esp_102->dw0028;
		esp_102->dw0070 = esp_102->dw0044;
		esp_102->dw0074 = esp_102->dw004C;
		Eq_4 eax_117 = esp_102->t0020;
		Eq_4 edx_118 = (word32) eax_117 + 1;
		Eq_4 ebx_119 = esp_102->t0024;
		if ((word32) eax_117 + 1 <= ebx_119)
			ebp_140 = esp_102->t0038;
		else
		{
			esp_102->t0000.u0 = 0x080D88A0;
			esp_102->t0004 = esp_102->t0038;
			esp_102->t0008 = eax_117;
			esp_102->t000C = ebx_119;
			esp_102->t0010 = (word32) eax_117 + 1;
			word32 esi_309;
			runtime.growslice(gs, esp_102->t0000, esp_102->t0004, esp_102->t0008, esp_102->t000C, esp_102->t0010, out esi_309);
			ebp_140 = esp_102->t0014;
			ebx_119 = esp_102->t001C;
			edx_118 = esp_102->dw0018 + 0x01;
			eax_117 = esp_102->t0020;
		}
		esp_102->t0030 = ebp_140;
		esp_102->t0020 = edx_118;
		esp_102->t0024 = ebx_119;
		Eq_4 edi_156 = (word32) ebp_140 + (eax_117 << 0x05);
		if (g_t81576F0 == 0x00)
			fn08090250(&esp_102->dw0058, edi_156);
		else
		{
			esp_102->t0000.u0 = 0x080D88A0;
			esp_102->t0004 = edi_156;
			esp_102->t0008 = &esp_102->dw0058;
			word32 edi_170;
			word32 esi_172;
			runtime.typedmemmove(esp_102->t0000, esp_102->t0004, esp_102->t0008, out esi_172, out edi_170);
		}
		esp_190 = fp - 0x0078;
		if (dwLoc28 == 0x00)
			break;
		runtime.callCgoSymbolizer(gs);
		eax_207 = dwLoc54;
		ecx_208 = dwLoc58;
		edx_209 = dwLoc48;
	}
	runtime.callCgoSymbolizer(gs);
}

// 08081C20: void runtime.(*Func).funcInfo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*Func).Name
void runtime.(*Func).funcInfo(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findmoduledatap(gs, *dwArg04);
}

// 08081C60: void runtime.activeModules()
// Called from:
//      runtime.cgoIsGoPointer
//      runtime.cgoCheckTypedBlock
//      runtime.itabsinit
//      runtime.bulkBarrierPreWrite
//      runtime.gcMarkRootPrepare
//      runtime.markroot
//      reflect.typelinks
//      runtime.typelinksinit
void runtime.activeModules()
{
	runtime/internal/atomic.Loadp();
	if (dwLoc04 == 0x00)
		;
}

// 08081CB0: Register word32 runtime.modulesinit(Register (ptr32 Eq_2) gs, Register out Eq_4 esiOut)
// Called from:
//      runtime.schedinit
word32 runtime.modulesinit(struct Eq_2 * gs, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080C9200);
	Eq_4 ecx_29 = 135500832;
	eax_472 = dwLoc3C;
	while (true)
	{
		Eq_4 eax_472;
		Eq_4 eax_149 = eax_472;
		if (ecx_29 == 0x00)
			break;
		Eq_4 edx_150 = *((word32) eax_472 + 4);
		Eq_4 ebx_151 = *((word32) eax_472 + 8);
		Eq_4 ebp_152 = *eax_472;
		if ((word32) edx_150 + 1 > ebx_151)
		{
			word32 esi_479;
			runtime.growslice(gs, 0x080C7CC0, ebp_152, edx_150, ebx_151, (word32) edx_150 + 1, out esi_479);
			*((word32) dwLoc3C + 8) = dwLoc24;
			dwLoc38 = edx_150;
			dwLoc34 = ebx_151;
			if (g_t81576F0 == 0x00)
				*dwLoc3C = dwLoc2C;
			else
				runtime.writebarrierptr(dwLoc3C, dwLoc2C);
			edx_150 = dwLoc28;
			ebp_152 = dwLoc2C;
			eax_149 = dwLoc3C;
		}
		*((word32) eax_149 + 4) = (word32) edx_150 + 1;
		Eq_4 ebx_212 = (word32) ebp_152 + edx_150 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) ebp_152 + edx_150 * 0x04) = ecx_29;
		else
		{
			runtime.writebarrierptr(ebx_212, ecx_29);
			eax_149 = dwLoc3C;
		}
		Eq_4 eax_474 = eax_149;
		if (*((word32) ecx_29 + 0x00C4) == 0x00)
		{
			Eq_4 ebx_239 = (word32) ecx_29 + 200;
			eax_474 = eax_149;
			if (*((word32) ecx_29 + 200) == 0x00)
			{
				runtime.progToPointerMask(gs, *((word32) ecx_29 + 92), *((word32) ecx_29 + 0x0044) - *((word32) ecx_29 + 64));
				*((word32) ecx_29 + 0x00C4) = dwLoc38;
				if (g_t81576F0 == 0x00)
					*((word32) ecx_29 + 200) = dwLoc34;
				else
					runtime.writebarrierptr(ebx_239, dwLoc34);
				runtime.progToPointerMask(gs, *((word32) ecx_29 + 96), *((word32) ecx_29 + 76) - *((word32) ecx_29 + 72));
				*((word32) ecx_29 + 0x00CC) = dwLoc38;
				if (g_t81576F0 == 0x00)
					*((word32) ecx_29 + 0x00D0) = dwLoc34;
				else
					runtime.writebarrierptr((word32) ecx_29 + 0x00D0, dwLoc34);
				eax_474 = dwLoc3C;
			}
		}
		ecx_29 = *((word32) ecx_29 + 0x00D8);
		eax_472 = eax_474;
	}
	Eq_4 eax_105 = eax_472;
	Eq_4 ecx_46 = *((word32) eax_472 + 4);
	Eq_4 ebx_47 = *eax_472;
	Eq_4 edx_48 = g_t80E7C38;
	Eq_4 esi_50 = 0x00;
	ebx_57 = ebx_47;
	while (true)
	{
		Eq_4 ebx_57;
		if (esi_50 >= ecx_46)
			break;
		Eq_4 edi_59 = *ebx_57;
		if (*((word32) edi_59 + 48) <= edx_48 && edx_48 <= *((word32) edi_59 + 52))
		{
			if (ecx_46 <= 0x00)
				runtime.panicindex(gs);
			if (g_t81576F0 == 0x00)
				*ebx_47 = edi_59;
			else
				runtime.writebarrierptr(ebx_47, edi_59);
			eax_105 = dwLoc3C;
			Eq_4 edx_107 = *dwLoc3C;
			if (esi_50 >= *((word32) dwLoc3C + 4))
				runtime.panicindex(gs);
			else
			{
				Eq_4 ebx_113 = (word32) edx_107 + esi_50 * 0x04;
				if (g_t81576F0 == 0x00)
					*((word32) edx_107 + esi_50 * 0x04) = 135500832;
				else
				{
					runtime.writebarrierptr(ebx_113, 135500832);
					eax_105 = dwLoc3C;
				}
				break;
			}
		}
		ebx_57 = (word32) ebx_57 + 4;
		esi_50 = (word32) esi_50 + 1;
		eax_105 = dwLoc3C;
	}
	word32 ebx_138 = runtime.atomicstorep(135548892, eax_105);
	esiOut = esi_50;
	return ebx_138;
}

// 08081F50: Register word32 runtime.moduledataverify(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
word32 runtime.moduledataverify(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = 135500832;
	while (eax_18 != 0x00)
	{
		ebx = runtime.moduledataverify1(esi, gs, dwLoc0C, eax_18, out esi);
		Eq_4 esp_34 = <invalid>;
		eax_18 = *((word32) *((word32) esp_34 + 4) + 0x00D8);
	}
	return ebx;
}

// 08081FA0: Register Eq_4 runtime.moduledataverify1(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Register out Eq_4 esiOut)
// Called from:
//      runtime.moduledataverify
Eq_4 runtime.moduledataverify1(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, union Eq_4 & esiOut)
{
	while (fp - 0xD8 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_72842 * ebx_20 = *dwArg04;
	Eq_4 edx_21 = **dwArg04;
	if (edx_21 != ~0x04 || ((byte) ((word32) ebx_20->b0004) != 0x00 || ((byte) ((word32) ebx_20->b0005) != 0x00 || ((byte) ((word32) ebx_20->b0006) != 0x01 || (byte) ((word32) ebx_20->b0007) != 0x04))))
	{
		Eq_4 eax_69 = (word32) ebx_20->b0004;
		Eq_4 ecx_72 = (word32) ebx_20->b0005;
		Eq_4 edx_74 = (word32) ebx_20->b0006;
		Eq_4 ebx_76 = (word32) ebx_20->b0007;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		Eq_4 esi_113;
		runtime.printhex(esi, gs, edx_21, 0x00, out esi_113);
		runtime.printsp(gs);
		Eq_4 esi_133;
		runtime.printhex(esi_113, gs, eax_69, 0x00, out esi_133);
		runtime.printsp(gs);
		Eq_4 esi_153;
		runtime.printhex(esi_133, gs, ecx_72, 0x00, out esi_153);
		runtime.printsp(gs);
		Eq_4 esi_173;
		runtime.printhex(esi_153, gs, edx_74, 0x00, out esi_173);
		runtime.printsp(gs);
		word32 esi_1094;
		runtime.printhex(esi_173, gs, ebx_76, 0x00, out esi_1094);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		Eq_4 edx_220 = *((word32) dwArg04 + 16);
		fn0808FD60(0x00, fp - 0x0104);
		Eq_4 eax_230 = 0x00;
		edx_242 = edx_220;
		while (true)
		{
			Eq_4 edx_242;
			if (eax_230 >= edx_220 - 0x01)
				break;
			Eq_4 ebp_445 = *((word32) dwArg00 + 16);
			Eq_4 esi_446 = edx_242;
			Eq_4 edx_447 = *((word32) dwArg00 + 0x0C);
			if (eax_230 >= ebp_445)
			{
l0808265A:
				runtime.panicindex(gs);
			}
			struct Eq_72990 * ebx_451 = (word32) edx_447 + eax_230 * 0x08;
			up32 ebx_453 = ebx_451->dw0000;
			Eq_4 ecx_454 = (word32) eax_230 + 1;
			if (ecx_454 >= ebp_445)
				goto l0808265A;
			struct Eq_73002 * edx_459 = (word32) edx_447 + 8 + eax_230 * 0x08;
			if (ebx_453 > edx_459->dw0000)
			{
				Eq_4 ebx_463 = *((word32) dwArg00 + 4);
				struct Eq_73016 * ebp_464 = *dwArg00;
				Eq_4 esi_466 = ebx_451->t0004;
				if (esi_466 >= ebx_463)
					runtime.panicindex(gs);
				word32 esi_469 = esi_466 + ebp_464;
				Eq_4 edx_470 = edx_459->t0004;
				if (edx_470 >= ebx_463)
					runtime.panicindex(gs);
				word32 edx_474 = edx_470 + ebp_464;
				if (ecx_454 < edx_220 - 0x01)
					runtime.funcname(gs, edx_474, dwArg00);
				runtime.funcname(gs, esi_469, dwArg00);
				Eq_4 ecx_512 = *((word32) dwArg00 + 0x0C);
				Eq_4 edx_513 = *((word32) dwArg00 + 16);
				if (eax_230 < edx_513)
				{
					Eq_4 edi_520 = *((word32) ecx_512 + eax_230 * 0x08);
					if (ecx_454 < edx_513)
					{
						Eq_4 eax_529 = *((word32) ecx_512 + (eax_230 * 0x08 + 8));
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						Eq_4 esi_562;
						runtime.printhex(eax_230, gs, edi_520, 0x00, out esi_562);
						runtime.printsp(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						word32 esi_1095;
						runtime.printhex(esi_562, gs, eax_529, 0x00, out esi_1095);
						runtime.printsp(gs);
						runtime.printstring(gs);
						runtime.printnl(gs);
						runtime.printunlock(gs);
						Eq_4 eax_650 = 0x00;
						while (eax_650 <= eax_230)
						{
							struct Eq_73016 * ebx_670 = *dwArg00;
							Eq_4 ebp_671 = *((word32) dwArg00 + 4);
							Eq_4 esi_672 = *((word32) dwArg00 + 0x0C);
							if (eax_650 >= *((word32) dwArg00 + 16))
							{
l08082626:
								runtime.panicindex(gs);
							}
							Eq_4 esi_677 = (word32) esi_672 + eax_650 * 0x08 + 0x04;
							if (esi_677 >= ebp_671)
								goto l08082626;
							runtime.funcname(gs, ebx_670 + esi_677, dwArg00);
							Eq_4 ecx_692 = *((word32) dwArg00 + 0x0C);
							if (eax_650 >= *((word32) dwArg00 + 16))
								goto l08082626;
							Eq_4 eax_702 = *((word32) ecx_692 + eax_650 * 0x08);
							runtime.printlock(gs);
							runtime.printstring(gs);
							word32 esi_1096;
							runtime.printhex(eax_650, gs, eax_702, 0x00, out esi_1096);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							eax_650 = (word32) eax_650 + 1;
						}
						runtime.throw(gs);
					}
				}
				runtime.panicindex(gs);
			}
			if (edx_220 - 0x01 - eax_230 < 0x05)
			{
				struct Eq_73016 * eax_781 = *dwArg00;
				Eq_4 ebx_782 = *((word32) dwArg00 + 4);
				Eq_4 esi_784 = ebx_451->t0004;
				if (esi_784 >= ebx_782)
					runtime.panicindex(gs);
				word32 edi_787 = eax_781 + esi_784;
				word32 edi_789 = Mem788[eax_781 + esi_784:word32];
				if (ecx_454 < edx_220 - 0x01)
				{
					Eq_4 edx_792 = edx_459->t0004;
					if (edx_792 >= ebx_782)
						runtime.panicindex(gs);
					if (Mem788[eax_781 + 0x18 + edx_792:word32] != 0x00)
					{
						word32 edx_799 = Mem788[eax_781 + edx_792:word32];
						if ((word32) edx_799 - 16 >= edi_789)
							edi_789 = (word32) edx_799 - 16;
					}
				}
				runtime.pcvalue(gs, edi_787, dwArg00, Mem810[eax_781 + 0x14 + esi_784:word32], edi_789, fp - 0x0108, 0x01);
				runtime.pcvalue(gs, edi_787, dwArg00, Mem820[eax_781 + 0x18 + esi_784:word32], edi_789, fp - 0x0108, 0x01);
				runtime.pcvalue(gs, edi_787, dwArg00, Mem845[eax_781 + 0x10 + esi_784:word32], edi_789, fp - 0x0108, 0x01);
				bLoc014C = (byte) (fp - 0x0108);
				esi_446 = dwLoc0110;
			}
			edx_242 = esi_446;
			eax_230 = ecx_454;
		}
		Eq_4 ebx_240 = *((word32) dwArg00 + 40);
		Eq_4 ebp_241 = *((word32) dwArg00 + 16);
		Eq_4 esi_1084 = edx_242;
		Eq_4 edx_244 = *((word32) dwArg00 + 0x0C);
		if (ebp_241 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			if (*edx_244 == ebx_240)
			{
				Eq_4 edx_254 = *((word32) dwArg00 + 44);
				if (edx_220 - 0x01 >= ebp_241)
					runtime.panicindex(gs);
				if (edx_254 == ((edx_244 - 0x08))[edx_242].t0000)
				{
					Eq_4 ecx_272 = *((word32) dwArg00 + 188);
					Eq_4 edx_274 = *((word32) dwArg00 + 0x00B8);
					Eq_4 ebx_275 = 0x00;
					while (ebx_275 < ecx_272)
					{
						fn0809026E(edx_274, fp - 0x18);
						fn0809026E(fp - 0x18, fp - 44);
						Eq_4 ecx_312 = dwLoc1C->t0000;
						if (dwLoc20 != dwLoc1C->t0004)
						{
l08082532:
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printsp(gs);
							runtime.printstring(gs);
							runtime.printsp(gs);
							runtime.printstring(gs);
							runtime.printsp(gs);
							runtime.printstring(gs);
							runtime.printnl(gs);
							runtime.printunlock(gs);
							runtime.throw(gs);
						}
						word32 edi_1097;
						runtime.eqstring(dwLoc24, dwLoc20, ecx_312, out esi_1084, out edi_1097);
						if ((byte) (word32) bLoc014C == 0x00)
							goto l08082532;
						edx_274 = (word32) edx_274 + 20;
						ebx_275 = (word32) ebx_275 + 1;
					}
					esiOut = esi_1084;
					return ebx_275;
				}
			}
			runtime.throw(gs);
		}
	}
}

// 08082750: void runtime.FuncForPC(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.methodName
void runtime.FuncForPC(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findfunc(gs, dwArg04);
}

// 08082790: void runtime.(*Func).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.methodName
void runtime.(*Func).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	runtime.(*Func).funcInfo(gs, dwArg04);
	runtime.funcname(gs, dwLoc0C, dwLoc08);
}

// 08082800: void runtime.findmoduledatap(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*Func).funcInfo
//      runtime.findfunc
void runtime.findmoduledatap(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_73393 * ecx_17;
	for (ecx_17 = &g_t8139420; ecx_17 != null; ecx_17 = ecx_17->ptr00D8)
	{
		if (ecx_17->t0028 <= dwArg04 && dwArg04 < ecx_17->t002C)
			return;
	}
}

// 08082850: void runtime.findfunc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.newproc1
//      runtime.setsSP
//      runtime.(*sigctxt).preparePanic
//      runtime.(*pcExpander).init
//      runtime.FuncForPC
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.printcreatedby
void runtime.findfunc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findmoduledatap(gs, dwArg04);
	if (dwLoc04 == null)
		return;
	uint32 edx_35 = dwArg04 - dwLoc04->dw0028;
	struct Eq_73430 * edx_40 = dwLoc04->dw0024 + ((edx_35 >> 0x0C) + (edx_35 >> 0x0C) * 0x04) * 0x04;
	Eq_73443 ecx_42 = (edx_35 & 0x0FFF) >> 0x08;
	word32 ebp_43 = edx_40->dw0000;
	if (ecx_42 >= 0x10)
		runtime.panicindex(gs);
	else
	{
		word32 ecx_110 = (word32) Mem19[edx_40 + 0x04 + ecx_42:byte] + ebp_43;
		struct Eq_73463 * edx_52 = dwLoc04->ptr000C;
		uint32 ebp_53 = dwLoc04->dw0010;
		if (ecx_110 >= ebp_53)
			ecx_110 = ebp_53 - 0x01;
		if (ecx_110 >= ebp_53)
			runtime.panicindex(gs);
		else if (dwArg04 < edx_52[ecx_110])
		{
			for (; ecx_110 < ebp_53; --ecx_110)
			{
				if (edx_52[ecx_110] <= dwArg04 || ecx_110 <= 0x00)
				{
					if (ecx_110 == 0x00)
						runtime.throw(gs);
l080828F0:
					up32 esi_137 = dwLoc04->dw0004;
					if (ecx_110 >= ebp_53 || *((word32) (&(((edx_52 + ecx_110)->a0000))[0].t0000) + 4) >= esi_137)
						runtime.panicindex(gs);
					else
						return;
				}
			}
			runtime.panicindex(gs);
		}
		else
		{
			while (true)
			{
				uint32 esi_111 = ecx_110 + 0x01;
				if (esi_111 >= ebp_53)
					break;
				if (edx_52->a0008[ecx_110].t0000 > dwArg04)
					goto l080828F0;
				ecx_110 = esi_111;
			}
			runtime.panicindex(gs);
		}
	}
}

// 08082980: void runtime.pcvalue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack (ptr32 Eq_73058) dwArg14, Stack byte bArg18)
// Called from:
//      runtime.moduledataverify1
//      runtime.funcline1
//      runtime.funcspdelta
//      runtime.pcdatavalue
void runtime.pcvalue(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, struct Eq_73058 * dwArg14, byte bArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
		return;
	if (dwArg14 != null)
	{
		Eq_73538 ebx_30 = 0x00;
		while (ebx_30 < 0x10)
		{
			if (ebx_30 >= 0x10)
				runtime.panicindex(gs);
			ui32 ebp_424 = ebx_30 * 0x03;
			esi = dwArg14->a0004[ebp_424];
			if (dwArg0C == esi)
			{
				esi = dwArg14[ebp_424 * 0x04 / 8];
				if (dwArg10 == esi)
					return;
			}
			ebx_30 = (word32) ebx_30 + 1;
		}
	}
	if (dwArg04 == 0x00)
	{
		if ((byte) (word32) bArg18 == 0x00 || g_dw8157618 != 0x00)
			return;
		Eq_4 eax_53 = *dwArg04;
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_677;
		runtime.printhex(esi, gs, eax_53, 0x00, out esi_677);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		Eq_4 esi_98 = *((word32) dwArg08 + 8);
		Eq_4 edi_99 = *((word32) dwArg08 + 4);
		word32 ebp_100 = *dwArg08;
		if (dwArg0C > edi_99)
			runtime.panicslice(gs);
		else
		{
			Eq_4 esi_113 = esi_98 - dwArg0C;
			Eq_4 esi_123 = -esi_113 >> 0x1F & dwArg0C;
			Eq_4 ecx_109 = *dwArg04;
			Eq_73593 edi_112 = edi_99 - dwArg0C;
			Eq_4 ecx_114 = esi_113;
			byte (* ebp_124)[] = (word32) esi_123 + ebp_100;
			while (true)
			{
				runtime.step(gs, ebp_124, edi_112, ecx_114, fp - 0x1C, fp - 0x20, *dwArg04 == ecx_109);
				if ((byte) (word32) bLoc24 == 0x00)
					break;
				if (dwArg10 < ecx_109)
				{
					if (dwArg14 != null)
					{
						Eq_4 ecx_396 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
						Eq_4 edx_397 = *((word32) ecx_396 + 0x0094);
						Eq_4 ebx_402 = edx_397 << 0x01 ^ edx_397 >> 0x1F & 0xA8888EEF;
						*((word32) ecx_396 + 0x0094) = ebx_402;
						ui32 ecx_407 = (ebx_402 & 0x0F) + (ebx_402 & 0x0F) * 0x02;
						dwArg14[ecx_407 * 0x04 / 8] = (struct Eq_73058) dwArg10;
						dwArg14->a0004[ecx_407] = dwArg0C;
						dwArg14->a0008[ecx_407] = ~0x00;
					}
					return;
				}
				edi_112 = dwLoc2C;
				ebp_124 = dwLoc30;
				ecx_114 = dwLoc28;
			}
			if (g_dw8157618 != 0x00 || (byte) ((word32) bArg18) == 0x00)
				return;
			runtime.funcname(gs, dwArg04, dwArg08);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			word32 esi_678;
			runtime.printhex(esi_123, gs, ecx_109, 0x00, out esi_678);
			runtime.printstring(gs);
			word32 esi_679;
			runtime.printhex(esi_123, gs, dwArg10, 0x00, out esi_679);
			runtime.printstring(gs);
			runtime.printslice(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			Eq_4 ecx_264 = *((word32) dwArg08 + 8);
			Eq_4 edx_265 = *((word32) dwArg08 + 4);
			word32 eax_266 = *dwArg08;
			if (dwArg0C > edx_265)
				runtime.panicslice(gs);
			else
			{
				Eq_4 ecx_279 = ecx_264 - dwArg0C;
				Eq_4 esi_275 = *dwArg04;
				Eq_73593 edx_278 = edx_265 - dwArg0C;
				Eq_4 esi_280 = ecx_279;
				byte (* eax_284)[] = eax_266 + (-ecx_279 >> 0x1F & dwArg0C);
				while (true)
				{
					runtime.step(gs, eax_284, edx_278, esi_280, fp - 0x1C, fp - 0x20, *dwArg04 == esi_275);
					if ((byte) (word32) bLoc24 == 0x00)
						break;
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(SLICE(dwLoc30, word24, 8), gs, ~0x00);
					runtime.printstring(gs);
					word32 esi_680;
					runtime.printhex(dwLoc28, gs, esi_275, 0x00, out esi_680);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					esi_280 = dwLoc28;
					edx_278 = dwLoc2C;
					eax_284 = dwLoc30;
				}
				runtime.throw(gs);
			}
		}
	}
}

// 08082E00: void runtime.funcname(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanframeworker
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.(*pcExpander).next
//      runtime.moduledataverify1
//      runtime.(*Func).Name
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.printcreatedby
//      runtime.showframe
void runtime.funcname(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 != 0x00)
	{
		Eq_4 eax_21 = *((word32) dwArg04 + 4);
		if (eax_21 != 0x00)
		{
			if (eax_21 >= *((word32) dwArg08 + 4))
				runtime.panicindex(gs);
l08082E26:
			runtime.gostringnocopy();
			return;
		}
	}
	goto l08082E26;
}

// 08082E70: void runtime.funcnameFromNameoff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*pcExpander).next
//      runtime.gentraceback
void runtime.funcnameFromNameoff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	if (dwArg0C >= *((word32) dwArg08 + 4))
		runtime.panicindex(gs);
	else
		runtime.gostringnocopy();
}

// 08082EE0: void runtime.funcfile(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*pcExpander).next
//      runtime.gentraceback
void runtime.funcfile(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	Eq_4 edx_28 = *((word32) dwArg08 + 4);
	Eq_4 eax_30 = *((word32) dwArg08 + 24);
	if (dwArg0C >= *((word32) dwArg08 + 28) || *((word32) eax_30 + dwArg0C * 0x04) >= edx_28)
		runtime.panicindex(gs);
	else
		runtime.gostringnocopy();
}

// 08082F60: void runtime.funcline1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg10)
// Called from:
//      runtime.(*pcExpander).init
//      runtime.funcline
void runtime.funcline1(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	runtime.pcvalue(gs, dwArg04, dwArg08, *((word32) dwArg04 + 20), dwArg0C, null, (byte) (word32) bArg10);
	runtime.pcvalue(gs, dwArg04, dwArg08, *((word32) dwArg04 + 24), dwArg0C, null, (byte) (word32) bArg10);
	if (dwLoc08 == ~0x00 || dwLoc08 == ~0x00)
		return;
	Eq_4 ebx_67 = *((word32) dwArg08 + 28);
	Eq_4 ebp_68 = *((word32) dwArg08 + 24);
	if (dwLoc08 >= ebx_67)
		return;
	Eq_4 ebx_71 = *((word32) dwArg08 + 4);
	if (dwLoc08 >= ebx_67 || *((word32) ebp_68 + dwLoc08 * 0x04) >= ebx_71)
		runtime.panicindex(gs);
	else
		runtime.gostringnocopy();
}

// 080830A0: void runtime.funcline(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gentraceback
//      runtime.printcreatedby
void runtime.funcline(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.funcline1(gs, dwArg04, dwArg08, 0x01);
}

// 08083100: void runtime.funcspdelta(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gentraceback
void runtime.funcspdelta(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.pcvalue(gs, dwArg04, dwArg08, *((word32) dwArg04 + 16), dwArg0C, dwArg10, 0x01);
	if ((dwLoc18 & 0x03) != 0x00)
	{
		runtime.funcname(gs, dwArg04, dwArg08);
		Eq_4 ebx_51 = *dwArg04;
		Eq_4 edx_53 = *((word32) dwArg04 + 16);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		word32 esi_208;
		runtime.printhex(esi, gs, ebx_51, 0x00, out esi_208);
		runtime.printstring(gs);
		word32 esi_209;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_209);
		runtime.printstring(gs);
		word32 esi_210;
		runtime.printhex(esi, gs, edx_53, edx_53 >> 0x1F, out esi_210);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, dwLoc18);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 080832A0: void runtime.pcdatavalue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scanframeworker
//      runtime.adjustframe
//      runtime.(*pcExpander).init
//      runtime.gentraceback
void runtime.pcdatavalue(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C < 0x00 || dwArg0C >= *((word32) dwArg04 + 28))
		return;
	runtime.pcvalue(gs, dwArg04, dwArg08, *((word32) dwArg04 + (dwArg0C * 0x04 + 36)), dwArg10, dwArg14, 0x01);
}

// 08083320: Register (ptr32 int32) runtime.funcdata(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scanframeworker
//      runtime.newproc1
//      runtime.adjustframe
//      runtime.(*pcExpander).init
//      runtime.gentraceback
int32 * runtime.funcdata(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C < 0x00)
		return ebx;
	ebx = (word32) dwArg04 + 32;
	if (dwArg0C >= *((word32) dwArg04 + 32))
		return ebx;
	return (word32) dwArg04 + 32;
}

// 08083370: void runtime.step(Register (ptr32 Eq_2) gs, Stack (arr byte) dwArg04, Stack Eq_73593 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14, Stack Eq_73606 bArg18)
// Called from:
//      runtime.pcvalue
void runtime.step(struct Eq_2 * gs, byte dwArg04[], Eq_73593 dwArg08, Eq_4 dwArg0C, word32 * dwArg10, word32 * dwArg14, Eq_73606 bArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		uint32 edx_27 = (word32) dwArg04[0];
		if (edx_27 == 0x00 && (byte) ((word32) bArg18) == 0x00)
			return;
		Eq_73593 ebx_58;
		if ((edx_27 & 0x80) == 0x00)
			ebx_58.u0 = 0x01;
		else
		{
			runtime.readvarint(gs, dwArg04, dwArg08);
			ebx_58 = dwLoc10;
			edx_27 = dwLoc0C;
		}
		if (ebx_58 > dwArg08)
			runtime.panicslice(gs);
		else
		{
			uint32 edx_121;
			int32 ebx_87 = ebx_58 & ebx_58 - dwArg0C >> 0x1F;
			Eq_73593 eax_73 = dwArg08 - ebx_58;
			byte (* ebp_89)[] = dwArg04 + ebx_87;
			if ((edx_27 & 0x01) != 0x00)
				edx_121 = ~(edx_27 >> 0x01);
			else
				edx_121 = edx_27 >> 0x01;
			if (eax_73 <= 0x00)
				runtime.panicindex(gs);
			else
			{
				Eq_73593 ebx_130;
				uint32 ecx_113 = (word32) dwArg04[ebx_87];
				if ((ecx_113 & 0x80) == 0x00)
					ebx_130.u0 = 0x01;
				else
				{
					runtime.readvarint(gs, ebp_89, eax_73);
					ebx_130 = dwLoc10;
					ecx_113 = dwLoc0C;
				}
				if (ebx_130 > eax_73)
					runtime.panicslice(gs);
				else
				{
					*dwArg10 += ecx_113;
					*dwArg14 += edx_121;
				}
			}
		}
	}
}

// 08083510: void runtime.readvarint(Register (ptr32 Eq_2) gs, Stack (ptr32 (arr byte)) dwArg04, Stack Eq_73593 dwArg08)
// Called from:
//      runtime.step
void runtime.readvarint(struct Eq_2 * gs, byte (* dwArg04)[], Eq_73593 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_73593 ecx_19 = 0x00;
	while (ecx_19 < dwArg08)
	{
		Eq_73593 edi_45 = (word32) ecx_19 + 1;
		if ((SLICE((word32) SLICE((word32) Mem35[dwArg04 + ecx_19:byte], byte, 0), byte, 0) & 0x80) == 0x00)
			return;
		ecx_19 = edi_45;
	}
	runtime.panicindex(gs);
}

// 08083580: void runtime.stackmapdata(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanframeworker
//      runtime.newproc1
//      runtime.adjustframe
void runtime.stackmapdata(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 >= 0x00 && dwArg08 < *dwArg04)
		return;
	runtime.throw(gs);
}

// 080835F0: Register Eq_4 runtime.deltimer(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.runtime_pollUnblock
Eq_4 runtime.deltimer(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_29;
	word32 edi_30;
	Eq_4 esi_225;
	runtime.lock(esi, gs, 0x081452A0, out ebp_29, out esi_225, out edi_30);
	Eq_4 ecx_37 = *dwArg04;
	Eq_4 edx_38 = g_t81452B8;
	Eq_4 ebx_39 = g_t81452BC;
	if (ecx_37 >= 0x00 && ecx_37 <= ebx_39 - 0x01)
	{
		if (ecx_37 >= ebx_39)
			runtime.panicindex(gs);
		esi_225 = *((word32) edx_38 + ecx_37 * 0x04);
		Eq_4 edi_49 = (word32) edx_38 + ecx_37 * 0x04;
		if (esi_225 == dwArg04)
		{
			if (ebx_39 - 0x01 != ecx_37)
			{
				if (ebx_39 - 0x01 >= ebx_39)
					runtime.panicindex(gs);
				Eq_4 esi_59 = (edx_38 - 0x04)[ebx_39];
				if (g_t81576F0 == 0x00)
					*((word32) edx_38 + ecx_37 * 0x04) = esi_59;
				else
					runtime.writebarrierptr(edi_49, esi_59);
				Eq_4 eax_79 = g_t81452B8;
				if (ecx_37 >= g_t81452BC)
					runtime.panicindex(gs);
				**((word32) eax_79 + ecx_37 * 0x04) = ecx_37;
			}
			Eq_4 edx_89 = g_t81452B8;
			if (ebx_39 - 0x01 >= g_t81452BC)
				runtime.panicindex(gs);
			else
			{
				Eq_4 esi_148 = edx_89 - 0x04 + ebx_39 * 0x04;
				if (g_t81576F0 == 0x00)
					(edx_89 - 0x04)[ebx_39] = 0x00;
				else
					runtime.writebarrierptr(esi_148, 0x00);
				if (ebx_39 - 0x01 > g_t81452C0)
					runtime.panicslice(gs);
				else
				{
					g_t81452BC = ebx_39 - 0x01;
					if (ebx_39 - 0x01 != ecx_37)
					{
						runtime.siftupTimer(gs, ecx_37);
						esi_148 = runtime.siftdownTimer(gs, ecx_37);
					}
					word32 edx_241;
					word32 ebx_242;
					runtime.unlock(gs, 0x081452A0, out edx_241, out ebx_242);
					return esi_148;
				}
			}
		}
	}
	word32 ebx_240;
	word32 edx_239;
	runtime.unlock(gs, 0x081452A0, out edx_239, out ebx_240);
	return esi_225;
}

// 08083780: void runtime.timerproc(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.timerproc(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = gs->ptr0000->tFFFFFFFC;
	if (g_t81576F0 == 0x00)
		g_t81452A4 = ecx_19;
	else
	{
		runtime.writebarrierptr(135549604, ecx_19);
		dwLoc50 = ecx_19;
	}
	while (true)
	{
l08083A59:
		word32 ebp_606;
		word32 esi_607;
		word32 edi_45;
		runtime.lock(esi, gs, 0x081452A0, out ebp_606, out esi_607, out edi_45);
		g_b81452A9 = 0x00;
		runtime.nanotime();
		while (true)
		{
			ui64 ecx_esi_506;
			Eq_4 edx_65 = g_t81452BC;
			Eq_4 ebx_66 = g_t81452B8;
			ui24 eax_24_8_101 = SLICE(dwLoc50, word24, 8);
			ui24 eax_24_8_106 = SLICE(dwLoc50, word24, 8);
			ui24 eax_24_8_125 = SLICE(dwLoc50, word24, 8);
			ui24 edx_24_8_130 = SLICE(edx_65, word24, 8);
			ui24 ebx_24_8_155 = SLICE(ebx_66, word24, 8);
			if (edx_65 == 0x00)
				break;
			Eq_4 ebp_72 = *ebx_66;
			Eq_4 esi_73 = *((word32) ebp_72 + 4);
			ecx_esi_506 = SEQ(ecx_79, esi_73) - SEQ(dwLoc50, 0x081452A0);
			up32 esi_77 = (word32) ecx_esi_506;
			int32 ecx_83 = SLICE(ecx_esi_506, word32, 32);
			ui32 edi_108 = SEQ(SLICE(edi_45, word24, 8), esi_77 > 0x00) & SEQ(eax_24_8_101, ecx_83 == 0x00) | SEQ(eax_24_8_106, ecx_83 > 0x00);
			Eq_4 ecx_79 = *((word32) ebp_72 + 8);
			ebx_24_8_155 = SLICE(ebx_66, word24, 8);
			eax_24_8_125 = eax_24_8_106;
			if ((byte) edi_108 != 0x00)
				goto l08083A0E;
			Eq_4 esi_343;
			Eq_4 eax_229 = *((word32) ebp_72 + 16);
			ui24 ebx_24_8_238 = SLICE(esi_77, word24, 8);
			Eq_4 ecx_230 = *((word32) ebp_72 + 0x0C);
			ui32 edi_266 = SEQ(SLICE(edi_108, word24, 8), ecx_230 > 0x00) & SEQ(ebx_24_8_238, eax_229 == 0x00) | SEQ(ebx_24_8_238, eax_229 > 0x00);
			if ((byte) edi_266 == 0x00)
			{
				if (edx_65 > 0x01)
				{
					if (edx_65 - 0x01 >= edx_65)
						runtime.panicindex(gs);
					Eq_4 esi_358 = (ebx_66 - 0x04)[edx_65];
					if (g_t81576F0 == 0x00)
						*ebx_66 = esi_358;
					else
						runtime.writebarrierptr(ebx_66, esi_358);
					Eq_4 ebx_379 = g_t81452B8;
					if (g_t81452BC <= 0x00)
						runtime.panicindex(gs);
					**ebx_379 = 0x00;
				}
				Eq_4 ebx_389 = g_t81452B8;
				if (edx_65 - 0x01 >= g_t81452BC)
					runtime.panicindex(gs);
				esi_343 = ebx_389 - 0x04 + edx_65 * 0x04;
				if (g_t81576F0 == 0x00)
					(ebx_389 - 0x04)[edx_65] = 0x00;
				else
					runtime.writebarrierptr(esi_343, 0x00);
				if (edx_65 - 0x01 > g_t81452C0)
					runtime.panicslice(gs);
				g_t81452BC = edx_65 - 0x01;
				if (edx_65 > 0x01)
					esi_343 = runtime.siftdownTimer(gs, 0x00);
				*ebp_72 = ~0x00;
			}
			else
			{
				runtime.int64div(SLICE(esi_73, word24, 8), edi_266, gs, SEQ(dwLoc50, 0x081452A0) - SEQ(ecx_79, esi_73), SEQ(eax_229, ecx_230));
				uint64 edx_eax_310 = ecx_230 * (dwLoc44 + 0x01);
				uint32 eax_311 = (word32) edx_eax_310;
				*((word32) ebp_72 + 4) = (word32) esi_73 + eax_311;
				*((word32) ebp_72 + 8) = SLICE(SEQ((dwLoc44 + 0x01) *s eax_229 + SLICE(edx_eax_310, word32, 32) + (dwLoc40 + (dwLoc44 < 0x01)) *s ecx_230, eax_311) + SEQ(ecx_79, esi_73), word32, 32);
				esi_343 = runtime.siftdownTimer(gs, 0x00);
			}
			Eq_4 eax_446 = *((word32) ebp_72 + 20);
			Eq_4 ecx_450 = *((word32) ebp_72 + 28);
			Eq_4 edx_452 = *((word32) ebp_72 + 24);
			Eq_4 ebx_454 = *((word32) ebp_72 + 32);
			word32 edx_608;
			word32 ebx_609;
			runtime.unlock(gs, 0x081452A0, out edx_608, out ebx_609);
			<anonymous> * eax_476 = *eax_446;
			eax_476();
			word32 esi_611;
			word32 ebp_610;
			runtime.lock(esi_343, gs, 0x081452A0, out ebp_610, out esi_611, out edi_45);
		}
		ecx_esi_506 = ~0x00;
l08083A0E:
		int32 ecx_119 = SLICE(ecx_esi_506, word32, 32);
		esi = (word32) ecx_esi_506;
		if ((byte) (SEQ(eax_24_8_125, ecx_119 == 0x00) & SEQ(edx_24_8_130, Test(ULT,false)) | SEQ(edx_24_8_130, ecx_119 < 0x00)) != 0x00)
			break;
		int32 eax_143 = g_dw8157674;
		up32 edx_144 = g_dw8157670;
		if ((byte) (SEQ(SLICE(edx_144, word24, 8), edx_144 > 0x00) & SEQ(ebx_24_8_155, eax_143 == 0x00) | SEQ(SLICE(eax_143, word24, 8), eax_143 > 0x00)) != 0x00)
			break;
		g_b81452A9 = 0x01;
		ui64 eax_eax_515 = SEQ(dwLoc50, 0x081452A0) + ecx_esi_506;
		g_dw81452AC = (word32) eax_eax_515;
		g_dw81452B0 = SLICE(eax_eax_515, word32, 32);
		g_dw81452B4 = 0x00;
		word32 ebx_613;
		word32 edx_612;
		runtime.unlock(gs, 0x081452A0, out edx_612, out ebx_613);
		runtime.notetsleepg(gs);
		dwLoc50 = esi;
	}
	g_b81452AA = 0x01;
	runtime.goparkunlock(gs);
	dwLoc50.u0 = 135149445;
	dwLoc44 = 0x01;
	goto l08083A59;
}

// 08083B70: void runtime.timejump(Register Eq_4 ebp, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.checkdead
void runtime.timejump(Eq_4 ebp, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17 = g_dw8157674;
	up32 ecx_18 = g_dw8157670;
	if ((byte) (SEQ(SLICE(eax_17, word24, 8), eax_17 == 0x00) & SEQ(SLICE(ecx_18, word24, 8), ecx_18 == 0x00)) != 0x00)
		return;
	word32 esi_171;
	word32 edi_172;
	word32 ebp_170;
	runtime.lock(esi, gs, 0x081452A0, out ebp_170, out esi_171, out edi_172);
	if ((byte) (word32) g_b81452A8 != 0x00)
	{
		Eq_4 eax_48 = g_t81452B8;
		if (g_t81452BC != 0x00)
		{
			struct Eq_74792 * eax_53 = *eax_48;
			int32 ecx_54 = g_dw8157674;
			up32 edx_55 = g_dw8157670;
			int32 ebx_56 = eax_53->dw0008;
			up32 eax_70 = eax_53->dw0004;
			if ((byte) (SEQ(SLICE(ecx_54, word24, 8), ecx_54 < ebx_56) | SEQ(SLICE(edx_55, word24, 8), edx_55 < eax_70) & SEQ(SLICE(ebp, word24, 8), ecx_54 == ebx_56)) != 0x00)
			{
				g_dw8157670 = eax_70;
				g_dw8157674 = ebx_56;
				if ((byte) (word32) g_b81452AA != 0x00)
					g_b81452AA = 0x00;
			}
			word32 edx_175;
			word32 ebx_176;
			runtime.unlock(gs, 0x081452A0, out edx_175, out ebx_176);
			return;
		}
	}
	word32 edx_173;
	word32 ebx_174;
	runtime.unlock(gs, 0x081452A0, out edx_173, out ebx_174);
}

// 08083C80: void runtime.siftupTimer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.deltimer
void runtime.siftupTimer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81452B8;
	Eq_4 ecx_18 = g_t81452BC;
	Eq_4 edx_147 = dwArg04;
	if (dwArg04 >= ecx_18)
		runtime.panicindex(gs);
	else
	{
		Eq_4 ebx_24 = *((word32) eax_17 + dwArg04 * 0x04);
		Eq_4 ebp_26 = *((word32) ebx_24 + 4);
		Eq_4 esi_28 = *((word32) ebx_24 + 8);
		eax_100 = eax_17;
		esi_105 = esi_28;
		ebp_104 = ebp_26;
		while (true)
		{
			Eq_4 ebp_104;
			Eq_4 esi_105;
			Eq_4 eax_100;
			ui24 edx_24_8_57 = SLICE(edx_147, word24, 8);
			if (edx_147 <= 0x00)
				break;
			Eq_74885 edi_35 = edx_147 - 0x01 >> 0x1F >> 0x1E;
			Eq_74892 edi_36 = (word32) edx_147 + (edi_35 - 0x01);
			if (edi_36 >> 0x02 >= ecx_18)
				runtime.panicindex(gs);
			Eq_4 ebx_45 = *((word32) eax_100 + (edi_36 >> 0x02) * 0x04);
			Eq_4 ecx_47 = *((word32) ebx_45 + 8);
			Eq_4 ebx_52 = *((word32) ebx_45 + 4);
			Eq_4 edx_68 = (word32) eax_100 + (edi_36 >> 0x02) * 0x04;
			if ((byte) (SEQ(SLICE(ecx_47, word24, 8), esi_105 > ecx_47) | SEQ(edx_24_8_57, esi_105 == ecx_47) & SEQ(SLICE(ebx_52, word24, 8), ebp_104 >= ebx_52)) != 0x00)
				return;
			if (edx_147 >= ecx_18)
				runtime.panicindex(gs);
			Eq_4 edx_82 = (word32) eax_100 + edx_147 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) eax_100 + edx_147 * 0x04) = ebx_45;
			else
			{
				runtime.writebarrierptr(edx_82, ebx_45);
				eax_100 = eax_17;
				ebp_104 = ebp_26;
				esi_105 = esi_28;
			}
			*ebx_45 = edx_147;
			word32 edi_134 = edi_35 - 0x01 + edx_147 >> 0x02;
			if (g_t81576F0 == 0x00)
				*((word32) eax_100 + edi_134 * 0x04) = ebx_24;
			else
			{
				runtime.writebarrierptr(edx_68, ebx_24);
				eax_100 = eax_17;
				ebp_104 = ebp_26;
				esi_105 = esi_28;
				edi_134 = edi_36 >> 0x02;
			}
			*ebx_24 = edi_134;
			edx_147 = edi_134;
		}
	}
}

// 08083E00: Register Eq_4 runtime.siftdownTimer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.deltimer
//      runtime.timerproc
Eq_4 runtime.siftdownTimer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81452B8;
	Eq_4 ecx_18 = g_t81452BC;
	Eq_4 edx_19 = dwArg04;
	if (dwArg04 >= ecx_18)
		runtime.panicindex(gs);
	else
	{
		Eq_4 ebx_24 = *((word32) eax_17 + dwArg04 * 0x04);
		Eq_4 ebp_26 = *((word32) ebx_24 + 4);
		Eq_4 esi_28 = *((word32) ebx_24 + 8);
		while (true)
		{
			ui32 edx_32 = edx_19 << 0x02;
			Eq_4 esi_193 = esi_28;
			ui24 edx_24_8_63 = SLICE(edx_32, word24, 8);
			if (edx_32 + 0x01 >= ecx_18)
				break;
			if (edx_32 + 0x01 >= ecx_18)
				runtime.panicindex(gs);
			Eq_4 ecx_50;
			Eq_4 eax_49;
			Eq_4 edi_43 = *((word32) eax_17 + (edx_32 * 0x04 + 4));
			Eq_4 ebp_44 = *((word32) edi_43 + 4);
			Eq_4 edi_45 = *((word32) edi_43 + 8);
			esi_193 = edx_32 + 0x02;
			if (edx_32 + 0x02 < ecx_18)
			{
				if (edx_32 + 0x02 >= ecx_18)
					runtime.panicindex(gs);
				Eq_4 eax_53 = *((word32) eax_17 + (edx_32 * 0x04 + 8));
				Eq_4 ecx_54 = *((word32) eax_53 + 4);
				eax_49 = *((word32) eax_53 + 8);
				if ((byte) (SEQ(SLICE(ecx_54, word24, 8), eax_49 < edi_45) | SEQ(edx_24_8_63, eax_49 == edi_45) & SEQ(SLICE(ecx_54, word24, 8), ecx_54 < ebp_44)) != 0x00)
					ecx_50 = ecx_54;
				else
				{
					eax_49 = edi_45;
					ecx_50 = ebp_44;
					esi_193 = edx_32 + 0x01;
				}
			}
			else
			{
				eax_49 = edi_45;
				ecx_50 = ebp_44;
				esi_193 = edx_32 + 0x01;
			}
			Eq_4 eax_194;
			Eq_4 edx_107;
			Eq_4 edi_108;
			ui24 ebx_24_8_164 = SLICE(edx_32 + 0x03, word24, 8);
			ui24 ebx_24_8_182 = SLICE(edx_32 + 0x03, word24, 8);
			if (edx_32 + 0x03 < ecx_18)
			{
				if (edx_32 + 0x03 >= ecx_18)
					runtime.panicindex(gs);
				Eq_4 eax_109;
				Eq_4 esi_101 = *((word32) eax_17 + (edx_32 * 0x04 + 0x0C));
				Eq_4 ecx_102 = *((word32) esi_101 + 8);
				Eq_4 esi_103 = *((word32) esi_101 + 4);
				ui24 eax_24_8_129 = SLICE(edx_32 + 0x04, word24, 8);
				ui24 eax_24_8_135 = SLICE(edx_32 + 0x04, word24, 8);
				if (edx_32 + 0x04 < ecx_18)
				{
					if (edx_32 + 0x04 >= ecx_18)
						runtime.panicindex(gs);
					Eq_4 edx_112 = *((word32) eax_17 + (edx_32 * 0x04 + 16));
					edi_108 = *((word32) edx_112 + 8);
					edx_107 = *((word32) edx_112 + 4);
					ebx_24_8_164 = SLICE(edx_32 + 0x03, word24, 8);
					ebx_24_8_164 = SLICE(edx_32 + 0x03, word24, 8);
					if ((byte) (SEQ(SLICE(ecx_18, word24, 8), edi_108 == ecx_102) & SEQ(eax_24_8_129, edx_107 < esi_103) | SEQ(eax_24_8_135, edi_108 < ecx_102)) != 0x00)
						eax_109 = edx_32 + 0x04;
					else
					{
						edx_107 = esi_103;
						edi_108 = ecx_102;
						eax_109 = edx_32 + 0x03;
					}
				}
				else
				{
					edx_107 = esi_103;
					edi_108 = ecx_102;
					eax_109 = edx_32 + 0x03;
				}
				Eq_4 esi_184 = SEQ(SLICE(esi_103, word24, 8), edx_107 < ecx_50) & SEQ(ebx_24_8_164, edi_108 == eax_49) | SEQ(ebx_24_8_164, edi_108 < eax_49);
				ebx_24_8_182 = ebx_24_8_164;
				esi_193 = esi_184;
				eax_194 = eax_109;
				if ((byte) esi_184 == 0x00)
				{
					edi_108 = eax_49;
					edx_107 = ecx_50;
					eax_194 = esi_193;
				}
			}
			else
			{
				edi_108 = eax_49;
				edx_107 = ecx_50;
				eax_194 = esi_193;
			}
			if ((byte) (SEQ(ebx_24_8_182, edi_108 > esi_28) | SEQ(SLICE(edx_107, word24, 8), edx_107 >= ebp_26) & SEQ(ebx_24_8_182, edi_108 == esi_28)) != 0x00)
				return esi_193;
			if (eax_194 >= ecx_18)
			{
l08084078:
				runtime.panicindex(gs);
			}
			Eq_4 esi_234 = *((word32) eax_17 + eax_194 * 0x04);
			Eq_4 edi_235 = (word32) eax_17 + eax_194 * 0x04;
			if (edx_19 >= ecx_18)
				goto l08084078;
			Eq_4 ebp_244 = (word32) eax_17 + edx_19 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) eax_17 + edx_19 * 0x04) = esi_234;
			else
				runtime.writebarrierptr(ebp_244, esi_234);
			*esi_234 = edx_19;
			if (g_t81576F0 == 0x00)
				*((word32) eax_17 + eax_194 * 0x04) = ebx_24;
			else
				runtime.writebarrierptr(edi_235, ebx_24);
			*ebx_24 = eax_194;
			edx_19 = eax_194;
		}
		return esi_193;
	}
}

// 080840B0: void time.now(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
void time.now(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.walltime();
	runtime.nanotime();
}

// 08084130: void runtime.traceReader(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedule
void runtime.traceReader(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw814F510 == 0x00 || g_ptr814F508 == null && (byte) ((word32) g_b814F4C9) == 0x00)
		return;
	word32 esi_124;
	word32 ebp_123;
	word32 edi_125;
	runtime.lock(esi, gs, 0x0814F4C0, out ebp_123, out esi_124, out edi_125);
	if (g_dw814F510 != 0x00 && (g_ptr814F508 != null || (byte) ((word32) g_b814F4C9) != 0x00))
	{
		g_dw814F510 = 0x00;
		word32 edx_128;
		word32 ebx_129;
		runtime.unlock(gs, 0x0814F4C0, out edx_128, out ebx_129);
	}
	else
	{
		word32 edx_126;
		word32 ebx_127;
		runtime.unlock(gs, 0x0814F4C0, out edx_126, out ebx_127);
	}
}

// 08084200: void runtime.traceProcFree(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.procresize
void runtime.traceProcFree(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_75242 * ecx_18 = *((word32) dwArg04 + 2344);
	*((word32) dwArg04 + 2344) = null;
	if (ecx_18 == null)
		return;
	word32 edi_110;
	word32 esi_109;
	word32 ebp_108;
	runtime.lock(esi, gs, 0x0814F4C0, out ebp_108, out esi_109, out edi_110);
	ecx_18->ptr0000 = null;
	if (g_ptr814F508 == null)
		g_ptr814F508 = ecx_18;
	else
		g_ptr814F50C->ptr0000 = ecx_18;
	g_ptr814F50C = ecx_18;
	word32 ebx_112;
	word32 edx_111;
	runtime.unlock(gs, 0x0814F4C0, out edx_111, out ebx_112);
}

// 08084290: Register Eq_75347 runtime.traceEvent(Register (ptr32 Eq_2) gs, Stack byte bArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_75351) dwArg0C, Stack Eq_75347 dwArg10, Register out Eq_75347 esiOut)
// Called from:
//      runtime.traceGomaxprocs
//      runtime.traceProcStart
//      runtime.traceProcStop
//      runtime.traceGCStart
//      runtime.traceGCDone
//      runtime.traceGCScanStart
//      runtime.traceGCScanDone
//      runtime.traceGCSweepSpan
//      runtime.traceGCSweepDone
//      runtime.traceGCMarkAssistStart
//      runtime.traceGCMarkAssistDone
//      runtime.traceGoCreate
//      runtime.traceGoStart
//      runtime.traceGoEnd
//      runtime.traceGoSched
//      runtime.traceGoPreempt
//      runtime.traceGoPark
//      runtime.traceGoUnpark
//      runtime.traceGoSysCall
//      runtime.traceGoSysExit
//      runtime.traceGoSysBlock
//      runtime.traceHeapAlloc
//      runtime.traceNextGC
Eq_75347 runtime.traceEvent(struct Eq_2 * gs, byte bArg04, Eq_4 dwArg08, struct Eq_75351 * dwArg0C, Eq_75347 dwArg10, union Eq_75347 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.traceAcquireBuffer(gs);
	if ((byte) (word32) g_b814F4C8 == 0x00 && (byte) ((word32) dwLoc4C->b01E0) == 0x00)
	{
		runtime.traceReleaseBuffer(gs, dwLoc48);
		esiOut = esi;
		return ebp;
	}
	else
	{
		struct Eq_75242 * dwLoc4C_364;
		struct Eq_75242 * ecx_65;
		struct Eq_75242 * ebx_49 = *dwLoc44;
		if (ebx_49 != null && -((word32) ebx_49->t000C - 0x0000FDF0) >= 0x34)
		{
			ecx_65 = ebx_49;
			dwLoc4C_364 = dwLoc4C;
		}
		else
		{
			runtime.traceFlush(gs, ebx_49);
			*dwLoc44 = (struct Eq_75242 **) dwLoc48;
			dwLoc4C_364 = ebx_49;
			ecx_65 = dwLoc48;
		}
		runtime.cputicks();
		struct Eq_75242 * ecx_93 = dwLoc4C_364 >> 0x06 | dwLoc48 << 0x1A;
		struct Eq_75242 * ebx_95 = ecx_65->ptr0004;
		Eq_75347 esi_99 = ecx_65->t0008;
		struct Eq_75242 * ecx_141 = ecx_93 - ebx_95;
		Eq_75431 edx_105 = (dwLoc48 >> 0x06) - esi_99 - (ecx_93 - ebx_95 < 0x00);
		Eq_75347 ebp_106 = ecx_65->t000C;
		if (ebp_106 == 0x00)
		{
			Mem112[ecx_65 + 0x0210 + ebp_106:byte] = 0x41;
			ecx_65->t000C = (word32) ecx_65->t000C + 1;
			runtime.(*traceBuf).varint(ebp_106, esi_99, gs, ecx_65, dwLoc48, dwLoc48 >> 0x1F);
			runtime.(*traceBuf).varint(ebp_106, esi_99, gs, ecx_65, ecx_93, dwLoc48 >> 0x06);
			edx_105.u0 = 0x00;
			ecx_141 = null;
		}
		Eq_75347 esi_155;
		ecx_65->ptr0004 = ecx_93;
		ecx_65->t0008 = dwLoc48 >> 0x06;
		if (dwArg08 >= 0x00)
			esi_155 = (word32) dwArg10.u0 + 1;
		else
			esi_155 = dwArg10;
		Eq_75347 esi_166 = esi_155;
		if ((byte) esi_155 > 0x03)
			esi_166.u0 = 0x03;
		byte bl_191 = (byte) ((word32) bArg04 | esi_166 << 0x06);
		Eq_75347 esi_180 = ecx_65->t000C;
		if (esi_180 >= 0xFDF0)
			runtime.panicindex(gs);
		else
		{
			byte * ebx_229;
			Mem192[ecx_65 + 0x0210 + esi_180:byte] = bl_191;
			ecx_65->t000C = (word32) ecx_65->t000C + 1;
			if ((byte) esi_166 != 0x03)
				ebx_229 = null;
			else
			{
				runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, null, 0x00);
				Eq_75347 ecx_221 = ecx_65->t000C;
				if (ecx_221 >= 0xFDF1)
					runtime.panicindex(gs);
				ebx_229 = (byte *) (ecx_65 + ((word32) ecx_221 + 527) / 0x01E1);
			}
			runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, ecx_141, edx_105);
			Eq_75347 eax_249 = 0x00;
			struct Eq_75351 * ecx_252 = dwArg0C;
			while (eax_249 < dwArg10)
			{
				runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, ecx_252->dw0000, ecx_252->dw0004);
				++ecx_252;
				eax_249 = (word32) eax_249.u0 + 1;
			}
			if (dwArg08 != 0x00)
			{
				if (dwArg08 > 0x00)
				{
					runtime.traceStackID(gs, dwLoc4C, 0x80);
					runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, dwLoc38, dwLoc34);
				}
			}
			else
				runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, null, 0x00);
			int32 eax_322 = ecx_65->t000C - esi_180;
			if (eax_322 > 0x34)
				runtime.throw(gs);
			else
			{
				if (ebx_229 != null)
					*ebx_229 = (byte) (eax_322 + ~0x01);
				runtime.traceReleaseBuffer(gs, dwLoc48);
				esiOut = esi_180;
				return dwArg10;
			}
		}
	}
}

// 080845B0: void runtime.traceStackID(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_75242) dwArg04, Stack Eq_4 dwArg10)
// Called from:
//      runtime.traceEvent
void runtime.traceStackID(struct Eq_2 * gs, struct Eq_75242 * dwArg04, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_38;
	Eq_4 ecx_20 = dwArg04->t0054;
	if (ecx_20 != (gs->ptr0000)->tFFFFFFFC)
	{
		if (ecx_20 == 0x00)
			eax_38.u0 = 0x00;
		else
		{
			runtime.gcallers(gs, dwArg0C);
			eax_38 = dwLoc08;
		}
	}
	else
	{
		runtime.callers(gs);
		eax_38 = dwLoc0C;
	}
	if (eax_38 > 0x00)
		--eax_38;
	if (eax_38 > 0x00)
	{
		Eq_4 edx_73 = *((word32) ecx_20 + 80);
		Eq_4 ecx_74 = *((word32) ecx_20 + 84);
		if ((byte) (SEQ(SLICE(ecx_74, word24, 8), ecx_74 == 0x00) & SEQ(SLICE(edx_73, word24, 8), edx_73 == 0x01)) != 0x00)
			--eax_38;
	}
	if (eax_38 > dwArg10)
		runtime.panicslice(gs);
	else
		runtime.(*traceStackTable).put(gs, 135591188, dwArg08, eax_38);
}

// 080846D0: void runtime.traceAcquireBuffer(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.traceEvent
void runtime.traceAcquireBuffer(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	if (*((word32) *((word32) eax_18 + 24) + 92) != 0x00)
		return;
	word32 ebp_77;
	word32 esi_78;
	word32 edi_79;
	runtime.lock(esi, gs, 0x08157548, out ebp_77, out esi_78, out edi_79);
}

// 08084760: void runtime.traceReleaseBuffer(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_75242) dwArg04)
// Called from:
//      runtime.traceEvent
void runtime.traceReleaseBuffer(struct Eq_2 * gs, struct Eq_75242 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == (struct Eq_75242 *) ~0x00)
	{
		word32 edx_61;
		word32 ebx_62;
		runtime.unlock(gs, 0x08157548, out edx_61, out ebx_62);
	}
	Eq_4 eax_29 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_30 = *((word32) eax_29 + 24);
	Eq_4 edx_31 = *((word32) ecx_30 + 0x0078);
	*((word32) ecx_30 + 0x0078) = edx_31 - 0x01;
	if (edx_31 == 0x01 && (byte) ((word32) (*((word32) eax_29 + 0x006C))) != 0x00)
		((word32) eax_29 + 8)->u0 = ~0x0521;
}

// 080847D0: void runtime.traceFlush(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_75242) dwArg04)
// Called from:
//      runtime.traceEvent
void runtime.traceFlush(struct Eq_2 * gs, struct Eq_75242 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_75782 al_28;
	Eq_4 eax_17 = g_t814F4C4;
	if (eax_17 != 0x00)
		al_28 = eax_17 != *((word32) (*((word32) (gs->ptr0000)->tFFFFFFFC + 24)) + 84);
	else
		al_28.u0 = 0x01;
	Eq_75782 al_98;
	al_98 = al_28;
	if (al_28 != 0x00)
	{
		word32 edi_171;
		word32 esi_170;
		word32 ebp_169;
		runtime.lock(esi, gs, 0x0814F4C0, out ebp_169, out esi_170, out edi_171);
		al_98 = (byte) (word32) al_28;
	}
	if (dwArg04 != null)
	{
		dwArg04->ptr0000 = null;
		if (g_ptr814F508 == null)
			g_ptr814F508 = dwArg04;
		else
			g_ptr814F50C->ptr0000 = dwArg04;
		g_ptr814F50C = dwArg04;
	}
	bool Z_110;
	struct Eq_75817 * ecx_103 = g_ptr814F504;
	if (ecx_103 != null)
	{
		g_ptr814F504 = ecx_103->ptr0000;
		Z_110 = SLICE(cond(al_98), bool, 2);
	}
	else
	{
		runtime.sysAlloc();
		if (dwLoc0C == null)
			runtime.throw(gs);
		Z_110 = SLICE(cond((byte) (word32) al_28), bool, 2);
		ecx_103 = dwLoc0C;
	}
	ecx_103->ptr0000 = null;
	ecx_103->dw000C = 0x00;
	ecx_103->dw0004 = 0x00;
	ecx_103->dw0008 = 0x00;
	if (Z_110)
	{
		word32 ebx_172;
		word32 edx_120;
		runtime.unlock(gs, 0x0814F4C0, out edx_120, out ebx_172);
	}
}

// 08084920: void runtime.(*traceBuf).varint(Register Eq_75347 ebp, Register Eq_75347 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_75242) dwArg04, Stack (ptr32 Eq_75242) dwArg08, Stack Eq_75431 dwArg0C)
// Called from:
//      runtime.traceEvent
void runtime.(*traceBuf).varint(Eq_75347 ebp, Eq_75347 esi, struct Eq_2 * gs, struct Eq_75242 * dwArg04, struct Eq_75242 * dwArg08, Eq_75431 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_75347 ecx_17 = dwArg04->t000C;
	struct Eq_75242 * edx_18 = dwArg08;
	Eq_75431 ebx_19 = dwArg0C;
	while (true)
	{
		ui24 ebx_24_8_42 = SLICE(esi, word24, 8);
		Eq_75347 esi_60 = SEQ(ebx_24_8_42, ebx_19 > 0x00) | SEQ(SLICE(ebp, word24, 8), ebx_19 == 0x00) & SEQ(ebx_24_8_42, edx_18 >= (struct Eq_75242 *) 0x80);
		byte dl_81 = (byte) edx_18;
		esi = esi_60;
		if ((byte) esi_60 == 0x00)
			break;
		if (ecx_17 >= 0xFDF0)
			runtime.panicindex(gs);
		Mem91[dwArg04 + 0x0210 + ecx_17:byte] = SLICE(edx_18 | ~0x7F, byte, 0);
		ebp = edx_18 >> 0x07;
		edx_18 = ebx_19 << 0x19 | ebp;
		ebx_19 >>= 0x07;
		ecx_17 = (word32) ecx_17 + 1;
	}
	if (ecx_17 >= 0xFDF0)
		runtime.panicindex(gs);
	else
	{
		Mem82[dwArg04 + 0x0210 + ecx_17:byte] = dl_81;
		dwArg04->t000C = (word32) ecx_17 + 1;
	}
}

// 080849C0: void runtime.(*traceStackTable).put(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_207 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.traceStackID
//      runtime.traceGoCreate
void runtime.(*traceStackTable).put(struct Eq_2 * gs, Eq_4 dwArg04, Eq_207 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
		return;
	runtime.memhash(gs, mm0, dwArg08, 0x00, dwArg0C << 0x02);
	runtime.(*traceStackTable).find(gs, dwArg04, dwArg08, dwArg0C, dwLoc18);
	if (dwLoc10 != 0x00)
		return;
	word32 edi_264;
	word32 esi_263;
	word32 ebp_262;
	runtime.lock(esi, gs, dwArg04, out ebp_262, out esi_263, out edi_264);
	runtime.(*traceStackTable).find(gs, dwArg04, dwArg08, dwArg0C, dwLoc18);
	if (dwLoc10 != 0x00)
	{
		word32 edx_265;
		word32 ebx_266;
		runtime.unlock(gs, dwArg04, out edx_265, out ebx_266);
	}
	else
	{
		*((word32) dwArg04 + 4) = (word32) *((word32) dwArg04 + 4) + 1;
		runtime.(*traceStackTable).newStack(gs, dwArg0C);
		*((word32) dwArg0C + 4) = dwLoc18;
		*((word32) dwArg0C + 8) = *((word32) dwArg04 + 4);
		*((word32) dwArg0C + 0x0C) = dwArg0C;
		if (dwArg0C > 0x80)
			runtime.panicslice(gs);
		else
		{
			Eq_207 ebp_123 = dwArg08;
			Eq_4 esi_124 = 0x00;
			while (esi_124 < dwArg0C)
			{
				Eq_4 edi_162 = *ebp_123;
				if (esi_124 >= dwArg0C)
					runtime.panicindex(gs);
				*((word32) dwArg0C + (esi_124 * 0x04 + 16)) = edi_162;
				ebp_123 = (word32) ebp_123 + 4;
				esi_124 = (word32) esi_124 + 1;
			}
			*dwArg0C = *((word32) dwArg04 + ((dwLoc18 & 0x1FFF) * 0x04 + 16));
			runtime.atomicstorep((word32) dwArg04 + 16 + (dwLoc18 & 0x1FFF) * 0x04, dwArg0C);
			word32 edx_267;
			word32 ebx_268;
			runtime.unlock(gs, dwArg04, out edx_267, out ebx_268);
		}
	}
}

// 08084B70: void runtime.(*traceStackTable).find(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_207 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg14)
// Called from:
//      runtime.(*traceStackTable).put
void runtime.(*traceStackTable).find(struct Eq_2 * gs, Eq_4 dwArg04, Eq_207 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_25 = *((word32) dwArg04 + ((dwArg14 & 0x1FFF) * 0x04 + 16));
	while (eax_25 != 0x00)
	{
		if (dwArg14 == *((word32) eax_25 + 4))
		{
			Eq_4 ebp_41 = *((word32) eax_25 + 0x0C);
			if (ebp_41 == dwArg0C)
			{
				word32 * esi_45 = (word32) eax_25 + 16;
				if (ebp_41 > 0x80)
					runtime.panicslice(gs);
				else
				{
					Eq_4 edi_55 = 0x00;
					while (edi_55 < ebp_41)
					{
						word32 edx_70 = *esi_45;
						if (edi_55 >= dwArg0C)
							runtime.panicindex(gs);
						if (edx_70 != *((word32) dwArg08 + edi_55 * 0x04))
							goto l08084BC5;
						++esi_45;
						edi_55 = (word32) edi_55 + 1;
					}
					return;
				}
			}
		}
l08084BC5:
		eax_25 = *eax_25;
	}
}

// 08084C30: void runtime.(*traceStackTable).newStack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*traceStackTable).put
void runtime.(*traceStackTable).newStack(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*traceAlloc).alloc(gs, dwArg04 + 0x08, (dwArg08 << 0x02) + 0x14);
}

// 08084C80: void runtime.(*traceAlloc).alloc(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_76151) dwArg04, Stack ui32 dwArg08)
// Called from:
//      runtime.(*traceStackTable).newStack
void runtime.(*traceAlloc).alloc(struct Eq_2 * gs, struct Eq_76151 * dwArg04, ui32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 edx_21 = dwArg08 + 0x03 & ~0x03;
	if (dwArg04->ptr0000 == null || dwArg04->dw0004 + edx_21 > 0xFFFC)
	{
		if (edx_21 > 0xFFFC)
			runtime.throw(gs);
		runtime.sysAlloc();
		if (dwLoc04 == null)
			runtime.throw(gs);
		dwLoc04->ptr0000 = dwArg04->ptr0000;
		dwArg04->ptr0000 = dwLoc04;
		dwArg04->dw0004 = 0x00;
	}
	uint32 edx_71 = dwArg04->dw0004;
	if (edx_71 >= 0xFFFC)
		runtime.panicindex(gs);
	else
		dwArg04->dw0004 = edx_21 + edx_71;
}

// 08084D70: Register (ptr32 word32) runtime.traceGomaxprocs(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut)
// Called from:
//      runtime.procresize
word32 * runtime.traceGomaxprocs(struct Eq_2 * gs, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_36;
	word32 * ebp_31 = runtime.traceEvent(gs, 0x04, 0x01, fp - 0x08, 0x01, out esi_36);
	esiOut = esi_36;
	return ebp_31;
}

// 08084DE0: void runtime.traceProcStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.acquirep
void runtime.traceProcStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_52;
	runtime.traceEvent(gs, 0x05, ~0x00, fp - 0x08, 0x01, out esi_52);
}

// 08084E60: void runtime.traceProcStop(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.entersyscall_gcwait
//      runtime.procresize
//      runtime.releasep
//      runtime.retake
void runtime.traceProcStop(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	Eq_4 ecx_23 = *((word32) eax_18 + 24);
	Eq_4 eax_31 = *((word32) ecx_23 + 92);
	*((word32) ecx_23 + 92) = dwArg04;
	word32 esi_83;
	runtime.traceEvent(gs, 0x06, ~0x00, null, 0x00, out esi_83);
	*((word32) ecx_23 + 92) = eax_31;
	Eq_4 eax_48 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_49 = *((word32) ecx_23 + 0x0078);
	*((word32) ecx_23 + 0x0078) = edx_49 - 0x01;
	if (edx_49 == 0x01 && (byte) ((word32) (*((word32) eax_48 + 0x006C))) != 0x00)
		((word32) eax_48 + 8)->u0 = ~0x0521;
}

// 08084F20: void runtime.traceGCStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
void runtime.traceGCStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_57;
	runtime.traceEvent(gs, 0x07, 0x03, fp - 0x08, 0x01, out esi_57);
	up32 eax_32 = g_dw814F4F8;
	word32 ecx_35 = g_dw814F4FC;
	g_dw814F4F8 = eax_32 + 0x01;
	g_dw814F4FC = (word32) ((bool) (eax_32 < 0x01) + ecx_35);
}

// 08084FB0: void runtime.traceGCDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
void runtime.traceGCDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 0x08, ~0x00, null, 0x00, out esi_36);
}

// 08085000: void runtime.traceGCScanStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
//      runtime.gchelper
void runtime.traceGCScanStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 0x09, ~0x00, null, 0x00, out esi_36);
}

// 08085050: void runtime.traceGCScanDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
//      runtime.gchelper
void runtime.traceGCScanDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 0x0A, ~0x00, null, 0x00, out esi_36);
}

// 080850A0: void runtime.traceGCSweepStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.deductSweepCredit
//      runtime.(*mheap).alloc_m
void runtime.traceGCSweepStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	if ((byte) (word32) *((word32) ecx_20 + 0x092C) != 0x00)
		runtime.throw(gs);
	else
	{
		*((word32) ecx_20 + 0x092C) = 0x01;
		*((word32) ecx_20 + 2352) = 0x00;
		*((word32) ecx_20 + 0x0934) = 0x00;
	}
}

// 08085120: void runtime.traceGCSweepSpan(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04)
// Called from:
//      runtime.(*mspan).sweep
void runtime.traceGCSweepSpan(struct Eq_2 * gs, ui32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	if ((byte) (word32) *((word32) ecx_20 + 0x092C) != 0x00)
	{
		if (*((word32) ecx_20 + 2352) == 0x00)
		{
			word32 esi_44;
			runtime.traceEvent(gs, 11, 0x01, null, 0x00, out esi_44);
		}
		*((word32) ecx_20 + 2352) = (word32) *((word32) ecx_20 + 2352) + dwArg04;
	}
}

// 080851C0: Register word32 runtime.traceGCSweepDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.deductSweepCredit
//      runtime.(*mheap).alloc_m
word32 runtime.traceGCSweepDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	if ((byte) (word32) *((word32) ecx_20 + 0x092C) == 0x00)
		runtime.throw(gs);
	else
	{
		if (*((word32) ecx_20 + 2352) != 0x00)
			runtime.traceEvent(gs, 0x0C, ~0x00, fp - 0x14, 0x02, out esi);
		*((word32) ecx_20 + 0x092C) = 0x00;
		return esi;
	}
}

// 080852B0: void runtime.traceGCMarkAssistStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcAssistAlloc
void runtime.traceGCMarkAssistStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 0x2B, 0x01, null, 0x00, out esi_36);
}

// 08085300: void runtime.traceGCMarkAssistDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcAssistAlloc
void runtime.traceGCMarkAssistDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 44, ~0x00, null, 0x00, out esi_36);
}

// 08085350: void runtime.traceGoCreate(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.newproc1
void runtime.traceGoCreate(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	((word32) dwArg04 + 0x007C)->u0 = 0x00;
	*((word32) dwArg04 + 0x0080) = null;
	*((word32) dwArg04 + 0x0084) = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	runtime.newobject(gs, 0x080CBDA0);
	*dwLoc20 = (word32) dwArg08 + 1;
	runtime.(*traceStackTable).put(gs, 135591188, dwLoc20, 0x01);
	word32 esi_122;
	runtime.traceEvent(gs, 0x0D, 0x02, fp - 0x10, 0x02, out esi_122);
}

// 08085450: void runtime.traceGoStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.execute
//      runtime.procresize
void runtime.traceGoStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
	Eq_4 ebx_22 = *((word32) ecx_20 + 0x007C);
	Eq_4 edx_25 = *((word32) *((word32) ecx_20 + 24) + 92);
	struct Eq_44977 * ebp_26 = *((word32) ecx_20 + 0x0080);
	*((word32) ecx_20 + 0x007C) = (word32) ebx_22 + 1;
	Mem30[ecx_20 + 0x80:word32] = ebp_26 + (ebx_22 <u 0x01);
	if (ecx_20 != *((word32) edx_25 + 0x0948))
	{
		if (*((word32) ecx_20 + 0x0084) == edx_25)
		{
			word32 esi_172;
			runtime.traceEvent(gs, 0x26, ~0x00, fp - 0x34, 0x01, out esi_172);
		}
		else
		{
			*((word32) ecx_20 + 0x0084) = edx_25;
			word32 esi_171;
			runtime.traceEvent(gs, 0x0E, ~0x00, fp - 44, 0x02, out esi_171);
		}
	}
	else
	{
		fn0808FD8A(0x00, fp - 0x1C);
		if (*((word32) edx_25 + 0x094C) >= 0x03)
			runtime.panicindex(gs);
		else
		{
			word32 esi_170;
			runtime.traceEvent(gs, 0x29, ~0x00, fp - 0x20, 0x03, out esi_170);
		}
	}
}

// 08085610: void runtime.traceGoEnd(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.goexit1
void runtime.traceGoEnd(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_48;
	runtime.traceEvent(gs, 0x0F, ~0x00, null, 0x00, out esi_48);
}

// 08085660: void runtime.traceGoSched(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gosched_m
//      runtime.procresize
void runtime.traceGoSched(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	*((word32) eax_19 + 0x0084) = *((word32) *((word32) eax_19 + 24) + 92);
	word32 esi_53;
	runtime.traceEvent(gs, 0x11, 0x01, null, 0x00, out esi_53);
}

// 080856D0: void runtime.traceGoPreempt(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gopreempt_m
void runtime.traceGoPreempt(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	*((word32) eax_18 + 0x0084) = *((word32) *((word32) eax_18 + 24) + 92);
	word32 esi_43;
	runtime.traceEvent(gs, 0x12, 0x01, null, 0x00, out esi_43);
}

// 08085740: void runtime.traceGoPark(Register (ptr32 Eq_2) gs, Stack byte bArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.park_m
void runtime.traceGoPark(struct Eq_2 * gs, byte bArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 eax_17 = (word32) bArg04;
	if (((byte) eax_17 & 0x80) != 0x00)
	{
		word32 esi_88;
		runtime.traceEvent(gs, 0x24, ~0x00, null, 0x00, out esi_88);
		eax_17 = (word32) bArg04;
	}
	word32 esi_89;
	runtime.traceEvent(gs, (byte) (eax_17 & 0x7F), dwArg08, null, 0x00, out esi_89);
}

// 080857D0: void runtime.traceGoUnpark(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.ready
//      runtime.findrunnable
//      runtime.injectglist
//      runtime.schedule
//      runtime.park_m
//      runtime.procresize
void runtime.traceGoUnpark(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_21 = *((word32) dwArg04 + 0x007C);
	Eq_4 eax_24 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	struct Eq_44977 * ebx_25 = *((word32) dwArg04 + 0x0080);
	*((word32) dwArg04 + 0x007C) = (word32) edx_21 + 1;
	Mem29[dwArg04 + 0x80:word32] = ebx_25 + (edx_21 <u 0x01);
	if (*((word32) dwArg04 + 0x0084) == eax_24)
	{
		word32 esi_115;
		runtime.traceEvent(gs, 0x27, dwArg08, fp - 0x18, 0x01, out esi_115);
	}
	else
	{
		*((word32) dwArg04 + 0x0084) = eax_24;
		word32 esi_114;
		runtime.traceEvent(gs, 0x15, dwArg08, fp - 0x10, 0x02, out esi_114);
	}
}

// 080858F0: void runtime.traceGoSysCall(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.entersyscallblock_handoff
void runtime.traceGoSysCall(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_48;
	runtime.traceEvent(gs, 0x1C, 0x01, null, 0x00, out esi_48);
}

// 08085940: void runtime.traceGoSysExit(Register Eq_51915 edx, Register word32 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.execute
//      runtime.exitsyscallfast.func1
//      runtime.exitsyscallfast_reacquired.func1
void runtime.traceGoSysExit(Eq_51915 edx, word32 ebp, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx_24_8 = SLICE(runtime.morestack_noctxt(), word24, 8);
	ui24 ebx_24_8_31 = SLICE(ebp, word24, 8);
	if ((byte) (SEQ(edx_24_8, dwArg08 != 0x00) | SEQ(ebx_24_8_31, dwArg04 != 0x00)) != 0x00)
	{
		Eq_4 edx_46 = g_t814F4DC;
		Eq_4 esi_58 = g_t814F4D8;
	}
	Eq_4 edx_102 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
	Eq_4 ebx_103 = *((word32) edx_102 + 0x007C);
	struct Eq_44977 * ebp_106 = *((word32) edx_102 + 0x0080);
	*((word32) edx_102 + 0x007C) = (word32) ebx_103 + 1;
	Mem110[edx_102 + 0x80:word32] = ebp_106 + (ebx_103 <u 0x01);
	*((word32) edx_102 + 0x0084) = *((word32) *((word32) edx_102 + 24) + 92);
	fn0808FD8A(0x00, fp - 0x18);
	word32 esi_181;
	runtime.traceEvent(gs, 0x1D, ~0x00, fp - 0x1C, 0x03, out esi_181);
}

// 08085A80: Register Eq_4 runtime.traceGoSysBlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out (ptr32 word32) ebpOut, Register out ptr32 esiOut)
// Called from:
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.entersyscall_gcwait
//      runtime.entersyscallblock_handoff
//      runtime.retake
//      runtime.exitsyscallfast_reacquired.func1
Eq_4 runtime.traceGoSysBlock(struct Eq_2 * gs, Eq_4 dwArg04, word32 & ebpOut, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	Eq_4 ecx_23 = *((word32) eax_18 + 24);
	Eq_4 eax_31 = *((word32) ecx_23 + 92);
	*((word32) ecx_23 + 92) = dwArg04;
	ptr32 esi_46;
	word32 * ebp_41 = runtime.traceEvent(gs, 0x1E, ~0x00, null, 0x00, out esi_46);
	*((word32) ecx_23 + 92) = eax_31;
	Eq_4 eax_56 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_57 = *((word32) ecx_23 + 0x0078);
	*((word32) ecx_23 + 0x0078) = edx_57 - 0x01;
	if (edx_57 == 0x01 && (byte) ((word32) (*((word32) eax_56 + 0x006C))) != 0x00)
		((word32) eax_56 + 8)->u0 = ~0x0521;
	ebpOut = ebp_41;
	esiOut = esi_46;
	return edx_57;
}

// 08085B40: Register (ptr32 word32) runtime.traceHeapAlloc(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.gcMark
//      runtime.(*mheap).alloc_m
word32 * runtime.traceHeapAlloc(struct Eq_2 * gs, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_36;
	word32 * ebp_31 = runtime.traceEvent(gs, 33, ~0x00, fp - 0x08, 0x01, out esi_36);
	esiOut = esi_36;
	return ebp_31;
}

// 08085BB0: void runtime.traceNextGC(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcSetTriggerRatio
void runtime.traceNextGC(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = g_t8158228;
	Eq_4 ecx_17 = g_t815822C;
	if ((byte) (SEQ(SLICE(ecx_17, word24, 8), ecx_17 == ~0x00) & SEQ(SLICE(eax_16, word24, 8), eax_16 == ~0x00)) != 0x00)
	{
		word32 esi_90;
		runtime.traceEvent(gs, 0x22, ~0x00, fp - 0x08, 0x01, out esi_90);
	}
	else
	{
		word32 esi_89;
		runtime.traceEvent(gs, 0x22, ~0x00, fp - 0x10, 0x01, out esi_89);
	}
}

// 08085C90: void runtime.tracebackinit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.tracebackinit(struct Eq_2 * gs)
{
	while (fp - 0x08 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_t81575E8 = g_t80E7C14;
	g_dw81575F8 = g_dw80E7C28;
	g_t81575FC = g_t80E7C40;
	g_t8157600 = g_t80E7C7C;
	g_t8157604 = g_t80E7C84;
	g_t8157630 = g_t80E7CB0;
	g_t815763C = g_t80E7CC0;
	g_t8157634 = g_t80E7CB8;
	g_t8157598 = g_t80E7B94;
	g_t81575D0 = g_t80E7BF0;
	g_t8157650 = g_t80E7CF4;
	g_t81575D8 = g_t80E7BFC;
	g_t815764C = g_t80E7CEC;
	g_t8157648 = g_t80E7CF0;
	g_t81575A0 = g_t80E7BB8;
	g_dw8157640 = g_dw80E7CD0;
	g_t81575EC = g_t80E7C18;
}

// 08085F30: void runtime.tracebackdefers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanstack
//      runtime.adjustdefers
void runtime.tracebackdefers(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD85(0x00, fp - 44);
	Eq_4 ecx_152 = *((word32) dwArg00 + 20);
	while (ecx_152 != 0x00)
	{
		Eq_4 dwLoc28_161;
		Eq_4 eax_33 = *((word32) ecx_152 + 16);
		if (eax_33 == 0x00)
			dwLoc28_161.u0 = 0x00;
		else
		{
			Eq_4 ecx_38 = *eax_33;
			runtime.findfunc(gs, ecx_38);
			dwLoc28_161 = ecx_38;
			if (dwLoc54 == 0x00)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_273;
				runtime.printhex(esi, gs, ecx_38, 0x00, out esi_273);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			*ecx_152 != 0x00;
			runtime.getArgInfo(gs, fp - 0x30, dwLoc54, 0x01, eax_33);
		}
		(*dwArg04)();
		dwLoc54 = dwArg08;
		if ((byte) (word32) (byte) dwLoc50 == 0x00)
			return;
		ecx_152 = *((word32) ecx_152 + 24);
	}
}

// 080860D0: void runtime.gentraceback(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C, Stack Eq_4 dwArg20, Stack Eq_29729 dwArg24)
// Called from:
//      runtime.scanstack
//      runtime.sigprof
//      runtime.copystack
//      runtime.traceback1
//      runtime.gcallers
//      runtime.callers.func1
void runtime.gentraceback(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C, Eq_4 dwArg20, Eq_29729 dwArg24)
{
	while (fp - 0x0140 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 dwLoc30_1971 = 0x00;
	if (dwArg14 <= 0x00 || dwArg20 == 0x00)
	{
		if (g_t81575E8 == 0x00)
			runtime.throw(gs);
		else
		{
			Eq_4 edx_52 = gs->ptr0000->tFFFFFFFC;
			if (edx_52 != dwArg10 || edx_52 != *((word32) (*((word32) edx_52 + 24)) + 84))
			{
				Eq_4 edx_111;
				Eq_4 ebx_109;
				runtime.gotraceback(dwLoc01C4);
				if (dwArg08 == ~0x00)
				{
					edx_111 = dwArg0C;
					if (dwArg0C == ~0x00)
					{
						edx_111 = *((word32) dwArg14 + 56);
						if (edx_111 != 0x00)
							ebx_109 = *((word32) dwArg14 + 60);
						else
						{
							ebx_109 = *((word32) dwArg14 + 32);
							edx_111 = *((word32) dwArg14 + 28);
						}
					}
					else
						ebx_109 = dwArg08;
				}
				else
				{
					ebx_109 = dwArg08;
					edx_111 = dwArg0C;
				}
				fn0808FD85(0x00, fp - 0x28);
				Eq_4 dwLoc24_2290 = ebx_109;
				Eq_4 dwLoc18_2291 = edx_111;
				Eq_4 esi_115 = *((word32) dwArg10 + 0x00B8);
				Eq_4 edi_153 = *((word32) dwArg10 + 20);
				while (edi_153 != 0x00 && *((word32) edi_153 + 8) == ~0x00)
					edi_153 = *((word32) edi_153 + 24);
				if (ebx_109 == 0x00)
				{
					dwLoc24_2290 = *edx_111;
					dwLoc18_2291 = (word32) edx_111 + 4;
				}
				runtime.findfunc(gs, dwLoc24_2290);
				Eq_4 dwLoc01C0_2317 = dwLoc24_2290;
				if (dwLoc01BC == 0x00)
				{
					if (dwArg20 == 0x00)
						return;
					runtime.printlock(gs);
					runtime.printstring(gs);
					word32 esi_3984;
					runtime.printhex(esi, gs, dwLoc24_2290, 0x00, out esi_3984);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				else
				{
					fn0808FD60(0x00, fp - 0x0130);
					Eq_4 dwLoc2C_2358 = dwLoc01BC;
					Eq_4 dwLoc28_2359 = dwLoc01B8;
					Eq_4 eax_1951 = 0x00;
					Eq_77543 cl_1950 = 0x00;
					Eq_4 edx_1963 = dwLoc54;
					Eq_4 ebx_1956 = dwLoc0174;
					Eq_4 esi_1957 = 0x00;
					Eq_4 edi_1958 = esi_115;
					while (true)
					{
						Eq_4 eax_1583;
						Eq_4 edi_1593;
						Eq_4 ecx_1584;
						if (eax_1951 >= dwArg18)
							break;
						if (*((word32) dwLoc30_1971 + 16) == 0x00)
						{
							eax_1583 = edi_1958;
							ecx_1584 = eax_1951;
							edi_1593 = esi_1957;
							goto l08086500;
						}
						Eq_77543 cl_593;
						cl_593 = cl_1950;
						if (dwLoc18_2291 == 0x00)
						{
							Eq_4 ebx_312;
							Eq_4 edx_311;
							Eq_4 eax_302 = dwLoc1C;
							if ((dwArg24 & 0x04) != 0x00)
							{
								if (g_t8157648 == *dwLoc30_1971)
								{
									if (dwLoc6C->ptr0018->t0000 == dwArg0C)
									{
										Eq_4 edi_331 = *((word32) *((word32) dwArg0C + 24) + 84);
										if (edi_331 != 0x00)
										{
											eax_302 = *((word32) edi_331 + 28);
											Eq_4 edx_341 = *((word32) *((word32) dwArg0C + 24) + 84);
											dwLoc1C = eax_302;
											ebx_312 = *((word32) edx_341 + 0x00B8);
											edx_311 = *((word32) edx_341 + 188);
										}
										else
										{
											edx_311 = ebx_1956;
											ebx_312 = edx_1963;
										}
									}
									else
									{
										edx_311 = ebx_1956;
										ebx_312 = edx_1963;
									}
								}
								else
								{
									edx_311 = ebx_1956;
									ebx_312 = edx_1963;
								}
							}
							else
							{
								edx_311 = ebx_1956;
								ebx_312 = edx_1963;
								eax_302 = dwLoc1C;
							}
							runtime.funcspdelta(gs, dwLoc30_1971);
							dwLoc01C0_2317 = dwLoc2C_2358;
							dwLoc01BC = dwLoc28_2359;
							dwLoc01B8 = fp - 0x0134;
							dwLoc18_2291 = (byte) dwLoc01B4.u0 + ((word32) eax_302 + 4);
							cl_593 = (byte) (word32) cl_1950;
							ebx_1956 = edx_311;
							edx_1963 = ebx_312;
						}
						Eq_77572 al_404;
						word24 nLoc01B7_2631 = SLICE(dwLoc01B8, word24, 8);
						Eq_4 eax_379 = *dwLoc30_1971;
						if (g_t81575E8 == eax_379)
							al_404.u1 = 0x01;
						else if (g_t8157604 == eax_379)
							al_404.u1 = 0x01;
						else if (g_t81575FC == eax_379)
							al_404.u1 = 0x01;
						else if (g_t8157600 == eax_379)
							al_404.u1 = 0x01;
						else if (g_t8157630 == eax_379)
							al_404.u1 = 0x01;
						else
						{
							Eq_4 ebx_395 = g_t81575B8;
							if (ebx_395 != 0x00)
								al_404 = eax_379 == ebx_395;
							else
								al_404.u1 = 0x00;
						}
						Eq_4 ebx_525;
						Eq_4 eax_444;
						if (al_404 != 0x00)
						{
							dwLoc20.u0 = 0x00;
							eax_444.u0 = 0x00;
							ebx_525.u0 = 0x00;
						}
						else
						{
							if (dwLoc20 == 0x00)
								dwLoc20 = *((byte) dwLoc18_2291.u0 - 4);
							runtime.findfunc(gs, dwLoc20);
							eax_444 = dwLoc01BC;
							if (dwLoc01C0_2317 == 0x00 && dwArg1C != 0x00)
							{
								runtime.funcname(gs, dwLoc30_1971, dwLoc2C_2358);
								runtime.printlock(gs);
								runtime.printstring(gs);
								runtime.printstring(gs);
								runtime.printstring(gs);
								word32 esi_3994;
								runtime.printhex(esi, gs, dwLoc20, 0x00, out esi_3994);
								runtime.printstring(gs);
								runtime.printunlock(gs);
								runtime.throw(gs);
							}
							ebx_525 = dwLoc01C0_2317;
							cl_593 = (byte) (word32) cl_1950;
						}
						word32 esi_554;
						if (dwArg1C == 0x00)
						{
							word32 esi_546 = (word32) bLoc01A5;
							esi_554 = esi_546;
							if ((byte) esi_546 == 0x00)
								goto l080864B3;
						}
						runtime.getArgInfo(gs, fp - 0x30, dwLoc30_1971, dwArg1C != 0x00, dwArg10);
						dwLoc10 = dwLoc18_2291;
						dwLoc01C0_2317 = dwLoc30_1971;
						dwLoc01BC = dwLoc2C_2358;
						dwLoc01B4.u0 = 0x00;
						dwLoc0C = dwLoc01B0;
						cl_593 = (byte) (word32) cl_1950;
						esi_554 = (word32) bLoc01A5;
						dwLoc01B8 = SEQ(nLoc01B7_2631, dwArg1C != 0x00);
l080864B3:
						byte bLoc01BC_2645 = (byte) dwLoc01BC;
						Eq_4 edi_603 = edi_1958;
						if (cl_593 != 0x00 && (edi_1958 == 0x00 || dwLoc1C != *((word32) edi_1958 + 8)))
							;
						while (true)
						{
							bool Z_641;
							if (edi_603 == 0x00)
								break;
							Eq_4 ecx_626 = *((word32) edi_603 + 8);
							if (dwLoc1C != ecx_626 && ecx_626 != ~0x00)
							{
								Z_641 = SLICE(cond(dwArg1C), bool, 2);
								goto l080862B8;
							}
							edi_603 = *((word32) edi_603 + 24);
						}
						Z_641 = SLICE(cond(dwArg1C), bool, 2);
l080862B8:
						bool Z_680;
						if (!Z_641)
							Z_680 = SLICE(cond(dwArg14), bool, 2);
						else
						{
							(*dwArg1C)();
							dwLoc01C0_2317 = dwArg20;
							if ((byte) (word32) bLoc01BC_2645 == 0x00)
								return;
							Z_680 = SLICE(cond(dwArg14), bool, 2);
							esi_554 = (word32) bLoc01A5;
						}
						Eq_4 eax_1492;
						Eq_4 edi_1437;
						Eq_4 ebx_1533;
						Eq_4 ebx_686;
						Eq_4 eax_685;
						if (!Z_680)
						{
							ebx_686 = dwArg10;
							if (dwArg10 == 0x00)
							{
								eax_685 = eax_1951;
								if (eax_1951 >= 0x00100000)
									runtime.panicindex(gs);
								*((word32) dwArg14 + eax_1951 * 0x04) = dwLoc28_2359;
								goto l080862FC;
							}
							Eq_4 esi_691 = dwLoc28_2359;
							if ((eax_1951 > 0x00 || (dwArg24 & 0x02) == 0x00) && (dwLoc28_2359 > *dwLoc30_1971 && (byte) ((word32) cl_1950) == 0x00))
								esi_691 = dwLoc28_2359 - 0x01;
							runtime.funcdata(gs, dwLoc30_1971, 0x02);
							dwLoc01C0_2317 = dwLoc2C_2358;
							dwLoc01BC.u0 = 0x02;
							if (dwLoc01B8 == 0x00)
							{
								ebx_1533 = dwArg10 - 0x01;
								edi_1437 = esi_1957;
								eax_1492 = eax_1951;
								goto l0808630B;
							}
							runtime.pcdatavalue(gs, dwLoc30_1971, 0x01);
							dwLoc01C0_2317 = dwLoc2C_2358;
							dwLoc01BC.u0 = 0x01;
							dwLoc01B8 = esi_691;
							dwLoc01B4 = fp - 0x0134;
							Eq_4 eax_763 = dwLoc01B0;
							Eq_4 edx_765 = dwArg10;
							word32 ebx_766 = 0x00;
							while (eax_763 >= 0x00 && edx_765 > 0x00)
							{
								if (eax_763 >= 0x00100000)
									runtime.panicindex(gs);
								--edx_765;
								++ebx_766;
								eax_763 = *((byte) dwLoc01B8.u0 + eax_763 * 0x10);
							}
							dwLoc01B4 = fp - 0x0134;
							if (edx_765 > 0x00)
							{
								ebx_1533 = edx_765 - 0x01;
								edi_1437 = esi_1957;
								eax_1492 = eax_1951;
								goto l0808630B;
							}
							if (eax_1951 >= 0x00100000)
								runtime.panicindex(gs);
							*((word32) dwArg14 + eax_1951 * 0x04) = dwLoc28_2359;
							if ((word32) eax_1951 + 1 < dwArg18)
							{
								Eq_4 ebx_812 = ebx_766 + g_dw80E7CD0;
								eax_685 = (word32) eax_1951 + 1;
								if (eax_1951 >= 0x000FFFFF)
									runtime.panicindex(gs);
								*((word32) dwArg14 + (eax_1951 * 0x04 + 4)) = ebx_812;
							}
							else
								eax_685 = eax_1951;
							esi_554 = (word32) bLoc01A5;
							ebx_686 = edx_765;
						}
						else
						{
							eax_685 = eax_1951;
							ebx_686 = dwArg10;
						}
l080862FC:
						word24 nLoc01B7_2894 = SLICE(dwLoc01B8, word24, 8);
						byte bLoc01B4_2839 = (byte) dwLoc01B4;
						if ((byte) esi_554 == 0x00)
						{
							edi_1437 = esi_1957;
							dwLoc01B4 = dwLoc01B4_2923;
							goto l0808630A;
						}
						Eq_4 eax_1427;
						dwLoc01B4_2923 = dwLoc01B4;
						if ((dwArg24 & 0x01) != 0x00)
						{
l080867B6:
							Eq_4 esi_928 = dwLoc28_2359;
							if ((eax_685 > 0x00 || (dwArg24 & 0x02) == 0x00) && (dwLoc28_2359 > *dwLoc30_1971 && (byte) ((word32) cl_1950) == 0x00))
								esi_928 = dwLoc28_2359 - 0x01;
							Eq_4 dwLoc01B4_2945;
							Eq_4 edx_1015;
							runtime.funcline(gs);
							runtime.funcdata(gs, dwLoc30_1971, 0x02);
							dwLoc01BC.u0 = 0x02;
							if (dwLoc01B8 == 0x00)
							{
								edx_1015 = dwLoc01B0;
								dwLoc01B4_2945 = dwLoc01B4_2923;
							}
							else
							{
								runtime.pcdatavalue(gs, dwLoc30_1971, 0x01);
								dwLoc01BC.u0 = 0x01;
								dwLoc01B8 = esi_928;
								dwLoc01B4_2945.u0 = 0x00;
								Eq_4 eax_1005 = dwLoc01B0;
								Eq_4 ebx_1008 = dwLoc01B0;
								while (eax_1005 != ~0x00)
								{
									if (eax_1005 >= 0x00100000)
										runtime.panicindex(gs);
									int32 eax_1023 = eax_1005 << 0x04;
									runtime.funcnameFromNameoff(gs, dwLoc30_1971, dwLoc2C_2358, (byte) dwLoc01B8.u0 + 0x0C + eax_1023);
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printstring(gs);
									runtime.printunlock(gs);
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printstring(gs);
									runtime.printstring(gs);
									runtime.printint(ebx, gs, ebx_1008);
									runtime.printstring(gs);
									runtime.printunlock(gs);
									Eq_4 edx_1113 = (byte) dwLoc01B8.u0 + 4 + eax_1023;
									runtime.funcfile(gs, dwLoc30_1971, dwLoc2C_2358, edx_1113);
									dwLoc01BC = edx_1113;
									eax_1005 = *((byte) dwLoc01B8.u0 + eax_1023);
									ebx_1008 = (byte) dwLoc01B8.u0 + 8 + eax_1023;
								}
								edx_1015 = ebx_1008;
							}
							runtime.funcname(gs, dwLoc30_1971, dwLoc2C_2358);
							byte bLoc01B4_3005 = (byte) dwLoc01B4_2945;
							if (dwLoc01B8 == 0x0F)
							{
								word32 esi_3995;
								word32 edi_3996;
								runtime.eqstring(dwLoc01BC, dwLoc01B8, 0x080E23CE, out esi_3995, out edi_3996);
								dwLoc01BC.u0 = 0x080E23CE;
								dwLoc01B8.u0 = 0x0F;
								dwLoc01B4_3696 = dwLoc01B4_2945;
							}
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							uint32 ecx_1214;
							for (ecx_1214 = 0x00; ecx_1214 < dwLoc0C >> 0x02; ++ecx_1214)
							{
								if (ecx_1214 >= 0x0A)
								{
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printunlock(gs);
									break;
								}
								dwLoc0180 = ecx_1214;
								if (ecx_1214 != 0x00)
								{
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printunlock(gs);
								}
								Eq_4 edx_1467 = *((word32) dwLoc10 + ecx_1214 * 0x04);
								runtime.printlock(gs);
								word32 esi_3997;
								runtime.printhex(esi, gs, edx_1467, 0x00, out esi_3997);
								runtime.printunlock(gs);
							}
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printint(ebx, gs, edx_1015);
							runtime.printunlock(gs);
							Eq_4 edx_1300 = *dwLoc30_1971;
							if (dwLoc28_2359 > edx_1300)
							{
								runtime.printlock(gs);
								runtime.printstring(gs);
								word32 esi_3998;
								runtime.printhex(esi, gs, dwLoc28_2359 - edx_1300, 0x00, out esi_3998);
								runtime.printunlock(gs);
							}
							struct Eq_77656 * edx_1334 = dwLoc6C->ptr0018;
							if (edx_1334->dw006C > 0x00 && edx_1334->t0054 == dwArg0C || dwLoc0184 >= 0x02)
							{
								runtime.printlock(gs);
								runtime.printstring(gs);
								word32 esi_3999;
								runtime.printhex(esi, gs, dwLoc18_2291, 0x00, out esi_3999);
								runtime.printstring(gs);
								word32 esi_4000;
								runtime.printhex(esi, gs, dwLoc1C, 0x00, out esi_4000);
								runtime.printstring(gs);
								word32 esi_4001;
								runtime.printhex(esi, gs, dwLoc28_2359, 0x00, out esi_4001);
								runtime.printunlock(gs);
							}
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							dwLoc01C0_2317.u0 = 0x01;
							eax_1427 = (word32) esi_1957 + 1;
							dwLoc01B4 = dwLoc01B4_3696;
							goto l08086B06;
						}
						Eq_77984 bLoc01B8_2828 = esi_1957 == 0x00;
						runtime.showframe(gs, dwLoc30_1971, dwArg0C, bLoc01B8_2828);
						dwLoc01C0_2317 = dwLoc2C_2358;
						dwLoc01BC = dwArg0C;
						dwLoc01B8 = SEQ(nLoc01B7_2894, bLoc01B8_2828);
						if ((byte) (word32) bLoc01B4_2839 != 0x00)
							goto l080867B6;
						eax_1427 = esi_1957;
						dwLoc01B4 = dwLoc01B4_2923;
l08086B06:
						edi_1437 = eax_1427;
l0808630A:
						ebx_1533 = ebx_686;
						eax_1492 = (word32) eax_685 + 1;
l0808630B:
						Eq_4 esi_1511;
						word24 nLoc01BF_3726 = SLICE(dwLoc01C0_2317, word24, 8);
						if (g_t81575A0 == *dwLoc30_1971 && ebx_1956 > 0x00)
						{
							esi_1511 = ebx_1956 - 0x01;
							if (ebx_1956 - 0x01 >= ebx_1956)
								runtime.panicindex(gs);
							Eq_4 ecx_1532 = (edx_1963 - 0x04)[ebx_1956];
							if (ebx_1533 == 0x00 && dwArg1C == 0x00)
							{
								Eq_4 dl_1552 = (byte) (word32) bLoc01A5;
								runtime.tracebackCgoContext(gs, dwArg14, dl_1552);
								dwLoc01BC = ecx_1532;
								dwLoc01B8 = eax_1492;
								dwLoc01B4 = dwArg18;
								eax_1492 = dwLoc01B0;
								esi_1511 = ebx_1956 - 0x01;
								dwLoc01C0_2317 = SEQ(nLoc01BF_3726, dl_1552);
							}
						}
						else
							esi_1511 = ebx_1956;
						edi_1593 = edi_1437;
						Eq_4 ebp_1577 = *dwLoc30_1971;
						Eq_4 ecx_1578 = g_t815763C;
						if (ebx_525 == 0x00)
						{
							eax_1583 = edi_603;
							ecx_1584 = eax_1492;
							goto l08086500;
						}
						dwLoc30_1971 = ebx_525;
						dwLoc2C_2358 = eax_444;
						dwLoc28_2359 = dwLoc20;
						dwLoc20.u0 = 0x00;
						dwLoc1C = dwLoc18_2291;
						dwLoc18_2291.u0 = 0x00;
						cl_1950 = ecx_1578 == ebp_1577;
						eax_1951 = eax_1492;
						ebx_1956 = esi_1511;
						esi_1957 = edi_1437;
						edi_1958 = edi_603;
					}
					ecx_1584 = eax_1951;
					eax_1583 = edi_1958;
					edi_1593 = esi_1957;
l08086500:
					if ((byte) (word32) bLoc01A5 == 0x00)
						edi_1593 = ecx_1584;
					bool Z_1599 = SLICE(cond(dwArg1C), bool, 2);
					if (dwArg1C != 0x00)
					{
						if (edi_1593 < dwArg18)
						{
							if (eax_1583 != 0x00)
							{
								Eq_4 ebx_1796 = *((word32) dwArg0C + 80);
								Eq_4 ebp_1798 = *((word32) eax_1583 + 8);
								Eq_4 eax_1800 = *((word32) eax_1583 + 0x0C);
								runtime.printlock(gs);
								runtime.printstring(gs);
								runtime.printint(ebx, gs, ebx_1796);
								runtime.printstring(gs);
								word32 esi_3986;
								runtime.printhex(esi, gs, ebp_1798, 0x00, out esi_3986);
								runtime.printstring(gs);
								word32 esi_3987;
								runtime.printhex(esi, gs, eax_1800, 0x00, out esi_3987);
								runtime.printstring(gs);
								runtime.printunlock(gs);
								Eq_4 eax_1861 = *((word32) dwArg0C + 20);
								while (eax_1861 != 0x00)
								{
									Eq_4 ecx_1868 = *((word32) eax_1861 + 8);
									Eq_4 edx_1870 = *((word32) eax_1861 + 0x0C);
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printpointer(gs);
									runtime.printstring(gs);
									word32 esi_3988;
									runtime.printhex(esi, gs, ecx_1868, 0x00, out esi_3988);
									runtime.printstring(gs);
									word32 esi_3989;
									runtime.printhex(esi, gs, edx_1870, 0x00, out esi_3989);
									runtime.printstring(gs);
									runtime.printunlock(gs);
									eax_1861 = *((word32) eax_1861 + 24);
								}
								runtime.throw(gs);
							}
							Z_1599 = SLICE(cond(dwArg1C), bool, 2);
						}
						else
							Z_1599 = SLICE(cond(dwArg1C), bool, 2);
					}
					if (Z_1599 || edi_1593 >= dwArg18)
						return;
					Eq_4 ebx_1628 = *((word32) dwArg0C + 64);
					if (dwLoc1C == ebx_1628)
						return;
					Eq_4 edx_1636 = *((word32) dwArg0C + 80);
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(ebx, gs, edx_1636);
					runtime.printstring(gs);
					word32 esi_3990;
					runtime.printhex(esi, gs, dwLoc1C, 0x00, out esi_3990);
					runtime.printstring(gs);
					word32 esi_3991;
					runtime.printhex(esi, gs, ebx_1628, 0x00, out esi_3991);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					Eq_4 ecx_1702 = *dwArg0C;
					Eq_4 eax_1704 = *((word32) dwArg0C + 4);
					runtime.printlock(gs);
					runtime.printstring(gs);
					word32 esi_3992;
					runtime.printhex(esi, gs, ecx_1702, 0x00, out esi_3992);
					runtime.printstring(gs);
					word32 esi_3993;
					runtime.printhex(esi, gs, eax_1704, 0x00, out esi_3993);
					runtime.printstring(gs);
					runtime.printint(ebx, gs, edi_1593);
					runtime.printstring(gs);
					runtime.printint(ebx, gs, dwArg18);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
			}
			else
				runtime.throw(gs);
		}
	}
	else
		runtime.throw(gs);
}

// 08087730: void runtime.getArgInfo(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_77416) dwArg04, Stack Eq_4 dwArg08, Stack Eq_77418 bArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.tracebackdefers
//      runtime.gentraceback
void runtime.getArgInfo(struct Eq_2 * gs, struct Eq_77416 * dwArg04, Eq_4 dwArg08, Eq_77418 bArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 8);
	if ((byte) (word32) bArg10 == 0x00 || ecx_18 != 0x80000000)
		return;
	runtime.funcname(gs, dwArg08, dwArg0C);
	if (dwLoc14 == 0x14)
	{
		word32 edi_48;
		word32 esi_49;
		runtime.eqstring(dwLoc18, dwLoc14, 135147931, out esi_49, out edi_48);
		if ((byte) (word32) bLoc10 != 0x00)
			goto l080877C8;
	}
	if (dwLoc14 != 0x17)
		return;
	word32 edi_75;
	word32 esi_76;
	runtime.eqstring(dwLoc18, dwLoc14, 135150179, out esi_76, out edi_75);
	if ((byte) (word32) bLoc10 == 0x00)
		return;
l080877C8:
	Eq_4 eax_92 = dwArg14;
	if (dwArg14 == 0x00)
		eax_92 = *dwArg04->ptr0014;
	if (*eax_92 == *dwArg08)
		return;
	runtime.funcname(gs, dwArg08, dwArg0C);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 080878C0: void runtime.tracebackCgoContext(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gentraceback
void runtime.tracebackCgoContext(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 188 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD70(0x00, fp - 288);
	runtime.cgoContextPCs(gs, 0x20);
	fn0808FD89(0x00, fp - 0x20);
	fn08090160(fp - 0x0128, fp - 0xA8);
	int32 eax_209 = 0x00;
	word32 * ecx_206 = fp - 0xAC;
	Eq_4 ebx_203 = dwArg04;
	ui32 edx_195 = 0x00;
	while (true)
	{
		byte dl_71 = (byte) edx_195;
		if (eax_209 >= 0x20)
			break;
		Eq_4 ebp_63 = *ecx_206;
		if (ebp_63 == 0x00 || ebx_203 >= dwArg08)
			break;
		if (dwLoc08 != null)
		{
			if (ebx_203 >= 0x00100000)
				runtime.panicindex(gs);
			dwLoc08[ebx_203] = ebp_63;
		}
		if ((byte) (word32) bLoc04 != 0x00)
		{
			Eq_4 eax_175;
			<anonymous> * ebp_123 = g_ptr8144FBC;
			if (ebp_123 != null)
			{
				runtime.printOneCgoTraceback(gs, ebp_63, dwArg08 - ebx_203, fp - 0x28);
				eax_175 = fp - 0x0125 + ebx_203;
			}
			else
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_318;
				runtime.printhex(esi, gs, ebp_63, 0x00, out esi_318);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				eax_175 = ebx_203;
			}
			edx_195 = (word32) (ebp_123 != null) | (word32) dl_71;
			ebx_203 = eax_175;
		}
		++ecx_206;
		++eax_209;
		ebx_203 = (word32) ebx_203 + 1;
	}
	if (dl_71 != 0x00)
		runtime.callCgoSymbolizer(gs);
}

// 08087AD0: void runtime.printcreatedby(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.traceback1
//      runtime.tracebackothers
void runtime.printcreatedby(struct Eq_2 * gs, Eq_4 dwArg04)
{
	byte bLoc2C = (byte) dwLoc2C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = *((word32) dwArg04 + 0x00A8);
	runtime.findfunc(gs, ecx_19);
	if (dwLoc38 != 0x00)
	{
		runtime.showframe(gs, dwLoc38, dwArg04, 0x00);
		if ((byte) (word32) bLoc2C != 0x00)
		{
			Eq_4 ecx_48 = *((word32) dwArg04 + 84);
			Eq_4 eax_49 = *((word32) dwArg04 + 80);
			if ((byte) (SEQ(SLICE(ecx_48, word24, 8), ecx_48 != 0x00) | SEQ(SLICE(eax_49, word24, 8), eax_49 != 0x01)) != 0x00)
			{
				runtime.funcname(gs, dwLoc38, dwLoc34);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				ecx_19 <= *dwLoc38;
				runtime.funcline(gs);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printint(ebx, gs, dwLoc28);
				runtime.printunlock(gs);
				Eq_4 eax_172 = *dwLoc38;
				if (ecx_19 > eax_172)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					word32 esi_311;
					runtime.printhex(esi, gs, ecx_19 - eax_172, 0x00, out esi_311);
					runtime.printunlock(gs);
				}
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
			}
		}
	}
}

// 08087CF0: void runtime.traceback(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.tracealloc
//      runtime.dopanic_m
//      runtime.sighandler
//      runtime.newstack
//      runtime.tracebackothers
//      runtime.tracealloc.func1
//      runtime.tracefree.func1
void runtime.traceback(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.traceback1(gs, dwArg0C, dwArg10, 0x00);
}

// 08087D40: void runtime.tracebacktrap(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sighandler
void runtime.tracebacktrap(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.traceback1(gs, dwArg0C, dwArg10, 0x02);
}

// 08087D90: void runtime.traceback1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack ui32 dwArg14)
// Called from:
//      runtime.traceback
//      runtime.tracebacktrap
void runtime.traceback1(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, ui32 dwArg14)
{
	while (fp - 44 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_23;
	union Eq_4 * esp_17 = fp - 0xAC;
	if ((byte) (word32) g_b8157571 != 0x00)
	{
		eax_23 = dwArg10;
		Eq_4 ecx_25 = *((word32) dwArg10 + 24);
		if (ecx_25 != 0x00 && (*((word32) ecx_25 + 0x00A0) > 0x00 && *((word32) dwArg10 + 56) != 0x00))
		{
			Eq_4 edx_36 = *((word32) ecx_25 + 0x00A8);
			if (edx_36 != 0x00 && *edx_36 != 0x00)
			{
				runtime/internal/atomic.Store((word32) ecx_25 + 0x00A4, 0x01);
				fn08090160(*((word32) *((word32) dwArg10 + 24) + 0x00A8), fp - 0x80);
				**((word32) *((word32) dwArg10 + 24) + 0x00A8) = 0x00;
				runtime/internal/atomic.Store((word32) *((word32) dwArg10 + 24) + 0x00A4, 0x00);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.printCgoTraceback(gs, stackArg0, fp - 0x84);
				dwLocA8 = 0x01;
				esp_17 = fp - 0xB0;
				eax_23 = dwArg0C;
			}
		}
	}
	else
		eax_23 = dwArg10;
	ui32 ebx_103;
	Eq_4 edx_101;
	*esp_17 = (union Eq_4 *) eax_23;
	runtime.readgstatus(*esp_17);
	if ((dwLocA8 & ~0x1000) == 0x03)
	{
		edx_101 = *((word32) dwArg10 + 56);
		ebx_103 = dwArg14 & ~0x02;
	}
	else
	{
		edx_101 = dwArg08;
		ebx_103 = dwArg14;
	}
	runtime.gentraceback(gs, edx_101, dwArg0C, dwArg0C, dwArg10, 0x00, 100, 0x00, 0x00);
	if (dwLoc84 == 0x00 && (ebx_103 & 0x01) == 0x00)
		runtime.gentraceback(gs, edx_101, dwArg0C, dwArg0C, dwArg10, 0x00, 100, 0x00, 0x00);
	if (dwLoc84 == 100)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printcreatedby(gs, dwArg10);
}

// 08087FF0: void runtime.callers(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.Caller
//      runtime.Callers
//      runtime.mProf_Malloc
//      runtime.saveblockevent
//      runtime.mcommoninit
//      runtime.traceStackID
void runtime.callers(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.getcallerpc();
	fn0808FD87(0x00, fp - 0x24);
	word32 ebp_95;
	word32 edi_96;
	runtime.systemstack(gs, fp - 0x28, out ebp_95, out edi_96);
}

// 080880B0: void runtime.gcallers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg10)
// Called from:
//      runtime.saveblockevent
//      runtime.traceStackID
void runtime.gcallers(struct Eq_2 * gs, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg10 <= 0x00)
		runtime.panicindex(gs);
	else
		runtime.gentraceback(gs, ~0x00, 0x00, dwArg04, dwArg08, dwArg0C, dwArg10, 0x00, 0x00);
}

// 08088140: void runtime.showframe(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Stack Eq_77984 bArg10)
// Called from:
//      runtime.gentraceback
//      runtime.printcreatedby
void runtime.showframe(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C, Eq_77984 bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	if (*((word32) eax_19 + 0x006C) > 0x00 && (dwArg0C != 0x00 && (*((word32) eax_19 + 84) == dwArg0C || *((word32) eax_19 + 88) == dwArg0C)))
		return;
	runtime.gotraceback(dwLoc24);
	runtime.funcname(gs, dwArg04, dwArg08);
	if (dwLoc14 == 0x0F)
	{
		word32 edi_66;
		word32 esi_67;
		runtime.eqstring(dwLoc18, dwLoc14, 0x080E23CE, out esi_67, out edi_66);
		if ((byte) (word32) bLoc10 != 0x00 && (byte) ((word32) bArg10) == 0x00)
			return;
	}
	if (dwLoc20 <= 0x01)
	{
		uip32 edx_115;
		if (dwArg04 == 0x00)
			edx_115 = 0x00;
		else
		{
			runtime.contains(gs);
			edx_115 = (word32) bLoc10;
		}
		if ((byte) edx_115 != 0x00)
		{
			uip32 edx_150;
			if (dwLoc14 < 0x08)
				edx_150 = 0x00;
			else
			{
				word32 edi_140;
				word32 esi_141;
				runtime.eqstring(dwLoc18, 0x08, 0x080E14E5, out esi_141, out edi_140);
				edx_150 = (word32) bLoc10;
			}
			if ((byte) edx_150 != 0x00 && dwLoc14 > 0x08)
			{
				uip32 ecx_388;
				if (*dwLoc18 == 0x746E7572)
				{
					Eq_4 ecx_178 = *((word32) dwLoc18 + 4);
					ecx_388 = SEQ(SLICE(ecx_178, word24, 8), ecx_178 == 778399081);
				}
				else
					ecx_388 = 0x00;
				if ((byte) ecx_388 != 0x00)
					(byte) (word32) *((word32) dwLoc18 + 8) < 0x41;
			}
		}
	}
}

// 08088300: Register Eq_4 runtime.goroutineheader(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.dopanic_m
//      runtime.sighandler
//      runtime.tracebackothers
Eq_4 runtime.goroutineheader(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_31;
	runtime.readgstatus(dwArg04);
	if ((dwLoc30 & ~0x1000) < 0x09)
		ebx_31 = g_a81442C0[dwLoc30 & ~0x1000];
	else
		ebx_31.u0 = 135138883;
	Eq_4 esi_46;
	bool Z_39 = SLICE(cond((dwLoc30 & ~0x1000) - 0x04), bool, 2);
	if ((dwLoc30 & ~0x1000) == 0x04)
	{
		esi_46 = *((word32) dwArg04 + 96);
		if (*((word32) dwArg04 + 100) != 0x00)
			Z_39 = SLICE(cond((dwLoc30 & ~0x1000) - 0x04), bool, 2);
		else
		{
			Z_39 = SLICE(cond((dwLoc30 & ~0x1000) - 0x04), bool, 2);
			esi_46 = ebx_31;
		}
	}
	else
		esi_46 = ebx_31;
	int32 edx_125;
	Eq_4 eax_126;
	if (!Z_39 || (dwLoc30 & ~0x1000) == 0x03)
	{
		Eq_4 eax_78 = *((word32) dwArg04 + 92);
		Eq_4 edx_79 = *((word32) dwArg04 + 88);
		if ((byte) (SEQ(SLICE(eax_78, word24, 8), eax_78 != 0x00) | SEQ(SLICE(edx_79, word24, 8), edx_79 != 0x00)) == 0x00)
		{
			eax_126.u0 = 0x00;
			edx_125 = 0x00;
		}
		else
		{
			runtime.nanotime();
			Eq_4 ebx_110 = *((word32) dwArg04 + 92);
			runtime.int64div(SLICE(ebx_110, word24, 8), edi, gs, (word32) (SEQ(dwLoc30, dwArg04) - SEQ(ebx_110, *((word32) dwArg04 + 88))), 4165425152);
			edx_125 = dwLoc20;
			eax_126 = dwLoc24;
		}
	}
	else
	{
		eax_126.u0 = 0x00;
		edx_125 = 0x00;
	}
	Eq_4 ebx_140 = *((word32) dwArg04 + 80);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx, gs, ebx_140);
	runtime.printstring(gs);
	runtime.printstring(gs);
	ui24 ebx_24_8_215 = SLICE(ebx_140, word24, 8);
	ui24 ecx_24_8_210 = SLICE(runtime.printunlock(gs), word24, 8);
	if ((dwLoc30 & 0x1000) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		ecx_24_8_210 = SLICE(runtime.printunlock(gs), word24, 8);
	}
	if ((byte) (SEQ(ecx_24_8_210, edx_125 == 0x00) & SEQ(ebx_24_8_215, eax_126 >= 0x01) | SEQ(ebx_24_8_215, edx_125 > 0x00)) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx, gs, eax_126);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	if (*((word32) dwArg04 + 0x0088) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	return esi_46;
}

// 08088590: Register Eq_4 runtime.tracebackothers(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.tracegc
//      runtime.dopanic_m
//      runtime.sighandler
Eq_4 runtime.tracebackothers(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gotraceback(dwLoc30);
	Eq_4 esp_21 = <invalid>;
	Eq_4 eax_27 = gs->ptr0000->tFFFFFFFC;
	*((word32) esp_21 + 36) = eax_27;
	Eq_4 ecx_29 = *((word32) eax_27 + 24);
	*((word32) esp_21 + 16) = *esp_21;
	Eq_4 ecx_32 = *((word32) ecx_29 + 84);
	if (ecx_32 != 0x00 && *((word32) esp_21 + 48) != ecx_32)
	{
		*((word32) esp_21 + 28) = ecx_32;
		runtime.printlock(gs);
		esp_21->u0 = 0x080E0D9C;
		((word32) esp_21 + 4)->u0 = 0x01;
		runtime.printstring(gs);
		runtime.printunlock(gs);
		*esp_21 = *((word32) esp_21 + 28);
		esi = runtime.goroutineheader(gs, *esp_21);
		esp_21->u0 = ~0x00;
		((word32) esp_21 + 4)->u0 = ~0x00;
		((word32) esp_21 + 8)->u0 = 0x00;
		*((word32) esp_21 + 0x0C) = *((word32) esp_21 + 28);
		runtime.traceback(gs);
	}
	esp_21->u0 = 0x08157590;
	word32 ebp_100;
	word32 edi_101;
	Eq_4 esi_102;
	runtime.lock(esi, gs, *esp_21, out ebp_100, out esi_102, out edi_101);
	Eq_4 eax_107 = g_t814510C;
	*((word32) esp_21 + 24) = eax_107;
	Eq_4 ecx_109 = g_t8145108;
	Eq_4 edx_110 = 0x00;
	while (edx_110 < eax_107)
	{
		Eq_4 ebx_134 = *ecx_109;
		if (dwArg04 != ebx_134)
		{
			esi_102 = dwLoc08;
			if (ebx_134 == *((word32) (*((word32) dwLoc08 + 24)) + 84))
				goto l08088602;
			runtime.readgstatus(ebx_134);
			Eq_4 esp_148 = <invalid>;
			if (*((word32) esp_148 + 4) == 0x06)
			{
l08088643:
				eax_107 = *((word32) esp_148 + 24);
				ecx_109 = *((word32) esp_148 + 40);
				edx_110 = *((word32) esp_148 + 20);
				goto l08088602;
			}
			Eq_79357 cl_181;
			Eq_4 ecx_157 = *((word32) *((word32) esp_148 + 32) + 0x00AC);
			if (g_t8157634 == ecx_157 && (byte) ((word32) g_b8157569) == 0x00)
				cl_181.u0 = 0x01;
			else if (g_t8157598 == ecx_157)
				cl_181.u0 = 0x01;
			else if (g_t81575D0 == ecx_157)
				cl_181.u0 = 0x01;
			else if (g_t8157650 == ecx_157)
				cl_181.u0 = 0x01;
			else
				cl_181 = g_t81575D8 == ecx_157;
			if (cl_181 != 0x00 && *((word32) esp_148 + 16) < 0x02)
				goto l08088643;
			runtime.printlock(gs);
			esp_148->u0 = 0x080E0D9C;
			((word32) esp_148 + 4)->u0 = 0x01;
			runtime.printstring(gs);
			runtime.printunlock(gs);
			*esp_148 = *((word32) esp_148 + 32);
			esi_102 = runtime.goroutineheader(gs, *esp_148);
			Eq_4 eax_240 = *((word32) esp_148 + 32);
			if (*((word32) eax_240 + 24) != *((word32) (*((word32) esp_148 + 36)) + 24))
			{
				*esp_148 = eax_240;
				runtime.readgstatus(*esp_148);
				esp_148.u0 = <invalid>;
				if ((*((byte) esp_148.u0 + 4) & ~0x1000) == 0x02)
				{
					runtime.printlock(gs);
					esp_148.u0->u0 = 135165165;
					((byte) esp_148.u0 + 4)->u0 = 0x36;
					runtime.printstring(gs);
					runtime.printunlock(gs);
					*esp_148.u0 = *((byte) esp_148.u0 + 32);
					runtime.printcreatedby(gs, *esp_148.u0);
l080886F6:
					eax_107 = *((byte) esp_148.u0 + 24);
					ecx_109 = *((byte) esp_148.u0 + 40);
					edx_110 = *((byte) esp_148.u0 + 20);
					goto l08088602;
				}
				eax_240 = *((byte) esp_148.u0 + 32);
			}
			esp_148.u0->u0 = ~0x00;
			((byte) esp_148.u0 + 4)->u0 = ~0x00;
			((byte) esp_148.u0 + 8)->u0 = 0x00;
			*((byte) esp_148.u0 + 0x0C) = eax_240;
			runtime.traceback(gs);
			goto l080886F6;
		}
l08088602:
		ecx_109 = (word32) ecx_109 + 4;
		edx_110 = (word32) edx_110 + 1;
	}
	word32 edx_379;
	word32 ebx_380;
	runtime.unlock(gs, 0x08157590, out edx_379, out ebx_380);
	return esi_102;
}

// 08088820: void runtime.printCgoTraceback(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 word32) dwArg04)
// Called from:
//      runtime.traceback1
void runtime.printCgoTraceback(struct Eq_2 * gs, Eq_4 dwArg00, word32 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_ptr8144FBC == null)
	{
		word32 * eax_21 = dwArg04;
		int32 ecx_24;
		for (ecx_24 = 0x00; ecx_24 < 0x20; ++ecx_24)
		{
			Eq_4 edx_32 = *eax_21;
			if (edx_32 == 0x00)
				return;
			runtime.printlock(gs);
			runtime.printstring(gs);
			word32 esi_191;
			runtime.printhex(esi, gs, edx_32, 0x00, out esi_191);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			++eax_21;
		}
	}
	else
	{
		fn0808FD89(0x00, fp - 0x1C);
		Eq_4 ecx_113 = dwArg00;
		int32 eax_115;
		for (eax_115 = 0x00; eax_115 < 0x20; ++eax_115)
		{
			Eq_4 edx_96 = *ecx_113;
			if (edx_96 == 0x00)
				break;
			runtime.printOneCgoTraceback(gs, edx_96, 0x7FFFFFFF, fp - 0x20);
			ecx_113 = (word32) ecx_113 + 4;
		}
		runtime.callCgoSymbolizer(gs);
	}
}

// 08088930: void runtime.printOneCgoTraceback(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_78548) dwArg0C)
// Called from:
//      runtime.tracebackCgoContext
//      runtime.printCgoTraceback
void runtime.printOneCgoTraceback(struct Eq_2 * gs, Eq_4 dwArg04, int32 dwArg08, struct Eq_78548 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg0C->t0000 = dwArg04;
	int32 edx_20;
	for (edx_20 = 0x00; edx_20 <= dwArg08; ++edx_20)
	{
		runtime.callCgoSymbolizer(gs);
		if (dwArg0C->dw000C != 0x00)
		{
			runtime.gostringnocopy();
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printnl(gs);
			runtime.printunlock(gs);
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printnl(gs);
			runtime.printunlock(gs);
		}
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		if (dwArg0C->dw0004 != 0x00)
		{
			runtime.gostringnocopy();
			Eq_4 ebx_123 = dwArg0C->t0008;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printint(ebx, gs, ebx_123);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_279;
		runtime.printhex(esi, gs, dwArg04, 0x00, out esi_279);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		if (dwArg0C->dw0014 == 0x00)
			return;
	}
}

// 08088B20: void runtime.callCgoSymbolizer(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.expandCgoFrames
//      runtime.tracebackCgoContext
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
void runtime.callCgoSymbolizer(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw8157618 <= 0x00)
	{
		Eq_4 eax_23 = gs->ptr0000->tFFFFFFFC;
		if (*((word32) *((word32) eax_23 + 24) + 84) == eax_23)
			goto l08088B45;
	}
l08088B45:
	word32 edi_63;
	runtime.asmcgocall(gs, g_ptr8144FBC, dwArg04, out edi_63);
}

// 08088B90: void runtime.cgoContextPCs(Register (ptr32 Eq_2) gs, Stack up32 dwArg0C)
// Called from:
//      runtime.tracebackCgoContext
void runtime.cgoContextPCs(struct Eq_2 * gs, up32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_ptr8144FC0 == null)
		return;
	if (g_dw8157618 <= 0x00)
	{
		Eq_4 eax_29 = gs->ptr0000->tFFFFFFFC;
		if (*((word32) *((word32) eax_29 + 24) + 84) == eax_29)
			goto l08088BC3;
	}
l08088BC3:
	if (dwArg0C <= 0x00)
		runtime.panicindex(gs);
	else
	{
		word32 edi_116;
		runtime.asmcgocall(gs, g_ptr8144FC0, fp - 0x10, out edi_116);
	}
}

// 08088C40: void runtime.(*_type).string(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.typestring
//      runtime.getitab
//      runtime.additab
//      runtime.panicdottypeE
//      runtime.assertE2I
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.SetFinalizer
//      runtime.tracealloc
//      runtime.typesEqual
void runtime.(*_type).string(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*_type).nameOff(gs);
	runtime.name.name(gs, dwLoc04);
	if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x02) == 0x00)
		return;
	if (dwLoc04 >= 0x01)
		return;
	runtime.panicslice(gs);
}

// 08088CD0: void runtime.(*_type).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.additab
//      runtime.SetFinalizer
//      runtime.typesEqual
void runtime.(*_type).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) == 0x00)
		return;
	cu8 cl_24 = (byte) ((word32) *((word32) dwArg04 + 0x0F) & 0x1F);
	if (cl_24 > 0x14)
	{
		if (cl_24 > 22)
		{
			if (cl_24 == 0x17)
				return;
			if (cl_24 != 0x19)
				;
		}
		else if (cl_24 != 0x15)
			;
	}
	else if (cl_24 > 0x12)
	{
		if (cl_24 != 0x13)
			;
	}
	else
	{
		if (cl_24 == 0x11)
			return;
		if (cl_24 == 0x12)
			;
	}
}

// 08088D90: void runtime.reflectOffsLock(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.addReflectOff
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
void runtime.reflectOffsLock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_32;
	word32 esi_33;
	word32 edi_34;
	runtime.lock(esi, gs, 135549344, out ebp_32, out esi_33, out edi_34);
}

// 08088DC0: void runtime.reflectOffsUnlock(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.addReflectOff
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
void runtime.reflectOffsUnlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_31;
	word32 ebx_32;
	runtime.unlock(gs, 135549344, out edx_31, out ebx_32);
}

// 08088DF0: Register Eq_4 runtime.resolveNameOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.resolveNameOff
//      runtime.(*_type).nameOff
//      runtime.name.pkgPath
//      runtime.typesEqual
Eq_4 runtime.resolveNameOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return ebx;
	struct Eq_79894 * edx_214;
	for (edx_214 = &g_t8139420; edx_214 != null; edx_214 = edx_214->ptr00D8)
	{
		ebx = edx_214->t0064;
		if (dwArg04 >= ebx)
		{
			Eq_4 ebp_209 = edx_214->t0068;
			if (dwArg04 < ebp_209)
			{
				if (ebx + dwArg08 >u ebp_209)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					word32 esi_421;
					runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_421);
					runtime.printsp(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					word32 esi_422;
					runtime.printhex(esi, gs, ebx, 0x00, out esi_422);
					runtime.printsp(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					word32 esi_423;
					runtime.printhex(esi, gs, ebp_209, 0x00, out esi_423);
					runtime.printnl(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				else
					return ebx;
			}
		}
	}
	runtime.reflectOffsLock(gs);
	runtime.mapaccess2_fast32(gs, &g_t80CFA40, g_t81451A8, dwArg08);
	runtime.reflectOffsUnlock(gs);
	if ((byte) (word32) (byte) (word32) bLoc1C != 0x00)
		return ebx;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	word32 esi_424;
	runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_424);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	word32 esi_425;
	runtime.printhex(esi, gs, dwArg04, 0x00, out esi_425);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	struct Eq_80000 * eax_132;
	for (eax_132 = &g_t8139420; eax_132 != null; eax_132 = eax_132->ptr00D8)
	{
		Eq_4 ecx_139 = eax_132->t0064;
		Eq_4 edx_141 = eax_132->t0068;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_426;
		runtime.printhex(esi, gs, ecx_139, 0x00, out esi_426);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_427;
		runtime.printhex(esi, gs, edx_141, 0x00, out esi_427);
		runtime.printnl(gs);
		runtime.printunlock(gs);
	}
	runtime.throw(gs);
}

// subject_text_0004.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text_0004.h"

// 080890D0: void runtime.(*_type).nameOff(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.getitab
//      runtime.additab
//      runtime.(*_type).string
//      runtime.typesEqual
void runtime.(*_type).nameOff(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.resolveNameOff(gs, dwArg04, dwArg08);
}

// 08089110: void runtime.resolveTypeOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*_type).typeOff
//      runtime.typesEqual
void runtime.resolveTypeOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return;
	struct Eq_80076 * edx_25;
	for (edx_25 = &g_t8139420; edx_25 != null; edx_25 = edx_25->ptr00D8)
	{
		if (dwArg04 >= edx_25->t0064 && dwArg04 < edx_25->t0068)
			goto l0808915D;
	}
	edx_25 = null;
l0808915D:
	if (edx_25 == null)
	{
		runtime.reflectOffsLock(gs);
		word32 edi_451;
		word32 esi_450;
		runtime.mapaccess1_fast32(gs, 0x080CFA40, g_t81451A8, dwArg08, out esi_450, out edi_451);
		word32 eax_71 = *dwLoc1C;
		runtime.reflectOffsUnlock(gs);
		if (eax_71 != 0x00)
			return;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_458;
		runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_458);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_459;
		runtime.printhex(esi, gs, dwArg04, 0x00, out esi_459);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		struct Eq_80212 * eax_149;
		for (eax_149 = &g_t8139420; eax_149 != null; eax_149 = eax_149->ptr00D8)
		{
			Eq_4 ecx_156 = eax_149->t0064;
			Eq_4 edx_158 = eax_149->t0068;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			word32 esi_460;
			runtime.printhex(esi, gs, ecx_156, 0x00, out esi_460);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			word32 esi_461;
			runtime.printhex(esi, gs, edx_158, 0x00, out esi_461);
			runtime.printnl(gs);
			runtime.printunlock(gs);
		}
		runtime.throw(gs);
	}
	else
	{
		word32 esi_452;
		word32 edi_453;
		runtime.mapaccess1_fast32(gs, 0x080CFB00, edx_25->t00D4, dwArg08, out esi_452, out edi_453);
		if (*dwLoc1C != 0x00)
			return;
		Eq_4 ecx_244 = edx_25->t0064;
		Eq_4 eax_247 = edx_25->t0068;
		if (ecx_244 + dwArg08 <=u eax_247)
			return;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_455;
		runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_455);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_456;
		runtime.printhex(esi, gs, ecx_244, 0x00, out esi_456);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_457;
		runtime.printhex(esi, gs, eax_247, 0x00, out esi_457);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 08089430: void runtime.(*_type).typeOff(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.additab
//      reflect.resolveTypeOff
void runtime.(*_type).typeOff(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.resolveTypeOff(gs, dwArg04, dwArg08);
}

// 08089470: void runtime.(*_type).textOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.additab
//      reflect.resolveTextOff
void runtime.(*_type).textOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_80284 * ecx_19;
	for (ecx_19 = &g_t8139420; ecx_19 != null; ecx_19 = ecx_19->ptr00D8)
	{
		if (dwArg04 >= ecx_19->t0064 && dwArg04 < ecx_19->t0068)
			goto l080894B1;
	}
	ecx_19 = null;
l080894B1:
	if (ecx_19 == null)
	{
		runtime.reflectOffsLock(gs);
		word32 edi_505;
		word32 esi_504;
		runtime.mapaccess1_fast32(gs, 0x080CFA40, g_t81451A8, dwArg08, out esi_504, out edi_505);
		word32 eax_65 = *dwLoc1C;
		runtime.reflectOffsUnlock(gs);
		if (eax_65 != 0x00)
			return;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_509;
		runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_509);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_510;
		runtime.printhex(esi, gs, dwArg04, 0x00, out esi_510);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		struct Eq_80449 * eax_143;
		for (eax_143 = &g_t8139420; eax_143 != null; eax_143 = eax_143->ptr00D8)
		{
			Eq_4 ecx_150 = eax_143->t0064;
			Eq_4 edx_152 = eax_143->t0068;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			word32 esi_511;
			runtime.printhex(esi, gs, ecx_150, 0x00, out esi_511);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			word32 esi_512;
			runtime.printhex(esi, gs, edx_152, 0x00, out esi_512);
			runtime.printnl(gs);
			runtime.printunlock(gs);
		}
		runtime.throw(gs);
	}
	else
	{
		Eq_4 eax_223;
		struct Eq_80323 * eax_217 = ecx_19->ptr006C;
		Eq_80327 edx_218 = ecx_19->t0070;
		if (edx_218 > 0x01)
		{
			Eq_80327 ebp_225 = 0x00;
			while (ebp_225 < edx_218)
			{
				if (ebp_225 >= edx_218)
					runtime.panicindex(gs);
				esi = ebp_225 * 0x03;
				Eq_4 edi_245 = eax_217[esi * 0x04 / 8];
				up32 ecx_246 = eax_217->a0004[esi];
				if (dwArg08 >= edi_245 && dwArg08 <= (word32) edi_245 + ecx_246)
				{
					eax_223 = (word32) dwArg08 + (eax_217->a0008)[esi] - edi_245;
					goto l080894F8;
				}
				ebp_225 = (word32) ebp_225 + 1;
			}
			eax_223.u0 = 0x00;
		}
		else
			eax_223 = dwArg08 + Mem216[ecx_19 + 0x30:word32];
l080894F8:
		Eq_4 edx_266 = ecx_19->t0034;
		if (eax_223 <= edx_266)
			return;
		Eq_4 eax_271 = ecx_19->t0030;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_506;
		runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_506);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_507;
		runtime.printhex(esi, gs, eax_271, 0x00, out esi_507);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_508;
		runtime.printhex(esi, gs, edx_266, 0x00, out esi_508);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 080897A0: void runtime.name.tagLen(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.name.tag
//      runtime.name.pkgPath
void runtime.name.tagLen(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((byte) (word32) *dwArg04 & 0x02) != 0x00)
		;
}

// 08089810: void runtime.name.name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.getitab
//      runtime.additab
//      runtime.(*_type).string
//      runtime.name.pkgPath
//      runtime.typesEqual
void runtime.name.name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	if ((word32) (word16) ((word32) *((word32) dwArg04 + 1) << 0x08 | (word32) (*((word32) dwArg04 + 2))) != 0x00)
		;
}

// 08089890: void runtime.name.tag(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.typesEqual
void runtime.name.tag(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.name.tagLen(gs, dwArg04);
	if (dwLoc04 != 0x00)
		;
}

// 08089910: Register word32 runtime.name.pkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out ptr32 ediOut)
// Called from:
//      runtime.additab
//      runtime.typesEqual
word32 runtime.name.pkgPath(struct Eq_2 * gs, Eq_4 dwArg04, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00 || ((byte) ((word32) (*dwArg04)) & 0x04) == 0x00)
	{
		ediOut = edi;
		return esi;
	}
	else
	{
		int32 eax_51;
		word16 dx_31 = (word16) (word32) *((word32) dwArg04 + 1);
		word16 cx_34 = (word16) (word32) *((word32) dwArg04 + 2);
		runtime.name.tagLen(gs, dwArg04);
		word32 eax_46 = (word32) (word16) ((word32) dx_31 << 0x08 | (word32) cx_34);
		if (dwLoc10 > 0x00)
			eax_51 = dwLoc10 + 0x05 + eax_46;
		else
			eax_51 = eax_46 + 0x03;
		ptr32 edi_67;
		word32 esi_68;
		word32 ebp_165;
		runtime.memmove(fp - 0x04, (word32) dwArg04 + eax_51, 0x04, out ebp_165, out esi_68, out edi_67);
		runtime.resolveNameOff(gs, dwArg04, 0x00);
		runtime.name.name(gs, 0x04);
		ediOut = edi_67;
		return esi_68;
	}
}

// 08089A00: Register Eq_4 runtime.typelinksinit(Register word32 ebx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
Eq_4 runtime.typelinksinit(word32 ebx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_6606 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp - 0xA8 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw81394F8 == 0x00)
		return esi;
	fn0808FD89(0x00, fp - 0xA8);
	word32 edi_53;
	word128 xmm0_57;
	word128 xmm1_58;
	Eq_4 esi_106 = runtime.makemap(ebx_24_8, esi, fn0808FD6D(0x00, fp - 0x90), gs, 0x080CFC00, dwLocF0, dwLocF0 >> 0x1F, fp - 0xB0, fp - 0x94, out edi_53, out xmm0_57, out xmm1_58);
	runtime.activeModules();
	Eq_4 dwLoc0124_643 = fp - 0xB0;
	if (dwLocF0 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		struct Eq_80696 * eax_100 = g_ptr80CFC00;
		word32 * ecx_102 = (0x01 - (dwLocF0 >> 0x1F) >> 0x1F & 0x04) + 0x080CFC00;
		Eq_80709 ebx_427 = 0x00;
		while (ebx_427 < dwLocF0 - 0x01)
		{
			struct Eq_80696 * ebp_104 = *ecx_102;
			esi_106 = eax_100->t0078;
			Eq_4 edi_107 = eax_100->t007C;
			Eq_4 dwLocFC_655 = 0x00;
			while (true)
			{
				Eq_6606 ebx_24_8_137 = SLICE(ebx_427, word24, 8);
				if (dwLocFC_655 >= edi_107)
					break;
				Eq_4 ecx_457;
				Eq_4 ebx_435 = *esi_106;
				Eq_4 ecx_437 = eax_100->t00D4;
				if (ecx_437 == 0x00)
					ecx_457 = (word32) ebx_435 + eax_100->dw0064;
				else
				{
					word32 edi_1035;
					word32 esi_1034;
					runtime.mapaccess1_fast32(gs, 0x080CFB00, ecx_437, ebx_435, out esi_1034, out edi_1035);
					ecx_457 = *dwLoc0124_643;
				}
				word32 esi_1036;
				word32 edi_1037;
				runtime.mapaccess1_fast32(gs, 0x080CFC00, dwLoc011C, *((word32) ecx_457 + 8), out esi_1036, out edi_1037);
				Eq_4 edx_484 = *dwLoc0124_643;
				Eq_4 ecx_483 = *((word32) dwLoc0124_643 + 8);
				Eq_4 eax_485 = *((word32) dwLoc0124_643 + 4);
				Eq_4 ebp_487 = edx_484;
				Eq_4 esi_488 = 0x00;
				edx_599 = edx_484;
				while (true)
				{
					Eq_4 edx_599;
					if (esi_488 >= eax_485)
						break;
					if (*edx_599 == ecx_457)
						goto l08089AD5;
					edx_599 = (word32) edx_599 + 4;
					esi_488 = (word32) esi_488 + 1;
				}
				Eq_4 edx_495 = (word32) eax_485 + 1;
				if ((word32) eax_485 + 1 > ecx_483)
				{
					word32 esi_1038;
					runtime.growslice(gs, 0x080D8DA0, edx_484, eax_485, ecx_483, (word32) eax_485 + 1, out esi_1038);
					dwLoc0124_643 = ecx_483;
					ebp_487 = dwLoc011C;
					ecx_483 = dwLoc0114;
					edx_495 = (word32) dwLoc0118 + 1;
				}
				Eq_4 esi_534 = (word32) ebp_487 + eax_485 * 0x04;
				if (g_t81576F0 == 0x00)
					*((word32) ebp_487 + eax_485 * 0x04) = ecx_457;
				else
					runtime.writebarrierptr(esi_534, ecx_457);
				runtime.mapassign_fast32(gs, 0x080CFC00, dwLoc011C, *((word32) ecx_457 + 8));
				*((word32) dwLoc0124_643 + 4) = edx_495;
				*((word32) dwLoc0124_643 + 8) = ecx_483;
				if (g_t81576F0 == 0x00)
					*dwLoc0124_643 = ebp_487;
				else
					runtime.writebarrierptr(dwLoc0124_643, ebp_487);
l08089AD5:
				esi_106 = (word32) esi_106 + 4;
				dwLocFC_655 = (word32) dwLocFC_655 + 1;
			}
			if (ebp_104->t00D4 == 0x00)
			{
				Eq_4 eax_128 = ebp_104->t007C;
				word32 edi_143;
				word128 xmm0_147;
				word128 xmm1_148;
				esi_106 = runtime.makemap(ebx_24_8_137, esi_106, edi_107, gs, 0x080CFB00, eax_128, eax_128 >> 0x1F, 0x00, 0x00, out edi_143, out xmm0_147, out xmm1_148);
				dwLoc0124_643.u0 = 0x00;
				Eq_4 ecx_157 = g_t8145160;
				Eq_4 edx_158 = g_t814515C;
				Eq_4 ebx_159 = g_t8145158;
				if ((word32) edx_158 + 1 > ecx_157)
				{
					runtime.growslice(gs, 0x080CFB00, ebx_159, edx_158, ecx_157, (word32) edx_158 + 1, out esi_106);
					g_t8145160 = dwLoc0114;
					dwLoc0124_643 = ecx_157;
					if (g_t81576F0 == 0x00)
						g_t8145158 = dwLoc011C;
					else
						runtime.writebarrierptr(0x08145158, dwLoc011C);
					edx_158 = dwLoc0118;
					ebx_159 = dwLoc011C;
				}
				g_t814515C = (word32) edx_158 + 1;
				Eq_4 ecx_215 = (word32) ebx_159 + edx_158 * 0x04;
				if (g_t81576F0 == 0x00)
				{
					*((word32) ebx_159 + edx_158 * 0x04) = dwLoc011C;
					ebp_104->t00D4 = dwLoc011C;
				}
				else
				{
					runtime.writebarrierptr(ecx_215, dwLoc011C);
					runtime.writebarrierptr(&ebp_104->t00D4, dwLoc011C);
				}
				Eq_4 eax_250 = ebp_104->t007C;
				Eq_4 edx_253 = ebp_104->t0078;
				Eq_4 ebx_254 = 0x00;
				while (ebx_254 < eax_250)
				{
					Eq_4 eax_269 = *edx_253;
					Eq_4 ebx_273 = (word32) eax_269 + ebp_104->dw0064;
					Eq_4 esi_289;
					Eq_4 edi_288;
					Eq_6606 ebx_24_8_319 = SLICE(runtime.mapaccess1_fast32(gs, 0x080CFC00, dwLoc011C, *((word32) ebx_273 + 8), out esi_289, out edi_288), word24, 8);
					Eq_4 ecx_295 = *((byte) dwLoc0124_643.u0 + 4);
					Eq_4 eax_297 = *dwLoc0124_643.u0;
					Eq_4 edx_298 = 0x00;
					while (true)
					{
						Eq_4 eax_307;
						if (edx_298 >= ecx_295)
							break;
						Eq_4 ecx_311 = *eax_297;
						word128 xmm0_330;
						word128 xmm1_331;
						word32 edi_1039;
						runtime.makemap(ebx_24_8_319, esi_289, edi_288, gs, 0x080CFAC0, 0x00, 0x00, 0x00, 0x00, out edi_1039, out xmm0_330, out xmm1_331);
						dwLoc0124_643.u0 = 0x00;
						esi_289 = runtime.typesEqual(gs, ebx_273, ecx_311, dwLoc011C, out edi_288);
						if (0x00 != 0x00)
						{
							eax_307 = ecx_311;
							goto l08089DAC;
						}
						eax_297 = (word32) eax_297 + 4;
						ebx_24_8_319.u0 = SLICE(edx_298, word24, 8);
						edx_298 = (word32) edx_298 + 1;
					}
					eax_307 = ebx_273;
l08089DAC:
					esi_106 = runtime.mapassign_fast32(gs, 0x080CFB00, ebp_104->t00D4, eax_269);
					if (g_t81576F0 == 0x00)
						*dwLoc0124_643.u0 = eax_307;
					else
						runtime.writebarrierptr(dwLoc0124_643, eax_307);
					edx_253 = (word32) edx_253 + 4;
					ebx_254 = (word32) ebx_254 + 1;
				}
			}
			++ecx_102;
			ebx_427 = (word32) ebx_427.u0 + 1;
			eax_100 = ebp_104;
		}
		return esi_106;
	}
}

// 08089F40: Register Eq_4 runtime.typesEqual(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_4 ediOut)
// Called from:
//      runtime.typelinksinit
//      runtime.typesEqual
Eq_4 runtime.typesEqual(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_4 & ediOut)
{
	byte bLoc80_1346 = (byte) dwLoc80;
	while (fp - 0x10 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edi_32;
	Eq_4 esi_33 = runtime.mapaccess2_fast64(gs, &g_t80CFAC0, dwArg0C, dwArg04, dwArg08, out edi_32);
	if ((byte) (word32) bLoc7C != 0x00)
	{
		ediOut = edi_32;
		return esi_33;
	}
	Eq_4 edi_127;
	Eq_4 esi_128 = runtime.mapassign_fast64(gs, 0x080CFAC0, dwArg0C, dwArg04, dwArg08, out edi_127);
	if (dwArg04 == dwArg08)
	{
		ediOut = edi_127;
		return esi_128;
	}
	ui32 edx_77 = (word32) *((word32) dwArg04 + 0x0F);
	byte bl_95 = (byte) edx_77;
	byte dl_85 = (byte) (edx_77 & 0x1F);
	if (dl_85 != (byte) ((word32) (*((word32) dwArg08 + 0x0F)) & 0x1F))
	{
		ediOut = edi_127;
		return esi_128;
	}
	runtime.(*_type).string(gs, dwArg04);
	runtime.(*_type).string(gs, dwArg08);
	if (dwArg04 != dwArg04)
	{
l0808A043:
		ediOut = edi_127;
		return esi_128;
	}
	Eq_4 dwLoc8C_1343 = dwArg04;
	Eq_4 dwLoc88_1344 = dwArg0C;
	byte bLoc84_1436 = (byte) dwArg04;
	word32 ebx_130 = runtime.eqstring(dwArg0C, dwArg04, dwArg0C, out esi_128, out edi_127);
	if ((byte) (word32) bLoc80_1346 == 0x00)
		goto l0808A043;
	byte bLoc80_1479;
	runtime.(*_type).uncommon(gs, dwArg04);
	runtime.(*_type).uncommon(gs, dwArg08);
	bool Z_164 = SLICE(cond(dwArg04), bool, 2);
	if (dwArg04 == 0x00)
	{
		bLoc80_1479 = (byte) dwLoc80;
		if (dwArg04 == 0x00)
			goto l0808A0B4;
		Z_164 = SLICE(cond(dwArg04), bool, 2);
	}
	if (Z_164 || dwArg04 == 0x00)
	{
		ediOut = edi_127;
		return esi_128;
	}
	Eq_4 eax_179 = *dwArg04;
	runtime.(*_type).nameOff(gs);
	runtime.name.name(gs, dwArg0C);
	Eq_4 edx_204 = *dwArg04;
	runtime.(*_type).nameOff(gs);
	runtime.name.name(gs, dwArg0C);
	if (dwArg0C == dwArg0C)
	{
		dwLoc8C_1343 = dwArg0C;
		dwLoc88_1344 = edx_204;
		bLoc84_1436 = (byte) dwArg0C;
		ebx_130 = runtime.eqstring(eax_179, dwArg0C, edx_204, out esi_128, out edi_127);
		if ((byte) (word32) bLoc80_1346 != 0x00)
		{
l0808A0B4:
			word32 eax_258 = (word32) dl_85;
			Eq_363 ebx_24_8_640 = SLICE(ebx_130, word24, 8);
			cu8 al_266 = (byte) eax_258;
			if ((byte) (eax_258 - 0x01) <= 0x0F)
			{
				ediOut = edi_127;
				return esi_128;
			}
			if (al_266 > 0x15)
			{
				if (al_266 <= 0x17)
				{
					if (al_266 != 22)
					{
						word32 edi_1943;
						runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_1943);
						ediOut = edi_127;
						return esi_128;
					}
					else
					{
						word32 edi_1944;
						runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_1944);
						ediOut = edi_127;
						return esi_128;
					}
				}
				if (al_266 != 0x18)
				{
					if (al_266 == 0x19)
					{
						Eq_4 ecx_278 = *((word32) dwArg04 + 40);
						if (ecx_278 != *((word32) dwArg08 + 40))
						{
							ediOut = edi_127;
							return esi_128;
						}
						else
						{
							Eq_4 ebx_287 = 0x00;
							while (ebx_287 < ecx_278)
							{
								Eq_4 esi_1774 = *((word32) dwArg04 + 36);
								if (ebx_287 >= *((word32) dwArg04 + 40))
									runtime.panicindex(gs);
								ui32 ebp_305 = ebx_287 * 0x03;
								Eq_4 edi_1737 = *((word32) dwArg08 + 40);
								Eq_4 edx_308 = *((word32) dwArg08 + 36);
								if (ebx_287 >= edi_1737)
									runtime.panicindex(gs);
								runtime.name.name(gs, *((word32) esi_1774 + ebp_305 * 0x04));
								runtime.name.name(gs, *((word32) edx_308 + ebp_305 * 0x04));
								if (dwLoc88_1344 != dwLoc88_1344)
								{
l0808AA59:
									ediOut = edi_1737;
									return esi_1774;
								}
								runtime.eqstring(dwLoc8C_1343, dwLoc88_1344, dwLoc8C_1343, out esi_1774, out edi_1737);
								if ((byte) (word32) bLoc80_1479 == 0x00)
									goto l0808AA59;
								word32 edi_1945;
								runtime.name.pkgPath(gs, *((word32) esi_1774 + ebp_305 * 0x04), out edi_1945);
								esi_128 = runtime.name.pkgPath(gs, *((word32) edx_308 + ebp_305 * 0x04), out edi_127);
								if (dwLoc8C_1343 != dwLoc8C_1343)
								{
l0808AA4A:
									ediOut = edi_127;
									return esi_128;
								}
								runtime.eqstring(dwLoc88_1344, dwLoc8C_1343, dwLoc88_1344, out esi_128, out edi_127);
								byte bLoc84_1411 = (byte) dwLoc8C_1343;
								if ((byte) (word32) bLoc80_1479 == 0x00)
									goto l0808AA4A;
								Eq_4 ebp_435 = *((word32) edx_308 + (ebp_305 * 0x04 + 4));
								word32 edi_1946;
								runtime.typesEqual(gs, *((word32) esi_1774 + (ebp_305 * 0x04 + 4)), ebp_435, dwArg0C, out edi_1946);
								if ((byte) (word32) bLoc84_1411 == 0x00)
								{
									ediOut = edi_127;
									return esi_128;
								}
								runtime.name.tag(gs, *((word32) esi_1774 + ebp_305 * 0x04));
								runtime.name.tag(gs, *((word32) edx_308 + ebp_305 * 0x04));
								if (dwArg0C != dwArg0C)
								{
l0808AA2C:
									ediOut = edi_127;
									return esi_128;
								}
								runtime.eqstring(ebp_435, dwArg0C, ebp_435, out esi_128, out edi_127);
								dwLoc8C_1343 = dwArg0C;
								dwLoc88_1344 = ebp_435;
								if ((byte) (word32) bLoc80_1479 == 0x00)
									goto l0808AA2C;
								if (*((word32) esi_1774 + (ebp_305 * 0x04 + 8)) != *((word32) edx_308 + (ebp_305 * 0x04 + 8)))
								{
									ediOut = edi_127;
									return esi_128;
								}
								ebx_287 = (word32) ebx_287 + 1;
							}
							ediOut = edi_127;
							return esi_128;
						}
					}
					if (al_266 != 0x1A)
					{
l0808ABCB:
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						runtime.printint(ebx_24_8_640, gs, (uint64) (uint32) ((word32) bl_95 & 0x1F));
						runtime.printnl(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
				}
				ediOut = edi_127;
				return esi_128;
			}
			else
			{
				if (al_266 > 0x12)
				{
					if (al_266 != 0x13)
					{
						if (al_266 != 0x14)
						{
							word32 edi_1935;
							runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_1935);
							if ((byte) (word32) bLoc84_1436 != 0x00)
							{
								word32 edi_1937;
								runtime.typesEqual(gs, *((word32) dwArg04 + 36), *((word32) dwArg08 + 36), dwArg0C, out edi_1937);
							}
							ediOut = edi_127;
							return esi_128;
						}
						else
						{
							runtime.name.name(gs, *((word32) dwArg04 + 32));
							runtime.name.name(gs, *((word32) dwArg08 + 32));
							if (dwLoc88_1344 == dwLoc88_1344)
							{
								runtime.eqstring(dwLoc8C_1343, dwLoc88_1344, dwLoc8C_1343, out esi_128, out edi_127);
								Eq_4 dwLoc88_1477 = dwLoc8C_1343;
								if ((byte) (word32) bLoc80_1479 != 0x00)
								{
									Eq_4 ecx_793 = *((word32) dwArg04 + 40);
									if (ecx_793 != *((word32) dwArg08 + 40))
									{
										ediOut = edi_127;
										return esi_128;
									}
									else
									{
										Eq_4 ebx_1023 = 0x00;
										while (ebx_1023 < ecx_793)
										{
											Eq_4 ebp_815 = *((word32) dwArg04 + 36);
											if (ebx_1023 >= *((word32) dwArg04 + 40))
												runtime.panicindex(gs);
											Eq_4 esi_1765 = (word32) ebp_815 + ebx_1023 * 0x08;
											Eq_4 edi_1729 = *((word32) dwArg08 + 40);
											Eq_4 edx_823 = *((word32) dwArg08 + 36);
											if (ebx_1023 >= edi_1729)
												runtime.panicindex(gs);
											runtime.resolveNameOff(gs, esi_1765, *((word32) ebp_815 + ebx_1023 * 0x08));
											Eq_4 ebx_848 = *((word32) edx_823 + ebx_1023 * 0x08);
											Eq_4 ebx_850 = (word32) edx_823 + ebx_1023 * 0x08;
											runtime.resolveNameOff(gs, ebx_850, ebx_848);
											runtime.name.name(gs, dwLoc88_1477);
											runtime.name.name(gs, dwLoc88_1477);
											if (dwLoc88_1477 != dwLoc88_1477)
											{
l0808A603:
												ediOut = edi_1729;
												return esi_1765;
											}
											runtime.eqstring(ebx_848, dwLoc88_1477, ebx_848, out esi_1765, out edi_1729);
											if ((byte) (word32) bLoc80_1479 == 0x00)
												goto l0808A603;
											word32 edi_1939;
											runtime.name.pkgPath(gs, dwLoc88_1477, out edi_1939);
											esi_128 = runtime.name.pkgPath(gs, dwLoc88_1477, out edi_127);
											if (ebx_848 != ebx_848)
											{
l0808A5F4:
												ediOut = edi_127;
												return esi_128;
											}
											runtime.eqstring(dwLoc88_1477, ebx_848, dwLoc88_1477, out esi_128, out edi_127);
											byte bLoc84_1528 = (byte) ebx_848;
											if ((byte) (word32) bLoc80_1479 == 0x00)
												goto l0808A5F4;
											runtime.resolveTypeOff(gs, esi_1765, *((word32) ebp_815 + (ebx_1023 * 0x08 + 4)));
											runtime.resolveTypeOff(gs, ebx_850, *((word32) edx_823 + (ebx_1023 * 0x08 + 4)));
											word32 edi_1940;
											runtime.typesEqual(gs, dwLoc88_1477, dwLoc88_1477, dwArg0C, out edi_1940);
											dwLoc88_1477 = dwArg0C;
											if ((byte) (word32) bLoc84_1528 == 0x00)
											{
												ediOut = edi_127;
												return esi_128;
											}
											ebx_1023 = (word32) ebx_1023 + 1;
										}
										ediOut = edi_127;
										return esi_128;
									}
								}
							}
							ediOut = edi_127;
							return esi_128;
						}
					}
					else
					{
						if ((word16) (word32) *((word32) dwArg04 + 0x0022) == (word16) ((word32) (*((word32) dwArg08 + 0x0022))))
						{
							word16 cx_1045 = (word16) (word32) *((word32) dwArg04 + 32);
							word16 bx_1044 = (word16) (word32) *((word32) dwArg08 + 32);
							if (bx_1044 == cx_1045)
							{
								word32 ebp_1063;
								if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
									ebp_1063 = 0x34;
								else
									ebp_1063 = 0x24;
								Eq_4 (* ebp_1068)[] = (word32) dwArg04 + ebp_1063;
								Eq_4 ecx_1073 = (word32) cx_1045;
								if (ecx_1073 > 0x00100000)
									runtime.panicslice(gs);
								else
								{
									word32 esi_1089;
									if (((byte) (word32) *((word32) dwArg08 + 0x0C) & 0x01) != 0x00)
										esi_1089 = 0x34;
									else
										esi_1089 = 0x24;
									Eq_4 esi_1094 = (word32) dwArg08 + esi_1089;
									Eq_4 ebx_1101 = (word32) bx_1044;
									if (ebx_1101 > 0x00100000)
										runtime.panicslice(gs);
									else
									{
										Eq_4 edi_1113 = 0x00;
										while (edi_1113 < ecx_1073)
										{
											if (edi_1113 >= ecx_1073)
											{
l0808ABB6:
												runtime.panicindex(gs);
											}
											Eq_4 edx_1269 = ebp_1068[edi_1113];
											if (edi_1113 >= ebx_1101)
												goto l0808ABB6;
											word32 edi_1936;
											runtime.typesEqual(gs, edx_1269, *((word32) esi_1094 + edi_1113 * 0x04), dwArg0C, out edi_1936);
											if ((byte) (word32) bLoc84_1436 == 0x00)
											{
												ediOut = edi_1113;
												return esi_1094;
											}
											edi_1113 = (word32) edi_1113 + 1;
										}
										word32 ecx_1127;
										if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
											ecx_1127 = 0x34;
										else
											ecx_1127 = 0x24;
										word32 eax_1138 = (word32) *((word32) dwArg04 + 32);
										word32 ecx_1132 = (word32) dwArg04 + ecx_1127;
										uint32 ebp_1140 = (word32) (word16) eax_1138;
										uint32 eax_1143 = (word32) (word16) (eax_1138 + ((word32) (*((word32) dwArg04 + 0x0022)) & 0x7FFF));
										if (ebp_1140 > eax_1143 || eax_1143 > 0x00100000)
											runtime.panicslice(gs);
										else
										{
											word32 ebx_1166;
											Eq_4 eax_1151 = eax_1143 - ebp_1140;
											Eq_4 ecx_1158[] = ecx_1132 + (-(-(ebp_1140 + 0xFFF00000)) >> 0x1F & ebp_1140 << 0x02);
											if (((byte) (word32) *((word32) dwArg08 + 0x0C) & 0x01) != 0x00)
												ebx_1166 = 0x34;
											else
												ebx_1166 = 0x24;
											word32 edx_1178 = (word32) *((word32) dwArg08 + 32);
											word32 ebx_1171 = (word32) dwArg08 + ebx_1166;
											uint32 esi_1180 = (word32) (word16) edx_1178;
											uint32 edx_1183 = (word32) (word16) (edx_1178 + ((word32) (*((word32) dwArg08 + 0x0022)) & 0x7FFF));
											if (esi_1180 > edx_1183 || edx_1183 > 0x00100000)
												runtime.panicslice(gs);
											else
											{
												Eq_4 edx_1199 = edx_1183 - esi_1180;
												Eq_4 esi_1216 = esi_1180 << 0x02;
												Eq_4 ebx_1219[] = ebx_1171 + (-(-(esi_1180 + 0xFFF00000)) >> 0x1F & esi_1180 << 0x02);
												Eq_4 ebp_1221 = 0x00;
												while (ebp_1221 < eax_1151)
												{
													if (ebp_1221 >= eax_1151)
													{
l0808ABA1:
														runtime.panicindex(gs);
													}
													Eq_4 esi_1235 = ecx_1158[ebp_1221];
													if (ebp_1221 >= edx_1199)
														goto l0808ABA1;
													word32 edi_1938;
													runtime.typesEqual(gs, esi_1235, ebx_1219[ebp_1221], dwArg0C, out edi_1938);
													if ((byte) (word32) bLoc84_1436 == 0x00)
													{
														ediOut = edi_1113;
														return esi_1235;
													}
													esi_1216 = ebp_1221;
													ebp_1221 = (word32) ebp_1221 + 1;
												}
												ediOut = edi_1113;
												return esi_1216;
											}
										}
									}
								}
							}
						}
						ediOut = edi_127;
						return esi_128;
					}
				}
				if (al_266 == 0x11)
				{
					word32 edi_1941;
					runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_1941);
					ediOut = edi_127;
					return esi_128;
				}
				if (al_266 == 0x12)
				{
					if (*((word32) dwArg04 + 36) == *((word32) dwArg08 + 36))
					{
						word32 edi_1942;
						runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_1942);
					}
					ediOut = edi_127;
					return esi_128;
				}
				goto l0808ABCB;
			}
		}
	}
	ediOut = edi_127;
	return esi_128;
}

// 0808AC30: void runtime.decoderune(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.stringtoslicerune
//      fmt.(*fmt).truncate
void runtime.decoderune(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C >= dwArg08)
		return;
	if (dwArg0C > dwArg08)
		runtime.panicslice(gs);
	else
	{
		Eq_81752 ecx_25 = dwArg08 - dwArg0C;
		int32 ecx_29 = -ecx_25 >> 0x1F & dwArg0C;
		if (ecx_25 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			ui32 ebp_35 = (word32) *((word32) dwArg04 + ecx_29);
			if ((byte) (ebp_35 + 0x40) >= 0x20)
			{
				if ((byte) (ebp_35 + 0x20) >= 0x10)
				{
					if ((byte) (ebp_35 + 0x10) >= 0x08 || ecx_25 <= 0x03)
						return;
					ui32 edx_68 = (word32) ((word32) dwArg04 + 1 + ecx_29);
					if ((byte) (edx_68 - 0x80) > 0x3F)
						return;
					ui32 esi_79 = (word32) ((word32) dwArg04 + 2 + ecx_29);
					if ((byte) (esi_79 - 0x80) > 0x3F)
						return;
					ui32 ecx_90 = (word32) ((word32) dwArg04 + 3 + ecx_29);
					if ((byte) (ecx_90 - 0x80) > 0x3F || (ecx_90 & 0x3F | (((ebp_35 & 0x07) << 0x12 | (edx_68 & 0x3F) << 0x0C) | (esi_79 & 0x3F) << 0x06)) > 1114111)
						;
				}
				else
				{
					if (ecx_25 <= 0x02)
						return;
					ui32 edx_114 = (word32) ((word32) dwArg04 + 1 + ecx_29);
					if ((byte) (edx_114 - 0x80) > 0x3F)
						return;
					ui32 ecx_125 = (word32) ((word32) dwArg04 + 2 + ecx_29);
					if ((byte) (ecx_125 - 0x80) > 0x3F)
						return;
					Eq_81828 edx_136 = (edx_114 & 0x3F) << 0x06 | (ebp_35 & 0x0F) << 0x0C | ecx_125 & 0x3F;
					if (edx_136 <= 0x07FF || edx_136 <= ~0xDFFE)
						;
				}
			}
			else
			{
				if (ecx_25 <= 0x01)
					return;
				ui32 ecx_148 = (word32) ((word32) dwArg04 + 1 + ecx_29);
				if ((byte) (ecx_148 - 0x80) > 0x3F || ((ebp_35 & 0x1F) << 0x06 | ecx_148 & 0x3F) <= 0x7F)
					;
			}
		}
	}
}

// 0808ADD0: void runtime.encoderune(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_70958) dwArg04, Stack up32 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      runtime.slicerunetostring
//      runtime.intstring
void runtime.encoderune(struct Eq_2 * gs, struct Eq_70958 * dwArg04, up32 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = dwArg10;
	byte al_108 = (byte) dwArg10;
	if (dwArg10 > 0x7F)
	{
		if (dwArg10 > 0x07FF)
		{
			if (dwArg10 > 1114111 || dwArg10 <= ~0xDFFE)
				eax_16.u0 = 0xFFFD;
			else if (dwArg10 > 0xFFFF)
			{
				if (dwArg08 <= 0x03)
					runtime.panicindex(gs);
				else
				{
					dwArg04->b0000 = (byte) (dwArg10 >> 0x12 | ~0x0F);
					dwArg04->b0001 = (byte) (dwArg10 >> 0x0C & 0x3F | ~0x7F);
					dwArg04->b0002 = (byte) (dwArg10 >> 0x06 & 0x3F | ~0x7F);
					dwArg04->b0003 = (byte) (dwArg10 & 0x3F | ~0x7F);
					return;
				}
			}
			if (dwArg08 <= 0x02)
				runtime.panicindex(gs);
			else
			{
				dwArg04->b0000 = (byte) (eax_16 >> 0x0C | ~0x1F);
				dwArg04->b0001 = (byte) (eax_16 >> 0x06 & 0x3F | ~0x7F);
				dwArg04->b0002 = (byte) (eax_16 & 0x3F | ~0x7F);
			}
		}
		else if (dwArg08 <= 0x01)
			runtime.panicindex(gs);
		else
		{
			dwArg04->b0000 = (byte) (dwArg10 >> 0x06 | ~0x3F);
			dwArg04->b0001 = (byte) (dwArg10 & 0x3F | ~0x7F);
		}
	}
	else if (dwArg08 <= 0x00)
		runtime.panicindex(gs);
	else
		dwArg04->b0000 = al_108;
}

// 0808AF10: Register Eq_4 runtime.float64toint64(Register (ptr32 Eq_2) gs, Stack real64 rArg04, Register out Eq_21959 xmm0Out)
// Called from:
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcAssistAlloc
//      runtime.gcAssistAlloc1
//      runtime.gcFlushBgCredit
//      runtime.deductSweepCredit
//      reflect.cvtFloatInt
Eq_4 runtime.float64toint64(struct Eq_2 * gs, real64 rArg04, union Eq_21959 & xmm0Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_21959 xmm0_21 = (uint128) (uint64) rArg04;
	runtime._d2v(gs, (word32) fp + 0x0C, (real64) xmm0_21);
	xmm0Out = xmm0_21;
	return <invalid>;
}

// 0808AF60: void runtime.float64touint64(Register (ptr32 Eq_2) gs, Stack real64 rArg04)
// Called from:
//      runtime.gcinit
//      runtime.(*gcControllerState).startCycle
//      runtime.gcSetTriggerRatio
//      reflect.cvtFloatUint
void runtime.float64touint64(struct Eq_2 * gs, real64 rArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime._d2v(gs, (word32) fp + 0x0C, (real64) (uint128) (uint64) rArg04);
}

// 0808AFB0: void runtime.int64tofloat64(Register Eq_363 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 qwArg04)
// Called from:
//      runtime.makemap
//      runtime.mapassign
//      runtime.hashGrow
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.nextSample
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).revise
//      runtime.(*gcControllerState).endCycle
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcAssistAlloc
//      runtime.gcAssistAlloc1
//      runtime.gcFlushBgCredit
//      reflect.cvtIntFloat
void runtime.int64tofloat64(Eq_363 ebx, struct Eq_2 * gs, Eq_4 qwArg04)
{
	int32 dwArg08 = SLICE(qwArg04, word32, 32);
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_24 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	if ((byte) (SEQ(ebx_24_8, dwArg08 < 0x00) | SEQ(ecx_24_8_24, dwArg08 == 0x00) & SEQ(ebx_24_8, Test(ULT,false))) == 0x00)
	{
		runtime.uint32tofloat64();
		runtime.uint32tofloat64();
	}
	else
	{
		runtime.uint32tofloat64();
		runtime.uint32tofloat64();
		uint128 xmm0_89 = (uint128) (uint64) rLoc14;
		__pxor(SEQ(SLICE(xmm0_89, word64, 64), (real64) xmm0_89 + (real64) ((uint128) ((uint64) g_r80F1888)) * (real64) ((uint128) ((uint64) ((real64) ((uint128) ((uint64) rLoc14)))))), (uint128) (uint64) g_r80F1890);
	}
}

// 0808B0A0: Register Eq_4 runtime.uint64tofloat64(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.makemap
//      runtime.mapassign
//      runtime.hashGrow
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.nextSample
//      runtime.gcinit
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      reflect.cvtUintFloat
Eq_4 runtime.uint64tofloat64(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	runtime.uint32tofloat64();
	runtime.uint32tofloat64();
	return ecx_7;
}

// 0808B110: void runtime._d2v(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_82041) dwArg04, Stack real64 rArg08)
// Called from:
//      runtime.float64toint64
//      runtime.float64touint64
void runtime._d2v(struct Eq_2 * gs, struct Eq_82041 * dwArg04, real64 rArg08)
{
	uint32 dwArg0C = SLICE(rArg08, word32, 32);
	uint32 dwArg08 = (word32) rArg08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ebx_24 = dwArg0C >> 0x14 & 0x07FF;
	Eq_82171 ecx_27 = 0x0433 - ebx_24;
	uint32 edx_121 = dwArg08;
	uint32 eax_126 = dwArg0C & 0x000FFFFF | 0x00100000;
	byte cl_97 = (byte) ecx_27;
	if (ecx_27 >= 0x00)
	{
		if (ecx_27 < 0x20)
		{
			if (ecx_27 != 0x00)
			{
				ui32 ebx_103 = 0x00 - (ecx_27 < 0x20);
				up32 ebx_109 = 0x20 - ecx_27;
				edx_121 = dwArg08 >> cl_97 & ebx_103 | eax_126 << (byte) ebx_109 & 0x00 - (ebx_109 < 0x20);
				eax_126 = eax_126 >> (byte) ecx_27 & ebx_103;
			}
		}
		else
		{
			if (ecx_27 != 0x20)
			{
				uint32 edx_74;
				if (ecx_27 < 0x40)
					edx_74 = 0x00 - (ecx_27 < 0x40) & eax_126 >> (byte) ((word32) ecx_27 - 32);
				else
					edx_74 = 0x00;
				eax_126 = edx_74;
			}
			edx_121 = eax_126;
			eax_126 = 0x00;
		}
	}
	else if (ebx_24 <= 0x043E)
	{
		byte cl_47 = (byte) (ebx_24 - 0x0433);
		ui32 ebp_51 = 0x00 - (ebx_24 < 1107);
		up32 ecx_56 = 1107 - ebx_24;
		edx_121 = dwArg08 << cl_47 & ebp_51;
		eax_126 = eax_126 << cl_47 & ebp_51 | dwArg08 >> (byte) ecx_56 & 0x00 - (ecx_56 < 0x20);
	}
	else
	{
		runtime.float64touint32();
		eax_126 = dwLoc0C;
		edx_121 = 0x00;
	}
	if (dwArg0C >> 0x1F << 0x1F != 0x00)
	{
		if (edx_121 != 0x00)
		{
			edx_121 = -edx_121;
			eax_126 = ~eax_126;
		}
		else
			eax_126 = -eax_126;
	}
	dwArg04->dw0000 = edx_121;
	dwArg04->dw0004 = eax_126;
}

// 0808B230: Register uint32 runtime.uint64div(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime/debug.setGCPercent
//      runtime.(*gcControllerState).startCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.itoaDiv
//      runtime.fmtNSAsMS
//      runtime.printuint
//      strconv.(*decimal).Assign
//      strconv.(*extFloat).ShortestDecimal
//      strconv.formatBits
//      fmt.(*fmt).fmt_integer
uint32 runtime.uint64div(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 != 0x00 || dwArg10 != 0x00)
		return runtime.dodiv(ebx, esi, gs, dwArg04, dwArg0C, dwArg10);
	bool Z_50 = SLICE(cond(dwArg0C), bool, 2);
	if (dwArg0C == 0x00)
	{
		runtime.panicdivide(gs);
		Z_50 = SLICE(cond(dwArg0C), bool, 2);
	}
	if (!Z_50)
		return (uint32) ((uint64) (uint32) dwArg04 % dwArg0C);
	runtime.panicdivide(gs);
}

// 0808B2D0: Register uint32 runtime.uint64mod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.itoaDiv
//      runtime.printuint
uint32 runtime.uint64mod(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 != 0x00 || dwArg10 != 0x00)
		return runtime.dodiv(ebx, esi, gs, dwArg04, dwArg0C, dwArg10);
	bool Z_50 = SLICE(cond(dwArg0C), bool, 2);
	if (dwArg0C == 0x00)
	{
		runtime.panicdivide(gs);
		Z_50 = SLICE(cond(dwArg0C), bool, 2);
	}
	if (!Z_50)
		return (uint32) ((uint64) (uint32) dwArg04 % dwArg0C);
	runtime.panicdivide(gs);
}

// 0808B370: void runtime.int64div(Register Eq_40550 ebx, Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_59300 qwArg04, Stack Eq_59301 qwArg0C)
// Called from:
//      runtime.schedtrace
//      runtime.timerproc
//      runtime.goroutineheader
void runtime.int64div(Eq_40550 ebx, ui32 edi, struct Eq_2 * gs, Eq_59300 qwArg04, Eq_59301 qwArg0C)
{
	Eq_4 dwArg04 = (word32) qwArg04;
	int32 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_4 dwArg0C = (word32) qwArg0C;
	Eq_4 dwArg10 = SLICE(qwArg0C, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ebx_26 = SEQ(ebx_24_8, dwArg04 >> 0x1F == dwArg08);
	ui24 eax_24_8_59 = SLICE(dwArg04 >> 0x1F, word24, 8);
	ui24 edx_24_8_107 = SLICE(dwArg08, word24, 8);
	edx_24_8_107 = SLICE(dwArg08, word24, 8);
	ui24 ebx_24_8_54 = SLICE(ebx_26 & 0x01, word24, 8);
	if ((byte) (ebx_26 & 0x01) != 0x00)
	{
		ui32 ebx_42 = SEQ(SLICE(dwArg0C >> 0x1F, word24, 8), dwArg0C >> 0x1F == dwArg10);
		ebx_24_8_54 = SLICE(ebx_42 & 0x01, word24, 8);
		if ((byte) (ebx_42 & 0x01) != 0x00)
		{
			if (dwArg04 == 0x80000000 && dwArg0C == ~0x00)
				return;
			bool Z_202 = SLICE(cond(dwArg0C), bool, 2);
			if (dwArg0C == 0x00)
			{
				runtime.panicdivide(gs);
				Z_202 = SLICE(cond(dwArg0C), bool, 2);
			}
			if (!Z_202)
				return;
			runtime.panicdivide(gs);
		}
	}
	Eq_4 eax_118;
	byte bl_67 = (byte) (SEQ(ebx_24_8_54, Test(ULT,false)) & SEQ(eax_24_8_59, dwArg08 == 0x00) | SEQ(eax_24_8_59, dwArg08 < 0x00));
	if (bl_67 != 0x00)
		eax_118 = (word32) (0x00 - qwArg04);
	else
		eax_118 = dwArg04;
	Eq_4 ebp_139;
	Eq_4 edx_138;
	ui32 edi_116 = SEQ(SLICE(edi, word24, 8), Test(ULT,false)) & SEQ(edx_24_8_107, dwArg10 == 0x00) | SEQ(edx_24_8_107, dwArg10 < 0x00);
	byte al_121 = (byte) edi_116;
	if ((byte) edi_116 != 0x00)
	{
		ui64 ebp_edx_254 = 0x00 - qwArg0C;
		edx_138 = (word32) ebp_edx_254;
		ebp_139 = SLICE(ebp_edx_254, word32, 32);
	}
	else
	{
		edx_138 = dwArg0C;
		ebp_139 = dwArg10;
	}
	runtime.dodiv(ebx, esi, gs, eax_118, edx_138, ebp_139);
}

// 0808B4F0: void runtime.int64mod(Register Eq_40550 ebx, Register word32 edi, Register (ptr32 Eq_2) gs, Stack Eq_40532 qwArg04, Stack Eq_40430 qwArg0C)
// Called from:
//      runtime.blocksampled
//      sync.event
void runtime.int64mod(Eq_40550 ebx, word32 edi, struct Eq_2 * gs, Eq_40532 qwArg04, Eq_40430 qwArg0C)
{
	Eq_4 dwArg04 = (word32) qwArg04;
	int32 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_4 dwArg0C = (word32) qwArg0C;
	Eq_4 dwArg10 = SLICE(qwArg0C, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ebx_26 = SEQ(ebx_24_8, dwArg08 == dwArg04 >> 0x1F);
	ui24 eax_24_8_59 = SLICE(dwArg04 >> 0x1F, word24, 8);
	ui24 edx_24_8_107 = SLICE(dwArg08, word24, 8);
	edx_24_8_107 = SLICE(dwArg08, word24, 8);
	ui24 ebx_24_8_54 = SLICE(ebx_26 & 0x01, word24, 8);
	if ((byte) (ebx_26 & 0x01) != 0x00)
	{
		ui32 ebx_42 = SEQ(SLICE(dwArg0C >> 0x1F, word24, 8), dwArg10 == dwArg0C >> 0x1F);
		ebx_24_8_54 = SLICE(ebx_42 & 0x01, word24, 8);
		if ((byte) (ebx_42 & 0x01) != 0x00)
		{
			bool Z_184 = SLICE(cond(dwArg0C), bool, 2);
			if (dwArg0C == 0x00)
			{
				runtime.panicdivide(gs);
				Z_184 = SLICE(cond(dwArg0C), bool, 2);
			}
			if (!Z_184)
				return;
			runtime.panicdivide(gs);
		}
	}
	Eq_4 eax_118;
	byte bl_67 = (byte) (SEQ(ebx_24_8_54, Test(ULT,false)) & SEQ(eax_24_8_59, dwArg08 == 0x00) | SEQ(eax_24_8_59, dwArg08 < 0x00));
	if (bl_67 != 0x00)
		eax_118 = (word32) (0x00 - qwArg04);
	else
		eax_118 = dwArg04;
	Eq_4 ebp_131;
	Eq_4 edx_130;
	if ((byte) (SEQ(SLICE(edi, word24, 8), Test(ULT,false)) & SEQ(edx_24_8_107, dwArg10 == 0x00) | SEQ(edx_24_8_107, dwArg10 < 0x00)) != 0x00)
	{
		ui64 ebp_edx_230 = 0x00 - qwArg0C;
		edx_130 = (word32) ebp_edx_230;
		ebp_131 = SLICE(ebp_edx_230, word32, 32);
	}
	else
	{
		edx_130 = dwArg0C;
		ebp_131 = dwArg10;
	}
	runtime.dodiv(ebx, esi, gs, eax_118, edx_130, ebp_131);
}

// 0808B640: Register Eq_4 runtime.dodiv(Register Eq_40550 ebx, Register word32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 qwArg04, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.uint64div
//      runtime.uint64mod
//      runtime.int64div
//      runtime.int64mod
Eq_4 runtime.dodiv(Eq_40550 ebx, word32 esi, struct Eq_2 * gs, Eq_4 qwArg04, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	Eq_4 dwArg04 = (word32) qwArg04;
	Eq_4 dwArg08 = SLICE(qwArg04, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 esi_120 = SEQ(SLICE(esi, word24, 8), dwArg10 == dwArg08) & SEQ(ebx_24_8, dwArg0C > dwArg04);
	if ((byte) (SEQ(ebx_24_8, dwArg10 > dwArg08) | esi_120) != 0x00)
		return dwArg04;
	if (dwArg10 != 0x00)
	{
		ui24 ebx_24_8_95 = SLICE(runtime._mul64by32(fp - 0x08, dwArg0C, dwArg10, (uint32) ((uint64) (uint32) dwArg08 /u dwArg10)), word24, 8);
		if (dwLoc24 == 0x00)
		{
			ui32 esi_112 = SEQ(SLICE(esi_120, word24, 8), dwArg04 < 0x00) & SEQ(ebx_24_8_95, dwArg08 == 0x00) | SEQ(ebx_24_8_95, dwArg08 < 0x00);
			esi_120 = esi_112;
			if ((byte) esi_112 == 0x00)
				return dwArg08;
		}
		runtime.slowdodiv(ebx, esi_120, gs, dwArg04, dwArg08, dwArg0C, dwArg10);
		return dwLoc18;
	}
	else
	{
		Eq_4 ebp_165;
		if (dwArg08 < dwArg0C)
		{
			ebp_165 = dwArg08;
			return runtime._div64by32(SEQ(ebp_165, dwArg04), dwArg0C, fp - 0x10);
		}
		else
		{
			bool Z_171 = SLICE(cond(dwArg0C), bool, 2);
			if (dwArg0C == 0x00)
			{
				runtime.panicdivide(gs);
				Z_171 = SLICE(cond(dwArg0C), bool, 2);
			}
			if (Z_171)
				runtime.panicdivide(gs);
			else
			{
				ebp_165 = dwArg08 - dwArg0C *s (uint32) ((uint64) ((uint32) dwArg08) /u dwArg0C) - (dwArg04 < 0x00);
				return runtime._div64by32(SEQ(ebp_165, dwArg04), dwArg0C, fp - 0x10);
			}
		}
	}
}

// 0808B830: void runtime.slowdodiv(Register Eq_40550 ebx, Register ui32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.dodiv
void runtime.slowdodiv(Eq_40550 ebx, ui32 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_25 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	if ((byte) (SEQ(ecx_24_8_25, dwArg10 == 0x00) & SEQ(ebx_24_8, dwArg0C == 0x00)) != 0x00)
		runtime.panicdivide(gs);
	Eq_4 esi_248;
	Eq_4 ebx_245;
	ui24 ecx_24_8_109 = SLICE(dwArg08, word24, 8);
	ecx_24_8_109 = SLICE(dwArg08, word24, 8);
	if ((byte) (SEQ(SLICE(esi, word24, 8), Test(UGE,false)) & SEQ(ebx_24_8, dwArg08 == 0x80000000) | SEQ(ebx_24_8, dwArg08 > 0x80000000)) != 0x00)
	{
		ebx_245.u0 = 0x80000000;
		esi_248.u0 = 0x00;
	}
	else
	{
		ebx_245 = dwArg08;
		esi_248 = dwArg04;
	}
	int32 edi_134 = 0x00;
	uint64 eax_edx_301 = SEQ(dwArg10, dwArg0C);
	while (true)
	{
		Eq_4 eax_90 = SLICE(eax_edx_301, word32, 32);
		Eq_4 edx_95 = (word32) eax_edx_301;
		ui24 ebx_24_8_105 = SLICE(dwArg04, word24, 8);
		if ((byte) (SEQ(ecx_24_8_109, eax_90 == ebx_245) & SEQ(ebx_24_8_105, edx_95 < esi_248) | SEQ(ebx_24_8_105, eax_90 < ebx_245)) == 0x00)
			break;
		++edi_134;
		ecx_24_8_109 = SLICE(dwArg08, word24, 8);
		eax_edx_301 = SEQ(eax_90 << 0x01 | edx_95 >> 0x1F, edx_95 << 0x01);
	}
	ui32 ebp_144 = 0x00;
	uint32 esi_145 = 0x00;
	ui64 ecx_ebx_293 = SEQ(dwArg08, dwArg04);
	uint64 eax_edx_296 = eax_edx_301;
	while (true)
	{
		uint32 edx_183 = (word32) eax_edx_296;
		uint32 eax_171 = SLICE(eax_edx_296, word32, 32);
		uint32 ecx_159 = SLICE(ecx_ebx_293, word32, 32);
		uint32 ebx_157 = (word32) ecx_ebx_293;
		if (edi_134 < 0x00)
			break;
		ui32 esi_167 = esi_145 >> 0x1F | ebp_144 << 0x01;
		ui24 ebx_24_8_179 = SLICE(esi_167, word24, 8);
		uint32 ebp_170 = esi_145 << 0x01;
		ui64 ecx_ebx_260 = ecx_ebx_293;
		if ((byte) (SEQ(SLICE(edi_134, word24, 8), ebx_157 >= edx_183) & SEQ(ebx_24_8_179, ecx_159 == eax_171) | SEQ(ebx_24_8_179, ecx_159 > eax_171)) != 0x00)
		{
			ecx_ebx_260 = ecx_ebx_293 - eax_edx_296;
			ebp_170 = esi_145 << 0x01 | 0x01;
		}
		--edi_134;
		esi_145 = ebp_170;
		ebp_144 = esi_167;
		ecx_ebx_293 = ecx_ebx_260;
		eax_edx_296 = SEQ(eax_171 >> 0x01, edx_183 >> 0x01 | eax_171 << 0x1F);
	}
}

// 0808B990: void runtime.writeErr(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gwrite
void runtime.writeErr(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		word32 edx_53;
		word32 ebx_54;
		runtime.write(out edx_53, out ebx_54);
	}
}

// 0808B9E0: void runtime.cgocallbackg1.func1(Register (ptr32 Eq_82856) gs, Stack (ptr32 Eq_82857) dwArg04)
void runtime.cgocallbackg1.func1(struct Eq_82856 * gs, struct Eq_82857 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	--dwArg04->dw00BC;
}

// 0808BA20: void runtime.cgoCheckWriteBarrier.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.cgoCheckWriteBarrier.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_129;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_129, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_82910 * esp_24 = esp_19 - 0x10;
	esp_24->t0008 = *((word32) edx + 4);
	esp_24->t000C = *((word32) edx + 8);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 0x080E2E90;
	esp_24->t0004.u0 = 0x13;
	runtime.printstring(gs);
	runtime.printsp(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_63;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_63);
	runtime.printsp(gs);
	esp_24->t0000.u0 = 0x080E2689;
	esp_24->t0004.u0 = 0x10;
	runtime.printstring(gs);
	runtime.printsp(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	word32 esi_130;
	runtime.printhex(esi_63, gs, esp_24->t0000, esp_24->t0004, out esi_130);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135159152;
	esp_24->t0004.u0 = 0x24;
	runtime.throw(gs);
}

// 0808BAE0: void runtime.cgoCheckTypedBlock.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.cgoCheckTypedBlock.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_64;
		word32 ebx_63;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_63, out esi_64);
	}
	runtime.cgoCheckUsingType(gs, *((word32) edx + 4), *((word32) edx + 8), *((word32) edx + 0x0C), *((word32) edx + 16));
}

// 0808BB20: void runtime.cgoCheckTypedBlock.func2(Register (ptr32 Eq_2) gs)
void runtime.cgoCheckTypedBlock.func2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808BB60: void runtime.cgoCheckBits.func1(Register (ptr32 Eq_2) gs)
void runtime.cgoCheckBits.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808BBA0: void runtime.chansend.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.chansend.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_61;
		word32 ebx_60;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_60, out esi_61);
	}
	word32 edx_62;
	word32 ebx_63;
	runtime.unlock(gs, (word32) *((word32) edx + 4) + 48, out edx_62, out ebx_63);
}

// 0808BBD0: void runtime.chanrecv.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.chanrecv.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_61;
		word32 ebx_60;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_60, out esi_61);
	}
	word32 edx_62;
	word32 ebx_63;
	runtime.unlock(gs, (word32) *((word32) edx + 4) + 48, out edx_62, out ebx_63);
}

// 0808BC00: void runtime.(*mcache).nextFree.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Register Eq_661 xmm1, Stack Eq_4 dwArg00)
void runtime.(*mcache).nextFree.func1(Eq_4 edx, struct Eq_2 * gs, Eq_661 xmm1, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_65;
		word32 ebx_64;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_64, out esi_65);
	}
	runtime.(*mcache).refill(gs, xmm1, *((word32) edx + 4), (byte) (word32) *((word32) edx + 8));
}

// 0808BC40: void runtime.mallocgc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm1, Stack Eq_4 dwArg00)
void runtime.mallocgc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm1, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_79;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_79, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.largeAlloc(esi, gs, xmm1, **((word32) edx + 8), (byte) (word32) *((word32) edx + 0x0C));
	*eax_26 = dwLoc08;
}

// 0808BC90: void runtime.persistentalloc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.persistentalloc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_96;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_96, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.persistentalloc1(esi, gs, *((word32) edx + 8), *((word32) edx + 0x0C), *((word32) edx + 16));
	if (g_t81576F0 == 0x00)
		*eax_26 = dwLoc08;
	else
		runtime.writebarrierptr(eax_26, dwLoc08);
}

// 0808BD00: void runtime.writebarrierptr_prewrite1.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.writebarrierptr_prewrite1.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_125;
		word32 ebx_124;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_124, out esi_125);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_26 = *((word32) edx + 8);
	Eq_4 edx_27 = *((word32) edx + 0x0C);
	if (*((word32) eax_25 + 92) == 0x00 && ((byte) ((word32) g_b8159250) != 0x00 && ((byte) ((word32) (*((word32) eax_25 + 0x008E))) == 0x00 && ecx_26 != 0x00)))
	{
		Eq_4 ebx_45 = g_t81493A8;
		if (ecx_26 >= ebx_45 && ecx_26 < g_t81493AC)
		{
			Eq_4 esi_52 = g_t8149108;
			uint32 ecx_54 = ecx_26 - ebx_45;
			if (ecx_54 >> 0x0D >= g_t814910C)
				runtime.panicindex(gs);
			struct Eq_83332 * ecx_58 = *((word32) esi_52 + (ecx_54 >> 0x0D) * 0x04);
			if (ecx_58 != null && (ecx_26 >= ecx_58->t000C && (ecx_26 < ecx_58->t0050 && (byte) ((word32) ecx_58->b003C) == 0x01)))
				runtime.throw(gs);
		}
	}
	*((word32) eax_25 + 0x008E) = 0x01;
	runtime.gcmarkwb_m(gs, edx_27, ecx_26);
}

// 0808BDE0: void runtime.writebarrierptr.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.writebarrierptr.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_109;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_109, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_83381 * esp_24 = esp_19 - 0x10;
	esp_24->t000C = *((word32) edx + 4);
	esp_24->t0008 = *((word32) edx + 8);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 135152254;
	esp_24->t0004.u0 = 0x1A;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	runtime.printpointer(gs);
	esp_24->t0000.u0 = 0x080E0E2E;
	esp_24->t0004.u0 = 0x03;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	word32 esi_110;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_110);
	esp_24->t0000.u0 = 0x080E0D9C;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135153504;
	esp_24->t0004.u0 = 0x1C;
	runtime.throw(gs);
}

// 0808BEA0: void runtime.writebarrierptr_prewrite.func1(Register (ptr32 Eq_2) gs)
void runtime.writebarrierptr_prewrite.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808BEE0: void runtime.typedslicecopy.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.typedslicecopy.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_382;
		word32 esi_383;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_382, out esi_383);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_27 = *((word32) edx + 8);
	Eq_4 ebx_29 = *((word32) edx + 0x0C);
	Eq_4 edx_31 = *((word32) edx + 16);
	Eq_4 ebp_33 = *eax_25;
	Eq_4 esi_34 = *ecx_27;
	if (ebp_33 < esi_34)
	{
		int32 edi_38 = **edx_31;
		if (ebx_29 *s edi_38 + ebp_33 >u esi_34)
		{
			word32 esi_140 = esi_34 + edi_38 *s (ebx_29 - 0x01);
			if (g_t81576F0 == 0x00)
				*ecx_27 = esi_140;
			else
				runtime.writebarrierptr(ecx_27, esi_140);
			Eq_4 ebx_169 = (word32) *eax_25 + *(*edx_31) *s (ebx_29 - 0x01);
			if (g_t81576F0 == 0x00)
				*eax_25 = ebx_169;
			else
				runtime.writebarrierptr(eax_25, ebx_169);
			word32 ebx_188 = 0x01;
			while (true)
			{
				word32 edi_207;
				word32 esi_209;
				runtime.typedmemmove(*edx_31, *ecx_27, *eax_25, out esi_209, out edi_207);
				if (ebx_188 + 0x00 >= ebx_29)
					break;
				word32 dwLoc18_348 = ebx_188 + 0x01;
				Eq_4 edi_230 = *ecx_27 - *(*edx_31);
				if (g_t81576F0 == 0x00)
					*ecx_27 = edi_230;
				else
					runtime.writebarrierptr(ecx_27, edi_230);
				Eq_4 ecx_258 = *eax_25 - *(*edx_31);
				if (g_t81576F0 == 0x00)
					*eax_25 = ecx_258;
				else
					runtime.writebarrierptr(eax_25, ecx_258);
				ebx_188 = dwLoc18_348;
			}
			return;
		}
	}
	word32 ebx_135 = 0x01;
	while (true)
	{
		word32 edi_385;
		word32 esi_384;
		runtime.typedmemmove(*edx_31, *ecx_27, *eax_25, out esi_384, out edi_385);
		if (ebx_135 + 0x00 >= ebx_29)
			break;
		word32 dwLoc14_322 = ebx_135 + 0x01;
		word32 ebx_82 = Mem75[Mem75[edx_31 + 0x00:word32] + 0x00:word32] + Mem75[ecx_27 + 0x00:word32];
		if (g_t81576F0 == 0x00)
			*ecx_27 = ebx_82;
		else
			runtime.writebarrierptr(ecx_27, ebx_82);
		word32 ecx_109 = Mem102[eax_25 + 0x00:word32] + Mem102[Mem102[edx_31 + 0x00:word32] + 0x00:word32];
		if (g_t81576F0 == 0x00)
			*eax_25 = ecx_109;
		else
			runtime.writebarrierptr(eax_25, ecx_109);
		ebx_135 = dwLoc14_322;
	}
}

// 0808C120: void runtime.freemcache.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.freemcache.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_114;
		word32 ebx_113;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_113, out esi_114);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.(*mcache).releaseAll(gs, eax_26);
	word32 ebp_115;
	word32 esi_116;
	word32 edi_117;
	runtime.lock(runtime.stackcache_clear(gs, eax_26), gs, 0x081488E0, out ebp_115, out esi_116, out edi_117);
	runtime.purgecachedstats(gs, eax_26);
	g_dw814B57C -= g_dw814B564;
	*eax_26 = g_t814B570;
	g_t814B570 = eax_26;
	word32 edx_118;
	word32 ebx_119;
	runtime.unlock(gs, 0x081488E0, out edx_118, out ebx_119);
}

// 0808C1C0: void runtime.SetFinalizer.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.SetFinalizer.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_56;
		word32 ebx_55;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_55, out esi_56);
	}
	runtime.removefinalizer(gs, *((word32) *((word32) edx + 4) + 4));
}

// 0808C1F0: void runtime.SetFinalizer.func2(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.SetFinalizer.func2(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (true)
	{
		byte bLoc04_82 = (byte) dwLoc04;
		if (fp > *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
			break;
		word32 ebx_87;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_87, out esi);
	}
	runtime.addfinalizer(esi, gs, *((word32) *((word32) edx + 4) + 4), *((word32) *((word32) edx + 8) + 4), *((word32) edx + 0x0C), *((word32) edx + 16), *((word32) edx + 20));
	if ((byte) (word32) bLoc04_82 != 0x00)
		return;
	runtime.throw(gs);
}

// 0808C260: void runtime.(*gcControllerState).findRunnableGCWorker.func1(Register Eq_22804 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
void runtime.(*gcControllerState).findRunnableGCWorker.func1(Eq_22804 ebx, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 4);
	up32 edx_19 = *dwArg04;
	if ((byte) (SEQ(SLICE(edx_19, word24, 8), edx_19 > 0x00) & SEQ(ebx_24_8, ecx_18 == 0x00) | SEQ(SLICE(ecx_18, word24, 8), ecx_18 > 0x00)) == 0x00)
		return;
	word32 ebp_142;
	word32 ebx_141;
	if ((byte) (SEQ(~0x00, Test(UGE,false)) & SEQ(SLICE(runtime/internal/atomic.Xaddint64(dwArg04, ~0x00, ~0x00, out ebx_141, out ebp_142), word24, 8), dwLoc08 == 0x00) | SEQ(SLICE(dwLoc08, word24, 8), dwLoc08 > 0x00)) != 0x00)
		return;
	word32 ebx_143;
	word32 ebp_144;
	runtime/internal/atomic.Xaddint64(dwArg00, 0x01, 0x00, out ebx_143, out ebp_144);
}

// 0808C310: void runtime.gcStart.func1(Register (ptr32 Eq_2) gs, Register Eq_661 xmm2)
void runtime.gcStart.func1(struct Eq_2 * gs, Eq_661 xmm2)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm2_36;
	word128 xmm0_35;
	runtime.finishsweep_m(gs, xmm2, out xmm0_35, out xmm2_36);
}

// 0808C330: void runtime.gcMarkDone.func1.1(Register word32 ebx, Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
void runtime.gcMarkDone.func1.1(word32 ebx, Eq_4 ebp, struct Eq_2 * gs, word32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*gcWork).dispose(ebx_24_8, ebp, gs, dwLoc08, dwArg04 + 0x0950);
}

// 0808C370: void runtime.gcMarkDone.func1(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.gcMarkDone.func1(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.forEachP(esi, gs, 0x080E7C00);
}

// 0808C3A0: void runtime.gcMarkTermination.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.gcMarkTermination.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_60;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_60, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.gcMark(esi, gs, *eax_26, *((word32) eax_26 + 4));
}

// 0808C3E0: void runtime.gcMarkTermination.func2(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm2, Stack Eq_4 dwArg00)
void runtime.gcMarkTermination.func2(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm2, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_242;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_242, out esi);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_27 = g_t81455EC;
	g_t81456B4 = g_t81455E8;
	g_t81456B8 = ecx_27;
	if (g_dw815772C > 0x00)
	{
		runtime.gcResetMarkState(gs);
		runtime.initCheckmarks(esi, gs);
		Eq_4 ecx_54 = *((word32) eax_25 + 4);
		esi = runtime.gcMark(esi, gs, *eax_25, ecx_54);
		runtime.clearCheckmarks(esi, gs);
		dwLoc08 = ecx_54;
	}
	runtime.setGCPhase(0x00);
	Eq_4 eax_85 = g_t814563C;
	Eq_661 xmm2_105 = runtime.gcSweep(esi, gs, xmm0, xmm2, eax_85);
	if (g_dw8157740 > 0x01)
	{
		runtime.nanotime();
		*eax_25 = eax_85;
		*((word32) eax_25 + 4) = dwLoc08;
		runtime.gcResetMarkState(gs);
		Eq_661 xmm0_144;
		Eq_661 xmm2_146;
		Eq_4 esi_142 = runtime.finishsweep_m(gs, xmm2_105, out xmm0_144, out xmm2_146);
		runtime.setGCPhase(0x02);
		Eq_4 esi_169 = runtime.gcMark(esi_142, gs, *eax_25, *((word32) eax_25 + 4));
		runtime.setGCPhase(0x00);
		runtime.gcSweep(esi_169, gs, xmm0_144, xmm2_146, g_t814563C);
	}
}

// 0808C4E0: void runtime.gcBgMarkWorker.func1(Register (ptr32 Eq_84113) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_84115) dwArg08)
void runtime.gcBgMarkWorker.func1(struct Eq_84113 * gs, Eq_4 dwArg04, struct Eq_84115 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	struct Eq_84128 * ecx_18 = dwArg08->ptr0000;
	struct Eq_84121 * edx_20 = gs->ptr0000->ptrFFFFFFFC;
	word32 ebx_21 = ecx_18->dw0078;
	ecx_18->dw0078 = ebx_21 - 0x01;
	if (ebx_21 == 0x01 && (byte) ((word32) edx_20->b006C) != 0x00)
		edx_20->ptr0008 = ~0x0521;
	word32 ecx_34 = dwArg08->dw0004;
	if (ecx_34 == 0x00)
		return;
	dwArg08->dw0004 = 0x00;
	runtime.(*guintptr).cas(ecx_34 + 0x0948, 0x00, dwArg04);
	if ((byte) (word32) bLoc04 != 0x00)
		;
}

// 0808C580: void runtime.gcBgMarkWorker.func2(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.gcBgMarkWorker.func2(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_274;
		word32 ebx_273;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_273, out esi_274);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	Eq_4 ecx_28 = *((word32) edx + 8);
	runtime.casgstatus(eax_26, 0x02, 0x04);
	Eq_4 ecx_46 = *((word32) ecx_28 + 0x094C);
	if (ecx_46 == 0x00)
	{
		Eq_4 esi_105;
		word32 ebp_275;
		runtime.gcDrain(gs, (word32) ecx_28 + 0x0950, 0x05, out ebp_275, out esi_105);
		if ((byte) (word32) *((word32) eax_26 + 0x006C) != 0x00)
		{
			word32 edi_280;
			word32 ebp_278;
			word32 esi_279;
			runtime.lock(esi_105, gs, 135549936, out ebp_278, out esi_279, out edi_280);
			while (true)
			{
				runtime.runqget(gs, ecx_28);
				if (0x05 == 0x00)
					break;
				*(word32 *) 0x6D = 0x00;
				Eq_4 ecx_197 = g_t814541C;
				if (ecx_197 != 0x00)
					((word32) ecx_197 + 0x0068)->u0 = 0x05;
				else
					g_t8145418.u0 = 0x05;
				g_t814541C.u0 = 0x05;
				g_t8145420 = (word32) g_t8145420 + 1;
			}
			word32 ebx_282;
			word32 edx_281;
			runtime.unlock(gs, 135549936, out edx_281, out ebx_282);
		}
		word32 esi_277;
		word32 ebp_276;
		runtime.gcDrain(gs, (word32) ecx_28 + 0x0950, 0x06, out ebp_276, out esi_277);
	}
	else if (ecx_46 != 0x01)
	{
		if (ecx_46 != 0x02)
			runtime.throw(gs);
		word32 ebp_285;
		word32 esi_286;
		runtime.gcDrain(gs, (word32) ecx_28 + 0x0950, 0x0D, out ebp_285, out esi_286);
	}
	else
	{
		word32 esi_284;
		word32 ebp_283;
		runtime.gcDrain(gs, (word32) ecx_28 + 0x0950, 0x05, out ebp_283, out esi_284);
	}
	runtime.casgstatus(eax_26, 0x04, 0x02);
}

// 0808C710: void runtime.gcMarkRootPrepare.func1(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkRootPrepare
void runtime.gcMarkRootPrepare.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0808C740: void runtime.markroot.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs)
void runtime.markroot.func1(Eq_4 edx, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_199;
		word32 esi_200;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_199, out esi_200);
		esp_19.u0 = <invalid>;
	}
	Eq_84352 bl_46;
	struct Eq_84353 * esp_24 = esp_19 - 0x1C;
	Eq_4 eax_27 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_4 ecx_101 = *((word32) edx + 4);
	esp_24->t0014 = ecx_101;
	esp_24->t0018 = *((word32) edx + 8);
	Eq_4 eax_32 = *((word32) eax_27 + 84);
	esp_24->t0010 = eax_32;
	if (ecx_101 != eax_32)
		bl_46.u0 = 0x00;
	else
	{
		esp_24->t0000 = eax_32;
		runtime.readgstatus(esp_24->t0000);
		Eq_4 esp_38 = <invalid>;
		bl_46 = *((word32) esp_38 + 4) == 0x02;
		eax_32 = *((word32) esp_38 + 16);
		ecx_101 = *((word32) esp_38 + 20);
	}
	if (bl_46 != 0x00)
	{
		runtime.casgstatus(eax_32, 0x02, 0x04);
		((word32) dwLoc0C + 100)->u0 = 0x17;
		if (g_t81576F0 == 0x00)
			((word32) dwLoc0C + 96)->u0 = 0x080E390A;
		else
			runtime.writebarrierptr((word32) dwLoc0C + 96, 0x080E390A);
		ecx_101 = dwLoc08;
	}
	runtime.scang(gs, ecx_101);
	if ((byte) (word32) bl_46 != 0x00)
		runtime.casgstatus(dwLoc0C, 0x04, 0x02);
}

// 0808C850: void runtime.gcAssistAlloc.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs)
void runtime.gcAssistAlloc.func1(Eq_4 edx, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_57;
		word32 esi_58;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_57, out esi_58);
		esp_19.u0 = <invalid>;
	}
	struct Eq_84468 * esp_24 = esp_19 - 0x0C;
	Eq_4 ecx_27 = *((word32) edx + 0x0C);
	Eq_4 edx_28 = *((word32) edx + 8);
	esp_24->t0000 = *((word32) edx + 4);
	esp_24->t0004 = edx_28;
	esp_24->t0008 = ecx_27;
	runtime.gcAssistAlloc1(gs, esp_24->tFFFFFFFC, esp_24->t0000, esp_24->t0004, esp_24->t0008, esp_24->dw000C);
}

// 0808C890: void runtime.scanstack.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_29985) dwArg04)
void runtime.scanstack.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_29985 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_66;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_66, out esi);
	}
	runtime.scanframeworker(esi, gs, dwArg04, *((word32) edx + 8));
}

// 0808C8D0: void runtime.gosweepone.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Register Eq_661 xmm2)
void runtime.gosweepone.func1(Eq_4 edx, struct Eq_2 * gs, Eq_661 xmm2)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_63;
		word32 ebx_62;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_62, out esi_63);
		esp_19.u0 = <invalid>;
	}
	struct Eq_84562 * esp_24 = esp_19 - 0x08;
	esp_24->t0004 = *((word32) edx + 4);
	word128 xmm0_64;
	word128 xmm2_65;
	runtime.sweepone(gs, xmm2, esp_24->ptrFFFFFFFC, out xmm0_64, out xmm2_65);
	*dwLoc04 = dwLoc08;
}

// 0808C910: void runtime.getempty.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.getempty.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_72;
		word32 ebx_71;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_71, out esi_72);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.(*mheap).allocManual(gs);
	*eax_26 = dwLoc08;
}

// 0808C970: void runtime.freeSomeWbufs.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.freeSomeWbufs.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_153;
		word32 esi_154;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_153, out esi_154);
	}
	word32 ecx_152 = (word32) *((word32) edx + 4);
	byte cl_29 = (byte) ecx_152;
	Eq_4 eax_31 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
	int32 edx_33 = 0x00;
	while (true)
	{
		byte cl_39 = (byte) ecx_152;
		if (edx_33 >= 0x40 || cl_39 != 0x00 && (byte) ((word32) (*((word32) eax_31 + 0x006C))) != 0x00)
			break;
		Eq_4 ebx_51 = g_t81455D4;
		if (ebx_51 == 0x00)
			return;
		runtime.(*mSpanList).remove(gs, 135550420, ebx_51);
		runtime.(*mheap).freeManual(gs, ebx_51, &g_t8158218);
		++edx_33;
		ecx_152 = (word32) cl_29;
	}
}

// 0808CA20: void runtime.(*mheap).alloc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_661 xmm2, Stack Eq_4 dwArg00)
void runtime.(*mheap).alloc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_661 xmm2, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_86;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_86, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.(*mheap).alloc_m(esi, gs, xmm2, *((word32) edx + 8), *((word32) edx + 0x0C), (byte) (word32) *((word32) edx + 16), (byte) (word32) *((word32) edx + 0x0011));
	*eax_26 = dwLoc08;
}

// 0808CA80: void runtime.(*mheap).freeSpan.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.(*mheap).freeSpan.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_187;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_187, out esi);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_30 = *((word32) edx + 8);
	Eq_4 edx_32 = *((word32) edx + 0x0C);
	Eq_4 ebx_36 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_4 ebp_45;
	word32 esi_188;
	word32 edi_189;
	runtime.lock(esi, gs, eax_25, out ebp_45, out esi_188, out edi_189);
	uint32 edx_56 = (word32) *((word32) *((word32) ebx_36 + 0x00B8) + 4) + g_dw81597B8;
	uint32 ecx_58 = g_dw81597BC;
	g_dw81597B8 = edx_56;
	g_dw81597BC = (uint32) ((bool) (edx_56 < 0x00) + ecx_58);
	((word32) *((word32) ebx_36 + 0x00B8) + 4)->u0 = 0x00;
	up32 edx_68 = (word32) *((word32) *((word32) ebx_36 + 0x00B8) + 16) + g_dw8159798;
	word32 ecx_70 = g_dw815979C;
	g_dw8159798 = edx_68;
	g_dw815979C = (word32) ((bool) (edx_68 < 0x00) + ecx_70);
	((word32) *((word32) ebx_36 + 0x00B8) + 16)->u0 = 0x00;
	if (edx_32 != 0x00)
	{
		up32 eax_81 = g_dw81581D8;
		word32 ecx_84 = g_dw81581DC;
		g_dw81581D8 = eax_81 + ~0x00;
		g_dw81581DC = (word32) ((bool) (eax_81 < ~0x00) + (ecx_84 + ~0x00));
	}
	if (g_dw81575DC != 0x00)
		runtime.(*gcControllerState).revise(ebp_45, gs, &g_dw8157860);
	runtime.(*mheap).freeSpanLocked(gs, eax_25, ecx_30, 0x01, 0x01, 0x00, 0x00);
	word32 ebx_191;
	word32 edx_190;
	runtime.unlock(gs, eax_25, out edx_190, out ebx_191);
}

// 0808CBC0: void runtime.mProf_Malloc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.mProf_Malloc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_59;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_59, out esi);
	}
	runtime.setprofilebucket(esi, gs, *((word32) edx + 4), *((word32) edx + 8));
}

// 0808CC00: void runtime.tracealloc.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.tracealloc.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_66;
		word32 ebx_65;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_65, out esi_66);
	}
	runtime.traceback(gs);
}

// 0808CC50: void runtime.tracefree.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.tracefree.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_66;
		word32 ebx_65;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_65, out esi_66);
	}
	runtime.traceback(gs);
}

// 0808CCA0: void runtime.futexwakeup.func1(Register Eq_4 edx, Register word32 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.futexwakeup.func1(Eq_4 edx, word32 ebx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	word32 ebx_132 = ebx;
	while (true)
	{
		Eq_363 ebx_24_8_69 = SLICE(ebx_132, word24, 8);
		if (fp > *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
			break;
		word32 esi_135;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_132, out esi_135);
	}
	Eq_4 ecx_28 = *((word32) edx + 8);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_69, gs, SEQ(ecx_28 >> 0x1F, ecx_28));
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0808CD40: void runtime.newdefer.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.newdefer.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_286;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_286, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	Eq_4 ecx_28 = *((word32) edx + 8);
	word32 edi_289;
	word32 ebp_287;
	word32 esi_288;
	runtime.lock(esi, gs, 135550012, out ebp_287, out esi_288, out edi_289);
	while (ecx_28 < 0x05)
	{
		Eq_4 ebx_55 = *((word32) eax_26 + (ecx_28 * 0x0C + 0x0044));
		Eq_4 esi_57 = (word32) eax_26 + 60 + ecx_28 * 0x0C;
		if ((eax_26 + 0x40)[ecx_28 * 0x0C] >= ((ebx_55 >> 0x1F) >>u 0x1F) + ebx_55 >> 0x01)
		{
l0808CEEF:
			word32 edx_290;
			word32 ebx_291;
			runtime.unlock(gs, 135550012, out edx_290, out ebx_291);
			return;
		}
		Eq_4 ebp_66 = g_a8145440[ecx_28 * 0x04];
		Eq_4 edi_67 = ecx_28 * 0x04 + 0x08145440;
		if (ebp_66 == 0x00)
			goto l0808CEEF;
		Eq_4 edi_91 = *((word32) ebp_66 + 24);
		if (g_t81576F0 == 0x00)
		{
			g_a8145440[ecx_28 * 0x04] = (word32) edi_91;
			((word32) ebp_66 + 24)->u0 = 0x00;
		}
		else
		{
			runtime.writebarrierptr(edi_67, edi_91);
			runtime.writebarrierptr((word32) ebp_66 + 24, 0x00);
		}
		Eq_4 ebx_128 = *((word32) eax_26 + (ecx_28 * 0x0C + 0x0044));
		Eq_4 esi_129 = *((word32) eax_26 + (ecx_28 * 0x0C + 64));
		Eq_4 edi_130 = *((word32) eax_26 + (ecx_28 * 0x0C + 60));
		if ((word32) esi_129 + 1 > ebx_128)
		{
			word32 esi_292;
			runtime.growslice(gs, 135033152, edi_130, esi_129, ebx_128, (word32) esi_129 + 1, out esi_292);
			*((word32) eax_26 + (ecx_28 * 0x0C + 0x0044)) = dwLoc28;
			if (g_t81576F0 == 0x00)
				*((word32) eax_26 + (ecx_28 * 0x0C + 60)) = dwLoc30;
			else
				runtime.writebarrierptr(esi_57, dwLoc30);
			esi_129 = dwLoc2C;
			edi_130 = dwLoc30;
		}
		*((word32) eax_26 + (ecx_28 * 0x0C + 64)) = (word32) esi_129 + 1;
		Eq_4 edx_197 = (word32) edi_130 + esi_129 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) edi_130 + esi_129 * 0x04) = ebp_66;
		else
			runtime.writebarrierptr(edx_197, ebp_66);
	}
	runtime.panicindex(gs);
}

// 0808CF20: void runtime.newdefer.func2(Register Eq_4 edx, Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.newdefer.func2(Eq_4 edx, Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_146;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx, out esi_146);
	}
	Eq_4 eax_29;
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_26 = *((word32) edx + 8);
	if (eax_25 <= 0x04)
		eax_29.u0 = 0x20;
	else
		eax_29 = (word32) eax_25 + 28;
	if (eax_29 >= 0x8000)
	{
		if ((byte) eax_29.u0 + 0x00002000 >= eax_29)
			eax_29 = (word32) eax_29 + 0x00001FFF & ~0x1FFF;
		goto l0808CF91;
	}
	if (eax_29 > 1016)
	{
		uint32 eax_47 = (byte) eax_29.u0 - 897;
		if (eax_47 >> 0x07 < 0xF9)
		{
			uint32 eax_52 = (word32) (eax_47 >> 0x07)->b81396E0;
			if (eax_52 < 0x43)
			{
				eax_29 = (word32) g_a8138820[eax_52 * 0x02];
l0808CF91:
				word32 ebx_147;
				word32 edi_149;
				word32 esi_148;
				runtime.mallocgc(ebx, gs, eax_29, g_t8144FC4, 0x01, out ebx_147, out esi_148, out edi_149);
				if (g_t81576F0 == 0x00)
					*ecx_26 = dwLoc08;
				else
					runtime.writebarrierptr(ecx_26, dwLoc08);
				return;
			}
		}
		runtime.panicindex(gs);
	}
	else
	{
		uint32 eax_59 = (byte) eax_29.u0 + 7;
		if (eax_59 >> 0x03 < 0x81)
		{
			uint32 eax_64 = (word32) (eax_59 >> 0x03)->b8138640;
			if (eax_64 < 0x43)
			{
				eax_29 = (word32) g_a8138820[eax_64 * 0x02];
				goto l0808CF91;
			}
		}
		runtime.panicindex(gs);
	}
}

// 0808D040: void runtime.freedefer.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.freedefer.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_245;
		word32 esi_246;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_245, out esi_246);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_27 = *((word32) edx + 8);
	Eq_4 edx_204 = 0x00;
	Eq_4 ebx_162 = 0x00;
	eax_148 = eax_25;
	while (true)
	{
		Eq_4 eax_148;
		if (ecx_27 >= 0x05)
			break;
		Eq_4 ecx_49 = *((word32) eax_148 + (ecx_27 * 0x0C + 0x0044));
		Eq_4 esi_47 = *((word32) eax_148 + (ecx_27 * 0x0C + 60));
		Eq_4 edi_48 = *((word32) eax_148 + (ecx_27 * 0x0C + 64));
		if (edi_48 <= ((ecx_49 >> 0x1F) >>u 0x1F) + ecx_49 >> 0x01)
		{
			word32 edi_249;
			word32 esi_248;
			word32 ebp_247;
			runtime.lock(esi_47, gs, 135550012, out ebp_247, out esi_248, out edi_249);
			Eq_4 esi_78 = g_a8145440[ecx_27 * 0x04];
			Eq_4 edi_79 = ecx_27 * 0x04 + 0x08145440;
			if (g_t81576F0 == 0x00)
			{
				*((word32) edx_204 + 24) = esi_78;
				g_a8145440[ecx_27 * 0x04] = (word32) ebx_162;
			}
			else
			{
				runtime.writebarrierptr((word32) edx_204 + 24, esi_78);
				runtime.writebarrierptr(edi_79, ebx_162);
			}
			word32 edx_250;
			word32 ebx_251;
			runtime.unlock(gs, 135550012, out edx_250, out ebx_251);
			return;
		}
		if (edi_48 - 0x01 >= edi_48)
			runtime.panicindex(gs);
		Eq_4 edx_127 = (esi_47 - 0x04)[edi_48];
		Eq_4 edx_129 = esi_47 - 0x04 + edi_48 * 0x04;
		if (g_t81576F0 == 0x00)
			(esi_47 - 0x04)[edi_48] = 0x00;
		else
		{
			runtime.writebarrierptr(edx_129, 0x00);
			eax_148 = eax_25;
		}
		if (edi_48 - 0x01 > *((word32) eax_148 + (ecx_27 * 0x0C + 0x0044)))
			runtime.panicslice(gs);
		*((word32) eax_148 + (ecx_27 * 0x0C + 64)) = edi_48 - 0x01;
		if (ebx_162 != 0x00)
		{
			if (g_t81576F0 == 0x00)
				*((word32) edx_204 + 24) = edx_127;
			else
			{
				runtime.writebarrierptr((word32) edx_204 + 24, edx_127);
				eax_148 = eax_25;
			}
		}
		else
			ebx_162 = edx_127;
		edx_204 = edx_127;
	}
	runtime.panicindex(gs);
}

// 0808D200: void runtime.preprintpanics.func1(Register (ptr32 Eq_2) gs)
void runtime.preprintpanics.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gorecover(gs, (word32) fp + 4);
	if (dwLoc08 == 0x00)
		return;
	runtime.throw(gs);
}

// 0808D250: void runtime.dopanic.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.dopanic.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_62;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_62, out esi);
	}
	runtime.dopanic_m(esi, gs, *((word32) edx + 4));
}

// 0808D290: void runtime.main.func1(Register (ptr32 Eq_2) gs)
void runtime.main.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newm(gs, 0x00);
}

// 0808D2D0: void runtime.main.func2(Register (ptr32 Eq_2) gs, Stack (ptr32 byte) dwArg04)
void runtime.main.func2(struct Eq_2 * gs, byte * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) *dwArg04 != 0x00)
		runtime.unlockOSThread(gs);
}

// 0808D300: void runtime.goready.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.goready.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_63;
		word32 ebx_62;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_62, out esi_63);
	}
	runtime.ready(gs, *((word32) edx + 4));
}

// 0808D340: void runtime.casgstatus.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.casgstatus.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_115;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_115, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_85575 * esp_24 = esp_19 - 0x10;
	esp_24->t0008 = *((word32) edx + 4);
	esp_24->t000C = *((word32) edx + 8);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 0x080E4990;
	esp_24->t0004.u0 = 0x1C;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_57;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_57);
	esp_24->t0000.u0 = 0x080E13A5;
	esp_24->t0004.u0 = 0x08;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	word32 esi_116;
	runtime.printhex(esi_57, gs, esp_24->t0000, esp_24->t0004, out esi_116);
	esp_24->t0000.u0 = 0x080E0D9C;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135155921;
	esp_24->t0004.u0 = 0x1F;
	runtime.throw(gs);
}

// 0808D400: void runtime.casgstatus.func2(Register (ptr32 Eq_2) gs)
void runtime.casgstatus.func2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808D440: void runtime.reentersyscall.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.reentersyscall.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_142;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_142, out esi);
		esp_19.u0 = <invalid>;
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	struct Eq_85718 * esp_24 = esp_19 - 0x14;
	esp_24->t0010 = *((word32) eax_26 + 56);
	esp_24->t000C = *eax_26;
	esp_24->t0008 = *((word32) eax_26 + 4);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 0x080E40F8;
	esp_24->t0004.u0 = 0x1A;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0010;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_60;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_60);
	esp_24->t0000.u0 = 135138731;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_84;
	runtime.printhex(esi_60, gs, esp_24->t0000, esp_24->t0004, out esi_84);
	esp_24->t0000.u0 = 0x080E0D89;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	word32 esi_143;
	runtime.printhex(esi_84, gs, esp_24->t0000, esp_24->t0004, out esi_143);
	esp_24->t0000.u0 = 0x080E0E0F;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135142811;
	esp_24->t0004.u0 = 0x0C;
	runtime.throw(gs);
}

// 0808D530: void runtime.entersyscallblock.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.entersyscallblock.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_194;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_194, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_85878 * esp_24 = esp_19 - 0x1C;
	Eq_4 eax_26 = *((word32) edx + 16);
	esp_24->t0010 = *((word32) edx + 4);
	esp_24->t000C = *((word32) edx + 8);
	esp_24->t0008 = *((word32) edx + 0x0C);
	esp_24->t0014 = *eax_26;
	esp_24->t0018 = *((word32) eax_26 + 4);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 135155983;
	esp_24->t0004.u0 = 0x1F;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0010;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_64;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_64);
	esp_24->t0000.u0 = 0x080E0D84;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_88;
	runtime.printhex(esi_64, gs, esp_24->t0000, esp_24->t0004, out esi_88);
	esp_24->t0000.u0 = 0x080E0D84;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_112;
	runtime.printhex(esi_88, gs, esp_24->t0000, esp_24->t0004, out esi_112);
	esp_24->t0000.u0 = 135138731;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0014;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_136;
	runtime.printhex(esi_112, gs, esp_24->t0000, esp_24->t0004, out esi_136);
	esp_24->t0000.u0 = 0x080E0D89;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0018;
	esp_24->t0004.u0 = 0x00;
	word32 esi_195;
	runtime.printhex(esi_136, gs, esp_24->t0000, esp_24->t0004, out esi_195);
	esp_24->t0000.u0 = 0x080E0E0F;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135145434;
	esp_24->t0004.u0 = 0x11;
	runtime.throw(gs);
}

// 0808D690: void runtime.entersyscallblock.func2(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.entersyscallblock.func2(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_194;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_194, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_86114 * esp_24 = esp_19 - 0x1C;
	Eq_4 eax_26 = *((word32) edx + 8);
	esp_24->t0008 = *((word32) edx + 4);
	esp_24->t0014 = *((word32) eax_26 + 28);
	esp_24->t0010 = *((word32) eax_26 + 56);
	esp_24->t000C = *eax_26;
	esp_24->t0018 = *((word32) eax_26 + 4);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 135155983;
	esp_24->t0004.u0 = 0x1F;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_64;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_64);
	esp_24->t0000.u0 = 0x080E0D84;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0014;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_88;
	runtime.printhex(esi_64, gs, esp_24->t0000, esp_24->t0004, out esi_88);
	esp_24->t0000.u0 = 0x080E0D84;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0010;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_112;
	runtime.printhex(esi_88, gs, esp_24->t0000, esp_24->t0004, out esi_112);
	esp_24->t0000.u0 = 135138731;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_136;
	runtime.printhex(esi_112, gs, esp_24->t0000, esp_24->t0004, out esi_136);
	esp_24->t0000.u0 = 0x080E0D89;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0018;
	esp_24->t0004.u0 = 0x00;
	word32 esi_195;
	runtime.printhex(esi_136, gs, esp_24->t0000, esp_24->t0004, out esi_195);
	esp_24->t0000.u0 = 0x080E0E0F;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135145434;
	esp_24->t0004.u0 = 0x11;
	runtime.throw(gs);
}

// 0808D7F0: void runtime.exitsyscall.func1(Register (ptr32 Eq_2) gs)
void runtime.exitsyscall.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808D830: void runtime.exitsyscallfast.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.exitsyscallfast.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_117;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_117, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_86365 * esp_24 = esp_19 - 0x14;
	esp_24->t0010 = *((word32) edx + 4);
	esp_24->t0008 = *((word32) edx + 8);
	esp_24->t000C = *((word32) edx + 0x0C);
	word32 ebp_35;
	Eq_51915 edx_24_8_78 = SLICE(runtime.exitsyscallfast_pidle(esi, gs, out ebp_35), word24, 8);
	byte al_48 = (byte) (word32) esp_24->t0000;
	*esp_24->t0010 = al_48;
	if (al_48 != 0x00 && (byte) ((word32) g_b814F4C8) != 0x00)
	{
		Eq_4 eax_58 = esp_24->t0008;
		if (eax_58 != 0x00)
		{
			while (true)
			{
				Eq_4 edx_68 = *((word32) *((word32) esp_24->t000C + 24) + 484);
				edx_24_8_78.u0 = SLICE(edx_68, word24, 8);
				if (*((word32) eax_58 + 20) != edx_68)
					break;
				runtime.osyield();
				eax_58 = esp_24->t0008;
			}
		}
		esp_24->t0000.u0 = 0x00;
		esp_24->t0004.u0 = 0x00;
		runtime.traceGoSysExit(edx_24_8_78, ebp_35, gs, esp_24->t0000, esp_24->t0004);
	}
}

// 0808D8D0: void runtime.exitsyscallfast_reacquired.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs)
void runtime.exitsyscallfast_reacquired.func1(Eq_4 edx, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_66;
		word32 esi_67;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_66, out esi_67);
		esp_19.u0 = <invalid>;
	}
	struct Eq_86480 * esp_24 = esp_19 - 0x08;
	esp_24->t0000 = *((word32) *((word32) *((word32) edx + 4) + 24) + 92);
	word32 ebp_31;
	word32 esi_68;
	Eq_51915 edx_24_8_44 = SLICE(runtime.traceGoSysBlock(gs, esp_24->t0000, out ebp_31, out esi_68), word24, 8);
	esp_24->t0000.u0 = 0x00;
	esp_24->t0004.u0 = 0x00;
	runtime.traceGoSysExit(edx_24_8_44, ebp_31, gs, esp_24->t0000, esp_24->t0004);
}

// 0808D920: void runtime.malg.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.malg.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_67;
		word32 ebx_66;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_66, out esi_67);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.stackalloc(gs, *((word32) edx + 8));
	*eax_26 = dwLoc0C;
	*((word32) eax_26 + 4) = dwLoc08;
}

// 0808D970: void runtime.newproc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.newproc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_69;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_69, out esi);
	}
	runtime.newproc1(esi, gs, **((word32) edx + 4), **((word32) edx + 0x0C), 0x00);
}

// 0808D9C0: void runtime.gfget.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.gfget.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_66;
		word32 ebx_65;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_65, out esi_66);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.stackalloc(gs, 0x0800);
	*eax_26 = dwLoc0C;
	*((word32) eax_26 + 4) = dwLoc08;
}

// 0808DA10: void runtime.(*rwmutex).rlock.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.(*rwmutex).rlock.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_133;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_133, out esi);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 esi_39;
	word32 ebp_134;
	word32 edi_135;
	runtime.lock(esi, gs, eax_25, out ebp_134, out esi_39, out edi_135);
	Eq_4 ecx_45 = *((word32) eax_25 + 8);
	if (ecx_45 > 0x00)
	{
		*((word32) eax_25 + 8) = ecx_45 - 0x01;
		word32 ebx_94;
		word32 edx_96;
		runtime.unlock(gs, eax_25, out edx_96, out ebx_94);
	}
	else
	{
		Eq_4 ecx_52 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		*((word32) ecx_52 + 0x00B4) = *((word32) eax_25 + 4);
		*((word32) eax_25 + 4) = ecx_52;
		word32 ebx_64;
		word32 edx_136;
		runtime.unlock(gs, eax_25, out edx_136, out ebx_64);
		runtime.notesleep(esi_39, gs, dwLoc14, (word32) ecx_52 + 0x00AC);
		((word32) ecx_52 + 0x00AC)->u0 = 0x00;
	}
}

// 0808DAC0: void runtime.morestackc.func1(Register (ptr32 Eq_2) gs)
void runtime.morestackc.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808DB00: void runtime.callers.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.callers.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_90;
		word32 ebx_89;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_89, out esi_90);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ebx_27 = *((word32) edx + 0x0C);
	Eq_4 ebp_28 = *((word32) edx + 16);
	Eq_4 esi_30 = **((word32) edx + 20);
	Eq_4 edi_31 = *((word32) edx + 24);
	Eq_4 edx_32 = *((word32) edx + 28);
	if (edx_32 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		runtime.gentraceback(gs, ebx_27, 0x00, ebp_28, esi_30, edi_31, edx_32, 0x00, 0x00);
		*eax_25 = dwLoc08;
	}
}

// 0808DB90: Register word32 runtime.init(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut, Register out ptr32 ediOut, Register out Eq_46373 xmm0Out)
// Called from:
//      runtime.main
//      sync.init
//      syscall.init
//      time.init
//      os.init
//      reflect.init
word32 runtime.init(struct Eq_2 * gs, ptr32 & esiOut, ptr32 & ediOut, union Eq_46373 & xmm0Out)
{
	word32 dwLoc08_128 = (word32) rLoc08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b815756E;
	if (al_18 <= 0x01)
	{
		if (al_18 != 0x01)
		{
			g_b815756E = 0x01;
			runtime.float64frombits(gs);
			Eq_46373 xmm0_32 = (uint128) (uint64) rLoc08;
			g_r8157678 = (real64) xmm0_32;
			runtime.funcPC();
			g_dw81575A8 = dwLoc08_128;
			runtime.funcPC();
			g_dw81575A4 = dwLoc08_128;
			word32 ebx_59 = runtime.nanotime();
			g_dw81576A8 = 0x080CF8FF;
			g_dw81576AC = 135166916;
			runtime.init.0(gs);
			ptr32 esi_86 = runtime.init.1(SLICE(ebx_59, word24, 8), gs);
			runtime.init.2(gs);
			ptr32 edi_101 = runtime.init.3(gs);
			runtime.init.4(gs);
			g_b815756E = 0x02;
			esiOut = esi_86;
			ediOut = edi_101;
			xmm0Out = xmm0_32;
			return ebx_59;
		}
		else
			runtime.throwinit(gs);
	}
	else
	{
		esiOut = esi;
		ediOut = edi;
		xmm0Out = xmm0;
		return ebx;
	}
}

// 0808DC80: void runtime.skipPleaseUseCallersFrames(Register ui32 ecx, Register ui32 edx, Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void runtime.skipPleaseUseCallersFrames(ui32 ecx, ui32 edx, struct Eq_2 * gs, Eq_661 xmm0, Eq_4 dwArg04, Eq_4 dwArg08)
{
	word32 edx_31;
	word128 xmm0_32;
	runtime.rt0_go(ecx, edx, gs, xmm0, dwArg04, dwArg08, out edx_31, out xmm0_32);
}

// 0808DD80: Register ui32 runtime.rt0_go(Register ui32 ecx, Register ui32 edx, Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 edxOut, Register out Eq_86885 xmm0Out)
// Called from:
//      runtime.skipPleaseUseCallersFrames
//      main
ui32 runtime.rt0_go(ui32 ecx, ui32 edx, struct Eq_2 * gs, Eq_661 xmm0, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & edxOut, union Eq_86885 & xmm0Out)
{
	__align(fp - 0x80);
	g_ptr81454A8 = fp + ~0x00010017;
	g_ptr81454AC = fp + ~0x00010017;
	g_ptr81454A0 = fp + ~0x00010017;
	g_ptr81454A4 = fp - 0x80;
	Eq_1797 ebx_12 = fp + ~0x00010017;
	if (((SCZDOP ^ 0x00200000 ^ (cond(fp - 0x80) | SCZDOP)) & 0x00200000) == 0x00)
	{
l0808DDC8:
		word32 ebx_346;
		ecx = runtime.write(out edx, out ebx_346);
		ebx_12 = runtime.exit();
		__syscall(0x03);
	}
	__cpuid(0x00, ecx, &0x00, &ebx_12, &ecx, &edx);
	if (0x00 == 0x00)
	{
l0808DF0C:
		<anonymous> * eax_134 = g_ptr8144F80;
		if (eax_134 != null)
		{
			eax_134();
			ptr32 eax_183 = g_ptr81454A0;
			g_ptr81454A8 = eax_183 + 880;
			g_ptr81454AC = eax_183 + 880;
		}
		else
		{
			runtime.ldt0setup();
			gs->ptr0000->tFFFFFFFC.u0 = 0x0123;
			Eq_4 eax_147 = g_t8145718;
			if (eax_147 != 0x0123)
				null = (union Eq_4 *) eax_147;
		}
		gs->ptr0000->tFFFFFFFC.u0 = 135550112;
		g_ptr81456E0 = 135550112;
		g_ptr81454B8 = 135550688;
		runtime.emptyfunc(gs);
		word64 mm0_219 = runtime.check(0x00, gs, xmm0);
		runtime.args(gs, dwArg04, dwArg08);
		runtime.schedinit(runtime.osinit(gs), gs, mm0_219);
		runtime.newproc();
		runtime.mstart(gs);
		__syscall(0x03);
		edxOut = edx_293;
		xmm0Out = xmm0_263;
		return ecx_292;
	}
	if (ebx_12 == 1970169159 && (edx == 0x49656E69 && ecx == 1818588270))
	{
		g_b815756F = 0x01;
		g_b8157573 = 0x01;
	}
	__cpuid(0x01, ecx, &0x01, &ebx_12, &ecx, &edx);
	g_dw8157628 = 0x01;
	if ((edx & 0x00800000) != 0x00)
	{
		g_t815757E = (edx & 0x04000000) != 0x00;
		g_t8157581 = (ecx & 0x0200) != 0x00;
		g_t815757F = (ecx & 0x00080000) != 0x00;
		g_t8157580 = (ecx & 0x00100000) != 0x00;
		g_t815757D = (ecx & 0x00800000) != 0x00;
		g_t8157576 = (ecx & 0x02000000) != 0x00;
		g_t815757C = (ecx & 0x08000000) != 0x00;
		g_t8157577 = (ecx & 0x10000000) != 0x00;
		if (false)
		{
			__cpuid(0x07, 0x00, &0x07, &ebx_12, &0x00, &edx);
			g_t8157579 = (ebx_12 & 0x08) != 0x00;
			g_t8157578 = (ebx_12 & 0x20) != 0x00;
			g_t815757A = (ebx_12 & 0x0100) != 0x00;
			g_t815757B = (ebx_12 & 0x0200) != 0x00;
			ecx = 0x00;
		}
		if (g_t815757C == 0x01)
		{
			word64 edx_eax_125 = __xgetbv(0x00);
			ecx = 0x00;
			edx = SLICE(edx_eax_125, word32, 32);
			if (((word32) edx_eax_125 & 0x06) == 0x06)
				goto l0808DF0C;
		}
		g_t8157577.u0 = 0x00;
		g_t8157578.u0 = 0x00;
		goto l0808DF0C;
	}
	goto l0808DDC8;
}

// 0808DFC0: void runtime.asminit()
// Called from:
//      runtime.mstart1
//      runtime.needm
void runtime.asminit()
{
	__fldcw(g_w8136002);
}

// 0808DFD0: void runtime.gosave(Register (ptr32 Eq_2) gs, Stack word32 dwArg00, Stack (ptr32 Eq_49927) dwArg04)
// Called from:
//      runtime.mstart1
void runtime.gosave(struct Eq_2 * gs, word32 dwArg00, struct Eq_49927 * dwArg04)
{
	dwArg04->ptr0000 = fp + 0x04;
	dwArg04->dw0004 = dwArg00;
	dwArg04->dw0010 = 0x00;
	if (dwArg04->dw000C == 0x00)
		dwArg04->t0008 = gs->ptr0000->tFFFFFFFC;
	else
		runtime.badctxt();
}

// 0808E010: void runtime.gogo(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_44873) dwArg04)
// Called from:
//      runtime.recovery
//      runtime.execute
//      runtime.newstack
void runtime.gogo(struct Eq_2 * gs, struct Eq_44873 * dwArg04)
{
	if (dwArg04->dw000C != 0x00)
		runtime.writebarrierptr_prewrite(0x00);
	struct Eq_6 * ecx_25 = gs->ptr0000;
	ecx_25->tFFFFFFFC = dwArg04->t0008;
	word32 eax_28 = dwArg04->dw0010;
	word32 edx_29 = dwArg04->dw000C;
	dwArg04->dw0000 = 0x00;
	dwArg04->dw0010 = 0x00;
	dwArg04->dw000C = 0x00;
	dwArg04->ptr0004();
}

// 0808E070: Register Eq_4 runtime.mcall(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 word32) dwArg04, Register out Eq_4 esiOut)
// Called from:
//      runtime.gopanic
//      runtime.Gosched
//      runtime.gopark
//      runtime.goexit1
//      runtime.exitsyscall
Eq_4 runtime.mcall(struct Eq_2 * gs, Eq_4 dwArg00, word32 * dwArg04, union Eq_4 & esiOut)
{
	struct Eq_6 * edx_7 = gs->ptr0000;
	Eq_4 eax_8 = edx_7->tFFFFFFFC;
	*((word32) eax_8 + 32) = dwArg00;
	*((word32) eax_8 + 28) = fp + 0x04;
	*((word32) eax_8 + 36) = eax_8;
	Eq_4 esi_16 = **((word32) edx_7->tFFFFFFFC + 24);
	if (esi_16 != eax_8)
	{
		edx_7->tFFFFFFFC = esi_16;
		*((word32) *((word32) esi_16 + 28) - 4) = eax_8;
		(*dwArg04)();
		g_t806E020();
		esiOut.u0 = <invalid>;
		return <invalid>;
	}
	else
	{
		word32 eax_36;
		g_t806DFE0();
		esiOut.u0 = <invalid>;
		return <invalid>;
	}
}

// 0808E0C0: void runtime.systemstack_switch()
void runtime.systemstack_switch()
{
}

// 0808E0D0: Register Eq_4 runtime.systemstack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_4 ebpOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.cgocallbackg1
//      runtime.cgoCheckWriteBarrier
//      runtime.cgoCheckTypedBlock
//      runtime.cgoCheckBits
//      runtime.(*mcache).nextFree
//      runtime.mallocgc
//      runtime.persistentalloc
//      runtime.writebarrierptr_prewrite1
//      runtime.writebarrierptr
//      runtime.writebarrierptr_prewrite
//      runtime.typedslicecopy
//      runtime.freemcache
//      runtime.SetFinalizer
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.markroot
//      runtime.gcAssistAlloc
//      runtime.gosweepone
//      runtime.getempty
//      runtime.freeSomeWbufs
//      runtime.(*mheap).alloc
//      runtime.(*mheap).freeSpan
//      runtime.mProf_Malloc
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.futexwakeup
//      runtime.newdefer
//      runtime.freedefer
//      runtime.startpanic
//      runtime.dopanic
//      runtime.main
//      runtime.goready
//      runtime.casgstatus
//      runtime.stopTheWorld
//      runtime.startTheWorld
//      runtime.reentersyscall
//      runtime.entersyscallblock
//      runtime.exitsyscall
//      runtime.exitsyscallfast
//      runtime.exitsyscallfast_reacquired
//      runtime.malg
//      runtime.newproc
//      runtime.gfget
//      runtime.unlockOSThread
//      runtime.(*rwmutex).rlock
//      os.sigpipe
//      runtime.morestackc
//      runtime.callers
Eq_4 runtime.systemstack(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_4 & ebpOut, union Eq_4 & ediOut)
{
	Eq_4 eax_32 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ebx_9 = *((word32) eax_32 + 24);
	if (eax_32 != *((word32) ebx_9 + 44))
	{
		Eq_4 edx_13 = *ebx_9;
		if (eax_32 != edx_13)
		{
			Eq_4 ebp_27 = *((word32) ebx_9 + 84);
			if (eax_32 != ebp_27)
				eax_32 = runtime.badsystemstack(gs, out edx_13);
			((word32) eax_32 + 32)->u0 = 0x0808E0C0;
			*((word32) eax_32 + 28) = fp;
			*((word32) eax_32 + 36) = eax_32;
			struct Eq_6 * ecx_41 = gs->ptr0000;
			ecx_41->tFFFFFFFC = edx_13;
			((word32) *((word32) edx_13 + 28) - 4)->u0 = 0x0806FA80;
			Eq_4 edi_52 = *dwArg04;
			edi_52();
			struct Eq_6 * ecx_58 = gs->ptr0000;
			Eq_4 ebx_60 = *((word32) ecx_58->tFFFFFFFC + 24);
			Eq_4 eax_61 = *((word32) ebx_60 + 84);
			ecx_58->tFFFFFFFC = eax_61;
			((word32) eax_61 + 28)->u0 = 0x00;
			ebpOut = ebp_27;
			ediOut = edi_52;
			return ebx_60;
		}
	}
	Eq_4 edi_19 = *dwArg04;
	edi_19();
	ebpOut = ebp;
	ediOut = edi_19;
	return ebx_9;
}

// 0808E160: Register Eq_4 runtime.morestack(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Register out Eq_4 ebxOut, Register out Eq_4 esiOut)
// Called from:
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.cgoCheckTypedBlock.func1
//      runtime.chansend.func1
//      runtime.chanrecv.func1
//      runtime.(*mcache).nextFree.func1
//      runtime.mallocgc.func1
//      runtime.persistentalloc.func1
//      runtime.writebarrierptr_prewrite1.func1
//      runtime.writebarrierptr.func1
//      runtime.typedslicecopy.func1
//      runtime.freemcache.func1
//      runtime.SetFinalizer.func1
//      runtime.SetFinalizer.func2
//      runtime.gcMarkTermination.func1
//      runtime.gcMarkTermination.func2
//      runtime.gcBgMarkWorker.func2
//      runtime.markroot.func1
//      runtime.gcAssistAlloc.func1
//      runtime.scanstack.func1
//      runtime.gosweepone.func1
//      runtime.getempty.func1
//      runtime.freeSomeWbufs.func1
//      runtime.(*mheap).alloc.func1
//      runtime.(*mheap).freeSpan.func1
//      runtime.mProf_Malloc.func1
//      runtime.tracealloc.func1
//      runtime.tracefree.func1
//      runtime.futexwakeup.func1
//      runtime.newdefer.func1
//      runtime.newdefer.func2
//      runtime.freedefer.func1
//      runtime.dopanic.func1
//      runtime.goready.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      runtime.exitsyscallfast.func1
//      runtime.exitsyscallfast_reacquired.func1
//      runtime.malg.func1
//      runtime.newproc.func1
//      runtime.gfget.func1
//      runtime.(*rwmutex).rlock.func1
//      runtime.callers.func1
//      runtime.morestack_noctxt
//      reflect.(*structType).FieldByName.func1
//      reflect.FuncOf.func1
//      reflect.funcLayout.func1
Eq_4 runtime.morestack(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, union Eq_4 & ebxOut, union Eq_4 & esiOut)
{
	struct Eq_6 * ecx_14 = gs->ptr0000;
	Eq_4 ebx_13 = *((word32) ecx_14->tFFFFFFFC + 24);
	if (ecx_14->tFFFFFFFC == *ebx_13)
	{
		ecx_14 = runtime.badmorestackg0(out edx, out ebx_13);
		__syscall(0x03);
	}
	if (ecx_14->tFFFFFFFC == *((word32) ebx_13 + 44))
	{
		edx = runtime.badmorestackgsignal(out ebx_13);
		__syscall(0x03);
	}
	*((word32) ebx_13 + 8) = dwArg04;
	*((word32) ebx_13 + 4) = fp + 0x08;
	struct Eq_6 * ecx_44 = gs->ptr0000;
	Eq_4 esi_45 = ecx_44->tFFFFFFFC;
	*((word32) ebx_13 + 0x0C) = esi_45;
	*((word32) esi_45 + 32) = dwArg00;
	*((word32) esi_45 + 36) = esi_45;
	*((word32) esi_45 + 28) = fp + 0x04;
	Eq_4 ebp_52 = *ebx_13;
	ecx_44->tFFFFFFFC = ebp_52;
	Eq_4 eax_54 = *((word32) ebp_52 + 28);
	Eq_4 ebx_55 = *((word32) eax_54 - 4);
	*((word32) eax_54 - 4) = edx;
	runtime.newstack(gs, dwArg00);
	*(word32 *) 0x1003 = 0x00;
	Eq_4 edx_69 = *((word32) eax_54 - 4);
	ebxOut = ebx_55;
	esiOut = esi_45;
	return edx_69;
}

// 0808E1F0: Register Eq_4 runtime.morestack_noctxt()
// Called from:
//      sync/atomic.(*Value).Load
//      sync/atomic.(*Value).Store
//      type..hash.sync/atomic.Value
//      type..eq.sync/atomic.Value
//      runtime.memhash0
//      runtime.memhash8
//      runtime.memhash16
//      runtime.memhash32
//      runtime.memhash64
//      runtime.memhash128
//      runtime.strhash
//      runtime.f32hash
//      runtime.f64hash
//      runtime.c64hash
//      runtime.c128hash
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.memequal0
//      runtime.memequal8
//      runtime.memequal16
//      runtime.memequal32
//      runtime.memequal64
//      runtime.memequal128
//      runtime.f32equal
//      runtime.f64equal
//      runtime.c64equal
//      runtime.c128equal
//      runtime.strequal
//      runtime.interequal
//      runtime.nilinterequal
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.alginit
//      runtime.cgocallbackg1
//      runtime.unwindm
//      runtime.makechan
//      runtime.chansend
//      runtime.send
//      runtime.sendDirect
//      runtime.recvDirect
//      runtime.closechan
//      runtime.chanrecv
//      runtime.recv
//      reflect.chanlen
//      runtime.(*waitq).dequeue
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addExtra
//      runtime.GOMAXPROCS
//      runtime.gogetenv
//      runtime.(*TypeAssertionError).Error
//      runtime.errorString.Error
//      runtime.plainError.Error
//      runtime.typestring
//      runtime.printany
//      runtime.panicwrap
//      runtime.Caller
//      runtime.Callers
//      runtime.GOROOT
//      runtime.float64frombits
//      runtime.memhash
//      runtime.(*hmap).newoverflow
//      runtime.makemap
//      runtime.mapaccess2
//      runtime.mapaccessK
//      runtime.mapassign
//      runtime.mapiterinit
//      runtime.mapiternext
//      runtime.makeBucketArray
//      runtime.hashGrow
//      runtime.growWork
//      runtime.evacuate
//      reflect.mapaccess
//      reflect.mapiterinit
//      reflect.mapiternext
//      reflect.mapiterkey
//      reflect.maplen
//      runtime.mapaccess1_fast32
//      runtime.mapaccess2_fast32
//      runtime.mapaccess2_fast64
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.getitab
//      runtime.additab
//      runtime.itabsinit
//      runtime.panicdottypeE
//      runtime.panicdottypeI
//      runtime.convT2E
//      runtime.convT2E32
//      runtime.convT2Estring
//      runtime.convT2Eslice
//      runtime.convT2I32
//      runtime.assertE2I
//      runtime.assertE2I2
//      reflect.ifaceE2I
//      runtime.(*lfstack).push
//      runtime.(*lfstack).pop
//      runtime.(*lfstack).empty
//      runtime.lock
//      runtime.unlock
//      runtime.notewakeup
//      runtime.notesleep
//      runtime.notetsleep
//      runtime.notetsleepg
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.nextFreeFast
//      runtime.(*mcache).nextFree
//      runtime.mallocgc
//      runtime.largeAlloc
//      runtime.newobject
//      reflect.unsafe_New
//      runtime.newarray
//      runtime.profilealloc
//      runtime.nextSample
//      runtime.persistentalloc
//      reflect.typedmemmove
//      reflect.typedmemmovepartial
//      runtime.(*mheap).mapBits
//      runtime.(*mspan).refillAllocCache
//      runtime.(*mspan).nextFreeIndex
//      runtime.markBitsForAddr
//      runtime.markBits.setMarked
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.heapBits.setCheckmarked
//      runtime.heapBits.initSpan
//      runtime.heapBits.initCheckmarkSpan
//      runtime.heapBits.clearCheckmarkSpan
//      runtime.(*mspan).countAlloc
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.progToPointerMask
//      runtime.runGCProg
//      runtime.allocmcache
//      runtime.freemcache
//      runtime.(*mcache).refill
//      runtime.(*mcache).releaseAll
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.(*mcentral).grow
//      runtime.addrspace_free
//      runtime.mmap_fixed
//      runtime.sysUnused
//      runtime.sysUsed
//      runtime.sysFault
//      runtime.sysReserve
//      runtime.sysMap
//      runtime.queuefinalizer
//      runtime.wakefing
//      runtime.createfing
//      runtime.runfinq
//      runtime.SetFinalizer
//      runtime.findObject
//      runtime.(*fixalloc).alloc
//      runtime.gcinit
//      runtime.readgogc
//      runtime.gcenable
//      runtime/debug.setGCPercent
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).revise
//      runtime.(*gcControllerState).endCycle
//      runtime.(*gcControllerState).enlistWorker
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcSetTriggerRatio
//      runtime.gcTrigger.test
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.gcBgMarkStartWorkers
//      runtime.gcBgMarkWorker
//      runtime.gcMarkWorkAvailable
//      runtime.gcMark
//      runtime.gcSweep
//      runtime.gcResetMarkState
//      sync.runtime_registerPoolCleanup
//      runtime.clearpools
//      runtime.gchelper
//      runtime.gchelperstart
//      runtime.itoaDiv
//      runtime.fmtNSAsMS
//      runtime.(*mTreap).insert
//      runtime.(*mTreap).removeNode
//      runtime.(*mTreap).remove
//      runtime.(*mTreap).removeSpan
//      runtime.scavengetreap
//      runtime.(*mTreap).rotateLeft
//      runtime.(*mTreap).rotateRight
//      runtime.gcMarkRootPrepare
//      runtime.gcMarkRootCheck
//      runtime.markroot
//      runtime.markrootBlock
//      runtime.markrootFreeGStacks
//      runtime.markrootSpans
//      runtime.gcAssistAlloc
//      runtime.gcWakeAllAssists
//      runtime.gcParkAssist
//      runtime.gcFlushBgCredit
//      runtime.scanframeworker
//      runtime.gcDrain
//      runtime.scanblock
//      runtime.scanobject
//      runtime.shade
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.gcMarkTinyAllocs
//      runtime.initCheckmarks
//      runtime.clearCheckmarks
//      runtime.finishsweep_m
//      runtime.bgsweep
//      runtime.sweepone
//      runtime.gosweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*mspan).sweep
//      runtime.deductSweepCredit
//      runtime.(*gcSweepBuf).push
//      runtime.(*gcSweepBuf).pop
//      runtime.(*gcSweepBuf).numBlocks
//      runtime.(*gcSweepBuf).block
//      runtime.init.0
//      runtime.(*gcWork).init
//      runtime.(*gcWork).put
//      runtime.(*gcWork).tryGet
//      runtime.(*gcWork).get
//      runtime.(*gcWork).dispose
//      runtime.(*gcWork).balance
//      runtime.(*workbuf).checknonempty
//      runtime.(*workbuf).checkempty
//      runtime.getempty
//      runtime.putempty
//      runtime.putfull
//      runtime.trygetfull
//      runtime.getfull
//      runtime.handoff
//      runtime.prepareFreeWorkbufs
//      runtime.freeSomeWbufs
//      runtime.recordspan
//      runtime.(*mheap).init
//      runtime.(*mheap).setArenaUsed
//      runtime.(*mheap).mapSpans
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).reclaim
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).alloc
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).allocLarge
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpan
//      runtime.(*mheap).freeSpanLocked
//      runtime.scavengeTreapNode
//      runtime.scavengelist
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.(*mSpanList).takeAll
//      runtime.addspecial
//      runtime.removespecial
//      runtime.addfinalizer
//      runtime.removefinalizer
//      runtime.setprofilebucket
//      runtime.freespecial
//      runtime.(*gcBitsArena).tryAlloc
//      runtime.newMarkBits
//      runtime.newAllocBits
//      runtime.nextMarkBitArenaEpoch
//      runtime.newArenaMayUnlock
//      runtime.newBucket
//      runtime.(*bucket).mp
//      runtime.(*bucket).bp
//      runtime.stkbucket
//      runtime.eqslice
//      runtime.mProf_NextCycle
//      runtime.mProf_Flush
//      runtime.mProf_FlushLocked
//      runtime.mProf_Malloc
//      runtime.mProf_Free
//      runtime.blockevent
//      runtime.blocksampled
//      runtime.saveblockevent
//      sync.event
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      runtime.init.1
//      runtime.cachestats
//      runtime.flushmcache
//      internal/poll.runtime_pollServerInit
//      runtime.netpollinited
//      internal/poll.runtime_pollOpen
//      internal/poll.runtime_pollClose
//      runtime.(*pollCache).free
//      internal/poll.runtime_pollReset
//      internal/poll.runtime_pollWait
//      internal/poll.runtime_pollUnblock
//      runtime.netpollready
//      runtime.netpollblockcommit
//      runtime.netpollgoready
//      runtime.netpollblock
//      runtime.netpollunblock
//      runtime.(*pollCache).alloc
//      runtime.netpollinit
//      runtime.netpollopen
//      runtime.netpollclose
//      runtime.netpoll
//      runtime.getproccount
//      runtime.newosproc
//      runtime.sysargs
//      runtime.sysauxv
//      runtime.osinit
//      runtime.getRandomData
//      runtime.goenvs
//      runtime.mpreinit
//      runtime.minit
//      runtime.panicCheckMalloc
//      runtime.panicindex
//      runtime.panicslice
//      runtime.panicdivide
//      runtime.panicoverflow
//      runtime.panicfloat
//      runtime.panicmem
//      runtime.throwinit
//      runtime.testdefersizes
//      runtime.init.2
//      runtime.freedeferpanic
//      runtime.freedeferfn
//      runtime.preprintpanics
//      runtime.printpanics
//      runtime.gopanic
//      runtime.recovery
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.recordForPanic
//      runtime.printlock
//      runtime.printunlock
//      runtime.gwrite
//      runtime.printsp
//      runtime.printnl
//      runtime.printbool
//      runtime.printfloat
//      runtime.printcomplex
//      runtime.printuint
//      runtime.printint
//      runtime.printhex
//      runtime.printpointer
//      runtime.printstring
//      runtime.printslice
//      runtime.printeface
//      runtime.main
//      runtime.init.3
//      runtime.forcegchelper
//      runtime.gopark
//      runtime.goparkunlock
//      runtime.goready
//      runtime.badmcall
//      runtime.badmcall2
//      runtime.badreflectcall
//      runtime.allgadd
//      runtime.schedinit
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.mcommoninit
//      runtime.ready
//      runtime.gcprocs
//      runtime.needaddgcproc
//      runtime.helpgc
//      runtime.freezetheworld
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.scang
//      runtime.restartg
//      runtime.stopTheWorld
//      runtime.startTheWorld
//      runtime.stopTheWorldWithSema
//      runtime.mhelpgc
//      runtime.startTheWorldWithSema
//      runtime.mstart1
//      runtime.runSafePointFn
//      runtime.allocm
//      runtime.newextram
//      runtime.oneNewExtraM
//      runtime.dropm
//      runtime.newm
//      runtime.stopm
//      runtime.mspinning
//      runtime.startm
//      runtime.handoffp
//      runtime.wakep
//      runtime.stoplockedm
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.execute
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.resetspinning
//      runtime.injectglist
//      runtime.schedule
//      runtime.parkunlock_c
//      runtime.park_m
//      runtime.goschedImpl
//      runtime.gosched_m
//      runtime.gopreempt_m
//      runtime.goexit1
//      runtime.goexit0
//      runtime.entersyscall_sysmon
//      runtime.entersyscall_gcwait
//      runtime.entersyscallblock_handoff
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.malg
//      runtime.newproc1
//      runtime.gfput
//      runtime.gfget
//      runtime.gfpurge
//      runtime.badunlockosthread
//      runtime._System
//      runtime._ExternalCode
//      runtime._LostExternalCode
//      runtime._GC
//      runtime.sigprof
//      runtime.setsSP
//      runtime.procresize
//      runtime.acquirep
//      runtime.acquirep1
//      runtime.releasep
//      runtime.incidlelocked
//      runtime.checkdead
//      runtime.sysmon
//      runtime.retake
//      runtime.preemptall
//      runtime.schedtrace
//      runtime.mput
//      runtime.globrunqget
//      runtime.pidleput
//      runtime.pidleget
//      runtime.runqempty
//      runtime.runqput
//      runtime.runqputslow
//      runtime.runqget
//      runtime.runqgrab
//      runtime.runqsteal
//      runtime.(*randomOrder).reset
//      runtime.gcd
//      runtime.(*profAtomic).load
//      runtime.(*profAtomic).cas
//      runtime.(*profBuf).hasOverflow
//      runtime.(*profBuf).takeOverflow
//      runtime.(*profBuf).incrementOverflow
//      runtime.(*profBuf).canWriteRecord
//      runtime.(*profBuf).canWriteTwoRecords
//      runtime.(*profBuf).write
//      runtime.(*profBuf).wakeupExtra
//      syscall.runtime_envs
//      os.runtime_args
//      runtime.args
//      runtime.goargs
//      runtime.goenvs_unix
//      runtime.testAtomic64
//      runtime.check
//      runtime.parsedebugvars
//      runtime/debug.SetTraceback
//      reflect.typelinks
//      reflect.resolveNameOff
//      reflect.resolveTypeOff
//      reflect.resolveTextOff
//      reflect.addReflectOff
//      runtime.extendRandom
//      runtime.(*rwmutex).rlock
//      runtime.(*rwmutex).runlock
//      internal/poll.runtime_Semacquire
//      sync.runtime_Semrelease
//      sync.runtime_SemacquireMutex
//      internal/poll.runtime_Semrelease
//      runtime.readyWithTime
//      runtime.semacquire
//      runtime.semacquire1
//      runtime.semrelease
//      runtime.semrelease1
//      runtime.cansemacquire
//      runtime.(*semaRoot).queue
//      runtime.(*semaRoot).dequeue
//      runtime.(*semaRoot).rotateLeft
//      runtime.(*semaRoot).rotateRight
//      sync.runtime_notifyListCheck
//      sync.runtime_nanotime
//      runtime.dumpregs
//      runtime.(*sigctxt).preparePanic
//      runtime.sighandler
//      os.sigpipe
//      runtime.init.4
//      runtime.setThreadCPUProfiler
//      runtime.sigpipe
//      runtime.sigpanic
//      runtime.raisebadsignal
//      runtime.crash
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.minitSignals
//      runtime.minitSignalStack
//      runtime.minitSignalMask
//      runtime.sigsend
//      runtime.signal_ignored
//      runtime.makeslice
//      runtime.growslice
//      runtime.stackinit
//      runtime.stacklog2
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.adjustctxt
//      runtime.adjustdefers
//      runtime.adjustsudogs
//      runtime.findsghi
//      runtime.syncadjustsudogs
//      runtime.copystack
//      runtime.round2
//      runtime.newstack
//      runtime.shrinkstack
//      runtime.freeStackSpans
//      runtime.concatstrings
//      runtime.concatstring2
//      runtime.concatstring3
//      runtime.concatstring4
//      runtime.concatstring5
//      runtime.slicebytetostring
//      runtime.rawstringtmp
//      runtime.stringtoslicebyte
//      runtime.stringtoslicerune
//      runtime.slicerunetostring
//      runtime.intstring
//      runtime.rawstring
//      runtime.rawbyteslice
//      runtime.rawruneslice
//      runtime.gostring
//      runtime.index
//      runtime.contains
//      runtime.atoi
//      runtime.atoi32
//      runtime.badsystemstack
//      reflect.memclrNoHeapPointers
//      runtime.CallersFrames
//      runtime.(*Frames).Next
//      runtime.(*stackExpander).next
//      runtime.(*pcExpander).init
//      runtime.(*pcExpander).next
//      runtime.expandCgoFrames
//      runtime.(*Func).funcInfo
//      runtime.modulesinit
//      runtime.moduledataverify
//      runtime.moduledataverify1
//      runtime.FuncForPC
//      runtime.(*Func).Name
//      runtime.findmoduledatap
//      runtime.findfunc
//      runtime.pcvalue
//      runtime.funcname
//      runtime.funcnameFromNameoff
//      runtime.funcfile
//      runtime.funcline1
//      runtime.funcline
//      runtime.funcspdelta
//      runtime.pcdatavalue
//      runtime.funcdata
//      runtime.step
//      runtime.readvarint
//      runtime.stackmapdata
//      runtime.deltimer
//      runtime.timerproc
//      runtime.timejump
//      runtime.siftupTimer
//      runtime.siftdownTimer
//      time.now
//      runtime.traceReader
//      runtime.traceProcFree
//      runtime.traceEvent
//      runtime.traceStackID
//      runtime.traceAcquireBuffer
//      runtime.traceReleaseBuffer
//      runtime.traceFlush
//      runtime.(*traceBuf).varint
//      runtime.(*traceStackTable).put
//      runtime.(*traceStackTable).find
//      runtime.(*traceStackTable).newStack
//      runtime.(*traceAlloc).alloc
//      runtime.traceGomaxprocs
//      runtime.traceProcStart
//      runtime.traceProcStop
//      runtime.traceGCStart
//      runtime.traceGCDone
//      runtime.traceGCScanStart
//      runtime.traceGCScanDone
//      runtime.traceGCSweepStart
//      runtime.traceGCSweepSpan
//      runtime.traceGCSweepDone
//      runtime.traceGCMarkAssistStart
//      runtime.traceGCMarkAssistDone
//      runtime.traceGoCreate
//      runtime.traceGoStart
//      runtime.traceGoEnd
//      runtime.traceGoSched
//      runtime.traceGoPreempt
//      runtime.traceGoPark
//      runtime.traceGoUnpark
//      runtime.traceGoSysCall
//      runtime.traceGoSysExit
//      runtime.traceGoSysBlock
//      runtime.traceHeapAlloc
//      runtime.traceNextGC
//      runtime.tracebackinit
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.traceback
//      runtime.tracebacktrap
//      runtime.traceback1
//      runtime.callers
//      runtime.gcallers
//      runtime.showframe
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.callCgoSymbolizer
//      runtime.cgoContextPCs
//      runtime.(*_type).string
//      runtime.(*_type).uncommon
//      runtime.reflectOffsLock
//      runtime.reflectOffsUnlock
//      runtime.resolveNameOff
//      runtime.(*_type).nameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).typeOff
//      runtime.(*_type).textOff
//      runtime.name.tagLen
//      runtime.name.name
//      runtime.name.tag
//      runtime.name.pkgPath
//      runtime.typelinksinit
//      runtime.typesEqual
//      runtime.decoderune
//      runtime.encoderune
//      runtime.float64toint64
//      runtime.float64touint64
//      runtime.int64tofloat64
//      runtime.uint64tofloat64
//      runtime._d2v
//      runtime.uint64div
//      runtime.uint64mod
//      runtime.int64div
//      runtime.int64mod
//      runtime.dodiv
//      runtime.slowdodiv
//      runtime.writeErr
//      runtime.cgocallbackg1.func1
//      runtime.cgoCheckTypedBlock.func2
//      runtime.cgoCheckBits.func1
//      runtime.writebarrierptr_prewrite.func1
//      runtime.(*gcControllerState).findRunnableGCWorker.func1
//      runtime.gcStart.func1
//      runtime.gcMarkDone.func1.1
//      runtime.gcMarkDone.func1
//      runtime.gcBgMarkWorker.func1
//      runtime.gcMarkRootPrepare.func1
//      runtime.preprintpanics.func1
//      runtime.main.func1
//      runtime.main.func2
//      runtime.casgstatus.func2
//      runtime.exitsyscall.func1
//      runtime.morestackc.func1
//      runtime.init
//      runtime.call16
//      runtime.call32
//      runtime.call64
//      runtime.call128
//      runtime.call256
//      runtime.call512
//      runtime.call1024
//      runtime.call2048
//      runtime.call4096
//      runtime.call8192
//      runtime.call16384
//      runtime.call32768
//      runtime.call65536
//      runtime.call131072
//      runtime.call262144
//      runtime.call524288
//      runtime.call1048576
//      runtime.call2097152
//      runtime.call4194304
//      runtime.call8388608
//      runtime.call16777216
//      runtime.call33554432
//      runtime.call67108864
//      runtime.call134217728
//      runtime.call268435456
//      runtime.call536870912
//      runtime.call1073741824
//      runtime.emptyfunc
//      type..hash.runtime._func
//      type..eq.runtime._func
//      type..hash.runtime.uncommontype
//      type..eq.runtime.uncommontype
//      type..hash.runtime.modulehash
//      type..eq.runtime.modulehash
//      type..hash.runtime.Frame
//      type..eq.runtime.Frame
//      type..hash.runtime.MemStats
//      type..eq.runtime.MemStats
//      type..hash.runtime.TypeAssertionError
//      type..eq.runtime.TypeAssertionError
//      type..hash.runtime._panic
//      type..eq.runtime._panic
//      type..hash.runtime._defer
//      type..eq.runtime._defer
//      type..hash.runtime.special
//      type..eq.runtime.special
//      type..hash.runtime.markBits
//      type..eq.runtime.markBits
//      type..hash.runtime.hchan
//      type..eq.runtime.hchan
//      type..hash.runtime.cpuProfile
//      type..eq.runtime.cpuProfile
//      type..hash.runtime.dbgVar
//      type..eq.runtime.dbgVar
//      runtime.(*errorString).Error
//      type..hash.runtime.finblock
//      type..eq.runtime.finblock
//      type..hash.runtime.gcControllerState
//      type..eq.runtime.gcControllerState
//      type..hash.runtime.mcentral
//      type..eq.runtime.mcentral
//      type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..hash.runtime.mstats
//      type..eq.runtime.mstats
//      runtime.(*plainError).Error
//      type..hash.runtime.sigTabT
//      type..eq.runtime.sigTabT
//      type..hash.runtime.stackmap
//      type..eq.runtime.stackmap
//      type..hash.runtime.sweepdata
//      type..eq.runtime.sweepdata
//      type..hash.runtime.traceStack
//      type..eq.runtime.traceStack
//      type..hash.[14]runtime.dbgVar
//      type..eq.[14]runtime.dbgVar
//      type..hash.[2]string
//      type..eq.[2]string
//      type..hash.[33]float64
//      type..eq.[33]float64
//      type..hash.[3]string
//      type..eq.[3]string
//      type..hash.[4]string
//      type..eq.[4]string
//      type..hash.[5]string
//      type..eq.[5]string
//      type..hash.[65]runtime.sigTabT
//      type..eq.[65]runtime.sigTabT
//      type..hash.[6]string
//      type..eq.[6]string
//      type..hash.[9]string
//      type..eq.[9]string
//      type..hash.struct { runtime.cycle uint32; runtime.flushed bool }
//      type..eq.struct { runtime.cycle uint32; runtime.flushed bool }
//      type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
//      type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
//      type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }
//      type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }
//      type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }
//      type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }
//      type..hash.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }
//      type..eq.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }
//      type..hash.struct { F uintptr; runtime.preemptible bool }
//      type..eq.struct { F uintptr; runtime.preemptible bool }
//      type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }
//      type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }
//      type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }
//      type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }
//      errors.New
//      errors.(*errorString).Error
//      unicode/utf8.DecodeRuneInString
//      unicode/utf8.EncodeRune
//      unicode/utf8.RuneCount
//      unicode/utf8.RuneCountInString
//      strconv.(*decimal).String
//      strconv.digitZero
//      strconv.trim
//      strconv.(*decimal).Assign
//      strconv.rightShift
//      strconv.prefixIsLessThan
//      strconv.leftShift
//      strconv.(*decimal).Shift
//      strconv.(*decimal).Round
//      strconv.(*decimal).RoundDown
//      strconv.(*decimal).RoundUp
//      strconv.(*extFloat).AssignComputeBounds
//      strconv.(*extFloat).Normalize
//      strconv.(*extFloat).Multiply
//      strconv.(*extFloat).frexp10
//      strconv.frexp10Many
//      strconv.(*extFloat).FixedDecimal
//      strconv.adjustLastDigitFixed
//      strconv.(*extFloat).ShortestDecimal
//      strconv.adjustLastDigit
//      strconv.AppendFloat
//      strconv.genericFtoa
//      strconv.bigFtoa
//      strconv.formatDigits
//      strconv.roundShortest
//      strconv.fmtE
//      strconv.fmtF
//      strconv.fmtB
//      strconv.FormatInt
//      strconv.Itoa
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendQuotedRuneWith
//      strconv.appendEscapedRune
//      strconv.AppendQuote
//      strconv.AppendQuoteToASCII
//      strconv.AppendQuoteRune
//      strconv.AppendQuoteRuneToASCII
//      strconv.CanBackquote
//      strconv.bsearch16
//      strconv.bsearch32
//      strconv.IsPrint
//      strconv.isInGraphicList
//      strconv.init
//      type..hash.strconv.decimal
//      type..eq.strconv.decimal
//      type..hash.strconv.extFloat
//      type..eq.strconv.extFloat
//      type..hash.strconv.leftCheat
//      type..eq.strconv.leftCheat
//      type..hash.[61]strconv.leftCheat
//      type..eq.[61]strconv.leftCheat
//      type..hash.[87]strconv.extFloat
//      type..eq.[87]strconv.extFloat
//      sync.(*Map).Load
//      sync.(*entry).load
//      sync.(*Map).Store
//      sync.(*entry).tryStore
//      sync.(*entry).unexpungeLocked
//      sync.(*entry).storeLocked
//      sync.(*Map).LoadOrStore
//      sync.(*entry).tryLoadOrStore
//      sync.(*Map).missLocked
//      sync.(*Map).dirtyLocked
//      sync.(*entry).tryExpungeLocked
//      sync.(*Mutex).Lock
//      sync.(*Mutex).Unlock
//      sync.(*Once).Do
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
//      sync.(*Pool).pin
//      sync.(*Pool).pinSlow
//      sync.poolCleanup
//      sync.init.0
//      sync.init.1
//      sync.init
//      io.init
//      syscall.SetNonblock
//      syscall.init.0
//      syscall.itoa
//      syscall.uitoa
//      syscall.ByteSliceFromString
//      syscall.BytePtrFromString
//      syscall.Readlink
//      syscall.mmap
//      syscall.Errno.Error
//      syscall.Write
//      syscall.readlinkat
//      syscall.Close
//      syscall.fcntl
//      syscall.write
//      syscall.munmap
//      syscall.mmap2
//      syscall.init
//      syscall.(*Errno).Error
//      type..hash.[133]string
//      type..eq.[133]string
//      time.init
//      internal/poll.(*TimeoutError).Error
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).decref
//      internal/poll.(*fdMutex).rwlock
//      internal/poll.(*fdMutex).rwunlock
//      internal/poll.(*FD).decref
//      internal/poll.(*FD).writeLock
//      internal/poll.(*FD).writeUnlock
//      internal/poll.(*pollDesc).init
//      internal/poll.(*pollDesc).close
//      internal/poll.(*pollDesc).evict
//      internal/poll.(*pollDesc).prepare
//      internal/poll.(*pollDesc).prepareWrite
//      internal/poll.(*pollDesc).wait
//      internal/poll.(*pollDesc).waitWrite
//      internal/poll.convertErr
//      internal/poll.(*FD).Init
//      internal/poll.(*FD).destroy
//      internal/poll.(*FD).Close
//      internal/poll.(*FD).Write
//      internal/poll.init
//      type..hash.internal/poll.FD
//      type..eq.internal/poll.FD
//      os.(*PathError).Error
//      os.(*File).Name
//      os.(*File).Write
//      os.Readlink
//      os.NewFile
//      os.newFile
//      os.epipecheck
//      os.(*file).close
//      os.(*File).write
//      os.init.0
//      os.glob..func1
//      os.init
//      type..hash.os.file
//      type..eq.os.file
//      type..hash.os.PathError
//      type..eq.os.PathError
//      unicode.init
//      reflect.makeMethodValue
//      reflect.name.tagLen
//      reflect.name.tag
//      reflect.name.pkgPath
//      reflect.newName
//      reflect.Kind.String
//      reflect.resolveReflectName
//      reflect.(*rtype).nameOff
//      reflect.(*rtype).typeOff
//      reflect.(*rtype).textOff
//      reflect.(*rtype).uncommon
//      reflect.(*rtype).String
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).NumMethod
//      reflect.(*rtype).Method
//      reflect.(*rtype).Name
//      reflect.(*rtype).ChanDir
//      reflect.(*rtype).Elem
//      reflect.(*rtype).In
//      reflect.(*rtype).Key
//      reflect.(*rtype).Len
//      reflect.(*rtype).NumIn
//      reflect.(*rtype).NumOut
//      reflect.(*rtype).Out
//      reflect.ChanDir.String
//      reflect.(*interfaceType).Method
//      reflect.(*interfaceType).NumMethod
//      reflect.(*interfaceType).MethodByName
//      reflect.(*structType).Field
//      reflect.(*structType).FieldByIndex
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.TypeOf
//      reflect.(*rtype).ptrTo
//      reflect.fnv1
//      reflect.implements
//      reflect.directlyAssignable
//      reflect.haveIdenticalType
//      reflect.haveIdenticalUnderlyingType
//      reflect.typesByString
//      reflect.FuncOf
//      reflect.funcStr
//      reflect.funcLayout
//      reflect.addTypeBits
//      reflect.Value.pointer
//      reflect.packEface
//      reflect.(*ValueError).Error
//      reflect.methodName
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
//      reflect.Value.Bool
//      reflect.Value.Bytes
//      reflect.Value.runes
//      reflect.methodReceiver
//      reflect.callMethod
//      reflect.Value.Complex
//      reflect.Value.Elem
//      reflect.Value.Field
//      reflect.Value.Float
//      reflect.Value.Index
//      reflect.Value.Int
//      reflect.Value.CanInterface
//      reflect.Value.Interface
//      reflect.valueInterface
//      reflect.Value.IsNil
//      reflect.Value.Kind
//      reflect.Value.Len
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.Value.NumMethod
//      reflect.Value.NumField
//      reflect.Value.Pointer
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.SetString
//      reflect.Value.Slice
//      reflect.Value.String
//      reflect.Value.Type
//      reflect.Value.Uint
//      reflect.ValueOf
//      reflect.Zero
//      reflect.New
//      reflect.Value.assignTo
//      reflect.convertOp
//      reflect.makeInt
//      reflect.makeFloat
//      reflect.makeComplex
//      reflect.makeString
//      reflect.makeBytes
//      reflect.makeRunes
//      reflect.cvtInt
//      reflect.cvtUint
//      reflect.cvtFloatInt
//      reflect.cvtFloatUint
//      reflect.cvtIntFloat
//      reflect.cvtUintFloat
//      reflect.cvtFloat
//      reflect.cvtComplex
//      reflect.cvtIntString
//      reflect.cvtUintString
//      reflect.cvtBytesString
//      reflect.cvtStringBytes
//      reflect.cvtRunesString
//      reflect.cvtStringRunes
//      reflect.cvtDirect
//      reflect.cvtT2I
//      reflect.cvtI2I
//      reflect.init
//      reflect.(*ChanDir).String
//      reflect.(*Kind).String
//      type..hash.reflect.uncommonType
//      type..eq.reflect.uncommonType
//      reflect.(*Value).Kind
//      reflect.(*Value).Len
//      reflect.(*Value).NumMethod
//      reflect.(*Value).NumField
//      reflect.(*Value).String
//      type..hash.reflect.Method
//      type..eq.reflect.Method
//      type..hash.reflect.ValueError
//      type..eq.reflect.ValueError
//      reflect.(*structType).uncommon
//      reflect.(*structType).String
//      reflect.(*structType).Size
//      reflect.(*structType).Bits
//      reflect.(*structType).Align
//      reflect.(*structType).FieldAlign
//      reflect.(*structType).Kind
//      reflect.(*structType).common
//      reflect.(*structType).NumMethod
//      reflect.(*structType).Method
//      reflect.(*structType).MethodByName
//      reflect.(*structType).PkgPath
//      reflect.(*structType).Name
//      reflect.(*structType).ChanDir
//      reflect.(*structType).IsVariadic
//      reflect.(*structType).Elem
//      reflect.(*structType).In
//      reflect.(*structType).Key
//      reflect.(*structType).Len
//      reflect.(*structType).NumField
//      reflect.(*structType).NumIn
//      reflect.(*structType).NumOut
//      reflect.(*structType).Out
//      reflect.(*structType).Implements
//      reflect.(*structType).AssignableTo
//      reflect.(*structType).ConvertibleTo
//      reflect.(*structType).Comparable
//      reflect.(*funcType).uncommon
//      reflect.(*funcType).String
//      reflect.(*funcType).Size
//      reflect.(*funcType).Bits
//      reflect.(*funcType).Align
//      reflect.(*funcType).FieldAlign
//      reflect.(*funcType).Kind
//      reflect.(*funcType).common
//      reflect.(*funcType).NumMethod
//      reflect.(*funcType).Method
//      reflect.(*funcType).MethodByName
//      reflect.(*funcType).PkgPath
//      reflect.(*funcType).Name
//      reflect.(*funcType).ChanDir
//      reflect.(*funcType).IsVariadic
//      reflect.(*funcType).Elem
//      reflect.(*funcType).Field
//      reflect.(*funcType).FieldByIndex
//      reflect.(*funcType).FieldByName
//      reflect.(*funcType).FieldByNameFunc
//      reflect.(*funcType).In
//      reflect.(*funcType).Key
//      reflect.(*funcType).Len
//      reflect.(*funcType).NumField
//      reflect.(*funcType).NumIn
//      reflect.(*funcType).NumOut
//      reflect.(*funcType).Out
//      reflect.(*funcType).Implements
//      reflect.(*funcType).AssignableTo
//      reflect.(*funcType).ConvertibleTo
//      reflect.(*funcType).Comparable
//      reflect.(*funcTypeFixed128).uncommon
//      reflect.(*funcTypeFixed128).String
//      reflect.(*funcTypeFixed128).Size
//      reflect.(*funcTypeFixed128).Bits
//      reflect.(*funcTypeFixed128).Align
//      reflect.(*funcTypeFixed128).FieldAlign
//      reflect.(*funcTypeFixed128).Kind
//      reflect.(*funcTypeFixed128).common
//      reflect.(*funcTypeFixed128).NumMethod
//      reflect.(*funcTypeFixed128).Method
//      reflect.(*funcTypeFixed128).MethodByName
//      reflect.(*funcTypeFixed128).PkgPath
//      reflect.(*funcTypeFixed128).Name
//      reflect.(*funcTypeFixed128).ChanDir
//      reflect.(*funcTypeFixed128).IsVariadic
//      reflect.(*funcTypeFixed128).Elem
//      reflect.(*funcTypeFixed128).Field
//      reflect.(*funcTypeFixed128).FieldByIndex
//      reflect.(*funcTypeFixed128).FieldByName
//      reflect.(*funcTypeFixed128).FieldByNameFunc
//      reflect.(*funcTypeFixed128).In
//      reflect.(*funcTypeFixed128).Key
//      reflect.(*funcTypeFixed128).Len
//      reflect.(*funcTypeFixed128).NumField
//      reflect.(*funcTypeFixed128).NumIn
//      reflect.(*funcTypeFixed128).NumOut
//      reflect.(*funcTypeFixed128).Out
//      reflect.(*funcTypeFixed128).Implements
//      reflect.(*funcTypeFixed128).AssignableTo
//      reflect.(*funcTypeFixed128).ConvertibleTo
//      reflect.(*funcTypeFixed128).Comparable
//      reflect.(*funcTypeFixed16).uncommon
//      reflect.(*funcTypeFixed16).String
//      reflect.(*funcTypeFixed16).Size
//      reflect.(*funcTypeFixed16).Bits
//      reflect.(*funcTypeFixed16).Align
//      reflect.(*funcTypeFixed16).FieldAlign
//      reflect.(*funcTypeFixed16).Kind
//      reflect.(*funcTypeFixed16).common
//      reflect.(*funcTypeFixed16).NumMethod
//      reflect.(*funcTypeFixed16).Method
//      reflect.(*funcTypeFixed16).MethodByName
//      reflect.(*funcTypeFixed16).PkgPath
//      reflect.(*funcTypeFixed16).Name
//      reflect.(*funcTypeFixed16).ChanDir
//      reflect.(*funcTypeFixed16).IsVariadic
//      reflect.(*funcTypeFixed16).Elem
//      reflect.(*funcTypeFixed16).Field
//      reflect.(*funcTypeFixed16).FieldByIndex
//      reflect.(*funcTypeFixed16).FieldByName
//      reflect.(*funcTypeFixed16).FieldByNameFunc
//      reflect.(*funcTypeFixed16).In
//      reflect.(*funcTypeFixed16).Key
//      reflect.(*funcTypeFixed16).Len
//      reflect.(*funcTypeFixed16).NumField
//      reflect.(*funcTypeFixed16).NumIn
//      reflect.(*funcTypeFixed16).NumOut
//      reflect.(*funcTypeFixed16).Out
//      reflect.(*funcTypeFixed16).Implements
//      reflect.(*funcTypeFixed16).AssignableTo
//      reflect.(*funcTypeFixed16).ConvertibleTo
//      reflect.(*funcTypeFixed16).Comparable
//      reflect.(*funcTypeFixed32).uncommon
//      reflect.(*funcTypeFixed32).String
//      reflect.(*funcTypeFixed32).Size
//      reflect.(*funcTypeFixed32).Bits
//      reflect.(*funcTypeFixed32).Align
//      reflect.(*funcTypeFixed32).FieldAlign
//      reflect.(*funcTypeFixed32).Kind
//      reflect.(*funcTypeFixed32).common
//      reflect.(*funcTypeFixed32).NumMethod
//      reflect.(*funcTypeFixed32).Method
//      reflect.(*funcTypeFixed32).MethodByName
//      reflect.(*funcTypeFixed32).PkgPath
//      reflect.(*funcTypeFixed32).Name
//      reflect.(*funcTypeFixed32).ChanDir
//      reflect.(*funcTypeFixed32).IsVariadic
//      reflect.(*funcTypeFixed32).Elem
//      reflect.(*funcTypeFixed32).Field
//      reflect.(*funcTypeFixed32).FieldByIndex
//      reflect.(*funcTypeFixed32).FieldByName
//      reflect.(*funcTypeFixed32).FieldByNameFunc
//      reflect.(*funcTypeFixed32).In
//      reflect.(*funcTypeFixed32).Key
//      reflect.(*funcTypeFixed32).Len
//      reflect.(*funcTypeFixed32).NumField
//      reflect.(*funcTypeFixed32).NumIn
//      reflect.(*funcTypeFixed32).NumOut
//      reflect.(*funcTypeFixed32).Out
//      reflect.(*funcTypeFixed32).Implements
//      reflect.(*funcTypeFixed32).AssignableTo
//      reflect.(*funcTypeFixed32).ConvertibleTo
//      reflect.(*funcTypeFixed32).Comparable
//      reflect.(*funcTypeFixed4).uncommon
//      reflect.(*funcTypeFixed4).String
//      reflect.(*funcTypeFixed4).Size
//      reflect.(*funcTypeFixed4).Bits
//      reflect.(*funcTypeFixed4).Align
//      reflect.(*funcTypeFixed4).FieldAlign
//      reflect.(*funcTypeFixed4).Kind
//      reflect.(*funcTypeFixed4).common
//      reflect.(*funcTypeFixed4).NumMethod
//      reflect.(*funcTypeFixed4).Method
//      reflect.(*funcTypeFixed4).MethodByName
//      reflect.(*funcTypeFixed4).PkgPath
//      reflect.(*funcTypeFixed4).Name
//      reflect.(*funcTypeFixed4).ChanDir
//      reflect.(*funcTypeFixed4).IsVariadic
//      reflect.(*funcTypeFixed4).Elem
//      reflect.(*funcTypeFixed4).Field
//      reflect.(*funcTypeFixed4).FieldByIndex
//      reflect.(*funcTypeFixed4).FieldByName
//      reflect.(*funcTypeFixed4).FieldByNameFunc
//      reflect.(*funcTypeFixed4).In
//      reflect.(*funcTypeFixed4).Key
//      reflect.(*funcTypeFixed4).Len
//      reflect.(*funcTypeFixed4).NumField
//      reflect.(*funcTypeFixed4).NumIn
//      reflect.(*funcTypeFixed4).NumOut
//      reflect.(*funcTypeFixed4).Out
//      reflect.(*funcTypeFixed4).Implements
//      reflect.(*funcTypeFixed4).AssignableTo
//      reflect.(*funcTypeFixed4).ConvertibleTo
//      reflect.(*funcTypeFixed4).Comparable
//      reflect.(*funcTypeFixed64).uncommon
//      reflect.(*funcTypeFixed64).String
//      reflect.(*funcTypeFixed64).Size
//      reflect.(*funcTypeFixed64).Bits
//      reflect.(*funcTypeFixed64).Align
//      reflect.(*funcTypeFixed64).FieldAlign
//      reflect.(*funcTypeFixed64).Kind
//      reflect.(*funcTypeFixed64).common
//      reflect.(*funcTypeFixed64).NumMethod
//      reflect.(*funcTypeFixed64).Method
//      reflect.(*funcTypeFixed64).MethodByName
//      reflect.(*funcTypeFixed64).PkgPath
//      reflect.(*funcTypeFixed64).Name
//      reflect.(*funcTypeFixed64).ChanDir
//      reflect.(*funcTypeFixed64).IsVariadic
//      reflect.(*funcTypeFixed64).Elem
//      reflect.(*funcTypeFixed64).Field
//      reflect.(*funcTypeFixed64).FieldByIndex
//      reflect.(*funcTypeFixed64).FieldByName
//      reflect.(*funcTypeFixed64).FieldByNameFunc
//      reflect.(*funcTypeFixed64).In
//      reflect.(*funcTypeFixed64).Key
//      reflect.(*funcTypeFixed64).Len
//      reflect.(*funcTypeFixed64).NumField
//      reflect.(*funcTypeFixed64).NumIn
//      reflect.(*funcTypeFixed64).NumOut
//      reflect.(*funcTypeFixed64).Out
//      reflect.(*funcTypeFixed64).Implements
//      reflect.(*funcTypeFixed64).AssignableTo
//      reflect.(*funcTypeFixed64).ConvertibleTo
//      reflect.(*funcTypeFixed64).Comparable
//      reflect.(*funcTypeFixed8).uncommon
//      reflect.(*funcTypeFixed8).String
//      reflect.(*funcTypeFixed8).Size
//      reflect.(*funcTypeFixed8).Bits
//      reflect.(*funcTypeFixed8).Align
//      reflect.(*funcTypeFixed8).FieldAlign
//      reflect.(*funcTypeFixed8).Kind
//      reflect.(*funcTypeFixed8).common
//      reflect.(*funcTypeFixed8).NumMethod
//      reflect.(*funcTypeFixed8).Method
//      reflect.(*funcTypeFixed8).MethodByName
//      reflect.(*funcTypeFixed8).PkgPath
//      reflect.(*funcTypeFixed8).Name
//      reflect.(*funcTypeFixed8).ChanDir
//      reflect.(*funcTypeFixed8).IsVariadic
//      reflect.(*funcTypeFixed8).Elem
//      reflect.(*funcTypeFixed8).Field
//      reflect.(*funcTypeFixed8).FieldByIndex
//      reflect.(*funcTypeFixed8).FieldByName
//      reflect.(*funcTypeFixed8).FieldByNameFunc
//      reflect.(*funcTypeFixed8).In
//      reflect.(*funcTypeFixed8).Key
//      reflect.(*funcTypeFixed8).Len
//      reflect.(*funcTypeFixed8).NumField
//      reflect.(*funcTypeFixed8).NumIn
//      reflect.(*funcTypeFixed8).NumOut
//      reflect.(*funcTypeFixed8).Out
//      reflect.(*funcTypeFixed8).Implements
//      reflect.(*funcTypeFixed8).AssignableTo
//      reflect.(*funcTypeFixed8).ConvertibleTo
//      reflect.(*funcTypeFixed8).Comparable
//      reflect.(*interfaceType).uncommon
//      reflect.(*interfaceType).String
//      reflect.(*interfaceType).Size
//      reflect.(*interfaceType).Bits
//      reflect.(*interfaceType).Align
//      reflect.(*interfaceType).FieldAlign
//      reflect.(*interfaceType).Kind
//      reflect.(*interfaceType).common
//      reflect.(*interfaceType).PkgPath
//      reflect.(*interfaceType).Name
//      reflect.(*interfaceType).ChanDir
//      reflect.(*interfaceType).IsVariadic
//      reflect.(*interfaceType).Elem
//      reflect.(*interfaceType).Field
//      reflect.(*interfaceType).FieldByIndex
//      reflect.(*interfaceType).FieldByName
//      reflect.(*interfaceType).FieldByNameFunc
//      reflect.(*interfaceType).In
//      reflect.(*interfaceType).Key
//      reflect.(*interfaceType).Len
//      reflect.(*interfaceType).NumField
//      reflect.(*interfaceType).NumIn
//      reflect.(*interfaceType).NumOut
//      reflect.(*interfaceType).Out
//      reflect.(*interfaceType).Implements
//      reflect.(*interfaceType).AssignableTo
//      reflect.(*interfaceType).ConvertibleTo
//      reflect.(*interfaceType).Comparable
//      reflect.(*ptrType).uncommon
//      reflect.(*ptrType).String
//      reflect.(*ptrType).Size
//      reflect.(*ptrType).Bits
//      reflect.(*ptrType).Align
//      reflect.(*ptrType).FieldAlign
//      reflect.(*ptrType).Kind
//      reflect.(*ptrType).common
//      reflect.(*ptrType).NumMethod
//      reflect.(*ptrType).Method
//      reflect.(*ptrType).MethodByName
//      reflect.(*ptrType).PkgPath
//      reflect.(*ptrType).Name
//      reflect.(*ptrType).ChanDir
//      reflect.(*ptrType).IsVariadic
//      reflect.(*ptrType).Elem
//      reflect.(*ptrType).Field
//      reflect.(*ptrType).FieldByIndex
//      reflect.(*ptrType).FieldByName
//      reflect.(*ptrType).FieldByNameFunc
//      reflect.(*ptrType).In
//      reflect.(*ptrType).Key
//      reflect.(*ptrType).Len
//      reflect.(*ptrType).NumField
//      reflect.(*ptrType).NumIn
//      reflect.(*ptrType).NumOut
//      reflect.(*ptrType).Out
//      reflect.(*ptrType).Implements
//      reflect.(*ptrType).AssignableTo
//      reflect.(*ptrType).ConvertibleTo
//      reflect.(*ptrType).Comparable
//      reflect.(*sliceType).uncommon
//      reflect.(*sliceType).String
//      reflect.(*sliceType).Size
//      reflect.(*sliceType).Bits
//      reflect.(*sliceType).Align
//      reflect.(*sliceType).FieldAlign
//      reflect.(*sliceType).Kind
//      reflect.(*sliceType).common
//      reflect.(*sliceType).NumMethod
//      reflect.(*sliceType).Method
//      reflect.(*sliceType).MethodByName
//      reflect.(*sliceType).PkgPath
//      reflect.(*sliceType).Name
//      reflect.(*sliceType).ChanDir
//      reflect.(*sliceType).IsVariadic
//      reflect.(*sliceType).Elem
//      reflect.(*sliceType).Field
//      reflect.(*sliceType).FieldByIndex
//      reflect.(*sliceType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
//      reflect.(*sliceType).In
//      reflect.(*sliceType).Key
//      reflect.(*sliceType).Len
//      reflect.(*sliceType).NumField
//      reflect.(*sliceType).NumIn
//      reflect.(*sliceType).NumOut
//      reflect.(*sliceType).Out
//      reflect.(*sliceType).Implements
//      reflect.(*sliceType).AssignableTo
//      reflect.(*sliceType).ConvertibleTo
//      reflect.(*sliceType).Comparable
//      type..hash.[27]string
//      type..eq.[27]string
//      type..hash.struct { reflect.b bool; reflect.x interface {} }
//      type..eq.struct { reflect.b bool; reflect.x interface {} }
//      type..hash.struct { F uintptr; reflect.name string }
//      type..eq.struct { F uintptr; reflect.name string }
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_boolean
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).truncate
//      fmt.(*fmt).fmt_s
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_sx
//      fmt.(*fmt).fmt_bx
//      fmt.(*fmt).fmt_q
//      fmt.(*fmt).fmt_c
//      fmt.(*fmt).fmt_qc
//      fmt.(*fmt).fmt_float
//      fmt.(*buffer).WriteRune
//      fmt.newPrinter
//      fmt.(*pp).free
//      fmt.(*pp).Width
//      fmt.(*pp).Precision
//      fmt.(*pp).Flag
//      fmt.(*pp).Write
//      fmt.Fprintln
//      fmt.Println
//      fmt.getField
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtBool
//      fmt.(*pp).fmt0x64
//      fmt.(*pp).fmtInteger
//      fmt.(*pp).fmtFloat
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtString
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).handleMethods
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
//      fmt.(*pp).doPrintln
//      fmt.glob..func1
//      fmt.init
//      type..hash.fmt.fmt
//      type..eq.fmt.fmt
//      main.main
//      main.init
Eq_4 runtime.morestack_noctxt()
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	Eq_4 stackArg4 = <invalid>;
	word32 ebx_17;
	word32 esi_18;
	return runtime.morestack(edx, gs, stackArg0, stackArg4, out ebx_17, out esi_18);
}

// 0808E200: void reflect.call(Stack Eq_4 dwArg10)
// Called from:
//      reflect.callMethod
void reflect.call(Eq_4 dwArg10)
{
	runtime.reflectcall(dwArg10);
}

// 0808E210: void runtime.reflectcall(Stack Eq_4 dwArg10)
// Called from:
//      runtime.cgocallbackg1
//      runtime.runfinq
//      runtime.gopanic
//      reflect.call
void runtime.reflectcall(Eq_4 dwArg10)
{
	if (dwArg10 > 0x10)
	{
		if (dwArg10 > 0x20)
		{
			if (dwArg10 > 0x40)
			{
				if (dwArg10 > 0x80)
				{
					if (dwArg10 > 0x0100)
					{
						if (dwArg10 > 0x0200)
						{
							if (dwArg10 > 0x0400)
							{
								if (dwArg10 > 0x0800)
								{
									if (dwArg10 > 0x1000)
									{
										if (dwArg10 > 0x2000)
										{
											if (dwArg10 > 0x4000)
											{
												if (dwArg10 > 0x8000)
												{
													if (dwArg10 > 0x00010000)
													{
														if (dwArg10 > 0x00020000)
														{
															if (dwArg10 > 0x00040000)
															{
																if (dwArg10 > 0x00080000)
																{
																	if (dwArg10 > 0x00100000)
																	{
																		if (dwArg10 > 0x00200000)
																		{
																			if (dwArg10 > 0x00400000)
																			{
																				if (dwArg10 > 0x00800000)
																				{
																					if (dwArg10 > 0x01000000)
																					{
																						if (dwArg10 > 0x02000000)
																						{
																							if (dwArg10 > 0x04000000)
																							{
																								if (dwArg10 > 0x08000000)
																								{
																									if (dwArg10 > 0x10000000)
																									{
																										if (dwArg10 > 0x20000000)
																										{
																											if (dwArg10 > 0x40000000)
																											{
																												word32 eax_62;
																												g_t806E060();
																											}
																											else
																											{
																												word32 eax_66;
																												g_t808F320();
																											}
																										}
																										else
																										{
																											word32 eax_70;
																											g_t808F280();
																										}
																									}
																									else
																									{
																										word32 eax_74;
																										g_t808F1E0();
																									}
																								}
																								else
																								{
																									word32 eax_78;
																									g_t808F140();
																								}
																							}
																							else
																							{
																								word32 eax_82;
																								g_t808F0A0();
																							}
																						}
																						else
																						{
																							word32 eax_86;
																							g_t808F000();
																						}
																					}
																					else
																					{
																						word32 eax_90;
																						g_t808EF60();
																					}
																				}
																				else
																				{
																					word32 eax_94;
																					g_t808EEC0();
																				}
																			}
																			else
																			{
																				word32 eax_98;
																				g_t808EE20();
																			}
																		}
																		else
																		{
																			word32 eax_102;
																			g_t808ED80();
																		}
																	}
																	else
																	{
																		word32 eax_106;
																		g_t808ECE0();
																	}
																}
																else
																{
																	word32 eax_110;
																	g_t808EC40();
																}
															}
															else
															{
																word32 eax_114;
																g_t808EBA0();
															}
														}
														else
														{
															word32 eax_118;
															g_t808EB00();
														}
													}
													else
													{
														word32 eax_122;
														g_t808EA60();
													}
												}
												else
												{
													word32 eax_126;
													g_t808E9C0();
												}
											}
											else
											{
												word32 eax_130;
												g_t808E920();
											}
										}
										else
										{
											word32 eax_134;
											g_t808E880();
										}
									}
									else
									{
										word32 eax_138;
										g_t808E7F0();
									}
								}
								else
								{
									word32 eax_142;
									g_t808E760();
								}
							}
							else
							{
								word32 eax_146;
								g_t808E6D0();
							}
						}
						else
						{
							word32 eax_150;
							g_t808E640();
						}
					}
					else
					{
						word32 eax_154;
						g_t808E5B0();
					}
				}
				else
				{
					word32 eax_158;
					g_t808E520();
				}
			}
			else
			{
				word32 eax_162;
				g_t808E4B0();
			}
		}
		else
		{
			word32 eax_166;
			g_t808E440();
		}
	}
	else
	{
		word32 eax_170;
		g_t808E3D0();
	}
}

// 0808E3B0: void callRet(Register Eq_4 ecx, Register (ptr32 Eq_16244) edx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.call16
//      runtime.call32
//      runtime.call64
//      runtime.call128
//      runtime.call256
//      runtime.call512
//      runtime.call1024
//      runtime.call2048
//      runtime.call4096
//      runtime.call8192
//      runtime.call16384
//      runtime.call32768
//      runtime.call65536
//      runtime.call131072
//      runtime.call262144
//      runtime.call524288
//      runtime.call1048576
//      runtime.call2097152
//      runtime.call4194304
//      runtime.call8388608
//      runtime.call16777216
//      runtime.call33554432
//      runtime.call67108864
//      runtime.call134217728
//      runtime.call268435456
//      runtime.call536870912
//      runtime.call1073741824
void callRet(Eq_4 ecx, struct Eq_16244 * edx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs)
{
	runtime.reflectcallmove(gs, edx, edi, esi, ecx);
}

// 0808E3D0: void runtime.call16(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call16(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x10;
	byte * esi_27 = dwArg0C;
	word32 ecx_28;
	byte * edi_29 = fp - 0x10;
	for (ecx_28 = dwArg10; ecx_28 != 0x00; --ecx_28)
	{
		*edi_29 = *esi_27;
		++esi_27;
		++edi_29;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x10 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E440: void runtime.call32(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call32(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x20;
	byte * esi_27 = dwArg0C;
	word32 ecx_28;
	byte * edi_29 = fp - 0x20;
	for (ecx_28 = dwArg10; ecx_28 != 0x00; --ecx_28)
	{
		*edi_29 = *esi_27;
		++esi_27;
		++edi_29;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x20 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E4B0: void runtime.call64(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call64(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x40;
	byte * esi_27 = dwArg0C;
	word32 ecx_28;
	byte * edi_29 = fp - 0x40;
	for (ecx_28 = dwArg10; ecx_28 != 0x00; --ecx_28)
	{
		*edi_29 = *esi_27;
		++esi_27;
		++edi_29;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x40 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E520: void runtime.call128(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call128(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x80;
	byte * esi_27 = dwArg0C;
	word32 ecx_28;
	byte * edi_29 = fp - 0x80;
	for (ecx_28 = dwArg10; ecx_28 != 0x00; --ecx_28)
	{
		*edi_29 = *esi_27;
		++esi_27;
		++edi_29;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x80 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E5B0: void runtime.call256(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call256(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp - 0x80 > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x0100;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x0100;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x0100 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E640: void runtime.call512(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call512(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp - 0x0180 > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x0200;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x0200;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x0200 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E6D0: void runtime.call1024(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call1024(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp - 0x0380 > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x0400;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x0400;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x0400 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E760: void runtime.call2048(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call2048(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp - 0x0780 > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x0800;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x0800;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x0800 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E7F0: void runtime.call4096(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call4096(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp + ~0x0F7F > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x1000;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x1000;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x1000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E880: void runtime.call8192(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call8192(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x22F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x2000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x2000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x2000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E920: void runtime.call16384(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call16384(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x42F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x4000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x4000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x4000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E9C0: void runtime.call32768(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call32768(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x82F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x8000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x8000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x8000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EA60: void runtime.call65536(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call65536(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 66288)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00010000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00010000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00010000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EB00: void runtime.call131072(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call131072(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x000202F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00020000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00020000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00020000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EBA0: void runtime.call262144(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call262144(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x000402F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00040000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00040000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00040000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EC40: void runtime.call524288(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call524288(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x000802F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00080000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00080000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00080000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808ECE0: void runtime.call1048576(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call1048576(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x001002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00100000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00100000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00100000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808ED80: void runtime.call2097152(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call2097152(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x002002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00200000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00200000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00200000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EE20: void runtime.call4194304(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call4194304(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x004002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00400000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00400000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00400000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EEC0: void runtime.call8388608(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call8388608(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x008002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00800000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00800000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00800000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EF60: void runtime.call16777216(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call16777216(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x010002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x01000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x01000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x01000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F000: void runtime.call33554432(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call33554432(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x020002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x02000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x02000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x02000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F0A0: void runtime.call67108864(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call67108864(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x040002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x04000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x04000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x04000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F140: void runtime.call134217728(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call134217728(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x080002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x08000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x08000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x08000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F1E0: void runtime.call268435456(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call268435456(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x100002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x10000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x10000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x10000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F280: void runtime.call536870912(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call536870912(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x200002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x20000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x20000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x20000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F320: void runtime.call1073741824(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_16244) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call1073741824(struct Eq_2 * gs, struct Eq_16244 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x400002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x40000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x40000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x40000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F3C0: void runtime.procyield(Stack Eq_4 dwArg04)
// Called from:
//      runtime.lock
//      runtime.getfull
//      runtime.casgstatus
//      runtime.scang
//      sync.runtime_doSpin
void runtime.procyield(Eq_4 dwArg04)
{
	Eq_4 eax_5;
	do
	{
		__pause();
		--eax_5;
	} while (eax_5 != 0x00);
}

// 0808F3D0: void runtime.publicationBarrier()
// Called from:
//      runtime.mallocgc
void runtime.publicationBarrier()
{
}

// 0808F3E0: void runtime.jmpdefer(Stack Eq_4 dwArg04, Stack (ptr32 Eq_44126) dwArg08)
// Called from:
//      runtime.deferreturn
void runtime.jmpdefer(Eq_4 dwArg04, struct Eq_44126 * dwArg08)
{
	dwArg08->dwFFFFFFFC -= 0x05;
	(*dwArg04)();
}

// 0808F400: Register Eq_4 gosave(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Register out Eq_4 edxOut)
// Called from:
//      runtime.asmcgocall
Eq_4 gosave(struct Eq_2 * gs, Eq_4 dwArg00, union Eq_4 & edxOut)
{
	Eq_4 ebx_12 = gs->ptr0000->tFFFFFFFC;
	*((word32) ebx_12 + 28) = fp + 0x04;
	*((word32) ebx_12 + 32) = dwArg00;
	((word32) ebx_12 + 44)->u0 = 0x00;
	if (*((word32) ebx_12 + 40) != 0x00)
		runtime.badctxt();
	edxOut.u0 = <invalid>;
	return <invalid>;
}

// 0808F440: Register (ptr32 Eq_89476) runtime.asmcgocall(Register (ptr32 Eq_2) gs, Stack (ptr32 code) dwArg04, Stack ptr32 dwArg08, Register out Eq_4 ediOut)
// Called from:
//      runtime.cgocall
//      runtime.notesleep
//      runtime.notetsleep_internal
//      runtime.newm
//      runtime.findrunnable
//      runtime.sysmon
//      runtime.callCgoSymbolizer
//      runtime.cgoContextPCs
struct Eq_89476 * runtime.asmcgocall(struct Eq_2 * gs, <anonymous> * dwArg04, ptr32 dwArg08, union Eq_4 & ediOut)
{
	Eq_4 esp_2 = fp;
	struct Eq_6 * ecx_9 = gs->ptr0000;
	<anonymous> * eax_16 = dwArg04;
	Eq_4 edx_17 = fp;
	Eq_4 esi_12 = **((word32) ecx_9->tFFFFFFFC + 24);
	Eq_4 edi_13 = ecx_9->tFFFFFFFC;
	if (esi_12 != edi_13)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		eax_16 = gosave(gs, stackArg0, out edx_17);
		gs->ptr0000->tFFFFFFFC = esi_12;
		esp_2 = *((word32) esi_12 + 28);
	}
	struct Eq_86891 * esp_24 = esp_2 - 0x20;
	__align(esp_24);
	esp_24->t0008 = edi_13;
	esp_24->dw0004 = *((word32) edi_13 + 4) - edx_17;
	esp_24->ptr0000 = dwArg08;
	word32 eax_37;
	eax_16();
	Eq_4 edi_42 = esp_24->t0008;
	struct Eq_89476 * esi_44 = *((word32) edi_42 + 4) - esp_24->dw0004;
	gs->ptr0000->tFFFFFFFC = edi_42;
	esi_44->dw000C = eax_37;
	ediOut = edi_42;
	return esi_44;
}

// 0808F4C0: void runtime.cgocallback_gofunc(Register (ptr32 Eq_2) gs, Stack word32 dwArg10)
void runtime.cgocallback_gofunc(struct Eq_2 * gs, word32 dwArg10)
{
	Eq_4 edx_25;
	Eq_4 ebp_28;
	struct Eq_6 * ecx_26 = gs->ptr0000;
	Eq_4 ebp_8 = ecx_26->tFFFFFFFC;
	if (ebp_8 != 0x00)
	{
		ebp_28 = *((word32) ebp_8 + 24);
		edx_25 = ebp_28;
	}
	else
	{
		runtime.needm(gs);
		ecx_26 = gs->ptr0000;
		ebp_28 = *((word32) ecx_26->tFFFFFFFC + 24);
		*((word32) *ebp_28 + 28) = fp - 0x0C;
		edx_25.u0 = 0x00;
	}
	*((word32) *ebp_28 + 28) = fp - 0x0C;
	Eq_4 esi_40 = *((word32) ebp_28 + 84);
	ecx_26->tFFFFFFFC = esi_40;
	Eq_4 edi_43 = *((word32) esi_40 + 28);
	Eq_4 ebp_44 = *((word32) esi_40 + 32);
	*((word32) edi_43 - 4) = ebp_44;
	*((word32) edi_43 - 0x0C) = edx_25;
	*((word32) edi_43 - 16) = dwArg10;
	runtime.cgocallbackg(ebp_44, gs, *((word32) edi_43 - 20));
	Eq_4 esp_59 = <invalid>;
	struct Eq_6 * ecx_66 = gs->ptr0000;
	Eq_4 edx_65 = *((word32) esp_59 + 4);
	Eq_4 esi_67 = ecx_66->tFFFFFFFC;
	*((word32) esi_67 + 32) = *((word32) esp_59 + 0x0C);
	*((word32) esi_67 + 28) = (word32) esp_59 + 16;
	Eq_4 esi_74 = **((word32) ecx_66->tFFFFFFFC + 24);
	ecx_66->tFFFFFFFC = esi_74;
	*((word32) esi_74 + 28) = **((word32) esi_74 + 28);
	if (edx_65 == 0x00)
		runtime.dropm(gs);
}

// 0808F580: Register Eq_4 runtime.setg(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.needm
//      runtime.dropm
//      runtime.sigtrampgo
Eq_4 runtime.setg(struct Eq_2 * gs, Eq_4 dwArg04)
{
	gs->ptr0000->tFFFFFFFC = dwArg04;
	return dwArg04;
}

// 0808F5A0: void setg_gcc(Register (ptr32 Eq_89679) gs, Stack word32 dwArg04)
void setg_gcc(struct Eq_89679 * gs, word32 dwArg04)
{
	gs->ptr0000->dwFFFFFFFC = dwArg04;
}

// 0808F5C0: void runtime.stackcheck(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.clone
void runtime.stackcheck(struct Eq_2 * gs)
{
	Eq_4 eax_7 = gs->ptr0000->tFFFFFFFC;
	if (*((word32) eax_7 + 4) <= fp)
		__syscall(0x03);
	if (fp <= *eax_7)
		__syscall(0x03);
}

// 0808F5E0: void runtime.getcallerpc()
// Called from:
//      runtime.chansend1
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.deferproc
//      runtime.dopanic
//      runtime.entersyscall
//      runtime.entersyscallblock
//      runtime.newproc
//      runtime.callers
void runtime.getcallerpc()
{
}

// 0808F600: void runtime.cputicks()
// Called from:
//      runtime.chansend
//      runtime.send
//      runtime.closechan
//      runtime.chanrecv
//      runtime.recv
//      runtime.mcommoninit
//      runtime.exitsyscall
//      runtime.readyWithTime
//      runtime.semacquire1
//      runtime.(*semaRoot).dequeue
//      runtime.traceEvent
void runtime.cputicks()
{
	if (g_t815757E == 0x01)
	{
		if (g_b8157573 == 0x01)
			__lfence();
		else
			__mfence();
	}
	__rdtsc();
}

// 0808F630: void runtime.ldt0setup()
// Called from:
//      main
void runtime.ldt0setup()
{
	runtime.setldt(&g_t8145718);
}

// 0808F660: void runtime.emptyfunc(Register (ptr32 Eq_2) gs)
// Called from:
//      main
//      runtime.clone
void runtime.emptyfunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0808F680: void runtime.memhash_varlen(Register (ptr32 Eq_89742) edx, Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void runtime.memhash_varlen(struct Eq_89742 * edx, struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	runtime.memhash(gs, mm0, dwArg04, dwArg08, edx->t0004);
}

// 0808F6B0: void runtime.aeshash(Register word64 mm0, Stack Eq_207 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.memhash
void runtime.aeshash(word64 mm0, Eq_207 dwArg08, Eq_4 dwArg0C)
{
	runtime.aeshashbody(dwArg0C, mm0, dwArg08);
}

// 0808F6D0: void runtime.aeshashstr(Register word64 mm0, Stack (ptr32 Eq_89759) dwArg04, Stack Eq_207 dwArg08)
void runtime.aeshashstr(word64 mm0, struct Eq_89759 * dwArg04, Eq_207 dwArg08)
{
	Eq_4 ebx_6 = dwArg04->t0004;
	runtime.aeshashbody(ebx_6, mm0, dwArg08);
}

// 0808F6F0: void runtime.aeshashbody(Register Eq_4 ebx, Register word64 mm0, Stack Eq_207 dwArg08)
// Called from:
//      runtime.aeshash
//      runtime.aeshashstr
void runtime.aeshashbody(Eq_4 ebx, word64 mm0, Eq_207 dwArg08)
{
	word128 xmm0_5 = (word128) dwArg08;
	Eq_45714 xmm0_7 = __pinsrw(xmm0_5, xmm0_5, ebx);
	__pshufw(mm0, mm0, 0x00);
	__pxor(xmm0_7, g_ow81577A0);
}

// 0808F930: void runtime.aeshash32()
void runtime.aeshash32()
{
}

// 0808F970: void runtime.aeshash64()
void runtime.aeshash64()
{
}

// 0808F9B0: void runtime.checkASM()
// Called from:
//      runtime.check
void runtime.checkASM()
{
}

// 0808F9D0: Register Eq_4 runtime.memequal(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_4 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.mapassign_faststr
//      type..eq.runtime._func
//      type..eq.runtime.MemStats
//      type..eq.runtime._panic
//      type..eq.runtime._defer
//      type..eq.runtime.special
//      type..eq.runtime.hchan
//      type..eq.runtime.cpuProfile
//      type..eq.runtime.finblock
//      type..eq.runtime.gcControllerState
//      type..eq.runtime.mcentral
//      type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.runtime.mstats
//      type..eq.runtime.stackmap
//      type..eq.runtime.sweepdata
//      type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
//      type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }
//      type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }
//      type..eq.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }
//      type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }
//      type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }
//      type..eq.strconv.decimal
//      type..eq.strconv.extFloat
//      type..eq.internal/poll.FD
//      type..eq.fmt.fmt
Eq_4 runtime.memequal(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_4 & esiOut, union Eq_4 & ediOut)
{
	if (dwArg04 == dwArg08)
	{
		esiOut = dwArg04;
		ediOut = dwArg08;
		return ebx;
	}
	else
	{
		Eq_4 edi_13;
		esiOut = runtime.memeqbody(fp + 0x10, dwArg0C, dwArg04, dwArg08, out edi_13);
		ediOut = edi_13;
		return dwArg0C;
	}
}

// 0808F9F0: void runtime.memequal_varlen(Register (ptr32 Eq_89802) edx, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void runtime.memequal_varlen(struct Eq_89802 * edx, Eq_4 dwArg04, Eq_4 dwArg08)
{
	if (dwArg04 == dwArg08)
		return;
	Eq_4 ebx_11 = edx->t0004;
	word32 edi_42;
	runtime.memeqbody(fp + 0x0C, ebx_11, dwArg04, dwArg08, out edi_42);
}

// 0808FA10: Register Eq_4 runtime.eqstring(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_4 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.strequal
//      runtime.gogetenv
//      runtime.additab
//      runtime.parsedebugvars
//      runtime.index
//      runtime.moduledataverify1
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.showframe
//      runtime.typesEqual
//      type..eq.runtime.modulehash
//      type..eq.runtime.Frame
//      type..eq.runtime.TypeAssertionError
//      type..eq.runtime.dbgVar
//      type..eq.runtime.sigTabT
//      type..eq.[14]runtime.dbgVar
//      type..eq.[2]string
//      type..eq.[3]string
//      type..eq.[4]string
//      type..eq.[5]string
//      type..eq.[65]runtime.sigTabT
//      type..eq.[6]string
//      type..eq.[9]string
//      type..eq.strconv.leftCheat
//      type..eq.[61]strconv.leftCheat
//      type..eq.[133]string
//      type..eq.os.file
//      type..eq.os.PathError
//      reflect.(*interfaceType).MethodByName
//      reflect.(*structType).FieldByName
//      reflect.implements
//      reflect.haveIdenticalType
//      reflect.haveIdenticalUnderlyingType
//      reflect.typesByString
//      reflect.(*structType).FieldByName.func1
//      type..eq.reflect.Method
//      type..eq.reflect.ValueError
//      reflect.(*sliceType).MethodByName
//      type..eq.[27]string
//      type..eq.struct { F uintptr; reflect.name string }
Eq_4 runtime.eqstring(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_4 & esiOut, union Eq_4 & ediOut)
{
	if (dwArg04 == dwArg0C)
	{
		esiOut = dwArg04;
		ediOut = dwArg0C;
		return ebx;
	}
	else
	{
		Eq_4 edi_13;
		esiOut = runtime.memeqbody(fp + 0x14, dwArg08, dwArg04, dwArg0C, out edi_13);
		ediOut = edi_13;
		return dwArg08;
	}
}

// 0808FA30: Register Eq_4 runtime.memeqbody(Register (ptr32 Eq_89851) eax, Register Eq_4 ebx, Register Eq_4 esi, Register Eq_4 edi, Register out Eq_4 ediOut)
// Called from:
//      runtime.memequal
//      runtime.memequal_varlen
//      runtime.eqstring
Eq_4 runtime.memeqbody(union Eq_89851 * eax, Eq_4 ebx, Eq_4 esi, Eq_4 edi, union Eq_4 & ediOut)
{
	if (ebx < 0x04)
	{
		Eq_89851 Z_42 = SLICE(cond(ebx), bool, 2);
		if (ebx != 0x00)
		{
			byte cl_18 = (byte) -(ebx * 0x08);
			if ((byte) esi <= 252)
				esi = *esi;
			else
				esi = Mem0[esi - 0x04 + ebx:word32] >>u cl_18;
			uint32 edi_32;
			if ((byte) edi <= 252)
				edi_32 = (uint32) *edi;
			else
				edi_32 = Mem0[edi - 0x04 + ebx:word32] >>u cl_18;
			edi = edi_32 - esi << cl_18;
			Z_42.u0 = SLICE(cond(edi), bool, 2);
		}
		*eax = (union Eq_89851 *) Z_42;
		ediOut = edi;
		return esi;
	}
	else if (ebx < 0x40 || g_t815757E != 0x01)
	{
		do
		{
			if (ebx <= 0x04)
			{
				Mem64[eax + 0x00:byte] = Mem0[esi_121 - 0x04 + ebx:word32] == Mem0[(edi_122 - 0x04) + ebx:word32];
				ediOut = edi_122;
				return esi_121;
			}
			esi = (word32) esi_121 + 4;
			edi = (word32) edi_122 + 4;
			ebx -= 0x04;
			esi_121 = esi;
			edi_122 = edi;
		} while (*esi_121 == *edi_122);
		*eax = (union Eq_89851 *) 0x00;
		ediOut = edi;
		return esi;
	}
}

// 0808FB10: void runtime.cmpstring(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime/debug.SetTraceback
//      reflect.typesByString
void runtime.cmpstring(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	runtime.cmpbody(fp + 0x14, dwArg10, dwArg08, dwArg04, dwArg0C);
}

// 0808FB30: void strings.IndexByte(Stack (ptr32 (arr Eq_5840)) dwArg04, Stack Eq_4 dwArg08, Stack Eq_5840 bArg0C)
// Called from:
//      runtime.panicwrap
void strings.IndexByte(Eq_5840 (* dwArg04)[], Eq_4 dwArg08, Eq_5840 bArg0C)
{
	Eq_4 ecx_10 = dwArg08;
	Eq_5840 (* edi_12)[] = dwArg04;
	while (ecx_10 != 0x00)
	{
		Z = SLICE(cond(bArg0C - edi_69[0]), bool, 2);
		edi_12 = (Eq_5840 (*)[]) ((char *) edi_69 + 1);
		--ecx_10;
		edi_69 = edi_12;
		if (bArg0C != edi_69[0])
			break;
	}
	if (Z)
		;
}

// 0808FB60: void runtime.cmpbody(Register (ptr32 uint32) eax, Register Eq_4 edx, Register Eq_4 ebx, Register Eq_4 esi, Register Eq_4 edi)
// Called from:
//      runtime.cmpstring
void runtime.cmpbody(uint32 * eax, Eq_4 edx, Eq_4 ebx, Eq_4 esi, Eq_4 edi)
{
	Eq_4 ebp_10 = edx;
	int32 edx_7 = edx - ebx;
	if (edx_7 > 0x00)
		ebp_10 = ebx;
	if (esi != edi)
	{
		if (ebp_10 >= 0x04)
		{
			if (g_t815757E == 0x01 && ebp_10 >= 0x10)
				;
			while (true)
			{
				ui32 ecx_118;
				ui32 ebx_117;
				if (ebp_10 <= 0x04)
					break;
				ebx_117 = (ui32) *esi;
				ecx_118 = (ui32) *edi;
				if (ebx_117 != ecx_118)
					goto l0808FBE6;
				esi = (word32) esi + 4;
				edi = (word32) edi + 4;
				ebp_10 -= 0x04;
			}
			ebx_117 = (ui32) *((word32) ebp_10 + (esi - 0x04));
			ecx_118 = Mem0[edi - 0x04 + ebp_10:word32];
			if (ebx_117 != ecx_118)
			{
l0808FBE6:
				uint32 ebx_122 = __bswap(ebx_117);
				*eax = (ebx_122 >> (byte) __bsr(__bswap(ecx_118) ^ ebx_122) & 0x01) * 0x02 + ~0x00;
				return;
			}
		}
		else
		{
			ui32 ecx_21 = -(ebp_10 * 0x08);
			byte cl_39 = (byte) ecx_21;
			if (ecx_21 != 0x00)
			{
				uint32 esi_40;
				if ((byte) esi <= 252)
					esi_40 = (uint32) *esi;
				else
					esi_40 = Mem0[esi - 0x04 + ebp_10:word32] >>u cl_39;
				uint32 edi_60;
				ui32 esi_45 = esi_40 << cl_39;
				if ((byte) edi <= 252)
					edi_60 = (uint32) *edi;
				else
					edi_60 = Mem0[edi - 0x04 + ebp_10:word32] >>u cl_39;
				uint32 esi_67 = __bswap(esi_45);
				ui32 edi_69 = __bswap(edi_60 << cl_39) ^ esi_67;
				if (edi_69 != 0x00)
				{
					*eax = (esi_67 >> (byte) __bsr(edi_69) & 0x01) * 0x02 + ~0x00;
					return;
				}
			}
		}
	}
	*eax = (uint32) (uint8) (edx_7 == 0x00) - 0x01 + (uint32) ((uint8) (edx_7 < 0x00)) * 0x02;
}

// 0808FC60: Register word32 runtime.return0()
// Called from:
//      runtime.deferproc
word32 runtime.return0()
{
	return 0x00;
}

// 0808FC70: void runtime.goexit(Register (ptr32 Eq_2) gs)
void runtime.goexit(struct Eq_2 * gs)
{
	runtime.goexit1(gs);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	runtime.prefetcht0();
}

// 0808FC80: void runtime.prefetcht0()
// Called from:
//      runtime.testAtomic64
//      runtime.goexit
void runtime.prefetcht0()
{
}

// 0808FC90: void runtime.prefetcht1()
// Called from:
//      runtime.testAtomic64
void runtime.prefetcht1()
{
}

// 0808FCA0: void runtime.prefetcht2()
// Called from:
//      runtime.testAtomic64
void runtime.prefetcht2()
{
}

// 0808FCB0: void runtime.prefetchnta()
// Called from:
//      runtime.testAtomic64
void runtime.prefetchnta()
{
}

// 0808FCC0: void runtime.uint32tofloat64()
// Called from:
//      runtime.nextSample
//      runtime.deductSweepCredit
//      runtime.int64tofloat64
//      runtime.uint64tofloat64
void runtime.uint32tofloat64()
{
}

// 0808FCE0: void runtime.float64touint32()
// Called from:
//      runtime._d2v
void runtime.float64touint32()
{
	uint16 wLoc0C_17 = __fstcw();
	__fldcw(g_w8136008);
	__fldcw(wLoc0C_17);
}

// 0808FD10: void runtime.duffzero(Register word32 eax, Register (ptr32 Eq_42856) edi)
// Called from:
//      runtime.sysargs
void runtime.duffzero(word32 eax, struct Eq_42856 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	edi->dw001C = eax;
	edi->dw0020 = eax;
	edi->dw0024 = eax;
	edi->dw0028 = eax;
	edi->dw002C = eax;
	edi->dw0030 = eax;
	edi->dw0034 = eax;
	edi->dw0038 = eax;
	edi->dw003C = eax;
	edi->dw0040 = eax;
	edi->dw0044 = eax;
	edi->dw0048 = eax;
	edi->dw004C = eax;
	edi->dw0050 = eax;
	edi->dw0054 = eax;
	edi->dw0058 = eax;
	edi->dw005C = eax;
	edi->dw0060 = eax;
	edi->dw0064 = eax;
	edi->dw0068 = eax;
	edi->dw006C = eax;
	edi->dw0070 = eax;
	edi->dw0074 = eax;
	edi->dw0078 = eax;
	edi->dw007C = eax;
	edi->dw0080 = eax;
	edi->dw0084 = eax;
	edi->dw0088 = eax;
	edi->dw008C = eax;
	edi->dw0090 = eax;
	edi->dw0094 = eax;
	edi->dw0098 = eax;
	edi->dw009C = eax;
	edi->dw00A0 = eax;
	edi->dw00A4 = eax;
	edi->dw00A8 = eax;
	edi->dw00AC = eax;
	edi->dw00B0 = eax;
	edi->dw00B4 = eax;
	edi->dw00B8 = eax;
	edi->dw00BC = eax;
	edi->dw00C0 = eax;
	edi->dw00C4 = eax;
	edi->dw00C8 = eax;
	edi->dw00CC = eax;
	edi->dw00D0 = eax;
	edi->dw00D4 = eax;
	edi->dw00D8 = eax;
	edi->dw00DC = eax;
	edi->dw00E0 = eax;
	edi->dw00E4 = eax;
	edi->dw00E8 = eax;
	edi->dw00EC = eax;
	edi->dw00F0 = eax;
	edi->dw00F4 = eax;
	edi->dw00F8 = eax;
	edi->dw00FC = eax;
	edi->dw0100 = eax;
	edi->dw0104 = eax;
	edi->dw0108 = eax;
	edi->dw010C = eax;
	edi->dw0110 = eax;
	edi->dw0114 = eax;
	edi->dw0118 = eax;
	edi->dw011C = eax;
	edi->dw0120 = eax;
	edi->dw0124 = eax;
	edi->dw0128 = eax;
	edi->dw012C = eax;
	fn0808FD5C(eax, &edi->dw012C + 1);
}

// 0808FD50: void fn0808FD50(Register word32 eax, Register (ptr32 Eq_56624) edi)
// Called from:
//      runtime.sigprof
void fn0808FD50(word32 eax, struct Eq_56624 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	edi->dw001C = eax;
	edi->dw0020 = eax;
	edi->dw0024 = eax;
	edi->dw0028 = eax;
	edi->dw002C = eax;
	fn0808FD5C(eax, &edi->dw002C + 1);
}

// 0808FD5C: void fn0808FD5C(Register word32 eax, Register (ptr32 Eq_69469) edi)
// Called from:
//      runtime.copystack
//      runtime.duffzero
//      fn0808FD50
void fn0808FD5C(word32 eax, struct Eq_69469 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	fn0808FD60(eax, &edi->dw000C + 1);
}

// 0808FD60: void fn0808FD60(Register word32 eax, Register (ptr32 Eq_29714) edi)
// Called from:
//      runtime.scanstack
//      runtime.moduledataverify1
//      runtime.gentraceback
//      fn0808FD5C
void fn0808FD60(word32 eax, struct Eq_29714 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	edi->dw001C = eax;
	edi->dw0020 = eax;
	edi->dw0024 = eax;
	edi->dw0028 = eax;
	edi->dw002C = eax;
	edi->dw0030 = eax;
	edi->dw0034 = eax;
	edi->dw0038 = eax;
	edi->dw003C = eax;
	fn0808FD70(eax, &edi->dw003C + 1);
}

// 0808FD6D: Register (ptr32 Eq_40258) fn0808FD6D(Register word32 eax, Register (ptr32 Eq_40258) edi)
// Called from:
//      runtime.typelinksinit
struct Eq_40258 * fn0808FD6D(word32 eax, struct Eq_40258 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	return fn0808FD70(eax, &edi->dw0008 + 1);
}

// 0808FD70: Register (ptr32 Eq_40254) fn0808FD70(Register word32 eax, Register (ptr32 Eq_40254) edi)
// Called from:
//      runtime.mProf_Malloc
//      runtime.saveblockevent
//      runtime.stringtoslicerune
//      runtime.tracebackCgoContext
//      fn0808FD60
//      fn0808FD6D
struct Eq_40254 * fn0808FD70(word32 eax, struct Eq_40254 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	return fn0808FD77(eax, &edi->dw0018 + 1);
}

// 0808FD77: Register (ptr32 Eq_45952) fn0808FD77(Register word32 eax, Register (ptr32 Eq_45952) edi)
// Called from:
//      runtime.printuint
//      runtime.printhex
//      fn0808FD70
struct Eq_45952 * fn0808FD77(word32 eax, struct Eq_45952 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	edi->dw001C = eax;
	edi->dw0020 = eax;
	edi->dw0024 = eax;
	edi->dw0028 = eax;
	edi->dw002C = eax;
	edi->dw0030 = eax;
	edi->dw0034 = eax;
	edi->dw0038 = eax;
	edi->dw003C = eax;
	edi->dw0040 = eax;
	edi->dw0044 = eax;
	edi->dw0048 = eax;
	edi->dw004C = eax;
	edi->dw0050 = eax;
	edi->dw0054 = eax;
	edi->dw0058 = eax;
	edi->dw005C = eax;
	edi->dw0060 = eax;
	return &edi->dw0060 + 1;
}

// 0808FD80: Register (ptr32 Eq_5995) fn0808FD80(Register Eq_4 eax, Register (ptr32 Eq_5995) edi)
// Called from:
//      strconv.formatBits
//      reflect.implements
//      reflect.funcStr
struct Eq_5995 * fn0808FD80(Eq_4 eax, struct Eq_5995 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	return fn0808FD82(eax, (char *) &edi->t0004 + 4);
}

// 0808FD82: Register (ptr32 Eq_5991) fn0808FD82(Register Eq_4 eax, Register (ptr32 Eq_5991) edi)
// Called from:
//      runtime.Caller
//      fn0808FD80
struct Eq_5991 * fn0808FD82(Eq_4 eax, struct Eq_5991 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	edi->t0008 = eax;
	return fn0808FD85(eax, (char *) &edi->t0008 + 4);
}

// 0808FD83: Register (ptr32 Eq_4) fn0808FD83(Register Eq_4 eax, Register (ptr32 Eq_4) edi)
// Called from:
//      reflect.(*structType).Field
//      reflect.(*structType).FieldByIndex
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.(*funcType).Field
//      reflect.(*funcType).FieldByIndex
//      reflect.(*funcType).FieldByName
//      reflect.(*funcType).FieldByNameFunc
//      reflect.(*funcTypeFixed128).Field
//      reflect.(*funcTypeFixed128).FieldByIndex
//      reflect.(*funcTypeFixed128).FieldByName
//      reflect.(*funcTypeFixed128).FieldByNameFunc
//      reflect.(*funcTypeFixed16).Field
//      reflect.(*funcTypeFixed16).FieldByIndex
//      reflect.(*funcTypeFixed16).FieldByName
//      reflect.(*funcTypeFixed16).FieldByNameFunc
//      reflect.(*funcTypeFixed32).Field
//      reflect.(*funcTypeFixed32).FieldByIndex
//      reflect.(*funcTypeFixed32).FieldByName
//      reflect.(*funcTypeFixed32).FieldByNameFunc
//      reflect.(*funcTypeFixed4).Field
//      reflect.(*funcTypeFixed4).FieldByIndex
//      reflect.(*funcTypeFixed4).FieldByName
//      reflect.(*funcTypeFixed4).FieldByNameFunc
//      reflect.(*funcTypeFixed64).Field
//      reflect.(*funcTypeFixed64).FieldByIndex
//      reflect.(*funcTypeFixed64).FieldByName
//      reflect.(*funcTypeFixed64).FieldByNameFunc
//      reflect.(*funcTypeFixed8).Field
//      reflect.(*funcTypeFixed8).FieldByIndex
//      reflect.(*funcTypeFixed8).FieldByName
//      reflect.(*funcTypeFixed8).FieldByNameFunc
//      reflect.(*interfaceType).Field
//      reflect.(*interfaceType).FieldByIndex
//      reflect.(*interfaceType).FieldByName
//      reflect.(*interfaceType).FieldByNameFunc
//      reflect.(*ptrType).Field
//      reflect.(*ptrType).FieldByIndex
//      reflect.(*ptrType).FieldByName
//      reflect.(*ptrType).FieldByNameFunc
//      reflect.(*sliceType).Field
//      reflect.(*sliceType).FieldByIndex
//      reflect.(*sliceType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
union Eq_4 * fn0808FD83(Eq_4 eax, union Eq_4 * edi)
{
	*edi = (union Eq_4 *) eax;
	return fn0808FD84(eax, (char *) edi + 4);
}

// 0808FD84: Register (ptr32 Eq_5991) fn0808FD84(Register Eq_4 eax, Register (ptr32 Eq_5991) edi)
// Called from:
//      fn0808FD83
//      sync.(*Map).dirtyLocked
struct Eq_5991 * fn0808FD84(Eq_4 eax, struct Eq_5991 * edi)
{
	edi->t0000 = eax;
	return fn0808FD85(eax, &edi->t0004);
}

// 0808FD85: Register (ptr32 Eq_4) fn0808FD85(Register Eq_4 eax, Register (ptr32 Eq_4) edi)
// Called from:
//      runtime.tracebackdefers
//      runtime.gentraceback
//      fn0808FD82
//      fn0808FD84
union Eq_4 * fn0808FD85(Eq_4 eax, union Eq_4 * edi)
{
	*edi = (union Eq_4 *) eax;
	return fn0808FD86(eax, (char *) edi + 4);
}

// 0808FD86: Register (ptr32 Eq_18147) fn0808FD86(Register Eq_4 eax, Register (ptr32 Eq_18147) edi)
// Called from:
//      runtime.heapBitsSetTypeGCProg
//      runtime.gcMarkTermination
//      fn0808FD85
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).Method
//      reflect.(*interfaceType).MethodByName
//      reflect.(*structType).Method
//      reflect.(*structType).MethodByName
//      reflect.(*funcType).Method
//      reflect.(*funcType).MethodByName
//      reflect.(*funcTypeFixed128).Method
//      reflect.(*funcTypeFixed128).MethodByName
//      reflect.(*funcTypeFixed16).Method
//      reflect.(*funcTypeFixed16).MethodByName
//      reflect.(*funcTypeFixed32).Method
//      reflect.(*funcTypeFixed32).MethodByName
//      reflect.(*funcTypeFixed4).Method
//      reflect.(*funcTypeFixed4).MethodByName
//      reflect.(*funcTypeFixed64).Method
//      reflect.(*funcTypeFixed64).MethodByName
//      reflect.(*funcTypeFixed8).Method
//      reflect.(*funcTypeFixed8).MethodByName
//      reflect.(*ptrType).Method
//      reflect.(*ptrType).MethodByName
//      reflect.(*sliceType).Method
//      reflect.(*sliceType).MethodByName
struct Eq_18147 * fn0808FD86(Eq_4 eax, struct Eq_18147 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	edi->t0008 = eax;
	return fn0808FD89(eax, (char *) &edi->t0008 + 4);
}

// 0808FD87: void fn0808FD87(Register Eq_4 eax, Register (ptr32 Eq_78872) edi)
// Called from:
//      runtime.callers
void fn0808FD87(Eq_4 eax, struct Eq_78872 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	fn0808FD89(eax, (char *) &edi->t0004 + 4);
}

// 0808FD88: void fn0808FD88(Register Eq_4 eax, Register (ptr32 Eq_4) edi)
// Called from:
//      runtime.panicwrap
//      runtime.Caller
//      runtime.stringtoslicebyte
//      runtime.(*Frames).Next
//      runtime.(*stackExpander).next
//      runtime.(*pcExpander).next
//      strconv.(*extFloat).FixedDecimal
//      strconv.genericFtoa
//      syscall.uitoa
//      reflect.haveIdenticalUnderlyingType
void fn0808FD88(Eq_4 eax, union Eq_4 * edi)
{
	*edi = (union Eq_4 *) eax;
	fn0808FD89(eax, (char *) edi + 4);
}

// 0808FD89: Register Eq_4 fn0808FD89(Register Eq_4 eax, Register Eq_4 edi)
// Called from:
//      runtime.freedefer
//      runtime.expandCgoFrames
//      runtime.tracebackCgoContext
//      runtime.printCgoTraceback
//      runtime.typelinksinit
//      fn0808FD86
//      fn0808FD87
//      fn0808FD88
Eq_4 fn0808FD89(Eq_4 eax, Eq_4 edi)
{
	*edi = eax;
	*((word32) edi + 4) = eax;
	return fn0808FD8B(eax, (word32) edi + 8);
}

// 0808FD8A: void fn0808FD8A(Register Eq_4 eax, Register (ptr32 word32) edi)
// Called from:
//      runtime.SetFinalizer
//      runtime.gcMarkTermination
//      runtime.(*mspan).sweep
//      runtime.sigprof
//      runtime.sigtrampgo
//      runtime.traceGoStart
//      runtime.traceGoSysExit
//      strconv.(*decimal).Assign
//      strconv.(*extFloat).ShortestDecimal
//      strconv.genericFtoa
//      strconv.bigFtoa
void fn0808FD8A(Eq_4 eax, word32 * edi)
{
	*edi = (word32) eax;
	fn0808FD8B(eax, edi + 1);
}

// 0808FD8B: Register (ptr32 Eq_2499) fn0808FD8B(Register Eq_4 eax, Register (ptr32 Eq_2499) edi)
// Called from:
//      runtime.cgoCheckTypedBlock
//      runtime.persistentalloc
//      runtime.typedslicecopy
//      runtime.(*mheap).alloc
//      runtime.setsig
//      runtime.setsigstack
//      runtime.getsig
//      runtime.testdefersizes
//      runtime.gopanic
//      runtime.entersyscallblock
//      runtime.newproc
//      runtime.sigtrampgo
//      fn0808FD89
//      fn0808FD8A
//      sync.init.1
//      reflect.funcLayout
struct Eq_2499 * fn0808FD8B(Eq_4 eax, struct Eq_2499 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	edi->t0008 = eax;
	edi->t000C = eax;
	edi->t0010 = eax;
	return (char *) &edi->t0010 + 4;
}

// 0808FDA0: void runtime.duffcopy(Register (ptr32 Eq_90689) esi, Register (ptr32 Eq_90690) edi)
void runtime.duffcopy(struct Eq_90689 * esi, struct Eq_90690 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	edi->dw0008 = esi->dw0008;
	edi->dw000C = esi->dw000C;
	edi->dw0010 = esi->dw0010;
	edi->dw0014 = esi->dw0014;
	edi->dw0018 = esi->dw0018;
	edi->dw001C = esi->dw001C;
	edi->dw0020 = esi->dw0020;
	edi->dw0024 = esi->dw0024;
	edi->dw0028 = esi->dw0028;
	edi->dw002C = esi->dw002C;
	edi->dw0030 = esi->dw0030;
	edi->dw0034 = esi->dw0034;
	edi->dw0038 = esi->dw0038;
	edi->dw003C = esi->dw003C;
	edi->dw0040 = esi->dw0040;
	edi->dw0044 = esi->dw0044;
	edi->dw0048 = esi->dw0048;
	edi->dw004C = esi->dw004C;
	edi->dw0050 = esi->dw0050;
	edi->dw0054 = esi->dw0054;
	edi->dw0058 = esi->dw0058;
	edi->dw005C = esi->dw005C;
	edi->dw0060 = esi->dw0060;
	edi->dw0064 = esi->dw0064;
	edi->dw0068 = esi->dw0068;
	edi->dw006C = esi->dw006C;
	edi->dw0070 = esi->dw0070;
	edi->dw0074 = esi->dw0074;
	edi->dw0078 = esi->dw0078;
	edi->dw007C = esi->dw007C;
	edi->dw0080 = esi->dw0080;
	edi->dw0084 = esi->dw0084;
	edi->dw0088 = esi->dw0088;
	edi->dw008C = esi->dw008C;
	edi->dw0090 = esi->dw0090;
	edi->dw0094 = esi->dw0094;
	edi->dw0098 = esi->dw0098;
	edi->dw009C = esi->dw009C;
	edi->dw00A0 = esi->dw00A0;
	edi->dw00A4 = esi->dw00A4;
	edi->dw00A8 = esi->dw00A8;
	edi->dw00AC = esi->dw00AC;
	edi->dw00B0 = esi->dw00B0;
	edi->dw00B4 = esi->dw00B4;
	edi->dw00B8 = esi->dw00B8;
	edi->dw00BC = esi->dw00BC;
	edi->dw00C0 = esi->dw00C0;
	edi->dw00C4 = esi->dw00C4;
	edi->dw00C8 = esi->dw00C8;
	edi->dw00CC = esi->dw00CC;
	edi->dw00D0 = esi->dw00D0;
	edi->dw00D4 = esi->dw00D4;
	edi->dw00D8 = esi->dw00D8;
	edi->dw00DC = esi->dw00DC;
	edi->dw00E0 = esi->dw00E0;
	edi->dw00E4 = esi->dw00E4;
	edi->dw00E8 = esi->dw00E8;
	edi->dw00EC = esi->dw00EC;
	edi->dw00F0 = esi->dw00F0;
	edi->dw00F4 = esi->dw00F4;
	edi->dw00F8 = esi->dw00F8;
	edi->dw00FC = esi->dw00FC;
	edi->dw0100 = esi->dw0100;
	edi->dw0104 = esi->dw0104;
	edi->dw0108 = esi->dw0108;
	edi->dw010C = esi->dw010C;
	edi->dw0110 = esi->dw0110;
	edi->dw0114 = esi->dw0114;
	edi->dw0118 = esi->dw0118;
	edi->dw011C = esi->dw011C;
	edi->dw0120 = esi->dw0120;
	edi->dw0124 = esi->dw0124;
	edi->dw0128 = esi->dw0128;
	edi->dw012C = esi->dw012C;
	edi->dw0130 = esi->dw0130;
	edi->dw0134 = esi->dw0134;
	edi->dw0138 = esi->dw0138;
	edi->dw013C = esi->dw013C;
	edi->dw0140 = esi->dw0140;
	edi->dw0144 = esi->dw0144;
	edi->dw0148 = esi->dw0148;
	edi->dw014C = esi->dw014C;
	edi->dw0150 = esi->dw0150;
	edi->dw0154 = esi->dw0154;
	edi->dw0158 = esi->dw0158;
	edi->dw015C = esi->dw015C;
	edi->dw0160 = esi->dw0160;
	edi->dw0164 = esi->dw0164;
	edi->dw0168 = esi->dw0168;
	edi->dw016C = esi->dw016C;
	edi->dw0170 = esi->dw0170;
	edi->dw0174 = esi->dw0174;
	edi->dw0178 = esi->dw0178;
	edi->dw017C = esi->dw017C;
	fn08090160(&esi->dw017C + 1, &edi->dw017C + 1);
}

// 08090160: void fn08090160(Register Eq_4 esi, Register (ptr32 Eq_78473) edi)
// Called from:
//      runtime.tracebackCgoContext
//      runtime.traceback1
//      runtime.duffcopy
void fn08090160(Eq_4 esi, struct Eq_78473 * edi)
{
	edi->dw0000 = (word32) *esi;
	edi->t0004 = *((word32) esi + 4);
	edi->t0008 = *((word32) esi + 8);
	edi->t000C = *((word32) esi + 0x0C);
	edi->t0010 = *((word32) esi + 16);
	edi->t0014 = *((word32) esi + 20);
	edi->t0018 = *((word32) esi + 24);
	edi->t001C = *((word32) esi + 28);
	edi->t0020 = *((word32) esi + 32);
	edi->t0024 = *((word32) esi + 36);
	edi->t0028 = *((word32) esi + 40);
	edi->t002C = *((word32) esi + 44);
	edi->t0030 = *((word32) esi + 48);
	edi->t0034 = *((word32) esi + 52);
	edi->t0038 = *((word32) esi + 56);
	edi->t003C = *((word32) esi + 60);
	edi->t0040 = *((word32) esi + 64);
	edi->t0044 = *((word32) esi + 0x0044);
	edi->t0048 = *((word32) esi + 72);
	edi->t004C = *((word32) esi + 76);
	edi->t0050 = *((word32) esi + 80);
	edi->t0054 = *((word32) esi + 84);
	edi->t0058 = *((word32) esi + 88);
	edi->t005C = *((word32) esi + 92);
	edi->t0060 = *((word32) esi + 96);
	fn0809025A((word32) esi + 100, (char *) &edi->t0060 + 4);
}

// 080901EC: void fn080901EC(Register (ptr32 Eq_5945) esi, Register (ptr32 Eq_5946) edi)
// Called from:
//      runtime.panicwrap
void fn080901EC(struct Eq_5945 * esi, struct Eq_5946 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	edi->dw0008 = esi->dw0008;
	edi->dw000C = esi->dw000C;
	edi->dw0010 = esi->dw0010;
	fn0809021E(&esi->dw0010 + 1, &edi->dw0010 + 1);
}

// 0809021E: void fn0809021E(Register Eq_4 esi, Register (ptr32 Eq_91462) edi)
// Called from:
//      fn080901EC
//      reflect.(*structType).FieldByIndex
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.(*sliceType).Field
//      reflect.(*sliceType).FieldByIndex
//      reflect.(*sliceType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
//      fmt.(*pp).printValue
void fn0809021E(Eq_4 esi, struct Eq_91462 * edi)
{
	edi->dw0000 = (word32) *esi;
	edi->dw0004 = (word32) *((word32) esi + 4);
	edi->t0008 = *((word32) esi + 8);
	edi->t000C = *((word32) esi + 0x0C);
	edi->t0010 = *((word32) esi + 16);
	fn08090250((word32) esi + 20, (char *) &edi->t0010 + 4);
}

// 08090228: void fn08090228(Register (ptr32 Eq_5146) esi, Register (ptr32 Eq_5147) edi)
// Called from:
//      runtime.(*TypeAssertionError).Error
void fn08090228(struct Eq_5146 * esi, struct Eq_5147 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	fn0809023C(&esi->dw0004 + 1, &edi->dw0004 + 1);
}

// 0809023C: void fn0809023C(Register (ptr32 Eq_91518) esi, Register (ptr32 Eq_91519) edi)
// Called from:
//      fn08090228
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).MethodByName
//      reflect.(*sliceType).MethodByName
void fn0809023C(struct Eq_91518 * esi, struct Eq_91519 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	fn08090250(&esi->dw0004 + 1, &edi->dw0004 + 1);
}

// 08090246: void fn08090246(Register (ptr32 word32) esi, Register Eq_4 edi)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
void fn08090246(word32 * esi, Eq_4 edi)
{
	*edi = *esi;
	fn08090250(esi + 1, (word32) edi + 4);
}

// 08090250: void fn08090250(Register Eq_4 esi, Register Eq_4 edi)
// Called from:
//      runtime.panicwrap
//      runtime.Caller
//      runtime.(*Frames).Next
//      runtime.(*stackExpander).next
//      runtime.(*pcExpander).next
//      runtime.expandCgoFrames
//      fn0809021E
//      fn0809023C
//      fn08090246
void fn08090250(Eq_4 esi, Eq_4 edi)
{
	*edi = *esi;
	fn0809025A((word32) esi + 4, (word32) edi + 4);
}

// 0809025A: void fn0809025A(Register (ptr32 Eq_69665) esi, Register (ptr32 Eq_69666) edi)
// Called from:
//      runtime.newstack
//      fn08090160
//      fn08090250
void fn0809025A(struct Eq_69665 * esi, struct Eq_69666 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	edi->dw0008 = esi->dw0008;
	edi->dw000C = esi->dw000C;
	edi->dw0010 = esi->dw0010;
	edi->dw0014 = esi->dw0014;
	edi->dw0018 = esi->dw0018;
}

// 08090264: void fn08090264(Register (ptr32 word32) esi, Register (ptr32 word32) edi)
// Called from:
//      runtime.cgocallbackg
//      strconv.genericFtoa
//      strconv.bigFtoa
//      strconv.formatDigits
void fn08090264(word32 * esi, word32 * edi)
{
	*edi = *esi;
	fn0809026E(esi + 1, edi + 1);
}

// 0809026E: void fn0809026E(Register Eq_4 esi, Register (ptr32 Eq_73286) edi)
// Called from:
//      runtime.moduledataverify1
//      fn08090264
//      reflect.funcLayout
void fn0809026E(Eq_4 esi, struct Eq_73286 * edi)
{
	edi->dw0000 = (word32) *esi;
	edi->t0004 = *((word32) esi + 4);
	edi->t0008 = *((word32) esi + 8);
	edi->t000C = *((word32) esi + 0x0C);
	edi->t0010 = *((word32) esi + 16);
}

// 08090278: Register (ptr32 Eq_14001) fn08090278(Register (ptr32 Eq_14001) esi, Register (ptr32 Eq_14002) edi)
// Called from:
//      runtime.mallocinit
struct Eq_14001 * fn08090278(struct Eq_14001 * esi, struct Eq_14002 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	edi->dw0008 = esi->dw0008;
	edi->dw000C = esi->dw000C;
	return &esi->dw000C + 1;
}

// 080902B0: Register Eq_4 runtime.memclrNoHeapPointers(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.evacuate
//      runtime.mallocgc
//      runtime.typedmemclr
//      runtime.memclrHasPointers
//      runtime.heapBits.initSpan
//      runtime.heapBitsSetTypeGCProg
//      runtime.(*fixalloc).alloc
//      runtime.(*mheap).alloc
//      runtime.newArenaMayUnlock
//      runtime.newproc1
//      runtime.growslice
//      runtime.rawbyteslice
//      runtime.rawruneslice
//      reflect.memclrNoHeapPointers
Eq_4 runtime.memclrNoHeapPointers(Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 edi_17 = dwArg04;
	Eq_4 ebx_10;
	Eq_91682 ax_115 = 0x00;
	do
	{
		byte al_16 = (byte) ax_115;
		if (ebx_10 == 0x00)
			return edi_17;
		if (ebx_10 <= 0x02)
		{
			*edi_17 = al_16;
			*((word32) ebx_10 + (edi_17 - 0x01)) = al_16;
			return edi_17;
		}
		ax_115.u0 = (uint32) (uint16) ax_115;
		if (ebx_10 < 0x04)
		{
			*edi_17 = ax_115;
			*((word32) edi_17 + 2) = al_16;
			return edi_17;
		}
		if (ebx_10 == 0x04)
		{
			*edi_17 = ax_115;
			return edi_17;
		}
		if (ebx_10 <= 0x08)
		{
			*edi_17 = ax_115;
			Mem34[edi_17 - 0x04 + ebx_10:word32] = ax_115;
			return edi_17;
		}
		if (ebx_10 <= 0x10)
		{
			*edi_17 = ax_115;
			*((word32) edi_17 + 4) = ax_115;
			Mem39[edi_17 - 0x08 + ebx_10:word32] = ax_115;
			Mem40[edi_17 - 0x04 + ebx_10:word32] = ax_115;
			return edi_17;
		}
		if (g_t815757E == 0x01)
		{
			if (ebx_10 <= 0x20)
				;
			if (ebx_10 <= 0x40)
				;
			if (ebx_10 <= 0x80)
				;
			if (ebx_10 <= 0x0100)
				;
		}
		uint32 ecx_45;
		for (ecx_45 = ebx_10 >> 0x02; ecx_45 != 0x00; --ecx_45)
		{
			*edi_17 = ax_115;
			edi_17 += 4;
		}
		ebx_10 &= 0x03;
	} while (ebx_10 != 0x00);
	return edi_17;
}

// 08090490: Register Eq_4 runtime.memmove(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebpOut, Register out Eq_4 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.sendDirect
//      runtime.recvDirect
//      runtime.(*cpuProfile).addNonGo
//      runtime.typedmemmove
//      reflect.typedmemmovepartial
//      runtime.reflectcallmove
//      runtime.typedslicecopy
//      runtime.(*gcSweepBuf).push
//      runtime.handoff
//      runtime.stkbucket
//      runtime.getRandomData
//      runtime.deferproc
//      runtime.deferreturn
//      runtime.recordForPanic
//      runtime.gwrite
//      runtime.newproc1
//      runtime.sigprof
//      runtime.(*profBuf).write
//      runtime.growslice
//      runtime.syncadjustsudogs
//      runtime.copystack
//      runtime.concatstrings
//      runtime.slicebytetostring
//      runtime.stringtoslicebyte
//      runtime.gostring
//      runtime.name.pkgPath
//      strconv.(*decimal).String
//      strconv.genericFtoa
//      strconv.fmtE
//      strconv.fmtF
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendEscapedRune
//      syscall.ByteSliceFromString
//      reflect.name.pkgPath
//      reflect.newName
//      reflect.(*structType).FieldByNameFunc
//      reflect.funcStr
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_float
//      fmt.(*pp).Write
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printValue
Eq_4 runtime.memmove(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebpOut, union Eq_4 & esiOut, union Eq_4 & ediOut)
{
	Eq_4 edi_110 = dwArg04;
	Eq_4 esi_107 = dwArg08;
	Eq_4 ebx_103 = dwArg0C;
	while (ebx_103 != 0x00)
	{
		if (ebx_103 <= 0x02)
		{
			byte cl_17 = *((word32) ebx_103 + (esi_107 - 0x01));
			*edi_110 = *esi_107;
			Mem20[edi_110 - 0x01 + ebx_103:byte] = cl_17;
			ebpOut = ebp;
			esiOut = esi_107;
			ediOut = edi_110;
			return <invalid>;
		}
		if (ebx_103 < 0x04)
		{
			byte cl_24 = *((word32) esi_107 + 2);
			*edi_110 = *esi_107;
			*((word32) edi_110 + 2) = cl_24;
			ebpOut = ebp;
			esiOut = esi_107;
			ediOut = edi_110;
			return <invalid>;
		}
		if (ebx_103 == 0x04)
		{
			*edi_110 = *esi_107;
			ebpOut = ebp;
			esiOut = esi_107;
			ediOut = edi_110;
			return <invalid>;
		}
		if (ebx_103 <= 0x08)
		{
			word32 ecx_33 = Mem15[esi_107 - 0x04 + ebx_103:word32];
			*edi_110 = *esi_107;
			Mem35[edi_110 - 0x04 + ebx_103:word32] = ecx_33;
			ebpOut = ebp;
			esiOut = esi_107;
			ediOut = edi_110;
			return <invalid>;
		}
		if (ebx_103 <= 0x10)
		{
			word32 ecx_39 = *((word32) esi_107 + 4);
			word32 edx_40 = Mem15[esi_107 - 0x08 + ebx_103:word32];
			word32 ebp_41 = Mem15[esi_107 - 0x04 + ebx_103:word32];
			*edi_110 = *esi_107;
			*((word32) edi_110 + 4) = ecx_39;
			Mem44[edi_110 - 0x08 + ebx_103:word32] = edx_40;
			Mem45[edi_110 - 0x04 + ebx_103:word32] = ebp_41;
			ebpOut = ebp_41;
			esiOut = esi_107;
			ediOut = edi_110;
			return <invalid>;
		}
		if (g_t815757E == 0x01)
		{
			if (ebx_103 <= 0x20)
				;
			if (ebx_103 <= 0x40)
				;
			if (ebx_103 <= 0x80)
				;
		}
		if (esi_107 <= edi_110 && esi_107 + ebx_103 >u edi_110)
		{
			uint32 ecx_67;
			ebx_103 &= 0x03;
			word32 edi_69 = edi_110 + ebx_103 - 0x04;
			word32 esi_70 = esi_107 + ebx_103 - 0x04;
			for (ecx_67 = ebx_103 >> 0x02; ecx_67 != 0x00; --ecx_67)
			{
				*edi_69 = *esi_70;
				esi_70 -= 4;
				edi_69 -= 4;
			}
			edi_110 = (word32) edi_69 + 4 - ebx_103;
			esi_107 = (word32) esi_70 + 4 - ebx_103;
			continue;
		}
		if (g_t815757B == 0x01 && ((esi_107 | edi_110) & 0x03) != 0x00)
		{
			Eq_4 ecx_115;
			for (ecx_115 = ebx_103; ecx_115 != 0x00; --ecx_115)
			{
				*edi_110 = *esi_107;
				++esi_107;
				++edi_110;
			}
			ebpOut = ebp;
			esiOut = esi_107;
			ediOut = edi_110;
			return <invalid>;
		}
		uint32 ecx_102;
		ebx_103 &= 0x03;
		for (ecx_102 = ebx_103 >> 0x02; ecx_102 != 0x00; --ecx_102)
		{
			*edi_110 = *esi_107;
			esi_107 += 4;
			edi_110 += 4;
		}
	}
	ebpOut = ebp;
	esiOut = esi_107;
	ediOut = edi_110;
	return <invalid>;
}

// 08090630: void _rt0_386_linux(Register ui32 ecx, Register ui32 edx, Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Stack Eq_4 dwArg00)
void _rt0_386_linux(ui32 ecx, ui32 edx, struct Eq_2 * gs, Eq_661 xmm0, Eq_4 dwArg00)
{
	ui32 edx_20;
	Eq_661 xmm0_24;
	ui32 ecx_18 = main(ecx, edx, gs, xmm0, dwArg00, fp + 0x04, out edx_20, out xmm0_24);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	word32 edx_56;
	word128 xmm0_57;
	main(ecx_18, edx_20, gs, xmm0_24, fp + 0x04, dwArg00, out edx_56, out xmm0_57);
}

// 08090650: Register ui32 main(Register ui32 ecx, Register ui32 edx, Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 edxOut, Register out Eq_91966 xmm0Out)
// Called from:
//      _rt0_386_linux
ui32 main(ui32 ecx, ui32 edx, struct Eq_2 * gs, Eq_661 xmm0, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & edxOut, union Eq_91966 & xmm0Out)
{
	ptr32 edx_14;
	Eq_91966 xmm0_19;
	ui32 ecx_12 = runtime.rt0_go(ecx, edx, gs, xmm0, dwArg04, dwArg08, out edx_14, out xmm0_19);
	edxOut = edx_14;
	xmm0Out = xmm0_19;
	return ecx_12;
}

// 08090660: Register word32 runtime.exit()
// Called from:
//      runtime.cgocallbackg
//      runtime.sysAlloc
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.main
//      runtime.needm
//      runtime.sighandler
//      runtime.dieFromSignal
//      main
word32 runtime.exit()
{
	__syscall(0x80);
	__syscall(0x03);
	return dwArg04;
}

// 08090670: void runtime.exit1()
// Called from:
//      runtime.clone
void runtime.exit1()
{
	__syscall(0x80);
	__syscall(0x03);
}

// 08090680: void runtime.open()
// Called from:
//      runtime.sysargs
//      runtime.getRandomData
void runtime.open()
{
	__syscall(0x80);
}

// 080906B0: void runtime.closefd()
// Called from:
//      runtime.sysargs
//      runtime.getRandomData
void runtime.closefd()
{
	__syscall(0x80);
}

// 080906D0: Register word32 runtime.write(Register out ptr32 edxOut, Register out ptr32 ebxOut)
// Called from:
//      runtime.badmorestackg0
//      runtime.badmorestackgsignal
//      runtime.needm
//      runtime.writeErr
//      main
word32 runtime.write(ptr32 & edxOut, ptr32 & ebxOut)
{
	__syscall(0x80);
	edxOut = dwArg0C;
	ebxOut = dwArg04;
	return dwArg08;
}

// 08090700: void runtime.read()
// Called from:
//      runtime.sysargs
//      runtime.getRandomData
void runtime.read()
{
	__syscall(0x80);
}

// 08090730: Register word32 runtime.usleep(Register out ptr32 ediOut)
// Called from:
//      runtime.getfull
//      runtime.freezetheworld
//      runtime.lockextra
//      runtime.sysmon
//      runtime.runqgrab
//      runtime.sighandler
//      runtime.raisebadsignal
word32 runtime.usleep(ptr32 & ediOut)
{
	__syscall(0x80);
	ediOut = fp - 0x08;
	return 0x00;
}

// 08090770: void runtime.gettid()
// Called from:
//      runtime.minit
void runtime.gettid()
{
	__syscall(0x80);
}

// 08090780: void runtime.raise()
// Called from:
//      runtime.dieFromSignal
//      runtime.raisebadsignal
void runtime.raise()
{
	__syscall(0x80);
	__syscall(0x80);
}

// 080907A0: void runtime.raiseproc()
// Called from:
//      runtime.sighandler
void runtime.raiseproc()
{
	__syscall(0x80);
	__syscall(0x80);
}

// 080907C0: void runtime.setitimer()
// Called from:
//      runtime.setThreadCPUProfiler
void runtime.setitimer()
{
	__syscall(0x80);
}

// 080907E0: void runtime.mincore()
// Called from:
//      runtime.addrspace_free
//      runtime.sysargs
void runtime.mincore()
{
	__syscall(0x80);
}

// 08090800: void runtime.walltime()
// Called from:
//      time.now
void runtime.walltime()
{
	__syscall(0x80);
}

// 08090830: Register word32 runtime.nanotime()
// Called from:
//      runtime.(*cpuProfile).add
//      runtime.notetsleep_internal
//      runtime.(*gcControllerState).endCycle
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.gcAssistAlloc1
//      runtime.(*mheap).freeSpanLocked
//      runtime.main
//      runtime.forcegchelper
//      runtime.schedinit
//      runtime.casgstatus
//      runtime.scang
//      runtime.findrunnable
//      runtime.procresize
//      runtime.sysmon
//      runtime.schedtrace
//      runtime.extendRandom
//      sync.runtime_nanotime
//      runtime.timerproc
//      time.now
//      runtime.goroutineheader
//      runtime.gcMarkTermination.func2
//      runtime.init
word32 runtime.nanotime()
{
	__syscall(0x80);
	return dwLoc14;
}

// 08090870: Register word32 runtime.rtsigprocmask()
// Called from:
//      runtime.sigprocmask
word32 runtime.rtsigprocmask()
{
	__syscall(0x80);
	if (true)
		__syscall(0x03);
	return dwArg10;
}

// 080908A0: void runtime.rt_sigaction()
// Called from:
//      runtime.setsig
//      runtime.setsigstack
//      runtime.getsig
void runtime.rt_sigaction()
{
	__syscall(0x80);
}

// 080908C0: void runtime.sigfwd(Stack (ptr32 code) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sigfwdgo
void runtime.sigfwd(<anonymous> * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	__align(fp - 44);
	dwArg04();
}

// 08090900: void runtime.sigtramp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_65413) dwArg0C)
// Called from:
//      runtime.cgoSigtramp
void runtime.sigtramp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_65413 * dwArg0C)
{
	runtime.sigtrampgo(gs, dwLoc20, dwArg04, dwArg08, dwArg0C);
}

// 08090950: void runtime.cgoSigtramp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_65413) dwArg0C)
void runtime.cgoSigtramp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_65413 * dwArg0C)
{
	runtime.sigtramp(gs, dwArg04, dwArg08, dwArg0C);
}

// 08090960: void runtime.sigreturn()
void runtime.sigreturn()
{
	__syscall(0x80);
	__syscall(0x03);
}

// 08090970: Register word32 runtime.mmap()
// Called from:
//      runtime.mmap_fixed
//      runtime.sysAlloc
//      runtime.sysFault
//      runtime.sysReserve
//      runtime.sysMap
//      runtime.sysargs
word32 runtime.mmap()
{
	__syscall(0x80);
	return dwArg10;
}

// 080909B0: void runtime.munmap()
// Called from:
//      runtime.mmap_fixed
//      runtime.sysFree
//      runtime.sysargs
void runtime.munmap()
{
	__syscall(0x80);
	if (true)
		__syscall(0x03);
}

// 080909D0: void runtime.madvise()
// Called from:
//      runtime.sysUnused
//      runtime.sysUsed
void runtime.madvise()
{
	__syscall(0x80);
}

// 080909F0: Register word32 runtime.futex(Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.futexsleep
//      runtime.futexwakeup
word32 runtime.futex(ptr32 & esiOut, ptr32 & ediOut)
{
	__syscall(0x80);
	esiOut = dwArg10;
	ediOut = dwArg14;
	return dwArg18;
}

// 08090A20: void runtime.clone(Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack (ptr32 Eq_42752) dwArg08, Stack (ptr32 Eq_42731) dwArg0C, Stack word32 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.newosproc
void runtime.clone(Eq_4 dwArg00, Eq_4 dwArg04, struct Eq_42752 * dwArg08, struct Eq_42731 * dwArg0C, word32 dwArg10, Eq_4 dwArg14)
{
	dwArg08->ptrFFFFFFF0 = dwArg0C;
	dwArg08->dwFFFFFFF4 = dwArg10;
	dwArg08->tFFFFFFF8 = dwArg14;
	dwArg08->dwFFFFFFFC = 0x04D2;
	__syscall(0x80);
	if (0x78 != 0x00)
		return;
	if (dwArg0C != (struct Eq_42731 *) 0x04D2)
		__syscall(0x03);
	__syscall(0x80);
	if (dwArg00 != 0x00 && dwArg04 != 0x00)
	{
		((word32) dwArg00 + 36)->u0 = 0xE0;
		struct Eq_2 * gs_66 = runtime.setldt((word32) dwArg00 + 56);
		gs_66->ptr0000->tFFFFFFFC = dwArg04;
		*((word32) dwArg04 + 24) = dwArg00;
		runtime.stackcheck(gs_66);
		runtime.emptyfunc(gs_66);
	}
	dwArg08();
	runtime.exit1();
	*(word32 *) 0x1005 = 4660;
	runtime.sigaltstack();
}

// 08090AD0: void runtime.sigaltstack()
// Called from:
//      runtime.sigtrampgo
//      runtime.minitSignalStack
//      runtime.unminitSignals
//      runtime.signalstack
//      runtime.clone
void runtime.sigaltstack()
{
	__syscall(0x80);
	if (true)
		__syscall(0x03);
}

// 08090AF0: Register (ptr16 Eq_92211) runtime.setldt(Stack (ptr32 Eq_89727) dwArg08)
// Called from:
//      runtime.ldt0setup
//      runtime.clone
struct Eq_92211 * runtime.setldt(struct Eq_89727 * dwArg08)
{
	dwArg08->dw0004 = &dwArg08->dw0004;
	ui32 ecx_9 = g_dw813601C;
	__syscall(0x80);
	if (true)
		__syscall(0x03);
	if (ecx_9 == ~0x00)
		g_dw813601C = ecx_9;
	return (word16) ((ecx_9 << 0x03) + 0x03);
}

// 08090B50: void runtime.osyield()
// Called from:
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addNonGo
//      runtime.lock
//      runtime.(*mspan).ensureSwept
//      runtime.getfull
//      runtime.casgstatus
//      runtime.scang
//      runtime.lockextra
//      runtime.exitsyscall
//      runtime.dieFromSignal
//      runtime.exitsyscallfast.func1
void runtime.osyield()
{
	__syscall(0x80);
}

// 08090B60: void runtime.sched_getaffinity()
// Called from:
//      runtime.getproccount
void runtime.sched_getaffinity()
{
	__syscall(0x80);
}

// 08090B80: Register word32 runtime.epollcreate()
// Called from:
//      runtime.netpollinit
word32 runtime.epollcreate()
{
	__syscall(0x80);
	return dwArg04;
}

// 08090B90: void runtime.epollcreate1()
// Called from:
//      runtime.netpollinit
void runtime.epollcreate1()
{
	__syscall(0x80);
}

// 08090BA0: Register word32 runtime.epollctl(Register out ptr32 esiOut)
// Called from:
//      runtime.netpollopen
//      runtime.netpollclose
word32 runtime.epollctl(ptr32 & esiOut)
{
	__syscall(0x80);
	esiOut = dwArg10;
	return dwArg04;
}

// 08090BC0: Register word32 runtime.epollwait()
// Called from:
//      runtime.netpoll
word32 runtime.epollwait()
{
	__syscall(0x80);
	return dwArg10;
}

// 08090BE0: void runtime.closeonexec()
// Called from:
//      runtime.netpollinit
void runtime.closeonexec()
{
	__syscall(0x80);
}

// 08090C00: void runtime.sbrk0()
// Called from:
//      runtime.mallocinit
void runtime.sbrk0()
{
	__syscall(0x80);
}

// 08090C10: Register word32 runtime._mul64by32(Stack (ptr32 Eq_82624) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack uint32 dwArg10)
// Called from:
//      runtime.dodiv
word32 runtime._mul64by32(struct Eq_82624 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, uint32 dwArg10)
{
	uint64 edx_eax_7 = dwArg10 * dwArg08;
	dwArg04->dw0000 = (word32) edx_eax_7;
	word32 ebx_15 = SLICE(edx_eax_7, word32, 32) + (word32) (dwArg10 * dwArg0C);
	dwArg04->dw0004 = ebx_15;
	return ebx_15;
}

// 08090C40: Register uint32 runtime._div64by32(Stack Eq_82663 dwArg04, Stack Eq_4 dwArg0C, Stack (ptr32 uint32) dwArg10)
// Called from:
//      runtime.dodiv
uint32 runtime._div64by32(Eq_82663 dwArg04, Eq_4 dwArg0C, uint32 * dwArg10)
{
	uint32 edx_10 = (uint32) (qwArg04 % dwArg0C);
	*dwArg10 = edx_10;
	return edx_10;
}

// 08090C60: void type..hash.runtime._func(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime._func(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0C);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 16, dwLoc04, 0x14);
}

// 08090CD0: void type..eq.runtime._func(Register (ptr32 Eq_92314) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C)
void type..eq.runtime._func(struct Eq_92314 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, word32 dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 edi_23;
	word32 esi_24;
	runtime.memequal(dwArg04, dwArg08, 0x0C, out esi_24, out edi_23);
	if ((byte) (word32) bArg00 != 0x00)
	{
		word32 edi_47;
		word32 esi_48;
		runtime.memequal((word32) dwArg08 + 16, dwArg0C + 0x10, 0x14, out esi_48, out edi_47);
	}
}

// 08090D50: void type..hash.runtime.uncommontype(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.uncommontype(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x06);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 8, dwLoc04, 0x04);
}

// 08090DC0: void type..eq.runtime.uncommontype(Register (ptr32 Eq_92378) gs, Stack (ptr32 Eq_92379) dwArg04, Stack (ptr32 Eq_92380) dwArg08)
void type..eq.runtime.uncommontype(struct Eq_92378 * gs, struct Eq_92379 * dwArg04, struct Eq_92380 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
		(word16) (word32) dwArg04->w0004 != (word16) ((word32) dwArg08->w0004);
}

// 08090E10: void type..hash.runtime.modulehash(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack (ptr32 Eq_639) dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.modulehash(struct Eq_2 * gs, word64 mm0, struct Eq_639 * dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.strhash(gs, mm0, dwArg04, dwArg08);
	runtime.strhash(gs, mm0, (char *) &dwArg04->t0004 + 4, dwLoc08);
	runtime.memhash(gs, mm0, (char *) &dwArg04->t0004 + 0x0C, dwLoc08, 0x04);
}

// 08090E90: void type..eq.runtime.modulehash(Register (ptr32 Eq_92440) gs, Stack (ptr32 Eq_92441) dwArg04, Stack (ptr32 Eq_92442) dwArg08)
void type..eq.runtime.modulehash(struct Eq_92440 * gs, struct Eq_92441 * dwArg04, struct Eq_92442 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	byte cl_45;
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 esi_22 = dwArg08->t0000;
	if (dwArg08->t0004 != ecx_18)
		cl_45 = 0x00;
	else
	{
		word32 edi_29;
		word32 esi_30;
		runtime.eqstring(edx_19, ecx_18, esi_22, out esi_30, out edi_29);
		cl_45 = (byte) (word32) bLoc04;
	}
	uip32 ecx_165;
	if (cl_45 != 0x00)
	{
		Eq_4 ecx_56 = dwArg04->t000C;
		Eq_4 edx_57 = dwArg04->t0008;
		Eq_4 esi_60 = dwArg08->t0008;
		if (dwArg08->t000C != ecx_56)
			ecx_165 = 0x00;
		else
		{
			word32 edi_68;
			word32 esi_69;
			runtime.eqstring(edx_57, ecx_56, esi_60, out esi_69, out edi_68);
			ecx_165 = (word32) bLoc04;
		}
	}
	else
		ecx_165 = 0x00;
}

// 08090F50: void type..hash.runtime.Frame(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.Frame(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x08);
	runtime.strhash(gs, mm0, (word32) dwArg04 + 8, dwLoc04);
	runtime.strhash(gs, mm0, (word32) dwArg04 + 16, 0x08);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 24, 0x08, 0x08);
}

// 08090FF0: void type..eq.runtime.Frame(Register (ptr32 Eq_92548) gs, Stack (ptr32 Eq_92549) dwArg04, Stack (ptr32 Eq_92550) dwArg08)
void type..eq.runtime.Frame(struct Eq_92548 * gs, struct Eq_92549 * dwArg04, struct Eq_92550 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	byte cl_59;
	if (dwArg04->dw0000 == dwArg08->dw0000)
	{
		if (dwArg04->dw0004 == dwArg08->dw0004)
		{
			Eq_4 ecx_33 = dwArg04->t000C;
			Eq_4 ebx_34 = dwArg04->t0008;
			Eq_4 esi_36 = dwArg08->t0008;
			if (dwArg08->t000C != ecx_33)
				cl_59 = 0x00;
			else
			{
				word32 esi_198;
				word32 edi_199;
				runtime.eqstring(ebx_34, ecx_33, esi_36, out esi_198, out edi_199);
				cl_59 = (byte) (word32) bLoc04;
			}
		}
		else
			cl_59 = 0x00;
	}
	else
		cl_59 = 0x00;
	uip32 ecx_195;
	if (cl_59 != 0x00)
	{
		Eq_4 ebx_73 = dwArg08->t0010;
		Eq_4 ebp_75 = dwArg04->t0010;
		Eq_4 esi_76 = dwArg04->t0014;
		if (esi_76 != dwArg08->t0014)
			ecx_195 = 0x00;
		else
		{
			word32 esi_200;
			word32 edi_201;
			runtime.eqstring(ebp_75, esi_76, ebx_73, out esi_200, out edi_201);
			ecx_195 = (word32) bLoc04;
		}
	}
	else
		ecx_195 = 0x00;
	if ((byte) ecx_195 != 0x00)
		dwArg04->dw0018 != dwArg08->dw0018;
}

// 080910F0: void type..hash.runtime.MemStats(Register (ptr32 Eq_2) gs, Register word64 mm0, Register Eq_661 xmm1, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.MemStats(struct Eq_2 * gs, word64 mm0, Eq_661 xmm1, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x10C8);
	runtime.f64hash(gs, mm0, xmm1, (word32) dwArg04 + 4296, dwLoc04);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 4304, 0x10C8, 0x02);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 4308, dwLoc04, 0x04C4);
}

// 080911A0: void type..eq.runtime.MemStats(Register (ptr32 Eq_92680) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_92684) dwArg0C)
void type..eq.runtime.MemStats(struct Eq_92680 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_92684 * dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 edi_23;
	word32 esi_24;
	runtime.memequal(dwArg04, dwArg08, 0x10C8, out esi_24, out edi_23);
	if ((byte) (word32) bArg00 != 0x00)
	{
		uint128 xmm0_43 = (uint128) (uint64) *((word32) dwArg08 + 4296);
		Eq_92714 xmm1_45 = (uint128) (uint64) dwArg0C->r10C8;
		if ((real64) xmm0_43 == xmm1_45 && !PARITY_EVEN((real64) xmm0_43 - xmm1_45))
		{
			if ((byte) (word32) *((word32) dwArg08 + 4304) == (byte) ((word32) dwArg0C->b10D0) && (byte) ((word32) (*((word32) dwArg08 + 0x000010D1))) == (byte) ((word32) dwArg0C->b10D1))
			{
				word32 edi_75;
				word32 esi_76;
				runtime.memequal((word32) dwArg08 + 4308, &dwArg0C->b10D1 + 3, 0x04C4, out esi_76, out edi_75);
			}
		}
	}
}

// 08091270: void type..hash.runtime.TypeAssertionError(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack (ptr32 Eq_639) dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.TypeAssertionError(struct Eq_2 * gs, word64 mm0, struct Eq_639 * dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.strhash(gs, mm0, dwArg04, dwArg08);
	runtime.strhash(gs, mm0, (char *) &dwArg04->t0004 + 4, dwLoc04);
	runtime.strhash(gs, mm0, (char *) &dwArg04->t0004 + 0x0C, dwLoc04);
	runtime.strhash(gs, mm0, (char *) &dwArg04->t0004 + 20, dwLoc04);
}

// 08091300: void type..eq.runtime.TypeAssertionError(Register (ptr32 Eq_92792) gs, Stack (ptr32 Eq_92793) dwArg04, Stack (ptr32 Eq_92794) dwArg08)
void type..eq.runtime.TypeAssertionError(struct Eq_92792 * gs, struct Eq_92793 * dwArg04, struct Eq_92794 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	byte cl_45;
	Eq_4 edx_19 = dwArg08->t0000;
	Eq_4 ebp_21 = dwArg04->t0004;
	Eq_4 esi_22 = dwArg04->t0000;
	if (dwArg08->t0004 != ebp_21)
		cl_45 = 0x00;
	else
	{
		word32 edi_29;
		word32 esi_30;
		runtime.eqstring(esi_22, ebp_21, edx_19, out esi_30, out edi_29);
		cl_45 = (byte) (word32) bLoc04;
	}
	byte cl_84;
	if (cl_45 != 0x00)
	{
		Eq_4 edx_57 = dwArg08->t0008;
		Eq_4 ebp_59 = dwArg04->t000C;
		Eq_4 esi_60 = dwArg04->t0008;
		if (dwArg08->t000C != ebp_59)
			cl_84 = 0x00;
		else
		{
			word32 edi_68;
			word32 esi_69;
			runtime.eqstring(esi_60, ebp_59, edx_57, out esi_69, out edi_68);
			cl_84 = (byte) (word32) bLoc04;
		}
	}
	else
		cl_84 = 0x00;
	uip32 ecx_118;
	if (cl_84 != 0x00)
	{
		Eq_4 edx_97 = dwArg08->t0010;
		Eq_4 ebp_99 = dwArg04->t0014;
		Eq_4 esi_100 = dwArg04->t0010;
		if (ebp_99 != dwArg08->t0014)
			ecx_118 = 0x00;
		else
		{
			word32 edi_108;
			word32 esi_109;
			runtime.eqstring(esi_100, ebp_99, edx_97, out esi_109, out edi_108);
			ecx_118 = (word32) bLoc04;
		}
	}
	else
		ecx_118 = 0x00;
	if ((byte) ecx_118 != 0x00)
	{
		Eq_4 ecx_136 = dwArg08->t0018;
		Eq_4 edx_138 = dwArg04->t001C;
		Eq_4 ebx_139 = dwArg04->t0018;
		if (dwArg08->t001C == edx_138)
		{
			word32 edi_148;
			word32 esi_149;
			runtime.eqstring(ebx_139, edx_138, ecx_136, out esi_149, out edi_148);
		}
	}
}

// 08091430: void type..hash.runtime._panic(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime._panic(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04);
	runtime.nilinterhash(gs, (word32) dwArg04 + 4, dwLoc04);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 0x0C, 0x04, 0x06);
}

// 080914B0: void type..eq.runtime._panic(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_92947) dwArg04, Stack (ptr32 Eq_92948) dwArg08)
void type..eq.runtime._panic(struct Eq_2 * gs, struct Eq_92947 * dwArg04, struct Eq_92948 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uip32 ecx_138;
	if (dwArg04->dw0000 == dwArg08->dw0000)
	{
		word32 ecx_26 = dwArg08->dw0008;
		word32 ebp_28 = dwArg04->dw0008;
		Eq_4 esi_29 = dwArg04->t0004;
		if (esi_29 != dwArg08->t0004)
			ecx_138 = 0x00;
		else
		{
			runtime.efaceeq(gs, esi_29, ebp_28, ecx_26);
			ecx_138 = (word32) bLoc04;
		}
	}
	else
		ecx_138 = 0x00;
	if ((byte) ecx_138 != 0x00)
	{
		word32 edi_64;
		word32 esi_65;
		runtime.memequal(&dwArg04->dw0008 + 1, &dwArg08->dw0008 + 1, 0x06, out esi_65, out edi_64);
	}
}

// 08091550: void type..hash.runtime._defer(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime._defer(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 8, dwLoc04, 0x14);
}

// 080915C0: void type..eq.runtime._defer(Register (ptr32 Eq_93030) gs, Stack (ptr32 Eq_93031) dwArg04, Stack (ptr32 Eq_93032) dwArg08)
void type..eq.runtime._defer(struct Eq_93030 * gs, struct Eq_93031 * dwArg04, struct Eq_93032 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000 && (byte) ((word32) dwArg04->b0004) == (byte) ((word32) dwArg08->b0004))
	{
		word32 edi_38;
		word32 esi_39;
		runtime.memequal(&dwArg04->b0004 + 4, &dwArg08->b0004 + 4, 0x14, out esi_39, out edi_38);
	}
}

// 08091630: void type..hash.runtime.special(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.special(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x07);
}

// 08091680: void type..eq.runtime.special(Register (ptr32 Eq_93093) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.runtime.special(struct Eq_93093 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x07, out esi_56, out edi_57);
}

// 080916D0: void type..hash.runtime.markBits(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.markBits(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 8, dwLoc04, 0x04);
}

// 08091740: void type..eq.runtime.markBits(Register (ptr32 Eq_93140) gs, Stack (ptr32 Eq_93141) dwArg04, Stack (ptr32 Eq_93142) dwArg08)
void type..eq.runtime.markBits(struct Eq_93140 * gs, struct Eq_93141 * dwArg04, struct Eq_93142 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
		(byte) (word32) dwArg04->b0004 != (byte) ((word32) dwArg08->b0004);
}

// 08091790: void type..hash.runtime.hchan(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.hchan(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0E);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 16, dwLoc04, 0x24);
}

// 08091800: void type..eq.runtime.hchan(Register (ptr32 Eq_93198) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C)
void type..eq.runtime.hchan(struct Eq_93198 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, word32 dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 edi_23;
	word32 esi_24;
	runtime.memequal(dwArg04, dwArg08, 0x0E, out esi_24, out edi_23);
	if ((byte) (word32) bArg00 != 0x00)
	{
		word32 edi_47;
		word32 esi_48;
		runtime.memequal((word32) dwArg08 + 16, dwArg0C + 0x10, 0x24, out esi_48, out edi_47);
	}
}

// 08091880: void type..hash.runtime.cpuProfile(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.cpuProfile(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 8, dwLoc04, 0x0FB0);
}

// 080918F0: void type..eq.runtime.cpuProfile(Register (ptr32 Eq_93262) gs, Stack (ptr32 Eq_93263) dwArg04, Stack (ptr32 Eq_93264) dwArg08)
void type..eq.runtime.cpuProfile(struct Eq_93262 * gs, struct Eq_93263 * dwArg04, struct Eq_93264 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000 && (byte) ((word32) dwArg04->b0004) == (byte) ((word32) dwArg08->b0004))
	{
		word32 edi_38;
		word32 esi_39;
		runtime.memequal(&dwArg04->b0004 + 4, &dwArg08->b0004 + 4, 0x0FB0, out esi_39, out edi_38);
	}
}

// 08091960: void type..hash.runtime.dbgVar(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack (ptr32 Eq_639) dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.[14]runtime.dbgVar
void type..hash.runtime.dbgVar(struct Eq_2 * gs, word64 mm0, struct Eq_639 * dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.strhash(gs, mm0, dwArg04, dwArg08);
	runtime.memhash(gs, mm0, (char *) &dwArg04->t0004 + 4, dwLoc08, 0x04);
}

// 080919C0: void type..eq.runtime.dbgVar(Register (ptr32 Eq_93330) gs, Stack (ptr32 Eq_93331) dwArg04, Stack (ptr32 Eq_93332) dwArg08)
void type..eq.runtime.dbgVar(struct Eq_93330 * gs, struct Eq_93331 * dwArg04, struct Eq_93332 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uip32 ecx_112;
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 esi_22 = dwArg08->t0000;
	if (ecx_18 != dwArg08->t0004)
		ecx_112 = 0x00;
	else
	{
		word32 edi_29;
		word32 esi_30;
		runtime.eqstring(edx_19, ecx_18, esi_22, out esi_30, out edi_29);
		ecx_112 = (word32) bLoc04;
	}
}

// 08091A40: void runtime.(*errorString).Error(Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
void runtime.(*errorString).Error(struct Eq_2 * gs, word32 dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x1C;
	if (dwArg04 == 0x00)
		runtime.panicwrap(gs);
	else
		runtime.concatstring2(gs, 0x00);
}

// 08091AC0: void type..hash.runtime.finblock(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.finblock(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0C);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 16, dwLoc04, 0x0FF0);
}

// 08091B30: void type..eq.runtime.finblock(Register (ptr32 Eq_93439) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C)
void type..eq.runtime.finblock(struct Eq_93439 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, word32 dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 edi_23;
	word32 esi_24;
	runtime.memequal(dwArg04, dwArg08, 0x0C, out esi_24, out edi_23);
	if ((byte) (word32) bArg00 != 0x00)
	{
		word32 edi_47;
		word32 esi_48;
		runtime.memequal((word32) dwArg08 + 16, dwArg0C + 0x10, 0x0FF0, out esi_48, out edi_47);
	}
}

// 08091BB0: void type..hash.runtime.gcControllerState(Register (ptr32 Eq_2) gs, Register word64 mm0, Register Eq_661 xmm1, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.gcControllerState(struct Eq_2 * gs, word64 mm0, Eq_661 xmm1, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x40);
	runtime.f64hash(gs, mm0, runtime.f64hash(gs, mm0, runtime.f64hash(gs, mm0, xmm1, (word32) dwArg04 + 64, dwLoc04), (word32) dwArg04 + 72, 0x40), (word32) dwArg04 + 80, 0x40);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 0x0098, 0x40, 0x08);
}

// 08091C70: void type..eq.runtime.gcControllerState(Register (ptr32 Eq_93519) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_93523) dwArg0C)
void type..eq.runtime.gcControllerState(struct Eq_93519 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_93523 * dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 edi_178;
	word32 esi_177;
	runtime.memequal(dwArg04, dwArg08, 0x40, out esi_177, out edi_178);
	if ((byte) (word32) bArg00 != 0x00)
	{
		Eq_93547 xmm0_43 = (uint128) (uint64) *((word32) dwArg08 + 64);
		uint128 xmm1_45 = (uint128) (uint64) dwArg0C->r0040;
		if ((real64) xmm1_45 == xmm0_43 && !PARITY_EVEN((real64) xmm1_45 - xmm0_43))
		{
			uint128 xmm0_54 = (uint128) (uint64) *((word32) dwArg08 + 72);
			Eq_93573 xmm1_55 = (uint128) (uint64) dwArg0C->r0048;
			if ((real64) xmm0_54 == xmm1_55 && !PARITY_EVEN((real64) xmm0_54 - xmm1_55))
			{
				uint128 xmm0_64 = (uint128) (uint64) *((word32) dwArg08 + 80);
				Eq_93593 xmm1_65 = (uint128) (uint64) dwArg0C->r0050;
				if ((real64) xmm0_64 != xmm1_65 || PARITY_EVEN((real64) xmm0_64 - xmm1_65))
					;
			}
		}
	}
}

// 08091D40: void type..hash.runtime.mcentral(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
void type..hash.runtime.mcentral(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 8, dwLoc04, 0x18);
}

// 08091DB0: void type..eq.runtime.mcentral(Register (ptr32 Eq_93632) gs, Stack (ptr32 Eq_93633) dwArg04, Stack (ptr32 Eq_93634) dwArg08)
// Called from:
//      type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
void type..eq.runtime.mcentral(struct Eq_93632 * gs, struct Eq_93633 * dwArg04, struct Eq_93634 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000 && (byte) ((word32) dwArg04->b0004) == (byte) ((word32) dwArg08->b0004))
	{
		word32 edi_38;
		word32 esi_39;
		runtime.memequal(&dwArg04->b0004 + 4, &dwArg08->b0004 + 4, 0x18, out esi_39, out edi_38);
	}
}

// 08091E20: void type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
void type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	type..hash.runtime.mcentral(gs, mm0, dwArg04, dwArg08);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 32, dwLoc08, 0x20);
}

// 08091E80: void type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(Register (ptr32 Eq_93632) gs, Stack (ptr32 Eq_93633) dwArg04, Stack (ptr32 Eq_93634) dwArg08)
void type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(struct Eq_93632 * gs, struct Eq_93633 * dwArg04, struct Eq_93634 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	type..eq.runtime.mcentral(gs, dwArg04, dwArg08);
	if ((byte) (word32) bLoc08 != 0x00)
	{
		word32 edi_45;
		word32 esi_46;
		runtime.memequal(&dwArg04->b0004 + 28, &dwArg08->b0004 + 28, 0x20, out esi_46, out edi_45);
	}
}

// 08091EF0: void type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x86; ++eax_17)
	{
		type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(gs, mm0, (eax_17 << 0x06) + dwArg04, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08091F50: void type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(Register (ptr32 Eq_93632) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(struct Eq_93632 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17 = 0x00;
	while (eax_17 < 0x86)
	{
		ui32 eax_28 = eax_17 << 0x06;
		type..eq.runtime.mcentral(gs, eax_28 + dwArg04, eax_28 + dwArg08);
		byte bLoc08_144 = (byte) eax_17;
		if ((byte) (word32) bLoc10 == 0x00)
			return;
		word32 edi_156;
		word32 esi_155;
		runtime.memequal(eax_28 + 0x20 + dwArg04, eax_28 + 0x20 + dwArg08, 0x20, out esi_155, out edi_156);
		bLoc10 = 0x20;
		if ((byte) (word32) bLoc08_144 == 0x00)
			return;
		eax_17 = eax_28 + 0x01;
	}
}

// 08092000: void type..hash.runtime.mstats(Register (ptr32 Eq_2) gs, Register word64 mm0, Register Eq_661 xmm1, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.mstats(struct Eq_2 * gs, word64 mm0, Eq_661 xmm1, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x10C8);
	Eq_661 xmm1_46 = runtime.f64hash(gs, mm0, xmm1, (word32) dwArg04 + 4296, dwLoc04);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 4304, 0x10C8, 0x02);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 4308, dwLoc04, 0x054C);
	runtime.f64hash(gs, mm0, xmm1_46, (word32) dwArg04 + 5664, dwLoc04);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 5672, 0x054C, 0x20);
}

// 080920F0: void type..eq.runtime.mstats(Register (ptr32 Eq_93865) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
void type..eq.runtime.mstats(struct Eq_93865 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	byte bArg04_166 = (byte) dwArg04;
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uip32 edx_225;
	Eq_4 ecx_110;
	Eq_4 eax_105;
	word32 edi_23;
	word32 esi_24;
	runtime.memequal(dwArg04, dwArg08, 0x10C8, out esi_24, out edi_23);
	struct Eq_93895 * esp_119 = fp - 0x0C;
	if ((byte) (word32) bArg00 != 0x00)
	{
		eax_105 = dwArg08;
		uint128 xmm0_45 = (uint128) (uint64) *((word32) dwArg08 + 4296);
		ecx_110 = dwArg0C;
		Eq_93909 xmm1_47 = (uint128) (uint64) *((word32) dwArg0C + 4296);
		if ((real64) xmm0_45 == xmm1_47 && !PARITY_EVEN((real64) xmm0_45 - xmm1_47))
		{
			if ((byte) (word32) *((word32) dwArg0C + 4304) == (byte) ((word32) (*((word32) dwArg08 + 4304))))
			{
				if ((byte) (word32) *((word32) dwArg0C + 0x000010D1) != (byte) ((word32) (*((word32) dwArg08 + 0x000010D1))))
					edx_225 = 0x00;
				else
				{
					word32 edi_76;
					word32 esi_77;
					runtime.memequal((word32) dwArg08 + 4308, (word32) dwArg0C + 4308, 0x054C, out esi_77, out edi_76);
					esp_119 = fp - 0x08;
					edx_225 = (word32) bArg04_166;
					eax_105 = dwArg0C;
					ecx_110 = dwArg10;
				}
			}
			else
				edx_225 = 0x00;
		}
		else
			edx_225 = 0x00;
	}
	else
	{
		eax_105 = dwArg08;
		ecx_110 = dwArg0C;
		edx_225 = 0x00;
	}
	if ((byte) edx_225 != 0x00)
	{
		uint128 xmm0_109 = (uint128) (uint64) *((word32) eax_105 + 5664);
		Eq_93968 xmm1_112 = (uint128) (uint64) *((word32) ecx_110 + 5664);
		if ((real64) xmm0_109 == xmm1_112 && !PARITY_EVEN((real64) xmm0_109 - xmm1_112))
		{
			esp_119->t0004 = (word32) ecx_110 + 5672;
			esp_119->t0000 = (word32) eax_105 + 5672;
			esp_119->t0008.u0 = 0x20;
			word32 edi_126;
			word32 esi_127;
			runtime.memequal(esp_119->t0000, esp_119->t0004, esp_119->t0008, out esi_127, out edi_126);
		}
	}
}

// 08092230: void runtime.(*plainError).Error(Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
void runtime.(*plainError).Error(struct Eq_2 * gs, word32 dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_16 = *((word32) ecx_7 + 16);
	if (ebx_16 != 0x00 && *ebx_16 == (word32) fp + 4)
		*ebx_16 = fp;
	if (dwArg04 != 0x00)
		return;
	runtime.panicwrap(gs);
}

// 08092280: void type..hash.runtime.sigTabT(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.[65]runtime.sigTabT
void type..hash.runtime.sigTabT(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04);
	runtime.strhash(gs, mm0, (word32) dwArg04 + 4, dwLoc04);
}

// 080922E0: void type..eq.runtime.sigTabT(Register (ptr32 Eq_94073) gs, Stack (ptr32 Eq_94074) dwArg04, Stack (ptr32 Eq_94075) dwArg08)
void type..eq.runtime.sigTabT(struct Eq_94073 * gs, struct Eq_94074 * dwArg04, struct Eq_94075 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
	{
		Eq_4 edx_27 = dwArg08->t0004;
		Eq_4 ebx_28 = dwArg04->t0008;
		Eq_4 eax_29 = dwArg04->t0004;
		if (ebx_28 == dwArg08->t0008)
		{
			word32 edi_36;
			word32 esi_37;
			runtime.eqstring(eax_29, ebx_28, edx_27, out esi_37, out edi_36);
		}
	}
}

// 08092350: void type..hash.runtime.stackmap(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.stackmap(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x09);
}

// 080923A0: void type..eq.runtime.stackmap(Register (ptr32 Eq_94136) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.runtime.stackmap(struct Eq_94136 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x09, out esi_56, out edi_57);
}

// 080923F0: void type..hash.runtime.sweepdata(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.sweepdata(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0A);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 0x0C, dwLoc04, 0x08);
}

// 08092460: void type..eq.runtime.sweepdata(Register (ptr32 Eq_94183) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_94187) dwArg0C)
void type..eq.runtime.sweepdata(struct Eq_94183 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_94187 * dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_97;
	word32 edi_98;
	runtime.memequal(dwArg04, dwArg08, 0x0A, out esi_97, out edi_98);
	if ((byte) (word32) bArg00 != 0x00)
		*((word32) dwArg08 + 0x0C) != dwArg0C->t000C;
}

// 080924D0: void type..hash.runtime.traceStack(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.runtime.traceStack(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x10);
}

// 08092520: void type..eq.runtime.traceStack(Register (ptr32 Eq_1052) gs, Stack (ptr32 Eq_1053) dwArg04, Stack (ptr32 Eq_1054) dwArg08)
void type..eq.runtime.traceStack(struct Eq_1052 * gs, struct Eq_1053 * dwArg04, struct Eq_1054 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime.memequal128(gs, dwArg04, dwArg08);
}

// 08092560: void type..hash.[14]runtime.dbgVar(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[14]runtime.dbgVar(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x0E; ++eax_17)
	{
		type..hash.runtime.dbgVar(gs, mm0, dwArg04 + eax_17 * 0x0C, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 080925C0: void type..eq.[14]runtime.dbgVar(Register (ptr32 Eq_94285) gs, Stack (ptr32 Eq_94286) dwArg04, Stack (ptr32 Eq_94287) dwArg08)
void type..eq.[14]runtime.dbgVar(struct Eq_94285 * gs, struct Eq_94286 * dwArg04, struct Eq_94287 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x0E; ++eax_17)
	{
		ui32 ecx_28 = eax_17 * 0x03;
		Eq_4 ebx_30 = dwArg08[ecx_28 * 0x04 / 8];
		Eq_4 edi_33 = dwArg04->a0004[ecx_28];
		Eq_4 eax_34 = dwArg04[ecx_28 * 0x04 / 8];
		if (edi_33 != (dwArg08->a0004)[ecx_28])
			return;
		word32 esi_136;
		word32 edi_137;
		runtime.eqstring(eax_34, edi_33, ebx_30, out esi_136, out edi_137);
		if ((byte) (word32) bLoc0C == 0x00 || (dwArg04->a0008)[ecx_28] != (dwArg08->a0008)[ecx_28])
			return;
	}
}

// 08092660: void type..hash.[2]string(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[2]string(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x02; ++eax_17)
	{
		runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 080926C0: void type..eq.[2]string(Register (ptr32 Eq_94380) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[2]string(struct Eq_94380 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x02; ++eax_17)
	{
		struct Eq_94399 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_94403 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 esi_129;
		word32 edi_130;
		runtime.eqstring(esi_35, edi_34, edx_33, out esi_129, out edi_130);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 08092740: void type..hash.[33]float64(Register (ptr32 Eq_2) gs, Register word64 mm0, Register Eq_661 xmm1, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[33]float64(struct Eq_2 * gs, word64 mm0, Eq_661 xmm1, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 33; ++eax_17)
	{
		xmm1 = runtime.f64hash(gs, mm0, xmm1, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 080927A0: void type..eq.[33]float64(Register (ptr32 Eq_94466) gs, Stack (arr real64) dwArg04, Stack (arr real64) dwArg08)
void type..eq.[33]float64(struct Eq_94466 * gs, real64 dwArg04[], real64 dwArg08[])
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 edx_18;
	for (edx_18 = 0x00; edx_18 < 33; ++edx_18)
	{
		uint128 xmm0_28 = (uint128) (uint64) dwArg04[edx_18];
		Eq_94491 xmm1_30 = (uint128) (uint64) dwArg08[edx_18];
		if ((real64) xmm0_28 != xmm1_30 || PARITY_EVEN((real64) xmm0_28 - xmm1_30))
			return;
	}
}

// 080927F0: void type..hash.[3]string(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[3]string(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x03; ++eax_17)
	{
		runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092850: void type..eq.[3]string(Register (ptr32 Eq_94537) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[3]string(struct Eq_94537 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x03; ++eax_17)
	{
		struct Eq_94556 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_94560 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 esi_129;
		word32 edi_130;
		runtime.eqstring(esi_35, edi_34, edx_33, out esi_129, out edi_130);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 080928D0: void type..hash.[4]string(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[4]string(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x04; ++eax_17)
	{
		runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092930: void type..eq.[4]string(Register (ptr32 Eq_94622) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[4]string(struct Eq_94622 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x04; ++eax_17)
	{
		struct Eq_94641 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_94645 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 esi_129;
		word32 edi_130;
		runtime.eqstring(esi_35, edi_34, edx_33, out esi_129, out edi_130);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 080929B0: void type..hash.[5]string(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[5]string(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x05; ++eax_17)
	{
		runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092A10: void type..eq.[5]string(Register (ptr32 Eq_94707) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[5]string(struct Eq_94707 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x05; ++eax_17)
	{
		struct Eq_94726 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_94730 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 esi_129;
		word32 edi_130;
		runtime.eqstring(esi_35, edi_34, edx_33, out esi_129, out edi_130);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 08092A90: void type..hash.[65]runtime.sigTabT(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[65]runtime.sigTabT(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x41; ++eax_17)
	{
		type..hash.runtime.sigTabT(gs, mm0, dwArg04 + eax_17 * 0x0C, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092AF0: void type..eq.[65]runtime.sigTabT(Register (ptr32 Eq_94793) gs, Stack (ptr32 Eq_94794) dwArg04, Stack (ptr32 Eq_94795) dwArg08)
void type..eq.[65]runtime.sigTabT(struct Eq_94793 * gs, struct Eq_94794 * dwArg04, struct Eq_94795 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x41; ++eax_17)
	{
		ui32 ecx_27 = eax_17 * 0x03;
		if (dwArg04[ecx_27 * 0x04 / 8] != dwArg08[(ecx_27 * 0x04) / 8])
			return;
		Eq_4 ebx_35 = dwArg08->a0004[ecx_27];
		Eq_4 edi_37 = dwArg04->a0008[ecx_27];
		Eq_4 ecx_38 = dwArg04->a0004[ecx_27];
		if (edi_37 != (dwArg08->a0008)[ecx_27])
			return;
		word32 esi_132;
		word32 edi_133;
		runtime.eqstring(ecx_38, edi_37, ebx_35, out esi_132, out edi_133);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 08092B80: void type..hash.[6]string(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[6]string(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x06; ++eax_17)
	{
		runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092BE0: void type..eq.[6]string(Register (ptr32 Eq_94888) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[6]string(struct Eq_94888 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x06; ++eax_17)
	{
		struct Eq_94907 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_94911 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 esi_129;
		word32 edi_130;
		runtime.eqstring(esi_35, edi_34, edx_33, out esi_129, out edi_130);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 08092C60: void type..hash.[9]string(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[9]string(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x09; ++eax_17)
	{
		runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092CC0: void type..eq.[9]string(Register (ptr32 Eq_94973) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[9]string(struct Eq_94973 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x09; ++eax_17)
	{
		struct Eq_94992 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_94996 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 esi_129;
		word32 edi_130;
		runtime.eqstring(esi_35, edi_34, edx_33, out esi_129, out edi_130);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 08092D40: void type..hash.struct { runtime.cycle uint32; runtime.flushed bool }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { runtime.cycle uint32; runtime.flushed bool }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05);
}

// 08092D90: void type..eq.struct { runtime.cycle uint32; runtime.flushed bool }(Register (ptr32 Eq_95048) gs, Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
void type..eq.struct { runtime.cycle uint32; runtime.flushed bool }(struct Eq_95048 * gs, word32 * dwArg04, word32 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	*dwArg04 != *dwArg08;
}

// 08092DD0: void type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x06);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 8, dwLoc04, 0x08);
}

// 08092E40: void type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(Register (ptr32 Eq_95095) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(struct Eq_95095 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 edi_100;
	word32 esi_99;
	runtime.memequal(dwArg04, dwArg08, 0x06, out esi_99, out edi_100);
}

// 08092EB0: void type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 100);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 0x0068, dwLoc04, 0x29);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 0x0094, dwLoc04, 0x15);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 0x00AC, dwLoc04, 0x15);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 0x00C4, dwLoc04, 0x80);
}

// 08092F80: void type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(Register (ptr32 Eq_95162) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C)
void type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(struct Eq_95162 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, word32 dwArg0C)
{
	byte bArg04_175 = (byte) dwArg04;
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	byte al_61;
	word32 edi_23;
	word32 esi_24;
	runtime.memequal(dwArg04, dwArg08, 100, out esi_24, out edi_23);
	struct Eq_95189 * esp_116 = fp - 0x0C;
	if ((byte) (word32) bArg00 == 0x00)
		al_61 = 0x00;
	else
	{
		word32 edi_46;
		word32 esi_47;
		runtime.memequal((word32) dwArg08 + 0x0068, dwArg0C + 0x68, 0x29, out esi_47, out edi_46);
		esp_116 = fp - 0x08;
		al_61 = (byte) (word32) bArg04_175;
	}
	byte al_91;
	if (al_61 == 0x00)
		al_91 = 0x00;
	else
	{
		esp_116->t0004 = esp_116->dw0018 + 0x94;
		esp_116->dw0000 = (word32) (esp_116->dw0014 + 0x94);
		esp_116->t0008.u0 = 0x15;
		word32 edi_76;
		word32 esi_77;
		runtime.memequal(esp_116->dw0000, esp_116->t0004, esp_116->t0008, out esi_77, out edi_76);
		esp_116 = (struct Eq_95189 *) &esp_116->t0004;
		al_91 = (byte) (word32) esp_116->b000C;
	}
	byte al_121;
	if (al_91 == 0x00)
		al_121 = 0x00;
	else
	{
		esp_116->t0004 = esp_116->dw0018 + 0xAC;
		esp_116->dw0000 = esp_116->dw0014 + 0xAC;
		esp_116->t0008.u0 = 0x15;
		word32 edi_106;
		word32 esi_107;
		runtime.memequal(esp_116->dw0000, esp_116->t0004, esp_116->t0008, out esi_107, out edi_106);
		esp_116 = (struct Eq_95189 *) &esp_116->t0004;
		al_121 = (byte) (word32) esp_116->b000C;
	}
	if (al_121 != 0x00)
	{
		esp_116->t0004 = esp_116->dw0018 + 0xC4;
		esp_116->dw0000 = esp_116->dw0014 + 0xC4;
		esp_116->t0008.u0 = 0x80;
		word32 edi_137;
		word32 esi_138;
		runtime.memequal(esp_116->dw0000, esp_116->t0004, esp_116->t0008, out esi_138, out edi_137);
	}
}

// 080930B0: void type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x39);
}

// 08093100: void type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }(Register (ptr32 Eq_95360) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }(struct Eq_95360 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x39, out esi_56, out edi_57);
}

// 08093150: void type..hash.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x09);
}

// 080931A0: void type..eq.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }(Register (ptr32 Eq_95401) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }(struct Eq_95401 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x09, out esi_56, out edi_57);
}

// 080931F0: void type..hash.struct { F uintptr; runtime.preemptible bool }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { F uintptr; runtime.preemptible bool }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05);
}

// 08093240: void type..eq.struct { F uintptr; runtime.preemptible bool }(Register (ptr32 Eq_95442) gs, Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
void type..eq.struct { F uintptr; runtime.preemptible bool }(struct Eq_95442 * gs, word32 * dwArg04, word32 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	*dwArg04 != *dwArg08;
}

// 08093280: void type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x12);
}

// 080932D0: void type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }(Register (ptr32 Eq_95483) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }(struct Eq_95483 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x12, out esi_56, out edi_57);
}

// 08093320: void type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0E);
}

// 08093370: void type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }(Register (ptr32 Eq_95524) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }(struct Eq_95524 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x0E, out esi_56, out edi_57);
}

// 080933C0: void errors.New(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08)
// Called from:
//      strconv.init
//      io.init
//      time.init
//      internal/poll.init
//      os.init
//      fmt.init
void errors.New(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080D1920);
	*((word32) dwLoc08 + 4) = dwArg08;
	if (g_t81576F0 == 0x00)
		*dwLoc08 = dwArg04;
	else
		runtime.writebarrierptr(dwLoc08, dwArg04);
}

// 08093440: void errors.(*errorString).Error(Register (ptr32 Eq_95577) gs)
void errors.(*errorString).Error(struct Eq_95577 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08093470: void unicode/utf8.DecodeRuneInString(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_95591) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.appendQuotedWith
//      strconv.CanBackquote
void unicode/utf8.DecodeRuneInString(struct Eq_2 * gs, struct Eq_95591 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 < 0x01)
		return;
	ui32 ebx_26 = (word32) ((word32) (byte) (word32) dwArg04->b0000 + 0x081399E0);
	bcu8 bl_44 = (byte) ebx_26;
	if ((byte) ebx_26 >= 0xF0)
		return;
	uint32 ebx_46 = (word32) (bl_44 >> 0x04);
	if (ebx_46 >= 0x05)
		runtime.panicindex(gs);
	else
	{
		struct Eq_95631 * ebx_52 = ebx_46 * 0x02 + 0x08136108;
		word32 edi_53 = (word32) ebx_52->b0001;
		cu8 bl_67 = (byte) (word32) ebx_52->b0000;
		if (dwArg08 < (ebx_26 & 0x07))
			return;
		if (dwArg08 <= 0x01)
			runtime.panicindex(gs);
		else
		{
			word32 esi_62 = (word32) dwArg04->b0001;
			if ((byte) esi_62 < bl_67 || (byte) edi_53 < (byte) esi_62)
				return;
			if ((byte) (ebx_26 & 0x07) == 0x02)
				return;
			if (dwArg08 <= 0x02)
				runtime.panicindex(gs);
			else
			{
				if ((byte) ((word32) dwArg04->b0002 - 0x80) > 0x3F)
					return;
				if ((byte) (ebx_26 & 0x07) == 0x03)
					return;
				if (dwArg08 <= 0x03)
					runtime.panicindex(gs);
				else if ((byte) ((word32) dwArg04->b0003 - 0x80) <= 0x3F)
					;
			}
		}
	}
}

// 08093640: void unicode/utf8.EncodeRune(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_95700) dwArg04, Stack ptr32 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      strconv.appendEscapedRune
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_c
//      fmt.(*buffer).WriteRune
void unicode/utf8.EncodeRune(struct Eq_2 * gs, struct Eq_95700 * dwArg04, ptr32 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = dwArg10;
	byte al_108 = (byte) dwArg10;
	if (dwArg10 > 0x7F)
	{
		if (dwArg10 > 0x07FF)
		{
			if (dwArg10 > 1114111 || dwArg10 <= ~0xDFFE)
				eax_16.u0 = 0xFFFD;
			else if (dwArg10 > 0xFFFF)
			{
				if (dwArg08 <= 0x03)
					runtime.panicindex(gs);
				else
				{
					dwArg04->b0000 = (byte) (dwArg10 >> 0x12 | ~0x0F);
					dwArg04->b0001 = (byte) (dwArg10 >> 0x0C & 0x3F | ~0x7F);
					dwArg04->b0002 = (byte) (dwArg10 >> 0x06 & 0x3F | ~0x7F);
					dwArg04->b0003 = (byte) (dwArg10 & 0x3F | ~0x7F);
					return;
				}
			}
			if (dwArg08 <= 0x02)
				runtime.panicindex(gs);
			else
			{
				dwArg04->b0000 = (byte) (eax_16 >> 0x0C | ~0x1F);
				dwArg04->b0001 = (byte) (eax_16 >> 0x06 & 0x3F | ~0x7F);
				dwArg04->b0002 = (byte) (eax_16 & 0x3F | ~0x7F);
			}
		}
		else if (dwArg08 <= 0x01)
			runtime.panicindex(gs);
		else
		{
			dwArg04->b0000 = (byte) (dwArg10 >> 0x06 | ~0x3F);
			dwArg04->b0001 = (byte) (dwArg10 & 0x3F | ~0x7F);
		}
	}
	else if (dwArg08 <= 0x00)
		runtime.panicindex(gs);
	else
		dwArg04->b0000 = al_108;
}

// 08093780: void unicode/utf8.RuneCount(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*fmt).pad
void unicode/utf8.RuneCount(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_157 = 0x00;
	while (edx_157 < dwArg08)
	{
		if (edx_157 >= dwArg08)
			runtime.panicindex(gs);
		word32 ebp_36 = (word32) Mem35[dwArg04 + edx_157:byte];
		if ((byte) ebp_36 < 0x80)
			++edx_157;
		else
		{
			ui32 ebp_55 = (word32) ((word32) (byte) ebp_36 + 0x081399E0);
			if ((byte) ebp_55 == ~0x0E)
				++edx_157;
			else
			{
				struct Eq_95866 * ebp_141 = ebp_55 & 0x07;
				if ((word32) edx_157 + (ebp_55 & 0x07) > dwArg08)
					++edx_157;
				else
				{
					uint32 esi_84 = (word32) ((byte) ebp_55 >> 0x04);
					if (esi_84 >= 0x05)
						runtime.panicindex(gs);
					struct Eq_95885 * esi_92 = esi_84 * 0x02 + 0x08136108;
					word32 edi_93 = (word32) esi_92->b0001;
					word32 esi_94 = (word32) esi_92->b0000;
					if (edx_157 + 0x01 >=u dwArg08)
						runtime.panicindex(gs);
					struct Eq_95866 * ebx_148;
					byte bl_102 = SLICE((word32) Mem90[edx_157 + 0x01 + dwArg04:byte], byte, 0);
					if (bl_102 < (byte) esi_94 || (byte) edi_93 < bl_102)
						ebx_148 = (struct Eq_95866 *) 0x01;
					else
					{
						if ((ebp_55 & 0x07) != 0x02)
						{
							if (edx_157 + 0x02 >=u dwArg08)
								runtime.panicindex(gs);
							struct Eq_95866 * ebx_143;
							if (SLICE((word32) Mem90[edx_157 + 0x02 + dwArg04:byte] + ~0x7F, byte, 0) >u 0x3F)
								ebx_143 = (struct Eq_95866 *) 0x01;
							else
							{
								if ((ebp_55 & 0x07) != 0x03)
								{
									if (edx_157 + 0x03 >=u dwArg08)
										runtime.panicindex(gs);
									struct Eq_95866 * ebx_138;
									if (SLICE((word32) Mem90[edx_157 + 0x03 + dwArg04:byte] + ~0x7F, byte, 0) >u 0x3F)
										ebx_138 = (struct Eq_95866 *) 0x01;
									else
										ebx_138 = ebp_55 & 0x07;
									ebp_141 = ebx_138;
								}
								ebx_143 = ebp_141;
							}
							ebp_141 = ebx_143;
						}
						ebx_148 = ebp_141;
					}
					edx_157 += ebx_148;
				}
			}
		}
	}
}

// 080938D0: void unicode/utf8.RuneCountInString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*fmt).padString
void unicode/utf8.RuneCountInString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_157 = 0x00;
	while (edx_157 < dwArg08)
	{
		if (edx_157 >= dwArg08)
			runtime.panicindex(gs);
		word32 ebp_36 = (word32) Mem35[dwArg04 + edx_157:byte];
		if ((byte) ebp_36 < 0x80)
			++edx_157;
		else
		{
			ui32 ebp_55 = (word32) ((word32) (byte) ebp_36 + 0x081399E0);
			if ((byte) ebp_55 == ~0x0E)
				++edx_157;
			else
			{
				struct Eq_96000 * ebp_141 = ebp_55 & 0x07;
				if ((word32) edx_157 + (ebp_55 & 0x07) > dwArg08)
					++edx_157;
				else
				{
					uint32 esi_84 = (word32) ((byte) ebp_55 >> 0x04);
					if (esi_84 >= 0x05)
						runtime.panicindex(gs);
					struct Eq_96019 * esi_92 = esi_84 * 0x02 + 0x08136108;
					word32 edi_93 = (word32) esi_92->b0000;
					word32 esi_94 = (word32) esi_92->b0001;
					if (edx_157 + 0x01 >=u dwArg08)
						runtime.panicindex(gs);
					struct Eq_96000 * ebx_148;
					byte bl_102 = SLICE((word32) Mem90[edx_157 + 0x01 + dwArg04:byte], byte, 0);
					if (bl_102 < (byte) edi_93 || (byte) esi_94 < bl_102)
						ebx_148 = (struct Eq_96000 *) 0x01;
					else
					{
						if ((ebp_55 & 0x07) != 0x02)
						{
							if (edx_157 + 0x02 >=u dwArg08)
								runtime.panicindex(gs);
							struct Eq_96000 * ebx_143;
							if (SLICE((word32) Mem90[edx_157 + 0x02 + dwArg04:byte] + ~0x7F, byte, 0) >u 0x3F)
								ebx_143 = (struct Eq_96000 *) 0x01;
							else
							{
								if ((ebp_55 & 0x07) != 0x03)
								{
									if (edx_157 + 0x03 >=u dwArg08)
										runtime.panicindex(gs);
									struct Eq_96000 * ebx_138;
									if (SLICE((word32) Mem90[edx_157 + 0x03 + dwArg04:byte] + ~0x7F, byte, 0) >u 0x3F)
										ebx_138 = (struct Eq_96000 *) 0x01;
									else
										ebx_138 = ebp_55 & 0x07;
									ebp_141 = ebx_138;
								}
								ebx_143 = ebp_141;
							}
							ebp_141 = ebx_143;
						}
						ebx_148 = ebp_141;
					}
					edx_157 += ebx_148;
				}
			}
		}
	}
}

// 08093A20: void strconv.(*decimal).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void strconv.(*decimal).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_23;
	Eq_4 ecx_18 = *((word32) dwArg04 + 800);
	Eq_4 ebx_20 = *((word32) dwArg04 + 804);
	if (ebx_20 > 0x00)
		ecx_23 = (word32) ebx_20 + ((word32) ecx_18 + 0x0A);
	else
		ecx_23 = (word32) ecx_18 + 0x0A;
	if (ebx_20 < 0x00)
		ecx_23 -= ebx_20;
	word32 edi_461;
	runtime.makeslice(gs, 0x080CF320, ecx_23, ecx_23, out edi_461);
	Eq_4 ebp_55 = *((word32) dwArg04 + 800);
	if (ebp_55 == 0x00)
		return;
	Eq_4 eax_134;
	Eq_4 esi_142 = *((word32) dwArg04 + 804);
	if (esi_142 <= 0x00)
	{
		if (dwLoc1C <= 0x00)
			runtime.panicindex(gs);
		*dwLoc20 = 0x30;
		if (dwLoc1C <= 0x01)
			runtime.panicindex(gs);
		*((word32) dwLoc20 + 1) = 0x2E;
		Eq_96162 ebx_249 = -*((word32) dwArg04 + 804);
		if (ebx_249 < 0x00 || (word32) ebx_249 + 2 > dwLoc18)
			runtime.panicslice(gs);
		strconv.digitZero(gs, (word32) dwLoc20 + (0x02 - dwLoc18 >> 0x1F & 0x02), ebx_249);
		if (dwLoc20 + 0x02 <=u dwLoc1C)
		{
			word32 edx_281 = dwLoc1C - (dwLoc20 + 0x02);
			word32 ecx_288 = (dwLoc20 + 0x02 & (dwLoc20 + 0x02) - dwLoc18 >> 0x1F) + dwLoc20;
			Eq_4 edi_290 = *((word32) dwArg04 + 800);
			if (edi_290 <= 800)
			{
				if (edx_281 <= edi_290)
					edi_290 = edx_281;
				word32 edi_464;
				word32 esi_463;
				word32 ebp_462;
				runtime.memmove(ecx_288, dwArg04, edi_290, out ebp_462, out esi_463, out edi_464);
				eax_134 = (word32) dwLoc20 + ((word32) edi_290 + 2);
				goto l08093B67;
			}
		}
		runtime.panicslice(gs);
	}
	if (esi_142 >= ebp_55)
	{
		if (ebp_55 > 800)
			runtime.panicslice(gs);
		if (dwLoc1C <= ebp_55)
			ebp_55 = dwLoc1C;
		word32 ebp_471;
		word32 edi_473;
		word32 esi_472;
		runtime.memmove(dwLoc20, dwArg04, ebp_55, out ebp_471, out esi_472, out edi_473);
		word32 ecx_105 = Mem88[dwArg04 + 0x0324:word32] + ebp_55 - Mem88[dwArg04 + 800:word32];
		if (ebp_55 > ecx_105 || ecx_105 > dwLoc18)
			runtime.panicslice(gs);
		strconv.digitZero(gs, (ebp_55 - dwLoc18 >> 0x1F & ebp_55) + dwLoc20, ecx_105 - ebp_55);
		eax_134 = dwLoc20 + ebp_55;
l08093B67:
		if (eax_134 > dwLoc18)
			runtime.panicslice(gs);
		else
			runtime.slicebytetostring(gs, 0x00, dwLoc20, eax_134);
	}
	else
	{
		if (esi_142 > 800)
			runtime.panicslice(gs);
		if (dwLoc1C <= esi_142)
			esi_142 = dwLoc1C;
		word32 ebp_465;
		word32 edi_467;
		word32 esi_466;
		runtime.memmove(dwLoc20, dwArg04, esi_142, out ebp_465, out esi_466, out edi_467);
		if (esi_142 >= dwLoc1C)
			runtime.panicindex(gs);
		Mem168[dwLoc20 + esi_142:byte] = 0x2E;
		if ((word32) esi_142 + 1 <= dwLoc1C)
		{
			Eq_4 ecx_172 = dwLoc1C - ((word32) esi_142 + 1);
			Eq_4 ebx_184 = (word32) dwLoc20 + ((word32) esi_142 + 1 & ((word32) esi_142 + 1) - dwLoc18 >> 0x1F);
			Eq_4 edi_186 = *((word32) dwArg04 + 804);
			Eq_4 edx_187 = *((word32) dwArg04 + 800);
			if (edi_186 <= edx_187 && edx_187 <= 800)
			{
				Eq_4 edx_193 = edx_187 - edi_186;
				Eq_4 ebp_211 = (word32) dwArg04 + (edi_186 & edi_186 - 800 >> 0x1F);
				if (ecx_172 <= edx_193)
					edx_193 = ecx_172;
				word32 edi_470;
				word32 esi_469;
				word32 ebp_468;
				runtime.memmove(ebx_184, ebp_211, edx_193, out ebp_468, out esi_469, out edi_470);
				eax_134 = (word32) esi_142 + ((word32) edx_193 + 1);
				goto l08093B67;
			}
		}
		runtime.panicslice(gs);
	}
}

// 08093D80: void strconv.digitZero(Register (ptr32 Eq_2) gs, Stack int32 dwArg04, Stack Eq_96162 dwArg08)
// Called from:
//      strconv.(*decimal).String
void strconv.digitZero(struct Eq_2 * gs, int32 dwArg04, Eq_96162 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_96162 edx_18 = 0x00;
	while (edx_18 < dwArg08)
	{
		if (edx_18 >= dwArg08)
			runtime.panicindex(gs);
		*((word32) edx_18 + dwArg04) = 0x30;
		edx_18 = (word32) edx_18 + 1;
	}
}

// 08093DC0: void strconv.trim(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      strconv.(*decimal).Assign
//      strconv.rightShift
//      strconv.leftShift
//      strconv.(*decimal).RoundDown
void strconv.trim(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	while (true)
	{
		Eq_4 ecx_19 = *((word32) dwArg04 + 800);
		bool Z_33 = SLICE(cond(ecx_19), bool, 2);
		if (ecx_19 <= 0x00)
			break;
		if (ecx_19 >= 0x0321)
			runtime.panicindex(gs);
		if (SLICE((word32) Mem18[ecx_19 - 0x01 + dwArg04:byte], byte, 0) != 0x30)
		{
			Z_33 = SLICE(cond(ecx_19), bool, 2);
			break;
		}
		*((word32) dwArg04 + 800) = ecx_19 - 0x01;
	}
	if (!Z_33)
		((word32) dwArg04 + 804)->u0 = 0x00;
}

// 08093E20: void strconv.(*decimal).Assign(Register Eq_96401 ebx, Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.bigFtoa
//      strconv.roundShortest
void strconv.(*decimal).Assign(Eq_96401 ebx, Eq_4 ebp, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8A(0x00, fp - 0x18);
	Eq_4 eax_136 = dwArg08;
	Eq_4 ecx_129 = dwArg04;
	Eq_96426 edx_142 = 0x00;
	while (true)
	{
		ui24 ebx_24_8_45 = SLICE(ebp, word24, 8);
		Eq_4 ebp_63 = SEQ(ebx_24_8_45, eax_136 > 0x00) | SEQ(ebx_24_8, eax_136 == 0x00) & SEQ(ebx_24_8_45, ecx_129 > 0x00);
		ebp = ebp_63;
		if ((byte) ebp_63 == 0x00)
			break;
		runtime.uint64div(gs, ecx_129, eax_136, 0x0A, 0x00);
		ecx_129 = dwLoc28;
		byte dl_140 = (byte) (ecx_129 - (word32) (dwLoc28 * 0x0A) + 0x30);
		eax_136 = dwLoc24;
		ebx_24_8 = SLICE(edx_142, word24, 8);
		if (edx_142 >= 0x18)
			runtime.panicindex(gs);
		*((word32) edx_142 + (fp - 0x1C)) = dl_140;
		edx_142 = (word32) edx_142 + 1;
	}
	((word32) dwArg00 + 800)->u0 = 0x00;
	Eq_96450 ecx_111;
	for (ecx_111 = edx_142 - 0x01; ecx_111 >= 0x00; --ecx_111)
	{
		if (ecx_111 >= 0x18)
		{
l08093F1B:
			runtime.panicindex(gs);
		}
		Eq_4 edx_102 = *((word32) dwArg00 + 800);
		byte bl_106 = SLICE((word32) Mem85[fp - 0x1C + ecx_111:byte], byte, 0);
		if (edx_102 >= 800)
			goto l08093F1B;
		Mem107[dwArg00 + edx_102:byte] = bl_106;
		*((word32) dwArg00 + 800) = (word32) *((word32) dwArg00 + 800) + 1;
	}
	*((word32) dwArg00 + 804) = *((word32) dwArg00 + 800);
	strconv.trim(gs, dwArg00);
}

// 08093F40: Register Eq_4 strconv.rightShift(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_96521 dwArg08, Register out Eq_4 esiOut)
// Called from:
//      strconv.(*decimal).Shift
Eq_4 strconv.rightShift(struct Eq_2 * gs, Eq_4 dwArg04, Eq_96521 dwArg08, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = 0x00;
	Eq_4 ebx_20 = 0x00;
	while (true)
	{
		Eq_4 ebp_156;
		byte cl_28 = (byte) dwArg08;
		Eq_4 esi_27 = ecx_19;
		ui32 edi_32 = 0x00 - (dwArg08 < 0x20);
		if ((edi_32 & ecx_19 >> cl_28) != 0x00)
			break;
		if (ebx_20 >= *((word32) dwArg04 + 800))
		{
			if (ecx_19 == 0x00)
			{
				((word32) dwArg04 + 800)->u0 = 0x00;
				esiOut = ecx_19;
				return ebx_20;
			}
			else
			{
				while (true)
				{
					ebp_156 = esi_27;
					if ((edi_32 & esi_27 >> cl_28) != 0x00)
						break;
					esi_27 *= 0x0A;
					++ebx_20;
				}
				goto l08093FBE;
			}
		}
		if (ebx_20 >= 800)
			runtime.panicindex(gs);
		ecx_19 = (word32) Mem0[ebx_20 + dwArg04:byte] - 0x30 + ecx_19 * 0x0A;
		++ebx_20;
	}
	ebp_156 = ecx_19;
l08093FBE:
	*((word32) dwArg04 + 804) -= ebx_20 - (struct Eq_96575 *) 0x01;
	ui32 ebx_79 = 0x01 << cl_28 & edi_32;
	Eq_4 esi_187;
	Eq_4 dwLoc14_235 = 0x00;
	byte cl_224 = (byte) dwArg08;
	for (esi_187 = ebx_20; esi_187 < *((word32) dwArg04 + 800); ++esi_187)
	{
		if (esi_187 >= 800)
			runtime.panicindex(gs);
		word32 ebx_167 = (word32) Mem166[esi_187 + dwArg04:byte];
		ui32 ebp_171 = ebp_156 >> cl_224 & edi_32;
		ui32 edi_174 = ebp_156 & ebx_79 - 0x01;
		if (dwLoc14_235 >= 800)
			runtime.panicindex(gs);
		Mem184[dwArg04 + dwLoc14_235:byte] = SLICE(ebp_171 + 0x30, byte, 0);
		ebp_156 = ebx_167 - 0x30 + edi_174 * 0x0A;
		++dwLoc14_235;
	}
	Eq_4 esi_104 = dwLoc14_235;
	while (ebp_156 > 0x00)
	{
		Eq_4 ebp_137;
		uint32 ebp_121 = ebp_156 >> cl_224;
		ui32 ebp_124 = ebp_121 & edi_32;
		ui32 edx_127 = ebp_156 & ebx_79 - 0x01;
		if (esi_104 < 800)
		{
			if (esi_104 >= 800)
				runtime.panicindex(gs);
			Mem145[dwArg04 + esi_104:byte] = SLICE(ebp_124 + 0x30, byte, 0);
			ebp_137 = esi_104 + 0x01;
		}
		else
		{
			if ((edi_32 & ebp_121) > 0x00)
				*((word32) dwArg04 + 809) = 0x01;
			ebp_137 = esi_104;
		}
		esi_104 = ebp_137;
		ebp_156 = edx_127 * 0x0A;
	}
	*((word32) dwArg04 + 800) = esi_104;
	strconv.trim(gs, dwArg04);
	esiOut = esi_104;
	return ebx_79 - 0x01;
}

// 08094100: void strconv.prefixIsLessThan(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      strconv.leftShift
void strconv.prefixIsLessThan(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, int32 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebp_20 = 0x00;
	while (ebp_20 < dwArg14)
	{
		if (ebp_20 >= dwArg08)
			return;
		if (ebp_20 >= dwArg08)
		{
l0809415B:
			runtime.panicindex(gs);
		}
		word32 esi_36 = (word32) Mem0[dwArg04 + ebp_20:byte];
		if (ebp_20 >= dwArg14)
			goto l0809415B;
		if ((byte) esi_36 != (byte) ((word32) (*((word32) ebp_20 + dwArg10))))
			return;
		ebp_20 = (word32) ebp_20 + 1;
	}
}

// 08094170: Register Eq_4 strconv.leftShift(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out (ptr32 Eq_96718) esiOut)
// Called from:
//      strconv.(*decimal).Shift
Eq_4 strconv.leftShift(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_96718 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_141528 ecx_18[] = g_ptr8142760;
	if (dwArg08 >= g_t8142764)
		runtime.panicindex(gs);
	else
	{
		Eq_96739 ebx_23 = ecx_18[dwArg08].t0000;
		Eq_4 esi_25 = *((word32) dwArg04 + 800);
		if (esi_25 > 800)
			runtime.panicslice(gs);
		else
		{
			Eq_96739 edx_52;
			strconv.prefixIsLessThan(gs, dwArg04, esi_25, ecx_18[dwArg08].dw0004, ecx_18[dwArg08].t0008);
			if ((byte) (word32) bLoc0C != 0x00)
				edx_52 = ebx_23 - 0x01;
			else
				edx_52 = ebx_23;
			Eq_4 ebp_60 = *((word32) dwArg04 + 800);
			word32 esi_115 = edx_52 + ebp_60;
			Eq_96772 ebp_180;
			uint32 eax_129 = 0x00;
			for (ebp_180 = ebp_60 - 0x01; ebp_180 >= 0x00; --ebp_180)
			{
				if (ebp_180 >= 800)
					runtime.panicindex(gs);
				word32 edx_150 = ((word32) Mem138[dwArg04 + ebp_180:byte] + ~0x2F << SLICE(dwArg08, byte, 0) & 0x00 - (dwArg08 <u 0x20)) + eax_129;
				uint32 edx_154 = SLICE(edx_150 * ~0x33333332, word32, 32);
				uint32 edi_159 = edx_150 - ((edx_154 >> 0x03) + (edx_154 >> 0x03) * 0x04 << 0x01);
				struct Eq_96718 * edx_161 = esi_115 - 0x01;
				if (edx_161 < (struct Eq_96718 *) 800)
				{
					if (edx_161 >= (struct Eq_96718 *) 800)
						runtime.panicindex(gs);
					*((word32) dwArg04 + (esi_115 - 0x01)) = (byte) (edi_159 + 0x30);
				}
				else if (edi_159 != 0x00)
					*((word32) dwArg04 + 809) = 0x01;
				eax_129 = edx_154 >> 0x03;
				esi_115 = edx_161;
			}
			while (eax_129 > 0x00)
			{
				uint32 edx_110 = SLICE(eax_129 * ~0x33333332, word32, 32);
				uint32 ecx_114 = eax_129 - ((edx_110 >> 0x03) + (edx_110 >> 0x03) * 0x04 << 0x01);
				struct Eq_96718 * edi_116 = esi_115 - (struct Eq_96868 *) 0x01;
				if (edi_116 < (struct Eq_96718 *) 800)
				{
					if (edi_116 >= (struct Eq_96718 *) 800)
						runtime.panicindex(gs);
					Mem127[esi_115 - 0x01 + dwArg04:byte] = SLICE(ecx_114 + 0x30, byte, 0);
				}
				else if (ecx_114 != 0x00)
					*((word32) dwArg04 + 809) = 0x01;
				eax_129 = edx_110 >> 0x03;
				esi_115 = edi_116;
			}
			word32 eax_80 = Mem77[dwArg04 + 800:word32] + edx_52;
			*((word32) dwArg04 + 800) = eax_80;
			if (eax_80 >= 800)
				((word32) dwArg04 + 800)->u0 = 800;
			Mem91[dwArg04 + 0x0324:word32] = Mem86[dwArg04 + 0x0324:word32] + edx_52;
			strconv.trim(gs, dwArg04);
			esiOut = esi_115;
			return dwArg04;
		}
	}
}

// 08094330: Register word32 strconv.(*decimal).Shift(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 esiOut)
// Called from:
//      strconv.bigFtoa
//      strconv.roundShortest
word32 strconv.(*decimal).Shift(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 800) != 0x00)
	{
		Eq_4 ecx_22 = dwArg08;
		if (dwArg08 <= 0x00)
		{
			if (dwArg08 < 0x00)
			{
				while (ecx_22 < ~0x1B)
				{
					word32 esi_148;
					strconv.rightShift(gs, dwArg04, 0x1C, out esi_148);
					ecx_22 = (word32) ecx_22 + 28;
				}
				ebx = strconv.rightShift(gs, dwArg04, -ecx_22, out esi);
			}
		}
		else
		{
			for (; ecx_22 > 0x1C; ecx_22 -= 0x1C)
			{
				word32 esi_147;
				strconv.leftShift(gs, dwArg04, 0x1C, out esi_147);
			}
			ebx = strconv.leftShift(gs, dwArg04, ecx_22, out esi);
		}
	}
	esiOut = esi;
	return ebx;
}

// 080943E0: void strconv.(*decimal).Round(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.bigFtoa
//      strconv.roundShortest
void strconv.(*decimal).Round(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 < 0x00)
		return;
	Eq_4 edx_22 = *((word32) dwArg04 + 800);
	if (dwArg08 >= edx_22)
		return;
	if (dwArg08 >= 800)
		runtime.panicindex(gs);
	Eq_96983 dl_38;
	byte bl_28 = SLICE((word32) Mem0[dwArg04 + dwArg08:byte], byte, 0);
	Eq_96983 C_35 = SLICE(cond(bl_28 - 0x35), bool, 1);
	if (bl_28 == 0x35)
	{
		if (dwArg08 + 0x01 == edx_22)
		{
			if ((byte) (word32) *((word32) dwArg04 + 809) != 0x00)
				goto l08094435;
			if (dwArg08 > 0x00)
			{
				if (dwArg08 >= 0x0321)
					runtime.panicindex(gs);
				dl_38 = (SLICE((word32) Mem0[dwArg08 - 0x01 + dwArg04:byte] + ~0x2F, byte, 0) & 0x01) != 0x00;
			}
			else
				dl_38.u1 = 0x00;
l08094462:
			if (dl_38 == 0x00)
			{
				strconv.(*decimal).RoundDown(gs, dwArg04, dwArg08);
				return;
			}
l08094435:
			strconv.(*decimal).RoundUp(gs, dwArg04, dwArg08);
			return;
		}
		C_35.u0 = SLICE(cond(bl_28 - 0x35), bool, 1);
	}
	dl_38 = C_35;
	goto l08094462;
}

// 080944A0: void strconv.(*decimal).RoundDown(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.(*decimal).Round
//      strconv.roundShortest
void strconv.(*decimal).RoundDown(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 < 0x00 || dwArg08 >= *((word32) dwArg04 + 800))
		return;
	*((word32) dwArg04 + 800) = dwArg08;
	strconv.trim(gs, dwArg04);
}

// 080944F0: void strconv.(*decimal).RoundUp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.(*decimal).Round
//      strconv.roundShortest
void strconv.(*decimal).RoundUp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 < 0x00 || dwArg08 >= *((word32) dwArg04 + 800))
		return;
	Eq_97083 eax_24;
	for (eax_24 = dwArg08 - 0x01; eax_24 >= 0x00; --eax_24)
	{
		if (eax_24 >= 800)
			runtime.panicindex(gs);
		word32 edx_41 = (word32) Mem0[dwArg04 + eax_24:byte];
		if ((byte) edx_41 < 0x39)
		{
			Mem49[dwArg04 + eax_24:byte] = SLICE(edx_41 + 0x01, byte, 0);
			*((word32) dwArg04 + 800) = (word32) eax_24 + 1;
			return;
		}
	}
	*dwArg04 = 0x31;
	((word32) dwArg04 + 800)->u0 = 0x01;
	*((word32) dwArg04 + 804) = (word32) *((word32) dwArg04 + 804) + 1;
}

// 08094570: void strconv.(*extFloat).AssignComputeBounds(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_97128) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_97131 dwArg10, Stack byte bArg14, Stack (ptr32 Eq_24555) dwArg18)
// Called from:
//      strconv.genericFtoa
void strconv.(*extFloat).AssignComputeBounds(struct Eq_2 * gs, struct Eq_97128 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_97131 dwArg10, byte bArg14, struct Eq_24555 * dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg04->t0000 = dwArg08;
	dwArg04->t0004 = dwArg0C;
	dwArg04->dw0008 = dwArg10 - dwArg18->dw0000;
	dwArg04->b000C = (byte) (word32) bArg14;
	int32 edi_36 = dwArg04->dw0008;
	if (edi_36 <= 0x00)
	{
		Eq_97170 ebx_44 = -edi_36;
		up32 ecx_54 = 0x20 - ebx_44;
		byte cl_61 = (byte) ebx_44;
		ui32 ebx_65 = 0x00 - (ebx_44 < 0x20);
		ui32 edx_74 = 0x00 - (ecx_54 < 0x20);
		ui32 eax_80 = 0x00 - (ebx_44 < 0x40);
		uint32 edx_84 = dwArg0C >> (byte) (ebx_44 - 0x20) & eax_80 | (dwArg0C << (byte) ecx_54 & edx_74 | dwArg08 >> cl_61 & ebx_65);
		byte cl_95 = (byte) ebx_44;
		Eq_4 ebp_103 = edx_84 >> (byte) ecx_54 & edx_74 | (dwArg0C >> cl_61 & ebx_65) << cl_95 & ebx_65 | edx_84 << (byte) (ebx_44 - 0x20) & eax_80;
		Eq_4 esi_119 = edx_84 << cl_95 & ebx_65;
		if ((byte) (SEQ(SLICE(ebp_103, word24, 8), dwArg0C == ebp_103) & SEQ(SLICE(esi_119, word24, 8), dwArg08 == esi_119)) != 0x00)
		{
			Eq_4 ebp_145 = dwArg04->t0004;
			dwArg04->t0000 = ebp_145 >> (byte) (ebx_44 - 0x20) & eax_80 | (dwArg04->t0000 >> (byte) ebx_44 & ebx_65 | ebp_145 << (byte) ecx_54 & edx_74);
			dwArg04->t0004 = ebp_145 >> (byte) ebx_44 & ebx_65;
			dwArg04->dw0008 = 0x00;
			return;
		}
	}
	up32 ebp_216 = dwArg18->dw0000;
	up32 ebx_222 = 0x20 - ebp_216;
	word32 edx_200 = dwArg10 - dwArg18->dw0008;
	if ((byte) (SEQ(SLICE(dwArg0C, word24, 8), dwArg0C != (0x01 << (byte) (ebp_216 - 0x20) & 0x00 - (ebp_216 < 0x40) | 0x01 >> (byte) ebx_222 & 0x00 - (ebx_222 < 0x20))) | SEQ(SLICE(dwArg08, word24, 8), dwArg08 != (0x01 << (byte) ebp_216 & 0x00 - (ebp_216 < 0x20)))) != 0x00 || edx_200 == 0x01)
		;
}

// 08094830: void strconv.(*extFloat).Normalize(Register Eq_4 ebp, Register (ptr32 Eq_97316) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_97316) dwArg04)
// Called from:
//      strconv.(*extFloat).FixedDecimal
//      strconv.(*extFloat).ShortestDecimal
void strconv.(*extFloat).Normalize(Eq_4 ebp, struct Eq_97316 * esi, struct Eq_2 * gs, struct Eq_97316 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_17 = dwArg04->t0004;
	Eq_4 edx_18 = dwArg04->t0000;
	ui32 ebx_30 = SEQ(SLICE(ebp, word24, 8), ecx_17 == 0x00);
	Eq_4 ebx_19 = dwArg04->t0008;
	if ((byte) (SEQ(SLICE(esi, word24, 8), edx_18 == 0x00) & ebx_30) != 0x00)
		return;
	Eq_4 ecx_135;
	Eq_4 ebp_69;
	if ((byte) (ebx_30 & 0x01) != 0x00)
	{
		ecx_135 = ebx_19 - 0x20;
		ebp_69.u0 = 0x00;
	}
	else
	{
		ebp_69 = edx_18;
		edx_18 = ecx_17;
		ecx_135 = ebx_19;
	}
	Eq_4 edx_128;
	uint32 edx_78 = edx_18 >> 0x10;
	Eq_4 esi_77 = edx_18;
	if ((byte) (SEQ(SLICE(edx_78, word24, 8), edx_78 == 0x00) & 0x01) != 0x00)
	{
		esi_77 = edx_18 << 0x10 | ebp_69 >> 0x10;
		edx_128 = ebp_69 << 0x10;
		ecx_135 = (word32) ecx_135 - 16;
	}
	else
		edx_128 = ebp_69;
	Eq_4 esi_129;
	uint32 esi_101 = esi_77 >> 0x18;
	Eq_4 ebp_100 = esi_77;
	if ((byte) (SEQ(SLICE(esi_101, word24, 8), esi_101 == 0x00) & 0x01) != 0x00)
	{
		ebp_100 = esi_77 << 0x08 | edx_128 >> 0x18;
		esi_129 = edx_128 << 0x08;
		ecx_135 = (word32) ecx_135 - 8;
	}
	else
		esi_129 = edx_128;
	Eq_4 ebp_166;
	uint32 ebp_140 = ebp_100 >> 0x1C;
	Eq_4 edx_139 = ebp_100;
	if ((byte) (SEQ(SLICE(ebp_140, word24, 8), ebp_140 == 0x00) & 0x01) != 0x00)
	{
		edx_139 = ebp_100 << 0x04 | esi_129 >> 0x1C;
		ebp_166 = esi_129 << 0x04;
		ecx_135 = (word32) ecx_135 - 4;
	}
	else
		ebp_166 = esi_129;
	Eq_4 edx_189;
	uint32 edx_177 = edx_139 >> 0x1E;
	Eq_4 esi_176 = edx_139;
	if ((byte) (SEQ(SLICE(edx_177, word24, 8), edx_177 == 0x00) & 0x01) != 0x00)
	{
		esi_176 = edx_139 << 0x02 | ebp_166 >> 0x1E;
		edx_189 = ebp_166 << 0x02;
		ecx_135 = (word32) ecx_135 - 2;
	}
	else
		edx_189 = ebp_166;
	Eq_4 esi_228;
	uint32 esi_200 = esi_176 >> 0x1F;
	Eq_4 ebp_199 = esi_176;
	if ((byte) (SEQ(SLICE(esi_200, word24, 8), esi_200 == 0x00) & 0x01) != 0x00)
	{
		ebp_199 = esi_176 << 0x01 | edx_189 >> 0x1F;
		esi_228 = edx_189 << 0x01;
		--ecx_135;
	}
	else
		esi_228 = edx_189;
	dwArg04->t0000 = esi_228;
	dwArg04->t0004 = ebp_199;
	dwArg04->t0008 = ecx_135;
}

// 08094990: void strconv.(*extFloat).Multiply(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_97316) dwArg04, Stack uint32 dwArg08, Stack uint32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      strconv.(*extFloat).frexp10
//      strconv.frexp10Many
void strconv.(*extFloat).Multiply(struct Eq_2 * gs, struct Eq_97316 * dwArg04, uint32 dwArg08, uint32 dwArg0C, word32 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = dwArg04->t0004;
	Eq_4 esi_25 = dwArg04->t0000;
	uint64 edx_eax_22 = dwArg08 * eax_18;
	uint64 edx_eax_37 = dwArg0C * eax_18;
	uint64 edx_eax_30 = dwArg0C * esi_25;
	up32 edx_23 = SLICE(edx_eax_22, word32, 32);
	up32 eax_38 = (word32) edx_eax_37;
	word32 eax_26 = (word32) edx_eax_22;
	word32 eax_33 = (word32) edx_eax_30;
	up32 edx_31 = SLICE(edx_eax_30, word32, 32);
	up32 eax_41 = eax_38 + edx_23;
	up32 ebp_46 = eax_33 + eax_26;
	up32 edx_51 = SLICE(dwArg08 * esi_25, word32, 32);
	Eq_4 esi_83 = (bool) (eax_41 + edx_31 < 0x00) + ((bool) (eax_38 + edx_23 < 0x00) + SLICE(edx_eax_37, word32, 32));
	dwArg04->t0004 = esi_83;
	Eq_97551 eax_43 = eax_41 + edx_31;
	Eq_97553 edx_69 = SLICE(cond(eax_33 + eax_26), bool, 1) + (edx_51 + ebp_46 < 0x00) + (edx_51 + ebp_46 < 0x80000000);
	Mem86[dwArg04 + 0x00:word32] = edx_69 + eax_43;
	Mem91[dwArg04 + 0x04:word32] = esi_83 + (edx_69 + eax_43 <u 0x00);
	dwArg04->t0008 = (word32) dwArg04->t0008 + 64 + dwArg10;
}

// 08094A70: void strconv.(*extFloat).frexp10(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_97316) dwArg04)
// Called from:
//      strconv.frexp10Many
//      strconv.(*extFloat).FixedDecimal
void strconv.(*extFloat).frexp10(struct Eq_2 * gs, struct Eq_97316 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_18 = dwArg04->t0008;
	int32 ebx_20 = -((word32) edx_18 + 46);
	Eq_97607 edx_29 = (SLICE(ebx_20 *s 0x1C *s 0xB02C0B03, word32, 32) + ebx_20 *s 0x1C >> 0x06) - (ebx_20 *s 0x1C >> 0x1F);
	Eq_97621 edx_34 = (word32) edx_29 + ((word32) (((word32) edx_29 + 348 >> 0x1F) >> 0x1D) + 348) >> 0x03;
	while (edx_34 < 0x57)
	{
		Eq_97621 eax_83;
		struct Eq_97638 * edx_41 = edx_34 << 0x04;
		word32 esi_44 = edx_41->dw813F908;
		int32 edi_46 = (word32) edx_18 + 64 + esi_44;
		if (edi_46 < ~0x3B)
			eax_83 = (word32) edx_34 + 1;
		else
		{
			if (edi_46 <= ~0x1F)
			{
				strconv.(*extFloat).Multiply(gs, dwArg04, edx_41->dw813F900, edx_41->dw813F904, esi_44);
				return;
			}
			eax_83 = edx_34 - 0x01;
		}
		edx_34 = eax_83;
	}
	runtime.panicindex(gs);
}

// 08094B50: void strconv.frexp10Many(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_97316) dwArg04, Stack (ptr32 Eq_97316) dwArg08, Stack (ptr32 Eq_97316) dwArg0C)
// Called from:
//      strconv.(*extFloat).ShortestDecimal
void strconv.frexp10Many(struct Eq_2 * gs, struct Eq_97316 * dwArg04, struct Eq_97316 * dwArg08, struct Eq_97316 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.(*extFloat).frexp10(gs, dwArg0C);
	if (dwLoc14 >= 0x57)
		runtime.panicindex(gs);
	else
	{
		strconv.(*extFloat).Multiply(gs, dwArg04, g_a813F900[dwLoc14], g_a813F904[dwLoc14], g_a813F908[dwLoc14]);
		strconv.(*extFloat).Multiply(gs, dwArg08, g_a813F900[dwLoc14], g_a813F904[dwLoc14], g_a813F908[dwLoc14]);
	}
}

// 08094C20: void strconv.(*extFloat).FixedDecimal(Register Eq_4 ebp, Register (ptr32 Eq_97316) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_97316) dwArg04, Stack (ptr32 Eq_97722) dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      strconv.genericFtoa
void strconv.(*extFloat).FixedDecimal(Eq_4 ebp, struct Eq_97316 * esi, struct Eq_2 * gs, struct Eq_97316 * dwArg04, struct Eq_97722 * dwArg08, Eq_4 dwArg0C)
{
	while (fp - 0x48 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = dwArg04->t0000;
	Eq_4 edx_20 = dwArg04->t0004;
	if ((byte) (SEQ(SLICE(edx_20, word24, 8), edx_20 == 0x00) & SEQ(SLICE(ecx_19, word24, 8), ecx_19 == 0x00)) != 0x00)
	{
		dwArg08->dw000C = 0x00;
		dwArg08->dw0010 = 0x00;
		dwArg08->b0014 = (byte) (word32) dwArg04->t000C;
		return;
	}
	if (dwArg0C == 0x00)
		runtime.gopanic(gs);
	strconv.(*extFloat).Normalize(ebp, esi, gs, dwArg04);
	strconv.(*extFloat).frexp10(gs, dwArg04);
	up32 ecx_95 = -dwArg04->t0008;
	uint32 ebx_114 = 0x20 - ecx_95;
	Eq_4 edx_97 = dwArg04->t0000;
	ui32 ebp_106 = 0x00 - (ecx_95 < 0x20);
	Eq_4 eax_99 = dwArg04->t0004;
	ui32 ecx_124 = 0x00 - (ebx_114 < 0x20);
	ui32 esi_134 = 0x00 - (ecx_95 < 0x40);
	Eq_97814 eax_137 = eax_99 << (byte) ebx_114 & ecx_124 | edx_97 >> (byte) ecx_95 & ebp_106 | eax_99 >> (byte) (ecx_95 - 0x20) & esi_134;
	uint32 ebx_144 = edx_97 - (eax_137 << (byte) ecx_95 & ebp_106);
	ui24 ebx_24_8_196 = SLICE(ebx_144, word24, 8);
	Eq_4 esi_166 = 0x00;
	uint32 dwLoc8C_752 = 0x00;
	Eq_97814 dwLoc90_754 = 0x01;
	while (true)
	{
		ui24 edx_24_8_194 = SLICE(eax_137, word24, 8);
		if (esi_166 >= 0x14)
			break;
		if ((byte) (SEQ(edx_24_8_194, dwLoc90_754 > eax_137) & SEQ(ebx_24_8_196, dwLoc8C_752 == 0x00) | SEQ(ebx_24_8_196, dwLoc8C_752 > 0x00)) != 0x00)
			goto l08094DB0;
		esi_166 = (byte) esi_166.u0 + 1;
		ebx_24_8_196 = SLICE(ebx_144, word24, 8);
		dwLoc8C_752 = SLICE(dwLoc90_754 * 0x0A, word32, 32) + dwLoc8C_752 * 0x0A;
		dwLoc90_754 = (word32) (dwLoc90_754 * 0x0A);
	}
	esi_166.u0 = 0x00;
l08094DB0:
	uint32 esi_241;
	ui32 ebp_239;
	Eq_97814 edx_238;
	Eq_4 dwLoc80_764 = esi_166;
	if (esi_166 > dwArg0C)
	{
		Eq_97876 esi_244 = esi_166 - dwArg0C;
		if (esi_244 >= 0x14)
			runtime.panicindex(gs);
		struct Eq_97882 * ebx_250 = esi_244 * 0x08 + 0x08138C80;
		ebp_239 = ebx_250->dw0004;
		Eq_97890 ebx_252 = ebx_250->t0000;
		if (ebx_252 == 0x00)
			runtime.panicdivide(gs);
		Eq_97814 eax_260 = (uint32) ((uint64) (uint32) eax_137 /u ebx_252);
		edx_238 = eax_260;
		esi_241 = eax_137 - eax_260 *s ebx_252;
	}
	else
	{
		edx_238 = eax_137;
		ebp_239 = 0x00;
		esi_241 = 0x00;
	}
	fn0808FD88(0x00, fp - 0x20);
	struct Eq_97912 * eax_279 = (struct Eq_97912 *) 0x20;
	while (edx_238 > 0x00)
	{
		uint32 edx_695 = SLICE(edx_238 * ~0x33333332, word32, 32);
		edx_238 = edx_695 >> 0x03;
		uint32 edi_699 = edx_238 - ((edx_695 >> 0x03) + (edx_695 >> 0x03) * 0x04 << 0x01);
		struct Eq_97912 * ebx_700 = eax_279 - 0x01;
		if (ebx_700 >= (struct Eq_97912 *) 0x20)
			runtime.panicindex(gs);
		eax_279 - 0x01 + (fp - 0x24) = (byte *) (byte) (edi_699 + 0x30);
		eax_279 = ebx_700;
	}
	eax_293 = eax_279;
	while (true)
	{
		struct Eq_97912 * eax_293;
		if (eax_293 >= (struct Eq_97912 *) 0x20)
			break;
		Eq_4 eax_671 = eax_293 - eax_279;
		if (eax_293 >= (struct Eq_97912 *) 0x20)
		{
l08095237:
			runtime.panicindex(gs);
		}
		Eq_4 ebp_676 = dwArg04->t0000;
		word32 esi_677 = (word32) Mem674[fp - 0x24 + eax_293:byte];
		if (eax_671 >= dwArg04->t0004)
			goto l08095237;
		Mem684[ebp_676 + eax_671:byte] = SLICE(esi_677, byte, 0);
		eax_293 = (struct Eq_97912 *) ((char *) eax_293 + 1);
	}
	word64 ebx_eax_962;
	ui32 dwLoc7C_779;
	Eq_4 ebx_302 = 0x20 - eax_279;
	dwArg04->t000C = ebx_302;
	dwArg04->t0010 = dwLoc84 + dwLoc78;
	word32 ebx_314 = eax_279 - 0x20 + dwArg08;
	if (ebx_314 <= null)
	{
		dwLoc7C_779 = dwLoc70;
		ebx_eax_962 = 0x01;
		goto l080950F4;
	}
	else
	{
		if (esi_241 == 0x00)
		{
			struct Eq_97962 * ebx_354 = ebx_314;
			if ((byte) (SEQ(SLICE(dwLoc78, word24, 8), ebp_239 != 0x00) | SEQ(SLICE(dwLoc9C, word24, 8), dwLoc9C != 0x01)) == 0x00)
			{
				dwLoc7C_779 = dwLoc70;
				uint32 dwLocA8_787 = 0x01;
				ui32 dwLocA4_789 = 0x00;
				Eq_4 eax_398 = ebx_302;
				for (; ebx_354 > null; ebx_354 -= (struct Eq_98118 *) 0x01)
				{
					uint32 eax_515 = (word32) (dwLocA8_787 * 0x0A);
					ui32 edx_525 = SLICE(dwLocA8_787 * 0x0A, word32, 32) + dwLocA4_789 * 0x0A;
					ui32 ebp_541 = 0x01 >> (byte) ecx_124 & esi_134;
					uint32 eax_529 = eax_515 >> 0x1F | edx_525 << 0x01;
					uint32 esi_543 = 0x01 << (byte) eax_99 & eax_137 | ebp_541;
					ui24 ebx_24_8_551 = SLICE(ebp_541, word24, 8);
					uint32 eax_511 = (word32) (dwLoc80_764 * 0x0A);
					dwLocA8_787 = eax_515;
					uint32 ebx_520 = SLICE(dwLoc80_764 * 0x0A, word32, 32) + dwLoc7C_779 * 0x0A;
					dwLocA4_789 = edx_525;
					if ((byte) (SEQ(SLICE(eax_515 << 0x01, word24, 8), eax_515 << 0x01 > (0x01 << (byte) (ecx_95 - 0x20) & ebx_114)) & SEQ(ebx_24_8_551, eax_529 == esi_543) | SEQ(ebx_24_8_551, eax_529 > esi_543)) != 0x00)
						return;
					byte cl_610 = (byte) (ecx_95 - 0x20);
					uint32 ebp_604 = ebx_520 >> (byte) eax_99 & eax_137 | (ebx_520 << (byte) ecx_124 & esi_134 | eax_511 >> (byte) (ecx_95 - 0x20) & ebx_114);
					ui32 edi_612 = ebx_520 >> cl_610 & ebx_114;
					Eq_4 edi_615 = dwArg04->t0000;
					if (eax_398 >= dwArg04->t0004)
						runtime.panicindex(gs);
					Mem628[edi_615 + eax_398:byte] = SLICE(ebp_604 + 0x30, byte, 0);
					uint32 edx_622 = ebp_604 << cl_610 & ebx_114;
					dwLoc80_764 = eax_511 - edx_622;
					dwLoc7C_779 = SLICE(SEQ(ebx_520, eax_511) - SEQ((edi_612 << (byte) (ecx_95 - 0x20) & ebx_114 | ebp_604 >> (byte) ecx_124 & esi_134) | ebp_604 << (byte) eax_99 & eax_137, edx_622), word32, 32);
					eax_398 = (word32) eax_398 + 1;
				}
				dwArg04->t000C = eax_398;
				ebx_eax_962 = SEQ(dwLocA4_789, dwLocA8_787);
l080950F4:
				ui32 esi_443 = esi_241 << (byte) eax_99 & eax_137 | esi_241 >> (byte) ecx_124 & esi_134 | dwLoc7C_779;
				strconv.adjustLastDigitFixed(esi_443, gs, dwArg04, SEQ(esi_443, dwLoc80_764 | esi_241 << (byte) (ecx_95 - 0x20) & ebx_114), dwLoc9C, ebp_239, ecx_95 - 0x20, ebx_eax_962);
				if ((byte) (word32) bLocAC == 0x00)
					return;
				Eq_4 ecx_477;
				for (ecx_477 = dwArg04->t000C - 0x01; ecx_477 >= 0x00; --ecx_477)
				{
					Eq_4 edx_485 = dwArg04->t0000;
					if (ecx_477 >= dwArg04->t0004)
						runtime.panicindex(gs);
					if (SLICE((word32) Mem454[edx_485 + ecx_477:byte], byte, 0) != 0x30)
					{
						dwArg04->t000C = (word32) ecx_477 + 1;
						return;
					}
				}
				return;
			}
		}
		runtime.gopanic(gs);
	}
}

// 08095280: void strconv.adjustLastDigitFixed(Register ui32 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_97316) dwArg04, Stack ui64 qwArg08, Stack uint32 dwArg10, Stack ui32 dwArg14, Stack up32 dwArg18, Stack word64 qwArg1C)
// Called from:
//      strconv.(*extFloat).FixedDecimal
void strconv.adjustLastDigitFixed(ui32 esi, struct Eq_2 * gs, struct Eq_97316 * dwArg04, ui64 qwArg08, uint32 dwArg10, ui32 dwArg14, up32 dwArg18, word64 qwArg1C)
{
	uint32 dwArg08 = (word32) qwArg08;
	uint32 dwArg0C = SLICE(qwArg08, word32, 32);
	ui32 dwArg20 = SLICE(qwArg1C, word32, 32);
	uint32 dwArg1C = (word32) qwArg1C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ebx_24 = 0x00 - (dwArg18 < 0x20);
	up32 ecx_48 = 0x20 - dwArg18;
	ui32 ebp_47 = 0x00 - (dwArg18 < 0x40) & dwArg10 << (byte) (dwArg18 - 0x20);
	uint32 eax_25 = dwArg10 << (byte) dwArg18 & ebx_24;
	ui24 ebx_24_8_36 = SLICE(esi, word24, 8);
	uint32 edx_62 = dwArg10 >> (byte) ecx_48 & 0x00 - (ecx_48 < 0x20) | dwArg14 << (byte) dwArg18 & ebx_24 | ebp_47;
	ui24 ebx_24_8_128 = SLICE(dwArg0C, word24, 8);
	if ((byte) (SEQ(ebx_24_8_36, dwArg0C > edx_62) | SEQ(SLICE(ebp_47, word24, 8), dwArg0C == edx_62) & SEQ(ebx_24_8_36, dwArg08 > eax_25)) != 0x00)
		runtime.gopanic(gs);
	else
	{
		uint32 esi_120 = dwArg1C >> 0x1F | dwArg20 << 0x01;
		if ((byte) (SEQ(SLICE(dwArg1C << 0x01, word24, 8), dwArg1C << 0x01 > eax_25) & SEQ(ebx_24_8_128, esi_120 == edx_62) | SEQ(ebx_24_8_128, esi_120 > edx_62)) != 0x00)
			runtime.gopanic(gs);
		else
		{
			ui64 edi_ebx_325 = qwArg08 + qwArg1C;
			uint32 ebx_174 = (word32) edi_ebx_325;
			uint32 ebx_182 = ebx_174 >> 0x1F | SLICE(edi_ebx_325, word32, 32) << 0x01;
			ui24 eax_24_8_244 = SLICE(eax_25, word24, 8);
			if ((byte) (SEQ(SLICE(dwArg20, word24, 8), ebx_182 == edx_62) & SEQ(SLICE(ebx_174 << 0x01, word24, 8), ebx_174 << 0x01 < eax_25) | SEQ(SLICE(ebx_182, word24, 8), ebx_182 < edx_62)) != 0x00)
				return;
			ui64 ecx_esi_328 = qwArg08 - qwArg1C;
			ui32 ecx_232 = SLICE(ecx_esi_328, word32, 32);
			uint32 esi_227 = (word32) ecx_esi_328;
			uint32 esi_236 = esi_227 >> 0x1F | ecx_232 << 0x01;
			if ((byte) (SEQ(eax_24_8_244, esi_227 << 0x01 > eax_25) & SEQ(SLICE(ecx_232 << 0x01, word24, 8), esi_236 == edx_62) | SEQ(SLICE(ecx_232 << 0x01, word24, 8), esi_236 > edx_62)) == 0x00)
				return;
			Eq_4 ecx_264 = dwArg04->t000C - 0x01;
			while (true)
			{
				Eq_98364 SO_269 = SLICE(cond(ecx_264), bool, 4);
				if (ecx_264 < 0x00)
					break;
				Eq_4 edx_272 = dwArg04->t0000;
				if (ecx_264 >= dwArg04->t0004)
					runtime.panicindex(gs);
				if (SLICE((word32) Mem271[ecx_264 + edx_272:byte], byte, 0) != 0x39)
				{
					SO_269.u0 = SLICE(cond(ecx_264), bool, 4);
					break;
				}
				--dwArg04->t000C;
				ecx_264 -= (byte *) 0x01;
			}
			if (SO_269)
			{
				Eq_4 eax_293 = dwArg04->t0000;
				if (ecx_264 >= dwArg04->t0004)
					runtime.panicindex(gs);
				else
					Mem302[eax_293 + ecx_264:byte] = SLICE((word32) Mem271[ecx_264 + eax_293:byte] + 0x01, byte, 0);
			}
			else
			{
				Eq_4 edx_304 = dwArg04->t0000;
				if (dwArg04->t0004 <= 0x00)
					runtime.panicindex(gs);
				else
				{
					*edx_304 = 0x31;
					dwArg04->t000C.u0 = 0x01;
					dwArg04->t0010 = (word32) dwArg04->t0010 + 1;
				}
			}
		}
	}
}

// 08095480: void strconv.(*extFloat).ShortestDecimal(Register word32 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_98445) dwArg00, Stack (ptr32 Eq_97316) dwArg04, Stack (ptr32 Eq_98447) dwArg08, Stack (ptr32 Eq_97316) dwArg0C, Stack (ptr32 Eq_97316) dwArg10)
// Called from:
//      strconv.genericFtoa
void strconv.(*extFloat).ShortestDecimal(word32 ebp, Eq_4 esi, struct Eq_2 * gs, struct Eq_98445 * dwArg00, struct Eq_97316 * dwArg04, struct Eq_98447 * dwArg08, struct Eq_97316 * dwArg0C, struct Eq_97316 * dwArg10)
{
	while (fp - 0x70 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 ebx_20 = dwArg04->t0004;
	ui24 edx_24_8_85 = SLICE(edx_19, word24, 8);
	ui24 ebx_24_8_83 = SLICE(ebx_20, word24, 8);
	if ((byte) (SEQ(SLICE(esi, word24, 8), ebx_20 == 0x00) & SEQ(SLICE(ebp, word24, 8), edx_19 == 0x00)) != 0x00)
	{
		dwArg08->t000C.u0 = 0x00;
		dwArg08->dw0010 = 0x00;
		dwArg08->b0014 = (byte) (word32) dwArg04->t000C;
	}
	else
	{
		Eq_4 ebp_1126 = dwArg04->t0008;
		if (ebp_1126 == 0x00)
		{
			Eq_4 ecx_74 = dwArg0C->t0004;
			ebp_1126 = dwArg0C->t0000;
			ui24 ecx_24_8_120 = SLICE(ecx_74, word24, 8);
			if ((byte) (SEQ(ebx_24_8_83, ecx_74 == ebx_20) & SEQ(edx_24_8_85, ebp_1126 == edx_19)) != 0x00)
			{
				Eq_4 edx_93 = dwArg0C->t0008;
				if (edx_93 == ebp_1126)
				{
					byte bl_103 = (byte) (word32) dwArg0C->t000C;
					if ((byte) (word32) dwArg04->t000C == bl_103)
					{
						Eq_4 ebx_112 = dwArg10->t0000;
						ebp_1126 = dwArg10->t0004;
						struct Eq_97316 * esi_1002 = dwArg10;
						if ((byte) (SEQ(ecx_24_8_120, ebp_1126 == ecx_74) & SEQ(SLICE(ebx_112, word24, 8), ebx_112 == ebp_1126)) != 0x00 && (dwArg10->t0008 == edx_93 && (byte) ((word32) dwArg10->t000C) == (byte) ((word32) bl_103)))
						{
							fn0808FD8A(0x00, fp - 0x1C);
							Eq_4 edx_1129 = dwArg00->t0000;
							Eq_4 ebx_1130 = dwArg00->t0004;
							byte * eax_1006 = (byte *) 0x17;
							while (true)
							{
								ui24 ebx_24_8_986 = SLICE(esi_1002, word24, 8);
								struct Eq_97316 * ebx_1001 = SEQ(ebx_24_8_986, ebx_1130 > 0x00);
								esi_1002 = ebx_1001;
								if ((byte) (SEQ(SLICE(ebp_1126, word24, 8), ebx_1130 == 0x00) & SEQ(ebx_24_8_986, edx_1129 > 0x00) | ebx_1001) == 0x00)
									break;
								runtime.uint64div(gs, edx_1129, ebx_1130, 0x0A, 0x00);
								byte dl_1124 = (byte) (edx_1129 - (word32) (dwLocE4 * 0x0A) + 0x30);
								if (eax_1006 >= (byte *) 0x18)
									runtime.panicindex(gs);
								eax_1006[fp - 0x20] = dl_1124;
								ebp_1126 = eax_1006 - (byte *) 0x01;
								edx_1129 = dwLocE4;
								ebx_1130 = dwLocE0;
								eax_1006 -= (byte *) 0x01;
							}
							Eq_4 edx_1017 = 0x17 - eax_1006;
							Eq_4 ebp_1021;
							for (ebp_1021 = 0x00; ebp_1021 < edx_1017; ++ebp_1021)
							{
								word32 edi_1073 = eax_1006 + ebp_1021;
								if (eax_1006 + 0x01 + ebp_1021 >=u 0x18)
								{
l08095F89:
									runtime.panicindex(gs);
								}
								Eq_4 ecx_1078 = dwArg04->t0000;
								word32 edi_1080 = (word32) Mem1076[edi_1073 + 0x01 + (fp - 0x20):byte];
								if (ebp_1021 >= dwArg04->t0004)
									goto l08095F89;
								Mem1087[ecx_1078 + ebp_1021:byte] = SLICE(edi_1080, byte, 0);
							}
							dwArg04->t000C = edx_1017;
							dwArg04->t0010 = edx_1017;
							while (true)
							{
								Eq_4 eax_1033 = dwArg04->t000C;
								bool Z_1049 = SLICE(cond(eax_1033), bool, 2);
								if (eax_1033 <= 0x00)
									break;
								Eq_4 edx_1036 = dwArg04->t0000;
								if (eax_1033 - (byte *) 0x01 >= dwArg04->t0004)
									runtime.panicindex(gs);
								if (SLICE((word32) Mem1032[eax_1033 - 0x01 + edx_1036:byte], byte, 0) != 0x30)
								{
									Z_1049 = SLICE(cond(eax_1033), bool, 2);
									break;
								}
								dwArg04->t000C = eax_1033 - (byte *) 0x01;
							}
							if (!Z_1049)
								dwArg04->t0010.u0 = 0x00;
							dwArg04->b0014 = (byte) (word32) dwArg00->b000C;
							return;
						}
					}
				}
			}
		}
		strconv.(*extFloat).Normalize(ebp_1126, dwArg10, gs, dwArg10);
		Eq_4 ecx_154 = dwArg04->t0008;
		Eq_4 ebx_156 = dwArg10->t0008;
		if (ecx_154 > ebx_156)
		{
			Eq_98656 ecx_162 = ecx_154 - ebx_156;
			Eq_4 ebp_159 = dwArg04->t0000;
			ui32 edi_169 = 0x00 - (ecx_162 < 0x20);
			Eq_4 esi_161 = dwArg04->t0004;
			dwArg04->t0000 = ebp_159 << (byte) ecx_162 & edi_169;
			up32 ebx_177 = 0x20 - ecx_162;
			dwArg04->t0004 = ebp_159 << (byte) (ecx_162 - 0x20) & 0x00 - (ecx_162 < 0x40) | (esi_161 << (byte) ecx_162 & edi_169 | ebp_159 >> (byte) ebx_177 & 0x00 - (ebx_177 < 0x20));
			dwArg04->t0008 = dwArg10->t0008;
		}
		Eq_4 ecx_210 = dwArg0C->t0008;
		Eq_4 ebp_212 = dwArg10->t0008;
		if (ecx_210 > ebp_212)
		{
			Eq_98709 ecx_219 = ecx_210 - ebp_212;
			Eq_4 edi_217 = dwArg0C->t0000;
			ui32 eax_226 = 0x00 - (ecx_219 < 0x20);
			Eq_4 esi_216 = dwArg0C->t0004;
			dwArg0C->t0000 = edi_217 << (byte) ecx_219 & eax_226;
			up32 ecx_233 = 0x20 - ecx_219;
			dwArg0C->t0004 = edi_217 << (byte) (ecx_219 - 0x20) & 0x00 - (ecx_219 < 0x40) | (edi_217 >> (byte) ecx_233 & 0x00 - (ecx_233 < 0x20) | esi_216 << (byte) ecx_219 & eax_226);
			dwArg0C->t0008 = dwArg10->t0008;
		}
		strconv.frexp10Many(gs, dwArg0C, dwArg04, dwArg10);
		Eq_4 ecx_280 = dwArg10->t0000;
		Eq_4 ebx_285 = dwArg10->t0004;
		dwArg10->t0000 = (word32) ecx_280 + 1;
		Mem289[dwArg10 + 0x04:word32] = ebx_285 + (ecx_280 <u 0x01);
		Eq_4 ebx_291 = dwArg0C->t0000;
		Eq_4 ebp_295 = dwArg0C->t0004;
		dwArg0C->t0000 = (word32) ebx_291 - 1;
		Eq_4 ebp_298 = (bool) (ebx_291 < ~0x00) + ((word32) ebp_295 - 1);
		dwArg0C->t0004 = ebp_298;
		up32 ecx_302 = -dwArg10->t0008;
		up32 ebx_319 = 0x20 - ecx_302;
		Eq_4 esi_304 = dwArg10->t0004;
		Eq_4 eax_306 = dwArg10->t0000;
		ui32 ebx_331 = 0x00 - (ecx_302 < 0x20);
		ui32 ecx_336 = 0x00 - (ebx_319 < 0x20);
		ui32 eax_343 = 0x00 - (ecx_302 < 0x40);
		uint32 esi_345 = esi_304 >> (byte) (ecx_302 - 0x20) & eax_343 | (esi_304 << (byte) ebx_319 & ecx_336 | eax_306 >> (byte) ecx_302 & ebx_331);
		uint32 esi_351 = esi_345 << (byte) ecx_302 & ebx_331;
		uint32 ebx_353 = eax_306 - esi_351;
		Eq_4 ebp_360 = dwArg04->t0000;
		uint32 dwLoc90_1199 = ebx_353;
		Eq_98935 ebx_357 = eax_306 - ((word32) ebx_291 - 1);
		Eq_98938 ebx_362 = eax_306 - ebp_360;
		Eq_98940 ebx_381 = SLICE(SEQ(esi_304, eax_306) - SEQ(esi_345 << (byte) (ecx_302 - 0x20) & eax_343 | esi_345 >> (byte) ebx_319 & ecx_336, esi_351), word32, 32);
		Eq_98953 esi_390 = SLICE(SEQ(esi_304, eax_306) - SEQ(ebp_298, (word32) ebx_291 - 1), word32, 32);
		Eq_98959 ebx_398 = SLICE(SEQ(esi_304, eax_306) - SEQ(dwArg04->t0004, ebp_360), word32, 32);
		Eq_98488 ebp_401 = 0x00;
		uint32 esi_402 = 0x01;
		uint32 dwLocAC_1206 = 0x00;
		while (true)
		{
			ui24 edx_24_8_435 = SLICE(esi_345, word24, 8);
			if (ebp_401 >= 0x14)
				break;
			ui24 ebx_24_8_426 = SLICE(ebx_319, word24, 8);
			if ((byte) (SEQ(edx_24_8_435, esi_402 > esi_345) & SEQ(ebx_24_8_426, dwLocAC_1206 == 0x00) | SEQ(ebx_24_8_426, dwLocAC_1206 > 0x00)) != 0x00)
				goto l080959BB;
			uint64 edx_eax_460 = esi_402 * 0x0A;
			ebp_401 = (word32) ebp_401.u0 + 1;
			esi_402 = (word32) edx_eax_460;
			dwLocAC_1206 = SLICE(edx_eax_460, word32, 32) + dwLocAC_1206 * 0x0A;
		}
		ebp_401.u0 = 0x00;
l080959BB:
		Eq_98488 dwLoc94_1222 = 0x00;
		uint32 dwLoc98_1225 = esi_345;
		while (dwLoc94_1222 < ebp_401)
		{
			Eq_98993 ebp_771 = ebp_401 - dwLoc94_1222;
			if (ebp_771 >= 0x15)
				runtime.panicindex(gs);
			struct Eq_98999 * ebp_777 = ebp_771 * 0x08 + 0x08138C78;
			ui32 edx_778 = ebp_777->dw0004;
			Eq_99008 ebp_779 = ebp_777->t0000;
			if (ebp_779 == 0x00)
				runtime.panicdivide(gs);
			Eq_99016 eax_788 = (uint32) ((uint64) (uint32) dwLoc98_1225 /u ebp_779);
			byte * edi_790 = dwArg08->ptr0000;
			if (dwLoc94_1222 >= dwArg08->t0004)
				runtime.panicindex(gs);
			uint32 ebp_798 = dwLoc98_1225 - eax_788 *s ebp_779;
			Mem813[edi_790 + dwLoc94_1222:byte] = SLICE(eax_788 + 0x30, byte, 0);
			uint32 ebp_806 = ebp_798 << (byte) ecx_302 & ebx_331;
			Eq_98953 edi_832 = SLICE(SEQ(ebp_798 << (byte) (ecx_302 - 0x20) & eax_343 | ebp_798 >> (byte) ebx_319 & ecx_336, ebp_806) + SEQ(ebx_381, ebx_353), word32, 32);
			ui24 ebx_24_8_840 = SLICE(eax_343, word24, 8);
			Eq_98935 ebp_809 = ebp_806 + ebx_353;
			dwLoc98_1225 = ebp_798;
			if ((byte) (SEQ(SLICE(ebp_809, word24, 8), ebp_809 < ebx_357) & SEQ(ebx_24_8_840, edi_832 == esi_390) | SEQ(ebx_24_8_840, edi_832 < esi_390)) != 0x00)
			{
				dwArg08->t000C = (word32) dwLoc94_1222 + 1;
				Mem888[dwArg08 + 0x10:word32] = ebp_401 + dwLocE4;
				dwArg08->b0014 = (byte) (word32) dwArg04->t000C;
				strconv.adjustLastDigit(ebx_331, gs, dwArg08, SEQ(edi_832, ebp_809), ebx_362, ebx_398, SEQ(esi_390, ebx_357), SEQ(ebp_779 << (byte) (ecx_302 - 0x20) & eax_343 | (ebp_779 >> (byte) ebx_319 & ecx_336 | edx_778 << (byte) ecx_302 & ebx_331), ebp_779 << (byte) ecx_302 & ebx_331), 0x02);
				return;
			}
			dwLoc94_1222 = (word32) dwLoc94_1222 + 1;
		}
		dwArg08->t000C = ebp_401;
		Mem506[dwArg08 + 0x10:word32] = ebp_401 + dwLocE4;
		dwArg08->b0014 = (byte) (word32) dwArg04->t000C;
		Eq_98940 dwLoc8C_1234 = ebx_381;
		int32 dwLocA0_1236 = 0x00;
		Eq_98988 dwLocA4_1238 = 0x01;
		byte cl_1134 = (byte) (ecx_302 - 0x20);
		while (true)
		{
			int32 edx_554 = SLICE(dwLocA4_1238 * 0x0A, word32, 32) + dwLocA0_1236 * 0x0A;
			uint32 ebx_549 = SLICE(dwLoc90_1199 * 0x0A, word32, 32) + dwLoc8C_1234 * 0x0A;
			uint32 eax_542 = (word32) (dwLoc90_1199 * 0x0A);
			byte cl_565 = (byte) ecx_302;
			Eq_98988 eax_583 = (word32) (dwLocA4_1238 * 0x0A);
			dwLocA0_1236 = edx_554;
			Eq_99144 ebx_574 = ebx_549 >> cl_1134 & eax_343 | (ebx_549 << (byte) ebx_319 & ecx_336 | eax_542 >> cl_565 & ebx_331);
			byte * edx_576 = dwArg08->ptr0000;
			Eq_98488 ebp_578 = dwArg08->t000C;
			if (ebp_578 >= dwArg08->t0004)
				break;
			Mem599[edx_576 + ebp_578:byte] = SLICE(ebx_574 + 0x30, byte, 0);
			dwArg08->t000C = (word32) dwArg08->t000C + 1;
			uint32 ebx_588 = ebx_574 << cl_565 & ebx_331;
			byte cl_617 = (byte) ecx_302;
			uint64 edx_eax_593 = ebx_357 * eax_583;
			int32 ebp_635 = esi_390 *s eax_583;
			Eq_98940 ebx_632 = SLICE(SEQ(ebx_549, eax_542) - SEQ(((ebx_574 >> 0x1F) << cl_617 & ebx_331 | ebx_574 >> (byte) ebx_319 & ecx_336) | ebx_574 << (byte) (ecx_302 - 0x20) & eax_343, ebx_588), word32, 32);
			Eq_98940 edx_641 = ebx_357 *s edx_554 + SLICE(edx_eax_593, word32, 32) + ebp_635;
			ui24 ebx_24_8_649 = SLICE(ebp_635, word24, 8);
			uint32 esi_590 = eax_542 - ebx_588;
			uint32 eax_654 = (word32) edx_eax_593;
			dwLocA4_1238 = eax_583;
			if ((byte) (SEQ(SLICE(esi_590, word24, 8), esi_590 < eax_654) & SEQ(ebx_24_8_649, ebx_632 == edx_641) | SEQ(ebx_24_8_649, ebx_632 < edx_641)) != 0x00)
			{
				uint64 edx_eax_707 = ebx_362 * eax_583;
				ui32 ebp_741 = 0x01 >> (byte) ebx_319 & ecx_336;
				strconv.adjustLastDigit(ebp_741, gs, dwArg08, SEQ(ebx_632, esi_590), (word32) edx_eax_707, SLICE(edx_eax_707, word32, 32) + ebx_398 *s eax_583 + ebx_362 *s edx_554, SEQ(edx_641, eax_654), SEQ(0x01 << (byte) (ecx_302 - 0x20) & eax_343 | ebp_741, 0x01 << cl_617 & ebx_331), SEQ(eax_583 >> 0x1F | edx_554 << 0x01, eax_583 << 0x01));
				return;
			}
			dwLoc8C_1234 = ebx_632;
			dwLoc90_1199 = esi_590;
			cl_1134 = (byte) (ecx_302 - 0x20);
		}
		runtime.panicindex(gs);
	}
}

// 08095FB0: void strconv.adjustLastDigit(Register ui32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_98447) dwArg04, Stack word64 qwArg08, Stack Eq_98938 dwArg10, Stack Eq_98959 dwArg14, Stack word64 qwArg18, Stack ui64 qwArg20, Stack ui64 qwArg28)
// Called from:
//      strconv.(*extFloat).ShortestDecimal
void strconv.adjustLastDigit(ui32 ebp, struct Eq_2 * gs, struct Eq_98447 * dwArg04, word64 qwArg08, Eq_98938 dwArg10, Eq_98959 dwArg14, word64 qwArg18, ui64 qwArg20, ui64 qwArg28)
{
	uint32 dwArg2C = SLICE(qwArg28, word32, 32);
	uint32 dwArg28 = (word32) qwArg28;
	uint32 dwArg24 = SLICE(qwArg20, word32, 32);
	uint32 dwArg20 = (word32) qwArg20;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 edx_23 = dwArg28 >> 0x1F | dwArg2C << 0x01;
	if ((byte) (SEQ(SLICE(edx_23, word24, 8), dwArg24 < edx_23) | SEQ(SLICE(dwArg28 << 0x01, word24, 8), dwArg20 < dwArg28 << 0x01) & SEQ(SLICE(ebp, word24, 8), dwArg24 == edx_23)) != 0x00)
		return;
	word64 qwArg08_404 = qwArg08;
	while (true)
	{
		uint32 dwArg08_328 = (word32) qwArg08_404;
		uint32 eax_67 = dwArg24 << 0x1F | dwArg20 >> 0x01;
		uint32 eax_71 = eax_67 + dwArg08_328;
		uint32 dwArg0C_333 = SLICE(qwArg08_404, word32, 32);
		uint64 ebp_eax_296 = SEQ((dwArg24 >> 0x01) + dwArg0C_333 + (eax_67 + dwArg08_328 < 0x00), eax_71) + qwArg28;
		word32 eax_86 = (word32) ebp_eax_296;
		Eq_98959 ebp_90 = SLICE(ebp_eax_296, word32, 32);
		Eq_98938 eax_74 = eax_71 + dwArg28;
		ui24 ebx_24_8_145 = SLICE(dwArg10, word24, 8);
		if ((byte) (SEQ(SLICE(eax_74, word24, 8), eax_74 < dwArg10) & SEQ(SLICE(eax_86, word24, 8), ebp_90 == dwArg14) | SEQ(SLICE(eax_86, word24, 8), ebp_90 < dwArg14)) == 0x00)
			break;
		byte * ecx_263 = dwArg04->ptr0000;
		Eq_98488 eax_265 = dwArg04->t000C;
		if (eax_265 - 0x01 >= dwArg04->t0004)
			runtime.panicindex(gs);
		Mem275[eax_265 - 0x01 + ecx_263:byte] = SLICE((word32) Mem78[eax_265 - 0x01 + ecx_263:byte] - 0x01, byte, 0);
		qwArg08_404 = SEQ(SLICE(qwArg08_404 + qwArg20, word32, 32), dwArg08_328 + dwArg20);
	}
	uint32 ebp_119 = (word32) dwArg10.u1 + eax_67;
	up32 ecx_127 = SLICE(qwArg20 + qwArg08_404, word32, 32);
	up32 edx_139 = SLICE(SEQ(SLICE(SEQ(dwArg14, eax_67) + SEQ(dwArg24 >> 0x01, dwArg10), word32, 32), ebp_119) + qwArg28, word32, 32);
	uint32 ebp_121 = ebp_119 + dwArg28;
	ui32 ebp_162 = SEQ(SLICE(ebp_121, word24, 8), dwArg08_328 + dwArg20 <= ebp_121) & SEQ(ebx_24_8_145, ecx_127 == edx_139) | SEQ(SLICE(ecx_127, word24, 8), ecx_127 < edx_139);
	ui24 edx_24_8_192 = SLICE(edx_139, word24, 8);
	if ((byte) ebp_162 != 0x00)
		return;
	ui24 ecx_24_8_230 = SLICE(dwArg0C_333, word24, 8);
	ui24 eax_24_8_222 = SLICE(dwArg2C, word24, 8);
	if ((byte) (SEQ(SLICE(ebp_162, word24, 8), dwArg08_328 < dwArg28) & SEQ(edx_24_8_192, dwArg0C_333 == dwArg2C) | SEQ(edx_24_8_192, dwArg0C_333 < dwArg2C)) != 0x00)
		return;
	ui64 ebp_edx_311 = qwArg18 - qwArg28;
	uint32 edx_211 = (word32) ebp_edx_311;
	uint32 ebp_215 = SLICE(ebp_edx_311, word32, 32);
	if ((byte) (SEQ(eax_24_8_222, dwArg0C_333 == ebp_215) & SEQ(SLICE(edx_211, word24, 8), dwArg08_328 > edx_211) | SEQ(ecx_24_8_230, dwArg0C_333 > ebp_215)) != 0x00)
		return;
	if (dwArg04->t000C != 0x01)
		return;
	byte * edx_242 = dwArg04->ptr0000;
	if (dwArg04->t0004 <= 0x00)
		runtime.panicindex(gs);
	else if ((byte) (word32) *edx_242 == 0x30)
	{
		dwArg04->t000C.u0 = 0x00;
		dwArg04->dw0010 = 0x00;
	}
}

// 080961D0: void strconv.AppendFloat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack real64 rArg10, Stack byte bArg18, Stack Eq_4 dwArg20)
// Called from:
//      fmt.(*fmt).fmt_float
void strconv.AppendFloat(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, real64 rArg10, byte bArg18, Eq_4 dwArg20)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.genericFtoa(gs, dwArg04, dwArg08, dwArg0C, (real64) (uint128) (uint64) rArg10, SEQ(nLoc17, (byte) (word32) bArg18), dwArg20);
}

// 08096250: void strconv.genericFtoa(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack real64 rArg10, Stack Eq_4 dwArg18, Stack Eq_4 dwArg20)
// Called from:
//      strconv.AppendFloat
void strconv.genericFtoa(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, real64 rArg10, Eq_4 dwArg18, Eq_4 dwArg20)
{
	byte bArg18 = (byte) dwArg18;
	while (fp - 0xAC <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_24555 * ecx_43;
	Eq_97131 edx_41;
	uint32 eax_42;
	if (dwArg20 == 0x20)
	{
		rLocE0.u1 = (real32) (uint128) (uint64) rArg10;
		edx_41 = rLocE0;
		eax_42 = 0x00;
		ecx_43 = &g_t8136118;
	}
	else
	{
		if (dwArg20 != 0x40)
			runtime.gopanic(gs);
		real64 rLocA4_853 = (real64) (uint128) (uint64) rArg10;
		edx_41 = (word32) rLocA4_853;
		eax_42 = SLICE(rLocA4_853, word32, 32);
		ecx_43 = &g_t8136128;
	}
	up32 ebx_59 = ecx_43->dw0000;
	up32 edx_75 = ecx_43->dw0004;
	up32 edx_79 = edx_75 + ebx_59;
	up32 ebp_77 = edx_75 - 0x20 + ebx_59;
	ui32 ebx_85 = 0x00 - (edx_79 < 0x20);
	up32 ebx_90 = -ebp_77;
	up32 ecx_141 = 0x20 - ebx_59;
	ui32 ebp_63 = 0x00 - (ebx_59 < 0x20);
	ui32 ebx_138 = 0x00 - (ebx_59 < 0x40);
	ui32 edx_154 = 0x00 - (ecx_141 < 0x20);
	uint32 edx_71 = 0x01 << (byte) ebx_59 & ebp_63;
	ui32 edx_190 = 0x01 >> (byte) ecx_141 & edx_154 | 0x01 << (byte) (ebx_59 - 0x20) & ebx_138;
	ui32 ebx_112 = 0x00 - (ebp_77 < 0x20) & eax_42 >> (byte) ebp_77 | (edx_41 >> (byte) edx_79 & ebx_85 | eax_42 << (byte) ebx_90 & 0x00 - (ebx_90 < 0x20));
	ui32 ebx_160 = edx_41 >> (byte) ebx_59 & ebp_63 | eax_42 << (byte) ecx_141 & edx_154 | eax_42 >> (byte) (ebx_59 - 0x20) & ebx_138;
	ui32 ebp_171 = 0x01 << (byte) edx_75 & 0x00 - (edx_75 < 0x20);
	ui32 edx_196 = edx_190 + ~0x00 + (edx_71 < ~0x00);
	byte al_236 = (byte) (SEQ(SLICE(ebx_112, word24, 8), (ebx_85 & eax_42 >> (byte) edx_79) != 0x00) | SEQ(SLICE(edx_79, word24, 8), ebx_112 != 0x00));
	Eq_4 edx_174 = ebp_171 - 0x01 & ebx_160;
	Eq_4 ebx_198 = eax_42 & edx_196;
	Eq_4 edi_201 = edx_41 & edx_71 + ~0x00;
	if (edx_174 == ebp_171 - 0x01)
	{
		Eq_4 ecx_766;
		Eq_4 eax_765;
		if ((byte) (SEQ(SLICE(edx_41, word24, 8), (edx_71 + ~0x00 & edx_41) != 0x00) | SEQ(SLICE(eax_42, word24, 8), (edx_196 & eax_42) != 0x00)) != 0x00)
		{
			eax_765.u0 = 0x03;
			ecx_766.u0 = 0x080E0E52;
		}
		else if (al_236 != 0x00)
		{
			eax_765.u0 = 0x04;
			ecx_766.u0 = 0x080E0EBE;
		}
		else
		{
			eax_765.u0 = 0x04;
			ecx_766.u0 = 0x080E0EB6;
		}
		Eq_4 esi_803;
		word32 ebx_775 = dwArg08 + eax_765;
		Eq_4 ebp_777 = dwArg0C;
		if (ebx_775 <= dwArg0C)
			esi_803 = dwArg04;
		else
		{
			word32 esi_1396;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, ebx_775, out esi_1396);
			ebp_777 = dwLoc0110;
			esi_803 = dwLoc0118;
		}
		if (ebx_775 > ebp_777)
			runtime.panicslice(gs);
		else
		{
			word32 esi_1398;
			word32 edi_1399;
			word32 ebp_1397;
			runtime.memmove(dwArg08 + esi_803, ecx_766, eax_765, out ebp_1397, out esi_1398, out edi_1399);
			return;
		}
	}
	Eq_4 edx_213;
	if ((ebx_160 & ebp_171 - 0x01) == 0x00)
		edx_213 = ebx_198;
	else
	{
		edi_201 |= edx_71;
		edx_213 = ebx_198 | edx_190;
	}
	Eq_4 bl_226 = (byte) (word32) bArg18;
	byte bArg18_1140 = (byte) dwArg18;
	if (bl_226 == 0x62)
	{
		strconv.fmtB(edx_174, ecx_43, gs, dwArg04, dwArg08, dwArg0C, al_236, edi_201, edx_213);
		return;
	}
	if ((byte) (word32) g_b8136001 == 0x00)
	{
		strconv.bigFtoa(gs, edi_201, edx_213);
		return;
	}
	byte al_415;
	fn0808FD8A(0x00, fp - 0x18);
	Eq_4 ecx_326 = dwArg18;
	Eq_4 edi_329 = edx_213;
	if (dwArg18 >= 0x00)
	{
		if (bl_226 == 0x66)
		{
			al_415 = 0x00;
			goto l080965AF;
		}
		Eq_4 ebp_533;
		bool Z_536;
		if (bl_226 <= 0x47)
		{
			if (bl_226 == 0x45)
			{
l080965A1:
				ebp_533 = (word32) dwArg18 + 1;
				goto l080965A4;
			}
			if (bl_226 == 0x47)
			{
				Z_536 = SLICE(cond(dwArg18), bool, 2);
l0809677B:
				if (!Z_536)
					ecx_326.u0 = 0x01;
				ebp_533 = ecx_326;
l080965A4:
				if (ebp_533 > 0x0F)
					al_415 = 0x00;
				else
				{
					fn0808FD8A(0x00, fp - 0x60);
					strconv.(*extFloat).FixedDecimal(ebp_533, fp - 0x20, gs, fp - 0x84, fp - 0x20, ebp_533);
					Eq_4 esp_604 = <invalid>;
					dwLoc0130 = fp - 0x20;
					al_415 = (byte) (word32) *((word32) esp_604 + 0x0C);
					bl_226 = (byte) (word32) *((word32) esp_604 + 0x0144);
					edi_329 = *((word32) esp_604 + 72);
				}
l080965AF:
				if (al_415 == 0x00)
				{
					strconv.bigFtoa(gs, edi_201, edi_329);
					return;
				}
				else
				{
					fn08090264(fp - 0x18, fp - 0x011C);
					strconv.formatDigits(gs, dwLoc0130, dwArg04, dwArg08, (byte) dwArg0C, SLICE(dwArg0C, byte, 8), dwLoc0114, dwLoc0110, dwLoc010C, dwArg18, bl_226);
					return;
				}
			}
		}
		else
		{
			if (bl_226 == 101)
				goto l080965A1;
			if (bl_226 == 0x67)
			{
				Z_536 = SLICE(cond(dwArg18), bool, 2);
				goto l0809677B;
			}
		}
		ebp_533 = dwArg18;
		goto l080965A4;
	}
	strconv.(*extFloat).AssignComputeBounds(gs, fp - 0x70, edi_201, edx_213, rLocE0, (byte) (word32) bLocF1, ecx_43);
	fn0808FD88(0x00, fp - 0x48);
	strconv.(*extFloat).ShortestDecimal(dwLoc0104, dwLoc0118, gs, dwLoc0138, fp - 116, fp - 0x20, fp - 0x94, fp - 0xA4);
	dwLoc0130 = fp - 0x20;
	al_415 = (byte) (word32) (byte) ecx_43;
	if (al_415 == 0x00)
	{
		strconv.bigFtoa(gs, edi_201, edx_213);
		return;
	}
	word32 ecx_460 = (word32) bArg18_1140;
	cu8 cl_461 = (byte) ecx_460;
	if (cl_461 <= 0x47)
	{
		if (cl_461 == 0x45)
		{
l080968E0:
			goto l080968EC;
		}
		if (cl_461 == 0x47)
			goto l0809690E;
	}
	else
	{
		if (cl_461 == 101)
			goto l080968E0;
		if (cl_461 == 0x66)
		{
l080968EC:
			bl_226 = (byte) ecx_460;
			edi_329 = edx_213;
			goto l080965AF;
		}
		if (cl_461 == 0x67)
		{
l0809690E:
			goto l080968EC;
		}
	}
	goto l080968EC;
}

// 08096B20: void strconv.bigFtoa(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      strconv.genericFtoa
void strconv.bigFtoa(struct Eq_2 * gs, Eq_4 dwArg18, Eq_4 dwArg1C)
{
	while (fp - 772 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 * edi_18 = fp - 0x0344;
	word32 ecx_19;
	for (ecx_19 = 0xCB; ecx_19 != 0x00; --ecx_19)
	{
		*edi_18 = 0x00;
		++edi_18;
	}
	Eq_4 edx_147;
	strconv.(*decimal).Assign(SLICE(dwArg18, word24, 8), dwArg1C, gs, dwLoc0388, fp - 0x0344, dwArg18);
	Eq_4 esp_37 = <invalid>;
	*((word32) esp_37 + 4) = *((word32) esp_37 + 932) - *(*((word32) esp_37 + 936));
	*esp_37 = (word32) esp_37 + 64;
	word32 esi_56;
	Eq_100020 ebx_24_8_83 = SLICE(strconv.(*decimal).Shift(gs, *esp_37, *((word32) esp_37 + 4), out esi_56), word24, 8);
	fn0808FD8A(0x00, (word32) esp_37 + 876);
	Eq_4 eax_171 = *((word32) esp_37 + 912);
	*((word32) esp_37 + 59) = eax_171 < 0x00;
	if (eax_171 >= 0x00)
	{
		bool Z_184;
		cu8 cl_149 = (byte) (word32) *((word32) esp_37 + 916);
		if (cl_149 <= 0x47)
		{
			if (cl_149 == 0x45)
			{
l08096BD2:
				*((word32) esp_37 - 4) = (word32) esp_37 + 60;
				*esp_37 = (word32) eax_171 + 1;
				strconv.(*decimal).Round(gs, *((word32) esp_37 - 4), *esp_37);
				eax_171 = *((word32) esp_37 + 912);
				goto l08096BEC;
			}
			if (cl_149 == 0x47)
			{
				Z_184 = SLICE(cond(eax_171), bool, 2);
				goto l08096CC8;
			}
		}
		else
		{
			if (cl_149 == 101)
				goto l08096BD2;
			if (cl_149 == 0x66)
			{
				Mem159[esp_37 + 0x00:word32] = Mem72[esp_37 + 0x0360:word32] + eax_171;
				*((word32) esp_37 - 4) = (word32) esp_37 + 60;
				strconv.(*decimal).Round(gs, *((word32) esp_37 - 4), *esp_37);
				eax_171 = *((word32) esp_37 + 912);
				goto l08096BEC;
			}
			if (cl_149 == 0x67)
			{
				Z_184 = SLICE(cond(eax_171), bool, 2);
l08096CC8:
				if (!Z_184)
					eax_171.u0 = 0x01;
				*((word32) esp_37 + 912) = eax_171;
				*((word32) esp_37 - 4) = (word32) esp_37 + 60;
				*esp_37 = eax_171;
				strconv.(*decimal).Round(gs, *((word32) esp_37 - 4), *esp_37);
				eax_171 = *((word32) esp_37 + 912);
l08096BEC:
				fn0808FD8A(0x00, (word32) esp_37 + 872);
				*((word32) esp_37 + 868) = (word32) esp_37 + 56;
				*((word32) esp_37 + 872) = 800;
				*((word32) esp_37 + 876) = 800;
				*((word32) esp_37 + 880) = *((word32) esp_37 + 856);
				*((word32) esp_37 + 884) = *((word32) esp_37 + 860);
				edx_147 = eax_171;
l08096C3F:
				*((word32) esp_37 - 8) = *((word32) esp_37 + 896);
				*((word32) esp_37 - 4) = *((word32) esp_37 + 900);
				*esp_37 = *((word32) esp_37 + 0x0388);
				*((word32) esp_37 + 4) = (byte) (word32) *((word32) esp_37 + 55);
				*((word32) esp_37 + 5) = (byte) (word32) *((word32) esp_37 + 913);
				fn08090264((word32) esp_37 + 868, (word32) esp_37 + 8);
				*((word32) esp_37 + 28) = edx_147;
				*((word32) esp_37 + 32) = (byte) (word32) *((word32) esp_37 + 908);
				strconv.formatDigits(gs, *((word32) esp_37 - 0x0C), *((word32) esp_37 - 8), *((word32) esp_37 - 4), *esp_37, *((word32) esp_37 + 1), *((word32) esp_37 + 16), *((word32) esp_37 + 20), *((word32) esp_37 + 24), *((word32) esp_37 + 28), *((word32) esp_37 + 32));
				return;
			}
		}
		goto l08096BEC;
	}
	Eq_4 eax_130;
	*((word32) esp_37 - 4) = (word32) esp_37 + 60;
	*esp_37 = *((word32) esp_37 + 920);
	*((word32) esp_37 + 4) = *((word32) esp_37 + 924);
	*((word32) esp_37 + 8) = *((word32) esp_37 + 928);
	*((word32) esp_37 + 0x0C) = *((word32) esp_37 + 932);
	strconv.roundShortest(ebx_24_8_83, esi_56, gs, *((word32) esp_37 - 4), *esp_37, *((word32) esp_37 + 4), *((word32) esp_37 + 8), *((word32) esp_37 + 0x0C));
	fn0808FD8A(0x00, (word32) esp_37 + 872);
	*((word32) esp_37 + 868) = (word32) esp_37 + 56;
	*((word32) esp_37 + 872) = 800;
	*((word32) esp_37 + 876) = 800;
	*((word32) esp_37 + 880) = *((word32) esp_37 + 856);
	word32 eax_110 = *((word32) esp_37 + 860);
	*((word32) esp_37 + 884) = eax_110;
	cu8 cl_113 = (byte) (word32) *((word32) esp_37 + 912);
	if (cl_113 <= 0x47)
	{
		if (cl_113 == 0x45)
		{
l08096DD0:
			eax_130 = *((word32) esp_37 + 880) - 0x01;
			goto l08096DD8;
		}
		if (cl_113 == 0x47)
			goto l08096DE4;
	}
	else
	{
		if (cl_113 == 101)
			goto l08096DD0;
		if (cl_113 == 0x66)
		{
			Eq_4 edx_123 = *((word32) esp_37 + 880) - eax_110;
			if (edx_123 <= 0x00)
				edx_123.u0 = 0x00;
			eax_130 = edx_123;
l08096DD8:
			edx_147 = eax_130;
			goto l08096C3F;
		}
		if (cl_113 == 0x67)
		{
l08096DE4:
			eax_130 = *((word32) esp_37 + 880);
			goto l08096DD8;
		}
	}
	eax_130 = *((word32) esp_37 + 908);
	goto l08096DD8;
}

// 08096E30: void strconv.formatDigits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 bArg10, Stack Eq_95910 bArg11, Stack Eq_4 dwArg20, Stack Eq_4 dwArg24, Stack Eq_4 dwArg28, Stack Eq_4 dwArg2C, Stack Eq_4 bArg30)
// Called from:
//      strconv.genericFtoa
//      strconv.bigFtoa
void strconv.formatDigits(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 bArg10, Eq_95910 bArg11, Eq_4 dwArg20, Eq_4 dwArg24, Eq_4 dwArg28, Eq_4 dwArg2C, Eq_4 bArg30)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 eax_101 = (word32) bArg30;
	cu8 al_19 = (byte) eax_101;
	if (al_19 <= 0x47)
	{
		if (al_19 == 0x45)
		{
l08096E60:
			fn08090264((word32) fp + 20, fp - 44);
			strconv.fmtE(gs, dwLoc40, dwArg04, dwArg08, (byte) dwArg0C, SEQ(nLoc2F, (byte) (word32) bArg11), dwLoc2C, dwLoc28, dwLoc24, dwLoc20, dwArg28, al_19);
			return;
		}
		if (al_19 == 0x47)
		{
l08096EBF:
			Eq_4 ecx_121 = dwArg20;
			if (dwArg2C <= dwArg20 || dwArg20 < dwArg24)
				ecx_121 = dwArg2C;
			Eq_4 ebx_171 = dwArg20;
			if ((byte) (word32) bArg10 != 0x00)
				ecx_121.u0 = 0x06;
			Eq_100441 SZO_239;
			if (dwArg24 < ~0x02)
				SZO_239.u0 = SLICE(cond(dwArg2C - dwArg20), bool, 4);
			else
			{
				if (dwArg24 - 0x01 < ecx_121)
				{
					if (dwArg2C <= dwArg24)
						ebx_171 = dwArg2C;
					Eq_4 ebx_176 = ebx_171 - dwArg24;
					if (ebx_176 <= 0x00)
						ebx_176.u0 = 0x00;
					fn08090264((word32) fp + 20, fp - 44);
					strconv.fmtF(gs, dwLoc40, dwArg04, dwArg08, (byte) dwArg0C, SEQ(nLoc2F, (byte) (word32) bArg11), dwLoc2C, dwLoc28, dwLoc24, dwLoc20, ebx_176);
					return;
				}
				SZO_239.u0 = SLICE(cond(dwArg2C - dwArg20), bool, 4);
			}
			if (SZO_239)
				ebx_171 = dwArg2C;
			fn08090264((word32) fp + 20, fp - 44);
			strconv.fmtE(gs, dwLoc40, dwArg04, dwArg08, (byte) dwArg0C, SEQ(nLoc2F, (byte) (word32) bArg11), dwLoc2C, dwLoc28, dwLoc24, dwLoc20, ebx_171 - 0x01, (byte) (eax_101 + ~0x01));
			return;
		}
	}
	else
	{
		if (al_19 == 101)
			goto l08096E60;
		if (al_19 == 0x66)
		{
			fn08090264((word32) fp + 20, fp - 44);
			strconv.fmtF(gs, dwLoc40, dwArg04, dwArg08, (byte) dwArg0C, SEQ(nLoc2F, (byte) (word32) bArg11), dwLoc2C, dwLoc28, dwLoc24, dwLoc20, dwArg28);
			return;
		}
		if (al_19 == 0x67)
			goto l08096EBF;
	}
	Eq_4 ebp_103;
	if ((word32) dwArg08 + 2 <= dwArg0C)
		ebp_103 = dwArg04;
	else
	{
		word32 esi_92;
		runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 2, out esi_92);
		ebp_103 = dwLoc28;
		eax_101 = (word32) bArg30;
	}
	Mem106[ebp_103 + dwArg08:byte] = 0x25;
	*((word32) dwArg08 + ((word32) ebp_103 + 1)) = (byte) eax_101;
}

// 080970B0: void strconv.roundShortest(Register Eq_100020 ebx, Register word32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 fArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      strconv.bigFtoa
void strconv.roundShortest(Eq_100020 ebx, word32 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 fArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp - 0x05F4 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (SEQ(SLICE(esi, word24, 8), dwArg0C == 0x00) & SEQ(ebx_24_8, dwArg08 == 0x00)) != 0x00)
	{
		((word32) dwArg04 + 800)->u0 = 0x00;
		return;
	}
	if (dwArg10 > (word32) (*((word32) dwArg14 + 8)) + 1 && (*((word32) dwArg04 + 804) - *((word32) dwArg04 + 800)) *s 332 >= (dwArg10 - *dwArg14) *s 100)
		return;
	Eq_4 edi_82 = (dwArg08 << 0x01) + 0x01;
	word32 * edi_502 = fp - 0x032C;
	word32 ecx_505;
	for (ecx_505 = 0xCB; ecx_505 != 0x00; --ecx_505)
	{
		*edi_502 = 0x00;
		++edi_502;
	}
	uint32 ebx_216;
	uint32 eax_219;
	Eq_4 ecx_218;
	strconv.(*decimal).Assign(SLICE(fp - 0x032C, word24, 8), edi_82, gs, dwLoc0678, fp - 0x032C, edi_82);
	Eq_4 esp_118 = <invalid>;
	*((word32) esp_118 + 4) = *((word32) esp_118 + 1668) - *(*((word32) esp_118 + 0x0688)) - 0x01;
	*esp_118 = (word32) esp_118 + 840;
	word32 esi_680;
	strconv.(*decimal).Shift(gs, *esp_118, *((word32) esp_118 + 4), out esi_680);
	up32 ecx_144 = **((word32) esp_118 + 0x0688);
	up32 ecx_169 = -(ecx_144 + ~0x1F);
	ui32 esi_181 = 0x00 - (ecx_169 < 0x20);
	uint32 ebp_151 = 0x00 - (ecx_144 < 0x20) & 0x01 << (byte) ecx_144;
	uint32 ebx_152 = *((word32) esp_118 + 1660);
	uint32 edx_183 = 0x01 >> (byte) ecx_169 & esi_181 | 0x00 - (ecx_144 < 0x40) & 0x01 << (byte) (ecx_144 + ~0x1F);
	uint32 ebx_184 = *((word32) esp_118 + 1664);
	if ((byte) (SEQ(SLICE(edx_183, word24, 8), ebx_184 > edx_183) | SEQ(SLICE(esi_181, word24, 8), ebx_184 == edx_183) & SEQ(SLICE(ebp_151, word24, 8), ebx_152 > ebp_151)) == 0x00)
	{
		Eq_4 ebp_208 = *((word32) esp_118 + 1668);
		if (*((word32) esp_118 + 0x0C) != ebp_208)
		{
			Eq_4 edx_211 = *((word32) esp_118 + 24);
			ebx_216 = (uint32) ((bool) (edx_211 < ~0x00) + ((word32) (*((word32) esp_118 + 20)) - 1));
			ecx_218 = ebp_208 - 0x01;
			eax_219 = (word32) edx_211 - 1;
l0809723A:
			*((word32) esp_118 + 16) = ecx_218;
			uint32 eax_235 = eax_219 << 0x01;
			*((word32) esp_118 + 24) = eax_235 + 0x01;
			word32 * edi_239 = (word32) esp_118 + 28;
			word32 ecx_240;
			for (ecx_240 = 0xCB; ecx_240 != 0x00; --ecx_240)
			{
				*edi_239 = 0x00;
				++edi_239;
			}
			*esp_118 = (word32) esp_118 + 28;
			*((word32) esp_118 + 4) = *((word32) esp_118 + 24);
			ui32 ebx_251 = ebx_216 << 0x01;
			*((word32) esp_118 + 8) = (eax_219 >> 0x1F | ebx_251) + (eax_235 < 0x01);
			strconv.(*decimal).Assign(SLICE(ebx_251, word24, 8), eax_235 + 0x01, gs, *((word32) esp_118 - 4), *esp_118, *((word32) esp_118 + 4));
			word32 esi_288;
			strconv.(*decimal).Shift(gs, fp - 0x0658, dwLoc0664 - *dwArg14 - 0x01, out esi_288);
			byte dl_512 = (byte) (SEQ(SLICE(dwArg08, word24, 8), (dwArg08 & 0x01) == 0x00) & 0x01);
			Eq_4 eax_301;
			for (eax_301 = 0x00; eax_301 < *((word32) dwArg04 + 800); ++eax_301)
			{
				word32 esi_317;
				if (eax_301 < dwLoc0338)
				{
					if (eax_301 >= 800)
						runtime.panicindex(gs);
					esi_317 = (word32) Mem281[eax_301 + (fp - 0x0658):byte];
				}
				else
					esi_317 = 0x30;
				if (eax_301 >= 800)
					runtime.panicindex(gs);
				word32 ebx_334;
				word32 edi_329 = (word32) Mem281[eax_301 + dwArg04:byte];
				if (eax_301 < dwLoc0C)
					ebx_334 = (word32) Mem281[eax_301 + (fp - 0x032C):byte];
				else
					ebx_334 = 0x30;
				Eq_100866 cl_372;
				cu8 bl_380 = (byte) ebx_334;
				word24 ebx_24_8_554 = SLICE(ebx_334, word24, 8);
				if ((byte) esi_317 != (byte) edi_329)
					cl_372.u1 = 0x01;
				else if (dl_512 != 0x00)
					cl_372 = dwLoc0338 == eax_301 + 0x01;
				else
					cl_372.u1 = 0x00;
				uip32 ebx_675;
				if (bl_380 != (byte) edi_329)
				{
					if (dl_512 != 0x00)
						ebx_675 = 0x01;
					else if ((byte) (edi_329 + 0x01) < bl_380)
						ebx_675 = 0x01;
					else
						ebx_675 = SEQ(ebx_24_8_554, eax_301 + 0x01 < dwLoc0C);
				}
				else
					ebx_675 = 0x00;
				byte bl_419 = (byte) ebx_675;
				bool Z_418 = SLICE(cond(cl_372), bool, 2);
				if (cl_372 != 0x00)
				{
					if (bl_419 != 0x00)
					{
						strconv.(*decimal).Round(gs, dwArg04, eax_301 + 0x01);
						return;
					}
					Z_418 = SLICE(cond(cl_372), bool, 2);
				}
				if (Z_418)
				{
					strconv.(*decimal).RoundDown(gs, dwArg04, eax_301 + 0x01);
					return;
				}
				if (bl_419 != 0x00)
				{
					strconv.(*decimal).RoundUp(gs, dwArg04, eax_301 + 0x01);
					return;
				}
			}
			return;
		}
	}
	eax_219 = ebx_152 + ~0x00;
	ebx_216 = (uint32) ((bool) (ebx_152 < ~0x00) + (ebx_184 + ~0x00));
	ecx_218 = *((word32) esp_118 + 1668);
	goto l0809723A;
}

// 08097470: void strconv.fmtE(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10, Stack (ptr32 byte) dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C, Stack Eq_4 dwArg20, Stack Eq_4 dwArg24, Stack Eq_4 dwArg2C, Stack cu8 bArg30)
// Called from:
//      strconv.formatDigits
void strconv.fmtE(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10, byte * dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C, Eq_4 dwArg20, Eq_4 dwArg24, Eq_4 dwArg2C, cu8 bArg30)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_111;
	Eq_4 eax_109;
	Eq_4 edx_24;
	if ((byte) (word32) bArg10 != 0x00)
	{
		edx_24 = (word32) dwArg08 + 1;
		ebx_111 = dwArg0C;
		if ((word32) dwArg08 + 1 <= dwArg0C)
			eax_109 = dwArg04;
		else
		{
			word32 esi_894;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi_894);
			eax_109 = dwLoc2C;
			ebx_111 = dwLoc24;
			edx_24 = dwLoc28 + 0x01;
		}
		Mem56[eax_109 + dwArg08:byte] = 0x2D;
	}
	else
	{
		ebx_111 = dwArg0C;
		eax_109 = dwArg04;
		edx_24 = dwArg08;
	}
	byte cl_115;
	if (dwArg20 != 0x00)
	{
		if (dwArg18 <= 0x00)
			runtime.panicindex(gs);
		cl_115 = (byte) (word32) *dwArg14;
	}
	else
		cl_115 = 0x30;
	Eq_4 ebp_112 = (word32) edx_24 + 1;
	if (ebp_112 > ebx_111)
	{
		word32 esi_895;
		runtime.growslice(gs, 0x080CF320, eax_109, edx_24, ebx_111, ebp_112, out esi_895);
		eax_109 = dwLoc2C;
		ebx_111 = dwLoc24;
		ebp_112 = dwLoc28 + 0x01;
		cl_115 = (byte) (word32) cl_115;
	}
	Eq_4 edx_125;
	Mem119[eax_109 + edx_24:byte] = cl_115;
	if (dwArg2C <= 0x00)
	{
		edx_125 = ebp_112;
		goto l0809756D;
	}
	edx_125 = (word32) ebp_112 + 1;
	if (edx_125 > ebx_111)
	{
		word32 esi_896;
		runtime.growslice(gs, 0x080CF320, eax_109, ebp_112, ebx_111, edx_125, out esi_896);
		eax_109 = dwLoc2C;
		ebx_111 = dwLoc24;
		edx_125 = dwLoc28 + 0x01;
	}
	Mem157[eax_109 + ebp_112:byte] = 0x2E;
	Eq_4 ecx_160 = dwArg2C;
	Eq_4 ebp_159 = dwArg20;
	if (dwArg20 >= (word32) dwArg2C + 1)
		ebp_159 = (word32) dwArg2C + 1;
	Eq_4 ebp_252;
	if (ebp_159 > 0x01)
	{
		if (ebp_159 <= dwArg1C)
		{
			word32 ecx_177 = ebp_159 - 0x01 + edx_125;
			Eq_4 ebx_188 = ebx_111;
			Eq_4 esi_191 = dwArg14 + (0x01 - dwArg1C >> 0x1F & 0x01);
			if (ecx_177 > ebx_111)
			{
				word32 esi_898;
				runtime.growslice(gs, 0x080CF320, eax_109, edx_125, ebx_111, ecx_177, out esi_898);
				eax_109 = dwLoc2C;
				ebx_188 = dwLoc24;
			}
			if (ecx_177 <= ebx_188)
			{
				word32 edi_901;
				word32 esi_900;
				word32 ebp_899;
				runtime.memmove(eax_109 + edx_125, esi_191, ebp_159 - 0x01, out ebp_899, out esi_900, out edi_901);
				ecx_160 = dwArg2C;
				ebp_252 = ebp_159;
				ebx_111 = ebx_188;
				edx_125 = ecx_177;
l0809751F:
				while (ebp_252 <= ecx_160)
				{
					Eq_4 esi_596 = (word32) edx_125 + 1;
					if (esi_596 > ebx_111)
					{
						word32 esi_897;
						runtime.growslice(gs, 0x080CF320, eax_109, edx_125, ebx_111, esi_596, out esi_897);
						eax_109 = dwLoc2C;
						ebx_111 = dwLoc24;
						esi_596 = dwLoc28 + 0x01;
						ecx_160 = dwArg2C;
					}
					Mem627[eax_109 + edx_125:byte] = 0x30;
					ebp_252 = (byte) ebp_252.u0 + 1;
					edx_125 = esi_596;
				}
l0809756D:
				Eq_4 ecx_263 = (word32) edx_125 + 1;
				if (ecx_263 > ebx_111)
				{
					word32 esi_902;
					runtime.growslice(gs, 0x080CF320, eax_109, edx_125, ebx_111, ecx_263, out esi_902);
					eax_109 = dwLoc2C;
					ebx_111 = dwLoc24;
					ecx_263 = dwLoc28 + 0x01;
				}
				Mem310[eax_109 + edx_125:byte] = SLICE((word32) bArg30, byte, 0);
				Eq_4 ebx_312 = ebx_111;
				int32 edx_314 = dwArg24 - 0x01;
				if (dwArg20 == 0x00)
					edx_314 = 0x00;
				word32 ebp_326;
				if (edx_314 < 0x00)
				{
					edx_314 = -edx_314;
					ebp_326 = 0x2D;
				}
				else
					ebp_326 = 0x2B;
				Eq_4 esi_338 = (word32) ecx_263 + 1;
				if (esi_338 > ebx_111)
				{
					word32 esi_903;
					runtime.growslice(gs, 0x080CF320, eax_109, ecx_263, ebx_111, esi_338, out esi_903);
					eax_109 = dwLoc2C;
					ebx_312 = dwLoc24;
					esi_338 = dwLoc28 + 0x01;
					ebp_326 = (word32) (byte) ebp_326;
				}
				Mem393[eax_109 + ecx_263:byte] = SLICE(ebp_326, byte, 0);
				if (edx_314 < 0x0A)
				{
					Eq_4 ecx_544 = (word32) esi_338 + 2;
					if (ecx_544 > ebx_312)
					{
						word32 esi_904;
						runtime.growslice(gs, 0x080CF320, eax_109, esi_338, ebx_312, ecx_544, out esi_904);
						eax_109 = dwLoc2C;
					}
					Mem573[eax_109 + esi_338:byte] = 0x30;
					*((word32) esi_338 + ((word32) eax_109 + 1)) = (byte) (edx_314 + 0x30);
				}
				else if (edx_314 < 100)
				{
					int32 edx_500 = (SLICE(edx_314 *s ~0x33333332, word32, 32) + edx_314 >> 0x03) - (edx_314 >> 0x1F);
					Eq_4 ecx_489 = (word32) esi_338 + 2;
					Eq_4 ebp_490 = eax_109;
					int32 eax_503 = edx_314 - edx_500 * 0x0A;
					if (ecx_489 > ebx_312)
					{
						word32 esi_905;
						runtime.growslice(gs, 0x080CF320, eax_109, esi_338, ebx_312, ecx_489, out esi_905);
						ebp_490 = dwLoc2C;
					}
					Mem538[ebp_490 + esi_338:byte] = SLICE(edx_500 + 0x30, byte, 0);
					*((word32) esi_338 + ((word32) ebp_490 + 1)) = (byte) (eax_503 + 0x30);
				}
				else
				{
					int32 edx_422 = (SLICE(edx_314 *s ~0x33333332, word32, 32) + edx_314 >> 0x03) - (edx_314 >> 0x1F);
					int32 edx_430 = edx_422 - ((word32) ((byte) edx_422) *s 0x019A >> 0x0C) * 0x0A;
					Eq_4 ecx_402 = (word32) esi_338 + 3;
					Eq_4 ebp_403 = eax_109;
					int32 edx_413 = (SLICE(edx_314 *s 1374389535, word32, 32) >> 0x05) - (edx_314 >> 0x1F);
					byte dl_436 = (byte) edx_430;
					int32 edi_433 = edx_314 - edx_422 * 0x0A;
					if (ecx_402 > ebx_312)
					{
						word32 esi_906;
						runtime.growslice(gs, 0x080CF320, eax_109, esi_338, ebx_312, ecx_402, out esi_906);
						ebp_403 = dwLoc2C;
						edx_430 = (word32) dl_436;
					}
					Mem476[ebp_403 + esi_338:byte] = SLICE(edx_413 + 0x30, byte, 0);
					*((word32) esi_338 + ((word32) ebp_403 + 1)) = (byte) (edx_430 + 0x30);
					*((word32) esi_338 + ((word32) ebp_403 + 2)) = (byte) (edi_433 + 0x30);
				}
				return;
			}
		}
		runtime.panicslice(gs);
	}
	else
	{
		ebp_252.u0 = 0x01;
		goto l0809751F;
	}
}

// 080979A0: void strconv.fmtF(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C, Stack Eq_4 dwArg20, Stack Eq_4 dwArg24, Stack Eq_4 dwArg2C)
// Called from:
//      strconv.formatDigits
void strconv.fmtF(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10, Eq_4 dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C, Eq_4 dwArg20, Eq_4 dwArg24, Eq_4 dwArg2C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_109;
	Eq_4 ebx_108;
	Eq_4 ecx_23;
	if ((byte) (word32) bArg10 != 0x00)
	{
		ecx_23 = (word32) dwArg08 + 1;
		edx_109 = dwArg0C;
		if ((word32) dwArg08 + 1 <= dwArg0C)
			ebx_108 = dwArg04;
		else
		{
			word32 esi_43;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi_43);
			ebx_108 = dwLoc2C;
			edx_109 = dwLoc24;
			ecx_23 = dwLoc28 + 0x01;
		}
		Mem56[ebx_108 + dwArg08:byte] = 0x2D;
	}
	else
	{
		ebx_108 = dwArg04;
		ecx_23 = dwArg08;
		edx_109 = dwArg0C;
	}
	Eq_4 eax_154;
	if (dwArg24 > 0x00)
	{
		Eq_4 ebp_65 = dwArg20;
		if (dwArg20 >= dwArg24)
			ebp_65 = dwArg24;
		if (ebp_65 <= dwArg1C)
		{
			word32 esi_78 = ebp_65 + ecx_23;
			if (esi_78 > edx_109)
			{
				word32 esi_589;
				runtime.growslice(gs, 0x080CF320, ebx_108, ecx_23, edx_109, esi_78, out esi_589);
				ebx_108 = dwLoc2C;
				edx_109 = dwLoc24;
			}
			if (esi_78 <= edx_109)
			{
				word32 edi_133;
				word32 esi_134;
				word32 ebp_590;
				runtime.memmove(ecx_23 + ebx_108, dwArg14, ebp_65, out ebp_590, out esi_134, out edi_133);
				Eq_4 eax_143;
				Eq_4 ecx_144 = esi_78;
				for (eax_143 = ebp_65; eax_143 < dwArg24; ++eax_143)
				{
					word32 ebp_155 = ecx_144 + 0x01;
					if (ebp_155 > edx_109)
					{
						word32 esi_591;
						runtime.growslice(gs, 0x080CF320, ebx_108, ecx_144, edx_109, ebp_155, out esi_591);
						ebx_108 = dwLoc2C;
						edx_109 = dwLoc24;
						ebp_155 = dwLoc28 + 0x01;
					}
					Mem188[ebx_108 + ecx_144:byte] = 0x30;
					ecx_144 = ebp_155;
				}
				eax_154 = ecx_144;
l08097A00:
				if (dwArg2C > 0x00)
				{
					Eq_4 ebp_232 = (word32) eax_154 + 1;
					if (ebp_232 > edx_109)
					{
						word32 esi_253;
						runtime.growslice(gs, 0x080CF320, ebx_108, eax_154, edx_109, ebp_232, out esi_253);
						ebx_108 = dwLoc2C;
						edx_109 = dwLoc24;
						ebp_232 = dwLoc28 + 0x01;
					}
					Mem266[ebx_108 + eax_154:byte] = 0x2E;
					Eq_4 eax_267 = 0x00;
					while (eax_267 < dwArg2C)
					{
						byte cl_312;
						word32 esi_289 = dwArg24 + eax_267;
						if (esi_289 >= 0x00)
						{
							if (esi_289 < dwArg20)
							{
								if (esi_289 >= dwArg18)
									runtime.panicindex(gs);
								cl_312 = SLICE((word32) Mem287[dwArg14 + esi_289:byte], byte, 0);
							}
							else
								cl_312 = 0x30;
						}
						else
							cl_312 = 0x30;
						Eq_4 esi_305 = (word32) ebp_232 + 1;
						if (esi_305 > edx_109)
						{
							word32 esi_588;
							runtime.growslice(gs, 0x080CF320, ebx_108, ebp_232, edx_109, esi_305, out esi_588);
							ebx_108 = dwLoc2C;
							edx_109 = dwLoc24;
							esi_305 = dwLoc28 + 0x01;
							cl_312 = (byte) (word32) cl_312;
						}
						Mem348[ebx_108 + ebp_232:byte] = cl_312;
						eax_267 = (word32) eax_267 + 1;
						ebp_232 = esi_305;
					}
				}
				return;
			}
		}
		runtime.panicslice(gs);
	}
	else
	{
		eax_154 = (word32) ecx_23 + 1;
		if (eax_154 > edx_109)
		{
			word32 esi_209;
			runtime.growslice(gs, 0x080CF320, ebx_108, ecx_23, edx_109, eax_154, out esi_209);
			ebx_108 = dwLoc2C;
			edx_109 = dwLoc24;
			eax_154 = dwLoc28 + 0x01;
		}
		Mem222[ebx_108 + ecx_23:byte] = 0x30;
		goto l08097A00;
	}
}

// 08097CB0: void strconv.fmtB(Register Eq_4 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      strconv.genericFtoa
void strconv.fmtB(Eq_4 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_24;
	Eq_4 ecx_23;
	Eq_4 ebx_22;
	if ((byte) (word32) bArg10 != 0x00)
	{
		ecx_23 = (word32) dwArg08 + 1;
		edx_24 = dwArg0C;
		if ((word32) dwArg08 + 1 <= dwArg0C)
			ebx_22 = dwArg04;
		else
		{
			ebp = runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi);
			ebx_22 = dwLoc20;
			edx_24 = dwLoc18;
			ecx_23 = dwLoc1C + 0x01;
		}
		Mem56[ebx_22 + dwArg08:byte] = 0x2D;
	}
	else
	{
		ebx_22 = dwArg04;
		ecx_23 = dwArg08;
		edx_24 = dwArg0C;
	}
	struct Eq_24555 * esi_114 = strconv.formatBits(ebp, esi, gs, dwLoc38, ebx_22, ecx_23, SEQ(dwArg14, edx_24), dwArg18, 0x0A);
	Eq_4 esp_90 = <invalid>;
	Eq_4 ecx_123 = *((word32) esp_90 + 32);
	Eq_4 eax_119 = *((word32) esp_90 + 28);
	Eq_4 edx_121 = *((word32) esp_90 + 36);
	Eq_4 ebx_122 = (word32) ecx_123 + 1;
	if ((word32) ecx_123 + 1 > edx_121)
	{
		*((word32) esp_90 + 60) = ecx_123;
		esp_90->u0 = 0x080CF320;
		*((word32) esp_90 + 4) = eax_119;
		*((word32) esp_90 + 8) = ecx_123;
		*((word32) esp_90 + 0x0C) = edx_121;
		*((word32) esp_90 + 16) = (word32) ecx_123 + 1;
		runtime.growslice(gs, *esp_90, *((word32) esp_90 + 4), *((word32) esp_90 + 8), *((word32) esp_90 + 0x0C), *((word32) esp_90 + 16), out esi_114);
		eax_119 = *((word32) esp_90 + 20);
		edx_121 = *((word32) esp_90 + 28);
		ebx_122 = (word32) *((word32) esp_90 + 24) + 1;
		ecx_123 = *((word32) esp_90 + 60);
	}
	Eq_4 ecx_136;
	Mem126[eax_119 + ecx_123:byte] = 0x70;
	Eq_4 ebp_131 = *((word32) esp_90 + 80) - *(*((word32) esp_90 + 84));
	if (ebp_131 >= 0x00)
	{
		ecx_136 = (word32) ebx_122 + 1;
		if (ecx_136 > edx_121)
		{
			*((word32) esp_90 + 48) = ebx_122;
			*((word32) esp_90 + 80) = ebp_131;
			esp_90->u0 = 0x080CF320;
			*((word32) esp_90 + 4) = eax_119;
			*((word32) esp_90 + 8) = ebx_122;
			*((word32) esp_90 + 0x0C) = edx_121;
			*((word32) esp_90 + 16) = ecx_136;
			runtime.growslice(gs, *esp_90, *((word32) esp_90 + 4), *((word32) esp_90 + 8), *((word32) esp_90 + 0x0C), *((word32) esp_90 + 16), out esi_114);
			eax_119 = *((word32) esp_90 + 20);
			edx_121 = *((word32) esp_90 + 28);
			ecx_136 = (word32) *((word32) esp_90 + 24) + 1;
			ebx_122 = *((word32) esp_90 + 48);
			ebp_131 = *((word32) esp_90 + 80);
		}
		Mem170[eax_119 + ebx_122:byte] = 0x2B;
	}
	else
		ecx_136 = ebx_122;
	*esp_90 = eax_119;
	*((word32) esp_90 + 4) = ecx_136;
	*((word32) esp_90 + 8) = edx_121;
	*((word32) esp_90 + 0x0C) = ebp_131;
	Eq_4 ebp_185 = ebp_131 >> 0x1F;
	*((word32) esp_90 + 16) = ebp_185;
	((word32) esp_90 + 20)->u0 = 0x0A;
	*((word32) esp_90 + 24) = ebp_131 < 0x00;
	*((word32) esp_90 + 25) = 0x01;
	strconv.formatBits(ebp_185, esi_114, gs, *((word32) esp_90 - 4), *esp_90, *((word32) esp_90 + 4), *((word32) esp_90 + 8), *((word32) esp_90 + 16), *((word32) esp_90 + 20));
}

// 08097E80: void strconv.FormatInt(Register Eq_101632 ebx, Register word32 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack Eq_101636 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      strconv.Itoa
void strconv.FormatInt(Eq_101632 ebx, word32 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, Eq_101636 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		word24 ecx_24_8_27 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	word24 ebx_24_8_38 = SLICE(ebp, word24, 8);
	ui32 ecx_28 = SEQ(ecx_24_8_27, dwArg08 == 0x00);
	Eq_4 ebx_39 = SEQ(ebx_24_8_38, dwArg08 > 0x00);
	ui32 ebx_42 = SEQ(ebx_24_8, Test(UGE,false)) & ecx_28 | ebx_39;
	Eq_4 ebp_108 = ebx_39;
	ui24 ebx_24_8_53 = SLICE(ebx_42, word24, 8);
	if ((byte) ebx_42 != 0x00)
	{
		Eq_4 ebx_64 = SEQ(ebx_24_8_38, dwArg08 < 0x00);
		ebp_108 = ebx_64;
		if ((byte) (SEQ(ebx_24_8_53, dwArg04 < 100) & ecx_28 | ebx_64) != 0x00 && dwArg0C == 0x0A)
		{
			uint32 ecx_137 = (dwArg04 << 0x01) + 0x02;
			if ((word32) (dwArg04 < 0x0A) + dwArg04 * 0x02 <= ecx_137 && ecx_137 <= 200)
				return;
			runtime.panicslice(gs);
		}
	}
	strconv.formatBits(ebp_108, esi, gs, dwLoc34, 0x00, 0x00, SEQ(dwArg04, 0x00), dwArg08, dwArg0C);
}

// 08097FA0: void strconv.Itoa(Register Eq_101714 ebx, Register word32 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack Eq_101636 dwArg04)
// Called from:
//      reflect.Kind.String
//      reflect.ChanDir.String
void strconv.Itoa(Eq_101714 ebx, word32 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, Eq_101636 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.FormatInt(ebx_24_8, ebp, esi, gs, dwArg04, dwArg04 >> 0x1F, 0x0A);
}

// 08097FF0: Register (ptr32 Eq_24555) strconv.formatBits(Register Eq_4 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 qwArg0C, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      strconv.fmtB
//      strconv.FormatInt
struct Eq_24555 * strconv.formatBits(Eq_4 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 qwArg0C, Eq_4 dwArg14, Eq_4 dwArg18)
{
	byte bArg19_782 = SLICE(dwArg18, byte, 8);
	Eq_4 dwArg10 = SLICE(qwArg0C, word32, 32);
	Eq_4 dwArg0C = (word32) qwArg0C;
	byte bArg18_742 = (byte) dwArg18;
	while (fp - 0x1C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg18 > 0x24)
		runtime.gopanic(gs);
	Eq_4 edx_170;
	Eq_4 eax_171;
	word32 ecx_45 = (word32) bArg18_742;
	ptr32 edi_162 = fn0808FD80(0x00, fp - 0x44);
	byte cl_251 = (byte) ecx_45;
	ui24 ecx_24_8_718 = SLICE(ecx_45, word24, 8);
	if (cl_251 != 0x00)
	{
		ui64 edx_eax_736 = 0x00 - qwArg0C;
		eax_171 = (word32) edx_eax_736;
		edx_170 = SLICE(edx_eax_736, word32, 32);
	}
	else
	{
		edx_170 = dwArg10;
		eax_171 = dwArg0C;
	}
	byte * eax_255;
	bool Z_421;
	if (dwArg14 == 0x0A)
	{
		Eq_4 ebx_322 = 0x41;
		while (true)
		{
			ui24 ebx_24_8_333 = SLICE(ebp, word24, 8);
			byte cl_729 = (byte) ecx_45;
			Eq_4 ebx_363 = ebx_322;
			Eq_4 eax_373 = eax_171;
			if ((byte) (SEQ(ebx_24_8_333, edx_170 > 0x00) | SEQ(SLICE(esi, word24, 8), edx_170 == 0x00) & SEQ(ebx_24_8_333, eax_171 >= 1000000000)) == 0x00)
				break;
			runtime.uint64div(gs, eax_171, edx_170, 1000000000, 0x00);
			uint32 edx_635 = eax_171 - (word32) (dwLoc90 * 1000000000);
			Eq_4 ebx_639 = ebx_322;
			int32 ebp_640;
			for (ebp_640 = 0x04; ebp_640 > 0x00; --ebp_640)
			{
				uint32 edx_669 = SLICE((edx_635 >> 0x01) * 2748779070, word32, 32);
				uint32 esi_673 = edx_635 - (edx_669 >> 0x05) *s 100;
				if (esi_673 << 0x01 >= ~0xC6)
				{
l080986D5:
					runtime.panicindex(gs);
				}
				word32 ebp_682 = (word32) g_a80E7A42[esi_673];
				if (ebx_639 >= 66)
					goto l080986D5;
				Mem691[ebx_639 - 0x01 + (fp - 0x49):byte] = SLICE(ebp_682, byte, 0);
				if (esi_673 << 0x01 >= 200)
				{
l080986CE:
					runtime.panicindex(gs);
				}
				Eq_4 ebp_697 = ebx_639 - (byte *) 0x02;
				byte dl_702 = (byte) (word32) g_a80E7A41[esi_673];
				if (ebp_697 >= 0x41)
					goto l080986CE;
				Mem703[fp - 0x4B + ebx_639:byte] = dl_702;
				ebx_639 = ebp_697;
				edx_635 = edx_669 >> 0x05;
			}
			struct Eq_101864 * edx_645 = edx_635 << 0x01;
			if (edx_645 >= (struct Eq_101864 *) 199)
			{
l080986C7:
				runtime.panicindex(gs);
			}
			ebp = ebx_639 - 0x01;
			esi = (struct Eq_24555 *) g_a80E7A41;
			byte dl_658 = (byte) (word32) edx_645->b80E7A42;
			if (ebp >= 0x41)
				goto l080986C7;
			Mem660[fp - 0x4A + ebx_639:byte] = dl_658;
			ecx_45 = (word32) bArg18_742;
			eax_171 = dwLoc90;
			edx_170 = dwLoc8C;
			ebx_322 = ebp;
		}
		while (eax_373 >= 100)
		{
			uint32 edx_570 = SLICE((eax_373 >> 0x01) * 2748779070, word32, 32);
			uint32 esi_574 = eax_373 - (edx_570 >> 0x05) *s 100;
			if (esi_574 << 0x01 >= ~0xC6)
			{
l080986C0:
				runtime.panicindex(gs);
			}
			word32 edi_586 = (word32) g_a80E7A42[esi_574];
			if (ebx_363 >= 66)
				goto l080986C0;
			Mem595[ebx_363 - 0x01 + (fp - 0x49):byte] = SLICE(edi_586, byte, 0);
			if (esi_574 << 0x01 >= 200)
			{
l080986B9:
				runtime.panicindex(gs);
			}
			Eq_4 esi_601 = ebx_363 - (byte *) 0x02;
			byte dl_606 = (byte) (word32) g_a80E7A41[esi_574];
			if (esi_601 >= 0x41)
				goto l080986B9;
			Mem607[fp - 0x4B + ebx_363:byte] = dl_606;
			eax_373 = edx_570 >> 0x05;
			ebx_363 = esi_601;
		}
		struct Eq_102142 * eax_379 = eax_373 << 0x01;
		if (eax_379 < (struct Eq_102142 *) 199)
		{
			byte * ebp_384 = ebx_363 - 0x01;
			word32 edi_387 = (word32) eax_379->b80E7A42;
			if (ebp_384 < (byte *) 0x41)
			{
				Mem399[ebx_363 - 0x01 + (fp - 0x49):byte] = SLICE(edi_387, byte, 0);
				if (eax_373 < 0x0A)
				{
					Z_421 = SLICE(cond(cl_729), bool, 2);
					eax_255 = ebp_384;
					goto l080982A1;
				}
				if (eax_379 < (struct Eq_102142 *) 200)
				{
					eax_255 = ebx_363 - (byte *) 0x02;
					byte dl_417 = (byte) (word32) g_a80E7A41[eax_373];
					if (eax_255 < (byte *) 0x41)
					{
						Mem418[ebx_363 - 0x02 + (fp - 0x49):byte] = dl_417;
						Z_421 = SLICE(cond(cl_729), bool, 2);
						goto l080982A1;
					}
				}
				runtime.panicindex(gs);
			}
		}
		runtime.panicindex(gs);
	}
	if (dwArg14 >= 0x25)
		runtime.panicindex(gs);
	byte * ebx_136;
	up32 ebp_69 = g_a8138AA0[dwArg14 * 0x04];
	if (ebp_69 <= 0x00)
	{
		byte * esi_119 = (byte *) 0x41;
		while (true)
		{
			ui24 ebx_24_8_90 = SLICE(edi_162, word24, 8);
			if ((byte) (SEQ(ecx_24_8_718, edx_170 == dwArg14 >> 0x1F) & SEQ(ebx_24_8_90, eax_171 >= dwArg14) | SEQ(ebx_24_8_90, edx_170 > dwArg14 >> 0x1F)) == 0x00)
				break;
			runtime.uint64div(gs, eax_171, edx_170, dwArg14, dwArg14 >> 0x1F);
			struct Eq_102117 * edx_156 = eax_171 - (word32) (dwLoc90 * dwArg14);
			if (edx_156 >= (struct Eq_102117 *) 0x24)
			{
l0809868F:
				runtime.panicindex(gs);
			}
			--esi_119;
			edi_162 = 0x080E5D28;
			byte dl_166 = (byte) (word32) edx_156->b80E5D28;
			if (esi_119 >= (byte *) 66)
				goto l0809868F;
			Mem167[fp - 0x4A + esi_119:byte] = dl_166;
			edx_170 = dwLoc8C;
			eax_171 = dwLoc90;
			ecx_24_8_718 = SLICE((word32) bArg18_742, word24, 8);
		}
		if (eax_171 < 0x24)
		{
			byte * ecx_120 = esi_119 - (byte *) 0x01;
			byte al_130 = (byte) (word32) *((word32) eax_171 + 135159080);
			if (ecx_120 < (byte *) 0x41)
			{
				Mem131[esi_119 - 0x01 + (fp - 0x49):byte] = al_130;
				Z_421 = SLICE(cond((byte) (word32) bArg18_742), bool, 2);
				ebx_136 = ecx_120;
l08098583:
				eax_255 = ebx_136;
l080982A1:
				byte * ecx_428;
				if (!Z_421)
				{
					ecx_428 = eax_255 - 0x01;
					if (ecx_428 >= (byte *) 0x41)
						runtime.panicindex(gs);
					Mem436[fp - 0x4A + eax_255:byte] = 0x2D;
				}
				else
					ecx_428 = eax_255;
				if ((byte) (word32) bArg19_782 == 0x00)
				{
					if (ecx_428 > (byte *) 0x41)
						runtime.panicslice(gs);
					else
					{
						Eq_4 eax_452 = 0x41 - ecx_428;
						return runtime.slicebytetostring(gs, 0x00, fp - 0x49 + (ecx_428 & -eax_452 >> 0x1F), eax_452);
					}
				}
				else
				{
					if (ecx_428 <= (byte *) 0x41)
					{
						Eq_4 esi_519;
						Eq_4 ebx_491 = 0x41 - ecx_428;
						up32 eax_487 = dwArg04 - ecx_428;
						byte * ecx_495 = ecx_428 & -ebx_491 >> 0x1F;
						Eq_4 ebx_496 = dwArg08;
						if (eax_487 + 0x41 <= dwArg08)
							esi_519 = dwArg00;
						else
						{
							word32 esi_927;
							runtime.growslice(gs, 0x080CF320, dwArg00, dwArg04, dwArg08, eax_487 + 0x41, out esi_927);
							esi_519 = dwLoc8C;
							ebx_496 = dwLoc84;
						}
						if (dwArg04 - ecx_428 + 0x41 <= ebx_496)
						{
							struct Eq_24555 * esi_546;
							word32 edi_929;
							word32 ebp_928;
							runtime.memmove(esi_519 + dwArg04, fp - 0x49 + ecx_495, ebx_491, out ebp_928, out esi_546, out edi_929);
							return esi_546;
						}
					}
					runtime.panicslice(gs);
				}
			}
		}
		runtime.panicindex(gs);
	}
	else
	{
		byte * dwLoc6C_766 = (byte *) 0x41;
		Eq_4 eax_185 = eax_171;
		while (true)
		{
			ui24 ebx_24_8_196 = SLICE(ebp_69, word24, 8);
			if ((byte) (SEQ(ebx_24_8_196, edx_170 > dwArg14 >> 0x1F) | SEQ(SLICE(dwArg14, word24, 8), eax_185 >= dwArg14) & SEQ(ebx_24_8_196, edx_170 == dwArg14 >> 0x1F)) == 0x00)
				break;
			struct Eq_101928 * eax_258 = eax_185 & dwArg14 - 0x01;
			if (eax_258 >= (struct Eq_101928 *) 0x24)
			{
l0809869D:
				runtime.panicindex(gs);
			}
			byte al_269 = (byte) (word32) eax_258->b80E5D28;
			if (dwLoc6C_766 >= (byte *) 66)
				goto l0809869D;
			Mem270[fp - 0x4A + dwLoc6C_766:byte] = al_269;
			ui32 esi_304 = 0x00 - (ebp_69 < 0x20);
			up32 ebx_287 = 0x20 - ebp_69;
			dwLoc6C_766 -= (byte *) 0x01;
			cl_251 = (byte) (word32) bArg18_742;
			edx_170 = edx_170 >> (byte) ebp_69 & esi_304;
			eax_185 = edx_170 << (byte) ebx_287 & 0x00 - (ebx_287 < 0x20) | eax_185 >> (byte) ebp_69 & esi_304 | edx_170 >> (byte) (ebp_69 - 0x20) & 0x00 - (ebp_69 < 0x40);
		}
		if (eax_185 < 0x24)
		{
			ebx_136 = dwLoc6C_766 - (byte *) 0x01;
			byte al_249 = (byte) (word32) *((word32) eax_185 + 135159080);
			if (dwLoc6C_766 < (byte *) 66)
			{
				Mem250[dwLoc6C_766 - 0x01 + (fp - 0x49):byte] = al_249;
				Z_421 = SLICE(cond(cl_251), bool, 2);
				goto l08098583;
			}
		}
		runtime.panicindex(gs);
	}
}

// 08098700: void strconv.appendQuotedWith(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_95591) dwArg10, Stack Eq_4 dwArg14, Stack byte bArg18, Stack byte bArg19, Stack byte bArg1A)
// Called from:
//      strconv.AppendQuote
//      strconv.AppendQuoteToASCII
void strconv.appendQuotedWith(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_95591 * dwArg10, Eq_4 dwArg14, byte bArg18, byte bArg19, byte bArg1A)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_105;
	Eq_4 ecx_18 = (word32) dwArg08 + 1;
	Eq_4 edx_19 = dwArg0C;
	if ((word32) dwArg08 + 1 <= dwArg0C)
		ebx_105 = dwArg04;
	else
	{
		word32 esi_568;
		runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi_568);
		dwLoc34 = dwArg08;
		dwLoc30 = dwArg0C;
		ebx_105 = dwLoc28;
		edx_19 = dwLoc20;
		ecx_18 = (word32) dwLoc24 + 1;
	}
	word32 ebp_48 = (word32) bArg18;
	Mem56[ebx_105 + dwArg08:byte] = SLICE(ebp_48, byte, 0);
	word32 ebp_144 = ebp_48;
	Eq_4 ecx_202 = ecx_18;
	struct Eq_95591 * eax_118 = dwArg10;
	Eq_4 esi_377 = dwArg14;
	while (esi_377 > 0x00)
	{
		Eq_4 dwLoc18_433;
		Eq_4 edi_121 = (word32) eax_118->b0000;
		if (edi_121 < 0x80)
			dwLoc18_433.u0 = 0x01;
		else
		{
			unicode/utf8.DecodeRuneInString(gs, eax_118, esi_377);
			edi_121 = dwLoc34;
			ebp_144 = (word32) bArg18;
			dwLoc18_433 = dwLoc30;
		}
		Eq_4 esi_204;
		Eq_4 edi_203;
		Eq_4 edx_168 = edx_19;
		Eq_4 ebx_161 = ebx_105;
		if (dwLoc18_433 == 0x01 && edi_121 == 0xFFFD)
		{
			Eq_4 edi_207 = (word32) ecx_202 + 2;
			if (edi_207 > edx_19)
			{
				word32 esi_569;
				runtime.growslice(gs, 0x080CF320, ebx_105, ecx_202, edx_19, edi_207, out esi_569);
				dwLoc30 = edx_19;
				edx_168 = dwLoc20;
				ebx_161 = dwLoc28;
			}
			if (edi_207 > edx_168)
				runtime.panicslice(gs);
			word32 esi_571;
			word32 edi_572;
			word32 ebp_570;
			runtime.memmove(ebx_161 + ecx_202, 0x080E0E0B, 0x02, out ebp_570, out esi_571, out edi_572);
			dwLoc34.u0 = 0x02;
			struct Eq_102380 * ecx_265 = (word32) ((byte) (word32) eax_118->b0000 >> 0x04);
			if (ecx_265 >= (struct Eq_102380 *) 0x10)
				runtime.panicindex(gs);
			Eq_4 ebx_269 = (word32) ecx_202 + 3;
			byte cl_275 = (byte) (word32) ecx_265->b80E2469;
			esi_204 = edx_168;
			if ((word32) ecx_202 + 3 <= edx_168)
				edi_203 = ebx_161;
			else
			{
				word32 esi_573;
				runtime.growslice(gs, 0x080CF320, ebx_161, edi_207, edx_168, (word32) ecx_202 + 3, out esi_573);
				dwLoc34 = edi_207;
				dwLoc30 = edx_168;
				edi_203 = dwLoc28;
				esi_204 = dwLoc20;
				ebx_269 = (word32) dwLoc24 + 1;
				cl_275 = (byte) (word32) cl_275;
			}
			*((word32) edi_203 + ((word32) ecx_202 + 2)) = cl_275;
			ecx_202 = (word32) ebx_269 + 1;
			byte dl_322 = (byte) (word32) ((word32) eax_118->b0000 & 0x0F)->b80E2469;
			if (ecx_202 > esi_204)
			{
				word32 esi_574;
				runtime.growslice(gs, 0x080CF320, edi_203, ebx_269, esi_204, ecx_202, out esi_574);
				dwLoc34 = ebx_269;
				dwLoc30 = esi_204;
				edi_203 = dwLoc28;
				esi_204 = dwLoc20;
				ecx_202 = (word32) dwLoc24 + 1;
				dl_322 = (byte) (word32) dl_322;
			}
			Mem354[edi_203 + ebx_269:byte] = dl_322;
		}
		else
		{
			strconv.appendEscapedRune(gs, ebx_105, ecx_202, edx_19, edi_121, (byte) ebp_144, (byte) (word32) bArg19, (byte) (word32) bArg1A);
			dwLoc34 = edx_19;
			dwLoc30 = edi_121;
			ecx_202 = dwLoc24;
			edi_203 = dwLoc28;
			esi_204 = dwLoc20;
		}
		if (dwLoc18_433 > esi_377)
			runtime.panicslice(gs);
		Eq_4 ebx_362 = esi_377 - dwLoc18_433;
		eax_118 += (dwLoc18_433 & -ebx_362 >> 0x1F) / 4;
		ebp_144 = (word32) bArg18;
		ebx_105 = edi_203;
		edx_19 = esi_204;
		esi_377 = ebx_362;
	}
	Eq_4 eax_68 = (word32) ecx_202 + 1;
	if (eax_68 > edx_19)
	{
		word32 esi_86;
		runtime.growslice(gs, 0x080CF320, ebx_105, ecx_202, edx_19, eax_68, out esi_86);
		ebx_105 = dwLoc28;
		ebp_144 = (word32) bArg18;
	}
	Mem107[ebx_105 + ecx_202:byte] = SLICE(ebp_144, byte, 0);
}

// 08098A60: void strconv.appendQuotedRuneWith(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack byte bArg14, Stack byte bArg15, Stack byte bArg16)
// Called from:
//      strconv.AppendQuoteRune
//      strconv.AppendQuoteRuneToASCII
void strconv.appendQuotedRuneWith(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, byte bArg14, byte bArg15, byte bArg16)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_40;
	Eq_4 ecx_18 = (word32) dwArg08 + 1;
	Eq_4 edx_19 = dwArg0C;
	if ((word32) dwArg08 + 1 <= dwArg0C)
		ebx_40 = dwArg04;
	else
	{
		word32 esi_221;
		runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi_221);
		ebx_40 = dwLoc0C;
		edx_19 = dwLoc04;
		ecx_18 = (word32) dwLoc08 + 1;
	}
	word32 ebp_48 = (word32) bArg14;
	Mem56[ebx_40 + dwArg08:byte] = SLICE(ebp_48, byte, 0);
	Eq_4 eax_60 = dwArg10;
	if (dwArg10 >= 0xD800 && dwArg10 > 1114111)
		eax_60.u0 = 0xFFFD;
	strconv.appendEscapedRune(gs, ebx_40, ecx_18, edx_19, eax_60, (byte) ebp_48, (byte) (word32) bArg15, (byte) (word32) bArg16);
	if ((word32) dwLoc08 + 1 > dwLoc04)
	{
		word32 esi_123;
		runtime.growslice(gs, 0x080CF320, dwLoc0C, dwLoc08, dwLoc04, (word32) dwLoc08 + 1, out esi_123);
	}
	Mem144[dwLoc0C + dwLoc08:byte] = SLICE((word32) bArg14, byte, 0);
}

// 08098BA0: void strconv.appendEscapedRune(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack byte bArg14, Stack byte bArg15, Stack byte bArg16)
// Called from:
//      strconv.appendQuotedWith
//      strconv.appendQuotedRuneWith
void strconv.appendEscapedRune(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, byte bArg14, byte bArg15, byte bArg16)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((word32) (byte) (word32) bArg14 == dwArg10 || dwArg10 == 0x5C)
	{
		Eq_4 ebp_101;
		word32 edx_29 = dwArg08 + 0x01;
		Eq_4 ebx_30 = dwArg0C;
		if (dwArg08 + 0x01 <= dwArg0C)
			ebp_101 = dwArg04;
		else
		{
			word32 esi_47;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x01, out esi_47);
			ebp_101 = dwLoc28;
			ebx_30 = dwLoc20;
			edx_29 = dwLoc24 + 0x01;
		}
		Mem61[ebp_101 + dwArg08:byte] = 0x5C;
		Eq_4 eax_63 = (word32) edx_29 + 1;
		if (eax_63 > ebx_30)
		{
			word32 esi_82;
			runtime.growslice(gs, 0x080CF320, ebp_101, edx_29, ebx_30, eax_63, out esi_82);
			ebp_101 = dwLoc28;
		}
		Mem103[ebp_101 + edx_29:byte] = SLICE(dwArg10, byte, 0);
		return;
	}
	if ((byte) (word32) bArg15 != 0x00)
	{
		if (dwArg10 < 0x80)
		{
			strconv.IsPrint(gs, dwArg10);
			if ((byte) (word32) bLoc38 != 0x00)
			{
				Eq_4 ebx_288;
				if (dwArg08 + 0x01 <= dwArg0C)
					ebx_288 = dwArg04;
				else
				{
					word32 esi_283;
					runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x01, out esi_283);
					ebx_288 = dwLoc28;
				}
				Mem304[ebx_288 + dwArg08:byte] = SLICE(dwArg10, byte, 0);
				return;
			}
		}
		goto l08098BF7;
	}
	strconv.IsPrint(gs, dwArg10);
	if ((byte) (word32) bLoc38 == 0x00)
	{
		if ((byte) (word32) bArg16 == 0x00)
		{
l08098BF7:
			if (dwArg10 <= 0x09)
			{
				if (dwArg10 == 0x07)
				{
					Eq_4 ebx_592;
					Eq_4 edx_571 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_592 = dwArg04;
					else
					{
						word32 esi_1612;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1612);
						ebx_592 = dwLoc28;
						edx_571 = dwLoc20;
					}
					if (dwArg08 + 0x02 >u edx_571)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_1613;
						word32 edi_1615;
						word32 esi_1614;
						runtime.memmove(dwArg08 + ebx_592, 135138811, 0x02, out ebp_1613, out esi_1614, out edi_1615);
						return;
					}
				}
				if (dwArg10 == 0x08)
				{
					Eq_4 ebx_654;
					Eq_4 edx_632 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_654 = dwArg04;
					else
					{
						word32 esi_1608;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1608);
						edx_632 = dwLoc20;
						ebx_654 = dwLoc28;
					}
					if (dwArg08 + 0x02 >u edx_632)
						runtime.panicslice(gs);
					else
					{
						word32 esi_1610;
						word32 edi_1611;
						word32 ebp_1609;
						runtime.memmove(dwArg08 + ebx_654, 135138813, 0x02, out ebp_1609, out esi_1610, out edi_1611);
						return;
					}
				}
				if (dwArg10 == 0x09)
				{
					Eq_4 ebx_714;
					Eq_4 edx_693 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_714 = dwArg04;
					else
					{
						word32 esi_1598;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1598);
						ebx_714 = dwLoc28;
						edx_693 = dwLoc20;
					}
					if (dwArg08 + 0x02 >u edx_693)
						runtime.panicslice(gs);
					else
					{
						word32 edi_736;
						word32 esi_737;
						word32 ebp_740;
						runtime.memmove(dwArg08 + ebx_714, 0x080E0E05, 0x02, out ebp_740, out esi_737, out edi_736);
						return;
					}
				}
			}
			else
			{
				if (dwArg10 <= 11)
				{
					if (dwArg10 != 0x0A)
					{
						Eq_4 ebx_350;
						Eq_4 edx_327 = dwArg0C;
						if (dwArg08 + 0x02 <=u dwArg0C)
							ebx_350 = dwArg04;
						else
						{
							word32 esi_1624;
							runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1624);
							ebx_350 = dwLoc28;
							edx_327 = dwLoc20;
						}
						if (dwArg08 + 0x02 >u edx_327)
							runtime.panicslice(gs);
						else
						{
							word32 ebp_1625;
							word32 edi_1627;
							word32 esi_1626;
							runtime.memmove(dwArg08 + ebx_350, 0x080E0E09, 0x02, out ebp_1625, out esi_1626, out edi_1627);
							return;
						}
					}
					else
					{
						Eq_4 ebx_409;
						Eq_4 edx_388 = dwArg0C;
						if (dwArg08 + 0x02 <=u dwArg0C)
							ebx_409 = dwArg04;
						else
						{
							word32 esi_1620;
							runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1620);
							ebx_409 = dwLoc28;
							edx_388 = dwLoc20;
						}
						if (dwArg08 + 0x02 >u edx_388)
							runtime.panicslice(gs);
						else
						{
							word32 ebp_1621;
							word32 esi_1622;
							word32 edi_1623;
							runtime.memmove(dwArg08 + ebx_409, 0x080E0E01, 0x02, out ebp_1621, out esi_1622, out edi_1623);
							return;
						}
					}
				}
				if (dwArg10 == 0x0C)
				{
					Eq_4 ebx_470;
					Eq_4 edx_449 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_470 = dwArg04;
					else
					{
						word32 esi_1628;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1628);
						ebx_470 = dwLoc28;
						edx_449 = dwLoc20;
					}
					if (dwArg08 + 0x02 >u edx_449)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_1629;
						word32 edi_1631;
						word32 esi_1630;
						runtime.memmove(dwArg08 + ebx_470, 135138815, 0x02, out ebp_1629, out esi_1630, out edi_1631);
						return;
					}
				}
				if (dwArg10 == 0x0D)
				{
					Eq_4 ebx_531;
					Eq_4 edx_510 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_531 = dwArg04;
					else
					{
						word32 esi_1616;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1616);
						ebx_531 = dwLoc28;
						edx_510 = dwLoc20;
					}
					if (dwArg08 + 0x02 >u edx_510)
						runtime.panicslice(gs);
					else
					{
						word32 edi_1619;
						word32 esi_1618;
						word32 ebp_1617;
						runtime.memmove(dwArg08 + ebx_531, 0x080E0E03, 0x02, out ebp_1617, out esi_1618, out edi_1619);
						return;
					}
				}
			}
			if (dwArg10 < 0x20)
			{
				Eq_4 ebp_779;
				Eq_4 ebx_757 = dwArg0C;
				if (dwArg08 + 0x02 <=u dwArg0C)
					ebp_779 = dwArg04;
				else
				{
					word32 esi_1601;
					runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1601);
					ebp_779 = dwLoc28;
					ebx_757 = dwLoc20;
				}
				if (dwArg08 + 0x02 >u ebx_757)
					runtime.panicslice(gs);
				else
				{
					word32 ebp_1602;
					word32 esi_1603;
					word32 edi_1604;
					runtime.memmove(dwArg08 + ebp_779, 0x080E0E0B, 0x02, out ebp_1602, out esi_1603, out edi_1604);
					struct Eq_102781 * eax_815 = (word32) ((byte) dwArg10 >> 0x04);
					if (eax_815 >= (struct Eq_102781 *) 0x10)
						runtime.panicindex(gs);
					else
					{
						Eq_4 edi_846;
						word32 ebx_819 = dwArg08 + 0x03;
						byte al_825 = (byte) (word32) eax_815->b80E2469;
						Eq_4 esi_822 = ebx_757;
						if (dwArg08 + 0x03 <= ebx_757)
							edi_846 = ebp_779;
						else
						{
							word32 esi_1605;
							runtime.growslice(gs, 0x080CF320, ebp_779, dwArg08 + 0x02, ebx_757, dwArg08 + 0x03, out esi_1605);
							edi_846 = dwLoc28;
							esi_822 = dwLoc20;
							ebx_819 = dwLoc24 + 0x01;
							al_825 = (byte) (word32) al_825;
						}
						Mem859[dwArg08 + 0x02 + edi_846:byte] = al_825;
						word32 eax_861 = ebx_819 + 0x01;
						byte cl_871 = (byte) (word32) (dwArg10 & 0x0F)->b80E2469;
						if (eax_861 > esi_822)
						{
							word32 esi_1606;
							runtime.growslice(gs, 0x080CF320, edi_846, ebx_819, esi_822, eax_861, out esi_1606);
							edi_846 = dwLoc28;
							cl_871 = (byte) (word32) cl_871;
						}
						Mem902[edi_846 + ebx_819:byte] = cl_871;
						return;
					}
				}
			}
			else
			{
				Eq_4 eax_1047;
				if (dwArg10 > 1114111)
					eax_1047.u0 = 0xFFFD;
				else
				{
					if (dwArg10 >= 0x00010000)
					{
						Eq_4 ebp_936;
						Eq_4 ebx_915 = dwArg0C;
						if (dwArg08 + 0x02 <=u dwArg0C)
							ebp_936 = dwArg04;
						else
						{
							word32 esi_1600;
							runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1600);
							ebp_936 = dwLoc28;
							ebx_915 = dwLoc20;
						}
						if (dwArg08 + 0x02 >u ebx_915)
							runtime.panicslice(gs);
						else
						{
							word32 edi_959;
							word32 esi_960;
							word32 ebp_963;
							runtime.memmove(dwArg08 + ebp_936, 0x080E0DF9, 0x02, out ebp_963, out esi_960, out edi_959);
							Eq_102754 eax_1042;
							Eq_4 ecx_1044 = ebx_915;
							Eq_4 edx_1010 = ebp_936;
							word32 ebx_1046 = dwArg08 + 0x02;
							for (eax_1042 = 0x1C; eax_1042 >= 0x00; eax_1042 -= 0x04)
							{
								word32 ebp_1030 = ebx_1046 + 0x01;
								Eq_4 edi_1029 = ecx_1044;
								byte al_1006 = (byte) (word32) (dwArg10 >> (byte) (~(0x00 - (eax_1042 < 0x20)) | eax_1042) & 0x0F)->b80E2469;
								if (ebp_1030 > ecx_1044)
								{
									word32 esi_1607;
									runtime.growslice(gs, 0x080CF320, edx_1010, ebx_1046, ecx_1044, ebp_1030, out esi_1607);
									edx_1010 = dwLoc28;
									edi_1029 = dwLoc20;
									ebp_1030 = dwLoc24 + 0x01;
									al_1006 = (byte) (word32) al_1006;
								}
								Mem1039[edx_1010 + ebx_1046:byte] = al_1006;
								ecx_1044 = edi_1029;
								ebx_1046 = ebp_1030;
							}
							return;
						}
					}
					eax_1047 = dwArg10;
				}
				Eq_4 ebp_1077;
				Eq_4 ebx_1055 = dwArg0C;
				if (dwArg08 + 0x02 <=u dwArg0C)
					ebp_1077 = dwArg04;
				else
				{
					word32 esi_1597;
					runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1597);
					ebp_1077 = dwLoc28;
					ebx_1055 = dwLoc20;
				}
				if (dwArg08 + 0x02 >u ebx_1055)
					runtime.panicslice(gs);
				else
				{
					word32 edi_1099;
					word32 esi_1100;
					word32 ebp_1103;
					runtime.memmove(dwArg08 + ebp_1077, 0x080E0E07, 0x02, out ebp_1103, out esi_1100, out edi_1099);
					Eq_102649 eax_1109;
					Eq_4 ecx_1110 = ebx_1055;
					Eq_4 edx_1111 = ebp_1077;
					word32 ebx_1112 = dwArg08 + 0x02;
					for (eax_1109 = 0x0C; eax_1109 >= 0x00; eax_1109 -= 0x04)
					{
						Eq_4 ebp_1132 = (word32) ebx_1112 + 1;
						Eq_4 edi_1144 = ecx_1110;
						byte al_1156 = (byte) (word32) (eax_1047 >> (byte) (~(0x00 - (eax_1109 < 0x20)) | eax_1109) & 0x0F)->b80E2469;
						if (ebp_1132 > ecx_1110)
						{
							word32 esi_1599;
							runtime.growslice(gs, 0x080CF320, edx_1111, ebx_1112, ecx_1110, ebp_1132, out esi_1599);
							edx_1111 = dwLoc28;
							edi_1144 = dwLoc20;
							ebp_1132 = dwLoc24 + 0x01;
							al_1156 = (byte) (word32) al_1156;
						}
						Mem1189[edx_1111 + ebx_1112:byte] = al_1156;
						ecx_1110 = edi_1144;
						ebx_1112 = ebp_1132;
					}
					return;
				}
			}
		}
		strconv.isInGraphicList(gs, dwArg10);
		if ((byte) (word32) bLoc38 == 0x00)
			goto l0809948A;
	}
	unicode/utf8.EncodeRune(gs, fp - 0x10, 0x04, dwArg10);
	if (dwLoc2C <= 0x04)
	{
		Eq_4 ebp_201;
		word32 edx_176 = dwArg08 + dwLoc2C;
		Eq_4 ebx_178 = dwArg0C;
		if (edx_176 <= dwArg0C)
			ebp_201 = dwArg04;
		else
		{
			word32 esi_1632;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, edx_176, out esi_1632);
			ebx_178 = dwLoc20;
			ebp_201 = dwLoc28;
		}
		if (edx_176 <= ebx_178)
		{
			word32 edi_1635;
			word32 esi_1634;
			word32 ebp_1633;
			runtime.memmove(dwArg08 + ebp_201, fp - 0x10, dwLoc2C, out ebp_1633, out esi_1634, out edi_1635);
			return;
		}
	}
	runtime.panicslice(gs);
}

// subject_text_0005.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text_0005.h"

// 08099680: void strconv.AppendQuote(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_95591) dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*fmt).fmt_q
void strconv.AppendQuote(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_95591 * dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.appendQuotedWith(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, 0x22, 0x00, 0x00);
}

// 080996F0: void strconv.AppendQuoteToASCII(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_95591) dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*fmt).fmt_q
void strconv.AppendQuoteToASCII(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_95591 * dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.appendQuotedWith(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, 0x22, 0x01, 0x00);
}

// 08099760: void strconv.AppendQuoteRune(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*fmt).fmt_qc
void strconv.AppendQuoteRune(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.appendQuotedRuneWith(gs, dwArg04, dwArg08, dwArg0C, dwArg10, 0x27, 0x00, 0x00);
}

// 080997D0: void strconv.AppendQuoteRuneToASCII(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*fmt).fmt_qc
void strconv.AppendQuoteRuneToASCII(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.appendQuotedRuneWith(gs, dwArg04, dwArg08, dwArg0C, dwArg10, 0x27, 0x01, 0x00);
}

// 08099840: void strconv.CanBackquote(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_95591) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*fmt).fmt_q
void strconv.CanBackquote(struct Eq_2 * gs, struct Eq_95591 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_95591 * eax_18 = dwArg04;
	Eq_4 ecx_19 = dwArg08;
	while (ecx_19 > 0x00)
	{
		unicode/utf8.DecodeRuneInString(gs, eax_18, ecx_19);
		if (dwLoc04 > ecx_19)
			runtime.panicslice(gs);
		Eq_4 edx_49 = ecx_19 - dwLoc04;
		struct Eq_95591 * edx_55 = eax_18 + (-edx_49 >> 0x1F & dwLoc04) / 4;
		if (dwLoc04 > 0x01)
		{
			if (dwLoc08 == 0xFEFF)
				return;
		}
		else
		{
			if (dwLoc08 == 0xFFFD)
				return;
			if (dwLoc08 < 0x20 && dwLoc08 != 0x09 || (dwLoc08 == 0x60 || dwLoc08 == 0x7F))
				return;
		}
		eax_18 = edx_55;
		ecx_19 = edx_49;
	}
}

// 08099900: Register (ptr32 (arr word16)) strconv.bsearch16(Register (ptr32 Eq_2) gs, Stack (arr word16) dwArg04, Stack Eq_103241 dwArg08, Stack cup16 wArg10)
// Called from:
//      strconv.IsPrint
//      strconv.isInGraphicList
word16 (* strconv.bsearch16)[](struct Eq_2 * gs, word16 dwArg04[], Eq_103241 dwArg08, cup16 wArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cup16 ax_63 = (word16) (word32) wArg10;
	Eq_103241 edx_18 = dwArg08;
	Eq_103241 ebp_20 = 0x00;
	while (ebp_20 < edx_18)
	{
		int32 edx_30 = edx_18 - ebp_20;
		Eq_103264 edx_34 = (edx_30 >> 0x1F >> 0x1F) + edx_30;
		Eq_103241 esi_29 = edx_18;
		Eq_103241 edi_36 = (word32) ebp_20.u0 + (edx_34 >> 0x01);
		if (edi_36 >= dwArg08)
			runtime.panicindex(gs);
		Eq_103241 ecx_49;
		if ((word16) (word32) dwArg04[edi_36] < ax_63)
			ecx_49 = (word32) ebp_20.u0 + ((edx_34 >> 0x01) + 0x01);
		else
		{
			esi_29 = edi_36;
			ecx_49 = ebp_20;
		}
		edi = dwArg04;
		ebp_20 = ecx_49;
		edx_18 = esi_29;
	}
	return edi;
}

// 08099980: Register (ptr32 (arr Eq_4)) strconv.bsearch32(Register (ptr32 Eq_2) gs, Stack (arr Eq_4) dwArg04, Stack Eq_103241 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      strconv.IsPrint
Eq_4 (* strconv.bsearch32)[](struct Eq_2 * gs, Eq_4 dwArg04[], Eq_103241 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_103241 edx_18 = dwArg08;
	Eq_103241 ebp_20 = 0x00;
	while (ebp_20 < edx_18)
	{
		int32 edx_30 = edx_18 - ebp_20;
		Eq_103312 edx_34 = (edx_30 >> 0x1F >> 0x1F) + edx_30;
		Eq_103241 esi_29 = edx_18;
		Eq_103241 edi_36 = (word32) ebp_20.u0 + (edx_34 >> 0x01);
		if (edi_36 >= dwArg08)
			runtime.panicindex(gs);
		Eq_103241 ecx_48;
		if (dwArg04[edi_36] < dwArg10)
			ecx_48 = (word32) ebp_20.u0 + ((edx_34 >> 0x01) + 0x01);
		else
		{
			esi_29 = edi_36;
			ecx_48 = ebp_20;
		}
		edi = dwArg04;
		ebp_20 = ecx_48;
		edx_18 = esi_29;
	}
	return edi;
}

// 080999F0: Register word32 strconv.IsPrint(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      strconv.appendEscapedRune
//      fmt.(*fmt).fmt_unicode
word32 strconv.IsPrint(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cup16 ax_131 = (word16) dwArg04;
	if (dwArg04 > 0xFF)
	{
		if (dwArg04 >= 0x00010000)
		{
			Eq_103241 ecx_22 = g_t8142754;
			Eq_4 edx_24[] = g_ptr8142750;
			Eq_103241 ebp_27 = g_t8142734;
			word16 (* esi_29)[] = g_ptr8142730;
			word32 edi_42 = strconv.bsearch32(gs, edx_24, ecx_22, dwArg04);
			if (dwLoc2C >= ecx_22)
				return edi_42;
			if ((dwLoc2C & ~0x01) < ecx_22)
			{
				if (dwArg04 < edx_24[dwLoc2C & ~0x01])
					return edi_42;
				if ((dwLoc2C | 0x01) < ecx_22)
				{
					if (edx_24[dwLoc2C | 0x01] < dwArg04)
						return edi_42;
					if (dwArg04 >= 0x00020000)
						return edi_42;
					word32 edi_87 = strconv.bsearch16(gs, esi_29, ebp_27, (word16) ((word32) dwArg04 - 0x00010000));
					if (dwLoc2C >= ebp_27 || dwLoc2C < ebp_27)
						return edi_87;
					runtime.panicindex(gs);
				}
			}
			runtime.panicindex(gs);
		}
		else
		{
			Eq_103241 ecx_117 = g_t8142744;
			word16 edx_119[] = g_ptr8142740;
			word16 (* esi_124)[] = g_ptr8142720;
			Eq_103241 edi_126 = g_t8142724;
			word32 edi_137 = strconv.bsearch16(gs, edx_119, ecx_117, ax_131);
			if (dwLoc2C >= ecx_117)
				return edi_137;
			if ((dwLoc2C & ~0x01) < ecx_117)
			{
				cup16 bp_154 = (word16) dwArg04;
				if (bp_154 < (word16) ((word32) edx_119[dwLoc2C & ~0x01]))
					return edi_137;
				if ((dwLoc2C | 0x01) < ecx_117)
				{
					if ((word16) (word32) edx_119[dwLoc2C | 0x01] < bp_154)
						return edi_137;
					word32 edi_177 = strconv.bsearch16(gs, esi_124, edi_126, bp_154);
					if (dwLoc2C >= edi_126 || dwLoc2C < edi_126)
						return edi_177;
					runtime.panicindex(gs);
				}
			}
			runtime.panicindex(gs);
		}
	}
	else
	{
		if (dwArg04 <= 0x7E)
			return edi;
		if (dwArg04 > 0xFF)
			return edi;
		return edi;
	}
}

// 08099C60: void strconv.isInGraphicList(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      strconv.appendEscapedRune
void strconv.isInGraphicList(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cup16 ax_29 = (word16) dwArg04;
	if (dwArg04 > 0xFFFF)
		return;
	strconv.bsearch16(gs, g_ptr8142710, g_t8142714, ax_29);
	Eq_103241 edx_43 = g_t8142714;
	if (dwLoc04 >= edx_43 || dwLoc04 < edx_43)
		return;
	runtime.panicindex(gs);
}

// 08099D00: void strconv.init(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.init
//      fmt.init
void strconv.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157584;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157584 = 0x01;
		errors.New(gs, 0x080E2B14, 0x12);
		g_dw81450B0 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t81450B4 = dwLoc04;
		else
			runtime.writebarrierptr(0x081450B4, dwLoc04);
		errors.New(gs, 0x080E2142, 0x0E);
		g_dw81450B8 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t81450BC = dwLoc04;
		else
			runtime.writebarrierptr(135549116, dwLoc04);
		g_b8157584 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 08099DE0: void type..hash.strconv.decimal(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.strconv.decimal(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x032A);
}

// 08099E30: void type..eq.strconv.decimal(Register (ptr32 Eq_103565) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.strconv.decimal(struct Eq_103565 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x032A, out esi_56, out edi_57);
}

// 08099E80: void type..hash.strconv.extFloat(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.[87]strconv.extFloat
void type..hash.strconv.extFloat(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0D);
}

// 08099ED0: void type..eq.strconv.extFloat(Register (ptr32 Eq_103606) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.strconv.extFloat(struct Eq_103606 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x0D, out esi_56, out edi_57);
}

// 08099F20: void type..hash.strconv.leftCheat(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.[61]strconv.leftCheat
void type..hash.strconv.leftCheat(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04);
	runtime.strhash(gs, mm0, (word32) dwArg04 + 4, dwLoc04);
}

// 08099F80: void type..eq.strconv.leftCheat(Register (ptr32 Eq_103652) gs, Stack (ptr32 Eq_103653) dwArg04, Stack (ptr32 Eq_103654) dwArg08)
void type..eq.strconv.leftCheat(struct Eq_103652 * gs, struct Eq_103653 * dwArg04, struct Eq_103654 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
	{
		Eq_4 edx_27 = dwArg08->t0004;
		Eq_4 ebx_28 = dwArg04->t0008;
		Eq_4 eax_29 = dwArg04->t0004;
		if (ebx_28 == dwArg08->t0008)
		{
			word32 edi_36;
			word32 esi_37;
			runtime.eqstring(eax_29, ebx_28, edx_27, out esi_37, out edi_36);
		}
	}
}

// 08099FF0: void type..hash.[61]strconv.leftCheat(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[61]strconv.leftCheat(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x3D; ++eax_17)
	{
		type..hash.strconv.leftCheat(gs, mm0, dwArg04 + eax_17 * 0x0C, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 0809A050: void type..eq.[61]strconv.leftCheat(Register (ptr32 Eq_103726) gs, Stack (ptr32 Eq_103727) dwArg04, Stack (ptr32 Eq_103728) dwArg08)
void type..eq.[61]strconv.leftCheat(struct Eq_103726 * gs, struct Eq_103727 * dwArg04, struct Eq_103728 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x3D; ++eax_17)
	{
		ui32 ecx_27 = eax_17 * 0x03;
		if (dwArg04[ecx_27 * 0x04 / 8] != dwArg08[(ecx_27 * 0x04) / 8])
			return;
		Eq_4 ebx_35 = dwArg08->a0004[ecx_27];
		Eq_4 edi_37 = dwArg04->a0008[ecx_27];
		Eq_4 ecx_38 = dwArg04->a0004[ecx_27];
		if (edi_37 != (dwArg08->a0008)[ecx_27])
			return;
		word32 esi_132;
		word32 edi_133;
		runtime.eqstring(ecx_38, edi_37, ebx_35, out esi_132, out edi_133);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 0809A0E0: void type..hash.[87]strconv.extFloat(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[87]strconv.extFloat(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x57; ++eax_17)
	{
		type..hash.strconv.extFloat(gs, mm0, (eax_17 << 0x04) + dwArg04, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 0809A140: void type..eq.[87]strconv.extFloat(Register (ptr32 Eq_103822) gs, Stack (ptr32 Eq_103823) dwArg04, Stack (ptr32 Eq_103824) dwArg08)
void type..eq.[87]strconv.extFloat(struct Eq_103822 * gs, struct Eq_103823 * dwArg04, struct Eq_103824 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 edx_19;
	for (edx_19 = 0x00; edx_19 < 0x57; ++edx_19)
	{
		struct Eq_103841 * edx_30 = edx_19 << 0x04;
		word32 ebp_32 = Mem29[edx_30 + dwArg08:word32];
		word32 ebx_36 = Mem29[edx_30 + 0x04 + dwArg04:word32];
		if (SLICE(SEQ(SLICE(ebx_36, word24, 8), ebx_36 != Mem29[(edx_30 + 0x04) + dwArg08:word32]) | SEQ(SLICE(ebp_32, word24, 8), Mem29[edx_30 + dwArg04:word32] != ebp_32), byte, 0) != 0x00 || (Mem29[(edx_30 + 0x08) + dwArg04:word32] != Mem29[(edx_30 + 0x08) + dwArg08:word32] || SLICE((word32) Mem29[(edx_30 + 0x0C) + dwArg04:byte], byte, 0) != SLICE((word32) Mem29[(edx_30 + 0x0C) + dwArg08:byte], byte, 0)))
			return;
	}
}

// 0809A1D0: void sync.(*Map).Load(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 bArg0C)
// Called from:
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.FuncOf.func1
void sync.(*Map).Load(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_37;
	byte al_42;
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc34 == 0x080D4580)
	{
		al_42 = (byte) (word32) dwLoc30->b0004;
		ecx_37 = dwLoc30->t0000;
	}
	else
	{
		al_42 = 0x00;
		ecx_37.u0 = 0x00;
	}
	word32 esi_362;
	runtime.mapaccess2(gs, 0x080CFA80, ecx_37, fp - 0x18, out esi_362);
	uip32 ecx_214 = (word32) bLoc28;
	byte bLoc14_359 = (byte) dwArg0C;
	if ((byte) ecx_214 != 0x00)
		ecx_214 = 0x01;
	else if ((byte) (word32) al_42 != 0x00)
	{
		Eq_4 ecx_107;
		byte al_113;
		sync.(*Mutex).Lock(gs, dwArg04);
		sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
		if (ecx_37 == 0x080D4580)
		{
			ecx_107 = dwArg08;
			al_113 = (byte) (word32) bLoc14_359;
		}
		else
		{
			ecx_107.u0 = 0x00;
			al_113 = 0x00;
		}
		word32 esi_134;
		runtime.mapaccess2(gs, 0x080CFA80, ecx_107, fp - 0x08, out esi_134);
		byte cl_142 = (byte) (word32) bLoc28;
		if (cl_142 != 0x00)
			cl_142 = 0x01;
		else if ((byte) (word32) al_113 != 0x00)
		{
			word32 esi_363;
			runtime.mapaccess2(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x10, out esi_363);
			sync.(*Map).missLocked(gs, dwArg04);
			cl_142 = (byte) (word32) (byte) (word32) bLoc28;
		}
		sync.(*Mutex).Unlock(gs, dwArg04);
		ecx_214 = (word32) cl_142;
	}
	if ((byte) ecx_214 == 0x00)
		return;
	sync.(*entry).load(gs);
}

// 0809A3D0: void sync.(*entry).load(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.(*Map).Load
void sync.(*entry).load(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	if (dwLoc04 == 0x00 || dwLoc04 == g_t8144FE8)
		;
}

// 0809A440: void sync.(*Map).Store(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 bArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.FuncOf.func1
void sync.(*Map).Store(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 bArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 dwLoc5C_502;
	runtime.newobject(gs, 0x080CECA0);
	*dwLoc5C = dwArg10;
	Eq_4 esp_16 = fp - 0x60;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwLoc5C + 4) = dwArg14;
		dwLoc5C_502 = dwLoc5C;
	}
	else
	{
		runtime.writebarrierptr((word32) dwLoc5C + 4, dwArg14);
		dwLoc5C_502 = dwArg14;
	}
	Eq_4 eax_71;
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc5C_502 == 0x080D4580)
		eax_71 = *dwLoc58;
	else
		eax_71.u0 = 0x00;
	word32 esi_684;
	runtime.mapaccess2(gs, 0x080CFA80, eax_71, fp - 0x08, out esi_684);
	byte bLoc04_676 = (byte) dwArg0C;
	Eq_4 dwLoc5C_523 = eax_71;
	byte bLoc58_537 = (byte) (fp - 0x08);
	Eq_4 eax_100 = *dwLoc54;
	if ((byte) (word32) bLoc50 != 0x00)
	{
		sync.(*entry).tryStore(gs, eax_100, dwLoc5C);
		dwLoc5C_523 = dwLoc5C;
		if ((byte) (word32) bLoc58_537 != 0x00)
			return;
	}
	Eq_4 ecx_154;
	byte al_159;
	Eq_4 edi_133 = sync.(*Mutex).Lock(gs, dwArg04);
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc5C_523 == 0x080D4580)
	{
		ecx_154 = dwArg08;
		al_159 = (byte) (word32) bLoc04_676;
	}
	else
	{
		al_159 = 0x00;
		ecx_154.u0 = 0x00;
	}
	word32 esi_683;
	runtime.mapaccess2(gs, 0x080CFA80, ecx_154, fp - 0x10, out esi_683);
	byte bLoc5C_582 = (byte) ecx_154;
	Eq_4 eax_188 = *dwLoc54;
	if ((byte) (word32) bLoc50 != 0x00)
	{
		sync.(*entry).unexpungeLocked(gs, eax_188);
		if ((byte) (word32) bLoc5C_582 != 0x00)
		{
			runtime.mapassign(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x18);
			if (g_t81576F0 == 0x00)
				*dwLoc54 = eax_188;
			else
				runtime.writebarrierptr(dwLoc54, eax_188);
		}
		sync.(*entry).storeLocked(gs, eax_188, dwLoc5C);
	}
	else
	{
		Eq_4 esi_209;
		word32 * ebx_208 = runtime.mapaccess2(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x20, out esi_209);
		Eq_4 eax_216 = *dwLoc54;
		if ((byte) (word32) bLoc50 == 0x00)
		{
			if ((byte) (word32) al_159 == 0x00)
			{
				word128 xmm0_249;
				word128 xmm1_250;
				Eq_4 ebx_241 = sync.(*Map).dirtyLocked(ebx_208, esi_209, edi_133, gs, dwLoc64, dwArg04, out xmm0_249, out xmm1_250);
				esp_16.u0 = <invalid>;
				*((byte) esp_16.u0 + 56) = *((byte) esp_16.u0 + 28);
				((byte) esp_16.u0 + 60)->u0 = 0x01;
				esp_16.u0->u0 = 0x080D4580;
				*((byte) esp_16.u0 + 4) = (byte) esp_16.u0 + 56;
				runtime.convT2E(ebx_241, gs, *esp_16.u0, *((byte) esp_16.u0 + 4));
				Eq_4 eax_275 = *((byte) esp_16.u0 + 0x0C);
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 8);
				*((byte) esp_16.u0 + 8) = eax_275;
				*esp_16.u0 = *((byte) esp_16.u0 + 36);
				sync/atomic.(*Value).Store(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
			}
			*((byte) esp_16.u0 + 48) = *((byte) esp_16.u0 + 0x0068);
			*((byte) esp_16.u0 + 52) = *((byte) esp_16.u0 + 0x006C);
			esp_16.u0->u0 = 0x080CECA0;
			runtime.newobject(gs, *esp_16.u0);
			Eq_4 eax_305 = *((byte) esp_16.u0 + 40);
			word32 ecx_306 = *eax_305;
			Eq_4 eax_307 = *((word32) eax_305 + 4);
			Eq_4 edx_308 = *((byte) esp_16.u0 + 4);
			*((byte) esp_16.u0 + 44) = edx_308;
			*edx_308 = ecx_306;
			if (g_t81576F0 == 0x00)
				*((word32) edx_308 + 4) = eax_307;
			else
			{
				*esp_16.u0 = (word32) edx_308 + 4;
				*((byte) esp_16.u0 + 4) = eax_307;
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
			esp_16.u0->u0 = 0x080D1CE0;
			runtime.newobject(gs, *esp_16.u0);
			Eq_4 eax_338 = *((byte) esp_16.u0 + 4);
			*((byte) esp_16.u0 + 24) = eax_338;
			if (g_t81576F0 == 0x00)
				*eax_338 = *((byte) esp_16.u0 + 44);
			else
			{
				*esp_16.u0 = eax_338;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 44);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
			*((byte) esp_16.u0 + 4) = *((word32) *((byte) esp_16.u0 + 100) + 16);
			esp_16.u0->u0 = 0x080CFA80;
			*((byte) esp_16.u0 + 8) = (byte) esp_16.u0 + 48;
			runtime.mapassign(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
			Eq_4 eax_380 = *((byte) esp_16.u0 + 0x0C);
			if (g_t81576F0 == 0x00)
				*eax_380 = *((byte) esp_16.u0 + 24);
			else
			{
				*esp_16.u0 = eax_380;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 24);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
		}
		else
			sync.(*entry).storeLocked(gs, eax_216, dwLoc5C);
	}
	sync.(*Mutex).Unlock(gs, dwArg04);
}

// 0809A7F0: void sync.(*entry).tryStore(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync.(*Map).Store
void sync.(*entry).tryStore(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	if (g_t8144FE8 == dwLoc0C)
		return;
	do
	{
		sync/atomic.CompareAndSwapPointer(dwArg04, dwLoc0C, dwArg08);
		if ((byte) (word32) bLoc04 != 0x00)
			return;
		sync/atomic.LoadPointer();
	} while (g_t8144FE8 != dwLoc0C);
}

// 0809A890: void sync.(*entry).unexpungeLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
void sync.(*entry).unexpungeLocked(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.CompareAndSwapPointer(dwArg04, g_t8144FE8, 0x00);
}

// 0809A8E0: void sync.(*entry).storeLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync.(*Map).Store
void sync.(*entry).storeLocked(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.StorePointer(dwArg04, dwArg08);
}

// 0809A920: Register word128 sync.(*Map).LoadOrStore(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Register out Eq_104523 xmm1Out)
// Called from:
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).ptrTo
//      reflect.funcLayout
word128 sync.(*Map).LoadOrStore(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg10, Eq_4 dwArg14, union Eq_104523 & xmm1Out)
{
	byte bLoc58 = (byte) dwLoc58;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_36;
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	Eq_4 esp_16 = fp - 0x68;
	if (dwLoc64 == 0x080D4580)
		eax_36 = *dwLoc60;
	else
		eax_36.u0 = 0x00;
	word32 esi_756;
	runtime.mapaccess2(gs, 0x080CFA80, eax_36, fp - 0x08, out esi_756);
	Eq_4 dwLoc64_551 = eax_36;
	Eq_4 dwLoc60_552 = fp - 0x08;
	Eq_4 eax_65 = *dwLoc5C;
	if ((byte) (word32) bLoc58 != 0x00)
	{
		sync.(*entry).tryLoadOrStore(gs, eax_65, dwArg10, dwArg14);
		dwLoc64_551 = dwArg10;
		dwLoc60_552 = dwArg14;
		if ((byte) (word32) bLoc53 != 0x00)
		{
			xmm1Out = xmm1;
			return xmm0;
		}
	}
	Eq_4 ecx_130;
	byte al_135;
	Eq_4 edi_109 = sync.(*Mutex).Lock(gs, dwArg04);
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc64_551 == 0x080D4580)
	{
		ecx_130 = *dwLoc60_552;
		al_135 = (byte) (word32) *((word32) dwLoc60_552 + 4);
	}
	else
	{
		al_135 = 0x00;
		ecx_130.u0 = 0x00;
	}
	word32 esi_755;
	runtime.mapaccess2(gs, 0x080CFA80, ecx_130, fp - 0x10, out esi_755);
	byte bLoc64_636 = (byte) ecx_130;
	Eq_4 eax_164 = *dwLoc5C;
	if ((byte) (word32) bLoc58 != 0x00)
	{
		sync.(*entry).unexpungeLocked(gs, eax_164);
		if ((byte) (word32) bLoc64_636 != 0x00)
		{
			runtime.mapassign(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x18);
			if (g_t81576F0 == 0x00)
				*dwLoc5C = eax_164;
			else
				runtime.writebarrierptr(dwLoc5C, eax_164);
		}
		sync.(*entry).tryLoadOrStore(gs, eax_164, dwArg10, dwArg14);
	}
	else
	{
		Eq_4 esi_185;
		word32 * ebx_184 = runtime.mapaccess2(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x20, out esi_185);
		Eq_4 eax_192 = *dwLoc5C;
		if ((byte) (word32) bLoc58 == 0x00)
		{
			if ((byte) (word32) al_135 == 0x00)
			{
				Eq_4 ebx_245 = sync.(*Map).dirtyLocked(ebx_184, esi_185, edi_109, gs, dwLoc6C, dwArg04, out xmm0, out xmm1);
				esp_16.u0 = <invalid>;
				*((byte) esp_16.u0 + 64) = *((byte) esp_16.u0 + 32);
				((byte) esp_16.u0 + 0x0044)->u0 = 0x01;
				esp_16.u0->u0 = 0x080D4580;
				*((byte) esp_16.u0 + 4) = (byte) esp_16.u0 + 64;
				runtime.convT2E(ebx_245, gs, *esp_16.u0, *((byte) esp_16.u0 + 4));
				Eq_4 eax_279 = *((byte) esp_16.u0 + 0x0C);
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 8);
				*((byte) esp_16.u0 + 8) = eax_279;
				*esp_16.u0 = *((byte) esp_16.u0 + 48);
				sync/atomic.(*Value).Store(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
			}
			*((byte) esp_16.u0 + 56) = *((byte) esp_16.u0 + 112);
			*((byte) esp_16.u0 + 60) = *((byte) esp_16.u0 + 116);
			esp_16.u0->u0 = 0x080CECA0;
			runtime.newobject(gs, *esp_16.u0);
			Eq_4 eax_309 = *((byte) esp_16.u0 + 4);
			*((byte) esp_16.u0 + 52) = eax_309;
			*eax_309 = *((byte) esp_16.u0 + 0x0078);
			if (g_t81576F0 == 0x00)
				*((word32) eax_309 + 4) = *((byte) esp_16.u0 + 0x007C);
			else
			{
				*esp_16.u0 = (word32) eax_309 + 4;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 0x007C);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
			esp_16.u0->u0 = 0x080D1CE0;
			runtime.newobject(gs, *esp_16.u0);
			Eq_4 eax_342 = *((byte) esp_16.u0 + 4);
			*((byte) esp_16.u0 + 28) = eax_342;
			if (g_t81576F0 == 0x00)
				*eax_342 = *((byte) esp_16.u0 + 52);
			else
			{
				*esp_16.u0 = eax_342;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 52);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
			*((byte) esp_16.u0 + 4) = *((word32) *((byte) esp_16.u0 + 0x006C) + 16);
			esp_16.u0->u0 = 0x080CFA80;
			*((byte) esp_16.u0 + 8) = (byte) esp_16.u0 + 56;
			runtime.mapassign(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
			Eq_4 eax_384 = *((byte) esp_16.u0 + 0x0C);
			if (g_t81576F0 == 0x00)
				*eax_384 = *((byte) esp_16.u0 + 28);
			else
			{
				*esp_16.u0 = eax_384;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 28);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
		}
		else
		{
			sync.(*entry).tryLoadOrStore(gs, eax_192, dwArg10, dwArg14);
			sync.(*Map).missLocked(gs, dwArg04);
		}
	}
	sync.(*Mutex).Unlock(gs, dwArg04);
	xmm1Out = xmm1;
	return xmm0;
}

// 0809AD50: void sync.(*entry).tryLoadOrStore(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync.(*Map).LoadOrStore
void sync.(*entry).tryLoadOrStore(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	if (g_t8144FE8 == dwLoc10)
		return;
	if (dwLoc10 != 0x00)
		return;
	runtime.newobject(gs, 0x080CECA0);
	*dwLoc10 = dwArg08;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc10 + 4) = dwArg0C;
	else
		runtime.writebarrierptr((word32) dwLoc10 + 4, dwArg0C);
	do
	{
		sync/atomic.CompareAndSwapPointer(dwArg04, 0x00, dwLoc10);
		if ((byte) (word32) bLoc08 != 0x00)
			return;
		sync/atomic.LoadPointer();
		if (g_t8144FE8 == 0x00)
			return;
	} while (0x00 == 0x00);
}

// 0809AED0: void sync.(*Map).missLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).Load
//      sync.(*Map).LoadOrStore
void sync.(*Map).missLocked(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 edx_26;
	Eq_4 ecx_18 = *((word32) dwArg04 + 20);
	*((word32) dwArg04 + 20) = (word32) ecx_18 + 1;
	Eq_4 edx_21 = *((word32) dwArg04 + 16);
	if (edx_21 != 0x00)
		edx_26 = (int32) *edx_21;
	else
		edx_26 = 0x00;
	if ((word32) ecx_18 + 1 < edx_26)
		return;
	runtime.convT2E((word32) dwArg04 + 16, gs, 0x080D4580, fp - 0x08);
	sync/atomic.(*Value).Store(gs, (word32) dwArg04 + 8, dwLoc14, dwLoc10);
	if (g_t81576F0 == 0x00)
		((word32) dwArg04 + 16)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) dwArg04 + 16, 0x00);
	((word32) dwArg04 + 20)->u0 = 0x00;
}

// 0809AFB0: Register (ptr32 word32) sync.(*Map).dirtyLocked(Register (ptr32 word32) ebx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_104181) dwArg00, Stack Eq_4 dwArg04, Register out Eq_104183 xmm0Out, Register out Eq_104184 xmm1Out)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
word32 * sync.(*Map).dirtyLocked(word32 * ebx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs, struct Eq_104181 * dwArg00, Eq_4 dwArg04, union Eq_104183 & xmm0Out, union Eq_104184 & xmm1Out)
{
	Eq_6606 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 16) != 0x00)
	{
		xmm0Out = xmm0;
		xmm1Out = xmm1;
		return ebx;
	}
	else
	{
		union Eq_4 * eax_40;
		sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
		if (dwLoc60 == 0x080D4580)
			eax_40 = (union Eq_4 *) *dwLoc5C;
		else
			eax_40 = null;
		Eq_4 ecx_50;
		if (eax_40 != null)
			ecx_50 = *eax_40;
		else
			ecx_50.u0 = 0x00;
		Eq_4 ecx_59 = ecx_50 >> 0x1F;
		Eq_104183 xmm0_85;
		Eq_104184 xmm1_86;
		word32 edi_359;
		runtime.makemap(ebx_24_8, esi, edi, gs, 0x080CFA80, ecx_50, ecx_59, 0x00, 0x00, out edi_359, out xmm0_85, out xmm1_86);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 16) = dwLoc50;
		else
			runtime.writebarrierptr((word32) dwArg04 + 16, dwLoc50);
		fn0808FD84(0x00, fp - 0x30);
		byte bLoc64_263 = (byte) dwLoc50;
		word32 * ebx_127 = runtime.mapiterinit(gs, 0x080CFA80, dwLoc50, fp - 0x34);
		while (dwLoc34 != 0x00)
		{
			Eq_4 ecx_150 = *dwLoc30;
			sync.(*entry).tryExpungeLocked(gs, ecx_150);
			if ((byte) (word32) bLoc64_263 == 0x00)
			{
				Eq_4 ecx_172 = dwArg00->t0010;
				runtime.mapassign(gs, 0x080CFA80, ecx_172, fp - 0x3C);
				bLoc64_263 = (byte) ecx_172;
				if (g_t81576F0 == 0x00)
					*ecx_59 = ecx_150;
				else
				{
					runtime.writebarrierptr(ecx_59, ecx_150);
					bLoc64_263 = (byte) ecx_150;
				}
			}
			ebx_127 = runtime.mapiternext(gs, fp - 0x34);
		}
		xmm0Out = xmm0_85;
		xmm1Out = xmm1_86;
		return ebx_127;
	}
}

// 0809B160: void sync.(*entry).tryExpungeLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).dirtyLocked
void sync.(*entry).tryExpungeLocked(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	word32 eax_23 = dwLoc0C;
	while (eax_23 == 0x00)
	{
		sync/atomic.CompareAndSwapPointer(dwArg04, 0x00, g_t8144FE8);
		if ((byte) (word32) bLoc04 != 0x00)
			return;
		sync/atomic.LoadPointer();
		eax_23 = 0x00;
	}
}

// 0809B1F0: Register ui32 sync.(*Mutex).Lock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).Load
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Once).Do
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
//      sync.(*Pool).pinSlow
//      reflect.FuncOf
ui32 sync.(*Mutex).Lock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_636;
	sync/atomic.CompareAndSwapInt32(dwArg04, 0x00, 0x01, out ebp_636);
	byte bLoc20_474 = 0x00;
	if ((byte) (word32) bLoc18 != 0x00)
		return edi;
	Eq_4 ecx_133 = *dwArg04;
	int32 edx_131 = 0x00;
	word32 ebp_135 = 0x00;
	uint32 esi_136 = 0x00;
	ui32 edi_137 = 0x00;
	ui32 ebx_134 = 0x00;
	while (true)
	{
l0809B244:
		byte bl_59 = (byte) ebx_134;
		byte al_54 = (byte) ebp_135;
		word32 ebp_174 = ebp_135;
		ui32 ebx_626 = ebx_134;
		if ((ecx_133 & 0x05) != 0x01)
			break;
		sync.runtime_canSpin(gs, edx_131);
		if ((byte) (word32) bLoc20_474 == 0x00)
		{
			ebx_626 = (word32) bl_59;
			ebp_174 = (word32) al_54;
			break;
		}
		byte al_120 = (byte) (word32) al_54;
		if (al_120 == 0x00 && ((ecx_133 & 0x02) == 0x00 && ecx_133 >> 0x03 != 0x00))
		{
			word32 ebp_637;
			sync/atomic.CompareAndSwapInt32(dwArg04, ecx_133, ecx_133 | 0x02, out ebp_637);
			bLoc20_474 = (byte) ecx_133;
			if ((byte) (word32) bLoc18 != 0x00)
				al_120 = 0x01;
			else
				al_120 = (byte) (word32) al_54;
		}
		sync.runtime_doSpin();
		++edx_131;
		ecx_133 = *dwArg04;
		ebx_134 = (word32) bl_59;
		ebp_135 = (word32) al_120;
	}
	ui32 edi_307 = edi_137;
	ui24 ebx_24_8_251 = SLICE(ebx_626, word24, 8);
	byte bl_158 = (byte) ebx_626;
	Eq_4 ecx_140 = ecx_133;
	if ((ecx_133 & 0x04) == 0x00)
		ecx_140 = ecx_133 | 0x01;
	if ((ecx_133 & 0x05) != 0x00)
		ecx_140 = (word32) ecx_140 + 8;
	if (bl_158 != 0x00 && (ecx_133 & 0x01) != 0x00)
		ecx_140 |= 0x04;
	if ((byte) ebp_174 != 0x00)
	{
		if ((ecx_140 & 0x02) == 0x00)
			runtime.gopanic(gs);
		ecx_140 &= ~0x02;
	}
	word24 nLoc1F_528 = SLICE(ecx_133, word24, 8);
	bLoc20_474 = (byte) ecx_133;
	word32 ebp_227;
	ui24 ecx_24_8_255 = SLICE(sync/atomic.CompareAndSwapInt32(dwArg04, ecx_133, ecx_140, out ebp_227), word24, 8);
	if ((byte) (word32) bLoc18 == 0x00)
	{
		ecx_133 = *dwArg04;
		ebx_134 = (word32) bl_59;
		ebp_135 = (word32) al_54;
	}
	else
	{
		if ((ecx_133 & 0x05) == 0x00)
			return edi_307;
		int64 edx_eax_628;
		if ((byte) (SEQ(ebx_24_8_251, edi_137 == 0x00) & SEQ(ecx_24_8_255, esi_136 == 0x00)) == 0x00)
			edx_eax_628 = SEQ(edi_137, esi_136);
		else
		{
			sync.runtime_nanotime(gs);
			edx_eax_628 = SEQ(ecx_133, dwArg04);
		}
		ui32 eax_362;
		byte bl_300 = (byte) (SEQ(SLICE(edi_137, word24, 8), edi_137 != 0x00) | SEQ(SLICE(esi_136, word24, 8), esi_136 != 0x00));
		ui32 edx_280 = SLICE(edx_eax_628, word32, 32);
		uint32 eax_277 = (word32) edx_eax_628;
		word32 ebp_310 = sync.runtime_SemacquireMutex(edi_137, gs, dwArg04 + 0x04, bl_300, out edi_307);
		ui32 dwLoc20_529 = SEQ(nLoc1F_528, bl_300);
		if ((byte) (word32) bl_59 != 0x00)
			eax_362 = 0x01;
		else
		{
			sync.runtime_nanotime(gs);
			ui64 edx_eax_459 = SEQ(dwLoc20_529, dwArg04 + 0x04) - edx_eax_628;
			up32 eax_335 = (word32) edx_eax_459;
			int32 edx_340 = SLICE(edx_eax_459, word32, 32);
			eax_362 = SEQ(SLICE(eax_335, word24, 8), eax_335 > 1000000) & SEQ(SLICE(ebp_310, word24, 8), edx_340 == 0x00) | SEQ(SLICE(edx_340, word24, 8), edx_340 > 0x00);
		}
		bLoc20_474 = bl_300;
		byte al_399 = (byte) eax_362;
		Eq_4 edx_369 = *dwArg04;
		if ((edx_369 & 0x04) != 0x00)
		{
			if ((edx_369 & 0x03) != 0x00 || edx_369 >> 0x03 == 0x00)
				runtime.gopanic(gs);
			else
			{
				Eq_4 eax_407;
				if (al_399 != 0x00 && edx_369 >> 0x03 != 0x01)
					eax_407.u0 = ~0x06;
				else
					eax_407.u0 = ~0x0A;
				sync/atomic.AddInt32(dwArg04, eax_407);
				return edi_307;
			}
		}
		ecx_133 = edx_369;
		edx_131 = 0x00;
		ebp_135 = 0x01;
		esi_136 = eax_277;
		edi_137 = edx_280;
		ebx_134 = eax_362;
	}
	goto l0809B244;
}

// 0809B4F0: void sync.(*Mutex).Unlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).Load
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
void sync.(*Mutex).Unlock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_24 = sync/atomic.AddInt32(dwArg04, ~0x00);
	Eq_4 eax_30 = dwLoc08;
	if (((word32) dwLoc08 + 1 & 0x01) == 0x00)
		runtime.gopanic(gs);
	else if ((dwLoc08 & 0x04) == 0x00)
	{
		while (eax_30 >> 0x03 != 0x00 && (eax_30 & 0x07) == 0x00)
		{
			word32 ebp_77;
			sync/atomic.CompareAndSwapInt32(dwArg04, eax_30, (word32) eax_30 - 8 | 0x02, out ebp_77);
			if ((byte) (word32) bLoc04 != 0x00)
			{
				sync.runtime_Semrelease(ebp_77, gs, dwLoc14, (word32) dwArg04 + 4);
				return;
			}
			eax_30 = *dwArg04;
		}
	}
	else
		sync.runtime_Semrelease(ebp_24, gs, dwLoc14, (word32) dwArg04 + 4);
}

// 0809B5D0: Register word32 sync.(*Once).Do(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 (ptr32 code)) dwArg08)
// Called from:
//      internal/poll.(*pollDesc).init
word32 sync.(*Once).Do(struct Eq_2 * gs, Eq_4 dwArg04, <anonymous> ** dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadUint32();
	if (dwLoc10 == 0x01)
		return runtime.deferreturn(gs);
	sync.(*Mutex).Lock(gs, dwArg04);
	word32 ebp_196;
	word32 esi_197;
	word32 edi_198;
	if (runtime.deferproc(gs, 0x04, 0x080E7D08, dwArg04, out ebp_196, out esi_197, out edi_198) != 0x00)
		return runtime.deferreturn(gs);
	if (*((word32) dwArg04 + 8) != 0x00)
		return runtime.deferreturn(gs);
	word32 ebp_199;
	word32 esi_200;
	word32 edi_201;
	if (runtime.deferproc(gs, 0x08, 0x080E7D10, (word32) dwArg04 + 8, out ebp_199, out esi_200, out edi_201) != 0x00)
		return runtime.deferreturn(gs);
	(*dwArg08)();
	return runtime.deferreturn(gs);
}

// 0809B6B0: void sync.(*Pool).Put(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ptr32 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.callMethod
//      fmt.(*pp).free
void sync.(*Pool).Put(struct Eq_2 * gs, Eq_4 dwArg04, ptr32 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return;
	ptr32 edx_68;
	Eq_4 ecx_65;
	sync.(*Pool).pin(gs, dwLoc38, dwArg04);
	if (dwLoc30->ptr0000 != 0x00)
	{
		ecx_65 = dwArg0C;
		edx_68 = dwArg08;
	}
	else
	{
		dwLoc30->ptr0000 = dwArg08;
		if (g_t81576F0 == 0x00)
			dwLoc30->t0004 = dwArg0C;
		else
			runtime.writebarrierptr(&dwLoc30->t0004, dwArg0C);
		ecx_65.u0 = 0x00;
		edx_68 = 0x00;
	}
	sync.runtime_procUnpin(gs);
	if (edx_68 != 0x00)
	{
		sync.(*Mutex).Lock(gs, (char *) &dwLoc30->t0010 + 4);
		Eq_4 ecx_104 = dwLoc30->t0008;
		Eq_4 edx_105 = dwLoc30->t000C;
		Eq_4 ebx_106 = dwLoc30->t0010;
		if ((word32) edx_105 + 1 > ebx_106)
		{
			word32 esi_124;
			runtime.growslice(gs, 0x080CECA0, ecx_104, edx_105, ebx_106, (word32) edx_105 + 1, out esi_124);
			dwLoc30->t0010 = dwLoc18;
			if (g_t81576F0 == 0x00)
				dwLoc30->t0008 = dwLoc20;
			else
				runtime.writebarrierptr(&dwLoc30->t0008, dwLoc20);
			edx_105 = dwLoc1C;
			ecx_104 = dwLoc20;
		}
		dwLoc30->t000C = (word32) edx_105 + 1;
		*((word32) ecx_104 + edx_105 * 0x08) = edx_68;
		Eq_4 ecx_172 = (word32) ecx_104 + 4 + edx_105 * 0x08;
		if (g_t81576F0 == 0x00)
			*ecx_172 = ecx_65;
		else
			runtime.writebarrierptr(ecx_172, ecx_65);
		sync.(*Mutex).Unlock(gs, (char *) &dwLoc30->t0010 + 4);
	}
}

// 0809B840: void sync.(*Pool).Get(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.callMethod
//      fmt.newPrinter
void sync.(*Pool).Get(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.(*Pool).pin(gs, dwLoc20, dwArg04);
	Eq_4 esp_27 = <invalid>;
	Eq_4 eax_33 = *((word32) esp_27 + 4);
	*((word32) esp_27 + 20) = eax_33;
	*((word32) esp_27 + 0x0C) = *eax_33;
	*((word32) esp_27 + 16) = *((word32) eax_33 + 4);
	eax_33->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) eax_33 + 4)->u0 = 0x00;
	else
	{
		*esp_27 = (word32) eax_33 + 4;
		((word32) esp_27 + 4)->u0 = 0x00;
		runtime.writebarrierptr(*esp_27, *((word32) esp_27 + 4));
	}
	sync.runtime_procUnpin(gs);
	Eq_4 eax_115 = *((word32) esp_27 + 0x0C);
	if (eax_115 == 0x00)
	{
		Eq_4 edx_101;
		Eq_4 ecx_90;
		Eq_4 eax_68 = *((word32) esp_27 + 20);
		*((word32) esp_27 + 24) = (word32) eax_68 + 20;
		*esp_27 = (word32) eax_68 + 20;
		sync.(*Mutex).Lock(gs, *esp_27);
		Eq_4 eax_83 = *((word32) esp_27 + 20);
		Eq_4 ecx_84 = *((word32) eax_83 + 8);
		Eq_4 edx_85 = *((word32) eax_83 + 0x0C);
		if (edx_85 >= 0x01)
		{
			if (edx_85 - 0x01 >= edx_85)
				runtime.panicindex(gs);
			struct Eq_105805 * ecx_94 = ecx_84 - 0x08 + edx_85 * 0x08;
			edx_101 = ecx_94->t0000;
			ecx_90 = ecx_94->t0004;
			*((word32) eax_83 + 0x0C) = edx_85 - 0x01;
		}
		else
		{
			ecx_90 = *((word32) esp_27 + 16);
			edx_101 = *((word32) esp_27 + 0x0C);
		}
		*((word32) esp_27 + 16) = ecx_90;
		*((word32) esp_27 + 0x0C) = edx_101;
		*esp_27 = *((word32) esp_27 + 24);
		sync.(*Mutex).Unlock(gs, *esp_27);
		eax_115 = *((word32) esp_27 + 0x0C);
		if (eax_115 == 0x00)
		{
			*esp_27 = *((word32) esp_27 + 32);
			sync.(*Pool).getSlow(gs, *((word32) esp_27 - 4), *esp_27);
			Eq_4 esp_124 = <invalid>;
			eax_115 = *((word32) esp_124 + 4);
		}
	}
	if (eax_115 == 0x00)
	{
		Eq_4 edx_144 = *((word32) dwArg04 + 8);
		if (edx_144 != 0x00)
			(*edx_144)();
	}
}

// 0809B970: void sync.(*Pool).getSlow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Pool).Get
void sync.(*Pool).getSlow(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadUintptr();
	word32 ecx_28 = *dwArg00;
	sync.runtime_procPin(gs);
	sync.runtime_procUnpin(gs);
	int32 eax_122;
	for (eax_122 = 0x01; eax_122 < (word32) dwArg04 + 4; ++eax_122)
	{
		if (dwArg04 == 0x04)
			runtime.panicdivide(gs);
		int32 edx_65;
		int32 ebx_61 = eax_122 + 0x00 + dwLoc2C;
		if (dwArg04 != 0x05)
			edx_65 = (int32) ((int64) ebx_61 % ((word32) dwArg04 + 4));
		else
			edx_65 = 0x00;
		struct Eq_105921 * edx_81 = (edx_65 << 0x07) + ecx_28;
		sync.(*Mutex).Lock(gs, (char *) &edx_81->t000C + 8);
		Eq_105929 edx_104 = edx_81->t000C;
		if (edx_104 >= 0x01)
		{
			if (edx_104 - 0x01 >= edx_104)
				runtime.panicindex(gs);
			else
			{
				edx_81->t000C = edx_104 - 0x01;
				sync.(*Mutex).Unlock(gs, (char *) &edx_81->t000C + 8);
				return;
			}
		}
		sync.(*Mutex).Unlock(gs, (char *) &edx_81->t000C + 8);
	}
}

// 0809BA90: void sync.(*Pool).pin(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Pool).Put
//      sync.(*Pool).Get
void sync.(*Pool).pin(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.runtime_procPin(gs);
	sync/atomic.LoadUintptr();
	if (dwLoc08 < (word32) dwArg04 + 4)
		return;
	sync.(*Pool).pinSlow(gs, dwArg00);
}

// 0809BB00: void sync.(*Pool).pinSlow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Pool).pin
void sync.(*Pool).pinSlow(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.runtime_procUnpin(gs);
	sync.(*Mutex).Lock(gs, 0x081576C8);
	Eq_4 dwLoc38_272 = 0x080E7D08;
	word32 ebp_353;
	word32 edi_354;
	Eq_4 esi_107;
	if (runtime.deferproc(gs, 0x04, 0x080E7D08, 0x081576C8, out ebp_353, out esi_107, out edi_354) != 0x00)
		runtime.deferreturn(gs);
	else
	{
		sync.runtime_procPin(gs);
		word32 ebp_79 = *dwArg04;
		if (*((word32) dwArg04 + 4) > 0x04)
			runtime.deferreturn(gs);
		else
		{
			if (ebp_79 == 0x00)
			{
				Eq_4 edx_105 = g_t8145180;
				Eq_4 ebp_106 = g_t814517C;
				esi_107 = g_t8145178;
				if ((word32) ebp_106 + 1 > edx_105)
				{
					word32 esi_356;
					runtime.growslice(gs, 0x080D86C0, esi_107, ebp_106, edx_105, (word32) ebp_106 + 1, out esi_356);
					g_t8145180 = dwLoc20;
					dwLoc38_272 = esi_107;
					dwLoc30 = edx_105;
					dwLoc2C = (word32) ebp_106 + 1;
					if (g_t81576F0 == 0x00)
						g_t8145178 = dwLoc28;
					else
					{
						runtime.writebarrierptr(0x08145178, dwLoc28);
						dwLoc38_272 = dwLoc28;
					}
					ebp_106 = dwLoc24;
					esi_107 = dwLoc28;
				}
				g_t814517C = (word32) ebp_106 + 1;
				Eq_4 edx_165 = (word32) esi_107 + ebp_106 * 0x04;
				if (g_t81576F0 == 0x00)
					*((word32) esi_107 + ebp_106 * 0x04) = dwArg04;
				else
				{
					runtime.writebarrierptr(edx_165, dwArg04);
					dwLoc38_272 = dwArg04;
				}
			}
			runtime.GOMAXPROCS(esi_107, gs, 0x00);
			word32 edi_355;
			runtime.makeslice(gs, 0x080D4520, dwLoc38_272, dwLoc38_272, out edi_355);
			if (dwLoc2C <= 0x00)
				runtime.panicindex(gs);
			else
			{
				sync/atomic.StorePointer(dwArg04, dwLoc30);
				sync/atomic.StoreUintptr((word32) dwArg04 + 4, dwLoc38_272);
				if (dwLoc2C <= 0x04)
					runtime.panicindex(gs);
				else
					runtime.deferreturn(gs);
			}
		}
	}
}

// 0809BD20: void sync.poolCleanup(Register (ptr32 Eq_2) gs)
void sync.poolCleanup(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_123 = g_t8145178;
	Eq_4 ecx_18 = g_t814517C;
	Eq_4 edx_127 = 0x00;
	ecx_115 = ecx_18;
	while (true)
	{
		Eq_4 ecx_115;
		if (edx_127 >= ecx_115)
			break;
		Eq_4 ebx_62 = *eax_123;
		Eq_4 esi_64 = g_t8145178;
		if (edx_127 >= g_t814517C)
			runtime.panicindex(gs);
		Eq_4 ebp_70 = (word32) esi_64 + edx_127 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) esi_64 + edx_127 * 0x04) = 0x00;
		else
		{
			runtime.writebarrierptr(ebp_70, 0x00);
			dwLoc20.u0 = 0x00;
			ecx_115 = ecx_18;
		}
		Eq_4 eax_114 = eax_123;
		Eq_4 ebx_117 = ebx_62;
		int32 ebp_215;
		for (ebp_215 = 0x00; ebp_215 < *((word32) ebx_117 + 4); ++ebp_215)
		{
			struct Eq_106181 * ebp_133 = (word32) *ebx_117 + (ebp_215 << 0x07);
			ebp_133->dw0000 = 0x00;
			if (g_t81576F0 == 0x00)
				ebp_133->dw0004 = 0x00;
			else
			{
				runtime.writebarrierptr(&ebp_133->dw0004, 0x00);
				dwLoc20.u0 = 0x00;
				eax_114 = eax_123;
				ebx_117 = ebx_62;
			}
			ui32 ecx_159 = ebp_133->dw000C;
			Eq_4 esi_160 = ebp_133->t0008;
			if (ecx_159 != 0x00)
			{
				runtime.memclrHasPointers(gs, esi_160, ecx_159 << 0x03);
				dwLoc20 = ecx_159 << 0x03;
				eax_114 = eax_123;
				ebx_117 = ebx_62;
			}
			ebp_133->dw000C = 0x00;
			ebp_133->dw0010 = 0x00;
			if (g_t81576F0 == 0x00)
				ebp_133->t0008.u0 = 0x00;
			else
			{
				runtime.writebarrierptr(&ebp_133->t0008, 0x00);
				dwLoc20.u0 = 0x00;
				eax_114 = eax_123;
				ebx_117 = ebx_62;
			}
			ecx_115 = ecx_18;
		}
		if (g_t81576F0 == 0x00)
			*ebx_117 = 0x00;
		else
		{
			runtime.writebarrierptr(ebx_117, 0x00);
			dwLoc20.u0 = 0x00;
			eax_114 = eax_123;
			ecx_115 = ecx_18;
			ebx_117 = ebx_62;
		}
		*((word32) ebx_117 + 4) = 0x00;
		eax_123 = (word32) eax_114 + 4;
		edx_127 = (word32) edx_127 + 1;
	}
	runtime.newobject(gs, 0x080CADA0);
	g_t814517C.u0 = 0x00;
	g_t8145180.u0 = 0x00;
	if (g_t81576F0 == 0x00)
		g_t8145178 = dwLoc20;
	else
		runtime.writebarrierptr(0x08145178, dwLoc20);
}

// 0809BF40: void sync.init.0(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.init
void sync.init.0(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.runtime_registerPoolCleanup(gs, 0x080E7D0C);
}

// 0809BF70: Register Eq_4 sync.init.1(Register Eq_106281 ebx, Register (ptr32 Eq_2) gs)
// Called from:
//      sync.init
Eq_4 sync.init.1(Eq_106281 ebx, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edi_21 = fn0808FD8B(0x00, fp - 0x14);
	sync.runtime_notifyListCheck(ebx_24_8, gs, 0x14);
	return edi_21;
}

// 0809BFB0: Register word32 sync.init(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut, Register out ptr32 ediOut, Register out Eq_106310 xmm0Out)
// Called from:
//      io.init
//      syscall.init
//      time.init
//      internal/poll.init
//      os.init
//      reflect.init
//      fmt.init
word32 sync.init(struct Eq_2 * gs, ptr32 & esiOut, ptr32 & ediOut, union Eq_106310 & xmm0Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157585;
	if (al_18 <= 0x01)
	{
		if (al_18 != 0x01)
		{
			g_b8157585 = 0x01;
			ptr32 esi_28;
			Eq_106310 xmm0_30;
			word32 edi_133;
			word32 ebx_24 = runtime.init(gs, out esi_28, out edi_133, out xmm0_30);
			runtime.newobject(gs, 0x080CECA0);
			Eq_106281 ebx_24_8_71 = SLICE(ebx_24, word24, 8);
			if (g_t81576F0 == 0x00)
				g_t8144FE8 = dwLoc04;
			else
				runtime.writebarrierptr(0x08144FE8, dwLoc04);
			sync.init.0(gs);
			ptr32 edi_74 = sync.init.1(ebx_24_8_71, gs);
			g_b8157585 = 0x02;
			esiOut = esi_28;
			ediOut = edi_74;
			xmm0Out = xmm0_30;
			return ebx_24;
		}
		else
			runtime.throwinit(gs);
	}
	else
	{
		esiOut = esi;
		ediOut = edi;
		xmm0Out = xmm0;
		return ebx;
	}
}

// 0809C040: void io.init(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.init
//      os.init
//      fmt.init
void io.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157562;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157562 = 0x01;
		word32 esi_415;
		word32 edi_416;
		word128 xmm0_417;
		sync.init(gs, out esi_415, out edi_416, out xmm0_417);
		errors.New(gs, 0x080E1BCC, 11);
		g_t8145048 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814504C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814504C, dwLoc04);
		errors.New(gs, 0x080E1E07, 0x0C);
		g_t8145040 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145044 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145044, dwLoc04);
		errors.New(gs, 0x080E0E46, 0x03);
		g_t8145028 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814502C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814502C, dwLoc04);
		errors.New(gs, 135144012, 0x0E);
		g_t8145050 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145054 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145054, dwLoc04);
		errors.New(gs, 0x080E6B63, 0x2B);
		g_t8145038 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814503C = dwLoc04;
		else
			runtime.writebarrierptr(135548988, dwLoc04);
		errors.New(gs, 135147411, 0x14);
		g_t8145060 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145064 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145064, dwLoc04);
		errors.New(gs, 0x080E2F7F, 0x14);
		g_t8145058 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814505C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814505C, dwLoc04);
		errors.New(gs, 0x080E4B04, 0x1D);
		g_t8145030 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145034 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145034, dwLoc04);
		g_b8157562 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809C300: Register word32 syscall.SetNonblock(Register (ptr32 Eq_2) gs, Stack byte bArg08)
// Called from:
//      os.newFile
word32 syscall.SetNonblock(struct Eq_2 * gs, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_28 = syscall.fcntl(gs);
	if (dwLoc08 != 0x00)
		return esi_28;
	return syscall.fcntl(gs);
}

// 0809C3A0: void syscall.init.0(Register (ptr32 Eq_2) gs)
// Called from:
//      syscall.init
void syscall.init.0(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_dw8136030 = 0xDD;
}

// 0809C3D0: void syscall.itoa(Register (ptr32 Eq_2) gs, Stack Eq_106579 dwArg04)
// Called from:
//      syscall.Errno.Error
void syscall.itoa(struct Eq_2 * gs, Eq_106579 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 >= 0x00)
		syscall.uitoa(gs, dwLoc20);
	else
	{
		syscall.uitoa(gs, dwLoc20);
		runtime.concatstring2(gs, 0x00);
	}
}

// 0809C460: void syscall.uitoa(Register (ptr32 Eq_2) gs, Stack uint32 dwArg00)
// Called from:
//      syscall.itoa
void syscall.uitoa(struct Eq_2 * gs, uint32 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD88(0x00, fp - 0x20);
	uint32 ecx_23 = dwArg00;
	Eq_106623 eax_24 = 0x1F;
	while (ecx_23 >= 0x0A)
	{
		uint32 edx_70 = SLICE(ecx_23 * ~0x33333332, word32, 32);
		uint32 ecx_74 = ecx_23 - ((edx_70 >> 0x03) + (edx_70 >> 0x03) * 0x04 << 0x01);
		if (eax_24 >= 0x20)
			runtime.panicindex(gs);
		*((word32) eax_24 + (fp - 0x24)) = (byte) (ecx_74 + 0x30);
		--eax_24;
		ecx_23 = edx_70 >> 0x03;
	}
	if (eax_24 >= 0x20)
		runtime.panicindex(gs);
	else
	{
		Mem35[fp - 0x24 + eax_24:byte] = SLICE(ecx_23 + 0x30, byte, 0);
		Eq_4 ecx_38 = 0x20 - eax_24;
		runtime.slicebytetostring(gs, 0x00, fp - 0x24 + (eax_24 & -ecx_38 >> 0x1F), ecx_38);
	}
}

// 0809C520: void syscall.ByteSliceFromString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      syscall.BytePtrFromString
void syscall.ByteSliceFromString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_19 = 0x00;
	while (edx_19 < dwArg08)
	{
		if (edx_19 >= dwArg08)
			runtime.panicindex(gs);
		if (SLICE((word32) Mem0[dwArg04 + edx_19:byte], byte, 0) == 0x00)
			return;
		edx_19 = (word32) edx_19 + 1;
	}
	word32 edi_173;
	runtime.makeslice(gs, 0x080CF320, (word32) dwArg08 + 1, (word32) dwArg08 + 1, out edi_173);
	Eq_4 ebx_49 = dwArg08;
	if (dwLoc14 <= dwArg08)
		ebx_49 = dwLoc14;
	word32 esi_175;
	word32 edi_176;
	word32 ebp_174;
	runtime.memmove(dwLoc18, dwArg04, ebx_49, out ebp_174, out esi_175, out edi_176);
}

// 0809C620: void syscall.BytePtrFromString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      syscall.readlinkat
void syscall.BytePtrFromString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.ByteSliceFromString(gs, dwArg04, dwArg08);
	if (dwLoc08 != 0x00)
		return;
	if (dwLoc10 > 0x00)
		return;
	runtime.panicindex(gs);
}

// 0809C6A0: void syscall.Readlink(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      os.Readlink
void syscall.Readlink(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.readlinkat(gs, dwArg04, dwArg08, dwArg10);
}

// 0809C710: void syscall.mmap(Register (ptr32 Eq_2) gs, Stack ui32 dwArg18, Stack Eq_106779 dwArg1C)
void syscall.mmap(struct Eq_2 * gs, ui32 dwArg18, Eq_106779 dwArg1C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_22 = (dwArg1C >> 0x1F >> 0x14) + dwArg18;
	uint32 eax_29 = eax_22 >> 0x0C | (word32) dwArg1C.u0 + (eax_22 < 0x00) << 0x14;
	if ((byte) (SEQ(SLICE(eax_29 >> 0x14, word24, 8), dwArg1C != eax_29 >> 0x14) | SEQ(SLICE(eax_29 << 0x0C, word24, 8), dwArg18 != eax_29 << 0x0C)) != 0x00)
		return;
	syscall.mmap2(gs);
}

// 0809C7E0: void syscall.Errno.Error(Register (ptr32 Eq_2) gs, Stack Eq_106579 dwArg04)
// Called from:
//      syscall.(*Errno).Error
void syscall.Errno.Error(struct Eq_2 * gs, Eq_106579 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 < 133 && g_a8144B44[dwArg04] != 0x00)
		return;
	syscall.itoa(gs, dwArg04);
	runtime.concatstring2(gs, 0x00);
}

// 0809C880: void syscall.Write(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_106856) dwArg0C)
// Called from:
//      internal/poll.(*FD).Write
void syscall.Write(struct Eq_2 * gs, struct Eq_106856 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.write(gs, dwArg0C);
}

// 0809C8E0: void syscall.readlinkat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg14)
// Called from:
//      syscall.Readlink
void syscall.readlinkat(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.BytePtrFromString(gs, dwArg08, dwArg0C);
	if (dwLoc30 != 0x00)
		return;
	Eq_4 ebx_69 = syscall.Syscall6(gs, 0x0131);
	if (dwLoc18 == 0x00)
		return;
	if (dwLoc18 <= 0x02)
	{
		if (dwLoc18 == 0x02)
			return;
	}
	else if (dwLoc18 == 11 || dwLoc18 == 22)
		return;
	runtime.convT2I32(ebx_69, gs, &g_t81366B0, fp - 0x10);
}

// 0809CA30: void syscall.Close(Register (ptr32 Eq_2) gs)
void syscall.Close(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_29;
	Eq_4 ebx_25 = syscall.Syscall(gs, 0x06, out esi_29);
	if (dwLoc08 == 0x00)
		return;
	if (dwLoc08 <= 0x02)
	{
		if (dwLoc08 == 0x02)
			return;
	}
	else if (dwLoc08 == 11 || dwLoc08 == 22)
		return;
	runtime.convT2I32(ebx_25, gs, &g_t81366B0, fp - 0x04);
}

// 0809CAF0: Register Eq_4 syscall.fcntl(Register (ptr32 Eq_2) gs)
// Called from:
//      syscall.SetNonblock
Eq_4 syscall.fcntl(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_122;
	Eq_4 ebx_27 = syscall.Syscall(gs, 55, out esi_122);
	if (dwLoc0C == 0x00)
		return esi_122;
	if (dwLoc0C <= 0x02)
	{
		if (dwLoc0C == 0x02)
			return esi_122;
	}
	else if (dwLoc0C == 11 || dwLoc0C == 22)
		return esi_122;
	esi_122 = runtime.convT2I32(ebx_27, gs, &g_t81366B0, fp - 0x04);
	return esi_122;
}

// 0809CBC0: void syscall.write(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_106856) dwArg0C)
// Called from:
//      syscall.Write
void syscall.write(struct Eq_2 * gs, struct Eq_106856 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_137;
	Eq_4 ebx_33 = syscall.Syscall(gs, 0x04, out esi_137);
	if (dwLoc0C == 0x00)
		return;
	if (dwLoc0C <= 0x02)
	{
		if (dwLoc0C == 0x02)
			return;
	}
	else if (dwLoc0C == 11 || dwLoc0C == 22)
		return;
	runtime.convT2I32(ebx_33, gs, &g_t81366B0, fp - 0x04);
}

// 0809CCB0: void syscall.munmap(Register (ptr32 Eq_2) gs)
void syscall.munmap(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_30;
	Eq_4 ebx_26 = syscall.Syscall(gs, 0x5B, out esi_30);
	if (dwLoc08 == 0x00)
		return;
	if (dwLoc08 <= 0x02)
	{
		if (dwLoc08 == 0x02)
			return;
	}
	else if (dwLoc08 == 11 || dwLoc08 == 22)
		return;
	runtime.convT2I32(ebx_26, gs, &g_t81366B0, fp - 0x04);
}

// 0809CD70: void syscall.mmap2(Register (ptr32 Eq_2) gs)
// Called from:
//      syscall.mmap
void syscall.mmap2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_33 = syscall.Syscall6(gs, 0xC0);
	if (dwLoc0C == 0x00)
		return;
	if (dwLoc0C <= 0x02)
	{
		if (dwLoc0C == 0x02)
			return;
	}
	else if (dwLoc0C == 11 || dwLoc0C == 22)
		return;
	runtime.convT2I32(ebx_33, gs, &g_t81366B0, fp - 0x04);
}

// 0809CE60: void syscall.init(Register (ptr32 Eq_2) gs)
// Called from:
//      time.init
//      internal/poll.init
//      os.init
void syscall.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157586;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157586 = 0x01;
		word128 xmm0_216;
		word32 edi_215;
		word32 esi_214;
		sync.init(gs, out esi_214, out edi_215, out xmm0_216);
		word128 xmm0_219;
		word32 edi_218;
		word32 esi_217;
		runtime.init(gs, out esi_217, out edi_218, out xmm0_219);
		Eq_4 edi_51;
		Eq_4 esi_53;
		Eq_6606 ebx_24_8_88 = SLICE(syscall.runtime_envs(gs, out esi_53, out edi_51), word24, 8);
		g_dw814518C = dwLoc14;
		g_dw8145190 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t8145188 = dwLoc18;
		else
			runtime.writebarrierptr(0x08145188, dwLoc18);
		word128 xmm1_222;
		word128 xmm0_221;
		word32 edi_220;
		runtime.makemap(ebx_24_8_88, esi_53, edi_51, gs, 0x080CFA00, 0x00, 0x00, 0x00, 0x00, out edi_220, out xmm0_221, out xmm1_222);
		if (g_t81576F0 == 0x00)
			g_t8142778 = dwLoc04;
		else
			runtime.writebarrierptr(135538552, dwLoc04);
		syscall.init.0(gs);
		g_b8157586 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809CF60: Register word32 syscall.Syscall(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Register out ptr32 esiOut)
// Called from:
//      syscall.Close
//      syscall.fcntl
//      syscall.write
//      syscall.munmap
word32 syscall.Syscall(struct Eq_2 * gs, up32 dwArg04, ptr32 & esiOut)
{
	runtime.entersyscall(gs);
	__syscall(0x80);
	if (dwArg04 <= ~0x0FFE)
	{
		ptr32 esi_33;
		word32 ebx_29 = runtime.exitsyscall(gs, out esi_33);
		esiOut = esi_33;
		return ebx_29;
	}
	else
	{
		ptr32 esi_50;
		word32 ebx_46 = runtime.exitsyscall(gs, out esi_50);
		esiOut = esi_50;
		return ebx_46;
	}
}

// 0809CFC0: Register word32 syscall.Syscall6(Register (ptr32 Eq_2) gs, Stack up32 dwArg04)
// Called from:
//      syscall.readlinkat
//      syscall.mmap2
word32 syscall.Syscall6(struct Eq_2 * gs, up32 dwArg04)
{
	runtime.entersyscall(gs);
	__syscall(0x80);
	if (dwArg04 <= ~0x0FFE)
	{
		word32 esi_84;
		return runtime.exitsyscall(gs, out esi_84);
	}
	else
	{
		word32 esi_85;
		return runtime.exitsyscall(gs, out esi_85);
	}
}

// 0809D020: void syscall.(*Errno).Error(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_106579) dwArg04)
void syscall.(*Errno).Error(struct Eq_2 * gs, union Eq_106579 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x0C;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		syscall.Errno.Error(gs, *dwArg04);
}

// 0809D080: void type..hash.[133]string(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[133]string(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 133; ++eax_17)
	{
		runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 0809D0E0: void type..eq.[133]string(Register (ptr32 Eq_107290) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[133]string(struct Eq_107290 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 133; ++eax_17)
	{
		struct Eq_107309 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_107313 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 esi_129;
		word32 edi_130;
		runtime.eqstring(esi_35, edi_34, edx_33, out esi_129, out edi_130);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 0809D160: void time.init(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.init
//      os.init
void time.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157587;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157587 = 0x01;
		syscall.init(gs);
		word32 esi_706;
		word32 edi_707;
		word128 xmm0_708;
		sync.init(gs, out esi_706, out edi_707, out xmm0_708);
		Eq_4 edi_53;
		Eq_4 esi_55;
		word128 xmm0_709;
		Eq_6606 ebx_24_8_166 = SLICE(runtime.init(gs, out esi_55, out edi_53, out xmm0_709), word24, 8);
		errors.New(gs, 0x080E3213, 0x14);
		g_dw81450C0 = dwLoc18;
		if (g_t81576F0 == 0x00)
			g_t81450C4 = dwLoc14;
		else
			runtime.writebarrierptr(0x081450C4, dwLoc14);
		errors.New(gs, 0x080E2C56, 0x13);
		g_dw81450D0 = dwLoc18;
		if (g_t81576F0 == 0x00)
			g_t81450D4 = dwLoc14;
		else
			runtime.writebarrierptr(0x081450D4, dwLoc14);
		errors.New(gs, 135145081, 0x10);
		g_dw81450D8 = dwLoc18;
		if (g_t81576F0 == 0x00)
			g_t81450DC = dwLoc14;
		else
			runtime.writebarrierptr(135549148, dwLoc14);
		word128 xmm0_711;
		word128 xmm1_712;
		word32 edi_710;
		runtime.makemap(ebx_24_8_166, esi_55, edi_53, gs, 0x080CFB80, 0x08, 0x00, 0x00, 0x00, out edi_710, out xmm0_711, out xmm1_712);
		word128 xmm1_715;
		word32 esi_713;
		word32 edi_714;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_713, out edi_714, out xmm1_715);
		null = (union Eq_4 *) 0x01;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 esi_716;
		word32 edi_717;
		word128 xmm1_718;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_716, out edi_717, out xmm1_718);
		null = (union Eq_4 *) 1000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word128 xmm1_721;
		word32 edi_720;
		word32 esi_719;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_719, out edi_720, out xmm1_721);
		null = (union Eq_4 *) 1000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 esi_722;
		word32 edi_723;
		word128 xmm1_724;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_722, out edi_723, out xmm1_724);
		null = (union Eq_4 *) 1000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word128 xmm1_727;
		word32 edi_726;
		word32 esi_725;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_725, out edi_726, out xmm1_727);
		null = (union Eq_4 *) 1000000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 edi_729;
		word128 xmm1_730;
		word32 esi_728;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_728, out edi_729, out xmm1_730);
		null = (union Eq_4 *) 1000000000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 esi_731;
		word32 edi_732;
		word128 xmm1_733;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_731, out edi_732, out xmm1_733);
		null = (union Eq_4 *) 4165425152;
		((union Eq_4 *) 0x04)->u0 = 0x0D;
		word32 esi_734;
		word32 edi_735;
		word128 xmm1_736;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_734, out edi_735, out xmm1_736);
		null = (union Eq_4 *) 0x30B8A000;
		((union Eq_4 *) 0x04)->u0 = 838;
		if (g_t81576F0 == 0x00)
			g_t8144FEC = dwLoc0C;
		else
			runtime.writebarrierptr(135548908, dwLoc0C);
		errors.New(gs, 135153170, 0x1B);
		g_ptr81450E0 = 0x080E0DA0;
		if (g_t81576F0 == 0x00)
			g_dw81450E4 = 0x01;
		else
			runtime.writebarrierptr(0x081450E4, 0x01);
		errors.New(gs, 0x080E518B, 0x1F);
		g_ptr81450C8 = 0x080E0DA0;
		if (g_t81576F0 == 0x00)
			g_dw81450CC = 0x01;
		else
			runtime.writebarrierptr(0x081450CC, 0x01);
		runtime.GOROOT(gs);
		runtime.concatstring2(gs, 0x00);
		g_dw81442BC = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t81442B8 = dwLoc0C;
		else
			runtime.writebarrierptr(135545528, dwLoc0C);
		g_b8157587 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809D5E0: void internal/poll.(*TimeoutError).Error(Register (ptr32 Eq_107641) gs)
void internal/poll.(*TimeoutError).Error(struct Eq_107641 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 0809D610: void internal/poll.(*fdMutex).increfAndClose(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).Close
void internal/poll.(*fdMutex).increfAndClose(struct Eq_2 * gs, Eq_4 dwArg04)
{
	ui32 dwLoc20 = SLICE(qwLoc24, word32, 32);
	uint32 dwLoc24 = (word32) qwLoc24;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		sync/atomic.LoadUint64(dwArg04);
		if ((dwLoc24 & 0x01) != 0x00)
			return;
		uint32 ecx_41 = (dwLoc24 | 0x01) + 0x08;
		ui32 eax_45 = (bool) (ecx_41 < 0x00) + dwLoc20;
		if ((byte) (SEQ(SLICE(ebp, word24, 8), (ecx_41 & 0x007FFFF8) == 0x00) & 0x01) != 0x00)
			runtime.gopanic(gs);
		word32 ebx_98;
		ui24 edx_24_8_120 = SLICE(sync/atomic.CompareAndSwapUint64(dwArg04, qwLoc24, SEQ(eax_45 & 0x80000000, ecx_41 & 0x007FFFFF), out ebx_98), word24, 8);
		ui24 ebx_24_8_122 = SLICE(ebx_98, word24, 8);
		ebp = ebp_97;
	} while ((byte) (word32) bLoc14 == 0x00);
	uint32 eax_110 = dwLoc24;
	ui32 ecx_111 = dwLoc20;
	while ((byte) (SEQ(edx_24_8_120, (ecx_111 & 0x07FF) != 0x00) | SEQ(ebx_24_8_122, (eax_110 & 0xFF800000) != 0x00)) != 0x00)
	{
		ebx_24_8_122 = SLICE((word32) dwArg04 + 8, word24, 8);
		edx_24_8_120 = SLICE(internal/poll.runtime_Semrelease(gs), word24, 8);
		ecx_111 = ecx_111 + ~0x00 + (eax_110 < 0xFF800000);
		eax_110 += 0xFF800000;
	}
	while ((ecx_111 & 0x7FFFF800) != 0x00)
	{
		internal/poll.runtime_Semrelease(gs);
		ecx_111 = ecx_111 + ~0x07FF + (eax_110 < 0x00);
	}
}

// 0809D770: void internal/poll.(*fdMutex).decref(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).decref
void internal/poll.(*fdMutex).decref(struct Eq_2 * gs, Eq_4 dwArg04)
{
	word32 dwLoc14 = SLICE(qwLoc18, word32, 32);
	uint32 dwLoc18 = (word32) qwLoc18;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx_24_8 = SLICE(runtime.morestack_noctxt(), word24, 8);
	do
	{
		sync/atomic.LoadUint64(dwArg04);
		if ((byte) (SEQ(edx_24_8, (dwLoc18 & 0x007FFFF8) == 0x00) & 0x01) != 0x00)
			runtime.gopanic(gs);
		word32 ebx_133;
		edx_24_8 = SLICE(sync/atomic.CompareAndSwapUint64(dwArg04, qwLoc18, SEQ((bool) (dwLoc18 < ~0x07) + (dwLoc14 + ~0x00), dwLoc18 + ~0x07), out ebx_133), word24, 8);
	} while ((byte) (word32) bLoc08 == 0x00);
}

// 0809D820: void internal/poll.(*fdMutex).rwlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*FD).writeLock
void internal/poll.(*fdMutex).rwlock(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	word32 dwLoc2C = SLICE(qwLoc30, word32, 32);
	ui32 dwLoc30 = (word32) qwLoc30;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 ebp_ebx_363;
	Eq_4 ecx_25;
	ui32 edi_32;
	ui32 esi_31;
	ui32 edx_26;
	if ((byte) (word32) bArg08 != 0x00)
	{
		ecx_25 = (word32) dwArg04 + 8;
		edx_26 = 0x02;
		esi_31 = 0x07FF;
		edi_32 = 0xFF800000;
		ebp_ebx_363 = 0x00800000;
	}
	else
	{
		ecx_25 = (word32) dwArg04 + 0x0C;
		edx_26 = 0x04;
		esi_31 = 0x7FFFF800;
		edi_32 = 0x00;
		ebp_ebx_363 = 0x80000000000;
	}
	word32 ebp_154 = SLICE(ebp_ebx_363, word32, 32);
	word32 ebx_361 = (word32) ebp_ebx_363;
	edi_128 = edi_32;
	while (true)
	{
		ui32 edi_128;
		sync/atomic.LoadUint64(dwArg04);
		ui24 ebx_24_8_82 = SLICE(ebx_361, word24, 8);
		if ((dwLoc30 & 0x01) != 0x00)
			break;
		Eq_136 eax_ecx_366;
		byte bl_85 = (byte) (SEQ(ebx_24_8_82, (edx_26 & dwLoc30) == 0x00) & 0x01);
		if (bl_85 != 0x00)
		{
			uint32 ecx_148 = dwLoc30 | edx_26;
			eax_ecx_366 = SEQ(dwLoc2C + (ecx_148 < 0x08), ecx_148 + 0x08);
			if ((byte) (SEQ(SLICE(ebp_154, word24, 8), (ecx_148 + 0x08 & 0x007FFFF8) == 0x00) & 0x01) != 0x00)
				runtime.gopanic(gs);
		}
		else
		{
			Eq_136 eax_ecx_254 = (word64) qwLoc30 + ebp_ebx_363;
			ui32 edi_120 = SEQ(SLICE(esi_31, word24, 8), (esi_31 & SLICE(eax_ecx_254, word32, 32)) == 0x00) & SEQ(SLICE(edi_32, word24, 8), (edi_32 & (word32) eax_ecx_254) == 0x00);
			edi_128 = edi_120;
			if ((byte) edi_120 != 0x00)
				runtime.gopanic(gs);
			eax_ecx_366 = eax_ecx_254;
		}
		word32 ebx_202;
		sync/atomic.CompareAndSwapUint64(dwArg04, qwLoc30, eax_ecx_366, out ebx_202);
		ebp_154 = ebp_201;
		if ((byte) (word32) bLoc20 != 0x00)
		{
			if ((byte) (word32) bl_85 != 0x00)
				return;
			edi_128 = internal/poll.runtime_Semacquire(edi_128, gs, ecx_25);
			ebp_154 = ebp_228;
			ebx_202 = ebx_229;
		}
		ebx_361 = ebx_202;
	}
}

// 0809D9B0: void internal/poll.(*fdMutex).rwunlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*FD).writeUnlock
void internal/poll.(*fdMutex).rwunlock(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	ui32 dwLoc30 = SLICE(qwLoc34, word32, 32);
	ui32 dwLoc34 = (word32) qwLoc34;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ebp_30;
	ui32 ebx_27;
	uint32 edi_32;
	ui32 edx_26;
	ui32 esi_31;
	if ((byte) (word32) bArg08 != 0x00)
	{
		edx_26 = 0x02;
		ebx_27 = 0xFF800000;
		ebp_30 = 0x07FF;
		esi_31 = 0x00;
		edi_32 = 0x00800000;
	}
	else
	{
		edx_26 = 0x04;
		ebx_27 = 0x00;
		ebp_30 = 0x7FFFF800;
		esi_31 = 0x0800;
		edi_32 = 0x00;
	}
	word24 ebx_24_8_219 = SLICE(ebx_27, word24, 8);
	do
	{
		sync/atomic.LoadUint64(dwArg04);
		ui32 ebx_77 = SEQ(ebx_24_8_219, (edx_26 & dwLoc34) == 0x00);
		ui24 ecx_24_8_135 = SLICE(dwLoc34, word24, 8);
		ui24 ebx_24_8_86 = SLICE(ebx_77 & 0x01, word24, 8);
		if ((byte) (ebx_77 & 0x01) != 0x00 || (byte) (SEQ(ebx_24_8_86, (dwLoc34 & 0x007FFFF8) == 0x00) & 0x01) != 0x00)
			runtime.gopanic(gs);
		uint32 edx_113 = ~edx_26 & dwLoc34;
		ui32 ebp_137 = SEQ(SLICE(dwLoc30, word24, 8), (ebp_30 & dwLoc30) != 0x00) | SEQ(ecx_24_8_135, (ebx_27 & dwLoc34) != 0x00);
		ui32 eax_118 = dwLoc30 + ~0x00 + (edx_113 < ~0x07);
		byte al_141 = (byte) ebp_137;
		Eq_136 eax_edx_297 = SEQ(eax_118, edx_113 + ~0x07);
		if ((byte) ebp_137 != 0x00)
		{
			uint32 edx_157 = edx_113 + ~0x07 - edi_32;
			eax_edx_297 = SEQ(eax_118 - esi_31 - (edx_157 < 0x00), edx_157);
		}
		word32 ebx_173;
		sync/atomic.CompareAndSwapUint64(dwArg04, qwLoc34, eax_edx_297, out ebx_173);
		ebx_24_8_219 = SLICE(ebx_173, word24, 8);
	} while ((byte) (word32) bLoc24 == 0x00);
	if ((byte) (word32) al_141 != 0x00)
		internal/poll.runtime_Semrelease(gs);
}

// 0809DB30: Register word32 internal/poll.(*FD).decref(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).Close
word32 internal/poll.(*FD).decref(struct Eq_2 * gs, Eq_4 dwArg04)
{
	byte bLoc08 = (byte) dwLoc08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*fdMutex).decref(gs, dwArg04);
	if ((byte) (word32) bLoc08 == 0x00)
		return esi;
	return internal/poll.(*FD).destroy(gs, dwArg04);
}

// 0809DBA0: void internal/poll.(*FD).writeLock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).Write
void internal/poll.(*FD).writeLock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*fdMutex).rwlock(gs, dwArg04, 0x00);
	if ((byte) (word32) bLoc04 != 0x00)
		return;
	(byte) (word32) *((word32) dwArg04 + 30) == 0x00;
}

// 0809DC20: void internal/poll.(*FD).writeUnlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void internal/poll.(*FD).writeUnlock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*fdMutex).rwunlock(gs, dwArg04, 0x00);
	if ((byte) (word32) bLoc04 != 0x00)
		internal/poll.(*FD).destroy(gs, dwArg04);
}

// 0809DC70: Register Eq_4 internal/poll.(*pollDesc).init(Register (ptr32 Eq_2) gs, Stack (ptr32 ptr32) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      internal/poll.(*FD).Init
Eq_4 internal/poll.(*pollDesc).init(struct Eq_2 * gs, ptr32 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_43;
	Eq_4 ebx_100 = internal/poll.runtime_pollOpen(sync.(*Once).Do(gs, 0x081576D0, &g_ptr80E7B18), gs, *((word32) dwArg08 + 16), out esi_43);
	if (dwLoc14 == 0x00)
	{
		*dwArg04 = 0x080E7B18;
		return esi_43;
	}
	else
	{
		if (true)
		{
			internal/poll.runtime_pollUnblock(esi_43, gs, &g_ptr80E7B18);
			word32 esi_167;
			ebx_100 = internal/poll.runtime_pollClose(gs, 0x080E7B18, out esi_167);
		}
		return runtime.convT2I32(ebx_100, gs, &g_t81366B0, fp - 0x04);
	}
}

// 0809DD40: Register word32 internal/poll.(*pollDesc).close(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4) dwArg04)
// Called from:
//      internal/poll.(*FD).destroy
word32 internal/poll.(*pollDesc).close(struct Eq_2 * gs, union Eq_4 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 == 0x00)
		return esi;
	word32 esi_29;
	internal/poll.runtime_pollClose(gs, ecx_18, out esi_29);
	*dwArg04 = (union Eq_4 *) 0x00;
	return esi_29;
}

// 0809DD80: void internal/poll.(*pollDesc).evict(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_41907)) dwArg04)
// Called from:
//      internal/poll.(*FD).Close
void internal/poll.(*pollDesc).evict(Eq_4 esi, struct Eq_2 * gs, struct Eq_41907 ** dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_41907 * eax_18 = *dwArg04;
	if (eax_18 == null)
		return;
	internal/poll.runtime_pollUnblock(esi, gs, eax_18);
}

// 0809DDC0: void internal/poll.(*pollDesc).prepare(Register ui32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_41647)) dwArg04, Stack word32 dwArg08, Stack byte bArg0C)
// Called from:
//      internal/poll.(*pollDesc).prepareWrite
void internal/poll.(*pollDesc).prepare(ui32 ebp, struct Eq_2 * gs, struct Eq_41647 ** dwArg04, word32 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_41647 * eax_18 = *dwArg04;
	if (eax_18 == null)
		return;
	internal/poll.convertErr(SLICE(internal/poll.runtime_pollReset(ebp, gs, eax_18, dwArg08), word24, 8), gs, dwLoc08, (byte) (word32) bArg0C);
}

// 0809DE40: void internal/poll.(*pollDesc).prepareWrite(Register ui32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_41647)) dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*FD).Write
void internal/poll.(*pollDesc).prepareWrite(ui32 ebp, struct Eq_2 * gs, struct Eq_41647 ** dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*pollDesc).prepare(ebp, gs, dwArg04, 0x77, (byte) (word32) bArg08);
}

// 0809DE90: void internal/poll.(*pollDesc).wait(Register (ptr32 Eq_41738) ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 word32) dwArg04, Stack (ptr32 Eq_41741) dwArg08, Stack byte bArg0C)
// Called from:
//      internal/poll.(*pollDesc).waitWrite
void internal/poll.(*pollDesc).wait(struct Eq_41738 * ebp, struct Eq_2 * gs, word32 * dwArg04, struct Eq_41741 * dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_41740 * eax_18 = *dwArg04;
	if (eax_18 != null)
		internal/poll.convertErr(SLICE(internal/poll.runtime_pollWait(ebp, gs, eax_18, dwArg08), word24, 8), gs, dwLoc0C, (byte) (word32) bArg0C);
	else
	{
		runtime.newobject(gs, 0x080D1920);
		*((word32) dwLoc10 + 4) = 33;
		if (g_t81576F0 == 0x00)
			*dwLoc10 = 0x080E58FE;
		else
			runtime.writebarrierptr(dwLoc10, 0x080E58FE);
	}
}

// 0809DF50: void internal/poll.(*pollDesc).waitWrite(Register (ptr32 Eq_41738) ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 word32) dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*FD).Write
void internal/poll.(*pollDesc).waitWrite(struct Eq_41738 * ebp, struct Eq_2 * gs, word32 * dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*pollDesc).wait(ebp, gs, dwArg04, (struct Eq_41741 *) 0x77, (byte) (word32) bArg08);
}

// 0809DFA0: void internal/poll.convertErr(Register Eq_108282 ebx, Register (ptr32 Eq_2) gs, Stack Eq_108284 dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*pollDesc).prepare
//      internal/poll.(*pollDesc).wait
void internal/poll.convertErr(Eq_108282 ebx, struct Eq_2 * gs, Eq_108284 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	if (dwArg04 == 0x01)
		return;
	if (dwArg04 == 0x02)
		return;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, SEQ(dwArg04 >> 0x1F, dwArg04));
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.gopanic(gs);
}

// 0809E090: Register word32 internal/poll.(*FD).Init(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 word32) dwArg08, Stack word32 dwArg0C, Stack byte bArg10)
// Called from:
//      os.newFile
word32 internal/poll.(*FD).Init(struct Eq_2 * gs, Eq_4 dwArg04, word32 * dwArg08, word32 dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x04 && *dwArg08 == 0x656C6966)
		*((word32) dwArg04 + 30) = 0x01;
	if ((byte) (word32) bArg10 == 0x00)
		return esi;
	return internal/poll.(*pollDesc).init(gs, (word32) dwArg04 + 20, dwArg04);
}

// 0809E120: Register word32 internal/poll.(*FD).destroy(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).decref
//      internal/poll.(*FD).writeUnlock
word32 internal/poll.(*FD).destroy(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_29 = internal/poll.(*pollDesc).close(gs, (word32) dwArg04 + 20);
	<anonymous> ** edx_35 = g_ptr81422A0;
	<anonymous> * ecx_39 = *edx_35;
	ecx_39();
	((word32) dwArg04 + 16)->u0 = ~0x00;
	return esi_29;
}

// 0809E180: Register Eq_4 internal/poll.(*FD).Close(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      os.(*file).close
Eq_4 internal/poll.(*FD).Close(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	byte bLoc08 = (byte) dwLoc08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*fdMutex).increfAndClose(gs, dwArg04);
	if ((byte) (word32) bLoc08 != 0x00)
	{
		internal/poll.(*pollDesc).evict(esi, gs, (word32) dwArg04 + 20);
		return internal/poll.(*FD).decref(gs, dwArg04);
	}
	else
	{
		(byte) (word32) *((word32) dwArg04 + 30) == 0x00;
		return esi;
	}
}

// 0809E220: void internal/poll.(*FD).Write(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_41738) dwArg0C, Stack (ptr32 Eq_41738) dwArg10)
// Called from:
//      os.(*File).write
void internal/poll.(*FD).Write(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_41738 * dwArg0C, struct Eq_41738 * dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*FD).writeLock(gs, dwArg04);
	if (dwLoc28 != 0x00)
		runtime.deferreturn(gs);
	else
	{
		ui32 ebp_62;
		word32 edi_494;
		word32 esi_493;
		if (runtime.deferproc(gs, 0x04, 0x080E7B14, dwArg04, out ebp_62, out esi_493, out edi_494) != 0x00)
			runtime.deferreturn(gs);
		else
		{
			internal/poll.(*pollDesc).prepareWrite(ebp_62, gs, (word32) dwArg04 + 20, (byte) (word32) *((word32) dwArg04 + 30));
			if (dwArg04 != 0x00)
				runtime.deferreturn(gs);
			else
			{
				struct Eq_41738 * eax_126 = null;
				while (true)
				{
					struct Eq_41738 * edx_145;
					if ((byte) (word32) *((word32) dwArg04 + 28) != 0x00 && dwArg0C - eax_126 > 0x40000000)
						edx_145 = &eax_126->ptr0004 + 0x0FFFFFFF;
					else
						edx_145 = dwArg0C;
					if (eax_126 > edx_145 || edx_145 > dwArg10)
						break;
					struct Eq_41738 * ebx_203;
					struct Eq_106856 * edx_182 = edx_145 - eax_126;
					syscall.Write(gs, edx_182);
					struct Eq_106856 * eax_198 = dwLoc18;
					if (dwLoc1C > null)
						ebx_203 = eax_126 + dwLoc1C;
					else
						ebx_203 = eax_126;
					if (ebx_203 == dwArg0C)
					{
						runtime.deferreturn(gs);
						return;
					}
					if (dwLoc18 != null && dwLoc18->ptr0004 == 0x080D5060)
					{
						eax_198 = dwLoc18;
						if (*dwLoc14 != 11)
							goto l0809E38F;
						eax_198 = dwLoc18;
						if (*((word32) dwArg04 + 20) == 0x00)
							goto l0809E38F;
						internal/poll.(*pollDesc).waitWrite(dwArg0C, gs, (word32) dwArg04 + 20, (byte) (word32) *((word32) dwArg04 + 30));
						if (edx_182 == null)
							goto l0809E2C2;
						eax_198 = edx_182;
					}
l0809E38F:
					if (eax_198 != null)
					{
						runtime.deferreturn(gs);
						return;
					}
					if (dwLoc1C == null)
					{
						runtime.deferreturn(gs);
						return;
					}
l0809E2C2:
					eax_126 = ebx_203;
				}
				runtime.panicslice(gs);
			}
		}
	}
}

// 0809E4C0: void internal/poll.init(Register (ptr32 Eq_2) gs)
// Called from:
//      os.init
void internal/poll.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157561;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157561 = 0x01;
		word128 xmm0_222;
		word32 esi_220;
		word32 edi_221;
		sync.init(gs, out esi_220, out edi_221, out xmm0_222);
		syscall.init(gs);
		time.init(gs);
		io.init(gs);
		errors.New(gs, 0x080E5563, 0x20);
		g_t8145020 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145024 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145024, dwLoc04);
		errors.New(gs, 0x080E2B02, 0x12);
		g_t8145018 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814501C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814501C, dwLoc04);
		g_b8157561 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809E5C0: void type..hash.internal/poll.FD(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
// Called from:
//      type..hash.os.file
void type..hash.internal/poll.FD(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x1F);
}

// 0809E610: void type..eq.internal/poll.FD(Register (ptr32 Eq_108756) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      type..eq.os.file
void type..eq.internal/poll.FD(struct Eq_108756 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 esi_56;
	word32 edi_57;
	runtime.memequal(dwArg04, dwArg08, 0x1F, out esi_56, out edi_57);
}

// 0809E660: void os.(*PathError).Error(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_108779) dwArg04)
void os.(*PathError).Error(struct Eq_2 * gs, struct Eq_108779 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_20 = dwArg04->dw0014;
	<anonymous> * ecx_21 = dwArg04->ptr0010->ptr0014;
	ecx_21();
	word32 ecx_29 = dwArg04->dw0000;
	word32 edx_30 = dwArg04->dw0004;
	runtime.concatstring5(gs, 0x00);
}

// 0809E710: void os.(*File).Name(Register (ptr32 Eq_108814) gs)
void os.(*File).Name(struct Eq_108814 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 0809E740: void os.(*File).Write(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4) dwArg04, Stack (ptr32 Eq_41738) dwArg0C, Stack (ptr32 Eq_41738) dwArg10)
void os.(*File).Write(struct Eq_2 * gs, union Eq_4 * dwArg04, struct Eq_41738 * dwArg0C, struct Eq_41738 * dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_21;
	if (dwArg04 != null)
		edx_21.u0 = 0x00;
	else
		edx_21 = g_t8145078;
	if (edx_21 != 0x00)
		return;
	os.(*File).write(gs, dwArg04, dwArg0C, dwArg10);
	byte bLoc30_311 = (byte) dwArg10;
	struct Eq_41738 * eax_60 = dwLoc2C;
	if (dwLoc2C < null)
		eax_60 = null;
	os.epipecheck(gs, dwArg04, dwLoc28, dwLoc24);
	Eq_4 dwLoc38_304 = dwLoc28;
	if (dwLoc28 == 0x00)
		return;
	if (g_t8145028 == dwLoc28)
	{
		runtime.ifaceeq(gs, dwLoc28, dwLoc24, g_t814502C);
		dwLoc38_304 = dwLoc24;
		if ((byte) (word32) bLoc30_311 != 0x00)
			return;
	}
	Eq_4 ecx_161;
	Eq_4 eax_139 = dwLoc28;
	if (g_t8145018 != dwLoc28)
		ecx_161 = dwLoc24;
	else
	{
		runtime.ifaceeq(gs, dwLoc28, dwLoc24, g_t814501C);
		dwLoc38_304 = dwLoc24;
		if ((byte) (word32) bLoc30_311 != 0x00)
		{
			eax_139 = g_t8145068;
			ecx_161 = g_t814506C;
		}
		else
		{
			ecx_161 = dwLoc24;
			eax_139 = dwLoc28;
		}
	}
	runtime.newobject(gs, 0x080D57C0);
	*((word32) dwLoc38_304 + 4) = 0x05;
	if (g_t81576F0 == 0x00)
		*dwLoc38_304 = 0x080E1065;
	else
		runtime.writebarrierptr(dwLoc38_304, 0x080E1065);
	Eq_4 ecx_205 = *dwArg04;
	Eq_4 edx_206 = *((word32) ecx_205 + 32);
	*((word32) dwLoc38_304 + 0x0C) = *((word32) ecx_205 + 36);
	Eq_4 ebx_211 = (word32) dwLoc38_304 + 8;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc38_304 + 8) = edx_206;
	else
		runtime.writebarrierptr(ebx_211, edx_206);
	*((word32) dwLoc38_304 + 16) = eax_139;
	Eq_4 edx_233 = (word32) dwLoc38_304 + 20;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc38_304 + 20) = ecx_161;
	else
		runtime.writebarrierptr(edx_233, ecx_161);
}

// 0809E9A0: void os.Readlink(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      os.glob..func1
void os.Readlink(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_172 = 0x80;
	while (true)
	{
		word32 edi_318;
		runtime.makeslice(gs, 0x080CF320, eax_172, eax_172, out edi_318);
		syscall.Readlink(gs, dwArg04, dwArg08, dwLoc28);
		dwLoc2C = dwLoc28;
		dwLoc28 = dwLoc24;
		Eq_4 ecx_169 = dwLoc24;
		if (dwLoc24 < 0x00)
			ecx_169.u0 = 0x00;
		if (dwLoc20 != 0x00)
			break;
		if (ecx_169 < eax_172)
		{
			if (ecx_169 > dwLoc24)
				runtime.panicslice(gs);
			else
			{
				runtime.slicebytetostring(gs, 0x00, dwLoc2C, ecx_169);
				return;
			}
		}
		eax_172 <<= 0x01;
	}
	runtime.newobject(gs, 0x080D57C0);
	*((word32) dwArg08 + 4) = 0x08;
	if (g_t81576F0 == 0x00)
		*dwArg08 = 135140565;
	else
		runtime.writebarrierptr(dwArg08, 135140565);
	*((word32) dwArg08 + 0x0C) = dwArg08;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 8) = dwArg04;
	else
		runtime.writebarrierptr((word32) dwArg08 + 8, dwArg04);
	*((word32) dwArg08 + 16) = dwLoc20;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 20) = dwLoc1C;
	else
		runtime.writebarrierptr((word32) dwArg08 + 20, dwLoc1C);
}

// 0809EB70: void os.NewFile(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      os.init
void os.NewFile(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	os.newFile(gs, dwArg04, dwArg08, dwArg0C, 0x00);
}

// 0809EBC0: void os.newFile(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10)
// Called from:
//      os.NewFile
void os.newFile(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 < 0x00)
		return;
	runtime.newobject(gs, 0x080D4820);
	runtime.newobject(gs, 0x080D69A0);
	*((word32) dwLoc1C + 16) = dwArg04;
	((word32) dwLoc1C + 28)->u1 = 0x0101;
	*((word32) dwLoc1C + 36) = dwArg0C;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc1C + 32) = dwArg08;
	else
		runtime.writebarrierptr((word32) dwLoc1C + 32, dwArg08);
	if (g_t81576F0 == 0x00)
		*dwLoc1C = dwLoc1C;
	else
		runtime.writebarrierptr(dwLoc1C, dwLoc1C);
	Eq_4 esi_116 = internal/poll.(*FD).Init(gs, dwLoc1C, &g_dw80E0F22, 0x04, (byte) (word32) bArg10);
	if (dwLoc10 == 0x00 && (byte) ((word32) bArg10) != 0x00)
	{
		esi_116 = syscall.SetNonblock(gs, 0x01);
		if (false)
			((word32) *dwLoc1C + 44)->u0 = 0x01;
	}
	runtime.SetFinalizer(esi_116, gs, 0x080D0640, *dwLoc1C, 0x080CDEA0);
}

// 0809ED30: void os.epipecheck(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      os.(*File).Write
void os.epipecheck(struct Eq_2 * gs, union Eq_4 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 != 0x00 && (*((word32) dwArg08 + 4) == 0x080D5060 && *dwArg0C == 0x20))
	{
		Eq_4 eax_30 = *((char *) *dwArg04 + 16);
		if (eax_30 == 0x01 || eax_30 == 0x02)
			os.sigpipe(gs);
	}
}

// 0809ED90: void os.(*file).close(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void os.(*file).close(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	Eq_4 esi_36 = internal/poll.(*FD).Close(esi, gs, dwArg04);
	Eq_4 eax_43 = dwLoc20;
	Eq_4 ecx_44 = dwLoc1C;
	if (dwLoc20 != 0x00)
	{
		if (dwLoc20 == g_t8145018)
		{
			runtime.ifaceeq(gs, dwLoc20, dwLoc1C, g_t814501C);
			dwLoc20 = dwLoc1C;
			if ((byte) (word32) bLoc18 != 0x00)
			{
				eax_43 = g_t8145068;
				ecx_44 = g_t814506C;
			}
			else
			{
				ecx_44 = dwLoc1C;
				eax_43 = dwLoc20;
			}
		}
		runtime.newobject(gs, 0x080D57C0);
		*((word32) dwLoc20 + 4) = 0x05;
		if (g_t81576F0 == 0x00)
			*dwLoc20 = 135139369;
		else
			runtime.writebarrierptr(dwLoc20, 135139369);
		Eq_4 edx_117 = *((word32) dwArg04 + 32);
		*((word32) dwLoc20 + 0x0C) = *((word32) dwArg04 + 36);
		Eq_4 ebp_122 = (word32) dwLoc20 + 8;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc20 + 8) = edx_117;
		else
			runtime.writebarrierptr(ebp_122, edx_117);
		*((word32) dwLoc20 + 16) = eax_43;
		Eq_4 ebx_145 = (word32) dwLoc20 + 20;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc20 + 20) = ecx_44;
		else
			runtime.writebarrierptr(ebx_145, ecx_44);
	}
	runtime.SetFinalizer(esi_36, gs, 0x080D0640, dwArg04, 0x00);
}

// 0809EF60: void os.(*File).write(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4) dwArg04, Stack (ptr32 Eq_41738) dwArg0C, Stack (ptr32 Eq_41738) dwArg10)
// Called from:
//      os.(*File).Write
void os.(*File).write(struct Eq_2 * gs, union Eq_4 * dwArg04, struct Eq_41738 * dwArg0C, struct Eq_41738 * dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*FD).Write(gs, *dwArg04, dwArg0C, dwArg10);
}

// 0809EFC0: void os.init.0(Register (ptr32 Eq_2) gs)
// Called from:
//      os.init
void os.init.0(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	os.runtime_args(gs);
	g_dw81450EC = dwLoc08;
	g_dw81450F0 = dwLoc04;
	if (g_t81576F0 == 0x00)
		g_t81450E8 = dwLoc0C;
	else
		runtime.writebarrierptr(0x081450E8, dwLoc0C);
}

// 0809F020: void os.glob..func1(Register (ptr32 Eq_2) gs)
// Called from:
//      os.init
void os.glob..func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	os.Readlink(gs, 135143494, 0x0E);
}

// 0809F080: void os.init(Register (ptr32 Eq_2) gs)
// Called from:
//      fmt.init
void os.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157564;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157564 = 0x01;
		io.init(gs);
		word32 esi_628;
		word32 edi_629;
		word128 xmm0_630;
		runtime.init(gs, out esi_628, out edi_629, out xmm0_630);
		syscall.init(gs);
		word32 esi_631;
		word32 edi_632;
		word128 xmm0_633;
		sync.init(gs, out esi_631, out edi_632, out xmm0_633);
		time.init(gs);
		internal/poll.init(gs);
		errors.New(gs, 135144825, 0x10);
		g_t8145078 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t814507C = dwLoc0C;
		else
			runtime.writebarrierptr(135549052, dwLoc0C);
		errors.New(gs, 0x080E2862, 0x11);
		g_t8145088 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t814508C = dwLoc0C;
		else
			runtime.writebarrierptr(0x0814508C, dwLoc0C);
		errors.New(gs, 0x080E2CC8, 0x13);
		g_t8145070 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t8145074 = dwLoc0C;
		else
			runtime.writebarrierptr(135549044, dwLoc0C);
		errors.New(gs, 135146715, 0x13);
		g_t8145080 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t8145084 = dwLoc0C;
		else
			runtime.writebarrierptr(0x08145084, dwLoc0C);
		errors.New(gs, 135146677, 0x13);
		g_t8145068 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t814506C = dwLoc0C;
		else
			runtime.writebarrierptr(0x0814506C, dwLoc0C);
		errors.New(gs, 135153952, 0x1C);
		g_t8145090 = dwLoc10;
		Eq_4 dwLoc18_519 = 135153952;
		Eq_4 dwLoc14_520 = 0x1C;
		if (g_t81576F0 == 0x00)
			g_t8145094 = dwLoc0C;
		else
		{
			runtime.writebarrierptr(0x08145094, dwLoc0C);
			dwLoc18_519.u0 = 0x08145094;
			dwLoc14_520 = dwLoc0C;
		}
		os.glob..func1(gs);
		g_t814509C = dwLoc14_520;
		if (g_t81576F0 == 0x00)
			g_t8145098 = dwLoc18_519;
		else
			runtime.writebarrierptr(0x08145098, dwLoc18_519);
		g_t81450A0 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t81450A4 = dwLoc0C;
		else
			runtime.writebarrierptr(0x081450A4, dwLoc0C);
		os.NewFile(gs, g_t8157660, 135141511, 0x0A);
		if (g_t81576F0 == 0x00)
			g_t8144F94 = dwLoc0C;
		else
			runtime.writebarrierptr(0x08144F94, dwLoc0C);
		os.NewFile(gs, g_t813602C, 135141985, 11);
		if (g_t81576F0 == 0x00)
			g_t8144F98 = dwLoc0C;
		else
			runtime.writebarrierptr(135548824, dwLoc0C);
		os.NewFile(gs, g_t8136028, 135141974, 11);
		if (g_t81576F0 == 0x00)
			g_t8144F90 = dwLoc0C;
		else
			runtime.writebarrierptr(0x08144F90, dwLoc0C);
		os.init.0(gs);
		g_b8157564 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809F430: void type..hash.os.file(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.os.file(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	type..hash.internal/poll.FD(gs, mm0, dwArg04, dwArg08);
	runtime.strhash(gs, mm0, (word32) dwArg04 + 32, dwLoc08);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 40, dwLoc08, 0x05);
}

// 0809F4B0: void type..eq.os.file(Register (ptr32 Eq_108756) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.os.file(struct Eq_108756 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uip32 ecx_158;
	type..eq.internal/poll.FD(gs, dwArg04, dwArg08);
	if ((byte) (word32) bLoc0C != 0x00)
	{
		Eq_4 ecx_44 = *((word32) dwArg04 + 32);
		Eq_4 ebx_46 = *((word32) dwArg08 + 32);
		Eq_4 ebp_47 = *((word32) dwArg04 + 36);
		if (ebp_47 != *((word32) dwArg08 + 36))
			ecx_158 = 0x00;
		else
		{
			word32 edi_55;
			word32 esi_56;
			runtime.eqstring(ecx_44, ebp_47, ebx_46, out esi_56, out edi_55);
			ecx_158 = (word32) bLoc04;
		}
	}
	else
		ecx_158 = 0x00;
	if ((byte) ecx_158 != 0x00)
		*((word32) dwArg04 + 40) != *((word32) dwArg08 + 40);
}

// 0809F570: void type..hash.os.PathError(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack (ptr32 Eq_639) dwArg04, Stack Eq_207 dwArg08)
void type..hash.os.PathError(struct Eq_2 * gs, word64 mm0, struct Eq_639 * dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.strhash(gs, mm0, dwArg04, dwArg08);
	runtime.strhash(gs, mm0, (char *) &dwArg04->t0004 + 4, dwLoc04);
	runtime.interhash(gs, (char *) &dwArg04->t0004 + 0x0C, dwLoc04);
}

// 0809F5E0: void type..eq.os.PathError(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_109718) dwArg04, Stack (ptr32 Eq_109719) dwArg08)
void type..eq.os.PathError(struct Eq_2 * gs, struct Eq_109718 * dwArg04, struct Eq_109719 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte cl_45;
	Eq_4 edx_19 = dwArg08->t0000;
	Eq_4 ebp_21 = dwArg04->t0004;
	Eq_4 esi_22 = dwArg04->t0000;
	if (dwArg08->t0004 != ebp_21)
		cl_45 = 0x00;
	else
	{
		word32 edi_29;
		word32 esi_30;
		runtime.eqstring(esi_22, ebp_21, edx_19, out esi_30, out edi_29);
		cl_45 = (byte) (word32) bLoc04;
	}
	uip32 ecx_194;
	if (cl_45 != 0x00)
	{
		Eq_4 edx_57 = dwArg08->t0008;
		Eq_4 ebp_59 = dwArg04->t000C;
		Eq_4 esi_60 = dwArg04->t0008;
		if (ebp_59 != dwArg08->t000C)
			ecx_194 = 0x00;
		else
		{
			word32 edi_68;
			word32 esi_69;
			runtime.eqstring(esi_60, ebp_59, edx_57, out esi_69, out edi_68);
			ecx_194 = (word32) bLoc04;
		}
	}
	else
		ecx_194 = 0x00;
	if ((byte) ecx_194 != 0x00)
	{
		Eq_4 ecx_96 = dwArg04->t0010;
		Eq_4 edx_98 = dwArg08->t0014;
		Eq_4 ebx_100 = dwArg04->t0014;
		if (ecx_96 == dwArg08->t0010)
			runtime.ifaceeq(gs, ecx_96, ebx_100, edx_98);
	}
}

// 0809F6C0: Register word128 unicode.init(Register word32 ebx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.init
word128 unicode.init(word32 ebx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs)
{
	Eq_6606 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157588;
	if (al_18 > 0x01)
		return xmm1;
	if (al_18 != 0x01)
	{
		g_b8157588 = 0x01;
		word128 xmm1_12839;
		word128 xmm0_12838;
		word32 edi_12837;
		runtime.makemap(ebx_24_8, esi, edi, gs, 0x080CFB40, 0x24, 0x00, 0x00, 0x00, out edi_12837, out xmm0_12838, out xmm1_12839);
		Eq_4 ecx_52 = g_t81422F4;
		word128 xmm1_12842;
		word32 edi_12841;
		word32 esi_12840;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12840, out edi_12841, out xmm1_12842);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_52;
		else
			runtime.writebarrierptr(0x00, ecx_52);
		Eq_4 eax_97 = g_t8142304;
		word128 xmm1_12845;
		word32 edi_12844;
		word32 esi_12843;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12843, out edi_12844, out xmm1_12845);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_97;
		else
			runtime.writebarrierptr(0x00, eax_97);
		Eq_4 eax_145 = g_t8142308;
		word32 esi_12846;
		word32 edi_12847;
		word128 xmm1_12848;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12846, out edi_12847, out xmm1_12848);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_145;
		else
			runtime.writebarrierptr(0x00, eax_145);
		Eq_4 eax_193 = g_t8142318;
		word32 esi_13488;
		word32 edi_13489;
		word128 xmm1_13490;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13488, out edi_13489, out xmm1_13490);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_193;
		else
			runtime.writebarrierptr(0x00, eax_193);
		Eq_4 eax_241 = g_t8142324;
		word128 xmm1_12851;
		word32 edi_12850;
		word32 esi_12849;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12849, out edi_12850, out xmm1_12851);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_241;
		else
			runtime.writebarrierptr(0x00, eax_241);
		Eq_4 eax_289 = g_t81423DC;
		word32 esi_13485;
		word32 edi_13486;
		word128 xmm1_13487;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13485, out edi_13486, out xmm1_13487);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_289;
		else
			runtime.writebarrierptr(0x00, eax_289);
		Eq_4 eax_337 = g_t81423FC;
		word32 esi_13482;
		word32 edi_13483;
		word128 xmm1_13484;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13482, out edi_13483, out xmm1_13484);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_337;
		else
			runtime.writebarrierptr(0x00, eax_337);
		Eq_4 eax_385 = g_t8142400;
		word32 esi_13479;
		word32 edi_13480;
		word128 xmm1_13481;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13479, out edi_13480, out xmm1_13481);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_385;
		else
			runtime.writebarrierptr(0x00, eax_385);
		Eq_4 eax_433 = g_t8142404;
		word128 xmm1_12854;
		word32 edi_12853;
		word32 esi_12852;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12852, out edi_12853, out xmm1_12854);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_433;
		else
			runtime.writebarrierptr(0x00, eax_433);
		Eq_4 eax_481 = g_t814240C;
		word32 esi_13476;
		word32 edi_13477;
		word128 xmm1_13478;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13476, out edi_13477, out xmm1_13478);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_481;
		else
			runtime.writebarrierptr(0x00, eax_481);
		Eq_4 eax_529 = g_t8142410;
		word32 esi_13473;
		word32 edi_13474;
		word128 xmm1_13475;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13473, out edi_13474, out xmm1_13475);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_529;
		else
			runtime.writebarrierptr(0x00, eax_529);
		Eq_4 eax_577 = g_t814241C;
		word32 esi_13470;
		word32 edi_13471;
		word128 xmm1_13472;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13470, out edi_13471, out xmm1_13472);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_577;
		else
			runtime.writebarrierptr(0x00, eax_577);
		Eq_4 eax_625 = g_t8142434;
		word32 esi_13467;
		word32 edi_13468;
		word128 xmm1_13469;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13467, out edi_13468, out xmm1_13469);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_625;
		else
			runtime.writebarrierptr(0x00, eax_625);
		Eq_4 eax_673 = g_t8142438;
		word32 esi_13464;
		word32 edi_13465;
		word128 xmm1_13466;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13464, out edi_13465, out xmm1_13466);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_673;
		else
			runtime.writebarrierptr(0x00, eax_673);
		Eq_4 eax_721 = g_t8142450;
		word32 esi_13461;
		word32 edi_13462;
		word128 xmm1_13463;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13461, out edi_13462, out xmm1_13463);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_721;
		else
			runtime.writebarrierptr(0x00, eax_721);
		Eq_4 eax_769 = g_t8142468;
		word32 esi_13458;
		word32 edi_13459;
		word128 xmm1_13460;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13458, out edi_13459, out xmm1_13460);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_769;
		else
			runtime.writebarrierptr(0x00, eax_769);
		Eq_4 eax_817 = g_t8142470;
		word128 xmm1_12857;
		word32 edi_12856;
		word32 esi_12855;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12855, out edi_12856, out xmm1_12857);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_817;
		else
			runtime.writebarrierptr(0x00, eax_817);
		Eq_4 eax_865 = g_t8142480;
		word32 esi_13455;
		word32 edi_13456;
		word128 xmm1_13457;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13455, out edi_13456, out xmm1_13457);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_865;
		else
			runtime.writebarrierptr(0x00, eax_865);
		Eq_4 eax_913 = g_t8142484;
		word32 esi_13452;
		word32 edi_13453;
		word128 xmm1_13454;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13452, out edi_13453, out xmm1_13454);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_913;
		else
			runtime.writebarrierptr(0x00, eax_913);
		Eq_4 eax_961 = g_t81424DC;
		word32 esi_13449;
		word32 edi_13450;
		word128 xmm1_13451;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13449, out edi_13450, out xmm1_13451);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_961;
		else
			runtime.writebarrierptr(0x00, eax_961);
		Eq_4 eax_1009 = g_t81424F4;
		word32 esi_13446;
		word32 edi_13447;
		word128 xmm1_13448;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13446, out edi_13447, out xmm1_13448);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1009;
		else
			runtime.writebarrierptr(0x00, eax_1009);
		Eq_4 eax_1057 = g_t81424F8;
		word32 esi_13443;
		word32 edi_13444;
		word128 xmm1_13445;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13443, out edi_13444, out xmm1_13445);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1057;
		else
			runtime.writebarrierptr(0x00, eax_1057);
		Eq_4 eax_1105 = g_t81424FC;
		word32 esi_13440;
		word32 edi_13441;
		word128 xmm1_13442;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13440, out edi_13441, out xmm1_13442);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1105;
		else
			runtime.writebarrierptr(0x00, eax_1105);
		Eq_4 eax_1153 = g_t8142500;
		word32 esi_13437;
		word32 edi_13438;
		word128 xmm1_13439;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13437, out edi_13438, out xmm1_13439);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1153;
		else
			runtime.writebarrierptr(0x00, eax_1153);
		Eq_4 eax_1201 = g_t814250C;
		word32 esi_13434;
		word32 edi_13435;
		word128 xmm1_13436;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13434, out edi_13435, out xmm1_13436);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1201;
		else
			runtime.writebarrierptr(0x00, eax_1201);
		Eq_4 eax_1249 = g_t8142510;
		word32 esi_13431;
		word32 edi_13432;
		word128 xmm1_13433;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13431, out edi_13432, out xmm1_13433);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1249;
		else
			runtime.writebarrierptr(0x00, eax_1249);
		Eq_4 eax_1297 = g_t8142518;
		word32 esi_13428;
		word32 edi_13429;
		word128 xmm1_13430;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13428, out edi_13429, out xmm1_13430);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1297;
		else
			runtime.writebarrierptr(0x00, eax_1297);
		Eq_4 eax_1345 = g_t8142530;
		word32 esi_13425;
		word32 edi_13426;
		word128 xmm1_13427;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13425, out edi_13426, out xmm1_13427);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1345;
		else
			runtime.writebarrierptr(0x00, eax_1345);
		Eq_4 eax_1393 = g_t814253C;
		word32 esi_13422;
		word32 edi_13423;
		word128 xmm1_13424;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13422, out edi_13423, out xmm1_13424);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1393;
		else
			runtime.writebarrierptr(0x00, eax_1393);
		Eq_4 eax_1441 = g_t8142558;
		word32 esi_13419;
		word32 edi_13420;
		word128 xmm1_13421;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13419, out edi_13420, out xmm1_13421);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1441;
		else
			runtime.writebarrierptr(0x00, eax_1441);
		Eq_4 eax_1489 = g_t814255C;
		word32 esi_13416;
		word32 edi_13417;
		word128 xmm1_13418;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13416, out edi_13417, out xmm1_13418);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1489;
		else
			runtime.writebarrierptr(0x00, eax_1489);
		Eq_4 eax_1537 = g_t8142560;
		word32 esi_13413;
		word32 edi_13414;
		word128 xmm1_13415;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13413, out edi_13414, out xmm1_13415);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1537;
		else
			runtime.writebarrierptr(0x00, eax_1537);
		Eq_4 eax_1585 = g_t81425D0;
		word128 xmm1_12860;
		word32 edi_12859;
		word32 esi_12858;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12858, out edi_12859, out xmm1_12860);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1585;
		else
			runtime.writebarrierptr(0x00, eax_1585);
		Eq_4 eax_1633 = g_t81425D4;
		word32 esi_13410;
		word32 edi_13411;
		word128 xmm1_13412;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13410, out edi_13411, out xmm1_13412);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1633;
		else
			runtime.writebarrierptr(0x00, eax_1633);
		Eq_4 eax_1681 = g_t81425D8;
		word32 esi_13407;
		word32 edi_13408;
		word128 xmm1_13409;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13407, out edi_13408, out xmm1_13409);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1681;
		else
			runtime.writebarrierptr(0x00, eax_1681);
		Eq_4 eax_1729 = g_t81425DC;
		Eq_4 edi_1744;
		Eq_4 esi_1746;
		word128 xmm1_13406;
		Eq_6606 ebx_24_8_1798 = SLICE(runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_1746, out edi_1744, out xmm1_13406), word24, 8);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_1729;
			g_t8144FF0 = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_1729);
			runtime.writebarrierptr(0x08144FF0, dwLoc1C);
		}
		word32 edi_13400;
		word128 xmm0_13401;
		word128 xmm1_13402;
		runtime.makemap(ebx_24_8_1798, esi_1746, edi_1744, gs, 0x080CFB40, 0x89, 0x00, 0x00, 0x00, out edi_13400, out xmm0_13401, out xmm1_13402);
		Eq_4 ecx_1819 = g_t81422AC;
		word32 esi_13403;
		word32 edi_13404;
		word128 xmm1_13405;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13403, out edi_13404, out xmm1_13405);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_1819;
		else
			runtime.writebarrierptr(0x00, ecx_1819);
		Eq_4 eax_1864 = g_t81422B0;
		word32 esi_13397;
		word32 edi_13398;
		word128 xmm1_13399;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13397, out edi_13398, out xmm1_13399);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1864;
		else
			runtime.writebarrierptr(0x00, eax_1864);
		Eq_4 eax_1912 = g_t81422B4;
		word32 esi_13394;
		word32 edi_13395;
		word128 xmm1_13396;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13394, out edi_13395, out xmm1_13396);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1912;
		else
			runtime.writebarrierptr(0x00, eax_1912);
		Eq_4 eax_1960 = g_t81422B8;
		word32 esi_13391;
		word32 edi_13392;
		word128 xmm1_13393;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13391, out edi_13392, out xmm1_13393);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1960;
		else
			runtime.writebarrierptr(0x00, eax_1960);
		Eq_4 eax_2008 = g_t81422BC;
		word32 esi_13388;
		word32 edi_13389;
		word128 xmm1_13390;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13388, out edi_13389, out xmm1_13390);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2008;
		else
			runtime.writebarrierptr(0x00, eax_2008);
		Eq_4 eax_2056 = g_t81422C0;
		word32 esi_13385;
		word32 edi_13386;
		word128 xmm1_13387;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13385, out edi_13386, out xmm1_13387);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2056;
		else
			runtime.writebarrierptr(0x00, eax_2056);
		Eq_4 eax_2104 = g_t81422C4;
		word32 esi_13382;
		word32 edi_13383;
		word128 xmm1_13384;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13382, out edi_13383, out xmm1_13384);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2104;
		else
			runtime.writebarrierptr(0x00, eax_2104);
		Eq_4 eax_2152 = g_t81422C8;
		word32 esi_13379;
		word32 edi_13380;
		word128 xmm1_13381;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13379, out edi_13380, out xmm1_13381);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2152;
		else
			runtime.writebarrierptr(0x00, eax_2152);
		Eq_4 eax_2200 = g_t81422CC;
		word32 esi_13376;
		word32 edi_13377;
		word128 xmm1_13378;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13376, out edi_13377, out xmm1_13378);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2200;
		else
			runtime.writebarrierptr(0x00, eax_2200);
		Eq_4 eax_2248 = g_t81422D0;
		word32 esi_13373;
		word32 edi_13374;
		word128 xmm1_13375;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13373, out edi_13374, out xmm1_13375);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2248;
		else
			runtime.writebarrierptr(0x00, eax_2248);
		Eq_4 eax_2296 = g_t81422D4;
		word32 esi_13370;
		word32 edi_13371;
		word128 xmm1_13372;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13370, out edi_13371, out xmm1_13372);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2296;
		else
			runtime.writebarrierptr(0x00, eax_2296);
		Eq_4 eax_2344 = g_t81422D8;
		word32 esi_13367;
		word32 edi_13368;
		word128 xmm1_13369;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13367, out edi_13368, out xmm1_13369);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2344;
		else
			runtime.writebarrierptr(0x00, eax_2344);
		Eq_4 eax_2392 = g_t81422E0;
		word32 esi_13364;
		word32 edi_13365;
		word128 xmm1_13366;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13364, out edi_13365, out xmm1_13366);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2392;
		else
			runtime.writebarrierptr(0x00, eax_2392);
		Eq_4 eax_2440 = g_t81422E4;
		word32 edi_13362;
		word32 esi_13361;
		word128 xmm1_13363;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13361, out edi_13362, out xmm1_13363);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2440;
		else
			runtime.writebarrierptr(0x00, eax_2440);
		Eq_4 eax_2488 = g_t81422E8;
		word128 xmm1_13360;
		word32 edi_13359;
		word32 esi_13358;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13358, out edi_13359, out xmm1_13360);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2488;
		else
			runtime.writebarrierptr(0x00, eax_2488);
		Eq_4 eax_2536 = g_t81422EC;
		word128 xmm1_13357;
		word32 edi_13356;
		word32 esi_13355;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13355, out edi_13356, out xmm1_13357);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2536;
		else
			runtime.writebarrierptr(0x00, eax_2536);
		Eq_4 eax_2584 = g_t81422F0;
		word128 xmm1_13354;
		word32 edi_13353;
		word32 esi_13352;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13352, out edi_13353, out xmm1_13354);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2584;
		else
			runtime.writebarrierptr(0x00, eax_2584);
		Eq_4 eax_2632 = g_t81422F8;
		word128 xmm1_13351;
		word32 edi_13350;
		word32 esi_13349;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13349, out edi_13350, out xmm1_13351);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2632;
		else
			runtime.writebarrierptr(0x00, eax_2632);
		Eq_4 eax_2680 = g_t81422FC;
		word128 xmm1_13348;
		word32 edi_13347;
		word32 esi_13346;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13346, out edi_13347, out xmm1_13348);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2680;
		else
			runtime.writebarrierptr(0x00, eax_2680);
		Eq_4 eax_2728 = g_t8142300;
		word128 xmm1_13345;
		word32 edi_13344;
		word32 esi_13343;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13343, out edi_13344, out xmm1_13345);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2728;
		else
			runtime.writebarrierptr(0x00, eax_2728);
		Eq_4 eax_2776 = g_t814230C;
		word128 xmm1_13342;
		word32 edi_13341;
		word32 esi_13340;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13340, out edi_13341, out xmm1_13342);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2776;
		else
			runtime.writebarrierptr(0x00, eax_2776);
		Eq_4 eax_2824 = g_t8142310;
		word128 xmm1_13339;
		word32 edi_13338;
		word32 esi_13337;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13337, out edi_13338, out xmm1_13339);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2824;
		else
			runtime.writebarrierptr(0x00, eax_2824);
		Eq_4 eax_2872 = g_t8142314;
		word128 xmm1_13336;
		word32 edi_13335;
		word32 esi_13334;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13334, out edi_13335, out xmm1_13336);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2872;
		else
			runtime.writebarrierptr(0x00, eax_2872);
		Eq_4 eax_2920 = g_t814231C;
		word128 xmm1_13333;
		word32 edi_13332;
		word32 esi_13331;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13331, out edi_13332, out xmm1_13333);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2920;
		else
			runtime.writebarrierptr(0x00, eax_2920);
		Eq_4 eax_2968 = g_t8142320;
		word128 xmm1_13330;
		word32 edi_13329;
		word32 esi_13328;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13328, out edi_13329, out xmm1_13330);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2968;
		else
			runtime.writebarrierptr(0x00, eax_2968);
		Eq_4 eax_3016 = g_t8142328;
		word32 esi_13325;
		word32 edi_13326;
		word128 xmm1_13327;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13325, out edi_13326, out xmm1_13327);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3016;
		else
			runtime.writebarrierptr(0x00, eax_3016);
		Eq_4 eax_3064 = g_t814232C;
		word32 esi_13322;
		word32 edi_13323;
		word128 xmm1_13324;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13322, out edi_13323, out xmm1_13324);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3064;
		else
			runtime.writebarrierptr(0x00, eax_3064);
		Eq_4 eax_3112 = g_t8142330;
		word32 esi_13319;
		word32 edi_13320;
		word128 xmm1_13321;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13319, out edi_13320, out xmm1_13321);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3112;
		else
			runtime.writebarrierptr(0x00, eax_3112);
		Eq_4 eax_3160 = g_t814233C;
		word128 xmm1_12863;
		word32 edi_12862;
		word32 esi_12861;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12861, out edi_12862, out xmm1_12863);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3160;
		else
			runtime.writebarrierptr(0x00, eax_3160);
		Eq_4 eax_3208 = g_t8142340;
		word32 esi_13316;
		word32 edi_13317;
		word128 xmm1_13318;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13316, out edi_13317, out xmm1_13318);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3208;
		else
			runtime.writebarrierptr(0x00, eax_3208);
		Eq_4 eax_3256 = g_t8142348;
		word32 esi_13313;
		word32 edi_13314;
		word128 xmm1_13315;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13313, out edi_13314, out xmm1_13315);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3256;
		else
			runtime.writebarrierptr(0x00, eax_3256);
		Eq_4 eax_3304 = g_t814234C;
		word128 xmm1_13312;
		word32 edi_13311;
		word32 esi_13310;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13310, out edi_13311, out xmm1_13312);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3304;
		else
			runtime.writebarrierptr(0x00, eax_3304);
		Eq_4 eax_3352 = g_t8142350;
		word128 xmm1_13309;
		word32 edi_13308;
		word32 esi_13307;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13307, out edi_13308, out xmm1_13309);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3352;
		else
			runtime.writebarrierptr(0x00, eax_3352);
		Eq_4 eax_3400 = g_t8142354;
		word128 xmm1_13306;
		word32 edi_13305;
		word32 esi_13304;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13304, out edi_13305, out xmm1_13306);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3400;
		else
			runtime.writebarrierptr(0x00, eax_3400);
		Eq_4 eax_3448 = g_t814235C;
		word128 xmm1_13303;
		word32 edi_13302;
		word32 esi_13301;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13301, out edi_13302, out xmm1_13303);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3448;
		else
			runtime.writebarrierptr(0x00, eax_3448);
		Eq_4 eax_3496 = g_t8142360;
		word128 xmm1_13300;
		word32 edi_13299;
		word32 esi_13298;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13298, out edi_13299, out xmm1_13300);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3496;
		else
			runtime.writebarrierptr(0x00, eax_3496);
		Eq_4 eax_3544 = g_t8142364;
		word128 xmm1_13297;
		word32 edi_13296;
		word32 esi_13295;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13295, out edi_13296, out xmm1_13297);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3544;
		else
			runtime.writebarrierptr(0x00, eax_3544);
		Eq_4 eax_3592 = g_t8142368;
		word128 xmm1_13294;
		word32 edi_13293;
		word32 esi_13292;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13292, out edi_13293, out xmm1_13294);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3592;
		else
			runtime.writebarrierptr(0x00, eax_3592);
		Eq_4 eax_3640 = g_t814236C;
		word128 xmm1_13291;
		word32 edi_13290;
		word32 esi_13289;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13289, out edi_13290, out xmm1_13291);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3640;
		else
			runtime.writebarrierptr(0x00, eax_3640);
		Eq_4 eax_3688 = g_t8142370;
		word128 xmm1_13288;
		word32 edi_13287;
		word32 esi_13286;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13286, out edi_13287, out xmm1_13288);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3688;
		else
			runtime.writebarrierptr(0x00, eax_3688);
		Eq_4 eax_3736 = g_t8142374;
		word128 xmm1_13285;
		word32 edi_13284;
		word32 esi_13283;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13283, out edi_13284, out xmm1_13285);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3736;
		else
			runtime.writebarrierptr(0x00, eax_3736);
		Eq_4 eax_3784 = g_t8142378;
		word128 xmm1_13282;
		word32 edi_13281;
		word32 esi_13280;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13280, out edi_13281, out xmm1_13282);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3784;
		else
			runtime.writebarrierptr(0x00, eax_3784);
		Eq_4 eax_3832 = g_t814237C;
		word128 xmm1_13279;
		word32 edi_13278;
		word32 esi_13277;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13277, out edi_13278, out xmm1_13279);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3832;
		else
			runtime.writebarrierptr(0x00, eax_3832);
		Eq_4 eax_3880 = g_t8142380;
		word128 xmm1_13276;
		word32 edi_13275;
		word32 esi_13274;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13274, out edi_13275, out xmm1_13276);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3880;
		else
			runtime.writebarrierptr(0x00, eax_3880);
		Eq_4 eax_3928 = g_t8142384;
		word128 xmm1_13273;
		word32 edi_13272;
		word32 esi_13271;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13271, out edi_13272, out xmm1_13273);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3928;
		else
			runtime.writebarrierptr(0x00, eax_3928);
		Eq_4 eax_3976 = g_t8142388;
		word128 xmm1_13270;
		word32 edi_13269;
		word32 esi_13268;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13268, out edi_13269, out xmm1_13270);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3976;
		else
			runtime.writebarrierptr(0x00, eax_3976);
		Eq_4 eax_4024 = g_t8142390;
		word128 xmm1_13267;
		word32 edi_13266;
		word32 esi_13265;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13265, out edi_13266, out xmm1_13267);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4024;
		else
			runtime.writebarrierptr(0x00, eax_4024);
		Eq_4 eax_4072 = g_t81423A4;
		word128 xmm1_13264;
		word32 edi_13263;
		word32 esi_13262;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13262, out edi_13263, out xmm1_13264);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4072;
		else
			runtime.writebarrierptr(0x00, eax_4072);
		Eq_4 eax_4120 = g_t81423A8;
		word128 xmm1_13261;
		word32 edi_13260;
		word32 esi_13259;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13259, out edi_13260, out xmm1_13261);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4120;
		else
			runtime.writebarrierptr(0x00, eax_4120);
		Eq_4 eax_4168 = g_t81423AC;
		word128 xmm1_13258;
		word32 edi_13257;
		word32 esi_13256;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13256, out edi_13257, out xmm1_13258);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4168;
		else
			runtime.writebarrierptr(0x00, eax_4168);
		Eq_4 eax_4216 = g_t81423B0;
		word128 xmm1_13255;
		word32 edi_13254;
		word32 esi_13253;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13253, out edi_13254, out xmm1_13255);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4216;
		else
			runtime.writebarrierptr(0x00, eax_4216);
		Eq_4 eax_4264 = g_t81423B4;
		word128 xmm1_13252;
		word32 edi_13251;
		word32 esi_13250;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13250, out edi_13251, out xmm1_13252);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4264;
		else
			runtime.writebarrierptr(0x00, eax_4264);
		Eq_4 eax_4312 = g_t81423BC;
		word128 xmm1_13249;
		word32 edi_13248;
		word32 esi_13247;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13247, out edi_13248, out xmm1_13249);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4312;
		else
			runtime.writebarrierptr(0x00, eax_4312);
		Eq_4 eax_4360 = g_t81423C0;
		word128 xmm1_13246;
		word32 edi_13245;
		word32 esi_13244;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13244, out edi_13245, out xmm1_13246);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4360;
		else
			runtime.writebarrierptr(0x00, eax_4360);
		Eq_4 eax_4408 = g_t81423C4;
		word128 xmm1_13243;
		word32 edi_13242;
		word32 esi_13241;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13241, out edi_13242, out xmm1_13243);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4408;
		else
			runtime.writebarrierptr(0x00, eax_4408);
		Eq_4 eax_4456 = g_t81423C8;
		word128 xmm1_13240;
		word32 edi_13239;
		word32 esi_13238;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13238, out edi_13239, out xmm1_13240);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4456;
		else
			runtime.writebarrierptr(0x00, eax_4456);
		Eq_4 eax_4504 = g_t81423CC;
		word128 xmm1_13237;
		word32 edi_13236;
		word32 esi_13235;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13235, out edi_13236, out xmm1_13237);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4504;
		else
			runtime.writebarrierptr(0x00, eax_4504);
		Eq_4 eax_4552 = g_t81423D0;
		word128 xmm1_13234;
		word32 edi_13233;
		word32 esi_13232;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13232, out edi_13233, out xmm1_13234);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4552;
		else
			runtime.writebarrierptr(0x00, eax_4552);
		Eq_4 eax_4600 = g_t81423D4;
		word128 xmm1_13231;
		word32 edi_13230;
		word32 esi_13229;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13229, out edi_13230, out xmm1_13231);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4600;
		else
			runtime.writebarrierptr(0x00, eax_4600);
		Eq_4 eax_4648 = g_t81423D8;
		word128 xmm1_13228;
		word32 edi_13227;
		word32 esi_13226;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13226, out edi_13227, out xmm1_13228);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4648;
		else
			runtime.writebarrierptr(0x00, eax_4648);
		Eq_4 eax_4696 = g_t81423E0;
		word128 xmm1_13225;
		word32 edi_13224;
		word32 esi_13223;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13223, out edi_13224, out xmm1_13225);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4696;
		else
			runtime.writebarrierptr(0x00, eax_4696);
		Eq_4 eax_4744 = g_t81423E4;
		word128 xmm1_13222;
		word32 edi_13221;
		word32 esi_13220;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13220, out edi_13221, out xmm1_13222);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4744;
		else
			runtime.writebarrierptr(0x00, eax_4744);
		Eq_4 eax_4792 = g_t81423E8;
		word128 xmm1_13219;
		word32 edi_13218;
		word32 esi_13217;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13217, out edi_13218, out xmm1_13219);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4792;
		else
			runtime.writebarrierptr(0x00, eax_4792);
		Eq_4 eax_4840 = g_t81423EC;
		word128 xmm1_13216;
		word32 edi_13215;
		word32 esi_13214;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13214, out edi_13215, out xmm1_13216);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4840;
		else
			runtime.writebarrierptr(0x00, eax_4840);
		Eq_4 eax_4888 = g_t81423F0;
		word128 xmm1_13213;
		word32 edi_13212;
		word32 esi_13211;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13211, out edi_13212, out xmm1_13213);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4888;
		else
			runtime.writebarrierptr(0x00, eax_4888);
		Eq_4 eax_4936 = g_t81423F4;
		word128 xmm1_13210;
		word32 edi_13209;
		word32 esi_13208;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13208, out edi_13209, out xmm1_13210);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4936;
		else
			runtime.writebarrierptr(0x00, eax_4936);
		Eq_4 eax_4984 = g_t81423F8;
		word128 xmm1_13207;
		word32 edi_13206;
		word32 esi_13205;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13205, out edi_13206, out xmm1_13207);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4984;
		else
			runtime.writebarrierptr(0x00, eax_4984);
		Eq_4 eax_5032 = g_t8142414;
		word128 xmm1_13204;
		word32 edi_13203;
		word32 esi_13202;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13202, out edi_13203, out xmm1_13204);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5032;
		else
			runtime.writebarrierptr(0x00, eax_5032);
		Eq_4 eax_5080 = g_t8142418;
		word128 xmm1_13201;
		word32 edi_13200;
		word32 esi_13199;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13199, out edi_13200, out xmm1_13201);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5080;
		else
			runtime.writebarrierptr(0x00, eax_5080);
		Eq_4 eax_5128 = g_t8142420;
		word128 xmm1_13198;
		word32 edi_13197;
		word32 esi_13196;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13196, out edi_13197, out xmm1_13198);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5128;
		else
			runtime.writebarrierptr(0x00, eax_5128);
		Eq_4 eax_5176 = g_t8142424;
		word128 xmm1_13195;
		word32 edi_13194;
		word32 esi_13193;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13193, out edi_13194, out xmm1_13195);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5176;
		else
			runtime.writebarrierptr(0x00, eax_5176);
		Eq_4 eax_5224 = g_t8142428;
		word128 xmm1_13192;
		word32 edi_13191;
		word32 esi_13190;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13190, out edi_13191, out xmm1_13192);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5224;
		else
			runtime.writebarrierptr(0x00, eax_5224);
		Eq_4 eax_5272 = g_t814242C;
		word128 xmm1_13189;
		word32 edi_13188;
		word32 esi_13187;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13187, out edi_13188, out xmm1_13189);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5272;
		else
			runtime.writebarrierptr(0x00, eax_5272);
		Eq_4 eax_5320 = g_t8142430;
		word128 xmm1_13186;
		word32 edi_13185;
		word32 esi_13184;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13184, out edi_13185, out xmm1_13186);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5320;
		else
			runtime.writebarrierptr(0x00, eax_5320);
		Eq_4 eax_5368 = g_t814243C;
		word128 xmm1_13183;
		word32 edi_13182;
		word32 esi_13181;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13181, out edi_13182, out xmm1_13183);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5368;
		else
			runtime.writebarrierptr(0x00, eax_5368);
		Eq_4 eax_5416 = g_t8142440;
		word128 xmm1_13180;
		word32 edi_13179;
		word32 esi_13178;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13178, out edi_13179, out xmm1_13180);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5416;
		else
			runtime.writebarrierptr(0x00, eax_5416);
		Eq_4 eax_5464 = g_t8142444;
		word128 xmm1_13177;
		word32 edi_13176;
		word32 esi_13175;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13175, out edi_13176, out xmm1_13177);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5464;
		else
			runtime.writebarrierptr(0x00, eax_5464);
		Eq_4 eax_5512 = g_t8142448;
		word128 xmm1_13174;
		word32 edi_13173;
		word32 esi_13172;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13172, out edi_13173, out xmm1_13174);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5512;
		else
			runtime.writebarrierptr(0x00, eax_5512);
		Eq_4 eax_5560 = g_t814244C;
		word128 xmm1_13171;
		word32 edi_13170;
		word32 esi_13169;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13169, out edi_13170, out xmm1_13171);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5560;
		else
			runtime.writebarrierptr(0x00, eax_5560);
		Eq_4 eax_5608 = g_t8142454;
		word128 xmm1_13168;
		word32 edi_13167;
		word32 esi_13166;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13166, out edi_13167, out xmm1_13168);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5608;
		else
			runtime.writebarrierptr(0x00, eax_5608);
		Eq_4 eax_5656 = g_t8142458;
		word128 xmm1_13165;
		word32 edi_13164;
		word32 esi_13163;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13163, out edi_13164, out xmm1_13165);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5656;
		else
			runtime.writebarrierptr(0x00, eax_5656);
		Eq_4 eax_5704 = g_t814245C;
		word128 xmm1_13162;
		word32 edi_13161;
		word32 esi_13160;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13160, out edi_13161, out xmm1_13162);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5704;
		else
			runtime.writebarrierptr(0x00, eax_5704);
		Eq_4 eax_5752 = g_t8142460;
		word128 xmm1_13159;
		word32 edi_13158;
		word32 esi_13157;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13157, out edi_13158, out xmm1_13159);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5752;
		else
			runtime.writebarrierptr(0x00, eax_5752);
		Eq_4 eax_5800 = g_t8142464;
		word128 xmm1_13156;
		word32 edi_13155;
		word32 esi_13154;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13154, out edi_13155, out xmm1_13156);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5800;
		else
			runtime.writebarrierptr(0x00, eax_5800);
		Eq_4 eax_5848 = g_t814246C;
		word128 xmm1_13153;
		word32 edi_13152;
		word32 esi_13151;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13151, out edi_13152, out xmm1_13153);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5848;
		else
			runtime.writebarrierptr(0x00, eax_5848);
		Eq_4 eax_5896 = g_t8142474;
		word128 xmm1_13150;
		word32 edi_13149;
		word32 esi_13148;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13148, out edi_13149, out xmm1_13150);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5896;
		else
			runtime.writebarrierptr(0x00, eax_5896);
		Eq_4 eax_5944 = g_t8142478;
		word128 xmm1_13147;
		word32 edi_13146;
		word32 esi_13145;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13145, out edi_13146, out xmm1_13147);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5944;
		else
			runtime.writebarrierptr(0x00, eax_5944);
		Eq_4 eax_5992 = g_t814247C;
		word128 xmm1_13144;
		word32 edi_13143;
		word32 esi_13142;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13142, out edi_13143, out xmm1_13144);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5992;
		else
			runtime.writebarrierptr(0x00, eax_5992);
		Eq_4 eax_6040 = g_t814248C;
		word128 xmm1_13141;
		word32 edi_13140;
		word32 esi_13139;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13139, out edi_13140, out xmm1_13141);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6040;
		else
			runtime.writebarrierptr(0x00, eax_6040);
		Eq_4 eax_6088 = g_t8142490;
		word128 xmm1_13138;
		word32 edi_13137;
		word32 esi_13136;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13136, out edi_13137, out xmm1_13138);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6088;
		else
			runtime.writebarrierptr(0x00, eax_6088);
		Eq_4 eax_6136 = g_t8142494;
		word128 xmm1_13135;
		word32 edi_13134;
		word32 esi_13133;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13133, out edi_13134, out xmm1_13135);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6136;
		else
			runtime.writebarrierptr(0x00, eax_6136);
		Eq_4 eax_6184 = g_t8142498;
		word128 xmm1_13132;
		word32 edi_13131;
		word32 esi_13130;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13130, out edi_13131, out xmm1_13132);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6184;
		else
			runtime.writebarrierptr(0x00, eax_6184);
		Eq_4 eax_6232 = g_t814249C;
		word128 xmm1_12866;
		word32 edi_12865;
		word32 esi_12864;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12864, out edi_12865, out xmm1_12866);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6232;
		else
			runtime.writebarrierptr(0x00, eax_6232);
		Eq_4 eax_6280 = g_t81424A0;
		word128 xmm1_13129;
		word32 edi_13128;
		word32 esi_13127;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13127, out edi_13128, out xmm1_13129);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6280;
		else
			runtime.writebarrierptr(0x00, eax_6280);
		Eq_4 eax_6328 = g_t81424A4;
		word128 xmm1_13126;
		word32 edi_13125;
		word32 esi_13124;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13124, out edi_13125, out xmm1_13126);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6328;
		else
			runtime.writebarrierptr(0x00, eax_6328);
		Eq_4 eax_6376 = g_t81424A8;
		word128 xmm1_13123;
		word32 edi_13122;
		word32 esi_13121;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13121, out edi_13122, out xmm1_13123);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6376;
		else
			runtime.writebarrierptr(0x00, eax_6376);
		Eq_4 eax_6424 = g_t81424AC;
		word128 xmm1_13120;
		word32 edi_13119;
		word32 esi_13118;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13118, out edi_13119, out xmm1_13120);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6424;
		else
			runtime.writebarrierptr(0x00, eax_6424);
		Eq_4 eax_6472 = g_t81424B0;
		word128 xmm1_13117;
		word32 edi_13116;
		word32 esi_13115;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13115, out edi_13116, out xmm1_13117);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6472;
		else
			runtime.writebarrierptr(0x00, eax_6472);
		Eq_4 eax_6520 = g_t81424B4;
		word128 xmm1_13114;
		word32 edi_13113;
		word32 esi_13112;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13112, out edi_13113, out xmm1_13114);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6520;
		else
			runtime.writebarrierptr(0x00, eax_6520);
		Eq_4 eax_6568 = g_t81424B8;
		word128 xmm1_13111;
		word32 edi_13110;
		word32 esi_13109;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13109, out edi_13110, out xmm1_13111);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6568;
		else
			runtime.writebarrierptr(0x00, eax_6568);
		Eq_4 eax_6616 = g_t81424E0;
		word128 xmm1_13108;
		word32 edi_13107;
		word32 esi_13106;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13106, out edi_13107, out xmm1_13108);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6616;
		else
			runtime.writebarrierptr(0x00, eax_6616);
		Eq_4 eax_6664 = g_t81424E4;
		word128 xmm1_13105;
		word32 edi_13104;
		word32 esi_13103;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13103, out edi_13104, out xmm1_13105);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6664;
		else
			runtime.writebarrierptr(0x00, eax_6664);
		Eq_4 eax_6712 = g_t81424F0;
		word128 xmm1_13102;
		word32 edi_13101;
		word32 esi_13100;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13100, out edi_13101, out xmm1_13102);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6712;
		else
			runtime.writebarrierptr(0x00, eax_6712);
		Eq_4 eax_6760 = g_t8142504;
		word128 xmm1_13099;
		word32 edi_13098;
		word32 esi_13097;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13097, out edi_13098, out xmm1_13099);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6760;
		else
			runtime.writebarrierptr(0x00, eax_6760);
		Eq_4 eax_6808 = g_t8142508;
		word128 xmm1_13096;
		word32 edi_13095;
		word32 esi_13094;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13094, out edi_13095, out xmm1_13096);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6808;
		else
			runtime.writebarrierptr(0x00, eax_6808);
		Eq_4 eax_6856 = g_t814251C;
		word128 xmm1_13093;
		word32 edi_13092;
		word32 esi_13091;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13091, out edi_13092, out xmm1_13093);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6856;
		else
			runtime.writebarrierptr(0x00, eax_6856);
		Eq_4 eax_6904 = g_t8142528;
		word128 xmm1_13090;
		word32 edi_13089;
		word32 esi_13088;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13088, out edi_13089, out xmm1_13090);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6904;
		else
			runtime.writebarrierptr(0x00, eax_6904);
		Eq_4 eax_6952 = g_t814252C;
		word128 xmm1_13087;
		word32 edi_13086;
		word32 esi_13085;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13085, out edi_13086, out xmm1_13087);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6952;
		else
			runtime.writebarrierptr(0x00, eax_6952);
		Eq_4 eax_7000 = g_t8142534;
		word128 xmm1_13084;
		word32 edi_13083;
		word32 esi_13082;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13082, out edi_13083, out xmm1_13084);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7000;
		else
			runtime.writebarrierptr(0x00, eax_7000);
		Eq_4 eax_7048 = g_t8142538;
		word128 xmm1_13081;
		word32 edi_13080;
		word32 esi_13079;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13079, out edi_13080, out xmm1_13081);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7048;
		else
			runtime.writebarrierptr(0x00, eax_7048);
		Eq_4 eax_7096 = g_t8142544;
		word128 xmm1_13078;
		word32 edi_13077;
		word32 esi_13076;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13076, out edi_13077, out xmm1_13078);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7096;
		else
			runtime.writebarrierptr(0x00, eax_7096);
		Eq_4 eax_7144 = g_t8142548;
		word128 xmm1_13075;
		word32 edi_13074;
		word32 esi_13073;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13073, out edi_13074, out xmm1_13075);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7144;
		else
			runtime.writebarrierptr(0x00, eax_7144);
		Eq_4 eax_7192 = g_t814254C;
		word128 xmm1_13072;
		word32 edi_13071;
		word32 esi_13070;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13070, out edi_13071, out xmm1_13072);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7192;
		else
			runtime.writebarrierptr(0x00, eax_7192);
		Eq_4 eax_7240 = g_t8142550;
		word128 xmm1_13069;
		word32 edi_13068;
		word32 esi_13067;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13067, out edi_13068, out xmm1_13069);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7240;
		else
			runtime.writebarrierptr(0x00, eax_7240);
		Eq_4 eax_7288 = g_t8142554;
		word128 xmm1_13066;
		word32 edi_13065;
		word32 esi_13064;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13064, out edi_13065, out xmm1_13066);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7288;
		else
			runtime.writebarrierptr(0x00, eax_7288);
		Eq_4 eax_7336 = g_t8142568;
		word128 xmm1_13063;
		word32 edi_13062;
		word32 esi_13061;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13061, out edi_13062, out xmm1_13063);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7336;
		else
			runtime.writebarrierptr(0x00, eax_7336);
		Eq_4 eax_7384 = g_t814256C;
		word128 xmm1_13060;
		word32 edi_13059;
		word32 esi_13058;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13058, out edi_13059, out xmm1_13060);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7384;
		else
			runtime.writebarrierptr(0x00, eax_7384);
		Eq_4 eax_7432 = g_t8142570;
		word128 xmm1_13057;
		word32 edi_13056;
		word32 esi_13055;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13055, out edi_13056, out xmm1_13057);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7432;
		else
			runtime.writebarrierptr(0x00, eax_7432);
		Eq_4 eax_7480 = g_t8142574;
		word32 esi_13052;
		word32 edi_13053;
		word128 xmm1_13054;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13052, out edi_13053, out xmm1_13054);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7480;
		else
			runtime.writebarrierptr(0x00, eax_7480);
		Eq_4 eax_7528 = g_t8142578;
		word32 esi_13049;
		word32 edi_13050;
		word128 xmm1_13051;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13049, out edi_13050, out xmm1_13051);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7528;
		else
			runtime.writebarrierptr(0x00, eax_7528);
		Eq_4 eax_7576 = g_t814257C;
		word32 esi_13046;
		word32 edi_13047;
		word128 xmm1_13048;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13046, out edi_13047, out xmm1_13048);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7576;
		else
			runtime.writebarrierptr(0x00, eax_7576);
		Eq_4 eax_7624 = g_t8142580;
		word32 esi_13043;
		word32 edi_13044;
		word128 xmm1_13045;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13043, out edi_13044, out xmm1_13045);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7624;
		else
			runtime.writebarrierptr(0x00, eax_7624);
		Eq_4 eax_7672 = g_t8142584;
		word32 esi_13040;
		word32 edi_13041;
		word128 xmm1_13042;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13040, out edi_13041, out xmm1_13042);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7672;
		else
			runtime.writebarrierptr(0x00, eax_7672);
		Eq_4 eax_7720 = g_t8142588;
		word32 esi_13037;
		word32 edi_13038;
		word128 xmm1_13039;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13037, out edi_13038, out xmm1_13039);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7720;
		else
			runtime.writebarrierptr(0x00, eax_7720);
		Eq_4 eax_7768 = g_t814258C;
		word32 esi_13034;
		word32 edi_13035;
		word128 xmm1_13036;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13034, out edi_13035, out xmm1_13036);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7768;
		else
			runtime.writebarrierptr(0x00, eax_7768);
		Eq_4 eax_7816 = g_t8142590;
		word32 esi_13031;
		word32 edi_13032;
		word128 xmm1_13033;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13031, out edi_13032, out xmm1_13033);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7816;
		else
			runtime.writebarrierptr(0x00, eax_7816);
		Eq_4 eax_7864 = g_t8142594;
		word32 esi_13028;
		word32 edi_13029;
		word128 xmm1_13030;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13028, out edi_13029, out xmm1_13030);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7864;
		else
			runtime.writebarrierptr(0x00, eax_7864);
		Eq_4 eax_7912 = g_t8142598;
		word32 esi_13025;
		word32 edi_13026;
		word128 xmm1_13027;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13025, out edi_13026, out xmm1_13027);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7912;
		else
			runtime.writebarrierptr(0x00, eax_7912);
		Eq_4 eax_7960 = g_t81425A0;
		word32 esi_13022;
		word32 edi_13023;
		word128 xmm1_13024;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13022, out edi_13023, out xmm1_13024);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7960;
		else
			runtime.writebarrierptr(0x00, eax_7960);
		Eq_4 eax_8008 = g_t81425A4;
		word32 esi_13019;
		word32 edi_13020;
		word128 xmm1_13021;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13019, out edi_13020, out xmm1_13021);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8008;
		else
			runtime.writebarrierptr(0x00, eax_8008);
		Eq_4 eax_8056 = g_t81425A8;
		word32 esi_13016;
		word32 edi_13017;
		word128 xmm1_13018;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13016, out edi_13017, out xmm1_13018);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8056;
		else
			runtime.writebarrierptr(0x00, eax_8056);
		Eq_4 eax_8104 = g_t81425AC;
		word32 esi_13013;
		word32 edi_13014;
		word128 xmm1_13015;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13013, out edi_13014, out xmm1_13015);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8104;
		else
			runtime.writebarrierptr(0x00, eax_8104);
		Eq_4 eax_8152 = g_t81425B0;
		word32 esi_13010;
		word32 edi_13011;
		word128 xmm1_13012;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13010, out edi_13011, out xmm1_13012);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8152;
		else
			runtime.writebarrierptr(0x00, eax_8152);
		Eq_4 eax_8200 = g_t81425B4;
		word32 esi_13007;
		word32 edi_13008;
		word128 xmm1_13009;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13007, out edi_13008, out xmm1_13009);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8200;
		else
			runtime.writebarrierptr(0x00, eax_8200);
		Eq_4 eax_8248 = g_t81425BC;
		word32 esi_13004;
		word32 edi_13005;
		word128 xmm1_13006;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13004, out edi_13005, out xmm1_13006);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8248;
		else
			runtime.writebarrierptr(0x00, eax_8248);
		Eq_4 eax_8296 = g_t81425C4;
		word32 esi_13001;
		word32 edi_13002;
		word128 xmm1_13003;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_13001, out edi_13002, out xmm1_13003);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8296;
		else
			runtime.writebarrierptr(0x00, eax_8296);
		Eq_4 eax_8344 = g_t81425CC;
		Eq_4 edi_8359;
		Eq_4 esi_8361;
		word128 xmm1_13000;
		Eq_6606 ebx_24_8_8413 = SLICE(runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_8361, out edi_8359, out xmm1_13000), word24, 8);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_8344;
			g_t8145000 = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_8344);
			runtime.writebarrierptr(0x08145000, dwLoc1C);
		}
		word32 edi_12994;
		word128 xmm0_12995;
		word128 xmm1_12996;
		runtime.makemap(ebx_24_8_8413, esi_8361, edi_8359, gs, 0x080CFB40, 0x22, 0x00, 0x00, 0x00, out edi_12994, out xmm0_12995, out xmm1_12996);
		Eq_4 ecx_8434 = g_t81422A8;
		word32 esi_12997;
		word32 edi_12998;
		word128 xmm1_12999;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12997, out edi_12998, out xmm1_12999);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_8434;
		else
			runtime.writebarrierptr(0x00, ecx_8434);
		Eq_4 eax_8479 = g_t81422DC;
		word32 esi_12991;
		word32 edi_12992;
		word128 xmm1_12993;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12991, out edi_12992, out xmm1_12993);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8479;
		else
			runtime.writebarrierptr(0x00, eax_8479);
		Eq_4 eax_8527 = g_t8142334;
		word32 esi_12988;
		word32 edi_12989;
		word128 xmm1_12990;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12988, out edi_12989, out xmm1_12990);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8527;
		else
			runtime.writebarrierptr(0x00, eax_8527);
		Eq_4 eax_8575 = g_t8142338;
		word32 esi_12985;
		word32 edi_12986;
		word128 xmm1_12987;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12985, out edi_12986, out xmm1_12987);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8575;
		else
			runtime.writebarrierptr(0x00, eax_8575);
		Eq_4 eax_8623 = g_t8142344;
		word32 esi_12982;
		word32 edi_12983;
		word128 xmm1_12984;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12982, out edi_12983, out xmm1_12984);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8623;
		else
			runtime.writebarrierptr(0x00, eax_8623);
		Eq_4 eax_8671 = g_t8142358;
		word32 esi_12979;
		word32 edi_12980;
		word128 xmm1_12981;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12979, out edi_12980, out xmm1_12981);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8671;
		else
			runtime.writebarrierptr(0x00, eax_8671);
		Eq_4 eax_8719 = g_t814238C;
		word32 esi_12976;
		word32 edi_12977;
		word128 xmm1_12978;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12976, out edi_12977, out xmm1_12978);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8719;
		else
			runtime.writebarrierptr(0x00, eax_8719);
		Eq_4 eax_8767 = g_t8142394;
		word32 esi_12973;
		word32 edi_12974;
		word128 xmm1_12975;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12973, out edi_12974, out xmm1_12975);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8767;
		else
			runtime.writebarrierptr(0x00, eax_8767);
		Eq_4 eax_8815 = g_t8142398;
		word32 esi_12970;
		word32 edi_12971;
		word128 xmm1_12972;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12970, out edi_12971, out xmm1_12972);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8815;
		else
			runtime.writebarrierptr(0x00, eax_8815);
		Eq_4 eax_8863 = g_t814239C;
		word32 esi_12967;
		word32 edi_12968;
		word128 xmm1_12969;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12967, out edi_12968, out xmm1_12969);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8863;
		else
			runtime.writebarrierptr(0x00, eax_8863);
		Eq_4 eax_8911 = g_t81423A0;
		word32 esi_12964;
		word32 edi_12965;
		word128 xmm1_12966;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12964, out edi_12965, out xmm1_12966);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8911;
		else
			runtime.writebarrierptr(0x00, eax_8911);
		Eq_4 eax_8959 = g_t81423B8;
		word32 esi_12961;
		word32 edi_12962;
		word128 xmm1_12963;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12961, out edi_12962, out xmm1_12963);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8959;
		else
			runtime.writebarrierptr(0x00, eax_8959);
		Eq_4 eax_9007 = g_t8142408;
		word32 esi_12958;
		word32 edi_12959;
		word128 xmm1_12960;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12958, out edi_12959, out xmm1_12960);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9007;
		else
			runtime.writebarrierptr(0x00, eax_9007);
		Eq_4 eax_9055 = g_t8142488;
		word32 esi_12955;
		word32 edi_12956;
		word128 xmm1_12957;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12955, out edi_12956, out xmm1_12957);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9055;
		else
			runtime.writebarrierptr(0x00, eax_9055);
		Eq_4 eax_9103 = g_t81424BC;
		word32 esi_12952;
		word32 edi_12953;
		word128 xmm1_12954;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12952, out edi_12953, out xmm1_12954);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9103;
		else
			runtime.writebarrierptr(0x00, eax_9103);
		Eq_4 eax_9151 = g_t81424C0;
		word32 esi_12949;
		word32 edi_12950;
		word128 xmm1_12951;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12949, out edi_12950, out xmm1_12951);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9151;
		else
			runtime.writebarrierptr(0x00, eax_9151);
		Eq_4 eax_9199 = g_t81424C4;
		word32 esi_12946;
		word32 edi_12947;
		word128 xmm1_12948;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12946, out edi_12947, out xmm1_12948);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9199;
		else
			runtime.writebarrierptr(0x00, eax_9199);
		Eq_4 eax_9247 = g_t81424C8;
		word32 esi_12943;
		word32 edi_12944;
		word128 xmm1_12945;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12943, out edi_12944, out xmm1_12945);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9247;
		else
			runtime.writebarrierptr(0x00, eax_9247);
		Eq_4 eax_9295 = g_t81424CC;
		word32 esi_12940;
		word32 edi_12941;
		word128 xmm1_12942;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12940, out edi_12941, out xmm1_12942);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9295;
		else
			runtime.writebarrierptr(0x00, eax_9295);
		Eq_4 eax_9343 = g_t81424D0;
		word32 esi_12937;
		word32 edi_12938;
		word128 xmm1_12939;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12937, out edi_12938, out xmm1_12939);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9343;
		else
			runtime.writebarrierptr(0x00, eax_9343);
		Eq_4 eax_9391 = g_t81424D4;
		word32 esi_12934;
		word32 edi_12935;
		word128 xmm1_12936;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12934, out edi_12935, out xmm1_12936);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9391;
		else
			runtime.writebarrierptr(0x00, eax_9391);
		Eq_4 eax_9439 = g_t81424D8;
		word32 esi_12931;
		word32 edi_12932;
		word128 xmm1_12933;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12931, out edi_12932, out xmm1_12933);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9439;
		else
			runtime.writebarrierptr(0x00, eax_9439);
		Eq_4 eax_9487 = g_t81424E8;
		word32 esi_12928;
		word32 edi_12929;
		word128 xmm1_12930;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12928, out edi_12929, out xmm1_12930);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9487;
		else
			runtime.writebarrierptr(0x00, eax_9487);
		Eq_4 eax_9535 = g_t81424EC;
		word32 esi_12925;
		word32 edi_12926;
		word128 xmm1_12927;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12925, out edi_12926, out xmm1_12927);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9535;
		else
			runtime.writebarrierptr(0x00, eax_9535);
		Eq_4 eax_9583 = g_t8142514;
		word32 esi_12922;
		word32 edi_12923;
		word128 xmm1_12924;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12922, out edi_12923, out xmm1_12924);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9583;
		else
			runtime.writebarrierptr(0x00, eax_9583);
		Eq_4 eax_9631 = g_t8142520;
		word32 esi_12919;
		word32 edi_12920;
		word128 xmm1_12921;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12919, out edi_12920, out xmm1_12921);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9631;
		else
			runtime.writebarrierptr(0x00, eax_9631);
		Eq_4 eax_9679 = g_t8142524;
		word128 xmm1_12918;
		word32 edi_12917;
		word32 esi_12916;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12916, out edi_12917, out xmm1_12918);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9679;
		else
			runtime.writebarrierptr(0x00, eax_9679);
		Eq_4 eax_9727 = g_t8142540;
		word128 xmm1_12915;
		word32 edi_12914;
		word32 esi_12913;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12913, out edi_12914, out xmm1_12915);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9727;
		else
			runtime.writebarrierptr(0x00, eax_9727);
		Eq_4 eax_9775 = g_t8142540;
		word128 xmm1_12912;
		word32 edi_12911;
		word32 esi_12910;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12910, out edi_12911, out xmm1_12912);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9775;
		else
			runtime.writebarrierptr(0x00, eax_9775);
		Eq_4 eax_9823 = g_t8142564;
		word128 xmm1_12909;
		word32 edi_12908;
		word32 esi_12907;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12907, out edi_12908, out xmm1_12909);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9823;
		else
			runtime.writebarrierptr(0x00, eax_9823);
		Eq_4 eax_9871 = g_t814259C;
		word128 xmm1_12906;
		word32 edi_12905;
		word32 esi_12904;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12904, out edi_12905, out xmm1_12906);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9871;
		else
			runtime.writebarrierptr(0x00, eax_9871);
		Eq_4 eax_9919 = g_t81425B8;
		word128 xmm1_12903;
		word32 edi_12902;
		word32 esi_12901;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12901, out edi_12902, out xmm1_12903);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9919;
		else
			runtime.writebarrierptr(0x00, eax_9919);
		Eq_4 eax_9967 = g_t81425C0;
		word128 xmm1_12900;
		word32 edi_12899;
		word32 esi_12898;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12898, out edi_12899, out xmm1_12900);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9967;
		else
			runtime.writebarrierptr(0x00, eax_9967);
		Eq_4 eax_10015 = g_t81425C8;
		Eq_4 edi_10030;
		Eq_4 esi_10032;
		word128 xmm1_12897;
		Eq_6606 ebx_24_8_10084 = SLICE(runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_10032, out edi_10030, out xmm1_12897), word24, 8);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_10015;
			g_t8144FFC = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_10015);
			runtime.writebarrierptr(0x08144FFC, dwLoc1C);
		}
		word128 xmm1_12893;
		word128 xmm0_12892;
		word32 edi_12891;
		runtime.makemap(ebx_24_8_10084, esi_10032, edi_10030, gs, 0x080CFB40, 0x06, 0x00, 0x00, 0x00, out edi_12891, out xmm0_12892, out xmm1_12893);
		Eq_4 ecx_10105 = g_t81425EC;
		word128 xmm1_12896;
		word32 edi_12895;
		word32 esi_12894;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12894, out edi_12895, out xmm1_12896);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_10105;
		else
			runtime.writebarrierptr(0x00, ecx_10105);
		Eq_4 eax_10150 = g_t81425F0;
		word128 xmm1_12890;
		word32 edi_12889;
		word32 esi_12888;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12888, out edi_12889, out xmm1_12890);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10150;
		else
			runtime.writebarrierptr(0x00, eax_10150);
		Eq_4 eax_10198 = g_t81425F4;
		word128 xmm1_12887;
		word32 edi_12886;
		word32 esi_12885;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12885, out edi_12886, out xmm1_12887);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10198;
		else
			runtime.writebarrierptr(0x00, eax_10198);
		Eq_4 eax_10246 = g_t81425F8;
		word128 xmm1_12884;
		word32 edi_12883;
		word32 esi_12882;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12882, out edi_12883, out xmm1_12884);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10246;
		else
			runtime.writebarrierptr(0x00, eax_10246);
		Eq_4 eax_10294 = g_t81425FC;
		word128 xmm1_12881;
		word32 edi_12880;
		word32 esi_12879;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12879, out edi_12880, out xmm1_12881);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10294;
		else
			runtime.writebarrierptr(0x00, eax_10294);
		Eq_4 eax_10342 = g_t8142600;
		Eq_4 edi_10357;
		Eq_4 esi_10359;
		word128 xmm1_12878;
		Eq_6606 ebx_24_8_10411 = SLICE(runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_10359, out edi_10357, out xmm1_12878), word24, 8);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_10342;
			g_t8144FF4 = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_10342);
			runtime.writebarrierptr(0x08144FF4, dwLoc1C);
		}
		word128 xmm1_12874;
		word128 xmm0_12873;
		word32 edi_12872;
		runtime.makemap(ebx_24_8_10411, esi_10359, edi_10357, gs, 0x080CFB40, 0x03, 0x00, 0x00, 0x00, out edi_12872, out xmm0_12873, out xmm1_12874);
		Eq_4 ecx_10432 = g_t81425E0;
		word128 xmm1_12877;
		word32 edi_12876;
		word32 esi_12875;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12875, out edi_12876, out xmm1_12877);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_10432;
		else
			runtime.writebarrierptr(0x00, ecx_10432);
		Eq_4 eax_10477 = g_t81425E4;
		word128 xmm1_12871;
		word32 edi_12870;
		word32 esi_12869;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12869, out edi_12870, out xmm1_12871);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10477;
		else
			runtime.writebarrierptr(0x00, eax_10477);
		Eq_4 eax_10525 = g_t81425E8;
		word128 xmm1_10545;
		word32 edi_12868;
		word32 esi_12867;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_12867, out edi_12868, out xmm1_10545);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_10525;
			g_t8144FF8 = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_10525);
			runtime.writebarrierptr(0x08144FF8, dwLoc1C);
		}
		g_b8157588 = 0x02;
		return xmm1_10545;
	}
	else
		runtime.throwinit(gs);
}

// 080A4A80: Register word128 reflect.makeMethodValue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Register out Eq_114483 xmm1Out)
// Called from:
//      reflect.valueInterface
//      reflect.Value.assignTo
word128 reflect.makeMethodValue(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, union Eq_114483 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg14 & 0x0200) == 0x00)
		runtime.gopanic(gs);
	else
	{
		byte dl_39 = (byte) (word32) *((word32) dwArg0C + 0x0F);
		reflect.Value.Type(gs, dwArg0C, dwArg14);
		ui32 edx_57 = (word32) dl_39 & 0x1F | dwArg14 & 0x01E0;
		if (dwLoc38 != 0x08138A00)
			runtime.panicdottypeI(gs, dwLoc38);
		else
		{
			Eq_4 ecx_81 = g_t80E7B64;
			Eq_114483 xmm1_94;
			word128 xmm0_93 = reflect.funcLayout(gs, dwLoc34, 0x00, out xmm1_94);
			runtime.newobject(gs, 0x080D6B20);
			null = (union Eq_4 *) ecx_81;
			if (g_t81576F0 == 0x00)
				*(union Eq_4 *) 0x04 = dwLoc30;
			else
				runtime.writebarrierptr(0x04, dwLoc30);
			*(union Eq_4 *) 0x08 = dwArg14 >> 0x0A;
			*(ui32 *) 0x14 = edx_57;
			if (g_t81576F0 == 0x00)
			{
				*(union Eq_4 *) 0x0C = dwArg0C;
				*(union Eq_4 *) 0x10 = dwArg10;
			}
			else
			{
				runtime.writebarrierptr(0x0C, dwArg0C);
				runtime.writebarrierptr(0x10, dwArg10);
			}
			reflect.methodReceiver(gs, *(union Eq_4 *) 0x0C, dwArg10, *(union Eq_4 *) 0x08);
			xmm1Out = xmm1_94;
			return xmm0_93;
		}
	}
}

// 080A4C70: void reflect.name.tagLen(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.name.tag
//      reflect.name.pkgPath
void reflect.name.tagLen(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((byte) (word32) *dwArg04 & 0x02) != 0x00)
		;
}

// 080A4CE0: void reflect.name.tag(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).Field
//      reflect.haveIdenticalUnderlyingType
void reflect.name.tag(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.name.tagLen(gs, dwArg04);
	if (dwLoc04 != 0x00)
		;
}

// 080A4D60: void reflect.name.pkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*interfaceType).Method
//      reflect.(*structType).Field
//      reflect.implements
//      reflect.haveIdenticalUnderlyingType
void reflect.name.pkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00 || ((byte) ((word32) (*dwArg04)) & 0x04) == 0x00)
		return;
	int32 eax_56;
	word16 dx_31 = (word16) (word32) *((word32) dwArg04 + 1);
	word16 cx_34 = (word16) (word32) *((word32) dwArg04 + 2);
	reflect.name.tagLen(gs, dwArg04);
	word32 eax_51 = (word32) (word16) ((word32) dx_31 << 0x08 | (word32) cx_34);
	if (dwLoc18 > 0x00)
		eax_56 = dwLoc18 + 0x05 + eax_51;
	else
		eax_56 = eax_51 + 0x03;
	word32 ebp_195;
	word32 esi_196;
	word32 edi_197;
	runtime.memmove(fp - 0x0C, (word32) dwArg04 + eax_56, 0x04, out ebp_195, out esi_196, out edi_197);
	reflect.resolveTypeOff(gs);
}

// 080A4E80: Register Eq_4 reflect.newName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack word32 dwArg18, Stack byte bArg1C, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
Eq_4 reflect.newName(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, word32 dwArg18, byte bArg1C, ptr32 & esiOut, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 > 0xFFFF)
	{
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if (dwArg10 > 0xFFFF)
	{
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x10);
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 ebx_124;
		ui32 ebp_125;
		if (dwArg10 > 0x00)
		{
			ebx_124 = (word32) dwArg08 + ((word32) dwArg10 + 5);
			ebp_125 = (word32) bArg1C | 0x02;
		}
		else
		{
			ebx_124 = (word32) dwArg08 + 3;
			ebp_125 = (word32) bArg1C;
		}
		if (dwArg18 != 0x00)
			ebp_125 |= 0x04;
		word32 edi_431;
		runtime.makeslice(gs, 0x080CF320, ebx_124, ebx_124, out edi_431);
		byte al_148 = (byte) ebp_125;
		if (dwLoc30 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			dwLoc34->a0000[0] = (byte) (word32) al_148;
			if (dwLoc30 <= 0x01)
				runtime.panicindex(gs);
			else
			{
				dwLoc34->t0001 = (byte) (dwArg08 >> 0x08);
				if (dwLoc30 <= 0x02)
					runtime.panicindex(gs);
				else
				{
					dwLoc34->b0002 = (byte) dwArg08;
					Eq_4 ebp_200 = dwArg08;
					Eq_4 ebx_206 = dwLoc34 + (0x03 - dwLoc2C >> 0x1F & 0x03) / 3;
					if (dwLoc30 - 0x03 <= dwArg08)
						ebp_200 = dwLoc30 - 0x03;
					bool Z_296;
					word32 ebp_223;
					ptr32 edi_219;
					ptr32 esi_220;
					Eq_4 ebx_218 = runtime.memmove(ebx_206, dwArg04, ebp_200, out ebp_223, out esi_220, out edi_219);
					if (dwArg10 > 0x00)
					{
						if ((word32) dwArg08 + 3 > dwLoc30)
							runtime.panicslice(gs);
						int32 ebx_242 = dwLoc2C - ((word32) dwArg08 + 3);
						int32 ebx_246 = -ebx_242 >> 0x1F & (word32) dwArg08 + 3;
						Eq_114842 edx_240 = dwLoc30 - ((word32) dwArg08 + 3);
						ui32 esi_248 = dwLoc34 + ebx_246 / 3;
						if (edx_240 <= 0x00)
							runtime.panicindex(gs);
						dwLoc34[ebx_246 / 3] = (struct Eq_114779) (byte) (dwArg10 >> 0x08);
						if (edx_240 <= 0x01)
							runtime.panicindex(gs);
						*((char *) &dwLoc34->t0001 + ebx_246) = (union Eq_114789 *) (byte) dwArg10;
						Eq_4 edi_265 = dwArg10;
						Eq_4 eax_270 = (0x02 - ebx_242 >> 0x1F & 0x02) + esi_248;
						if ((word32) edx_240 - 2 <= dwArg10)
							edi_265 = (word32) edx_240 - 2;
						word32 ebp_287;
						ebx_218 = runtime.memmove(eax_270, dwArg0C, edi_265, out ebp_287, out esi_220, out edi_219);
						Z_296 = SLICE(cond(dwArg18), bool, 2);
					}
					else
						Z_296 = SLICE(cond(dwArg18), bool, 2);
					if (Z_296)
						runtime.gopanic(gs);
					else
					{
						esiOut = esi_220;
						ediOut = edi_219;
						return ebx_218;
					}
				}
			}
		}
	}
}

// 080A5140: void reflect.Kind.String(Register Eq_4 ebx, Register word32 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack Eq_101636 dwArg04)
// Called from:
//      reflect.(*ValueError).Error
//      reflect.(*Kind).String
void reflect.Kind.String(Eq_4 ebx, word32 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, Eq_101636 dwArg04)
{
	Eq_101714 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_101636 eax_17 = g_t81426B4;
	if (dwArg04 >= eax_17)
	{
		strconv.Itoa(ebx_24_8, ebp, esi, gs, dwArg04);
		runtime.concatstring2(gs, 0x00);
	}
	else
	{
		if (dwArg04 < eax_17)
			return;
		runtime.panicindex(gs);
	}
}

// 080A51E0: void reflect.resolveReflectName(Register Eq_114922 ebx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
void reflect.resolveReflectName(Eq_114922 ebx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.addReflectOff(ebx_24_8, esi, edi, gs, dwArg04);
}

// 080A5220: Register word32 reflect.(*rtype).nameOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).String
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).Method
//      reflect.(*interfaceType).MethodByName
//      reflect.implements
//      reflect.methodReceiver
//      reflect.(*sliceType).MethodByName
//      reflect.(*sliceType).PkgPath
word32 reflect.(*rtype).nameOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return reflect.resolveNameOff(gs, dwArg04, dwArg08);
}

// 080A5260: void reflect.(*rtype).typeOff(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).Method
//      reflect.(*rtype).ptrTo
//      reflect.implements
//      reflect.methodReceiver
//      reflect.Value.Type
void reflect.(*rtype).typeOff(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.resolveTypeOff(gs);
}

// 080A52A0: void reflect.(*rtype).textOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).Method
//      reflect.methodReceiver
void reflect.(*rtype).textOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.resolveTextOff(gs, dwArg04, dwArg08);
}

// 080A52E0: void reflect.(*rtype).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).exportedMethods
//      reflect.implements
//      reflect.methodReceiver
//      reflect.Value.Type
//      reflect.(*structType).uncommon
//      reflect.(*funcType).uncommon
//      reflect.(*funcTypeFixed128).uncommon
//      reflect.(*funcTypeFixed16).uncommon
//      reflect.(*funcTypeFixed32).uncommon
//      reflect.(*funcTypeFixed4).uncommon
//      reflect.(*funcTypeFixed64).uncommon
//      reflect.(*funcTypeFixed8).uncommon
//      reflect.(*interfaceType).uncommon
//      reflect.(*ptrType).uncommon
//      reflect.(*sliceType).uncommon
//      reflect.(*sliceType).MethodByName
//      reflect.(*sliceType).PkgPath
void reflect.(*rtype).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) == 0x00)
		return;
	ui32 ecx_23 = (word32) *((word32) dwArg04 + 0x0F);
	if ((ecx_23 & 0x1F) > 0x14)
	{
		if ((ecx_23 & 0x1F) > 22)
		{
			if ((ecx_23 & 0x1F) == 0x17)
				return;
			if ((ecx_23 & 0x1F) != 0x19)
				;
		}
		else if ((ecx_23 & 0x1F) != 0x15)
			;
	}
	else if ((ecx_23 & 0x1F) > 0x12)
	{
		if ((ecx_23 & 0x1F) != 0x13)
			;
	}
	else
	{
		if ((ecx_23 & 0x1F) == 0x11)
			return;
		if ((ecx_23 & 0x1F) == 0x12)
			;
	}
}

// 080A53A0: void reflect.(*rtype).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).Name
//      reflect.(*rtype).ptrTo
//      reflect.typesByString
//      reflect.funcStr
//      reflect.funcLayout
//      reflect.Value.assignTo
//      reflect.(*structType).String
//      reflect.(*funcType).String
//      reflect.(*funcTypeFixed128).String
//      reflect.(*funcTypeFixed16).String
//      reflect.(*funcTypeFixed32).String
//      reflect.(*funcTypeFixed4).String
//      reflect.(*funcTypeFixed64).String
//      reflect.(*funcTypeFixed8).String
//      reflect.(*interfaceType).String
//      reflect.(*ptrType).String
//      reflect.(*sliceType).String
//      reflect.(*sliceType).Bits
void reflect.(*rtype).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).nameOff(gs, dwArg04, *((word32) dwArg04 + 24));
	uint32 dwLoc04_82 = 0x00;
	if (dwLoc0C != null)
		dwLoc04_82 = (word32) dwLoc0C->b0001 << 0x08 | (word32) dwLoc0C->b0002;
	if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x02) == 0x00)
		return;
	if (dwLoc04_82 >= 0x01)
		return;
	runtime.panicslice(gs);
}

// 080A5450: void reflect.(*rtype).Size(Register (ptr32 Eq_115100) gs)
// Called from:
//      reflect.(*structType).Size
//      reflect.(*funcType).Size
//      reflect.(*funcTypeFixed128).Size
//      reflect.(*funcTypeFixed16).Size
//      reflect.(*funcTypeFixed32).Size
//      reflect.(*funcTypeFixed4).Size
//      reflect.(*funcTypeFixed64).Size
//      reflect.(*funcTypeFixed8).Size
//      reflect.(*interfaceType).Size
//      reflect.(*ptrType).Size
//      reflect.(*sliceType).Size
void reflect.(*rtype).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A5480: void reflect.(*rtype).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).Bits
//      reflect.(*funcType).Bits
//      reflect.(*funcTypeFixed128).Bits
//      reflect.(*funcTypeFixed16).Bits
//      reflect.(*funcTypeFixed32).Bits
//      reflect.(*funcTypeFixed4).Bits
//      reflect.(*funcTypeFixed64).Bits
//      reflect.(*funcTypeFixed8).Bits
//      reflect.(*interfaceType).Bits
//      reflect.(*ptrType).Bits
//      reflect.(*sliceType).Bits
void reflect.(*rtype).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.gopanic(gs);
	else
	{
		if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) <= ~0x0F)
			return;
		reflect.(*rtype).String(gs, dwArg04);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x08);
		runtime.gopanic(gs);
	}
}

// 080A5560: void reflect.(*rtype).Align(Register (ptr32 Eq_115152) gs)
// Called from:
//      reflect.(*structType).Align
//      reflect.(*funcType).Align
//      reflect.(*funcTypeFixed128).Align
//      reflect.(*funcTypeFixed16).Align
//      reflect.(*funcTypeFixed32).Align
//      reflect.(*funcTypeFixed4).Align
//      reflect.(*funcTypeFixed64).Align
//      reflect.(*funcTypeFixed8).Align
//      reflect.(*interfaceType).Align
//      reflect.(*ptrType).Align
//      reflect.(*sliceType).Align
void reflect.(*rtype).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A5590: void reflect.(*rtype).FieldAlign(Register (ptr32 Eq_115165) gs)
// Called from:
//      reflect.(*structType).FieldAlign
//      reflect.(*funcType).FieldAlign
//      reflect.(*funcTypeFixed128).FieldAlign
//      reflect.(*funcTypeFixed16).FieldAlign
//      reflect.(*funcTypeFixed32).FieldAlign
//      reflect.(*funcTypeFixed4).FieldAlign
//      reflect.(*funcTypeFixed64).FieldAlign
//      reflect.(*funcTypeFixed8).FieldAlign
//      reflect.(*interfaceType).FieldAlign
//      reflect.(*ptrType).FieldAlign
//      reflect.(*sliceType).FieldAlign
void reflect.(*rtype).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A55C0: void reflect.(*rtype).Kind(Register (ptr32 Eq_115178) gs)
// Called from:
//      reflect.(*structType).Kind
//      reflect.(*funcType).Kind
//      reflect.(*funcTypeFixed128).Kind
//      reflect.(*funcTypeFixed16).Kind
//      reflect.(*funcTypeFixed32).Kind
//      reflect.(*funcTypeFixed4).Kind
//      reflect.(*funcTypeFixed64).Kind
//      reflect.(*funcTypeFixed8).Kind
//      reflect.(*interfaceType).Kind
//      reflect.(*ptrType).Kind
//      reflect.(*sliceType).Kind
void reflect.(*rtype).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A55F0: void reflect.(*rtype).common(Register (ptr32 Eq_115191) gs)
// Called from:
//      reflect.(*structType).common
//      reflect.(*funcType).common
//      reflect.(*funcTypeFixed128).common
//      reflect.(*funcTypeFixed16).common
//      reflect.(*funcTypeFixed32).common
//      reflect.(*funcTypeFixed4).common
//      reflect.(*funcTypeFixed64).common
//      reflect.(*funcTypeFixed8).common
//      reflect.(*interfaceType).common
//      reflect.(*ptrType).common
//      reflect.(*sliceType).common
void reflect.(*rtype).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A5620: Register word128 reflect.(*rtype).exportedMethods(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_115207 xmm1Out)
// Called from:
//      reflect.(*rtype).NumMethod
//      reflect.(*rtype).Method
word128 reflect.(*rtype).exportedMethods(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_115207 & xmm1Out)
{
	byte bLoc48 = (byte) dwLoc48;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.(*Map).Load(gs, 0x08145220, 0x080DDF40, dwArg04);
	Eq_4 dwLoc54_338 = dwArg04;
	if ((byte) (word32) bLoc48 != 0x00)
	{
		if (dwLoc50 != 0x080C9840)
			runtime.panicdottypeE(gs, dwLoc50);
		else
		{
			xmm1Out = xmm1;
			return xmm0;
		}
	}
	else
	{
		reflect.(*rtype).uncommon(gs, dwArg04);
		if (0x080DDF40 == 0x00)
		{
			xmm1Out = xmm1;
			return xmm0;
		}
		else
		{
			word32 ecx_74 = g_dw80DDF48;
			struct Eq_115246 * ecx_118 = ecx_74 + 0x080DDF40;
			Eq_4 eax_79 = (word32) g_w80DDF44;
			if (eax_79 > 0x00010000)
				runtime.panicslice(gs);
			else
			{
				Eq_4 ebx_104 = 0x00;
				while (true)
				{
					byte al_126;
					if (ebx_104 >= eax_79)
						break;
					ebx_104 = reflect.(*rtype).nameOff(gs, dwArg04, ecx_118->dw0000);
					if (((byte) (word32) *dwArg04 & 0x01) == 0x00)
					{
						al_126 = 0x00;
						goto l080A56F2;
					}
					++ecx_118;
					ebx_104 = (word32) ebx_104 + 1;
				}
				al_126 = 0x01;
l080A56F2:
				if (al_126 == 0x00)
				{
					word32 edi_494;
					runtime.makeslice(gs, 0x080D6AA0, 0x00, eax_79, out edi_494);
					dwLoc54_338 = eax_79;
					Eq_4 eax_154 = dwLoc50;
					Eq_4 ecx_155 = dwLoc4C;
					Eq_4 edx_156 = dwLoc48;
					ebx_104.u0 = 0x00;
					struct Eq_115292 * ebp_160 = ecx_74 + 0x080DDF40;
					while (ebx_104 < eax_79)
					{
						Eq_4 ebx_270;
						word32 eax_244 = ebp_160->dw000C;
						Eq_4 ecx_246 = ebp_160->dw0000;
						word32 edx_248 = ebp_160->dw0008;
						word32 ebx_250 = ebp_160->dw0004;
						reflect.(*rtype).nameOff(gs, dwArg04, ecx_246);
						if (((byte) (word32) *dwLoc54_338 & 0x01) != 0x00)
						{
							ecx_155 = (word32) ecx_155 + 1;
							if ((word32) ecx_155 + 1 <= edx_156)
								ebx_270 = eax_154;
							else
							{
								word32 esi_495;
								runtime.growslice(gs, 0x080D6AA0, eax_154, ecx_155, edx_156, (word32) ecx_155 + 1, out esi_495);
								dwLoc54_338 = ecx_155;
								dwLoc50 = edx_156;
								ebx_270 = dwLoc48;
								edx_156 = dwLoc40;
								ecx_155 = dwLoc44 + 0x01;
							}
							int32 eax_303 = ecx_155 << 0x04;
							*((word32) ebx_270 + eax_303) = ecx_246;
							(word32) ebx_270 + 4 + eax_303 = ebx_250;
							(word32) ebx_270 + 8 + eax_303 = edx_248;
							(word32) ebx_270 + 0x0C + eax_303 = eax_244;
						}
						else
							ebx_270 = eax_154;
						++ebp_160;
						eax_154 = ebx_270;
						ebx_104 = (byte) ebx_104.u0 + 1;
					}
				}
				runtime.convT2Eslice(ebx_104, gs, 0x080C9840, fp - 0x0C);
				Eq_115207 xmm1_214;
				word128 xmm0_213 = sync.(*Map).LoadOrStore(gs, 0x08145220, dwLoc54_338, dwLoc50, out xmm1_214);
				if (dwLoc48 != 0x080C9840)
					runtime.panicdottypeE(gs, dwLoc48);
				else
				{
					xmm1Out = xmm1_214;
					return xmm0_213;
				}
			}
		}
	}
}

// 080A5930: Register word128 reflect.(*rtype).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_115382 xmm1Out)
// Called from:
//      reflect.Value.Elem
//      reflect.Value.NumMethod
//      reflect.Value.assignTo
//      reflect.(*structType).NumMethod
//      reflect.(*funcType).NumMethod
//      reflect.(*funcTypeFixed128).NumMethod
//      reflect.(*funcTypeFixed16).NumMethod
//      reflect.(*funcTypeFixed32).NumMethod
//      reflect.(*funcTypeFixed4).NumMethod
//      reflect.(*funcTypeFixed64).NumMethod
//      reflect.(*funcTypeFixed8).NumMethod
//      reflect.(*ptrType).NumMethod
//      reflect.(*sliceType).NumMethod
word128 reflect.(*rtype).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_115382 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x14)
	{
		xmm1Out = xmm1;
		return xmm0;
	}
	else if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
	{
		Eq_115382 xmm1_41;
		word128 xmm0_40 = reflect.(*rtype).exportedMethods(gs, dwArg04, out xmm1_41);
		xmm1Out = xmm1_41;
		return xmm0_40;
	}
	else
	{
		xmm1Out = xmm1;
		return xmm0;
	}
}

// 080A5990: void reflect.(*rtype).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).Method
//      reflect.(*funcType).Method
//      reflect.(*funcTypeFixed128).Method
//      reflect.(*funcTypeFixed16).Method
//      reflect.(*funcTypeFixed32).Method
//      reflect.(*funcTypeFixed4).Method
//      reflect.(*funcTypeFixed64).Method
//      reflect.(*funcTypeFixed8).Method
//      reflect.(*ptrType).Method
//      reflect.(*sliceType).Method
//      reflect.(*sliceType).MethodByName
void reflect.(*rtype).Method(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp - 0x4C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, fp + 0x0C);
	if (((word32) *((word32) dwArg00 + 0x0F) & 0x1F) != 0x14)
	{
		word128 xmm1_1142;
		reflect.(*rtype).exportedMethods(gs, dwArg00, out xmm1_1142);
		if (dwArg04 < 0x00 || dwArg04 >= dwLocC8)
			runtime.gopanic(gs);
		else
		{
			Eq_4 ebp_75 = dwLocCC[dwArg04].t0004;
			reflect.(*rtype).nameOff(gs, dwArg00, dwLocCC[dwArg04].t0000);
			reflect.(*rtype).typeOff(gs);
			((byte) (word32) *((word32) dwLocC8 + 0x0C) & 0x01) == 0x00;
			up32 ecx_138 = (word32) *((word32) dwLocC8 + 32);
			if (ecx_138 > 0x00100000)
				runtime.panicslice(gs);
			else
			{
				Eq_4 dwLocC0_797;
				word32 edi_1143;
				runtime.makeslice(gs, 135117536, 0x00, ecx_138 + 0x01, out edi_1143);
				Eq_4 eax_161 = dwLocBC;
				Eq_4 ecx_162 = dwLocC4;
				Eq_4 ebx_164 = (word32) dwLocC0 + 1;
				dwLocC0_797 = dwLocC0;
				if ((word32) dwLocC0 + 1 > dwLocBC)
				{
					word32 esi_1144;
					runtime.growslice(gs, 135117536, dwLocC4, dwLocC0, dwLocBC, (word32) dwLocC0 + 1, out esi_1144);
					dwLocC4 = dwLocBC;
					dwLocC0_797 = (word32) dwLocC0 + 1;
					ecx_162 = dwLocBC;
					ebx_164 = dwLocB8 + 0x01;
					eax_161 = dwLocB4;
				}
				*((word32) ecx_162 + dwLocC0 * 0x08) = 0x08138A00;
				Eq_4 edx_196 = (word32) ecx_162 + 4 + dwLocC0 * 0x08;
				if (g_t81576F0 == 0x00)
					*edx_196 = dwArg00;
				else
				{
					runtime.writebarrierptr(edx_196, dwArg00);
					dwLoc88 = eax_161;
				}
				int32 edi_240;
				ptr32 esi_637 = 0x08138A00;
				Eq_4 ecx_314 = ecx_162;
				Eq_4 ebx_267 = ebx_164;
				if (((byte) (word32) *((word32) dwLocC8 + 0x0C) & 0x01) != 0x00)
					edi_240 = 0x34;
				else
					edi_240 = 0x24;
				word32 * ebp_245 = (word32) dwLocC8 + edi_240;
				Eq_115562 edi_250 = (word32) *((word32) dwLocC8 + 32);
				if (edi_250 > 0x00100000)
					runtime.panicslice(gs);
				else
				{
					Eq_115562 dwLoc78_817 = 0x00;
					Eq_4 eax_266 = eax_161;
					while (dwLoc78_817 < edi_250)
					{
						dwLoc3C = ebp_245;
						Eq_4 edi_608 = *ebp_245;
						Eq_4 edx_609 = (word32) ebx_267 + 1;
						if (edx_609 > eax_266)
						{
							word32 esi_1145;
							runtime.growslice(gs, 135117536, ecx_314, ebx_267, eax_266, edx_609, out esi_1145);
							dwLocC4 = eax_266;
							dwLocC0_797 = edx_609;
							ecx_314 = dwLocBC;
							esi_637 = 0x08138A00;
							edx_609 = dwLocB8 + 0x01;
							eax_266 = dwLocB4;
						}
						*((word32) ecx_314 + ebx_267 * 0x08) = esi_637;
						dwLoc88 = eax_266;
						Eq_4 eax_652 = (word32) ecx_314 + 4 + ebx_267 * 0x08;
						if (g_t81576F0 == 0x00)
							*eax_652 = edi_608;
						else
						{
							runtime.writebarrierptr(eax_652, edi_608);
							dwLoc7C = edx_609;
							esi_637 = 0x08138A00;
						}
						++ebp_245;
						dwLoc78_817 = (word32) dwLoc78_817.u0 + 1;
						ebx_267 = edx_609;
					}
					((byte) (word32) *((word32) dwLocC8 + 0x0C) & 0x01) == 0x00;
					word32 edi_300 = (word32) *((word32) dwLocC8 + 32);
					up32 eax_302 = (word32) (word16) edi_300;
					up32 ebp_305 = (word32) (word16) (((word32) *((word32) dwLocC8 + 0x0022) & 0x7FFF) + edi_300);
					if (eax_302 > ebp_305 || ebp_305 > 0x00100000)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_348;
						Eq_4 ebp_319 = ebp_305 - eax_302;
						word32 edi_1146;
						runtime.makeslice(gs, 135117536, 0x00, ebp_319, out edi_1146);
						byte bLocC8_839 = (byte) ebp_319;
						Eq_4 ecx_334 = dwLocC0_797;
						Eq_4 edx_335 = dwLocC4;
						if (((byte) (word32) *((word32) dwLocC8 + 0x0C) & 0x01) != 0x00)
							ebp_348 = 0x34;
						else
							ebp_348 = 0x24;
						word32 edi_360 = (word32) *((word32) dwLocC8 + 32);
						word32 ebp_353 = (word32) dwLocC8 + ebp_348;
						uint32 ebx_362 = (word32) (word16) edi_360;
						uint32 esi_365 = (word32) (word16) (((word32) *((word32) dwLocC8 + 0x0022) & 0x7FFF) + edi_360);
						Eq_4 eax_406 = dwLocBC;
						if (ebx_362 > esi_365 || esi_365 > 0x00100000)
							runtime.panicslice(gs);
						else
						{
							Eq_115663 esi_372 = esi_365 - ebx_362;
							word32 * ebx_393 = ebp_353 + (-(-(ebx_362 + 0xFFF00000)) >> 0x1F & ebx_362 << 0x02);
							Eq_115663 ebp_394 = 0x00;
							while (ebp_394 < esi_372)
							{
								Eq_4 edi_530 = *ebx_393;
								Eq_4 esi_531 = (word32) ecx_334 + 1;
								if (esi_531 > eax_406)
								{
									word32 esi_1147;
									runtime.growslice(gs, 135117536, edx_335, ecx_334, eax_406, esi_531, out esi_1147);
									bLocC8_839 = (byte) ecx_334;
									edx_335 = dwLocBC;
									esi_531 = dwLocB8 + 0x01;
									eax_406 = dwLocB4;
								}
								*((word32) edx_335 + ecx_334 * 0x08) = 0x08138A00;
								dwLoc90 = eax_406;
								Eq_4 ecx_572 = (word32) edx_335 + 4 + ecx_334 * 0x08;
								if (g_t81576F0 == 0x00)
									*ecx_572 = edi_530;
								else
									runtime.writebarrierptr(ecx_572, edi_530);
								++ebx_393;
								ebp_394 = (word32) ebp_394.u0 + 1;
								ecx_334 = esi_531;
							}
							reflect.(*rtype).IsVariadic(gs, dwLocC8);
							reflect.FuncOf(gs, dwLoc3C, dwLoc88, dwLoc90, (byte) (word32) bLocC8_839);
							runtime.newobject(gs, 0x080CF3A0);
							reflect.(*rtype).textOff(gs, dwArg04, ebp_75);
							if (g_t81576F0 == 0x00)
								*dwLoc88 = dwLoc7C;
							else
								runtime.writebarrierptr(dwLoc88, dwLoc7C);
							if (dwLocB0 == 0x08138A00)
								return;
							runtime.panicdottypeI(gs, dwLocB0);
						}
					}
				}
			}
		}
	}
	else
	{
		reflect.(*interfaceType).Method(gs, dwLocD4, dwArg00);
		fn0809023C(fp - 188, fp - 0x20);
		fn0809023C(fp - 0x24, fp + 0x10);
	}
}

// 080A6060: void reflect.(*rtype).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*structType).MethodByName
//      reflect.(*funcType).MethodByName
//      reflect.(*funcTypeFixed128).MethodByName
//      reflect.(*funcTypeFixed16).MethodByName
//      reflect.(*funcTypeFixed32).MethodByName
//      reflect.(*funcTypeFixed4).MethodByName
//      reflect.(*funcTypeFixed64).MethodByName
//      reflect.(*funcTypeFixed8).MethodByName
//      reflect.(*ptrType).MethodByName
//      reflect.(*sliceType).MethodByName
void reflect.(*rtype).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x4C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, &fp->dw0004 + 3);
	if (((word32) *((word32) dwArg00 + 0x0F) & 0x1F) == 0x14)
	{
		fn0808FD86(0x00, fp - 0x54);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		Eq_4 stackArg8 = <invalid>;
		reflect.(*interfaceType).MethodByName(gs, stackArg0, stackArg4, stackArg8);
		fn0809023C(fp - 200, fp - 88);
		fn0809023C(fp - 0x5C, fp - 0x34);
		fn0809023C(fp - 0x38, fp);
	}
	else
	{
		reflect.(*rtype).uncommon(gs, dwArg00);
		if (dwLocCC == null)
			fn0809023C(&g_t80F1F40, &fp->dw0004 + 2);
		else
		{
			Eq_141602 ecx_106[] = dwLocCC + dwLocCC->dw0008 / 0x0C;
			Eq_115847 edx_109 = (word32) dwLocCC->w0004;
			if (edx_109 > 0x00010000)
				runtime.panicslice(gs);
			else
			{
				Eq_115847 ebx_115 = 0x00;
				while (ebx_115 < (word32) dwLocCC->w0004)
				{
					if (ebx_115 >= edx_109)
						runtime.panicindex(gs);
					reflect.(*rtype).nameOff(gs, dwArg00, ecx_106[ebx_115].t0000);
					if (((byte) (word32) *dwLocC8 & 0x01) != 0x00)
					{
						Eq_4 dwLoc84_285 = (word32) dwLocC8 + 3;
						Eq_4 ecx_173 = (word32) *((word32) dwLocC8 + 1) << 0x08 | (word32) (*((word32) dwLocC8 + 2));
						if (dwArg08 == ecx_173)
						{
							word32 esi_369;
							word32 edi_370;
							runtime.eqstring(dwLoc84_285, ecx_173, dwArg04, out esi_369, out edi_370);
							dwLocC8 = dwArg04;
							if ((byte) (word32) bLocC0 != 0x00)
							{
								reflect.(*rtype).Method(gs, dwLocD4, dwArg00);
								fn0809023C(fp - 200, fp - 0x7C);
								fn0809023C(fp - 0x80, &fp->dw0004 + 1);
								return;
							}
						}
					}
					ebx_115 = (word32) ebx_115 + 1;
				}
				fn0809023C(&g_t80F1F80, &fp->dw0004 + 2);
			}
		}
	}
}

// 080A62D0: void reflect.(*rtype).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).PkgPath
//      reflect.(*funcType).PkgPath
//      reflect.(*funcTypeFixed128).PkgPath
//      reflect.(*funcTypeFixed16).PkgPath
//      reflect.(*funcTypeFixed32).PkgPath
//      reflect.(*funcTypeFixed4).PkgPath
//      reflect.(*funcTypeFixed64).PkgPath
//      reflect.(*funcTypeFixed8).PkgPath
//      reflect.(*interfaceType).PkgPath
//      reflect.(*ptrType).PkgPath
//      reflect.(*sliceType).PkgPath
void reflect.(*rtype).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x04) == 0x00)
		return;
	reflect.(*rtype).uncommon(gs, dwArg04);
	if (dwLoc10 == null)
		return;
	reflect.(*rtype).nameOff(gs, dwArg04, *dwLoc10);
}

// 080A6390: void reflect.(*rtype).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.directlyAssignable
//      reflect.convertOp
//      reflect.(*structType).Name
//      reflect.(*funcType).Name
//      reflect.(*funcTypeFixed128).Name
//      reflect.(*funcTypeFixed16).Name
//      reflect.(*funcTypeFixed32).Name
//      reflect.(*funcTypeFixed4).Name
//      reflect.(*funcTypeFixed64).Name
//      reflect.(*funcTypeFixed8).Name
//      reflect.(*interfaceType).Name
//      reflect.(*ptrType).Name
//      reflect.(*sliceType).Name
void reflect.(*rtype).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x04) == 0x00)
		return;
	reflect.(*rtype).String(gs, dwArg04);
	Eq_116030 edx_39;
	for (edx_39 = dwLoc04 - 0x01; edx_39 >= 0x00; --edx_39)
	{
		if (edx_39 >= dwLoc04)
			runtime.panicindex(gs);
		if ((byte) (word32) *((word32) edx_39 + dwLoc08) == 0x2E)
			break;
	}
	if ((word32) edx_39 + 1 <= dwLoc04)
		return;
	runtime.panicslice(gs);
}

// 080A6430: void reflect.(*rtype).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).ChanDir
//      reflect.(*funcType).ChanDir
//      reflect.(*funcTypeFixed128).ChanDir
//      reflect.(*funcTypeFixed16).ChanDir
//      reflect.(*funcTypeFixed32).ChanDir
//      reflect.(*funcTypeFixed4).ChanDir
//      reflect.(*funcTypeFixed64).ChanDir
//      reflect.(*funcTypeFixed8).ChanDir
//      reflect.(*interfaceType).ChanDir
//      reflect.(*ptrType).ChanDir
//      reflect.(*sliceType).ChanDir
void reflect.(*rtype).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x12)
		return;
	runtime.gopanic(gs);
}

// 080A6490: void reflect.(*rtype).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).Method
//      reflect.funcStr
//      reflect.(*structType).IsVariadic
//      reflect.(*funcType).IsVariadic
//      reflect.(*funcTypeFixed128).IsVariadic
//      reflect.(*funcTypeFixed16).IsVariadic
//      reflect.(*funcTypeFixed32).IsVariadic
//      reflect.(*funcTypeFixed4).IsVariadic
//      reflect.(*funcTypeFixed64).IsVariadic
//      reflect.(*funcTypeFixed8).IsVariadic
//      reflect.(*interfaceType).IsVariadic
//      reflect.(*ptrType).IsVariadic
//      reflect.(*sliceType).IsVariadic
void reflect.(*rtype).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x13)
		return;
	runtime.gopanic(gs);
}

// 080A64F0: void reflect.(*rtype).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).FieldByNameFunc
//      reflect.haveIdenticalUnderlyingType
//      reflect.Value.Bytes
//      reflect.Value.runes
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.convertOp
//      reflect.(*structType).Elem
//      reflect.(*funcType).Elem
//      reflect.(*funcTypeFixed128).Elem
//      reflect.(*funcTypeFixed16).Elem
//      reflect.(*funcTypeFixed32).Elem
//      reflect.(*funcTypeFixed4).Elem
//      reflect.(*funcTypeFixed64).Elem
//      reflect.(*funcTypeFixed8).Elem
//      reflect.(*interfaceType).Elem
//      reflect.(*ptrType).Elem
//      reflect.(*sliceType).Elem
void reflect.(*rtype).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ecx_18 = (word32) *((word32) dwArg04 + 0x0F);
	if ((ecx_18 & 0x1F) <= 0x12)
	{
		if ((ecx_18 & 0x1F) == 0x11)
		{
			*((word32) dwArg04 + 32) == 0x00;
			return;
		}
		if ((ecx_18 & 0x1F) == 0x12)
		{
			*((word32) dwArg04 + 32) == 0x00;
			return;
		}
	}
	else
	{
		if ((ecx_18 & 0x1F) == 0x15)
		{
			*((word32) dwArg04 + 36) == 0x00;
			return;
		}
		if ((ecx_18 & 0x1F) == 22)
		{
			*((word32) dwArg04 + 32) == 0x00;
			return;
		}
		if ((ecx_18 & 0x1F) == 0x17)
		{
			*((word32) dwArg04 + 32) == 0x00;
			return;
		}
	}
	runtime.gopanic(gs);
}

// 080A6600: void reflect.(*rtype).Field(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116165) dwArg00)
// Called from:
//      reflect.(*funcType).Field
//      reflect.(*funcTypeFixed128).Field
//      reflect.(*funcTypeFixed16).Field
//      reflect.(*funcTypeFixed32).Field
//      reflect.(*funcTypeFixed4).Field
//      reflect.(*funcTypeFixed64).Field
//      reflect.(*funcTypeFixed8).Field
//      reflect.(*interfaceType).Field
//      reflect.(*ptrType).Field
//      reflect.(*sliceType).Field
void reflect.(*rtype).Field(struct Eq_2 * gs, struct Eq_116165 * dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	if (((word32) dwArg00->b000F & 0x1F) != 0x19)
		runtime.gopanic(gs);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		reflect.(*structType).Field(gs, stackArg0, stackArg4);
		fn0809021E(fp - 0x6C, fp - 0x38);
		fn0809021E(fp - 0x3C, (word32) fp + 4);
	}
}

// 080A6680: void reflect.(*rtype).FieldByIndex(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116215) dwArg00)
// Called from:
//      reflect.(*funcType).FieldByIndex
//      reflect.(*funcTypeFixed128).FieldByIndex
//      reflect.(*funcTypeFixed16).FieldByIndex
//      reflect.(*funcTypeFixed32).FieldByIndex
//      reflect.(*funcTypeFixed4).FieldByIndex
//      reflect.(*funcTypeFixed64).FieldByIndex
//      reflect.(*funcTypeFixed8).FieldByIndex
//      reflect.(*interfaceType).FieldByIndex
//      reflect.(*ptrType).FieldByIndex
//      reflect.(*sliceType).FieldByIndex
void reflect.(*rtype).FieldByIndex(struct Eq_2 * gs, struct Eq_116215 * dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	if (((word32) dwArg00->b000F & 0x1F) != 0x19)
		runtime.gopanic(gs);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		Eq_4 stackArg12 = <invalid>;
		Eq_4 stackArg40 = <invalid>;
		reflect.(*structType).FieldByIndex(gs, stackArg0, stackArg4, stackArg12, stackArg40);
		fn0809021E(fp - 0x6C, fp - 0x38);
		fn0809021E(fp - 0x3C, (word32) fp + 0x0C);
	}
}

// 080A6730: void reflect.(*rtype).FieldByName(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116268) dwArg00)
// Called from:
//      reflect.(*funcType).FieldByName
//      reflect.(*funcTypeFixed128).FieldByName
//      reflect.(*funcTypeFixed16).FieldByName
//      reflect.(*funcTypeFixed32).FieldByName
//      reflect.(*funcTypeFixed4).FieldByName
//      reflect.(*funcTypeFixed64).FieldByName
//      reflect.(*funcTypeFixed8).FieldByName
//      reflect.(*interfaceType).FieldByName
//      reflect.(*ptrType).FieldByName
//      reflect.(*sliceType).FieldByName
void reflect.(*rtype).FieldByName(struct Eq_2 * gs, struct Eq_116268 * dwArg00)
{
	while (fp - 0x30 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, &fp->t0010);
	if (((word32) dwArg00->b000F & 0x1F) != 0x19)
		runtime.gopanic(gs);
	else
	{
		fn0808FD83(0x00, fp - 0x6C);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		Eq_4 stackArg8 = <invalid>;
		reflect.(*structType).FieldByName(esi, gs, stackArg0, stackArg4, stackArg8);
		fn0809021E(fp - 0xAC, fp - 0x70);
		fn0809021E(fp - 116, fp - 0x40);
		fn0809021E(fp - 0x44, fp);
	}
}

// 080A6810: void reflect.(*rtype).FieldByNameFunc(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116332) dwArg00)
// Called from:
//      reflect.(*funcType).FieldByNameFunc
//      reflect.(*funcTypeFixed128).FieldByNameFunc
//      reflect.(*funcTypeFixed16).FieldByNameFunc
//      reflect.(*funcTypeFixed32).FieldByNameFunc
//      reflect.(*funcTypeFixed4).FieldByNameFunc
//      reflect.(*funcTypeFixed64).FieldByNameFunc
//      reflect.(*funcTypeFixed8).FieldByNameFunc
//      reflect.(*interfaceType).FieldByNameFunc
//      reflect.(*ptrType).FieldByNameFunc
//      reflect.(*sliceType).FieldByNameFunc
void reflect.(*rtype).FieldByNameFunc(struct Eq_2 * gs, struct Eq_116332 * dwArg00)
{
	while (fp - 44 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, fp + 0x0C);
	if (((word32) dwArg00->b000F & 0x1F) != 0x19)
		runtime.gopanic(gs);
	else
	{
		fn0808FD83(0x00, fp - 0x6C);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg12 = <invalid>;
		reflect.(*structType).FieldByNameFunc(ebx, esi, gs, stackArg0, stackArg12);
		fn0809021E(fp - 0xAC, fp - 0x70);
		fn0809021E(fp - 116, fp - 0x40);
		fn0809021E(fp - 0x44, fp - 0x04);
	}
}

// 080A68E0: void reflect.(*rtype).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).In
//      reflect.(*funcType).In
//      reflect.(*funcTypeFixed128).In
//      reflect.(*funcTypeFixed16).In
//      reflect.(*funcTypeFixed32).In
//      reflect.(*funcTypeFixed4).In
//      reflect.(*funcTypeFixed64).In
//      reflect.(*funcTypeFixed8).In
//      reflect.(*interfaceType).In
//      reflect.(*ptrType).In
//      reflect.(*sliceType).In
void reflect.(*rtype).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x13)
		runtime.gopanic(gs);
	else
	{
		word32 ecx_43;
		if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
			ecx_43 = 0x34;
		else
			ecx_43 = 0x24;
		word32 (* ecx_48)[] = (word32) dwArg04 + ecx_43;
		Eq_4 eax_52 = (word32) *((word32) dwArg04 + 32);
		if (eax_52 > 0x00100000)
			runtime.panicslice(gs);
		else
		{
			if (dwArg08 < eax_52)
				return;
			runtime.panicindex(gs);
		}
	}
}

// 080A6990: void reflect.(*rtype).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).Key
//      reflect.(*funcType).Key
//      reflect.(*funcTypeFixed128).Key
//      reflect.(*funcTypeFixed16).Key
//      reflect.(*funcTypeFixed32).Key
//      reflect.(*funcTypeFixed4).Key
//      reflect.(*funcTypeFixed64).Key
//      reflect.(*funcTypeFixed8).Key
//      reflect.(*interfaceType).Key
//      reflect.(*ptrType).Key
//      reflect.(*sliceType).Key
void reflect.(*rtype).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x15)
		runtime.gopanic(gs);
	else
		*((word32) dwArg04 + 32) == 0x00;
}

// 080A6A00: void reflect.(*rtype).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).Len
//      reflect.(*funcType).Len
//      reflect.(*funcTypeFixed128).Len
//      reflect.(*funcTypeFixed16).Len
//      reflect.(*funcTypeFixed32).Len
//      reflect.(*funcTypeFixed4).Len
//      reflect.(*funcTypeFixed64).Len
//      reflect.(*funcTypeFixed8).Len
//      reflect.(*interfaceType).Len
//      reflect.(*ptrType).Len
//      reflect.(*sliceType).Len
void reflect.(*rtype).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x11)
		return;
	runtime.gopanic(gs);
}

// 080A6A60: void reflect.(*rtype).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
// Called from:
//      reflect.(*structType).NumField
//      reflect.(*funcType).NumField
//      reflect.(*funcTypeFixed128).NumField
//      reflect.(*funcTypeFixed16).NumField
//      reflect.(*funcTypeFixed32).NumField
//      reflect.(*funcTypeFixed4).NumField
//      reflect.(*funcTypeFixed64).NumField
//      reflect.(*funcTypeFixed8).NumField
//      reflect.(*interfaceType).NumField
//      reflect.(*ptrType).NumField
//      reflect.(*sliceType).NumField
void reflect.(*rtype).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) dwArg04->b000F & 0x1F) == 0x19)
		return;
	runtime.gopanic(gs);
}

// 080A6AC0: void reflect.(*rtype).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).NumIn
//      reflect.(*funcType).NumIn
//      reflect.(*funcTypeFixed128).NumIn
//      reflect.(*funcTypeFixed16).NumIn
//      reflect.(*funcTypeFixed32).NumIn
//      reflect.(*funcTypeFixed4).NumIn
//      reflect.(*funcTypeFixed64).NumIn
//      reflect.(*funcTypeFixed8).NumIn
//      reflect.(*interfaceType).NumIn
//      reflect.(*ptrType).NumIn
//      reflect.(*sliceType).NumIn
void reflect.(*rtype).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x13)
		return;
	runtime.gopanic(gs);
}

// 080A6B20: void reflect.(*rtype).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).NumOut
//      reflect.(*funcType).NumOut
//      reflect.(*funcTypeFixed128).NumOut
//      reflect.(*funcTypeFixed16).NumOut
//      reflect.(*funcTypeFixed32).NumOut
//      reflect.(*funcTypeFixed4).NumOut
//      reflect.(*funcTypeFixed64).NumOut
//      reflect.(*funcTypeFixed8).NumOut
//      reflect.(*interfaceType).NumOut
//      reflect.(*ptrType).NumOut
//      reflect.(*sliceType).NumOut
void reflect.(*rtype).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x13)
		runtime.gopanic(gs);
	else
	{
		((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) == 0x00;
		word32 eax_54 = (word32) *((word32) dwArg04 + 32);
		up32 eax_59 = (word32) (word16) (eax_54 + ((word32) (*((word32) dwArg04 + 0x0022)) & 0x7FFF));
		if ((word32) (word16) eax_54 <= eax_59 && eax_59 <= 0x00100000)
			return;
		runtime.panicslice(gs);
	}
}

// 080A6BC0: void reflect.(*rtype).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).Out
//      reflect.(*funcType).Out
//      reflect.(*funcTypeFixed128).Out
//      reflect.(*funcTypeFixed16).Out
//      reflect.(*funcTypeFixed32).Out
//      reflect.(*funcTypeFixed4).Out
//      reflect.(*funcTypeFixed64).Out
//      reflect.(*funcTypeFixed8).Out
//      reflect.(*interfaceType).Out
//      reflect.(*ptrType).Out
//      reflect.(*sliceType).Out
void reflect.(*rtype).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x13)
		runtime.gopanic(gs);
	else
	{
		word32 ecx_43;
		if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
			ecx_43 = 0x34;
		else
			ecx_43 = 0x24;
		word32 eax_54 = (word32) *((word32) dwArg04 + 32);
		word32 ecx_48 = (word32) dwArg04 + ecx_43;
		uint32 ebx_56 = (word32) (word16) eax_54;
		uint32 eax_59 = (word32) (word16) (eax_54 + ((word32) (*((word32) dwArg04 + 0x0022)) & 0x7FFF));
		if (ebx_56 > eax_59 || eax_59 > 0x00100000)
			runtime.panicslice(gs);
		else
		{
			word32 ecx_73[] = ecx_48 + (ebx_56 << 0x02 & -(-(ebx_56 + 0xFFF00000)) >> 0x1F);
			if (dwArg08 < eax_59 - ebx_56)
				return;
			runtime.panicindex(gs);
		}
	}
}

// 080A6CA0: void reflect.ChanDir.String(Register Eq_4 ebx, Register word32 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack Eq_101636 dwArg04)
// Called from:
//      reflect.(*ChanDir).String
void reflect.ChanDir.String(Eq_4 ebx, word32 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, Eq_101636 dwArg04)
{
	Eq_101714 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x01)
		return;
	if (dwArg04 == 0x02)
		return;
	if (dwArg04 == 0x03)
		return;
	strconv.Itoa(ebx_24_8, ebp, esi, gs, dwArg04);
	runtime.concatstring2(gs, 0x00);
}

// 080A6D70: void reflect.(*interfaceType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).MethodByName
void reflect.(*interfaceType).Method(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	if (dwArg04 < 0x00)
		return;
	Eq_4 ebx_32 = *((word32) dwArg00 + 36);
	if (dwArg04 >= *((word32) dwArg00 + 40))
		return;
	reflect.(*rtype).nameOff(gs, dwArg00, *((word32) ebx_32 + dwArg04 * 0x08));
	if (((byte) (word32) *dwLoc1C & 0x01) == 0x00)
	{
		reflect.name.pkgPath(gs, dwLoc1C);
		if (dwLoc1C == 0x00)
			*((word32) dwArg00 + 32) == 0x00;
	}
	reflect.(*rtype).typeOff(gs);
}

// 080A6EE0: void reflect.(*interfaceType).NumMethod(Register (ptr32 Eq_116779) gs)
void reflect.(*interfaceType).NumMethod(struct Eq_116779 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A6F10: void reflect.(*interfaceType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*sliceType).MethodByName
void reflect.(*interfaceType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	if (dwArg00 == 0x00)
		return;
	Eq_4 eax_33 = *((word32) dwArg00 + 40);
	Eq_4 edx_157 = 0x00;
	while (edx_157 < eax_33)
	{
		Eq_4 ebp_49 = *((word32) dwArg00 + 36);
		if (edx_157 >= *((word32) dwArg00 + 40))
			runtime.panicindex(gs);
		reflect.(*rtype).nameOff(gs, dwArg00, *((word32) ebp_49 + edx_157 * 0x08));
		Eq_4 dwLoc34_172 = 0x00;
		Eq_4 dwLoc30_173 = 0x00;
		if (dwLoc64 != 0x00)
		{
			dwLoc34_172 = (word32) dwLoc64 + 3;
			dwLoc30_173 = (word32) *((word32) dwLoc64 + 1) << 0x08 | (word32) (*((word32) dwLoc64 + 2));
		}
		if (dwLoc30_173 == dwArg08)
		{
			word32 esi_264;
			word32 edi_265;
			runtime.eqstring(dwLoc34_172, dwLoc30_173, dwArg04, out esi_264, out edi_265);
			dwLoc64 = dwArg04;
			if ((byte) (word32) bLoc5C != 0x00)
			{
				reflect.(*interfaceType).Method(gs, dwLoc70, dwArg00);
				fn0809023C(fp - 88, fp - 0x20);
				fn0809023C(fp - 0x24, (word32) fp + 20);
				return;
			}
		}
		edx_157 = (word32) edx_157 + 1;
	}
}

// 080A7060: void reflect.(*structType).Field(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.(*sliceType).Field
void reflect.(*structType).Field(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	if (dwArg04 >= 0x00)
	{
		Eq_4 ebx_32 = *((word32) dwArg00 + 36);
		if (dwArg04 < *((word32) dwArg00 + 40))
		{
			*((word32) ebx_32 + (dwArg04 * 0x0C + 4)) == 0x00;
			*((word32) ebx_32 + dwArg04 * 0x0C) == 0x00;
			Eq_4 ebp_115 = *((word32) ebx_32 + dwArg04 * 0x0C);
			if (((byte) (word32) *ebp_115 & 0x01) == 0x00)
			{
				reflect.name.pkgPath(gs, ebp_115);
				if (dwLoc20 == 0x00)
					*((word32) dwArg00 + 32) == 0x00;
			}
			reflect.name.tag(gs, *((word32) ebx_32 + dwArg04 * 0x0C));
			runtime.newobject(gs, 0x080CBC60);
			*dwLoc24 = (union Eq_4 *) dwArg04;
			return;
		}
	}
	runtime.gopanic(gs);
}

// 080A7240: void reflect.(*structType).FieldByIndex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg28)
// Called from:
//      reflect.(*sliceType).FieldByIndex
void reflect.(*structType).FieldByIndex(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg0C, Eq_4 dwArg28)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	Eq_4 ecx_23 = dwArg00;
	if (dwArg00 == 0x00)
		ecx_23.u0 = 0x00;
	Eq_4 dwArg24_150 = ecx_23;
	Eq_4 ecx_141 = 0x00;
	Eq_4 edx_139 = dwArg04;
	while (ecx_141 < dwArg0C)
	{
		Eq_4 ebp_56 = *edx_139;
		if (ecx_141 > 0x00)
		{
			Eq_4 eax_102;
			Eq_4 ecx_101;
			(*((word32) dwArg24_150 + 84))();
			dwLoc18 = ebp_56;
			dwLoc0C = dwArg28;
			if (dwLoc50 != 22)
			{
l080A7302:
				eax_102 = dwArg28;
				ecx_101 = dwArg24_150;
				goto l080A730A;
			}
			(*((word32) dwArg24_150 + 44))();
			Eq_4 eax_84 = *((word32) dwLoc50 + 84);
			eax_84();
			if (dwLoc50 != 0x19)
				goto l080A7302;
			Eq_4 eax_94 = *((word32) dwArg24_150 + 44);
			eax_94();
			ecx_101 = dwLoc50;
			eax_102 = dwLoc4C;
l080A730A:
			dwArg24_150 = ecx_101;
			dwArg28 = eax_102;
		}
		Eq_4 eax_116 = *((word32) dwArg24_150 + 48);
		eax_116();
		fn0809021E(dwLoc04, (word32) fp + 20);
		dwLoc50 = ebp_56;
		edx_139 = (word32) dwLoc0C + 4;
		ecx_141 = (word32) dwLoc18 + 1;
	}
}

// 080A7380: void reflect.(*structType).FieldByNameFunc(Register Eq_116367 ebx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*structType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
void reflect.(*structType).FieldByNameFunc(Eq_116367 ebx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg0C)
{
	while (fp - 0x80 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm0_49;
	word128 xmm1_50;
	word32 edi_1400;
	runtime.makemap(ebx_24_8, esi, fn0808FD83(0x00, fp + 0x0C), gs, 0x080CF980, 0x00, 0x00, 0x00, 0x00, out edi_1400, out xmm0_49, out xmm1_50);
	struct Eq_117063 * esp_102 = fp - 0x0104;
	Eq_4 dwLocF8_1091 = 0x00;
	Eq_4 dwLocF4_1089 = 0x00;
	Eq_4 eax_121 = fp - 0x14;
	Eq_4 ebp_124 = 0x01;
	Eq_4 esi_120 = fp - 200;
	Eq_4 edi_123 = 0x00;
	Eq_4 ebx_105 = 0x01;
	Eq_4 ecx_101 = dwLocF0;
	while (ebx_105 > 0x00)
	{
		esp_102->t00E0 = eax_121;
		esp_102->t0044 = ebx_105;
		esp_102->t0048 = ebp_124;
		esp_102->t0080 = eax_121;
		esp_102->t0074.u0 = 0x00;
		esp_102->t0078 = esp_102->t0080;
		esp_102->t00AC.u0 = 0x00;
		esp_102->t0098 = ecx_101;
		esp_102->t0070.u0 = 0x00;
		Eq_4 eax_100 = esp_102->t0080;
		ecx_101 = esp_102->t0098;
		while (esp_102->t0074 < ebx_105)
		{
			Eq_4 edx_203;
			Eq_4 ebx_206;
			Eq_4 ebp_208;
			Eq_4 ecx_201;
			byte al_867;
			esp_102->t006C = edi_123;
			esp_102->t00DC = esi_120;
			esp_102->t00D8 = eax_100;
			esp_102->t0040 = *((word32) eax_100 + 8);
			esp_102->dw00A8 = (word32) *((word32) eax_100 + 4);
			Eq_4 ebp_138 = *eax_100;
			esp_102->t00A4 = ebp_138;
			esp_102->t0000.u0 = 0x080CF980;
			esp_102->t0004 = ecx_101;
			esp_102->t0008 = ebp_138;
			word32 esi_1401;
			word32 edi_1402;
			runtime.mapaccess1_fast32(gs, esp_102->t0000, esp_102->t0004, esp_102->t0008, out esi_1401, out edi_1402);
			if ((byte) (word32) *esp_102->ptr000C != 0x00)
			{
				al_867 = (byte) (word32) esp_102->b003F;
				ecx_201 = esp_102->t00AC;
				edx_203 = esp_102->t00DC;
				ebx_206 = esp_102->t0070;
				ebp_208 = esp_102->t006C;
			}
			else
			{
				esp_102->t0000.u0 = 0x080CF980;
				esp_102->t0004 = esp_102->t00A0;
				esp_102->t0008 = esp_102->t00A4;
				runtime.mapassign_fast32(gs, esp_102->t0000, esp_102->t0004, esp_102->t0008);
				*esp_102->ptr000C = 0x01;
				Eq_4 eax_184 = esp_102->t00A4;
				Eq_4 ecx_185 = *((word32) eax_184 + 40);
				esp_102->t0068 = ecx_185;
				Eq_4 edx_187 = 0x00;
				word32 ebx_190 = (word32) esp_102->b003F;
				Eq_4 ebp_191 = esp_102->t00AC;
				Eq_4 esi_192 = esp_102->t00DC;
				Eq_4 edi_193 = esp_102->t006C;
				while (true)
				{
					byte bLocF4_1100 = (byte) dwLocF4_1089;
					esp_102 = fp - 252;
					byte bl_239 = (byte) ebx_190;
					if (edx_187 >= ecx_185)
						break;
					Eq_4 eax_211 = *((word32) eax_184 + 36);
					if (edx_187 >= *((word32) eax_184 + 40))
						runtime.panicindex(gs);
					ui32 ecx_217 = edx_187 * 0x03;
					struct Eq_117352 * ebp_218 = *((word32) eax_211 + ecx_217 * 0x04);
					Eq_4 dwLoc10_1077 = 0x00;
					if (ebp_218 != null)
						dwLoc10_1077 = (word32) ebp_218->b0001 << 0x08 | (word32) ebp_218->b0002;
					Eq_4 eax_249;
					if ((*((word32) eax_211 + (ecx_217 * 0x04 + 8)) & 0x01) != 0x00)
					{
						eax_249 = *((word32) eax_211 + (ecx_217 * 0x04 + 4));
						if (((word32) *((byte) eax_249.u0 + 0x0F) & 0x1F) == 22)
						{
							reflect.(*rtype).Elem(gs, eax_249);
							Eq_4 ecx_270 = *((word32) dwLocF8_1091 + 0x0088);
							ecx_270();
							eax_249 = dwLocF8_1091;
						}
					}
					else
						eax_249.u0 = 0x00;
					word32 eax_472;
					Eq_4 ebx_475;
					Eq_4 ecx_473;
					Eq_4 edx_474;
					Eq_4 ebp_476;
					(*dwArg0C)();
					dwLocF8_1091 = dwLoc10_1077;
					if ((byte) (word32) bLocF4_1100 == 0x00)
					{
						eax_472 = (word32) bl_239;
						if ((byte) eax_472 != 0x00 || (eax_249 == 0x00 || ((word32) (*((byte) eax_249.u0 + 0x0F)) & 0x1F) != 0x19))
						{
							ecx_473 = ebp_191;
							edx_474 = dwLoc8C;
							ebx_475 = esi_192;
							ebp_476 = edi_193;
						}
						else
						{
							Eq_4 edi_500;
							Eq_4 esi_501;
							Eq_6606 ebx_24_8_546 = SLICE(runtime.mapaccess1_fast32(gs, 0x080CF9C0, ebp_191, eax_249, out esi_501, out edi_500), word24, 8);
							if (*dwLocF0 <= 0x00)
							{
								Eq_4 eax_536 = ebp_191;
								if (ebp_191 == 0x00)
								{
									word128 xmm0_554;
									word128 xmm1_555;
									word32 edi_1405;
									runtime.makemap(ebx_24_8_546, esi_501, edi_500, gs, 0x080CF9C0, 0x00, 0x00, 0x00, 0x00, out edi_1405, out xmm0_554, out xmm1_555);
									eax_536 = dwLocE8;
								}
								runtime.mapassign_fast32(gs, 0x080CF9C0, eax_536, eax_249);
								*dwLocF0 = 0x01;
								word32 esi_1406;
								word32 edi_1407;
								runtime.mapaccess1_fast32(gs, 0x080CF9C0, dwLoc40, dwLoc58, out esi_1406, out edi_1407);
								if (*dwLocF0 > 0x01)
								{
									runtime.mapassign_fast32(gs, 0x080CF9C0, eax_536, eax_249);
									*dwLocF0 = 0x02;
								}
								Eq_4 edx_654;
								Eq_4 ecx_655;
								if (dwLocBC <= 0x00)
								{
									ecx_655.u0 = 0x00;
									edx_654.u0 = 0x00;
								}
								else
								{
									word32 esi_1408;
									runtime.growslice(gs, 0x080CEB60, 0x00, 0x00, 0x00, dwLocBC, out esi_1408);
									edx_654 = dwLocE8;
									ecx_655 = dwLocE0;
								}
								if (dwLocBC > ecx_655)
									runtime.panicslice(gs);
								Eq_4 ebx_710;
								word32 esi_1410;
								word32 edi_1411;
								word32 ebp_1409;
								runtime.memmove(edx_654, dwLoc54, dwLocBC << 0x02, out ebp_1409, out esi_1410, out edi_1411);
								dwLocF8_1091 = dwLoc54;
								dwLocF4_1089 = dwLocBC << 0x02;
								word32 ecx_688 = dwLocBC + 0x01;
								Eq_4 edx_689 = ecx_655;
								if (dwLocBC + 0x01 <= ecx_655)
									ebx_710 = edx_654;
								else
								{
									word32 esi_1412;
									runtime.growslice(gs, 0x080CEB60, edx_654, dwLocBC, ecx_655, dwLocBC + 0x01, out esi_1412);
									dwLocF8_1091 = edx_654;
									dwLocF4_1089 = dwLocBC;
									ebx_710 = dwLocE8;
									edx_689 = dwLocE0;
									ecx_688 = dwLocE4 + 0x01;
								}
								Eq_4 dwLoc4C_1221;
								Eq_4 eax_759;
								*((word32) ebx_710 + dwLocBC * 0x04) = edx_187;
								Eq_4 edi_723 = (word32) dwLoc8C + 1;
								if ((word32) dwLoc8C + 1 <= edi_193)
								{
									dwLoc4C_1221 = esi_192;
									eax_759 = edi_193;
								}
								else
								{
									word32 esi_1413;
									runtime.growslice(gs, 0x080D3200, esi_192, dwLoc8C, edi_193, (word32) dwLoc8C + 1, out esi_1413);
									dwLocF8_1091 = esi_192;
									dwLocF4_1089 = dwLoc8C;
									edi_723 = dwLocE4 + 0x01;
									dwLoc4C_1221 = dwLocE8;
									eax_759 = dwLocE0;
								}
								int32 esi_766 = dwLoc8C << 0x04;
								(word32) dwLoc4C_1221 + 8 + esi_766 = ecx_688;
								(word32) dwLoc4C_1221 + 0x0C + esi_766 = (union Eq_4 *) edx_689;
								Eq_4 eax_777 = (word32) dwLoc4C_1221 + esi_766;
								Eq_4 eax_779 = (word32) dwLoc4C_1221 + 4 + esi_766;
								if (g_t81576F0 == 0x00)
								{
									*((word32) dwLoc4C_1221 + esi_766) = eax_249;
									(word32) dwLoc4C_1221 + 4 + esi_766 = (union Eq_4 *) ebx_710;
								}
								else
								{
									runtime.writebarrierptr(eax_777, eax_249);
									runtime.writebarrierptr(eax_779, ebx_710);
									dwLoc8C = eax_759;
									dwLocF8_1091 = ebx_710;
								}
								eax_472 = (word32) bl_239;
								ecx_473 = eax_536;
								ebx_475 = dwLoc4C_1221;
								ebp_476 = eax_759;
								edx_474 = edi_723;
							}
							else
							{
								runtime.mapassign_fast32(gs, 0x080CF9C0, ebp_191, eax_249);
								*dwLocF0 = 0x02;
								dwLocF8_1091 = ebp_191;
								dwLocF4_1089 = eax_249;
								eax_472 = (word32) bl_239;
								ecx_473 = ebp_191;
								edx_474 = dwLoc8C;
								ebx_475 = esi_192;
								ebp_476 = edi_193;
							}
						}
					}
					else
					{
						word32 esi_1403;
						word32 edi_1404;
						runtime.mapaccess1_fast32(gs, 0x080CF9C0, dwLoc40, dwLoc58, out esi_1403, out edi_1404);
						dwLocF4_1089 = dwLoc58;
						if (*dwLocF0 > 0x01 || (byte) ((word32) bl_239) != 0x00)
						{
							fn0809021E(0x080F2040, fp + 0x10);
							return;
						}
						Eq_4 edx_399;
						Eq_4 ecx_400;
						reflect.(*structType).Field(gs, 0x00, dwLoc58);
						Eq_4 esp_358 = <invalid>;
						fn0809021E(*((word32) esp_358 + 228), (word32) esp_358 + 268);
						((word32) esp_358 + 300)->u0 = 0x00;
						((word32) esp_358 + 304)->u0 = 0x00;
						((word32) esp_358 + 308)->u0 = 0x00;
						dwLocF8_1091 = edx_187;
						esp_102 = (word32) esp_358 - 4;
						Eq_4 eax_377 = *((word32) esp_358 + 60);
						if (eax_377 <= 0x00)
						{
							ecx_400.u0 = 0x00;
							edx_399.u0 = 0x00;
						}
						else
						{
							((word32) esp_358 - 4)->u0 = 0x080CEB60;
							esp_358->u0 = 0x00;
							((word32) esp_358 + 4)->u0 = 0x00;
							((word32) esp_358 + 8)->u0 = 0x00;
							*((word32) esp_358 + 0x0C) = eax_377;
							word32 esi_1414;
							runtime.growslice(gs, *((word32) esp_358 - 4), *esp_358, *((word32) esp_358 + 4), *((word32) esp_358 + 8), *((word32) esp_358 + 0x0C), out esi_1414);
							edx_399 = *((word32) esp_358 + 16);
							ecx_400 = *((word32) esp_358 + 24);
							eax_377 = *((word32) esp_358 + 60);
						}
						if (eax_377 > ecx_400)
							runtime.panicslice(gs);
						*((word32) esp_358 + 92) = ecx_400;
						*((word32) esp_358 + 0x00C4) = edx_399;
						*((word32) esp_358 - 4) = edx_399;
						*esp_358 = *((word32) esp_358 + 0x00A4);
						*((word32) esp_358 + 4) = eax_377 << 0x02;
						word32 ebp_1415;
						word32 esi_1416;
						word32 edi_1417;
						runtime.memmove(*((word32) esp_358 - 4), *esp_358, *((word32) esp_358 + 4), out ebp_1415, out esi_1416, out edi_1417);
						Eq_4 eax_432 = *((word32) esp_358 + 0x00C4);
						*((word32) esp_358 + 300) = eax_432;
						Eq_4 ecx_434 = *((word32) esp_358 + 60);
						*((word32) esp_358 + 304) = ecx_434;
						Eq_4 edx_436 = *((word32) esp_358 + 92);
						*((word32) esp_358 + 308) = edx_436;
						if ((word32) ecx_434 + 1 > edx_436)
						{
							((word32) esp_358 - 4)->u0 = 0x080CEB60;
							*esp_358 = eax_432;
							*((word32) esp_358 + 4) = ecx_434;
							*((word32) esp_358 + 8) = edx_436;
							*((word32) esp_358 + 0x0C) = (word32) ecx_434 + 1;
							word32 esi_1418;
							runtime.growslice(gs, *((word32) esp_358 - 4), *esp_358, *((word32) esp_358 + 4), *((word32) esp_358 + 8), *((word32) esp_358 + 0x0C), out esi_1418);
							eax_432 = *((word32) esp_358 + 16);
							ecx_434 = *((word32) esp_358 + 20);
							*((word32) esp_358 + 308) = *((word32) esp_358 + 24);
							*((word32) esp_358 + 300) = eax_432;
						}
						*((word32) esp_358 + 304) = (word32) ecx_434 + 1;
						*((word32) eax_432 + ecx_434 * 0x04) = *((word32) esp_358 + 80);
						eax_472 = 0x01;
						ecx_473 = *((word32) esp_358 + 0x00CC);
						edx_474 = *((word32) esp_358 + 0x006C);
						ebx_475 = *((word32) esp_358 + 0x00D0);
						ebp_476 = *((word32) esp_358 + 96);
					}
					word32 esi_836 = esp_102->dw0054;
					esp_102->t0070 = edx_474;
					edi_193 = ebp_476;
					edx_187 = esi_836 + 0x01;
					ebp_191 = ecx_473;
					esi_192 = ebx_475;
					ecx_185 = esp_102->t0068;
					ebx_190 = eax_472;
					eax_184 = esp_102->t00A4;
				}
				al_867 = (byte) ebx_190;
				ecx_201 = ebp_191;
				edx_203 = esi_192;
				ebx_206 = dwLoc8C;
				ebp_208 = edi_193;
			}
			Eq_4 esi_860 = esp_102->t00D8;
			esp_102->t0074 = (word32) esp_102->t0074 + 1;
			esp_102->b003F = al_867;
			esp_102->t00AC = ecx_201;
			esp_102->t0070 = ebx_206;
			edi_123 = ebp_208;
			ecx_101 = esp_102->t00A0;
			ebx_105 = esp_102->t0044;
			eax_100 = (word32) esi_860 + 16;
			esi_120 = edx_203;
		}
		if ((byte) (word32) esp_102->b003F != 0x00)
			return;
		ebx_105 = esp_102->t0070;
		esi_120 = esp_102->t00E0;
		edi_123 = esp_102->t0048;
		esp_102->t00BC = esp_102->t00AC;
		eax_121 = esi_120;
		ebp_124 = edi_123;
	}
}

// 080A7CE0: void reflect.(*structType).FieldByName(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*sliceType).FieldByName
void reflect.(*structType).FieldByName(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x88 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 edi_252;
	fn0808FD83(0x00, &fp->t0010);
	Eq_4 eax_22 = 0x00;
	Eq_4 edx_249 = dwArg08;
	if (dwArg08 != 0x00)
	{
		Eq_4 ebp_38 = *((word32) dwArg00 + 40);
		esi.u0 = 0x00;
		edi_252 = 0x00;
		while (esi < ebp_38)
		{
			Eq_4 ebx_145 = *((word32) dwArg00 + 36);
			if (esi >= *((word32) dwArg00 + 40))
				runtime.panicindex(gs);
			ui32 ecx_148 = esi * 0x03;
			struct Eq_117894 * ebp_150 = *((word32) ebx_145 + ecx_148 * 0x04);
			Eq_4 dwLocB4_317 = 0x00;
			Eq_4 dwLocB0_318 = 0x00;
			if (ebp_150 != null)
			{
				dwLocB4_317 = &ebp_150->b0002 + 1;
				dwLocB0_318 = (word32) ebp_150->b0001 << 0x08 | (word32) ebp_150->b0002;
			}
			if (dwLocB0_318 == edx_249)
			{
				word32 esi_437;
				word32 edi_438;
				runtime.eqstring(dwLocB4_317, dwLocB0_318, dwArg04, out esi_437, out edi_438);
				dwLocBC = ebx_145;
				byte al_181 = (byte) edi_252;
				dwLoc0108 = dwLocB0_318;
				if ((byte) (word32) bLocFC != 0x00)
				{
					reflect.(*structType).Field(gs, dwLoc0110, dwArg00);
					fn0809021E(0x00, fp - 44);
					fn0809021E(fp - 0x30, (char *) &fp->t0010 + 4);
					return;
				}
				eax_22.u0 = 0x00;
				edx_249 = dwArg08;
				edi_252 = (word32) al_181;
			}
			Eq_4 ecx_259 = *((word32) ebx_145 + (ecx_148 * 0x04 + 8));
			esi = (byte) esi.u0 + 1;
			edi_252 |= SEQ(SLICE(ecx_259, word24, 8), (ecx_259 & 0x01) != 0x00);
		}
	}
	else
		edi_252 = 0x00;
	Eq_116367 ebx_24_8_83 = SLICE(dwArg00, word24, 8);
	if ((byte) edi_252 == 0x00)
		return;
	fn0808FD83(eax_22, fp - 0xA0);
	reflect.(*structType).FieldByNameFunc(ebx_24_8_83, esi, gs, dwLoc0114, dwLoc0108);
	fn0809021E(dwLocBC, fp - 0xA4);
	fn0809021E(fp - 0xA8, fp - 116);
	fn0809021E(fp - 0x78, fp);
}

// 080A7F20: void reflect.TypeOf(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      reflect.init
void reflect.TypeOf(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 080A7F60: void reflect.(*rtype).ptrTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.New
void reflect.(*rtype).ptrTo(struct Eq_2 * gs, Eq_4 dwArg04)
{
	byte bLoc48 = (byte) dwLoc48;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 28) != 0x00)
		reflect.(*rtype).typeOff(gs);
	else
	{
		sync.(*Map).Load(gs, 0x08145240, 0x080DDF40, dwArg04);
		if ((byte) (word32) bLoc48 != 0x00)
		{
			if (dwLoc50 == 0x080DDCA0)
				return;
			runtime.panicdottypeE(gs, dwLoc50);
		}
		else
		{
			reflect.(*rtype).String(gs, dwArg04);
			runtime.concatstring2(gs, fp - 0x34);
			reflect.typesByString(gs, dwLoc48, dwLoc44);
			word32 * ecx_119 = (word32 *) 0x01;
			Eq_118051 ebx_121 = 0x00;
			while (ebx_121 < 0x080DDF40)
			{
				Eq_4 ebp_309 = *ecx_119;
				if (*((word32) ebp_309 + 32) == dwArg04)
				{
					word128 xmm1_504;
					sync.(*Map).LoadOrStore(gs, 0x08145240, 0x080DDCA0, ebp_309, out xmm1_504);
					if (dwLoc48 != 0x080DDCA0)
						runtime.panicdottypeE(gs, dwLoc48);
					else
						return;
				}
				++ecx_119;
				ebx_121 = (word32) ebx_121.u0 + 1;
			}
			runtime.newobject(gs, 0x080D3560);
			if (g_t81576F0 == 0x00)
				fn08090246(&g_dw80C8F40, dwLoc44);
			else
			{
				word32 edi_506;
				word32 esi_505;
				runtime.typedmemmove(0x080D3560, dwLoc44, 0x080C8F40, out esi_505, out edi_506);
			}
			Eq_4 edi_195;
			Eq_4 esi_197;
			reflect.resolveReflectName(SLICE(reflect.newName(gs, dwLoc48, dwLoc44, 0x00, 0x00, 0x00, 0x00, out esi_197, out edi_195), word24, 8), esi_197, edi_195, gs, dwLoc40);
			*((word32) dwLoc44 + 24) = dwLoc44;
			((word32) dwLoc44 + 28)->u0 = 0x00;
			reflect.fnv1(gs, 0x01);
			((word32) dwLoc44 + 8)->u0 = 0x00;
			if (g_t81576F0 == 0x00)
				*((word32) dwLoc44 + 32) = dwArg04;
			else
				runtime.writebarrierptr((word32) dwLoc44 + 32, dwArg04);
			word128 xmm1_507;
			sync.(*Map).LoadOrStore(gs, 0x08145240, 0x080DDCA0, dwLoc44, out xmm1_507);
			if (false)
				return;
			runtime.panicdottypeE(gs, 0x00);
		}
	}
}

// 080A8270: void reflect.fnv1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
void reflect.fnv1(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_19 = 0x00;
	while (ebx_19 < dwArg0C)
		ebx_19 = (word32) ebx_19 + 1;
}

// 080A82C0: void reflect.(*rtype).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*structType).Implements
//      reflect.(*funcType).Implements
//      reflect.(*funcTypeFixed128).Implements
//      reflect.(*funcTypeFixed16).Implements
//      reflect.(*funcTypeFixed32).Implements
//      reflect.(*funcTypeFixed4).Implements
//      reflect.(*funcTypeFixed64).Implements
//      reflect.(*funcTypeFixed8).Implements
//      reflect.(*interfaceType).Implements
//      reflect.(*ptrType).Implements
//      reflect.(*sliceType).Implements
void reflect.(*rtype).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else
	{
		(*((word32) dwArg08 + 84))();
		if (dwLoc08 != 0x14)
			runtime.gopanic(gs);
		else if (dwArg08 != 0x08138A00)
			runtime.panicdottypeI(gs, dwArg08);
		else
			reflect.implements(gs, dwLoc10, dwArg0C);
	}
}

// 080A8390: void reflect.(*rtype).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*structType).AssignableTo
//      reflect.(*funcType).AssignableTo
//      reflect.(*funcTypeFixed128).AssignableTo
//      reflect.(*funcTypeFixed16).AssignableTo
//      reflect.(*funcTypeFixed32).AssignableTo
//      reflect.(*funcTypeFixed4).AssignableTo
//      reflect.(*funcTypeFixed64).AssignableTo
//      reflect.(*funcTypeFixed8).AssignableTo
//      reflect.(*interfaceType).AssignableTo
//      reflect.(*ptrType).AssignableTo
//      reflect.(*sliceType).AssignableTo
void reflect.(*rtype).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if (dwArg08 != 0x08138A00)
		runtime.panicdottypeI(gs, dwArg08);
	else
	{
		reflect.directlyAssignable(gs, dwArg0C, dwArg04);
		if ((byte) (word32) bLoc04 == 0x00)
			reflect.implements(gs, dwLoc10, dwArg0C);
	}
}

// 080A8450: void reflect.(*rtype).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*structType).ConvertibleTo
//      reflect.(*funcType).ConvertibleTo
//      reflect.(*funcTypeFixed128).ConvertibleTo
//      reflect.(*funcTypeFixed16).ConvertibleTo
//      reflect.(*funcTypeFixed32).ConvertibleTo
//      reflect.(*funcTypeFixed4).ConvertibleTo
//      reflect.(*funcTypeFixed64).ConvertibleTo
//      reflect.(*funcTypeFixed8).ConvertibleTo
//      reflect.(*interfaceType).ConvertibleTo
//      reflect.(*ptrType).ConvertibleTo
//      reflect.(*sliceType).ConvertibleTo
void reflect.(*rtype).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if (dwArg08 != 0x08138A00)
		runtime.panicdottypeI(gs, dwArg08);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		Eq_4 stackArg8 = <invalid>;
		reflect.convertOp(gs, stackArg4, stackArg8);
	}
}

// 080A84E0: void reflect.(*rtype).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
// Called from:
//      reflect.(*structType).Comparable
//      reflect.(*funcType).Comparable
//      reflect.(*funcTypeFixed128).Comparable
//      reflect.(*funcTypeFixed16).Comparable
//      reflect.(*funcTypeFixed32).Comparable
//      reflect.(*funcTypeFixed4).Comparable
//      reflect.(*funcTypeFixed64).Comparable
//      reflect.(*funcTypeFixed8).Comparable
//      reflect.(*interfaceType).Comparable
//      reflect.(*ptrType).Comparable
//      reflect.(*sliceType).Comparable
void reflect.(*rtype).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	dwArg04->dw0010 == 0x00;
}

// 080A8520: void reflect.implements(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.assignTo
//      reflect.convertOp
//      reflect.(*sliceType).Implements
//      reflect.(*sliceType).AssignableTo
void reflect.implements(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp - 0x20 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD80(0x00, fp - 0x40);
	if (((word32) *((word32) dwArg00 + 0x0F) & 0x1F) != 0x14)
		return;
	if (*((word32) dwArg00 + 40) == 0x00)
		return;
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x14)
	{
		reflect.(*rtype).uncommon(gs, dwArg04);
		if (dwLocA0 == null)
			return;
		Eq_141628 ecx_61[] = dwLocA0 + dwLocA0->dw0008 / 0x0C;
		Eq_118409 edx_64 = (word32) dwLocA0->w0004;
		if (edx_64 > 0x00010000)
			runtime.panicslice(gs);
		else
		{
			Eq_118409 ebx_375 = 0x00;
			Eq_4 ebp_379 = 0x00;
			while (ebx_375 < (word32) dwLocA0->w0004)
			{
				Eq_4 eax_86 = *((word32) dwArg00 + 36);
				if (ebp_379 >= *((word32) dwArg00 + 40))
					runtime.panicindex(gs);
				reflect.(*rtype).nameOff(gs, dwArg00, *((word32) eax_86 + ebp_379 * 0x08));
				if (ebx_375 >= edx_64)
					runtime.panicindex(gs);
				reflect.(*rtype).nameOff(gs, dwArg04, ecx_61[ebx_375].t0000);
				Eq_4 dwLoc2C_723 = 0x00;
				Eq_4 dwLoc28_724 = 0x00;
				if (dwLoc9C != 0x00)
				{
					dwLoc2C_723 = (word32) dwLoc9C + 3;
					dwLoc28_724 = (word32) *((word32) dwLoc9C + 2) | (word32) (*((word32) dwLoc9C + 1)) << 0x08;
				}
				Eq_4 dwLoc14_727 = 0x00;
				Eq_4 dwLoc10_728 = 0x00;
				if (dwLoc9C != 0x00)
				{
					dwLoc14_727 = (word32) dwLoc9C + 3;
					dwLoc10_728 = (word32) *((word32) dwLoc9C + 2) | (word32) (*((word32) dwLoc9C + 1)) << 0x08;
				}
				Eq_4 eax_357;
				if (dwLoc10_728 != dwLoc28_724)
				{
l080A89AF:
					eax_357 = ebp_379;
					goto l080A8899;
				}
				word32 edi_177;
				word32 esi_178;
				runtime.eqstring(dwLoc2C_723, dwLoc28_724, dwLoc14_727, out esi_178, out edi_177);
				dwLoc9C = dwLoc14_727;
				if ((byte) (word32) bLoc94 == 0x00)
					goto l080A89AF;
				reflect.(*rtype).typeOff(gs);
				Eq_4 edx_210 = *((word32) eax_86 + (ebp_379 * 0x08 + 4));
				reflect.(*rtype).typeOff(gs);
				if (dwLoc14_727 != dwLoc14_727)
					goto l080A89AF;
				if (((byte) (word32) *dwLoc9C & 0x01) != 0x00)
				{
l080A8A31:
					eax_357 = (word32) ebp_379 + 1;
					if ((word32) ebp_379 + 1 >= *((word32) dwArg00 + 40))
						return;
					goto l080A8899;
				}
				Eq_4 ecx_249;
				Eq_4 edx_248;
				reflect.name.pkgPath(gs, dwLoc9C);
				if (dwLoc14_727 == 0x00)
				{
					Eq_4 ecx_251 = *((word32) dwArg00 + 32);
					Eq_4 dwLoc0C_763 = 0x00;
					Eq_4 dwLoc08_764 = 0x00;
					if (ecx_251 != 0x00)
					{
						dwLoc0C_763 = (word32) ecx_251 + 3;
						dwLoc08_764 = (word32) *((word32) ecx_251 + 2) | (word32) (*((word32) ecx_251 + 1)) << 0x08;
					}
					ecx_249 = dwLoc08_764;
					edx_248 = dwLoc0C_763;
				}
				else
				{
					edx_248 = edx_210;
					ecx_249 = dwLoc14_727;
				}
				reflect.name.pkgPath(gs, dwLoc9C);
				Eq_4 eax_290 = dwLoc14_727;
				Eq_4 ecx_291 = edx_210;
				if (dwLoc14_727 == 0x00)
				{
					reflect.(*rtype).nameOff(gs, dwArg04, dwLocA0->t0000);
					Eq_4 dwLoc24_787 = 0x00;
					Eq_4 dwLoc20_788 = 0x00;
					if (dwLoc14_727 != 0x00)
					{
						dwLoc24_787 = (word32) dwLoc14_727 + 3;
						dwLoc20_788 = (word32) *((word32) dwLoc14_727 + 2) | (word32) (*((word32) dwLoc14_727 + 1)) << 0x08;
					}
					eax_290 = dwLoc20_788;
					ecx_291 = dwLoc24_787;
				}
				if (eax_290 == ecx_249)
				{
					word32 edi_340;
					word32 esi_1119;
					runtime.eqstring(edx_248, ecx_249, ecx_291, out esi_1119, out edi_340);
					dwLoc9C = ecx_291;
					if ((byte) (word32) bLoc94 == 0x00)
						goto l080A8AE7;
					goto l080A8A31;
				}
l080A8AE7:
				eax_357 = ebp_379;
l080A8899:
				ebx_375 = (word32) ebx_375 + 1;
				ebp_379 = eax_357;
			}
		}
	}
	else
	{
		Eq_4 edx_381 = 0x00;
		Eq_4 ebx_382 = 0x00;
		while (edx_381 < *((word32) dwArg04 + 40))
		{
			Eq_4 ebp_396 = *((word32) dwArg00 + 36);
			if (ebx_382 >= *((word32) dwArg00 + 40))
				runtime.panicindex(gs);
			reflect.(*rtype).nameOff(gs, dwArg00, *((word32) ebp_396 + ebx_382 * 0x08));
			Eq_4 edx_420 = *((word32) dwArg04 + 36);
			if (edx_381 >= *((word32) dwArg04 + 40))
				runtime.panicindex(gs);
			reflect.(*rtype).nameOff(gs, dwArg04, *((word32) edx_420 + edx_381 * 0x08));
			Eq_4 dwLoc1C_866 = 0x00;
			Eq_4 dwLoc18_867 = 0x00;
			if (dwLoc9C != 0x00)
			{
				dwLoc1C_866 = (word32) dwLoc9C + 3;
				dwLoc18_867 = (word32) *((word32) dwLoc9C + 2) | (word32) (*((word32) dwLoc9C + 1)) << 0x08;
			}
			Eq_4 dwLoc44_870 = 0x00;
			Eq_4 dwLoc40_871 = 0x00;
			if (dwLoc9C != 0x00)
			{
				dwLoc44_870 = (word32) dwLoc9C + 3;
				dwLoc40_871 = (word32) *((word32) dwLoc9C + 2) | (word32) (*((word32) dwLoc9C + 1)) << 0x08;
			}
			Eq_4 eax_658;
			if (dwLoc40_871 != dwLoc18_867)
			{
l080A8694:
				eax_658 = ebx_382;
				goto l080A858A;
			}
			word32 edi_486;
			word32 esi_487;
			runtime.eqstring(dwLoc1C_866, dwLoc18_867, dwLoc44_870, out esi_487, out edi_486);
			dwLoc9C = dwLoc44_870;
			if ((byte) (word32) bLoc94 == 0x00)
				goto l080A8694;
			reflect.(*rtype).typeOff(gs);
			Eq_4 edx_522 = *((word32) ebp_396 + (ebx_382 * 0x08 + 4));
			reflect.(*rtype).typeOff(gs);
			if (dwLoc44_870 != dwLoc44_870)
				goto l080A8694;
			if (((byte) (word32) *dwLoc9C & 0x01) != 0x00)
			{
l080A8720:
				eax_658 = (word32) ebx_382 + 1;
				if ((word32) ebx_382 + 1 >= *((word32) dwArg00 + 40))
					return;
				goto l080A858A;
			}
			Eq_4 edx_560;
			reflect.name.pkgPath(gs, dwLoc9C);
			Eq_4 ecx_556 = edx_522;
			if (dwLoc44_870 == 0x00)
			{
				Eq_4 ecx_562 = *((word32) dwArg00 + 32);
				Eq_4 dwLoc3C_909 = 0x00;
				Eq_4 dwLoc38_910 = 0x00;
				if (ecx_562 != 0x00)
				{
					dwLoc3C_909 = (word32) ecx_562 + 3;
					dwLoc38_910 = (word32) *((word32) ecx_562 + 2) | (word32) (*((word32) ecx_562 + 1)) << 0x08;
				}
				ecx_556 = dwLoc3C_909;
				edx_560 = dwLoc38_910;
			}
			else
				edx_560 = dwLoc44_870;
			Eq_4 edx_606;
			reflect.name.pkgPath(gs, dwLoc9C);
			Eq_4 ecx_602 = edx_522;
			if (dwLoc44_870 == 0x00)
			{
				Eq_4 ecx_609 = *((word32) dwArg04 + 32);
				Eq_4 dwLoc34_926 = 0x00;
				Eq_4 dwLoc30_927 = 0x00;
				if (ecx_609 != 0x00)
				{
					dwLoc34_926 = (word32) ecx_609 + 3;
					dwLoc30_927 = (word32) *((word32) ecx_609 + 2) | (word32) (*((word32) ecx_609 + 1)) << 0x08;
				}
				ecx_602 = dwLoc34_926;
				edx_606 = dwLoc30_927;
			}
			else
				edx_606 = dwLoc44_870;
			if (edx_606 == edx_560)
			{
				word32 edi_640;
				word32 esi_641;
				runtime.eqstring(ecx_556, edx_560, ecx_602, out esi_641, out edi_640);
				dwLoc9C = ecx_602;
				if ((byte) (word32) bLoc94 == 0x00)
					goto l080A8802;
				goto l080A8720;
			}
l080A8802:
			eax_658 = ebx_382;
l080A858A:
			edx_381 = (word32) edx_381 + 1;
			ebx_382 = eax_658;
		}
	}
}

// 080A8C00: void reflect.directlyAssignable(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.Value.assignTo
//      reflect.(*sliceType).AssignableTo
void reflect.directlyAssignable(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == dwArg08)
		return;
	reflect.(*rtype).Name(gs, dwArg04);
	if (dwLoc08 != 0x00)
	{
		reflect.(*rtype).Name(gs, dwArg08);
		if (dwLoc08 != 0x00)
			return;
	}
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != ((word32) (*((word32) dwArg08 + 0x0F)) & 0x1F))
		return;
	reflect.haveIdenticalUnderlyingType(gs, dwLoc14, dwArg04, (byte) dwArg08);
}

// 080A8CA0: void reflect.haveIdenticalType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack byte bArg14)
// Called from:
//      reflect.haveIdenticalUnderlyingType
void reflect.haveIdenticalType(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, byte bArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) bArg14 == 0x00)
	{
		(*((word32) dwArg04 + 100))();
		(*((word32) dwArg0C + 100))();
		if (dwLoc1C != dwLoc1C)
			return;
		word32 edi_53;
		word32 esi_54;
		runtime.eqstring(dwLoc20, dwLoc1C, dwLoc20, out esi_54, out edi_53);
		byte bLoc18_185 = (byte) dwLoc1C;
		if ((byte) (word32) bLoc14 == 0x00)
			return;
		(*((word32) dwArg04 + 84))();
		word32 edx_84;
		(*((word32) dwArg0C + 84))();
		if (dwLoc1C != dwLoc1C)
			return;
		Eq_4 eax_91 = *((word32) dwArg04 + 0x0088);
		eax_91();
		Eq_4 ecx_101 = *((word32) dwArg0C + 0x0088);
		ecx_101();
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		reflect.haveIdenticalUnderlyingType(gs, stackArg0, dwLoc1C, dwLoc1C);
	}
	else if (dwArg04 == dwArg0C)
		runtime.ifaceeq(gs, dwArg04, dwArg08, dwArg10);
}

// 080A8DF0: void reflect.haveIdenticalUnderlyingType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 bArg08)
// Called from:
//      reflect.directlyAssignable
//      reflect.haveIdenticalType
//      reflect.FuncOf
//      reflect.convertOp
void reflect.haveIdenticalUnderlyingType(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD88(0x00, fp - 0x20);
	if (dwArg00 == dwArg04)
		return;
	ui32 edx_30 = (word32) *((word32) dwArg00 + 0x0F);
	if ((edx_30 & 0x1F) != ((word32) (*((word32) dwArg04 + 0x0F)) & 0x1F))
		return;
	if ((edx_30 & 0x1F) <= 0x10 || ((edx_30 & 0x1F) == 0x18 || (edx_30 & 0x1F) == 0x1A))
		return;
	if ((edx_30 & 0x1F) > 0x13)
	{
		if ((edx_30 & 0x1F) <= 0x15)
		{
			if ((edx_30 & 0x1F) != 0x14)
			{
				reflect.(*rtype).Key(gs, dwArg00);
				reflect.(*rtype).Key(gs, dwArg04);
				reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, (byte) (word32) bArg08);
				if ((byte) (word32) bLoc5C != 0x00)
				{
					reflect.(*rtype).Elem(gs, dwArg00);
					reflect.(*rtype).Elem(gs, dwArg04);
					reflect.haveIdenticalType(gs, dwLoc68, dwLoc6C, dwLoc68, dwLoc6C, (byte) (word32) bArg08);
				}
			}
			else if (*((word32) dwArg00 + 40) != 0x00 || *((word32) dwArg04 + 40) != 0x00)
				;
		}
		else if ((edx_30 & 0x1F) <= 0x17)
		{
			reflect.(*rtype).Elem(gs, dwArg00);
			reflect.(*rtype).Elem(gs, dwArg04);
			reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, (byte) (word32) bArg08);
		}
		else
		{
			if ((edx_30 & 0x1F) != 0x19)
				return;
			Eq_4 edx_207 = *((word32) dwArg00 + 40);
			if (edx_207 != *((word32) dwArg04 + 40))
				return;
			Eq_4 ebx_215 = 0x00;
			while (ebx_215 < edx_207)
			{
				Eq_4 esi_229 = *((word32) dwArg00 + 36);
				if (ebx_215 >= *((word32) dwArg00 + 40))
					runtime.panicindex(gs);
				ui32 ebp_233 = ebx_215 * 0x03;
				Eq_4 ecx_236 = *((word32) dwArg04 + 36);
				if (ebx_215 >= *((word32) dwArg04 + 40))
					runtime.panicindex(gs);
				Eq_4 edi_239 = *((word32) esi_229 + ebp_233 * 0x04);
				Eq_4 dwLoc1C_983 = 0x00;
				Eq_4 dwLoc18_984 = 0x00;
				if (edi_239 != 0x00)
				{
					dwLoc1C_983 = (word32) edi_239 + 3;
					dwLoc18_984 = (word32) *((word32) edi_239 + 2) | (word32) (*((word32) edi_239 + 1)) << 0x08;
				}
				Eq_4 eax_257 = *((word32) ecx_236 + ebp_233 * 0x04);
				Eq_4 dwLoc0C_987 = 0x00;
				Eq_4 dwLoc08_988 = 0x00;
				if (eax_257 != 0x00)
				{
					dwLoc0C_987 = (word32) eax_257 + 3;
					dwLoc08_988 = (word32) *((word32) eax_257 + 1) << 0x08 | (word32) (*((word32) eax_257 + 2));
				}
				if (dwLoc08_988 != dwLoc18_984)
					return;
				word32 edi_294;
				word32 esi_1439;
				runtime.eqstring(dwLoc1C_983, dwLoc18_984, dwLoc0C_987, out esi_1439, out edi_294);
				if ((byte) (word32) bLoc60 == 0x00)
					return;
				Eq_4 edx_315 = *((word32) esi_229 + (ebp_233 * 0x04 + 4));
				byte dl_324 = (byte) (word32) bArg08;
				reflect.haveIdenticalType(gs, 0x08138A00, edx_315, 0x08138A00, *((word32) ecx_236 + (ebp_233 * 0x04 + 4)), dl_324);
				Eq_4 dwLoc68_1009 = 0x08138A00;
				Eq_4 dwLoc6C_1012 = edx_315;
				bLoc60 = dl_324;
				if ((byte) (word32) bLoc5C == 0x00)
					return;
				if ((byte) (word32) bArg08 != 0x00)
				{
					reflect.name.tag(gs, *((word32) esi_229 + ebp_233 * 0x04));
					reflect.name.tag(gs, *((word32) ecx_236 + ebp_233 * 0x04));
					if (true)
					{
						word32 edi_1443;
						word32 esi_1442;
						runtime.eqstring(edx_315, 0x08138A00, edx_315, out esi_1442, out edi_1443);
						dwLoc6C_1012.u0 = 0x08138A00;
						dwLoc68_1009 = edx_315;
						if ((byte) (word32) dl_324 != 0x00)
							goto l080A92D3;
					}
					return;
				}
l080A92D3:
				if (*((word32) esi_229 + (ebp_233 * 0x04 + 8)) != *((word32) ecx_236 + (ebp_233 * 0x04 + 8)))
					return;
				Eq_4 edx_420 = *((word32) esi_229 + ebp_233 * 0x04);
				if (((byte) (word32) *edx_420 & 0x01) == 0x00)
				{
					Eq_4 edx_444;
					reflect.name.pkgPath(gs, edx_420);
					Eq_4 ecx_440 = dwLoc6C_1012;
					if (dwLoc68_1009 == 0x00)
					{
						Eq_4 ecx_446 = *((word32) dwArg00 + 32);
						Eq_4 dwLoc14_1044 = 0x00;
						Eq_4 dwLoc10_1045 = 0x00;
						if (ecx_446 != 0x00)
						{
							dwLoc14_1044 = (word32) ecx_446 + 3;
							dwLoc10_1045 = (word32) *((word32) ecx_446 + 2) | (word32) (*((word32) ecx_446 + 1)) << 0x08;
						}
						ecx_440 = dwLoc14_1044;
						edx_444 = dwLoc10_1045;
					}
					else
						edx_444 = dwLoc68_1009;
					Eq_4 edx_492;
					Eq_4 ecx_493;
					reflect.name.pkgPath(gs, *((word32) ecx_236 + ebp_233 * 0x04));
					if (dwLoc68_1009 == 0x00)
					{
						Eq_4 ecx_496 = *((word32) dwArg04 + 32);
						Eq_4 dwLoc24_1064 = 0x00;
						Eq_4 dwLoc20_1065 = 0x00;
						if (ecx_496 != 0x00)
						{
							dwLoc24_1064 = (word32) ecx_496 + 3;
							dwLoc20_1065 = (word32) *((word32) ecx_496 + 1) << 0x08 | (word32) (*((word32) ecx_496 + 2));
						}
						ecx_493 = dwLoc20_1065;
						edx_492 = dwLoc24_1064;
					}
					else
					{
						edx_492 = dwLoc6C_1012;
						ecx_493 = dwLoc68_1009;
					}
					if (ecx_493 == edx_444)
					{
						word32 edi_1441;
						word32 esi_1440;
						runtime.eqstring(ecx_440, edx_444, edx_492, out esi_1440, out edi_1441);
						if ((byte) (word32) dl_324 != 0x00)
							goto l080A91A1;
					}
					return;
				}
l080A91A1:
				ebx_215 = (word32) ebx_215 + 1;
			}
		}
	}
	else if ((edx_30 & 0x1F) == 0x11)
	{
		reflect.(*rtype).Len(gs, dwArg00);
		reflect.(*rtype).Len(gs, dwArg04);
		if (dwLoc6C == dwLoc6C)
		{
			reflect.(*rtype).Elem(gs, dwArg00);
			reflect.(*rtype).Elem(gs, dwArg04);
			reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, (byte) (word32) bArg08);
		}
	}
	else if ((edx_30 & 0x1F) == 0x12)
	{
		reflect.(*rtype).ChanDir(gs, dwArg04);
		if (dwLoc6C == 0x03)
		{
			reflect.(*rtype).Elem(gs, dwArg00);
			reflect.(*rtype).Elem(gs, dwArg04);
			reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, (byte) (word32) bArg08);
			dwLoc6C = dwLoc68;
			dwLoc68 = dwLoc6C;
			if ((byte) (word32) bLoc5C != 0x00)
				return;
		}
		reflect.(*rtype).ChanDir(gs, dwArg04);
		reflect.(*rtype).ChanDir(gs, dwArg00);
		if (dwLoc6C == dwLoc6C)
		{
			reflect.(*rtype).Elem(gs, dwArg00);
			reflect.(*rtype).Elem(gs, dwArg04);
			reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, (byte) (word32) bArg08);
		}
	}
	else
	{
		if ((edx_30 & 0x1F) != 0x13)
			return;
		if ((word16) (word32) *((word32) dwArg00 + 0x0022) != (word16) ((word32) (*((word32) dwArg04 + 0x0022))) || (word16) ((word32) (*((word32) dwArg00 + 32))) != (word16) ((word32) (*((word32) dwArg04 + 32))))
			return;
		Eq_4 edx_783 = 0x00;
		while (true)
		{
			reflect.(*rtype).NumIn(gs, dwArg00);
			if (edx_783 >= dwLoc6C)
				break;
			reflect.(*rtype).In(gs, dwArg00, edx_783);
			reflect.(*rtype).In(gs, dwArg04, edx_783);
			reflect.haveIdenticalType(gs, dwLoc68, dwLoc64, dwLoc68, dwLoc64, (byte) (word32) bArg08);
			dwLoc6C = dwLoc64;
			if ((byte) (word32) bLoc5C == 0x00)
				return;
			edx_783 = (word32) edx_783 + 1;
		}
		Eq_4 eax_803 = 0x00;
		while (true)
		{
			reflect.(*rtype).NumOut(gs, dwArg00);
			if (eax_803 >= dwLoc6C)
				break;
			reflect.(*rtype).Out(gs, dwArg00, eax_803);
			reflect.(*rtype).Out(gs, dwArg04, eax_803);
			reflect.haveIdenticalType(gs, dwLoc68, dwLoc64, dwLoc68, dwLoc64, (byte) (word32) bArg08);
			dwLoc6C = dwLoc64;
			if ((byte) (word32) bLoc5C == 0x00)
				return;
			eax_803 = (word32) eax_803 + 1;
		}
	}
}

// subject_text_0006.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text_0006.h"

// 080A9620: void reflect.typesByString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
void reflect.typesByString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.typelinks(gs);
	struct Eq_119308 * ecx_144 = dwLoc68;
	Eq_4 ebp_146 = 0x00;
	Eq_4 esi_150 = 0x00;
	Eq_4 edi_151 = 0x00;
	Eq_4 dwLoc4C_318 = 0x00;
	dwLoc70_342 = dwLoc70;
	dwLoc64_366 = dwLoc64;
	while (true)
	{
		Eq_4 dwLoc64_366;
		Eq_4 dwLoc70_342;
		if (ebp_146 >= dwLoc64)
			break;
		Eq_119323 eax_58 = ecx_144->dw0004;
		word32 ecx_59[] = ecx_144->dw0000;
		if (ebp_146 >= dwLoc70)
			runtime.panicindex(gs);
		word32 ebx_70 = dwLoc74[ebp_146];
		Eq_119323 dwLoc38_331 = 0x00;
		Eq_119323 eax_285 = eax_58;
		while (true)
		{
			Eq_4 edi_220 = edi_151;
			Eq_4 esi_218 = esi_150;
			Eq_119323 edx_225 = dwLoc38_331;
			if (dwLoc38_331 >= eax_285)
				break;
			int32 eax_229 = eax_285 - dwLoc38_331;
			Eq_119349 eax_234 = (eax_229 >> 0x1F >> 0x1F) + eax_229;
			Eq_119323 ebp_236 = (word32) dwLoc38_331.u0 + (eax_234 >> 0x01);
			if (ebp_236 >= eax_58)
				runtime.panicindex(gs);
			Eq_119323 ecx_284;
			reflect.(*rtype).String(gs, ecx_59[ebp_236] + ebx_70);
			runtime.cmpstring(dwLoc70_342, dwLoc6C, dwArg04, dwArg08);
			dwLoc70_342 = dwLoc6C;
			dwLoc6C = dwArg04;
			if (dwLoc64_366 >= 0x00)
			{
				eax_285 = ebp_236;
				ecx_284 = dwLoc38_331;
			}
			else
				ecx_284 = (word32) dwLoc38_331.u0 + ((eax_234 >> 0x01) + 0x01);
			dwLoc38_331 = ecx_284;
		}
		Eq_4 eax_226 = dwLoc4C_318;
		while (true)
		{
			byte bLoc64_349 = (byte) dwLoc64_366;
			dwLoc4C_318 = eax_226;
			if (edx_225 >= eax_58)
				break;
			if (edx_225 >= eax_58)
				runtime.panicindex(gs);
			Eq_4 eax_103 = ecx_59[edx_225] + ebx_70;
			reflect.(*rtype).String(gs, eax_103);
			if (dwLoc6C != dwArg08)
				break;
			word32 edi_514;
			word32 esi_513;
			runtime.eqstring(dwLoc70_342, dwLoc6C, dwArg04, out esi_513, out edi_514);
			dwLoc70_342 = dwLoc6C;
			dwLoc6C = dwArg04;
			if ((byte) (word32) bLoc64_349 == 0x00)
				break;
			Eq_4 ebx_175;
			Eq_4 ecx_153 = (word32) edi_220 + 1;
			Eq_4 edx_154 = eax_226;
			if ((word32) edi_220 + 1 <= eax_226)
				ebx_175 = esi_218;
			else
			{
				dwLoc64_366 = (word32) edi_220 + 1;
				word32 esi_515;
				runtime.growslice(gs, 0x080DDF40, esi_218, edi_220, eax_226, dwLoc64_366, out esi_515);
				dwLoc70_342 = esi_218;
				dwLoc6C = edi_220;
				ebx_175 = dwLoc60;
				edx_154 = dwLoc58;
				ecx_153 = dwLoc5C + 0x01;
			}
			Eq_4 ebp_183 = (word32) ebx_175 + edi_220 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ebx_175 + edi_220 * 0x04) = eax_103;
			else
			{
				runtime.writebarrierptr(ebp_183, eax_103);
				dwLoc70_342 = eax_103;
			}
			esi_218 = ebx_175;
			edi_220 = ecx_153;
			edx_225 = (word32) edx_225 + 1;
			eax_226 = edx_154;
		}
		++ecx_144;
		ebp_146 = (word32) ebp_146 + 1;
		esi_150 = esi_218;
		edi_151 = edi_220;
	}
}

// 080A98E0: void reflect.FuncOf(Register (ptr32 Eq_2) gs, Stack (ptr32 word32) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg14, Stack byte bArg1C)
// Called from:
//      reflect.(*rtype).Method
void reflect.FuncOf(struct Eq_2 * gs, word32 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg14, byte bArg1C)
{
	while (fp - 0x18 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_119453 * esp_17 = fp - 0x98;
	if ((byte) (word32) bArg1C != 0x00)
	{
		if (dwArg08 != 0x00)
		{
			if (dwArg08 - 0x01 >= dwArg08)
				runtime.panicindex(gs);
			struct Eq_120410 ** edx_33 = dwArg04 - 0x08 + dwArg08 * 0x08;
			<anonymous> * edx_36 = *((char *) *edx_33 + 84);
			edx_36();
			if (dwLoc94 == 0x17)
				goto l080A9926;
		}
		runtime.gopanic(gs);
	}
	else
	{
l080A9926:
		Eq_4 edx_104;
		word32 ebp_75 = dwArg08 + dwArg14;
		if (ebp_75 > 0x04)
		{
			if (ebp_75 > 0x08)
			{
				if (ebp_75 > 0x10)
				{
					if (ebp_75 > 0x20)
					{
						if (ebp_75 > 0x40)
						{
							if (ebp_75 > 0x80)
								runtime.gopanic(gs);
							runtime.newobject(gs, 0x080D3260);
							edx_104.u0 = 0x80;
						}
						else
						{
							runtime.newobject(gs, 0x080D33E0);
							edx_104.u0 = 0x40;
						}
					}
					else
					{
						runtime.newobject(gs, 0x080D3320);
						edx_104.u0 = 0x20;
					}
				}
				else
				{
					runtime.newobject(gs, 0x080D32C0);
					edx_104.u0 = 0x10;
				}
			}
			else
			{
				runtime.newobject(gs, 0x080D3440);
				edx_104.u0 = 0x08;
			}
		}
		else
		{
			runtime.newobject(gs, 0x080D3380);
			edx_104.u0 = 0x04;
		}
		if (g_t81576F0 == 0x00)
		{
			fn08090246(&g_dw80CA340, dwLoc94);
			esp_17 = fp - 0x9C;
		}
		else
		{
			word32 esi_1471;
			word32 edi_1472;
			runtime.typedmemmove(0x080D58C0, dwLoc94, 0x080CA340, out esi_1471, out edi_1472);
		}
		Eq_4 edx_1008 = edx_104;
		Eq_4 ecx_1004 = 0x00;
		struct Eq_119544 * ebx_1002 = esp_17->ptr009C;
		Eq_4 ebp_1000 = 0x00;
		Eq_4 esi_1006 = esp_17->t008C;
		Eq_4 edi_1007 = 0x00;
		while (true)
		{
			esp_17->t002C = edi_1007;
			if (ecx_1004 >= esp_17->t00A0)
				break;
			esp_17->t0048 = ecx_1004;
			esp_17->ptr0088 = ebx_1002;
			Eq_4 eax_889 = ebx_1002->t0004;
			Eq_4 ecx_890 = ebx_1002->t0000;
			if (ecx_890 != 0x08138A00)
			{
				esp_17->t0000 = ecx_890;
				esp_17->t0004.u0 = 0x080DDF40;
				esp_17->t0008.u0 = 135117536;
				runtime.panicdottypeI(gs, esp_17->t0000);
			}
			esp_17->t0064 = eax_889;
			esp_17->t0028 = ebp_1000;
			Eq_4 ecx_907 = (word32) edi_1007 + 1;
			if (ecx_907 > edx_1008)
			{
				esp_17->t0000.u0 = 0x080DDF40;
				esp_17->t0004 = esi_1006;
				esp_17->t0008 = edi_1007;
				esp_17->t000C = edx_1008;
				esp_17->t0010 = ecx_907;
				word32 esi_1473;
				runtime.growslice(gs, esp_17->t0000, esp_17->t0004, esp_17->t0008, esp_17->t000C, esp_17->t0010, out esi_1473);
				esi_1006 = esp_17->t0014;
				edx_1008 = esp_17->t001C;
				ecx_907 = esp_17->dw0018 + 0x01;
				eax_889 = esp_17->t0064;
				ebp_1000 = esp_17->t0028;
				edi_1007 = esp_17->t002C;
			}
			esp_17->t006C = esi_1006;
			esp_17->t002C = ecx_907;
			esp_17->t0030 = edx_1008;
			Eq_4 ebx_943 = (word32) esi_1006 + edi_1007 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) esi_1006 + edi_1007 * 0x04) = eax_889;
			else
			{
				esp_17->t0000 = ebx_943;
				esp_17->t0004 = eax_889;
				runtime.writebarrierptr(esp_17->t0000, esp_17->t0004);
				eax_889 = esp_17->t0064;
				ebp_1000 = esp_17->t0028;
			}
			esp_17->t0040.u1 = 0x00;
			esp_17->t0040 = (byte) (*((word32) eax_889 + 8) >> 0x18);
			esp_17->b0041 = (byte) (*((word32) eax_889 + 8) >> 0x10);
			esp_17->b0042 = (byte) (*((word32) eax_889 + 8) >> 0x08);
			esp_17->t0043 = *((word32) eax_889 + 8);
			esp_17->t0000 = ebp_1000;
			esp_17->t0004 = &esp_17->t0040;
			esp_17->t0008.u0 = 0x04;
			esp_17->t000C.u0 = 0x04;
			reflect.fnv1(gs, esp_17->t0008);
			ebp_1000 = esp_17->t0010;
			ebx_1002 = (struct Eq_119544 *) ((char *) &esp_17->ptr0088->t0004 + 4);
			ecx_1004 = (word32) esp_17->t0048 + 1;
			esi_1006 = esp_17->t006C;
			edi_1007 = esp_17->t002C;
			edx_1008 = esp_17->t0030;
		}
		esp_17->t0084 = esi_1006;
		esp_17->t0044 = edx_1008;
		if ((byte) (word32) esp_17->b00B4 != 0x00)
		{
			esp_17->b0023 = (byte) (word32) g_b80F1803;
			esp_17->t0000 = ebp_1000;
			esp_17->t0004 = &esp_17->b0023;
			esp_17->t0008.u0 = 0x01;
			esp_17->t000C.u0 = 0x01;
			reflect.fnv1(gs, esp_17->t0008);
			ebp_1000 = esp_17->t0010;
		}
		esp_17->b0022 = (byte) (word32) g_b80F1804;
		esp_17->t0000 = ebp_1000;
		esp_17->t0004 = &esp_17->b0022;
		esp_17->t0008.u0 = 0x01;
		esp_17->t000C.u0 = 0x01;
		reflect.fnv1(gs, esp_17->t0008);
		Eq_4 eax_287 = esp_17->t0010;
		Eq_4 ecx_288 = 0x00;
		struct Eq_119834 * edx_291 = esp_17->ptr00A8;
		Eq_4 ebx_292 = esp_17->t0084;
		Eq_4 ebp_293 = esp_17->t0044;
		Eq_4 esi_294 = esp_17->t002C;
		while (true)
		{
			esp_17->t0028 = eax_287;
			Eq_4 edi_298 = esp_17->t00AC;
			word16 di_328 = (word16) edi_298;
			if (ecx_288 >= edi_298)
				break;
			esp_17->t0048 = ecx_288;
			esp_17->ptr0080 = edx_291;
			Eq_4 edi_764 = edx_291->t0004;
			Eq_4 ecx_765 = edx_291->t0000;
			if (ecx_765 != 0x08138A00)
			{
				esp_17->t0000 = ecx_765;
				esp_17->t0004.u0 = 0x080DDF40;
				esp_17->t0008.u0 = 135117536;
				runtime.panicdottypeI(gs, esp_17->t0000);
			}
			esp_17->t0060 = edi_764;
			Eq_4 ecx_781 = (word32) esi_294 + 1;
			if (ecx_781 > ebp_293)
			{
				esp_17->t002C = esi_294;
				esp_17->t0000.u0 = 0x080DDF40;
				esp_17->t0004 = ebx_292;
				esp_17->t0008 = esi_294;
				esp_17->t000C = ebp_293;
				esp_17->t0010 = ecx_781;
				word32 esi_1474;
				runtime.growslice(gs, esp_17->t0000, esp_17->t0004, esp_17->t0008, esp_17->t000C, esp_17->t0010, out esi_1474);
				ebx_292 = esp_17->t0014;
				ebp_293 = esp_17->t001C;
				ecx_781 = esp_17->dw0018 + 0x01;
				eax_287 = esp_17->t0028;
				esi_294 = esp_17->t002C;
				edi_764 = esp_17->t0060;
			}
			esp_17->t006C = ebx_292;
			esp_17->t002C = ecx_781;
			esp_17->t0030 = ebp_293;
			Eq_4 edx_820 = (word32) ebx_292 + esi_294 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ebx_292 + esi_294 * 0x04) = edi_764;
			else
			{
				esp_17->t0000 = edx_820;
				esp_17->t0004 = edi_764;
				runtime.writebarrierptr(esp_17->t0000, esp_17->t0004);
				eax_287 = esp_17->t0028;
				edi_764 = esp_17->t0060;
			}
			esp_17->t003C.u1 = 0x00;
			esp_17->t003C = (byte) (*((word32) edi_764 + 8) >> 0x18);
			esp_17->b003D = (byte) (*((word32) edi_764 + 8) >> 0x10);
			esp_17->b003E = (byte) (*((word32) edi_764 + 8) >> 0x08);
			esp_17->t003F = *((word32) edi_764 + 8);
			esp_17->t0000 = eax_287;
			esp_17->t0004 = &esp_17->t003C;
			esp_17->t0008.u0 = 0x04;
			esp_17->t000C.u0 = 0x04;
			reflect.fnv1(gs, esp_17->t0008);
			eax_287 = esp_17->t0010;
			edx_291 = (struct Eq_119834 *) ((char *) &esp_17->ptr0080->t0004 + 4);
			ecx_288 = (word32) esp_17->t0048 + 1;
			ebx_292 = esp_17->t006C;
			ebp_293 = esp_17->t0030;
			esi_294 = esp_17->t002C;
		}
		if (esi_294 > 0x32)
		{
			esp_17->t0000.u0 = 135066016;
			esp_17->t0004.u0 = 0x080F19B0;
			runtime.gopanic(gs);
		}
		else
		{
			Eq_4 ecx_322 = esp_17->t0068;
			((word32) ecx_322 + 0x0C)->u0 = 0x00;
			*((word32) ecx_322 + 8) = eax_287;
			*((word32) ecx_322 + 32) = esp_17->t00A0;
			((word32) ecx_322 + 0x0022)->u1 = di_328;
			if ((byte) (word32) esp_17->b00B4 != 0x00)
				((word32) ecx_322 + 0x0022)->u1 = (word16) (edi_298 | ~0x7FFF);
			esp_17->t0038 = eax_287;
			esp_17->t0000.u0 = 135549544;
			esp_17->t0004.u0 = 0x080CF2A0;
			esp_17->t0008 = &esp_17->t0038;
			sync.(*Map).Load(gs, esp_17->t0000, esp_17->t0004, esp_17->t0008);
			Eq_4 eax_362 = esp_17->t0010;
			Eq_4 ecx_363 = esp_17->t000C;
			if ((byte) (word32) esp_17->t0014 != 0x00)
			{
				if (ecx_363 != 0x080C9000)
				{
					esp_17->t0000 = ecx_363;
					esp_17->t0004.u0 = 0x080C9000;
					esp_17->t0008.u0 = 0x080CECA0;
					runtime.panicdottypeE(gs, esp_17->t0000);
				}
				Eq_4 ecx_376 = *((word32) eax_362 + 4);
				esp_17->t0048 = ecx_376;
				struct Eq_120209 * eax_378 = *eax_362;
				Eq_4 ebx_379 = 0x00;
				while (true)
				{
					byte bLoc8C_1326 = (byte) dwLoc8C;
					if (ebx_379 >= ecx_376)
						break;
					esp_17->t0044 = ebx_379;
					esp_17->ptr007C = eax_378;
					Eq_4 ecx_715 = eax_378->t0000;
					esp_17->t0050 = ecx_715;
					esp_17->t0000 = esp_17->t0068;
					esp_17->t0004 = ecx_715;
					esp_17->t0008.u0 = 0x01;
					reflect.haveIdenticalUnderlyingType(gs, esp_17->tFFFFFFFC, esp_17->t0000, esp_17->t0004);
					esp_17 = fp - 0x0098;
					if ((byte) (word32) bLoc8C_1326 != 0x00)
					{
						runtime.deferreturn(gs);
						return;
					}
					eax_378 = dwLoc1C + 0x04;
					ebx_379 = dwLoc54 + 0x01;
					ecx_376 = dwLoc50;
				}
			}
			sync.(*Mutex).Lock(gs, 135549536);
			word32 ebp_1475;
			word32 esi_1476;
			word32 edi_1477;
			if (runtime.deferproc(gs, 0x04, 0x080E7D08, 135549536, out ebp_1475, out esi_1476, out edi_1477) != 0x00)
				runtime.deferreturn(gs);
			else
			{
				sync.(*Map).Load(gs, 135549544, 0x080CF2A0, fp - 100);
				Eq_4 dwLoc90_1240 = fp - 100;
				if ((byte) (word32) bLoc84 != 0x00)
				{
					if (dwLoc8C != 0x080C9000)
						runtime.panicdottypeE(gs, dwLoc8C);
					int32 eax_468 = dwLoc88->dw0004;
					struct Eq_120269 * ecx_470 = dwLoc88->ptr0000;
					int32 edx_471 = 0x00;
					while (true)
					{
						byte bLoc8C_1322 = (byte) dwLoc8C;
						word24 nLoc8F_1399 = SLICE(dwLoc90_1240, word24, 8);
						if (edx_471 >= eax_468)
							break;
						reflect.haveIdenticalUnderlyingType(gs, dwLoc9C, dwLoc94, ecx_470->b0000);
						dwLoc90_1240 = SEQ(nLoc8F_1399, 0x01);
						if ((byte) (word32) bLoc8C_1322 != 0x00)
						{
							runtime.deferreturn(gs);
							return;
						}
						++ecx_470;
						++edx_471;
					}
				}
				runtime.newobject(gs, 0x080D10A0);
				*dwLoc94 = 0x080AFA50;
				*((word32) dwLoc94 + 4) = dwLoc70;
				reflect.funcStr(gs, dwLoc9C, dwLoc94, dwLoc94);
				reflect.typesByString(gs, dwLoc94, dwLoc90_1240);
				byte bLoc8C_1420 = (byte) dwLoc8C;
				Eq_4 ecx_530 = dwLoc90_1240;
				Eq_4 edx_531 = 0x00;
				while (edx_531 < dwLoc8C)
				{
					word32 eax_610 = *ecx_530;
					reflect.haveIdenticalUnderlyingType(gs, dwLoc9C, dwLoc94, (byte) eax_610);
					if ((byte) (word32) bLoc8C_1420 != 0x00)
					{
						fn00000004();
						runtime.deferreturn(gs);
						return;
					}
					ecx_530 = (word32) ecx_530 + 4;
					edx_531 = (word32) edx_531 + 1;
				}
				Eq_4 edi_554;
				Eq_4 esi_556;
				reflect.resolveReflectName(SLICE(reflect.newName(gs, dwLoc94, dwLoc90_1240, 0x00, 0x00, 0x00, 0x00, out esi_556, out edi_554), word24, 8), esi_556, edi_554, gs, dwLoc7C);
				*((word32) dwLoc94 + 24) = dwLoc90_1240;
				((word32) dwLoc94 + 28)->u0 = 0x00;
				fn00000004();
				runtime.deferreturn(gs);
			}
		}
	}
}

// 080AA210: void reflect.funcStr(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.FuncOf
void reflect.funcStr(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x20 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD80(0x00, fp - 0x5C);
	word32 esi_1243;
	word32 edi_1244;
	word32 ebp_1242;
	runtime.memmove(fp - 0x60, 0x080E1038, 0x05, out ebp_1242, out esi_1243, out edi_1244);
	Eq_4 dwLoc9C_1052 = 0x05;
	Eq_4 ecx_102 = dwArg00;
	((byte) (word32) *((word32) dwArg00 + 0x0C) & 0x01) == 0x00;
	Eq_120461 edx_55 = (word32) *((word32) dwArg00 + 32);
	if (edx_55 > 0x00100000)
		runtime.panicslice(gs);
	else
	{
		Eq_120461 ebx_61 = 0x00;
		Eq_4 ebp_104 = fp - 0x60;
		Eq_4 esi_163 = 0x40;
		Eq_4 edi_66 = 0x05;
		Eq_4 dwLoc98_1001 = dwLoc98;
		while (true)
		{
			Eq_4 dwLoc98_1184 = dwLoc98_1001;
			if (ebx_61 >= edx_55)
				break;
			Eq_4 edx_506;
			Eq_4 ecx_505;
			Eq_4 eax_504;
			if (ebx_61 > 0x00)
			{
				Eq_4 eax_507 = (word32) edi_66 + 2;
				if (eax_507 > esi_163)
				{
					word32 esi_1245;
					runtime.growslice(gs, 0x080CF320, ebp_104, edi_66, esi_163, eax_507, out esi_1245);
					dwLoc94 = esi_163;
					esi_163 = dwLoc84;
					ebp_104 = dwLoc8C;
				}
				if (eax_507 > esi_163)
					runtime.panicslice(gs);
				word32 esi_1247;
				word32 edi_1248;
				word32 ebp_1246;
				runtime.memmove(edi_66 + ebp_104, 0x080E0DB5, 0x02, out ebp_1246, out esi_1247, out edi_1248);
				dwLoc98_1001.u0 = 0x02;
				eax_504 = ebp_104;
				ecx_505 = esi_163;
				edx_506 = eax_507;
			}
			else
			{
				eax_504 = ebp_104;
				ecx_505 = esi_163;
				edx_506 = edi_66;
			}
			Eq_4 dwLoc98_1053;
			Eq_4 edx_672;
			Eq_4 eax_670;
			Eq_4 ecx_671;
			reflect.(*rtype).IsVariadic(gs, dwArg04);
			if ((byte) (word32) (byte) dwLoc98_1001 != 0x00 && (word32) (*((word32) dwArg08 + 32)) - 0x01 == dwLoc70)
			{
				Eq_4 esi_698;
				word32 ebx_674 = ecx_505 + 0x03;
				word32 dwLoc60_1056 = ecx_505 + 0x03;
				Eq_4 ebp_676 = dwLoc78;
				if (ecx_505 + 0x03 <=u dwLoc78)
					esi_698 = dwLoc10;
				else
				{
					dwLoc8C = ecx_505 + 0x03;
					word32 esi_1249;
					runtime.growslice(gs, 0x080CF320, dwLoc10, ecx_505, dwLoc78, dwLoc8C, out esi_1249);
					ebp_676 = edx_506;
					esi_698 = dwLoc88;
					ebx_674 = dwLoc60_1056;
				}
				if (ebx_674 > ebp_676)
					runtime.panicslice(gs);
				Eq_4 esi_772;
				word32 ebp_1250;
				word32 esi_1251;
				word32 edi_1252;
				runtime.memmove(ecx_505 + esi_698, 0x080E0E3A, 0x03, out ebp_1250, out esi_1251, out edi_1252);
				reflect.(*rtype).String(gs, *((word32) eax_504 + 32));
				word32 edx_744 = ecx_505 + 0x06;
				Eq_4 ebp_747 = ebp_676;
				if (edx_744 <= ebp_676)
					esi_772 = esi_698;
				else
				{
					word32 esi_1253;
					runtime.growslice(gs, 0x080CF320, esi_698, dwLoc60_1056, ebp_676, edx_744, out esi_1253);
					dwLoc8C = edx_744;
					ebp_747 = edx_506;
					esi_772 = dwLoc88;
				}
				if (edx_744 > ebp_747)
					runtime.panicslice(gs);
				word32 ecx_788 = ecx_505 + 0x03 + esi_772;
				word32 esi_1255;
				word32 edi_1256;
				word32 ebp_1254;
				runtime.memmove(ecx_788, 0x080E0E3A, 0x03, out ebp_1254, out esi_1255, out edi_1256);
				dwLoc10 = esi_772;
				dwLoc78 = ebp_747;
				dwLoc9C_1052 = ecx_788;
				dwLoc98_1053.u0 = 0x080E0E3A;
				dwLoc94.u0 = 0x03;
				eax_670 = edx_744;
				ecx_671 = ebp_747;
				edx_672 = esi_772;
			}
			else
			{
				Eq_4 esi_636;
				reflect.(*rtype).String(gs, eax_504);
				word32 edx_609 = ecx_505 + dwLoc94;
				Eq_4 ebp_612 = dwLoc78;
				if (edx_609 <= dwLoc78)
					esi_636 = dwLoc10;
				else
				{
					word32 esi_1272;
					runtime.growslice(gs, 0x080CF320, dwLoc10, ecx_505, dwLoc78, edx_609, out esi_1272);
					dwLoc8C = edx_609;
					ebp_612 = edx_506;
					esi_636 = dwLoc88;
				}
				if (edx_609 > ebp_612)
					runtime.panicslice(gs);
				word32 ecx_652 = ecx_505 + esi_636;
				word32 edi_1275;
				word32 ebp_1273;
				word32 esi_1274;
				runtime.memmove(ecx_652, dwLoc98_1001, dwLoc94, out ebp_1273, out esi_1274, out edi_1275);
				dwLoc78 = ebp_612;
				dwLoc10 = esi_636;
				dwLoc9C_1052 = ecx_652;
				dwLoc98_1053 = dwLoc98_1001;
				eax_670 = edx_609;
				ecx_671 = ebp_612;
				edx_672 = esi_636;
			}
			esi_163 = ecx_671;
			edi_66 = eax_670;
			ecx_102 = dwArg08;
			ebx_61 = dwLoc70 + 0x01;
			ebp_104 = edx_672;
			edx_55 = dwLoc5C;
			dwLoc98_1001 = dwLoc98_1053;
		}
		Eq_4 eax_1237 = (word32) edi_66 + 1;
		if (eax_1237 > esi_163)
		{
			word32 esi_1257;
			runtime.growslice(gs, 0x080CF320, ebp_104, edi_66, esi_163, eax_1237, out esi_1257);
			dwLoc9C_1052 = ebp_104;
			dwLoc98_1184 = edi_66;
			ebp_104 = dwLoc8C;
			esi_163 = dwLoc84;
			ecx_102 = dwArg04;
			eax_1237 = (word32) dwLoc88 + 1;
		}
		word32 edx_114;
		Mem106[ebp_104 + edi_66:byte] = 0x29;
		if (((byte) (word32) *((word32) ecx_102 + 0x0C) & 0x01) != 0x00)
			edx_114 = 0x34;
		else
			edx_114 = 0x24;
		word32 ecx_128 = (word32) *((word32) ecx_102 + 32);
		word32 edx_119 = (word32) ecx_102 + edx_114;
		uint32 edi_130 = (word32) (word16) ecx_128;
		uint32 ecx_133 = (word32) (word16) (ecx_128 + ((word32) (*((word32) ecx_102 + 0x0022)) & 0x7FFF));
		Eq_4 eax_145 = eax_1237;
		if (edi_130 > ecx_133 || ecx_133 > 0x00100000)
			runtime.panicslice(gs);
		else
		{
			Eq_4 ebx_227;
			Eq_120626 ecx_149 = ecx_133 - edi_130;
			word32 * edx_157 = edx_119 + (edi_130 << 0x02 & -(-(edi_130 + 0xFFF00000)) >> 0x1F);
			if (ecx_149 == 0x01)
			{
				ebx_227 = (word32) eax_1237 + 1;
				if ((word32) eax_1237 + 1 > esi_163)
				{
					word32 esi_1258;
					runtime.growslice(gs, 0x080CF320, ebp_104, eax_1237, esi_163, (word32) eax_1237 + 1, out esi_1258);
					dwLoc9C_1052 = ebp_104;
					dwLoc98_1184 = eax_1237;
					ebp_104 = dwLoc8C;
					esi_163 = dwLoc84;
					ebx_227 = (word32) dwLoc88 + 1;
				}
				Mem263[ebp_104 + eax_1237:byte] = 0x20;
			}
			else
			{
				Eq_4 edx_166;
				Eq_4 ecx_164;
				if (ecx_149 > 0x01)
				{
					word32 ebx_167 = eax_1237 + 0x02;
					word32 dwLoc60_888 = eax_1237 + 0x02;
					if (eax_1237 + 0x02 >u esi_163)
					{
						word32 esi_1267;
						runtime.growslice(gs, 0x080CF320, ebp_104, eax_1237, esi_163, eax_1237 + 0x02, out esi_1267);
						esi_163 = dwLoc84;
						ebp_104 = dwLoc8C;
						ebx_167 = dwLoc60_888;
					}
					if (ebx_167 > esi_163)
						runtime.panicslice(gs);
					word32 edi_1270;
					word32 ebp_1268;
					word32 esi_1269;
					runtime.memmove(eax_1237 + ebp_104, 0x080E0DA3, 0x02, out ebp_1268, out esi_1269, out edi_1270);
					dwLoc9C_1052.u0 = 0x080E0DA3;
					dwLoc98_1184.u0 = 0x02;
					eax_145 = dwLoc60_888;
					ecx_164 = esi_163;
					edx_166 = ebp_104;
				}
				else
				{
					ecx_164 = esi_163;
					edx_166 = ebp_104;
				}
				esi_163 = ecx_164;
				ebx_227 = eax_145;
				ebp_104 = edx_166;
			}
			word32 * edx_340 = edx_157;
			Eq_120626 eax_264 = 0x00;
			while (eax_264 < ecx_149)
			{
				Eq_4 edx_348;
				Eq_4 ecx_347;
				Eq_4 eax_346;
				Eq_4 edi_342 = *edx_340;
				if (eax_264 > 0x00)
				{
					Eq_4 ecx_349 = (word32) ebx_227 + 2;
					if (ecx_349 > esi_163)
					{
						word32 esi_1259;
						runtime.growslice(gs, 0x080CF320, ebp_104, ebx_227, esi_163, ecx_349, out esi_1259);
						esi_163 = dwLoc84;
						ebp_104 = dwLoc8C;
					}
					if (ecx_349 > esi_163)
						runtime.panicslice(gs);
					word32 esi_1261;
					word32 edi_1262;
					word32 ebp_1260;
					runtime.memmove(ebp_104 + ebx_227, 0x080E0DB5, 0x02, out ebp_1260, out esi_1261, out edi_1262);
					dwLoc9C_1052.u0 = 0x080E0DB5;
					dwLoc98_1184.u0 = 0x02;
					eax_346 = esi_163;
					ecx_347 = ebp_104;
					edx_348 = ecx_349;
				}
				else
				{
					eax_346 = esi_163;
					ecx_347 = ebp_104;
					edx_348 = ebx_227;
				}
				Eq_4 esi_454;
				reflect.(*rtype).String(gs, edi_342);
				word32 edx_427 = dwLoc98_1184 + edx_348;
				Eq_4 ebp_430 = eax_346;
				if (edx_427 <= eax_346)
					esi_454 = ecx_347;
				else
				{
					word32 esi_1263;
					runtime.growslice(gs, 0x080CF320, ecx_347, edx_348, eax_346, edx_427, out esi_1263);
					ebp_430 = dwLoc84;
					esi_454 = dwLoc8C;
				}
				if (edx_427 > ebp_430)
					runtime.panicslice(gs);
				word32 esi_1265;
				word32 edi_1266;
				word32 ebp_1264;
				runtime.memmove(edx_348 + esi_454, dwLoc9C_1052, dwLoc98_1184, out ebp_1264, out esi_1265, out edi_1266);
				++edx_340;
				eax_264 = (word32) eax_264.u0 + 1;
				esi_163 = ebp_430;
				ebx_227 = edx_427;
				ebp_104 = esi_454;
			}
			Eq_4 eax_276;
			if (ecx_149 > 0x01)
			{
				eax_276 = ebx_227 + 0x01;
				if (eax_276 > esi_163)
				{
					word32 esi_1271;
					runtime.growslice(gs, 0x080CF320, ebp_104, ebx_227, esi_163, eax_276, out esi_1271);
					ebp_104 = dwLoc8C;
					eax_276 = (word32) dwLoc88 + 1;
				}
				Mem308[ebp_104 + ebx_227:byte] = 0x29;
			}
			else
				eax_276 = ebx_227;
			runtime.slicebytetostring(gs, 0x00, ebp_104, eax_276);
		}
	}
}

// 080AAA10: Register word128 reflect.funcLayout(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_114536 xmm1Out)
// Called from:
//      reflect.makeMethodValue
//      reflect.callMethod
word128 reflect.funcLayout(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_114536 & xmm1Out)
{
	byte bLoc0130_1003 = (byte) dwLoc0130;
	while (fp - 0xC4 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x13)
		runtime.gopanic(gs);
	else if (dwArg08 == 0x00 || ((word32) (*((word32) dwArg08 + 0x0F)) & 0x1F) != 0x14)
	{
		sync.(*Map).Load(gs, 0x08145200, 0x080D3500, fp - 0x7C);
		Eq_4 dwLoc0140_1000 = 0x080D3500;
		if ((byte) (word32) bLoc0130_1003 != 0x00)
		{
			fn0808FD8B(0x00, fp - 0x14);
			if (dwLoc0138 != 0x080D7D20)
				runtime.panicdottypeE(gs, dwLoc0138);
			else
			{
				fn0809026E(dwLoc0134, fp - 0x14);
				fn0809026E(fp - 0x14, fp - 0x50);
				xmm1Out = xmm1;
				return xmm0;
			}
		}
		else
		{
			word32 ecx_194;
			runtime.newobject(gs, 0x080D31A0);
			if (dwArg08 != 0x00)
			{
				byte dl_198 = (byte) (word32) *((word32) dwArg08 + 0x0F);
				if ((dl_198 & 0x20) == 0x00 || (dl_198 & 0x80) == 0x00)
				{
					if ((g_dw80D3500 & 0x07) == 0x00)
					{
						Eq_4 edx_211 = g_t80D3508;
						Eq_4 ebx_212 = g_t80D3504;
						Eq_4 ebp_213 = g_t80D350C;
						if ((word32) edx_211 + 1 > ebp_213)
						{
							word32 esi_1418;
							runtime.growslice(gs, 0x080CF320, ebx_212, edx_211, ebp_213, (word32) edx_211 + 1, out esi_1418);
							g_t80D350C = dwLoc0128;
							dwLoc0140_1000 = ebx_212;
							if (g_t81576F0 == 0x00)
								g_t80D3504 = dwLoc0130;
							else
							{
								runtime.writebarrierptr(0x080D3504, dwLoc0130);
								dwLoc0140_1000 = dwLoc0130;
							}
							edx_211 = dwLoc012C;
							ebx_212 = dwLoc0130;
						}
						g_t80D3508 = (word32) edx_211 + 1;
						Mem277[ebx_212 + edx_211:byte] = 0x00;
					}
					Eq_4 ebx_281 = g_t80D3504;
					uint32 ebp_282 = g_dw80D3500;
					if (ebp_282 >> 0x03 >= g_t80D3508)
						runtime.panicindex(gs);
					Mem302[ebx_281 + (ebp_282 >>u 0x03):byte] = SLICE(0x01 << SLICE(ebp_282 & 0x07, byte, 0) | (word32) Mem279[ebx_281 + (ebp_282 >>u 0x03):byte], byte, 0);
					++g_dw80D3500;
				}
				ecx_194 = 0x04;
			}
			else
				ecx_194 = 0x00;
			word32 ebx_323;
			if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
				ebx_323 = 0x34;
			else
				ebx_323 = 0x24;
			word32 * ebx_328 = (word32) dwArg04 + ebx_323;
			Eq_121013 ebp_337 = (word32) *((word32) dwArg04 + 32);
			struct Eq_121024 * eax_359 = (struct Eq_121024 *) 0x35000000;
			if (ebp_337 > 0x00100000)
				runtime.panicslice(gs);
			else
			{
				Eq_121013 esi_345 = 0x00;
				while (esi_345 < ebp_337)
				{
					struct Eq_121028 * edx_356 = *ebx_328;
					Eq_4 ecx_376 = ecx_194 + ((word32) ((byte) ((word32) edx_356->b000D - 0x01)) & -ecx_194);
					reflect.addTypeBits(gs, eax_359, ecx_376, edx_356);
					dwLoc0140_1000 = ecx_376;
					++ebx_328;
					esi_345 = (word32) esi_345.u0 + 1;
					ecx_194 = (word32) ecx_376 + edx_356->dw0000;
					eax_359 = (struct Eq_121024 *) &g_dw80D3500;
				}
				word32 esi_423;
				uint32 ebx_406 = eax_359->dw0000;
				ui32 ecx_410 = (-ecx_194 & 0x03) + ecx_194;
				if (((byte) (word32) *((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
					esi_423 = 0x34;
				else
					esi_423 = 0x24;
				word32 ebp_437 = (word32) *((word32) dwArg04 + 32);
				word32 esi_431 = (word32) dwArg04 + esi_423;
				uint32 edx_439 = (word32) (word16) ebp_437;
				uint32 ebp_442 = (word32) (word16) (ebp_437 + ((word32) (*((word32) dwArg04 + 0x0022)) & 0x7FFF));
				struct Eq_121024 * eax_489 = eax_359;
				if (edx_439 > ebp_442 || ebp_442 > 0x00100000)
					runtime.panicslice(gs);
				else
				{
					Eq_121086 ebp_453 = ebp_442 - edx_439;
					word32 * edx_473 = (edx_439 << 0x02 & -(-(edx_439 + 0xFFF00000)) >> 0x1F) + esi_431;
					Eq_121086 edi_475 = 0x00;
					while (edi_475 < ebp_453)
					{
						struct Eq_121028 * ebx_486 = *edx_473;
						Eq_4 ecx_506 = ecx_410 + ((word32) ((byte) ((word32) ebx_486->b000D - 0x01)) & -ecx_410);
						reflect.addTypeBits(gs, eax_489, ecx_506, ebx_486);
						dwLoc0140_1000 = ecx_506;
						++edx_473;
						edi_475 = (word32) edi_475.u0 + 1;
						ecx_410 = (word32) ecx_506 + ebx_486->dw0000;
						eax_489 = (struct Eq_121024 *) &g_dw80D3500;
					}
					Eq_4 dwLoc0140_1116;
					bool Z_606;
					runtime.newobject(gs, 135113664);
					*((word32) dwLoc0140_1000 + 0x0D) = 0x04;
					*dwLoc0140_1000 = (-ecx_410 & 0x03) + ecx_410;
					*((word32) dwLoc0140_1000 + 4) = g_dw80D3500 << 0x02;
					if (g_dw80D3500 > 0x00)
					{
						Eq_4 ebx_572 = g_t80D3504;
						if (g_t80D3508 <= 0x00)
							runtime.panicindex(gs);
						if (g_t81576F0 == 0x00)
						{
							*((word32) dwLoc0140_1000 + 20) = ebx_572;
							Z_606 = SLICE(cond(dwArg08), bool, 2);
							dwLoc0140_1116 = dwLoc0140_1000;
						}
						else
						{
							runtime.writebarrierptr(dwLoc0140_1000 + 0x14, ebx_572);
							dwLoc0140_1116 = ebx_572;
							Z_606 = SLICE(cond(dwArg08), bool, 2);
						}
					}
					else
					{
						*((word32) dwLoc0140_1000 + 0x0F) = (byte) ((word32) *((word32) dwLoc0140_1000 + 0x0F) | ~0x7F);
						Z_606 = SLICE(cond(dwArg08), bool, 2);
						dwLoc0140_1116 = dwLoc0140_1000;
					}
					Eq_4 eax_645;
					Eq_4 ecx_646;
					g_dw80D3500 = ebx_406;
					if (!Z_606)
					{
						reflect.(*rtype).String(gs, dwArg08);
						reflect.(*rtype).String(gs, dwArg04);
						runtime.concatstring5(gs, fp - 244);
						dwLoc0128 = dwLoc0140_1116;
						eax_645 = dwLoc0114;
						ecx_646 = dwLoc0118;
					}
					else
					{
						reflect.(*rtype).String(gs, dwArg04);
						runtime.concatstring3(gs, fp - 212);
						eax_645 = dwLoc0124;
						ecx_646 = dwLoc0128;
					}
					Eq_4 edi_720;
					Eq_4 esi_722;
					reflect.resolveReflectName(SLICE(reflect.newName(gs, ecx_646, eax_645, 0x00, 0x00, 0x00, 0x00, out esi_722, out edi_720), word24, 8), esi_722, edi_720, gs, dwLoc0128);
					*((word32) dwLoc0140_1000 + 24) = eax_645;
					runtime.newobject(gs, 0x080D73A0);
					runtime.newobject(gs, 0x080D1160);
					*eax_645 = 0x080AFC20;
					if (g_t81576F0 == 0x00)
						*((word32) eax_645 + 4) = dwLoc0140_1000;
					else
						runtime.writebarrierptr((word32) eax_645 + 4, dwLoc0140_1000);
					Eq_4 ebx_801 = g_t81576F0;
					if (ebx_801 == 0x00)
						*((word32) eax_645 + 8) = eax_645;
					else
						runtime.writebarrierptr((word32) eax_645 + 8, eax_645);
					fn0809026E(0x080F1E50, fp - 0x28);
					runtime.convT2E(ebx_801, gs, 0x080D3500, fp - 116);
					runtime.convT2E(fp - 0x28, gs, 0x080D7D20, fp - 0x28);
					Eq_114536 xmm1_906;
					word128 xmm0_905 = sync.(*Map).LoadOrStore(gs, 0x08145200, 0x00, 0x00, out xmm1_906);
					fn0808FD8B(0x00, fp - 0x3C);
					if (true)
						runtime.panicdottypeE(gs, 0x00);
					else
					{
						fn0809026E(0x00, fp - 0x3C);
						fn0809026E(fp - 0x3C, fp - 100);
						xmm1Out = xmm1_906;
						return xmm0_905;
					}
				}
			}
		}
	}
	else
	{
		reflect.(*rtype).String(gs, dwArg08);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x6C);
		runtime.gopanic(gs);
	}
}

// 080AB360: void reflect.addTypeBits(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_121024) dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_121028) dwArg0C)
// Called from:
//      reflect.funcLayout
//      reflect.addTypeBits
void reflect.addTypeBits(struct Eq_2 * gs, struct Eq_121024 * dwArg04, Eq_4 dwArg08, struct Eq_121028 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 edx_18 = (word32) dwArg0C->b000F;
	if (((byte) edx_18 & 0x80) != 0x00)
		return;
	if ((edx_18 & 0x1F) <= 0x14)
	{
		if ((edx_18 & 0x1F) == 0x11)
		{
			Eq_121369 ecx_102 = 0x00;
			while (ecx_102 < dwArg0C->t0028)
			{
				struct Eq_121028 * edx_86 = dwArg0C->ptr0020;
				reflect.addTypeBits(gs, dwArg04, (word32) dwArg08 + edx_86->dw0000 *s ecx_102, edx_86);
				ecx_102 = (word32) ecx_102.u0 + 1;
			}
			return;
		}
		if ((edx_18 & 0x1F) > 0x13)
		{
			if ((edx_18 & 0x1F) != 0x14)
				return;
			while (true)
			{
				uint32 edx_297 = dwArg04->dw0000;
				if (edx_297 >= dwArg08 >> 0x02)
					break;
				if ((edx_297 & 0x07) == 0x00)
				{
					Eq_4 edx_494 = dwArg04->t0004;
					Eq_4 ebx_495 = dwArg04->t0008;
					Eq_4 esi_496 = dwArg04->t000C;
					if ((word32) ebx_495 + 1 > esi_496)
					{
						word32 esi_790;
						runtime.growslice(gs, 0x080CF320, edx_494, ebx_495, esi_496, (word32) ebx_495 + 1, out esi_790);
						dwArg04->t000C = dwLoc28;
						if (g_t81576F0 == 0x00)
							dwArg04->t0004 = dwLoc30;
						else
							runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
						ebx_495 = dwLoc2C;
						edx_494 = dwLoc30;
					}
					dwArg04->t0008 = (word32) ebx_495 + 1;
					Mem559[edx_494 + ebx_495:byte] = 0x00;
				}
				uint32 ebx_563 = dwArg04->dw0000;
				if (ebx_563 >> 0x03 >= dwArg04->t0008)
					runtime.panicindex(gs);
				dwArg04->dw0000 = ebx_563 + 0x01;
			}
			if ((edx_297 & 0x07) == 0x00)
			{
				Eq_4 edx_306 = dwArg04->t0004;
				Eq_4 ebx_307 = dwArg04->t0008;
				Eq_4 ebp_308 = dwArg04->t000C;
				if ((word32) ebx_307 + 1 > ebp_308)
				{
					word32 esi_791;
					runtime.growslice(gs, 0x080CF320, edx_306, ebx_307, ebp_308, (word32) ebx_307 + 1, out esi_791);
					dwArg04->t000C = dwLoc28;
					if (g_t81576F0 == 0x00)
						dwArg04->t0004 = dwLoc30;
					else
						runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
					ebx_307 = dwLoc2C;
					edx_306 = dwLoc30;
				}
				dwArg04->t0008 = (word32) ebx_307 + 1;
				Mem370[edx_306 + ebx_307:byte] = 0x00;
			}
			Eq_4 ebx_374 = dwArg04->t0004;
			uint32 ecx_376 = dwArg04->dw0000;
			if (ecx_376 >> 0x03 >= dwArg04->t0008)
				runtime.panicindex(gs);
			else
			{
				Mem396[ebx_374 + (ecx_376 >>u 0x03):byte] = SLICE((word32) Mem386[ebx_374 + (ecx_376 >>u 0x03):byte] | 0x01 << SLICE(ecx_376 & 0x07, byte, 0), byte, 0);
				uint32 edx_397 = dwArg04->dw0000;
				dwArg04->dw0000 = edx_397 + 0x01;
				if ((edx_397 + 0x01 & 0x07) == 0x00)
				{
					Eq_4 edx_403 = dwArg04->t000C;
					Eq_4 ebx_404 = dwArg04->t0008;
					Eq_4 ebp_405 = dwArg04->t0004;
					if ((word32) ebx_404 + 1 > edx_403)
					{
						word32 esi_792;
						runtime.growslice(gs, 0x080CF320, ebp_405, ebx_404, edx_403, (word32) ebx_404 + 1, out esi_792);
						dwArg04->t000C = dwLoc28;
						if (g_t81576F0 == 0x00)
							dwArg04->t0004 = dwLoc30;
						else
							runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
						ebp_405 = dwLoc30;
						ebx_404 = dwLoc2C;
					}
					dwArg04->t0008 = (word32) ebx_404 + 1;
					Mem463[ebp_405 + ebx_404:byte] = 0x00;
				}
				Eq_4 ebx_467 = dwArg04->t0004;
				uint32 ecx_468 = dwArg04->dw0000;
				if (ecx_468 >> 0x03 >= dwArg04->t0008)
					runtime.panicindex(gs);
				else
				{
					Mem486[ebx_467 + (ecx_468 >>u 0x03):byte] = SLICE((word32) Mem465[ebx_467 + (ecx_468 >>u 0x03):byte] | 0x01 << SLICE(ecx_468 & 0x07, byte, 0), byte, 0);
					++dwArg04->dw0000;
					return;
				}
			}
		}
	}
	else if ((edx_18 & 0x1F) > 0x18)
	{
		if ((edx_18 & 0x1F) == 0x19)
		{
			Eq_121369 ecx_33 = dwArg0C->t0028;
			Eq_121369 edx_35 = 0x00;
			while (edx_35 < ecx_33)
			{
				struct Eq_121809 * ebp_45 = dwArg0C->ptr0024;
				if (edx_35 >= dwArg0C->t0028)
					runtime.panicindex(gs);
				ui32 eax_50 = edx_35 * 0x03;
				reflect.addTypeBits(gs, dwArg04, (word32) dwArg08 + ((ebp_45->a0008)[eax_50] >> 0x01), ebp_45->a0004[eax_50].ptr0000.dw0000);
				edx_35 = (word32) edx_35 + 1;
			}
			return;
		}
		if ((edx_18 & 0x1F) != 0x1A)
			return;
	}
	while (true)
	{
		uint32 edx_110 = dwArg04->dw0000;
		if (edx_110 >= dwArg08 >> 0x02)
			break;
		if ((edx_110 & 0x07) == 0x00)
		{
			Eq_4 edx_213 = dwArg04->t0004;
			Eq_4 ebx_214 = dwArg04->t0008;
			Eq_4 esi_215 = dwArg04->t000C;
			if ((word32) ebx_214 + 1 > esi_215)
			{
				word32 esi_788;
				runtime.growslice(gs, 0x080CF320, edx_213, ebx_214, esi_215, (word32) ebx_214 + 1, out esi_788);
				dwArg04->t000C = dwLoc28;
				if (g_t81576F0 == 0x00)
					dwArg04->t0004 = dwLoc30;
				else
					runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
				ebx_214 = dwLoc2C;
				edx_213 = dwLoc30;
			}
			dwArg04->t0008 = (word32) ebx_214 + 1;
			Mem278[edx_213 + ebx_214:byte] = 0x00;
		}
		uint32 ebx_282 = dwArg04->dw0000;
		if (ebx_282 >> 0x03 >= dwArg04->t0008)
			runtime.panicindex(gs);
		dwArg04->dw0000 = ebx_282 + 0x01;
	}
	if ((edx_110 & 0x07) == 0x00)
	{
		Eq_4 edx_119 = dwArg04->t0008;
		Eq_4 ebx_120 = dwArg04->t000C;
		Eq_4 ebp_121 = dwArg04->t0004;
		if ((word32) edx_119 + 1 > ebx_120)
		{
			word32 esi_789;
			runtime.growslice(gs, 0x080CF320, ebp_121, edx_119, ebx_120, (word32) edx_119 + 1, out esi_789);
			dwArg04->t000C = dwLoc28;
			if (g_t81576F0 == 0x00)
				dwArg04->t0004 = dwLoc30;
			else
				runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
			edx_119 = dwLoc2C;
			ebp_121 = dwLoc30;
		}
		dwArg04->t0008 = (word32) edx_119 + 1;
		Mem182[ebp_121 + edx_119:byte] = 0x00;
	}
	Eq_4 ebx_186 = dwArg04->t0004;
	uint32 ecx_187 = dwArg04->dw0000;
	if (ecx_187 >> 0x03 >= dwArg04->t0008)
		runtime.panicindex(gs);
	else
	{
		Mem205[ebx_186 + (ecx_187 >>u 0x03):byte] = SLICE((word32) Mem184[ebx_186 + (ecx_187 >>u 0x03):byte] | 0x01 << SLICE(ecx_187 & 0x07, byte, 0), byte, 0);
		++dwArg04->dw0000;
	}
}

// 080AB8B0: void reflect.Value.pointer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.Value.Len
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.Value.Pointer
void reflect.Value.pointer(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg04 != 0x04 || ((byte) ((word32) (*((word32) dwArg04 + 0x0F))) & 0x80) != 0x00)
		runtime.gopanic(gs);
	else if ((dwArg0C & 0x80) == 0x00)
		;
}

// 080AB920: void reflect.packEface(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.valueInterface
void reflect.packEface(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x20) != 0x00)
		return;
	if ((dwArg0C & 0x80) == 0x00)
		runtime.gopanic(gs);
	else if ((dwArg0C & 0x0100) != 0x00)
	{
		reflect.unsafe_New(gs, dwArg04);
		reflect.typedmemmove(gs, dwArg04, dwLoc14, dwArg08);
	}
}

// 080ABA00: void reflect.(*ValueError).Error(Register Eq_4 ebx, Register word32 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_121924) dwArg04)
void reflect.(*ValueError).Error(Eq_4 ebx, word32 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, struct Eq_121924 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_101636 ecx_18 = dwArg04->t0008;
	if (ecx_18 != 0x00)
	{
		reflect.Kind.String(ebx, ebp, esi, gs, ecx_18);
		runtime.concatstring5(gs, 0x00);
	}
	else
		runtime.concatstring3(gs, 0x00);
}

// 080ABB00: void reflect.methodName(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
void reflect.methodName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.Caller(gs);
	runtime.FuncForPC(gs, dwLoc14);
	if (dwLoc14 == 0x00)
		return;
	runtime.(*Func).Name(gs, dwLoc14);
}

// 080ABB70: void reflect.flag.mustBe(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg08)
// Called from:
//      reflect.Value.Bool
//      reflect.Value.Bytes
//      reflect.Value.runes
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.Value.NumField
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.SetString
void reflect.flag.mustBe(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg04 & 0x1F) == dwArg08)
		return;
	reflect.methodName(gs);
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc14 + 4) = dwLoc14;
	if (g_t81576F0 == 0x00)
		*dwLoc14 = dwLoc18;
	else
		runtime.writebarrierptr(dwLoc14, dwLoc18);
	*((word32) dwLoc14 + 8) = dwArg04 & 0x1F;
	runtime.gopanic(gs);
}

// 080ABC20: void reflect.flag.mustBeAssignable(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.SetString
void reflect.flag.mustBeAssignable(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
	{
		reflect.methodName(gs);
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc3C + 4) = dwLoc3C;
		if (g_t81576F0 == 0x00)
			*dwLoc3C = dwLoc40;
		else
			runtime.writebarrierptr(dwLoc3C, dwLoc40);
		((word32) dwLoc3C + 8)->u0 = 0x00;
		runtime.gopanic(gs);
	}
	else if ((dwArg04 & 0x60) != 0x00)
	{
		reflect.methodName(gs);
		runtime.concatstring3(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x08);
		runtime.gopanic(gs);
	}
	else
	{
		if ((dwArg04 & 0x0100) != 0x00)
			return;
		reflect.methodName(gs);
		runtime.concatstring3(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x10);
		runtime.gopanic(gs);
	}
}

// 080ABDE0: void reflect.Value.Bool(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.Bool(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBe(gs, dwArg0C, 0x01);
}

// 080ABE20: void reflect.Value.Bytes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtBytesString
//      fmt.(*pp).printValue
void reflect.Value.Bytes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBe(gs, dwArg0C, 0x17);
	reflect.(*rtype).Elem(gs, dwArg04);
	<anonymous> * eax_39 = *(<anonymous> **) 0x6B;
	eax_39();
	if (false)
		return;
	runtime.gopanic(gs);
}

// 080ABEB0: void reflect.Value.runes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtRunesString
void reflect.Value.runes(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBe(gs, dwArg0C, 0x17);
	reflect.(*rtype).Elem(gs, dwArg04);
	<anonymous> * eax_39 = *(<anonymous> **) 0x6B;
	eax_39();
	if (false)
		return;
	runtime.gopanic(gs);
}

// 080ABF40: void reflect.methodReceiver(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg18)
// Called from:
//      reflect.makeMethodValue
//      reflect.callMethod
void reflect.methodReceiver(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg0C + 0x0F) & 0x1F) != 0x14)
	{
		reflect.(*rtype).uncommon(gs, dwArg0C);
		if (dwLoc50 != null)
		{
			word16 cx_35 = (word16) (word32) dwLoc50->w0004;
			if (dwArg18 < (word32) cx_35)
			{
				Eq_141669 eax_59[] = dwLoc50 + dwLoc50->dw0008 / 0x0C;
				Eq_4 ecx_62 = (word32) cx_35;
				if (ecx_62 > 0x00010000)
					runtime.panicslice(gs);
				else if (dwArg18 >= ecx_62)
					runtime.panicindex(gs);
				else
				{
					Eq_4 edx_71 = eax_59[dwArg18].t0008;
					Eq_4 eax_73 = eax_59[dwArg18].t0000;
					reflect.(*rtype).nameOff(gs, dwArg0C, eax_73);
					if (((byte) (word32) *dwLoc4C & 0x01) == 0x00)
					{
						runtime.concatstring3(gs, 0x00);
						runtime.convT2Estring(gs, 135066016, fp - 0x18);
						runtime.gopanic(gs);
					}
					else
					{
						runtime.newobject(gs, 0x080CF3A0);
						reflect.(*rtype).textOff(gs, dwArg0C, edx_71);
						if (g_t81576F0 == 0x00)
							*eax_73 = dwLoc4C;
						else
							runtime.writebarrierptr(eax_73, dwLoc4C);
						reflect.(*rtype).typeOff(gs);
						return;
					}
				}
			}
		}
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 ecx_206 = *((word32) dwArg0C + 36);
		if (dwArg18 >= *((word32) dwArg0C + 40))
			runtime.gopanic(gs);
		else
		{
			reflect.(*rtype).nameOff(gs, dwArg0C, *((word32) ecx_206 + dwArg18 * 0x08));
			if (((byte) (word32) *dwLoc4C & 0x01) == 0x00)
			{
				runtime.concatstring3(gs, 0x00);
				runtime.convT2Estring(gs, 135066016, fp - 0x08);
				runtime.gopanic(gs);
			}
			else if (*dwArg10 == 0x00)
			{
				runtime.concatstring3(gs, 0x00);
				runtime.convT2Estring(gs, 135066016, fp - 0x10);
				runtime.gopanic(gs);
			}
			else if (dwArg18 >= 100000)
				runtime.panicindex(gs);
			else
				reflect.(*rtype).typeOff(gs);
		}
	}
}

// 080AC2C0: void reflect.callMethod(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_122319) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.methodValueCall
void reflect.callMethod(struct Eq_2 * gs, struct Eq_122319 * dwArg04, Eq_4 dwArg08)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x48;
	Eq_4 ecx_28 = dwArg04->t000C;
	int32 edx_30 = dwArg04->dw0014;
	Eq_4 ebx_32 = dwArg04->t0010;
	reflect.methodReceiver(gs, ecx_28, ebx_32, dwArg04->t0008);
	word128 xmm1_410;
	reflect.funcLayout(gs, dwLoc2C, dwLoc30, out xmm1_410);
	sync.(*Pool).Get(gs, dwLoc30);
	if (dwLoc30 != 0x080CF3A0)
		runtime.panicdottypeE(gs, dwLoc30);
	else
	{
		ui32 eax_108 = (word32) *((word32) ecx_28 + 0x0F);
		byte bl_117 = (byte) eax_108;
		if ((eax_108 & 0x1F) == 0x14)
		{
			Eq_4 ebx_170 = *((word32) ebx_32 + 4);
			if (g_t81576F0 == 0x00)
				*ecx_28 = ebx_170;
			else
				runtime.writebarrierptr(ecx_28, ebx_170);
		}
		else if ((edx_30 & 0x80) != 0x00 && (bl_117 & 0x20) != 0x00)
		{
			Eq_4 ebx_125 = *ebx_32;
			if (g_t81576F0 == 0x00)
				*ecx_28 = ebx_125;
			else
				runtime.writebarrierptr(ecx_28, ebx_125);
		}
		else if (g_t81576F0 == 0x00)
			*ecx_28 = ebx_32;
		else
			runtime.writebarrierptr(ecx_28, ebx_32);
		if (ebx_32 > ~0x03)
			reflect.typedmemmovepartial(gs, ecx_28, (word32) ecx_28 + 4, dwArg08, 0x04, (word32) ebx_32 - 4);
		reflect.call(*ecx_28);
		Eq_4 ecx_241 = *ecx_28 - edx_30;
		if (ecx_241 > 0x00)
			reflect.typedmemmovepartial(gs, ecx_28, dwArg08 - 0x04 + edx_30, (word32) ecx_28 + edx_30, edx_30, ecx_241);
		reflect.memclrNoHeapPointers(gs, ecx_28, *ecx_28);
		sync.(*Pool).Put(gs, dwLoc30, 0x080CF3A0, ecx_28);
	}
}

// 080AC560: void reflect.Value.Complex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtComplex
//      fmt.(*pp).printValue
void reflect.Value.Complex(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) == 0x0F)
		return;
	if ((dwArg0C & 0x1F) == 0x10)
		return;
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x15;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 0x080E33DE;
	else
		runtime.writebarrierptr(dwLoc0C, 0x080E33DE);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AC640: void reflect.Value.Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.makeString
//      reflect.makeBytes
//      reflect.makeRunes
//      reflect.cvtI2I
//      fmt.getField
//      fmt.(*pp).printValue
void reflect.Value.Elem(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) == 0x14)
	{
		Eq_4 eax_54;
		word128 xmm1_309;
		reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_309);
		if (dwLoc14 == 0x00)
			eax_54 = *dwArg08;
		else
		{
			Eq_4 ecx_44 = *dwArg08;
			if (ecx_44 != 0x00)
				ecx_44 = *((word32) ecx_44 + 4);
			eax_54 = ecx_44;
		}
		ui32 edx_68;
		if (eax_54 != 0x00)
		{
			ui32 edx_73 = (word32) *((word32) eax_54 + 0x0F);
			edx_68 = edx_73 & 0x1F;
			if (((byte) edx_73 & 0x20) == 0x00)
				edx_68 = edx_73 & 0x1F | 0x80;
		}
		else
			edx_68 = 0x00;
	}
	else if ((dwArg0C & 0x1F) != 22)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc14 + 4) = 0x12;
		if (g_t81576F0 == 0x00)
			*dwLoc14 = 135146116;
		else
			runtime.writebarrierptr(dwLoc14, 135146116);
		*((word32) dwLoc14 + 8) = dwArg0C & 0x1F;
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 eax_161;
		if ((dwArg0C & 0x80) != 0x00)
			eax_161 = *dwArg08;
		else
			eax_161 = dwArg08;
		if (eax_161 == 0x00)
			;
	}
}

// 080AC7C0: void reflect.Value.Field(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.getField
void reflect.Value.Field(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) != 0x19)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc0C + 4) = 0x13;
		if (g_t81576F0 == 0x00)
			*dwLoc0C = 0x080E2DAC;
		else
			runtime.writebarrierptr(dwLoc0C, 0x080E2DAC);
		*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 eax_75 = *((word32) dwArg04 + 36);
		if (dwArg10 >= *((word32) dwArg04 + 40))
			runtime.gopanic(gs);
		else if (((byte) (word32) **((word32) eax_75 + dwArg10 * 0x0C) & 0x01) == 0x00)
			(*((word32) eax_75 + (dwArg10 * 0x0C + 8)) & 0x01) == 0x00;
	}
}

// 080AC8E0: void reflect.Value.Float(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtFloatInt
//      reflect.cvtFloatUint
//      reflect.cvtFloat
//      fmt.(*pp).printValue
void reflect.Value.Float(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) == 0x0D)
		return;
	if ((dwArg0C & 0x1F) == 0x0E)
		return;
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x13;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 135146943;
	else
		runtime.writebarrierptr(dwLoc0C, 135146943);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AC9B0: void reflect.Value.Index(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.Index(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) != 0x11)
	{
		if ((dwArg0C & 0x1F) != 0x17)
		{
			if ((dwArg0C & 0x1F) != 0x18)
			{
				runtime.newobject(gs, 0x080D3140);
				*((word32) dwLoc0C + 4) = 0x13;
				if (g_t81576F0 == 0x00)
					*dwLoc0C = 0x080E2DD2;
				else
					runtime.writebarrierptr(dwLoc0C, 0x080E2DD2);
				*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
				runtime.gopanic(gs);
			}
			else
			{
				if (dwArg10 < *((word32) dwArg08 + 4))
					return;
				runtime.gopanic(gs);
			}
		}
		else
		{
			if (dwArg10 < *((word32) dwArg08 + 4))
				return;
			runtime.gopanic(gs);
		}
	}
	else
	{
		if (dwArg10 < *((word32) dwArg04 + 40))
			return;
		runtime.gopanic(gs);
	}
}

// 080ACB60: void reflect.Value.Int(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtInt
//      reflect.cvtIntFloat
//      reflect.cvtIntString
//      fmt.(*pp).printValue
void reflect.Value.Int(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x03)
	{
		if ((dwArg0C & 0x1F) == 0x02)
			return;
		if ((dwArg0C & 0x1F) == 0x03)
			return;
	}
	else
	{
		if ((dwArg0C & 0x1F) == 0x04)
			return;
		if ((dwArg0C & 0x1F) == 0x05)
			return;
		if ((dwArg0C & 0x1F) == 0x06)
			return;
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x11;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 0x080E2873;
	else
		runtime.writebarrierptr(dwLoc0C, 0x080E2873);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080ACC80: void reflect.Value.CanInterface(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void reflect.Value.CanInterface(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C != 0x00)
		return;
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc08 + 4) = 0x1A;
	if (g_t81576F0 == 0x00)
		*dwLoc08 = 0x080E4230;
	else
		runtime.writebarrierptr(dwLoc08, 0x080E4230);
	((word32) dwLoc08 + 8)->u0 = 0x00;
	runtime.gopanic(gs);
}

// 080ACD20: Register word128 reflect.Value.Interface(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_122915 xmm1Out)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
word128 reflect.Value.Interface(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_122915 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_122915 xmm1_34;
	word128 xmm0_33 = reflect.valueInterface(gs, dwArg04, dwArg08, dwArg0C, 0x01, out xmm1_34);
	xmm1Out = xmm1_34;
	return xmm0_33;
}

// 080ACD80: Register word128 reflect.valueInterface(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10, Register out Eq_122937 xmm1Out)
// Called from:
//      reflect.Value.Interface
//      reflect.Value.assignTo
//      reflect.cvtT2I
word128 reflect.valueInterface(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10, union Eq_122937 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_125 = dwArg0C;
	if (dwArg0C == 0x00)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc20 + 4) = 0x17;
		if (g_t81576F0 == 0x00)
			*dwLoc20 = 135150133;
		else
			runtime.writebarrierptr(dwLoc20, 135150133);
		((word32) dwLoc20 + 8)->u0 = 0x00;
		runtime.gopanic(gs);
	}
	else if ((byte) (word32) bArg10 == 0x00 || (dwArg0C & 0x60) == 0x00)
	{
		Eq_4 ecx_124;
		Eq_4 edx_123;
		if ((dwArg0C & 0x0200) == 0x00)
		{
			ecx_124 = dwArg08;
			edx_123 = dwArg04;
		}
		else
		{
			dwLoc18 = dwArg08;
			xmm0 = reflect.makeMethodValue(gs, dwArg04, dwArg08, dwArg0C, out xmm1);
			edx_123 = dwLoc10;
			ecx_124 = dwLoc0C;
			eax_125 = dwLoc08;
		}
		if ((eax_125 & 0x1F) != 0x14)
		{
			reflect.packEface(gs, edx_123, ecx_124, eax_125);
			xmm1Out = xmm1;
			return xmm0;
		}
		else
		{
			Eq_122937 xmm1_172;
			word128 xmm0_171 = reflect.Value.NumMethod(gs, edx_123, eax_125, out xmm1_172);
			if (dwLoc18 == 0x00)
			{
				xmm1Out = xmm1_172;
				return xmm0_171;
			}
			else
			{
				*ecx_124 == 0x00;
				xmm1Out = xmm1_172;
				return xmm0_171;
			}
		}
	}
	else
		runtime.gopanic(gs);
}

// 080ACF10: void reflect.Value.IsNil(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtI2I
//      fmt.getField
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printValue
void reflect.Value.IsNil(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x14)
	{
		if ((dwArg0C & 0x1F) <= 0x13 && (dwArg0C & 0x1F) >= 0x12)
		{
l080ACF47:
			if ((dwArg0C & 0x0200) != 0x00)
				return;
			return;
		}
		if ((dwArg0C & 0x1F) == 0x14)
			return;
	}
	else
	{
		if ((dwArg0C & 0x1F) <= 22)
			goto l080ACF47;
		if ((dwArg0C & 0x1F) == 0x17)
			return;
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x13;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 0x080E2DE5;
	else
		runtime.writebarrierptr(dwLoc0C, 0x080E2DE5);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AD020: void reflect.Value.Kind(Register (ptr32 Eq_123098) gs)
void reflect.Value.Kind(struct Eq_123098 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080AD050: void reflect.Value.Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*Value).Len
//      fmt.(*pp).printValue
void reflect.Value.Len(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x12)
	{
		if ((dwArg0C & 0x1F) == 0x11)
			return;
		if ((dwArg0C & 0x1F) == 0x12)
		{
			reflect.Value.pointer(gs, dwArg04, dwArg0C);
			reflect.chanlen(gs, dwLoc0C);
			return;
		}
	}
	else
	{
		if ((dwArg0C & 0x1F) == 0x15)
		{
			reflect.Value.pointer(gs, dwArg04, dwArg0C);
			reflect.maplen(gs, dwLoc0C);
			return;
		}
		if ((dwArg0C & 0x1F) == 0x17)
			return;
		if ((dwArg0C & 0x1F) == 0x18)
			return;
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc14 + 4) = 0x11;
	if (g_t81576F0 == 0x00)
		*dwLoc14 = 0x080E2884;
	else
		runtime.writebarrierptr(dwLoc14, 0x080E2884);
	*((word32) dwLoc14 + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AD1A0: void reflect.Value.MapIndex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.MapIndex(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 eax_65;
	reflect.flag.mustBe(gs, dwArg0C, 0x15);
	reflect.Value.assignTo(gs, dwArg10, dwArg14, dwArg18, *((word32) dwArg04 + 32), 0x00);
	if ((dwLoc18 & 0x80) != 0x00)
		eax_65 = dwLoc1C;
	else
		eax_65 = (word32) fp + 20;
	reflect.Value.pointer(gs, dwArg04, dwArg0C);
	reflect.mapaccess(gs, dwArg04, 135149181, eax_65);
	if (135149181 == 0x00)
		return;
	Eq_4 ecx_110 = *((word32) dwArg04 + 36);
	if (((byte) (word32) *((word32) ecx_110 + 0x0F) & 0x20) != 0x00)
		return;
	reflect.unsafe_New(gs, ecx_110);
	reflect.typedmemmove(gs, ecx_110, 135149181, 135149181);
}

// 080AD340: void reflect.Value.MapKeys(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.MapKeys(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_65;
	reflect.flag.mustBe(gs, dwArg0C, 0x15);
	Eq_4 ecx_29 = *((word32) dwArg04 + 32);
	byte dl_32 = (byte) (word32) *((word32) ecx_29 + 0x0F);
	reflect.Value.pointer(gs, dwArg04, dwArg0C);
	Eq_4 eax_50 = dwArg0C & 0x60 | (word32) dl_32 & 0x1F;
	if (dwLoc44 == 0x00)
		edx_65.u0 = 0x00;
	else
	{
		reflect.maplen(gs, dwLoc44);
		edx_65 = dwArg08;
	}
	reflect.mapiterinit(gs, dwArg04, dwLoc44);
	word32 edi_390;
	runtime.makeslice(gs, 0x080E08C0, edx_65, edx_65, out edi_390);
	Eq_4 dwLoc4C_323 = edx_65;
	Eq_123298 ebx_114 = 0x00;
	while (ebx_114 < dwLoc40)
	{
		reflect.mapiterkey(gs);
		if (dwLoc4C_323 == 0x00)
			break;
		if (((byte) (word32) *((word32) ecx_29 + 0x0F) & 0x20) != 0x00)
		{
			Eq_4 eax_231 = *dwLoc4C_323;
			if (ebx_114 >= dwLoc40)
				runtime.panicindex(gs);
			*((word32) dwLoc44 + (ebx_114 * 0x0C + 8)) = eax_50;
			Eq_4 ebx_241 = (word32) dwLoc44 + ebx_114 * 0x0C;
			Eq_4 edx_242 = (word32) dwLoc44 + 4 + ebx_114 * 0x0C;
			if (g_t81576F0 == 0x00)
			{
				*((word32) dwLoc44 + ebx_114 * 0x0C) = ecx_29;
				*((word32) dwLoc44 + (ebx_114 * 0x0C + 4)) = eax_231;
			}
			else
			{
				runtime.writebarrierptr(ebx_241, ecx_29);
				runtime.writebarrierptr(edx_242, eax_231);
				dwLoc4C_323 = eax_231;
			}
		}
		else
		{
			reflect.unsafe_New(gs, ecx_29);
			reflect.typedmemmove(gs, ecx_29, dwLoc4C_323, dwLoc4C_323);
			if (ebx_114 >= dwLoc40)
				runtime.panicindex(gs);
			*((word32) dwLoc44 + (ebx_114 * 0x0C + 8)) = eax_50 | 0x80;
			Eq_4 edi_194 = (word32) dwLoc44 + ebx_114 * 0x0C;
			Eq_4 ebp_195 = (word32) dwLoc44 + 4 + ebx_114 * 0x0C;
			if (g_t81576F0 == 0x00)
			{
				*((word32) dwLoc44 + ebx_114 * 0x0C) = ecx_29;
				*((word32) dwLoc44 + (ebx_114 * 0x0C + 4)) = dwLoc4C_323;
			}
			else
			{
				runtime.writebarrierptr(edi_194, ecx_29);
				runtime.writebarrierptr(ebp_195, dwLoc4C_323);
			}
		}
		reflect.mapiternext(gs, dwArg0C);
		ebx_114 = (word32) ebx_114 + 1;
	}
	if (ebx_114 <= dwLoc3C)
		return;
	runtime.panicslice(gs);
}

// 080AD5E0: Register word128 reflect.Value.NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Register out Eq_123004 xmm1Out)
// Called from:
//      reflect.valueInterface
//      reflect.(*Value).NumMethod
word128 reflect.Value.NumMethod(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C, union Eq_123004 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc08 + 4) = 0x17;
		if (g_t81576F0 == 0x00)
			*dwLoc08 = 135150156;
		else
			runtime.writebarrierptr(dwLoc08, 135150156);
		((word32) dwLoc08 + 8)->u0 = 0x00;
		runtime.gopanic(gs);
	}
	else if ((dwArg0C & 0x0200) == 0x00)
	{
		Eq_123004 xmm1_84;
		word128 xmm0_83 = reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_84);
		xmm1Out = xmm1_84;
		return xmm0_83;
	}
	else
	{
		xmm1Out = xmm1;
		return xmm0;
	}
}

// 080AD6A0: void reflect.Value.NumField(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*Value).NumField
//      fmt.(*pp).printValue
void reflect.Value.NumField(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBe(gs, dwArg0C, 0x19);
}

// 080AD6E0: void reflect.Value.Pointer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printValue
void reflect.Value.Pointer(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x13)
	{
		if ((dwArg0C & 0x1F) == 0x12)
			goto l080AD714;
		if ((dwArg0C & 0x1F) == 0x13)
		{
			if ((dwArg0C & 0x0200) != 0x00)
				return;
			reflect.Value.pointer(gs, dwArg04, dwArg0C);
			return;
		}
	}
	else
	{
		if ((dwArg0C & 0x1F) <= 22)
			goto l080AD714;
		if ((dwArg0C & 0x1F) == 0x17)
			return;
		if ((dwArg0C & 0x1F) == 0x1A)
		{
l080AD714:
			reflect.Value.pointer(gs, dwArg04, dwArg0C);
			return;
		}
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc18 + 4) = 0x15;
	if (g_t81576F0 == 0x00)
		*dwLoc18 = 0x080E33F3;
	else
		runtime.writebarrierptr(dwLoc18, 0x080E33F3);
	*((word32) dwLoc18 + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AD830: void reflect.Value.SetBytes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      reflect.makeBytes
void reflect.Value.SetBytes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBeAssignable(gs, dwArg0C);
	reflect.flag.mustBe(gs, dwArg0C, 0x17);
	reflect.(*rtype).Elem(gs, dwArg04);
	<anonymous> * eax_48 = *(<anonymous> **) 0x6B;
	eax_48();
	if (true)
		runtime.gopanic(gs);
	else
	{
		*((word32) dwArg08 + 4) = dwArg14;
		*((word32) dwArg08 + 8) = dwArg18;
		if (g_t81576F0 == 0x00)
			*dwArg08 = dwArg10;
		else
			runtime.writebarrierptr(dwArg08, dwArg10);
	}
}

// 080AD8F0: void reflect.Value.setRunes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      reflect.makeRunes
void reflect.Value.setRunes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBeAssignable(gs, dwArg0C);
	reflect.flag.mustBe(gs, dwArg0C, 0x17);
	reflect.(*rtype).Elem(gs, dwArg04);
	<anonymous> * eax_48 = *(<anonymous> **) 0x6B;
	eax_48();
	if (true)
		runtime.gopanic(gs);
	else
	{
		*((word32) dwArg08 + 4) = dwArg14;
		*((word32) dwArg08 + 8) = dwArg18;
		if (g_t81576F0 == 0x00)
			*dwArg08 = dwArg10;
		else
			runtime.writebarrierptr(dwArg08, dwArg10);
	}
}

// 080AD9B0: void reflect.Value.SetString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack int32 dwArg14)
// Called from:
//      reflect.makeString
void reflect.Value.SetString(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, int32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBeAssignable(gs, dwArg0C);
	reflect.flag.mustBe(gs, dwArg0C, 0x18);
	*((word32) dwArg08 + 4) = dwArg14;
	if (g_t81576F0 == 0x00)
		*dwArg08 = dwArg10;
	else
		runtime.writebarrierptr(dwArg08, dwArg10);
}

// 080ADA20: void reflect.Value.Slice(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.Slice(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_153;
	Eq_4 ebx_151;
	Eq_4 edx_152;
	if ((dwArg0C & 0x1F) == 0x11)
	{
		if ((dwArg0C & 0x0100) == 0x00)
			runtime.gopanic(gs);
		edx_152 = *((word32) dwArg04 + 40);
		eax_153 = *((word32) dwArg04 + 36);
		ebx_151 = dwArg08;
	}
	else
	{
		if ((dwArg0C & 0x1F) != 0x17)
		{
			if ((dwArg0C & 0x1F) != 0x18)
			{
				runtime.newobject(gs, 0x080D3140);
				*((word32) dwLoc20 + 4) = 0x13;
				if (g_t81576F0 == 0x00)
					dwLoc20->u0 = 0x080E2DF8;
				else
					runtime.writebarrierptr(dwLoc20, 0x080E2DF8);
				*((word32) dwLoc20 + 8) = dwArg0C & 0x1F;
				runtime.gopanic(gs);
			}
			else if (dwArg10 < 0x00 || (dwArg14 < dwArg10 || dwArg14 > *((word32) dwArg08 + 4)))
				runtime.gopanic(gs);
			else
			{
				runtime.newobject(gs, 0x080D3620);
				word32 eax_121 = Mem107[dwArg08 + 0x00:word32] + dwArg10;
				*((word32) dwLoc20 + 4) = dwArg14 - dwArg10;
				if (g_t81576F0 == 0x00)
					*dwLoc20 = eax_121;
				else
					runtime.writebarrierptr(dwLoc20, eax_121);
				return;
			}
		}
		ebx_151 = *dwArg08;
		edx_152 = *((word32) dwArg08 + 8);
		eax_153 = dwArg04;
	}
	if (dwArg10 < 0x00 || (dwArg14 < dwArg10 || dwArg14 > edx_152))
		runtime.gopanic(gs);
	else
	{
		runtime.newobject(gs, 0x080CA300);
		*((word32) dwLoc20 + 4) = dwArg14 - dwArg10;
		Eq_4 ecx_229 = edx_152 - dwArg10;
		*((word32) dwLoc20 + 8) = ecx_229;
		if (ecx_229 > 0x00)
		{
			Eq_4 edx_260 = (word32) ebx_151 + dwArg10 *s *(*((word32) eax_153 + 32));
			if (g_t81576F0 == 0x00)
				*dwLoc20 = edx_260;
			else
				runtime.writebarrierptr(dwLoc20, edx_260);
		}
		else if (g_t81576F0 == 0x00)
			*dwLoc20 = ebx_151;
		else
			runtime.writebarrierptr(dwLoc20, ebx_151);
	}
}

// 080ADCB0: Register word32 reflect.Value.String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtStringBytes
//      reflect.cvtStringRunes
//      reflect.(*Value).String
//      fmt.(*pp).printValue
word32 reflect.Value.String(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) == 0x00)
		return ebx;
	if ((dwArg0C & 0x1F) == 0x18)
		return ebx;
	reflect.Value.Type(gs, dwArg04, dwArg0C);
	<anonymous> * ecx_45 = dwLoc18->ptr0084;
	ecx_45();
	return runtime.concatstring3(gs, 0x00);
}

// 080ADDA0: void reflect.Value.Type(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.makeMethodValue
//      reflect.Value.String
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printValue
void reflect.Value.Type(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc10 + 4) = 0x12;
		if (g_t81576F0 == 0x00)
			*dwLoc10 = 135146134;
		else
			runtime.writebarrierptr(dwLoc10, 135146134);
		((word32) dwLoc10 + 8)->u0 = 0x00;
		runtime.gopanic(gs);
	}
	else
	{
		if ((dwArg0C & 0x0200) == 0x00)
			return;
		if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x14)
		{
			reflect.(*rtype).uncommon(gs, dwArg04);
			if (dwLoc10 != 0x00)
			{
				word16 cx_99 = (word16) (word32) *((word32) dwLoc10 + 4);
				if (dwArg0C >> 0x0A < (word32) cx_99)
				{
					Eq_123927 ecx_126 = (word32) cx_99;
					if (ecx_126 > 0x00010000)
						runtime.panicslice(gs);
					else if (dwArg0C >> 0x0A >= ecx_126)
						runtime.panicindex(gs);
					else
					{
						reflect.(*rtype).typeOff(gs);
						return;
					}
				}
			}
			runtime.gopanic(gs);
		}
		else if (dwArg0C >> 0x0A >= *((word32) dwArg04 + 40))
			runtime.gopanic(gs);
		else
			reflect.(*rtype).typeOff(gs);
	}
}

// 080ADF60: void reflect.Value.Uint(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtUint
//      reflect.cvtUintFloat
//      reflect.cvtUintString
//      fmt.(*pp).printValue
void reflect.Value.Uint(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x09)
	{
		if ((dwArg0C & 0x1F) == 0x07)
			return;
		if ((dwArg0C & 0x1F) == 0x08)
			return;
		if ((dwArg0C & 0x1F) == 0x09)
			return;
	}
	else
	{
		if ((dwArg0C & 0x1F) == 0x0A)
			return;
		if ((dwArg0C & 0x1F) == 11)
			return;
		if ((dwArg0C & 0x1F) == 0x0C)
			return;
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x12;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 0x080E2AA8;
	else
		runtime.writebarrierptr(dwLoc0C, 0x080E2AA8);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AE0B0: void reflect.ValueOf(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printArg
void reflect.ValueOf(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	if ((byte) (word32) g_b81450F8 != 0x00)
	{
		g_t81450FC = dwArg04;
		if (g_t81576F0 == 0x00)
			g_t8145100 = dwArg08;
		else
			runtime.writebarrierptr(0x08145100, dwArg08);
	}
	if (dwArg04 != 0x00)
		((byte) (word32) *((word32) dwArg04 + 0x0F) & 0x20) != 0x00;
}

// 080AE190: void reflect.Zero(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.cvtI2I
void reflect.Zero(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.gopanic(gs);
	else
	{
		(*((word32) dwArg04 + 0x0088))();
		if (((byte) (word32) dwLoc10->b000F & 0x20) != 0x00)
			return;
		if (dwArg04 != 0x08138A00)
			runtime.panicdottypeI(gs, dwArg04);
		else
			reflect.unsafe_New(gs, dwArg08);
	}
}

// 080AE270: void reflect.New(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.makeString
//      reflect.makeBytes
//      reflect.makeRunes
void reflect.New(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.gopanic(gs);
	else if (dwArg04 != 0x08138A00)
		runtime.panicdottypeI(gs, dwArg04);
	else
	{
		reflect.unsafe_New(gs, dwArg08);
		Eq_4 ecx_64 = *((word32) dwArg04 + 0x0088);
		ecx_64();
		reflect.(*rtype).ptrTo(gs, dwLoc0C);
	}
}

// 080AE330: void reflect.Value.assignTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      reflect.Value.MapIndex
void reflect.Value.assignTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg18, Eq_4 dwArg1C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 dwLoc44_467;
	Eq_4 edx_47;
	Eq_4 ecx_46;
	Eq_4 eax_17 = dwArg0C;
	if ((dwArg0C & 0x0200) == 0x00)
	{
		ecx_46 = dwArg08;
		edx_47 = dwArg04;
		dwLoc44_467 = dwLoc44;
	}
	else
	{
		word128 xmm1_39;
		reflect.makeMethodValue(gs, dwArg04, dwArg08, dwArg0C, out xmm1_39);
		dwLoc3C = dwArg0C;
		eax_17 = dwLoc30;
		ecx_46 = dwLoc34;
		edx_47 = dwLoc38;
		dwLoc44_467 = dwArg04;
	}
	reflect.directlyAssignable(gs, dwArg18, edx_47);
	byte bLoc44_345 = (byte) dwLoc44_467;
	if ((byte) (word32) bLoc44_345 != 0x00)
		return;
	reflect.implements(gs, dwLoc50, dwArg18);
	if ((byte) (word32) bLoc44_345 == 0x00)
	{
		reflect.(*rtype).String(gs, edx_47);
		reflect.(*rtype).String(gs, dwArg18);
		runtime.concatstring5(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x08);
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 eax_197 = dwArg1C;
		if (dwArg1C == 0x00)
		{
			reflect.unsafe_New(gs, dwArg18);
			eax_197 = edx_47;
		}
		word128 xmm1_471;
		reflect.valueInterface(gs, edx_47, ecx_46, eax_17, 0x00, out xmm1_471);
		word128 xmm1_472;
		reflect.(*rtype).NumMethod(gs, dwArg18, out xmm1_472);
		if (ecx_46 == 0x00)
		{
			*eax_197 = dwLoc3C;
			if (g_t81576F0 == 0x00)
				*((word32) eax_197 + 4) = dwLoc38;
			else
				runtime.writebarrierptr((word32) eax_197 + 4, dwLoc38);
		}
		else
			reflect.ifaceE2I(gs, dwArg18, dwLoc3C, eax_197);
	}
}

// 080AE5C0: void reflect.convertOp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*sliceType).ConvertibleTo
void reflect.convertOp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	word24 nLoc0B_461 = SLICE(dwLoc0C, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ecx_18 = (word32) *((word32) dwArg08 + 0x0F);
	if ((ecx_18 & 0x1F) <= 0x0E)
	{
		if ((ecx_18 & 0x1F) <= 0x06 && (ecx_18 & 0x1F) >= 0x02)
		{
			ui32 edx_218 = (word32) *((word32) dwArg04 + 0x0F);
			if ((edx_218 & 0x1F) <= 0x0C)
				return;
			if ((edx_218 & 0x1F) <= 0x0E)
				return;
			if ((edx_218 & 0x1F) == 0x18)
				return;
			goto l080AE625;
		}
		if ((ecx_18 & 0x1F) <= 0x0C && (ecx_18 & 0x1F) >= 0x07)
		{
			ui32 edx_195 = (word32) *((word32) dwArg04 + 0x0F);
			if ((edx_195 & 0x1F) <= 0x0C)
				return;
			if ((edx_195 & 0x1F) <= 0x0E)
				return;
			if ((edx_195 & 0x1F) == 0x18)
				return;
			goto l080AE625;
		}
		if ((ecx_18 & 0x1F) <= ~0x0D)
		{
			ui32 edx_171 = (word32) *((word32) dwArg04 + 0x0F);
			if ((edx_171 & 0x1F) <= 0x06)
				return;
			if ((edx_171 & 0x1F) <= 0x0C)
				return;
			if ((edx_171 & 0x1F) <= ~0x0D)
				return;
l080AE625:
			reflect.haveIdenticalUnderlyingType(gs, dwLoc18, dwArg04, (byte) dwArg08);
			Eq_4 bLoc10_577 = (byte) dwArg08;
			word32 dwLoc0C_463 = SEQ(nLoc0B_461, 0x00);
			if ((byte) (word32) bLoc08 != 0x00)
				return;
			if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 22)
			{
				reflect.(*rtype).Name(gs, dwArg04);
				if (dwLoc0C_463 == 0x00 && ((word32) (*((word32) dwArg08 + 0x0F)) & 0x1F) == 22)
				{
					reflect.(*rtype).Name(gs, dwArg08);
					if (dwLoc0C_463 == 0x00)
					{
						reflect.(*rtype).Elem(gs, dwArg04);
						Eq_4 ecx_320 = *((word32) dwArg08 + 0x0088);
						ecx_320();
						reflect.(*rtype).Elem(gs, dwArg08);
						Eq_4 ecx_341 = *((word32) dwArg08 + 0x0088);
						ecx_341();
						reflect.haveIdenticalUnderlyingType(gs, dwLoc18, dwArg08, bLoc10_577);
						if ((byte) (word32) bLoc08 != 0x00)
							return;
					}
				}
			}
			reflect.implements(gs, dwLoc18, dwArg04);
			if (0x00 == 0x00)
				return;
			if (((word32) *((word32) dwArg08 + 0x0F) & 0x1F) != 0x14)
				return;
			return;
		}
	}
	else
	{
		if ((ecx_18 & 0x1F) <= 0x10 && (ecx_18 & 0x1F) >= 0x0F)
		{
			if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) <= ~0x0F)
				return;
			goto l080AE625;
		}
		if ((ecx_18 & 0x1F) == 0x17)
		{
			if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x18)
			{
				reflect.(*rtype).Elem(gs, dwArg08);
				<anonymous> * eax_104 = dwLoc10->ptr007C;
				eax_104();
				if (dwLoc0C == 0x00)
				{
					reflect.(*rtype).Elem(gs, dwArg08);
					<anonymous> * ecx_125 = dwLoc10->ptr0054;
					ecx_125();
					if (dwLoc10 == (struct Eq_124407 *) 0x05)
						return;
					if (dwLoc10 == (struct Eq_124407 *) 0x08)
						return;
				}
			}
			goto l080AE625;
		}
		if ((ecx_18 & 0x1F) == 0x18)
		{
			if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x17)
			{
				reflect.(*rtype).Elem(gs, dwArg04);
				<anonymous> * eax_44 = dwLoc10->ptr007C;
				eax_44();
				if (dwLoc0C == 0x00)
				{
					reflect.(*rtype).Elem(gs, dwArg04);
					<anonymous> * ecx_66 = dwLoc10->ptr0054;
					ecx_66();
					if (dwLoc10 == (struct Eq_124407 *) 0x05)
						return;
					if (dwLoc10 == (struct Eq_124407 *) 0x08)
						return;
				}
			}
			goto l080AE625;
		}
	}
	goto l080AE625;
}

// 080AE9D0: void reflect.makeInt(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C, Stack (ptr32 Eq_124453) dwArg10, Stack word32 dwArg14)
// Called from:
//      reflect.cvtInt
//      reflect.cvtUint
//      reflect.cvtFloatInt
//      reflect.cvtFloatUint
void reflect.makeInt(struct Eq_2 * gs, ui32 dwArg04, Eq_4 dwArg08, word32 dwArg0C, struct Eq_124453 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	<anonymous> * eax_19 = dwArg10->ptr0088;
	eax_19();
	reflect.unsafe_New(gs, dwLoc08);
	Eq_4 edx_40 = *dwLoc08;
	if (edx_40 <= 0x02)
	{
		if (edx_40 == 0x01)
			*dwLoc08 = (byte) dwArg08;
		else if (edx_40 == 0x02)
			*dwLoc08 = (word16) dwArg08;
	}
	else if (edx_40 == 0x04)
		*dwLoc08 = dwArg08;
	else if (edx_40 == 0x08)
	{
		*dwLoc08 = dwArg08;
		*((word32) dwLoc08 + 4) = dwArg0C;
	}
}

// 080AEA90: void reflect.makeFloat(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04, Stack real64 rArg08, Stack (ptr32 Eq_124508) dwArg10, Stack word32 dwArg14)
// Called from:
//      reflect.cvtIntFloat
//      reflect.cvtUintFloat
//      reflect.cvtFloat
void reflect.makeFloat(struct Eq_2 * gs, ui32 dwArg04, real64 rArg08, struct Eq_124508 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	<anonymous> * eax_19 = dwArg10->ptr0088;
	eax_19();
	reflect.unsafe_New(gs, dwLoc08);
	Eq_124529 edx_40 = *dwLoc08;
	if (edx_40 == 0x04)
		*dwLoc08 = (real32) (uint128) (uint64) rArg08;
	else if (edx_40 == 0x08)
		*dwLoc08 = (real64) (uint128) (uint64) rArg08;
}

// 080AEB30: void reflect.makeComplex(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04, Stack real64 rArg08, Stack real64 rArg10, Stack (ptr32 Eq_124553) dwArg18, Stack word32 dwArg1C)
// Called from:
//      reflect.cvtComplex
void reflect.makeComplex(struct Eq_2 * gs, ui32 dwArg04, real64 rArg08, real64 rArg10, struct Eq_124553 * dwArg18, word32 dwArg1C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	<anonymous> * eax_19 = dwArg18->ptr0088;
	eax_19();
	reflect.unsafe_New(gs, dwLoc08);
	Eq_124574 edx_40 = *dwLoc08;
	if (edx_40 == 0x08)
	{
		*dwLoc08 = (real32) (uint128) (uint64) rArg08;
		*((word32) dwLoc08 + 4) = (real32) (uint128) (uint64) rArg10;
	}
	else if (edx_40 == 0x10)
	{
		*dwLoc08 = (real64) (uint128) (uint64) rArg08;
		*((word32) dwLoc08 + 8) = (real64) (uint128) (uint64) rArg10;
	}
}

// 080AEBF0: void reflect.makeString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack int32 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.cvtIntString
//      reflect.cvtUintString
//      reflect.cvtBytesString
//      reflect.cvtRunesString
void reflect.makeString(struct Eq_2 * gs, Eq_4 dwArg08, int32 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.New(gs, dwArg10, dwArg14);
	reflect.Value.Elem(gs, dwLoc1C, dwLoc18, dwLoc14);
	reflect.Value.SetString(gs, dwLoc14, dwLoc10, dwArg08, dwArg0C);
}

// 080AECB0: void reflect.makeBytes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      reflect.cvtStringBytes
void reflect.makeBytes(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.New(gs, dwArg14, dwArg18);
	reflect.Value.Elem(gs, dwLoc1C, dwLoc18, dwLoc14);
	reflect.Value.SetBytes(gs, dwLoc18, dwLoc14, dwLoc10, dwArg08, dwArg0C, dwArg10);
}

// 080AED70: void reflect.makeRunes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      reflect.cvtStringRunes
void reflect.makeRunes(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.New(gs, dwArg14, dwArg18);
	reflect.Value.Elem(gs, dwLoc1C, dwLoc18, dwLoc14);
	reflect.Value.setRunes(gs, dwLoc18, dwLoc14, dwLoc10, dwArg08, dwArg0C, dwArg10);
}

// 080AEE30: void reflect.cvtInt(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_124453) dwArg10, Stack word32 dwArg14)
void reflect.cvtInt(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_124453 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Int(gs, dwArg0C);
	reflect.makeInt(gs, dwArg0C & 0x60, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AEEC0: void reflect.cvtUint(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_124453) dwArg10, Stack word32 dwArg14)
void reflect.cvtUint(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_124453 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Uint(gs, dwArg0C);
	reflect.makeInt(gs, dwArg0C & 0x60, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AEF50: void reflect.cvtFloatInt(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_124453) dwArg10, Stack word32 dwArg14)
void reflect.cvtFloatInt(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_124453 * dwArg10, word32 dwArg14)
{
	word32 dwLoc14_84 = (word32) rLoc14;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Float(gs, dwArg0C);
	word128 xmm0_107;
	runtime.float64toint64(gs, (real64) (uint128) (uint64) rLoc14, out xmm0_107);
	reflect.makeInt(gs, dwArg0C & 0x60, dwArg0C, dwLoc14_84, dwArg10, dwArg14);
}

// 080AEFF0: void reflect.cvtFloatUint(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_124453) dwArg10, Stack word32 dwArg14)
void reflect.cvtFloatUint(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_124453 * dwArg10, word32 dwArg14)
{
	word32 dwLoc14_84 = (word32) rLoc14;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Float(gs, dwArg0C);
	runtime.float64touint64(gs, (real64) (uint128) (uint64) rLoc14);
	reflect.makeInt(gs, dwArg0C & 0x60, dwArg0C, dwLoc14_84, dwArg10, dwArg14);
}

// 080AF090: void reflect.cvtIntFloat(Register word32 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_124508) dwArg10, Stack word32 dwArg14)
void reflect.cvtIntFloat(word32 ebx, struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_124508 * dwArg10, word32 dwArg14)
{
	word32 dwLoc14 = (word32) qwLoc14;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Int(gs, dwArg0C);
	runtime.int64tofloat64(ebx_24_8, gs, qwLoc14);
	reflect.makeFloat(gs, dwArg0C & 0x60, (real64) (uint128) (uint64) SEQ(dwLoc14, dwArg0C), dwArg10, dwArg14);
}

// 080AF130: void reflect.cvtUintFloat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_124508) dwArg10, Stack word32 dwArg14)
void reflect.cvtUintFloat(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_124508 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Uint(gs, dwArg0C);
	runtime.uint64tofloat64(gs, dwLoc10);
	reflect.makeFloat(gs, dwArg0C & 0x60, (real64) (uint128) (uint64) SEQ(dwLoc14, dwArg0C), dwArg10, dwArg14);
}

// 080AF1D0: void reflect.cvtFloat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_124508) dwArg10, Stack word32 dwArg14)
void reflect.cvtFloat(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_124508 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Float(gs, dwArg0C);
	reflect.makeFloat(gs, dwArg0C & 0x60, (real64) (uint128) (uint64) rLoc14, dwArg10, dwArg14);
}

// 080AF250: void reflect.cvtComplex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_124553) dwArg10, Stack word32 dwArg14)
void reflect.cvtComplex(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_124553 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Complex(gs, dwArg0C);
	reflect.makeComplex(gs, dwArg0C & 0x60, (real64) (uint128) (uint64) rLoc1C, (real64) (uint128) (uint64) rLoc14, dwArg10, dwArg14);
}

// 080AF2E0: void reflect.cvtIntString(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtIntString(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Int(gs, dwArg0C);
	runtime.intstring(ebx, gs, null, dwLoc14, dwLoc10);
	reflect.makeString(gs, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AF390: void reflect.cvtUintString(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtUintString(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Uint(gs, dwArg0C);
	runtime.intstring(ebx, gs, null, dwLoc14, dwLoc10);
	reflect.makeString(gs, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AF440: void reflect.cvtBytesString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtBytesString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Bytes(gs, dwArg04, dwArg08, dwArg0C);
	runtime.slicebytetostring(gs, 0x00, dwLoc14, dwLoc10);
	reflect.makeString(gs, dwLoc10, dwLoc0C, dwArg10, dwArg14);
}

// 080AF4F0: void reflect.cvtStringBytes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtStringBytes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.stringtoslicebyte(reflect.Value.String(gs, dwArg04, dwArg08, dwArg0C), gs, dwLoc28, null, dwLoc18, dwLoc14);
	reflect.makeBytes(gs, dwLoc18, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AF5A0: void reflect.cvtRunesString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtRunesString(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.runes(gs, dwArg04, dwArg08, dwArg0C);
	runtime.slicerunetostring(gs, 0x00, dwLoc14, dwLoc10);
	reflect.makeString(gs, dwLoc10, dwLoc0C, dwArg10, dwArg14);
}

// 080AF650: void reflect.cvtStringRunes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtStringRunes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.stringtoslicerune(reflect.Value.String(gs, dwArg04, dwArg08, dwArg0C), gs, dwLoc28, null, dwLoc18, dwLoc14);
	reflect.makeRunes(gs, dwLoc18, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AF700: void reflect.cvtDirect(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack ui32 dwArg0C, Stack (ptr32 Eq_125109) dwArg10, Stack word32 dwArg14)
void reflect.cvtDirect(struct Eq_2 * gs, Eq_4 dwArg08, ui32 dwArg0C, struct Eq_125109 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	<anonymous> * eax_19 = dwArg10->ptr0088;
	eax_19();
	if ((dwArg0C & 0x0100) != 0x00)
	{
		reflect.unsafe_New(gs, dwLoc10);
		reflect.typedmemmove(gs, dwLoc10, dwLoc10, dwArg08);
	}
}

// 080AF7A0: void reflect.cvtT2I(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.cvtI2I
void reflect.cvtT2I(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	(*((word32) dwArg10 + 0x0088))();
	reflect.unsafe_New(gs, dwLoc20);
	word128 xmm1_216;
	reflect.valueInterface(gs, dwArg04, dwArg08, dwArg0C, 0x00, out xmm1_216);
	(*((word32) dwArg10 + 112))();
	Eq_4 dwLoc20_170 = dwArg08;
	if (dwArg08 == 0x00)
	{
		*dwLoc20 = dwLoc14;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc20 + 4) = dwLoc10;
		else
		{
			runtime.writebarrierptr((word32) dwLoc20 + 4, dwLoc10);
			dwLoc20_170 = dwLoc10;
		}
	}
	else
	{
		if (dwArg10 != 0x08138A00)
			runtime.panicdottypeI(gs, dwArg10);
		reflect.ifaceE2I(gs, dwArg14, dwLoc14, dwLoc20);
		dwLoc20_170 = dwLoc14;
	}
	Eq_4 eax_136 = *((word32) dwArg10 + 0x0088);
	eax_136();
}

// 080AF900: void reflect.cvtI2I(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtI2I(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	byte bLoc14 = (byte) dwLoc14;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.IsNil(gs, dwArg0C);
	if ((byte) (word32) bLoc14 == 0x00)
	{
		reflect.Value.Elem(gs, dwArg04, dwArg08, dwArg0C);
		reflect.cvtT2I(gs, dwLoc14, dwLoc10, dwLoc0C, dwArg10, dwArg14);
	}
	else
		reflect.Zero(gs, dwArg10, dwArg14);
}

// 080AF9F0: void reflect.(*structType).FieldByName.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*structType).FieldByName.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_100;
		word32 ebx_99;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_99, out esi_100);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	if (dwArg08 == *((word32) edx + 8))
	{
		word32 edi_35;
		word32 esi_36;
		runtime.eqstring(dwArg04, dwArg08, eax_25, out esi_36, out edi_35);
	}
}

// 080AFA50: void reflect.FuncOf.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.FuncOf.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	byte bLoc3C = (byte) dwLoc3C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_285;
		word32 esi_286;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_285, out esi_286);
	}
	Eq_4 ecx_103;
	Eq_4 edx_57;
	Eq_4 ebx_53;
	sync.(*Map).Load(gs, 135549544, 0x080CF2A0, fp - 0x20);
	Eq_4 dwLoc48_222 = fp - 0x20;
	if ((byte) (word32) bLoc3C != 0x00)
	{
		if (dwLoc44 != 0x080C9000)
			runtime.panicdottypeE(gs, dwLoc44);
		ecx_103 = dwLoc40->t0000;
		ebx_53 = dwLoc40->t0004;
		edx_57 = dwLoc40->t0008;
	}
	else
	{
		ebx_53.u0 = 0x00;
		ecx_103.u0 = 0x00;
		edx_57.u0 = 0x00;
	}
	Eq_4 ebp_73 = (byte) ebx_53.u0 + 1;
	if (ebp_73 > edx_57)
	{
		word32 esi_287;
		runtime.growslice(gs, 0x080DDF40, ecx_103, ebx_53, edx_57, ebp_73, out esi_287);
		dwLoc48_222 = ebx_53;
		dwLoc44 = edx_57;
		ecx_103 = dwLoc3C;
	}
	Eq_4 esi_105 = (byte) ecx_103.u0 + ebx_53 * 0x04;
	if (g_t81576F0 == 0x00)
		*((byte) ecx_103.u0 + ebx_53 * 0x04) = dwArg04;
	else
		runtime.writebarrierptr(esi_105, dwArg04);
	runtime.convT2Eslice(runtime.convT2E32(ebx_53, gs, 0x080CF2A0, fp - 0x1C), gs, 0x080C9000, fp - 0x0C);
	sync.(*Map).Store(gs, 135549544, dwLoc48_222, dwLoc44, dwLoc48_222, dwLoc44);
}

// 080AFC20: void reflect.funcLayout.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.funcLayout.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_65;
		word32 ebx_64;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_64, out esi_65);
	}
	reflect.unsafe_New(gs, *((word32) edx + 4));
}

// 080AFC60: Register word128 reflect.init(Register (ptr32 Eq_2) gs)
// Called from:
//      fmt.init
word128 reflect.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157565;
	if (al_18 > 0x01)
		return xmm1;
	if (al_18 != 0x01)
	{
		g_b8157565 = 0x01;
		word128 xmm0_189;
		word32 edi_188;
		word32 esi_187;
		runtime.init(gs, out esi_187, out edi_188, out xmm0_189);
		strconv.init(gs);
		Eq_4 edi_46;
		Eq_4 esi_48;
		word128 xmm0_190;
		word128 xmm1_64 = unicode.init(sync.init(gs, out esi_48, out edi_46, out xmm0_190), esi_48, edi_46, gs);
		reflect.TypeOf(gs, 0x080CF320);
		if (dwLoc08 != 0x08138A00)
			runtime.panicdottypeI(gs, dwLoc08);
		else
		{
			if (g_t81576F0 == 0x00)
				g_t8144F9C = dwLoc04;
			else
				runtime.writebarrierptr(135548828, dwLoc04);
			g_b8157565 = 0x02;
			return xmm1_64;
		}
	}
	else
		runtime.throwinit(gs);
}

// 080AFD40: void reflect.methodValueCall(Register (ptr32 Eq_122319) edx, Register (ptr32 Eq_2) gs)
void reflect.methodValueCall(struct Eq_122319 * edx, struct Eq_2 * gs)
{
	Eq_4 ebx_9 = *((word32) gs->ptr0000->tFFFFFFFC + 16);
	if (ebx_9 != 0x00 && *ebx_9 == fp + 0x04)
		*ebx_9 = fp - 0x08;
	reflect.callMethod(gs, edx, fp + 0x04);
}

// 080AFD80: void reflect.(*ChanDir).String(Register word32 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_101636) dwArg04)
void reflect.(*ChanDir).String(word32 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, union Eq_101636 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x0C;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.ChanDir.String(ebx_17, ebp, esi, gs, *dwArg04);
}

// 080AFDE0: void reflect.(*Kind).String(Register word32 ebp, Register (ptr32 Eq_24555) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_101636) dwArg04)
void reflect.(*Kind).String(word32 ebp, struct Eq_24555 * esi, struct Eq_2 * gs, union Eq_101636 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x0C;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.Kind.String(ebx_17, ebp, esi, gs, *dwArg04);
}

// 080AFE40: void type..hash.reflect.uncommonType(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.reflect.uncommonType(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x06);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 8, dwLoc04, 0x04);
}

// 080AFEB0: void type..eq.reflect.uncommonType(Register (ptr32 Eq_125604) gs, Stack (ptr32 Eq_125605) dwArg04, Stack (ptr32 Eq_125606) dwArg08)
void type..eq.reflect.uncommonType(struct Eq_125604 * gs, struct Eq_125605 * dwArg04, struct Eq_125606 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
		(word16) (word32) dwArg04->w0004 != (word16) ((word32) dwArg08->w0004);
}

// 080AFF00: void reflect.(*Value).Kind(Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
void reflect.(*Value).Kind(struct Eq_2 * gs, word32 dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_16 = *((word32) ecx_7 + 16);
	if (ebx_16 != 0x00 && *ebx_16 == (word32) fp + 4)
		*ebx_16 = fp;
	if (dwArg04 != 0x00)
		return;
	runtime.panicwrap(gs);
}

// 080AFF50: void reflect.(*Value).Len(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_125672) dwArg04)
void reflect.(*Value).Len(struct Eq_2 * gs, struct Eq_125672 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x10;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.Value.Len(gs, dwArg04->t0000, dwArg04->t0008);
}

// 080AFFC0: void reflect.(*Value).NumMethod(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_125717) dwArg04)
void reflect.(*Value).NumMethod(struct Eq_2 * gs, struct Eq_125717 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x10;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
	{
		word128 xmm1_73;
		reflect.Value.NumMethod(gs, dwArg04->t0000, dwArg04->t0008, out xmm1_73);
	}
}

// 080B0030: void reflect.(*Value).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_125763) dwArg04)
void reflect.(*Value).NumField(struct Eq_2 * gs, struct Eq_125763 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x10;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.Value.NumField(gs, dwArg04->t0008);
}

// 080B00A0: void reflect.(*Value).String(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_125805) dwArg04)
void reflect.(*Value).String(struct Eq_2 * gs, struct Eq_125805 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x14;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.Value.String(gs, dwArg04->t0000, dwArg04->t0004, dwArg04->t0008);
}

// 080B0110: void type..hash.reflect.Method(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack (ptr32 Eq_639) dwArg04, Stack Eq_207 dwArg08)
void type..hash.reflect.Method(struct Eq_2 * gs, word64 mm0, struct Eq_639 * dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.strhash(gs, mm0, dwArg04, dwArg08);
	runtime.strhash(gs, mm0, (char *) &dwArg04->t0004 + 4, dwLoc08);
	runtime.interhash(gs, (char *) &dwArg04->t0004 + 0x0C, dwLoc08);
	runtime.memhash(gs, mm0, (char *) &dwArg04->t0004 + 20, dwLoc08, 0x10);
}

// 080B01A0: void type..eq.reflect.Method(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_125884) dwArg04, Stack (ptr32 Eq_125885) dwArg08)
void type..eq.reflect.Method(struct Eq_2 * gs, struct Eq_125884 * dwArg04, struct Eq_125885 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte cl_45;
	Eq_4 ecx_18 = dwArg04->t0000;
	Eq_4 ebx_20 = dwArg08->t0000;
	Eq_4 ebp_21 = dwArg08->t0004;
	Eq_4 esi_22 = dwArg04->t0004;
	if (esi_22 != ebp_21)
		cl_45 = 0x00;
	else
	{
		word32 edi_29;
		word32 esi_30;
		runtime.eqstring(ecx_18, esi_22, ebx_20, out esi_30, out edi_29);
		bLoc08 = (byte) ebp_21;
		cl_45 = (byte) (word32) bLoc04;
	}
	byte cl_84;
	if (cl_45 != 0x00)
	{
		Eq_4 ecx_56 = dwArg08->t0008;
		Eq_4 ebx_58 = dwArg04->t000C;
		Eq_4 ebp_59 = dwArg04->t0008;
		Eq_4 esi_60 = dwArg08->t000C;
		if (ebx_58 != esi_60)
			cl_84 = 0x00;
		else
		{
			word32 edi_68;
			word32 esi_69;
			runtime.eqstring(ebp_59, ebx_58, ecx_56, out esi_69, out edi_68);
			bLoc08 = (byte) esi_60;
			cl_84 = (byte) (word32) bLoc04;
		}
	}
	else
		cl_84 = 0x00;
	uip32 ecx_116;
	if (cl_84 != 0x00)
	{
		Eq_4 ecx_96 = dwArg04->t0014;
		Eq_4 ebx_97 = dwArg04->t0010;
		Eq_4 esi_100 = dwArg08->t0014;
		if (ebx_97 != dwArg08->t0010)
			ecx_116 = 0x00;
		else
		{
			runtime.ifaceeq(gs, ebx_97, ecx_96, esi_100);
			ecx_116 = (word32) bLoc08;
		}
	}
	else
		ecx_116 = 0x00;
	if ((byte) ecx_116 != 0x00)
	{
		uip32 ecx_264;
		if (dwArg04->dw0018 == dwArg08->dw0018)
		{
			if (dwArg04->dw001C == dwArg08->dw001C)
			{
				word32 ecx_149 = dwArg08->dw0020;
				ecx_264 = SEQ(SLICE(ecx_149, word24, 8), dwArg04->dw0020 == ecx_149);
			}
			else
				ecx_264 = 0x00;
		}
		else
			ecx_264 = 0x00;
	}
}

// 080B02E0: void type..hash.reflect.ValueError(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack (ptr32 Eq_639) dwArg04, Stack Eq_207 dwArg08)
void type..hash.reflect.ValueError(struct Eq_2 * gs, word64 mm0, struct Eq_639 * dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.strhash(gs, mm0, dwArg04, dwArg08);
	runtime.memhash(gs, mm0, (char *) &dwArg04->t0004 + 4, dwLoc08, 0x04);
}

// 080B0340: void type..eq.reflect.ValueError(Register (ptr32 Eq_126040) gs, Stack (ptr32 Eq_126041) dwArg04, Stack (ptr32 Eq_126042) dwArg08)
void type..eq.reflect.ValueError(struct Eq_126040 * gs, struct Eq_126041 * dwArg04, struct Eq_126042 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uip32 ecx_112;
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 esi_22 = dwArg08->t0000;
	if (ecx_18 != dwArg08->t0004)
		ecx_112 = 0x00;
	else
	{
		word32 edi_29;
		word32 esi_30;
		runtime.eqstring(edx_19, ecx_18, esi_22, out esi_30, out edi_29);
		ecx_112 = (word32) bLoc04;
	}
}

// 080B03C0: void reflect.(*structType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B03F0: void reflect.(*structType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B0430: void reflect.(*structType).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*structType).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B0460: void reflect.(*structType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B0490: void reflect.(*structType).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*structType).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B04C0: void reflect.(*structType).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*structType).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B04F0: void reflect.(*structType).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*structType).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B0520: void reflect.(*structType).common(Register (ptr32 Eq_115191) gs)
void reflect.(*structType).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B0550: void reflect.(*structType).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B0580: void reflect.(*structType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*structType).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B05C0: void reflect.(*structType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*structType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B0600: void reflect.(*structType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B0640: void reflect.(*structType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B0680: void reflect.(*structType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B06B0: void reflect.(*structType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B06E0: void reflect.(*structType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B0720: void reflect.(*structType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*structType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B0760: void reflect.(*structType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B07A0: void reflect.(*structType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B07D0: void reflect.(*structType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*structType).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B0800: void reflect.(*structType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B0830: void reflect.(*structType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B0860: void reflect.(*structType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*structType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B08A0: void reflect.(*structType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*structType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B08D0: void reflect.(*structType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*structType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B0900: void reflect.(*structType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*structType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B0930: void reflect.(*structType).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*structType).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B0960: void reflect.(*funcType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B0990: void reflect.(*funcType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B09D0: void reflect.(*funcType).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*funcType).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B0A00: void reflect.(*funcType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B0A30: void reflect.(*funcType).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*funcType).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B0A60: void reflect.(*funcType).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*funcType).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B0A90: void reflect.(*funcType).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*funcType).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B0AC0: void reflect.(*funcType).common(Register (ptr32 Eq_115191) gs)
void reflect.(*funcType).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B0AF0: void reflect.(*funcType).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B0B20: void reflect.(*funcType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcType).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B0B60: void reflect.(*funcType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B0BA0: void reflect.(*funcType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B0BE0: void reflect.(*funcType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B0C20: void reflect.(*funcType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B0C50: void reflect.(*funcType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B0C80: void reflect.(*funcType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B0CC0: void reflect.(*funcType).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcType).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B0D00: void reflect.(*funcType).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcType).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B0D40: void reflect.(*funcType).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcType).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B0D80: void reflect.(*funcType).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcType).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B0DC0: void reflect.(*funcType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B0E00: void reflect.(*funcType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B0E40: void reflect.(*funcType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B0E70: void reflect.(*funcType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*funcType).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B0EA0: void reflect.(*funcType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B0ED0: void reflect.(*funcType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B0F00: void reflect.(*funcType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B0F40: void reflect.(*funcType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B0F70: void reflect.(*funcType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B0FA0: void reflect.(*funcType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B0FD0: void reflect.(*funcType).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*funcType).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B1000: void reflect.(*funcTypeFixed128).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B1030: void reflect.(*funcTypeFixed128).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B1070: void reflect.(*funcTypeFixed128).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*funcTypeFixed128).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B10A0: void reflect.(*funcTypeFixed128).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B10D0: void reflect.(*funcTypeFixed128).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*funcTypeFixed128).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B1100: void reflect.(*funcTypeFixed128).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*funcTypeFixed128).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B1130: void reflect.(*funcTypeFixed128).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*funcTypeFixed128).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B1160: void reflect.(*funcTypeFixed128).common(Register (ptr32 Eq_115191) gs)
void reflect.(*funcTypeFixed128).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B1190: void reflect.(*funcTypeFixed128).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B11C0: void reflect.(*funcTypeFixed128).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed128).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B1200: void reflect.(*funcTypeFixed128).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B1240: void reflect.(*funcTypeFixed128).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B1280: void reflect.(*funcTypeFixed128).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B12C0: void reflect.(*funcTypeFixed128).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B12F0: void reflect.(*funcTypeFixed128).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B1320: void reflect.(*funcTypeFixed128).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B1360: void reflect.(*funcTypeFixed128).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed128).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B13A0: void reflect.(*funcTypeFixed128).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed128).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B13E0: void reflect.(*funcTypeFixed128).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed128).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B1420: void reflect.(*funcTypeFixed128).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed128).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B1460: void reflect.(*funcTypeFixed128).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed128).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B14A0: void reflect.(*funcTypeFixed128).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B14E0: void reflect.(*funcTypeFixed128).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B1510: void reflect.(*funcTypeFixed128).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*funcTypeFixed128).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B1540: void reflect.(*funcTypeFixed128).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B1570: void reflect.(*funcTypeFixed128).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B15A0: void reflect.(*funcTypeFixed128).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed128).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B15E0: void reflect.(*funcTypeFixed128).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed128).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B1610: void reflect.(*funcTypeFixed128).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed128).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B1640: void reflect.(*funcTypeFixed128).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed128).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B1670: void reflect.(*funcTypeFixed128).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*funcTypeFixed128).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B16A0: void reflect.(*funcTypeFixed16).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B16D0: void reflect.(*funcTypeFixed16).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B1710: void reflect.(*funcTypeFixed16).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*funcTypeFixed16).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B1740: void reflect.(*funcTypeFixed16).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B1770: void reflect.(*funcTypeFixed16).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*funcTypeFixed16).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B17A0: void reflect.(*funcTypeFixed16).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*funcTypeFixed16).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B17D0: void reflect.(*funcTypeFixed16).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*funcTypeFixed16).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B1800: void reflect.(*funcTypeFixed16).common(Register (ptr32 Eq_115191) gs)
void reflect.(*funcTypeFixed16).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B1830: void reflect.(*funcTypeFixed16).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B1860: void reflect.(*funcTypeFixed16).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed16).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B18A0: void reflect.(*funcTypeFixed16).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B18E0: void reflect.(*funcTypeFixed16).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B1920: void reflect.(*funcTypeFixed16).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B1960: void reflect.(*funcTypeFixed16).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B1990: void reflect.(*funcTypeFixed16).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B19C0: void reflect.(*funcTypeFixed16).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B1A00: void reflect.(*funcTypeFixed16).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed16).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B1A40: void reflect.(*funcTypeFixed16).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed16).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B1A80: void reflect.(*funcTypeFixed16).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed16).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B1AC0: void reflect.(*funcTypeFixed16).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed16).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B1B00: void reflect.(*funcTypeFixed16).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed16).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B1B40: void reflect.(*funcTypeFixed16).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B1B80: void reflect.(*funcTypeFixed16).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B1BB0: void reflect.(*funcTypeFixed16).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*funcTypeFixed16).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B1BE0: void reflect.(*funcTypeFixed16).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B1C10: void reflect.(*funcTypeFixed16).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B1C40: void reflect.(*funcTypeFixed16).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed16).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B1C80: void reflect.(*funcTypeFixed16).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed16).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B1CB0: void reflect.(*funcTypeFixed16).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed16).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B1CE0: void reflect.(*funcTypeFixed16).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed16).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B1D10: void reflect.(*funcTypeFixed16).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*funcTypeFixed16).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B1D40: void reflect.(*funcTypeFixed32).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B1D70: void reflect.(*funcTypeFixed32).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B1DB0: void reflect.(*funcTypeFixed32).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*funcTypeFixed32).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B1DE0: void reflect.(*funcTypeFixed32).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B1E10: void reflect.(*funcTypeFixed32).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*funcTypeFixed32).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B1E40: void reflect.(*funcTypeFixed32).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*funcTypeFixed32).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B1E70: void reflect.(*funcTypeFixed32).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*funcTypeFixed32).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B1EA0: void reflect.(*funcTypeFixed32).common(Register (ptr32 Eq_115191) gs)
void reflect.(*funcTypeFixed32).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B1ED0: void reflect.(*funcTypeFixed32).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B1F00: void reflect.(*funcTypeFixed32).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed32).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B1F40: void reflect.(*funcTypeFixed32).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B1F80: void reflect.(*funcTypeFixed32).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B1FC0: void reflect.(*funcTypeFixed32).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B2000: void reflect.(*funcTypeFixed32).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B2030: void reflect.(*funcTypeFixed32).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B2060: void reflect.(*funcTypeFixed32).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B20A0: void reflect.(*funcTypeFixed32).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed32).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B20E0: void reflect.(*funcTypeFixed32).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed32).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B2120: void reflect.(*funcTypeFixed32).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed32).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B2160: void reflect.(*funcTypeFixed32).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed32).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B21A0: void reflect.(*funcTypeFixed32).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed32).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B21E0: void reflect.(*funcTypeFixed32).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B2220: void reflect.(*funcTypeFixed32).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B2250: void reflect.(*funcTypeFixed32).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*funcTypeFixed32).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B2280: void reflect.(*funcTypeFixed32).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B22B0: void reflect.(*funcTypeFixed32).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B22E0: void reflect.(*funcTypeFixed32).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed32).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B2320: void reflect.(*funcTypeFixed32).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed32).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B2350: void reflect.(*funcTypeFixed32).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed32).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B2380: void reflect.(*funcTypeFixed32).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed32).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B23B0: void reflect.(*funcTypeFixed32).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*funcTypeFixed32).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B23E0: void reflect.(*funcTypeFixed4).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B2410: void reflect.(*funcTypeFixed4).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B2450: void reflect.(*funcTypeFixed4).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*funcTypeFixed4).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B2480: void reflect.(*funcTypeFixed4).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B24B0: void reflect.(*funcTypeFixed4).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*funcTypeFixed4).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B24E0: void reflect.(*funcTypeFixed4).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*funcTypeFixed4).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B2510: void reflect.(*funcTypeFixed4).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*funcTypeFixed4).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B2540: void reflect.(*funcTypeFixed4).common(Register (ptr32 Eq_115191) gs)
void reflect.(*funcTypeFixed4).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B2570: void reflect.(*funcTypeFixed4).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B25A0: void reflect.(*funcTypeFixed4).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed4).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B25E0: void reflect.(*funcTypeFixed4).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B2620: void reflect.(*funcTypeFixed4).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B2660: void reflect.(*funcTypeFixed4).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B26A0: void reflect.(*funcTypeFixed4).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B26D0: void reflect.(*funcTypeFixed4).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B2700: void reflect.(*funcTypeFixed4).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B2740: void reflect.(*funcTypeFixed4).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed4).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B2780: void reflect.(*funcTypeFixed4).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed4).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B27C0: void reflect.(*funcTypeFixed4).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed4).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B2800: void reflect.(*funcTypeFixed4).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed4).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B2840: void reflect.(*funcTypeFixed4).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed4).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B2880: void reflect.(*funcTypeFixed4).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B28C0: void reflect.(*funcTypeFixed4).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B28F0: void reflect.(*funcTypeFixed4).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*funcTypeFixed4).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B2920: void reflect.(*funcTypeFixed4).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B2950: void reflect.(*funcTypeFixed4).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B2980: void reflect.(*funcTypeFixed4).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed4).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B29C0: void reflect.(*funcTypeFixed4).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed4).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B29F0: void reflect.(*funcTypeFixed4).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed4).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B2A20: void reflect.(*funcTypeFixed4).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed4).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B2A50: void reflect.(*funcTypeFixed4).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*funcTypeFixed4).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B2A80: void reflect.(*funcTypeFixed64).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B2AB0: void reflect.(*funcTypeFixed64).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B2AF0: void reflect.(*funcTypeFixed64).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*funcTypeFixed64).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B2B20: void reflect.(*funcTypeFixed64).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B2B50: void reflect.(*funcTypeFixed64).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*funcTypeFixed64).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B2B80: void reflect.(*funcTypeFixed64).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*funcTypeFixed64).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B2BB0: void reflect.(*funcTypeFixed64).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*funcTypeFixed64).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B2BE0: void reflect.(*funcTypeFixed64).common(Register (ptr32 Eq_115191) gs)
void reflect.(*funcTypeFixed64).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B2C10: void reflect.(*funcTypeFixed64).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B2C40: void reflect.(*funcTypeFixed64).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed64).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B2C80: void reflect.(*funcTypeFixed64).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B2CC0: void reflect.(*funcTypeFixed64).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B2D00: void reflect.(*funcTypeFixed64).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B2D40: void reflect.(*funcTypeFixed64).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B2D70: void reflect.(*funcTypeFixed64).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B2DA0: void reflect.(*funcTypeFixed64).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B2DE0: void reflect.(*funcTypeFixed64).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed64).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B2E20: void reflect.(*funcTypeFixed64).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed64).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B2E60: void reflect.(*funcTypeFixed64).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed64).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B2EA0: void reflect.(*funcTypeFixed64).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed64).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B2EE0: void reflect.(*funcTypeFixed64).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed64).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B2F20: void reflect.(*funcTypeFixed64).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B2F60: void reflect.(*funcTypeFixed64).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B2F90: void reflect.(*funcTypeFixed64).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*funcTypeFixed64).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B2FC0: void reflect.(*funcTypeFixed64).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B2FF0: void reflect.(*funcTypeFixed64).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B3020: void reflect.(*funcTypeFixed64).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed64).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B3060: void reflect.(*funcTypeFixed64).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed64).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3090: void reflect.(*funcTypeFixed64).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed64).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B30C0: void reflect.(*funcTypeFixed64).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed64).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B30F0: void reflect.(*funcTypeFixed64).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*funcTypeFixed64).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B3120: void reflect.(*funcTypeFixed8).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B3150: void reflect.(*funcTypeFixed8).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B3190: void reflect.(*funcTypeFixed8).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*funcTypeFixed8).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B31C0: void reflect.(*funcTypeFixed8).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B31F0: void reflect.(*funcTypeFixed8).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*funcTypeFixed8).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B3220: void reflect.(*funcTypeFixed8).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*funcTypeFixed8).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B3250: void reflect.(*funcTypeFixed8).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*funcTypeFixed8).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B3280: void reflect.(*funcTypeFixed8).common(Register (ptr32 Eq_115191) gs)
void reflect.(*funcTypeFixed8).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B32B0: void reflect.(*funcTypeFixed8).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B32E0: void reflect.(*funcTypeFixed8).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed8).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B3320: void reflect.(*funcTypeFixed8).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B3360: void reflect.(*funcTypeFixed8).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B33A0: void reflect.(*funcTypeFixed8).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B33E0: void reflect.(*funcTypeFixed8).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B3410: void reflect.(*funcTypeFixed8).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B3440: void reflect.(*funcTypeFixed8).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B3480: void reflect.(*funcTypeFixed8).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed8).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B34C0: void reflect.(*funcTypeFixed8).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed8).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B3500: void reflect.(*funcTypeFixed8).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed8).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B3540: void reflect.(*funcTypeFixed8).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed8).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B3580: void reflect.(*funcTypeFixed8).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed8).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B35C0: void reflect.(*funcTypeFixed8).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B3600: void reflect.(*funcTypeFixed8).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B3630: void reflect.(*funcTypeFixed8).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*funcTypeFixed8).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B3660: void reflect.(*funcTypeFixed8).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B3690: void reflect.(*funcTypeFixed8).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B36C0: void reflect.(*funcTypeFixed8).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed8).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B3700: void reflect.(*funcTypeFixed8).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed8).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3730: void reflect.(*funcTypeFixed8).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed8).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3760: void reflect.(*funcTypeFixed8).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed8).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B3790: void reflect.(*funcTypeFixed8).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*funcTypeFixed8).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B37C0: void reflect.(*interfaceType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B37F0: void reflect.(*interfaceType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B3830: void reflect.(*interfaceType).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*interfaceType).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B3860: void reflect.(*interfaceType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B3890: void reflect.(*interfaceType).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*interfaceType).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B38C0: void reflect.(*interfaceType).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*interfaceType).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B38F0: void reflect.(*interfaceType).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*interfaceType).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B3920: void reflect.(*interfaceType).common(Register (ptr32 Eq_115191) gs)
void reflect.(*interfaceType).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B3950: void reflect.(*interfaceType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B3990: void reflect.(*interfaceType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B39D0: void reflect.(*interfaceType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B3A00: void reflect.(*interfaceType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B3A30: void reflect.(*interfaceType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B3A70: void reflect.(*interfaceType).Field(Register (ptr32 Eq_2) gs)
void reflect.(*interfaceType).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B3AB0: void reflect.(*interfaceType).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*interfaceType).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B3AF0: void reflect.(*interfaceType).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*interfaceType).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B3B30: void reflect.(*interfaceType).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*interfaceType).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B3B70: void reflect.(*interfaceType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*interfaceType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B3BB0: void reflect.(*interfaceType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B3BF0: void reflect.(*interfaceType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B3C20: void reflect.(*interfaceType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*interfaceType).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B3C50: void reflect.(*interfaceType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B3C80: void reflect.(*interfaceType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B3CB0: void reflect.(*interfaceType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*interfaceType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B3CF0: void reflect.(*interfaceType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*interfaceType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3D20: void reflect.(*interfaceType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*interfaceType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3D50: void reflect.(*interfaceType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*interfaceType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B3D80: void reflect.(*interfaceType).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*interfaceType).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B3DB0: void reflect.(*ptrType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B3DE0: void reflect.(*ptrType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B3E20: void reflect.(*ptrType).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*ptrType).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B3E50: void reflect.(*ptrType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B3E80: void reflect.(*ptrType).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*ptrType).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B3EB0: void reflect.(*ptrType).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*ptrType).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B3EE0: void reflect.(*ptrType).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*ptrType).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B3F10: void reflect.(*ptrType).common(Register (ptr32 Eq_115191) gs)
void reflect.(*ptrType).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B3F40: void reflect.(*ptrType).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B3F70: void reflect.(*ptrType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*ptrType).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B3FB0: void reflect.(*ptrType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*ptrType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B3FF0: void reflect.(*ptrType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B4030: void reflect.(*ptrType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B4070: void reflect.(*ptrType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B40A0: void reflect.(*ptrType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B40D0: void reflect.(*ptrType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B4110: void reflect.(*ptrType).Field(Register (ptr32 Eq_2) gs)
void reflect.(*ptrType).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B4150: void reflect.(*ptrType).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*ptrType).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B4190: void reflect.(*ptrType).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*ptrType).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B41D0: void reflect.(*ptrType).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*ptrType).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B4210: void reflect.(*ptrType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*ptrType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B4250: void reflect.(*ptrType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B4290: void reflect.(*ptrType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B42C0: void reflect.(*ptrType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*ptrType).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B42F0: void reflect.(*ptrType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B4320: void reflect.(*ptrType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B4350: void reflect.(*ptrType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*ptrType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B4390: void reflect.(*ptrType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*ptrType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B43C0: void reflect.(*ptrType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*ptrType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B43F0: void reflect.(*ptrType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*ptrType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B4420: void reflect.(*ptrType).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*ptrType).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B4450: void reflect.(*sliceType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B4480: void reflect.(*sliceType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B44C0: void reflect.(*sliceType).Size(Register (ptr32 Eq_115100) gs)
void reflect.(*sliceType).Size(struct Eq_115100 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B44F0: void reflect.(*sliceType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B4520: void reflect.(*sliceType).Align(Register (ptr32 Eq_115152) gs)
void reflect.(*sliceType).Align(struct Eq_115152 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B4550: void reflect.(*sliceType).FieldAlign(Register (ptr32 Eq_115165) gs)
void reflect.(*sliceType).FieldAlign(struct Eq_115165 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B4580: void reflect.(*sliceType).Kind(Register (ptr32 Eq_115178) gs)
void reflect.(*sliceType).Kind(struct Eq_115178 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B45B0: void reflect.(*sliceType).common(Register (ptr32 Eq_115191) gs)
void reflect.(*sliceType).common(struct Eq_115191 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B45E0: void reflect.(*sliceType).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_43;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_43);
}

// 080B4610: void reflect.(*sliceType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*sliceType).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B4650: void reflect.(*sliceType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*sliceType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B4690: void reflect.(*sliceType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B46D0: void reflect.(*sliceType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B4710: void reflect.(*sliceType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B4740: void reflect.(*sliceType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B4770: void reflect.(*sliceType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B47B0: void reflect.(*sliceType).Field(Register (ptr32 Eq_2) gs)
void reflect.(*sliceType).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B47F0: void reflect.(*sliceType).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*sliceType).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B4830: void reflect.(*sliceType).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*sliceType).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B4870: void reflect.(*sliceType).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*sliceType).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B48B0: void reflect.(*sliceType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*sliceType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B48F0: void reflect.(*sliceType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B4930: void reflect.(*sliceType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B4960: void reflect.(*sliceType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_116507) dwArg04)
void reflect.(*sliceType).NumField(struct Eq_2 * gs, struct Eq_116507 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B4990: void reflect.(*sliceType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B49C0: void reflect.(*sliceType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B49F0: void reflect.(*sliceType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*sliceType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B4A30: void reflect.(*sliceType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*sliceType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B4A60: void reflect.(*sliceType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*sliceType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B4A90: void reflect.(*sliceType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*sliceType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B4AC0: void reflect.(*sliceType).Comparable(Register (ptr32 Eq_118276) gs, Stack (ptr32 Eq_118277) dwArg04)
void reflect.(*sliceType).Comparable(struct Eq_118276 * gs, struct Eq_118277 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B4AF0: void type..hash.[27]string(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack word32 dwArg04, Stack Eq_207 dwArg08)
void type..hash.[27]string(struct Eq_2 * gs, word64 mm0, word32 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	Eq_207 ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x1B; ++eax_17)
	{
		runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 080B4B50: void type..eq.[27]string(Register (ptr32 Eq_131835) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[27]string(struct Eq_131835 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x1B; ++eax_17)
	{
		struct Eq_131854 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_131858 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 esi_129;
		word32 edi_130;
		runtime.eqstring(esi_35, edi_34, edx_33, out esi_129, out edi_130);
		if ((byte) (word32) bLoc08 == 0x00)
			return;
	}
}

// 080B4BD0: void type..hash.struct { reflect.b bool; reflect.x interface {} }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { reflect.b bool; reflect.x interface {} }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x01);
	runtime.nilinterhash(gs, (word32) dwArg04 + 4, dwLoc04);
}

// 080B4C30: void type..eq.struct { reflect.b bool; reflect.x interface {} }(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_131916) dwArg04, Stack (ptr32 Eq_131917) dwArg08)
void type..eq.struct { reflect.b bool; reflect.x interface {} }(struct Eq_2 * gs, struct Eq_131916 * dwArg04, struct Eq_131917 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) dwArg04->b0000 == (byte) ((word32) dwArg08->b0000))
	{
		word32 ecx_28 = dwArg04->dw0008;
		Eq_4 eax_29 = dwArg04->t0004;
		word32 ebx_30 = dwArg08->dw0008;
		if (eax_29 == dwArg08->t0004)
			runtime.efaceeq(gs, eax_29, ecx_28, ebx_30);
	}
}

// 080B4CA0: void type..hash.struct { F uintptr; reflect.name string }(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.struct { F uintptr; reflect.name string }(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04);
	runtime.strhash(gs, mm0, (word32) dwArg04 + 4, dwLoc04);
}

// 080B4D00: void type..eq.struct { F uintptr; reflect.name string }(Register (ptr32 Eq_131983) gs, Stack (ptr32 Eq_131984) dwArg04, Stack (ptr32 Eq_131985) dwArg08)
void type..eq.struct { F uintptr; reflect.name string }(struct Eq_131983 * gs, struct Eq_131984 * dwArg04, struct Eq_131985 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
	{
		Eq_4 edx_27 = dwArg08->t0004;
		Eq_4 ebx_28 = dwArg04->t0008;
		Eq_4 eax_29 = dwArg04->t0004;
		if (ebx_28 == dwArg08->t0008)
		{
			word32 edi_36;
			word32 esi_37;
			runtime.eqstring(eax_29, ebx_28, edx_27, out esi_37, out edi_36);
		}
	}
}

// 080B4D70: void fmt.(*fmt).writePadding(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_float
void fmt.(*fmt).writePadding(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 <= 0x00)
		return;
	Eq_4 edx_23 = dwArg04->t0000;
	Eq_4 ebp_27 = *((word32) edx_23 + 4);
	Eq_4 ebx_111 = *((word32) edx_23 + 8);
	Eq_4 edx_126 = *edx_23;
	word32 esi_31 = dwArg08 + ebp_27;
	if (esi_31 > ebx_111)
	{
		Eq_4 ecx_38 = (word32) dwArg08 + ebx_111 * 0x02;
		word32 edi_254;
		runtime.makeslice(gs, 0x080CF320, ecx_38, ecx_38, out edi_254);
		Eq_4 ecx_53 = dwArg04->t0000;
		Eq_4 esi_58 = *((word32) ecx_53 + 4);
		Eq_4 ecx_59 = *ecx_53;
		if (dwLoc18 <= esi_58)
			esi_58 = dwLoc18;
		word32 ebp_255;
		word32 esi_256;
		word32 edi_257;
		runtime.memmove(dwLoc1C, ecx_59, esi_58, out ebp_255, out esi_256, out edi_257);
		edx_126 = dwLoc1C;
		ebx_111 = dwLoc14;
	}
	word32 edi_102;
	if ((byte) (word32) dwArg04->b000A != 0x00)
		edi_102 = 0x30;
	else
		edi_102 = 0x20;
	if (ebp_27 > esi_31 || esi_31 > ebx_111)
		runtime.panicslice(gs);
	else
	{
		int32 ebx_127 = (word32) edx_126 + (ebp_27 & ebp_27 - ebx_111 >> 0x1F);
		Eq_4 ebp_128 = 0x00;
		while (ebp_128 < dwArg08)
		{
			if (ebp_128 >= dwArg08)
				runtime.panicindex(gs);
			*((word32) ebp_128 + ebx_127) = (byte) edi_102;
			ebp_128 = (word32) ebp_128 + 1;
		}
		Eq_4 eax_137 = dwArg04->t0000;
		*((word32) eax_137 + 4) = esi_31;
		*((word32) eax_137 + 8) = ebx_111;
		if (g_t81576F0 == 0x00)
			*eax_137 = edx_126;
		else
			runtime.writebarrierptr(eax_137, edx_126);
	}
}

// 080B4EC0: void fmt.(*fmt).pad(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).fmt_q
//      fmt.(*fmt).fmt_c
//      fmt.(*fmt).fmt_qc
//      fmt.(*fmt).fmt_float
void fmt.(*fmt).pad(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) dwArg04->b0004 == 0x00 || dwArg04->t0010 == 0x00)
	{
		Eq_4 eax_260 = dwArg04->t0000;
		Eq_4 ecx_263 = *((word32) eax_260 + 4);
		word32 ebx_265 = ecx_263 + dwArg0C;
		Eq_4 ebp_267 = *eax_260;
		Eq_4 esi_268 = *((word32) eax_260 + 8);
		if (ebx_265 > esi_268)
		{
			word32 esi_475;
			runtime.growslice(gs, 0x080CF320, ebp_267, ecx_263, esi_268, ebx_265, out esi_475);
			esi_268 = dwLoc20;
			ebp_267 = dwLoc28;
		}
		if (ebx_265 > esi_268)
			runtime.panicslice(gs);
		else
		{
			word32 ebp_476;
			word32 esi_477;
			word32 edi_478;
			runtime.memmove(ebp_267 + ecx_263, dwArg08, dwArg0C, out ebp_476, out esi_477, out edi_478);
			*((word32) eax_260 + 4) = ebx_265;
			*((word32) eax_260 + 8) = esi_268;
			if (g_t81576F0 == 0x00)
				*eax_260 = ebp_267;
			else
				runtime.writebarrierptr(eax_260, ebp_267);
		}
	}
	else
	{
		unicode/utf8.RuneCount(gs, dwArg08, dwArg0C);
		Eq_4 ecx_47 = dwArg04->t0010 - dwLoc30;
		if ((byte) (word32) dwArg04->b0006 == 0x00)
		{
			fmt.(*fmt).writePadding(gs, dwArg04, ecx_47);
			Eq_4 eax_68 = dwArg04->t0000;
			Eq_4 ecx_70 = *((word32) eax_68 + 4);
			word32 ebx_72 = dwArg0C + ecx_70;
			Eq_4 ebp_103 = *((word32) eax_68 + 8);
			Eq_4 esi_109 = *eax_68;
			if (ebx_72 > ebp_103)
			{
				word32 esi_483;
				runtime.growslice(gs, 0x080CF320, esi_109, ecx_70, ebp_103, ebx_72, out esi_483);
				ebp_103 = dwLoc20;
				esi_109 = dwLoc28;
			}
			if (ebx_72 > ebp_103)
				runtime.panicslice(gs);
			else
			{
				word32 edi_119;
				word32 esi_120;
				word32 ebp_123;
				runtime.memmove(esi_109 + ecx_70, dwArg08, dwArg0C, out ebp_123, out esi_120, out edi_119);
				*((word32) eax_68 + 4) = ebx_72;
				*((word32) eax_68 + 8) = ebp_103;
				if (g_t81576F0 == 0x00)
					*eax_68 = esi_109;
				else
					runtime.writebarrierptr(eax_68, esi_109);
			}
		}
		else
		{
			Eq_4 edx_152 = dwArg04->t0000;
			Eq_4 ebx_154 = *((word32) edx_152 + 4);
			word32 esi_156 = dwArg0C + ebx_154;
			Eq_4 edi_158 = *((word32) edx_152 + 8);
			Eq_4 ecx_159 = *edx_152;
			if (esi_156 > edi_158)
			{
				word32 esi_479;
				runtime.growslice(gs, 0x080CF320, ecx_159, ebx_154, edi_158, esi_156, out esi_479);
				edi_158 = dwLoc20;
				ecx_159 = dwLoc28;
			}
			if (esi_156 > edi_158)
				runtime.panicslice(gs);
			else
			{
				word32 ebp_480;
				word32 esi_481;
				word32 edi_482;
				runtime.memmove(ecx_159 + ebx_154, dwArg08, dwArg0C, out ebp_480, out esi_481, out edi_482);
				*((word32) edx_152 + 4) = esi_156;
				*((word32) edx_152 + 8) = edi_158;
				if (g_t81576F0 == 0x00)
					*edx_152 = ecx_159;
				else
					runtime.writebarrierptr(edx_152, ecx_159);
				fmt.(*fmt).writePadding(gs, dwArg04, ecx_47);
			}
		}
	}
}

// 080B51B0: void fmt.(*fmt).padString(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*fmt).fmt_boolean
//      fmt.(*fmt).fmt_s
//      fmt.(*fmt).fmt_q
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printArg
void fmt.(*fmt).padString(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) dwArg04->b0004 == 0x00 || dwArg04->t0010 == 0x00)
	{
		Eq_4 eax_258 = dwArg04->t0000;
		Eq_4 ecx_261 = *((word32) eax_258 + 4);
		word32 ebx_263 = dwArg0C + ecx_261;
		Eq_4 ebp_265 = *((word32) eax_258 + 8);
		Eq_4 esi_266 = *eax_258;
		if (ebx_263 > ebp_265)
		{
			word32 esi_470;
			runtime.growslice(gs, 0x080CF320, esi_266, ecx_261, ebp_265, ebx_263, out esi_470);
			ebp_265 = dwLoc20;
			esi_266 = dwLoc28;
		}
		if (ebx_263 > ebp_265)
			runtime.panicslice(gs);
		else
		{
			word32 ebp_471;
			word32 esi_472;
			word32 edi_473;
			runtime.memmove(esi_266 + ecx_261, dwArg08, dwArg0C, out ebp_471, out esi_472, out edi_473);
			*((word32) eax_258 + 4) = ebx_263;
			*((word32) eax_258 + 8) = ebp_265;
			if (g_t81576F0 == 0x00)
				*eax_258 = esi_266;
			else
				runtime.writebarrierptr(eax_258, esi_266);
		}
	}
	else
	{
		unicode/utf8.RuneCountInString(gs, dwArg08, dwArg0C);
		Eq_4 ecx_45 = dwArg04->t0010 - dwLoc34;
		if ((byte) (word32) dwArg04->b0006 == 0x00)
		{
			fmt.(*fmt).writePadding(gs, dwArg04, ecx_45);
			Eq_4 eax_66 = dwArg04->t0000;
			Eq_4 ecx_68 = *((word32) eax_66 + 4);
			word32 ebx_70 = dwArg0C + ecx_68;
			Eq_4 ebp_101 = *((word32) eax_66 + 8);
			Eq_4 esi_107 = *eax_66;
			if (ebx_70 > ebp_101)
			{
				word32 esi_478;
				runtime.growslice(gs, 0x080CF320, esi_107, ecx_68, ebp_101, ebx_70, out esi_478);
				ebp_101 = dwLoc20;
				esi_107 = dwLoc28;
			}
			if (ebx_70 > ebp_101)
				runtime.panicslice(gs);
			else
			{
				word32 edi_117;
				word32 esi_118;
				word32 ebp_121;
				runtime.memmove(esi_107 + ecx_68, dwArg08, dwArg0C, out ebp_121, out esi_118, out edi_117);
				*((word32) eax_66 + 4) = ebx_70;
				*((word32) eax_66 + 8) = ebp_101;
				if (g_t81576F0 == 0x00)
					*eax_66 = esi_107;
				else
					runtime.writebarrierptr(eax_66, esi_107);
			}
		}
		else
		{
			Eq_4 edx_150 = dwArg04->t0000;
			Eq_4 ebx_152 = *((word32) edx_150 + 4);
			word32 esi_154 = dwArg0C + ebx_152;
			Eq_4 edi_156 = *((word32) edx_150 + 8);
			Eq_4 ecx_157 = *edx_150;
			if (esi_154 > edi_156)
			{
				word32 esi_474;
				runtime.growslice(gs, 0x080CF320, ecx_157, ebx_152, edi_156, esi_154, out esi_474);
				edi_156 = dwLoc20;
				ecx_157 = dwLoc28;
			}
			if (esi_154 > edi_156)
				runtime.panicslice(gs);
			else
			{
				word32 ebp_475;
				word32 esi_476;
				word32 edi_477;
				runtime.memmove(ecx_157 + ebx_152, dwArg08, dwArg0C, out ebp_475, out esi_476, out edi_477);
				*((word32) edx_150 + 4) = esi_154;
				*((word32) edx_150 + 8) = edi_156;
				if (g_t81576F0 == 0x00)
					*edx_150 = ecx_157;
				else
					runtime.writebarrierptr(edx_150, ecx_157);
				fmt.(*fmt).writePadding(gs, dwArg04, ecx_45);
			}
		}
	}
}

// 080B5490: void fmt.(*fmt).fmt_boolean(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack byte bArg08)
// Called from:
//      fmt.(*pp).fmtBool
void fmt.(*fmt).fmt_boolean(struct Eq_2 * gs, struct Eq_132028 * dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) bArg08 != 0x00)
		fmt.(*fmt).padString(gs, dwArg04, 0x080E0F4A, 0x04);
	else
		fmt.(*fmt).padString(gs, dwArg04, 0x080E102E, 0x05);
}

// 080B5500: void fmt.(*fmt).fmt_unicode(Register int32 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_132585 dwArg0C)
// Called from:
//      fmt.(*pp).fmtInteger
void fmt.(*fmt).fmt_unicode(int32 edi, struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_132585 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_118;
	Eq_132758 (* ebx_27)[];
	word32 ebp_26;
	Eq_132758 ecx_116[] = (char *) &dwArg04->t0014 + 4;
	if ((byte) (word32) dwArg04->b0005 != 0x00)
	{
		edx_118 = dwArg04->t0014;
		if (edx_118 > 0x04)
		{
			if (edx_118 <= 0x3B)
			{
				ebx_27 = (Eq_132758 (*)[]) 0x44;
				ebp_26 = 0x44;
			}
			else
			{
				runtime.makeslice(gs, 0x080CF320, (byte) edx_118.u0 + 9, (byte) edx_118.u0 + 9, out edi);
				bLoc30 = (byte) ((byte) edx_118.u0 + 9);
				ecx_116 = dwLoc28;
				ebp_26 = dwLoc20;
				ebx_27 = dwLoc24;
			}
		}
		else
		{
			ebp_26 = 0x44;
			ebx_27 = (Eq_132758 (*)[]) 0x44;
			edx_118.u0 = 0x04;
		}
	}
	else
	{
		ebp_26 = 0x44;
		ebx_27 = (Eq_132758 (*)[]) 0x44;
		edx_118.u0 = 0x04;
	}
	Eq_132585 esi_217;
	Eq_132758 (* ebx_210)[];
	Eq_4 ebp_216;
	Eq_4 edx_215;
	ui24 eax_24_8_98 = SLICE(dwArg04, word24, 8);
	if ((byte) (word32) dwArg04->b0008 != 0x00)
	{
		int32 edi_104 = SEQ(SLICE(edi, word24, 8), dwArg0C == 0x00) & SEQ(eax_24_8_98, dwArg08 <= 1114111) | SEQ(eax_24_8_98, Test(ULT,false));
		edi = edi_104;
		if ((byte) edi_104 != 0x00)
		{
			edi = strconv.IsPrint(gs, dwArg08);
			if ((byte) (word32) bLoc30 != 0x00)
			{
				if (ebx_27 - 0x01 >= ebx_27)
					runtime.panicindex(gs);
				ui32 ebp_159;
				Mem143[ebx_27 - 0x01 + ecx_116:byte] = 0x27;
				if (dwArg08 < 0x00)
					ebp_159 = ~0x00;
				else if (dwArg08 <= 0x7F)
					ebp_159 = 0x01;
				else if (dwArg08 <= 0x07FF)
					ebp_159 = 0x02;
				else if (dwArg08 <= ~0xDFFE)
					ebp_159 = ~0x00;
				else if (dwArg08 <= 0xFFFF)
					ebp_159 = 0x03;
				else if (dwArg08 <= 1114111)
					ebp_159 = 0x04;
				else
					ebp_159 = ~0x00;
				Eq_132758 (* ecx_168)[] = ebx_27 - 0x01 - ebp_159;
				if (ecx_168 > ebx_27)
					runtime.panicslice(gs);
				int32 ebp_176 = ebp_26 - ecx_168;
				unicode/utf8.EncodeRune(gs, &(ecx_116 + (-ebp_176 >> 0x1F & ecx_168))->t0000, ebx_27 - ecx_168, dwArg08);
				edi = ebp_176;
				if (ecx_168 - 0x01 >= ebx_27)
					runtime.panicindex(gs);
				Mem209[ecx_168 - 0x01 + ecx_116:byte] = 0x27;
				ebx_210 = ecx_168 - (Eq_132758 (*)[]) 0x02;
				if (ecx_168 - (Eq_132758 (*)[]) 0x02 >= ebx_27)
					runtime.panicindex(gs);
				Mem213[ecx_168 - 0x02 + ecx_116:byte] = 0x20;
				edx_215 = edx_118;
				ebp_216 = dwArg08;
				esi_217 = dwArg0C;
l080B55B7:
				while ((byte) (SEQ(SLICE(edi, word24, 8), ebp_216 >= 0x10) & SEQ(SLICE(edx_215, word24, 8), esi_217 == 0x00) | SEQ(SLICE(edx_215, word24, 8), esi_217 > 0x00)) != 0x00)
				{
					Eq_132758 (* edx_364)[] = ebx_210 - 0x01;
					word32 ebp_367 = (word32) (ebp_216 & 0x0F)->b80E26DB;
					if (edx_364 >= ebx_27)
						runtime.panicindex(gs);
					ecx_116[ebx_210 - 0x01].t0000.u0 = (byte) ebp_367;
					ebp_216 = esi_217 << 0x1C | ebp_216 >> 0x04;
					esi_217 >>= 0x04;
					edi = edx_215 - 0x01;
					ebx_210 = edx_364;
					--edx_215;
				}
				if (esi_217 == 0x00 && ebp_216 < 0x11)
				{
					Eq_132758 (* edx_273)[] = ebx_210 - (Eq_132758 (*)[]) 0x01;
					word32 ebp_275 = (word32) *((word32) ebp_216 + 135145179);
					if (edx_273 < ebx_27)
					{
						Mem285[ebx_210 - 0x01 + ecx_116:byte] = SLICE(ebp_275, byte, 0);
						int32 ebx_290;
						for (ebx_290 = edx_215 - 0x01; ebx_290 > 0x00; --ebx_290)
						{
							Eq_132758 (* ebp_356)[] = edx_273 - (Eq_132758 (*)[]) 0x01;
							if (ebp_356 >= ebx_27)
								runtime.panicindex(gs);
							Mem359[edx_273 - 0x01 + ecx_116:byte] = 0x30;
							edx_273 = ebp_356;
						}
						if (edx_273 - (Eq_132758 (*)[]) 0x01 >= ebx_27)
							runtime.panicindex(gs);
						else
						{
							Mem302[edx_273 - 0x01 + ecx_116:byte] = 0x2B;
							Eq_132758 (* ebx_303)[] = edx_273 - (Eq_132758 (*)[]) 0x02;
							if (ebx_303 >= ebx_27)
								runtime.panicindex(gs);
							else
							{
								Mem306[edx_273 - 0x02 + ecx_116:byte] = 0x55;
								byte al_313 = (byte) (word32) dwArg04->b000A;
								dwArg04->b000A = 0x00;
								fmt.(*fmt).pad(gs, dwArg04, &(ecx_116 + (ebx_303 - ebp_26 >> 0x1F & ebx_303))->t0000, ebx_27 - ebx_303);
								dwArg04->b000A = (byte) (word32) al_313;
								return;
							}
						}
					}
				}
				runtime.panicindex(gs);
			}
		}
	}
	esi_217 = dwArg0C;
	ebp_216 = dwArg08;
	edx_215 = edx_118;
	ebx_210 = ebx_27;
	goto l080B55B7;
}

// 080B58A0: void fmt.(*fmt).fmt_integer(Register Eq_132869 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 qwArg08, Stack int32 dwArg10, Stack byte bArg14, Stack (ptr32 Eq_132875) dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      fmt.(*pp).fmt0x64
//      fmt.(*pp).fmtInteger
//      fmt.(*pp).fmtBytes
void fmt.(*fmt).fmt_integer(Eq_132869 ebx, struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 qwArg08, int32 dwArg10, byte bArg14, struct Eq_132875 * dwArg18, Eq_4 dwArg1C)
{
	Eq_4 dwArg0C = SLICE(qwArg08, word32, 32);
	Eq_4 dwArg08 = (word32) qwArg08;
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_34 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ui24 ebx_24_8_217;
	byte bl_47;
	if ((byte) (word32) bArg14 != 0x00)
	{
		ui32 ebx_44 = SEQ(ebx_24_8, dwArg0C < 0x00) | SEQ(ecx_24_8_34, dwArg0C == 0x00) & SEQ(ebx_24_8, Test(ULT,false));
		bl_47 = (byte) ebx_44;
		ebx_24_8_217 = SLICE(ebx_44, word24, 8);
	}
	else
	{
		bl_47 = 0x00;
		ebx_24_8_217 = 0x00;
	}
	Eq_4 edx_108;
	Eq_4 ecx_104;
	if (bl_47 != 0x00)
	{
		ui64 edx_ecx_763 = 0x00 - qwArg08;
		ecx_104 = (word32) edx_ecx_763;
		edx_108 = SLICE(edx_ecx_763, word32, 32);
	}
	else
	{
		ecx_104 = dwArg08;
		edx_108 = dwArg0C;
	}
	Eq_4 esi_129;
	byte bl_181;
	Eq_4 edi_128;
	Eq_133223 (* ebp_130)[] = (char *) &dwArg04->t0014 + 4;
	if ((byte) (word32) dwArg04->b0004 != 0x00 || (byte) ((word32) dwArg04->b0005) != 0x00)
	{
		Eq_4 esi_100 = (word32) dwArg04->t0014 + ((word32) dwArg04->t0010 + 3);
		if (esi_100 <= 0x44)
		{
			esi_129.u0 = 0x44;
			edi_128.u0 = 0x44;
			bl_181 = bl_47;
		}
		else
		{
			word32 edi_929;
			runtime.makeslice(gs, 0x080CF320, esi_100, esi_100, out edi_929);
			word32 ebx_134 = (word32) bl_47;
			edi_128 = dwLoc24;
			esi_129 = dwLoc28;
			ebp_130 = dwLoc2C;
			bl_181 = (byte) ebx_134;
			ebx_24_8_217 = SLICE(ebx_134, word24, 8);
		}
	}
	else
	{
		esi_129.u0 = 0x44;
		edi_128.u0 = 0x44;
		bl_181 = bl_47;
	}
	Eq_4 edi_163;
	Eq_4 edx_211 = edx_108;
	Eq_4 ecx_207 = ecx_104;
	ui24 eax_24_8_215 = SLICE(dwArg04, word24, 8);
	if ((byte) (word32) dwArg04->b0005 != 0x00)
	{
		edi_163 = dwArg04->t0014;
		if (edi_163 == 0x00 && (byte) (SEQ(eax_24_8_215, edx_108 == 0x00) & SEQ(ebx_24_8_217, ecx_104 == 0x00)) != 0x00)
		{
			byte cl_232 = (byte) (word32) dwArg04->b000A;
			dwArg04->b000A = 0x00;
			fmt.(*fmt).writePadding(gs, dwArg04, dwArg04->t0010);
			dwArg04->b000A = (byte) (word32) cl_232;
			return;
		}
	}
	else if ((byte) (word32) dwArg04->b000A != 0x00)
	{
		if ((byte) (word32) dwArg04->b0004 != 0x00)
		{
			edi_163 = dwArg04->t0010;
			if (bl_181 != 0x00 || ((byte) ((word32) dwArg04->b0007) != 0x00 || (byte) ((word32) dwArg04->b0009) != 0x00))
				--edi_163;
		}
		else
			edi_163.u0 = 0x00;
	}
	else
		edi_163.u0 = 0x00;
	Eq_4 esi_319;
	ui24 eax_24_8_291 = SLICE(dwArg10, word24, 8);
	ui24 eax_24_8_368 = SLICE(dwArg10, word24, 8);
	ui24 eax_24_8_465 = SLICE(dwArg10, word24, 8);
	ui24 eax_24_8_519 = SLICE(dwArg10, word24, 8);
	if (dwArg10 > 0x08)
	{
		if (dwArg10 == 0x0A)
		{
			esi_319 = esi_129;
			while ((byte) (SEQ(eax_24_8_368, edx_211 > 0x00) | SEQ(SLICE(edi_163, word24, 8), ecx_207 >= 0x0A) & SEQ(eax_24_8_368, edx_211 == 0x00)) != 0x00)
			{
				runtime.uint64div(gs, ecx_207, edx_211, 0x0A, 0x00);
				Eq_133120 dl_415 = (byte) ((word32) ecx_207 + 48 - (word32) (dwLoc28 * 0x0A));
				if (esi_319 - 0x01 >= esi_129)
					runtime.panicindex(gs);
				Mem416[esi_319 - 0x01 + ebp_130:byte] = dl_415;
				eax_24_8_368 = SLICE(dwArg10, word24, 8);
				ecx_207 = dwLoc28;
				edx_211 = dwLoc24;
				--esi_319;
			}
		}
		else
		{
			if (dwArg10 != 0x10)
				goto l080B5E4D;
			esi_319 = esi_129;
			while ((byte) (SEQ(SLICE(edi_163, word24, 8), edx_211 == 0x00) & SEQ(eax_24_8_291, ecx_207 >= 0x10) | SEQ(eax_24_8_291, edx_211 > 0x00)) != 0x00)
			{
				Eq_4 ecx_315 = ecx_207 & 0x0F;
				if (ecx_315 >= dwArg1C)
				{
l080B5E3F:
					runtime.panicindex(gs);
				}
				Eq_4 edi_320 = esi_319 - 0x01;
				byte cl_325 = SLICE((word32) Mem312[ecx_315 + dwArg18:byte], byte, 0);
				if (edi_320 >= esi_129)
					goto l080B5E3F;
				Mem327[esi_319 - 0x01 + ebp_130:byte] = cl_325;
				ecx_207 = edx_211 << 0x1C | ecx_207 >> 0x04;
				edx_211 >>= 0x04;
				eax_24_8_291 = SLICE(dwArg10, word24, 8);
				esi_319 = edi_320;
			}
		}
l080B59C1:
		if (edx_211 == 0x00 && ecx_207 < dwArg1C)
		{
			Eq_4 edx_549 = esi_319 - 0x01;
			byte cl_558 = SLICE((word32) Mem539[dwArg18 + ecx_207:byte], byte, 0);
			if (edx_549 < esi_129)
			{
				Mem562[esi_319 - 0x01 + ebp_130:byte] = cl_558;
				while (edx_549 > 0x00 && edi_163 > esi_129 - edx_549)
				{
					Eq_4 ebx_725 = edx_549 - (Eq_133223 (*)[]) 0x01;
					if (ebx_725 >= esi_129)
						runtime.panicindex(gs);
					Mem728[edx_549 - 0x01 + ebp_130:byte] = 0x30;
					edx_549 = ebx_725;
				}
				Eq_4 eax_589;
				bool Z_645;
				if ((byte) (word32) dwArg04->b0008 == 0x00)
				{
					Z_645 = SLICE(cond((byte) (word32) bl_47), bool, 2);
					eax_589 = edx_549;
					goto l080B5A61;
				}
				if (dwArg10 != 0x08)
				{
					if (dwArg10 != 0x10)
					{
						Z_645 = SLICE(cond((byte) (word32) bl_47), bool, 2);
						eax_589 = edx_549;
						goto l080B5A61;
					}
					if (dwArg1C > 0x10)
					{
						Eq_133223 bl_614 = (byte) (word32) dwArg18->b0010;
						if (edx_549 - (Eq_133223 (*)[]) 0x01 < esi_129)
						{
							Mem617[edx_549 - 0x01 + ebp_130:byte] = bl_614;
							eax_589 = edx_549 - (Eq_133223 (*)[]) 0x02;
							if (eax_589 >= esi_129)
								runtime.panicindex(gs);
							Mem621[edx_549 - 0x02 + ebp_130:byte] = 0x30;
							Z_645 = SLICE(cond((byte) (word32) bl_47), bool, 2);
l080B5A61:
							Eq_4 edx_664;
							if (!Z_645)
							{
								edx_664 = eax_589 - (Eq_133223 (*)[]) 0x01;
								if (edx_664 >= esi_129)
									runtime.panicindex(gs);
								Mem679[eax_589 - 0x01 + ebp_130:byte] = 0x2D;
							}
							else if ((byte) (word32) dwArg04->b0007 != 0x00)
							{
								edx_664 = eax_589 - (Eq_133223 (*)[]) 0x01;
								if (edx_664 >= esi_129)
									runtime.panicindex(gs);
								Mem675[eax_589 - 0x01 + ebp_130:byte] = 0x2B;
							}
							else if ((byte) (word32) dwArg04->b0009 != 0x00)
							{
								edx_664 = eax_589 - (Eq_133223 (*)[]) 0x01;
								if (edx_664 >= esi_129)
									runtime.panicindex(gs);
								Mem671[eax_589 - 0x01 + ebp_130:byte] = 0x20;
							}
							else
								edx_664 = eax_589;
							byte al_689 = (byte) (word32) dwArg04->b000A;
							dwArg04->b000A = 0x00;
							if (edx_664 > esi_129)
								runtime.panicslice(gs);
							else
							{
								fmt.(*fmt).pad(gs, dwArg04, &(ebp_130 + (edx_664 - edi_128 >> 0x1F & edx_664))->t0000, esi_129 - edx_664);
								dwArg04->b000A = (byte) (word32) al_689;
								return;
							}
						}
					}
					runtime.panicindex(gs);
				}
				else
				{
					if (edx_549 >= esi_129)
						runtime.panicindex(gs);
					if (SLICE((word32) Mem577[ebp_130 + edx_549:byte], byte, 0) != 0x30)
					{
						eax_589 = edx_549 - (Eq_133223 (*)[]) 0x01;
						if (eax_589 >= esi_129)
							runtime.panicindex(gs);
						Mem640[edx_549 - 0x01 + ebp_130:byte] = 0x30;
						Z_645 = SLICE(cond((byte) (word32) bl_47), bool, 2);
					}
					else
					{
						Z_645 = SLICE(cond((byte) (word32) bl_47), bool, 2);
						eax_589 = edx_549;
					}
					goto l080B5A61;
				}
			}
		}
		runtime.panicindex(gs);
	}
	else
	{
		if (dwArg10 == 0x02)
		{
			esi_319 = esi_129;
			while ((byte) (SEQ(eax_24_8_519, edx_211 > 0x00) | SEQ(SLICE(edi_163, word24, 8), ecx_207 >= 0x02) & SEQ(eax_24_8_519, edx_211 == 0x00)) != 0x00)
			{
				byte cl_737 = (byte) ((ecx_207 & 0x01) + 0x30);
				Eq_4 edi_734 = esi_319 - 0x01;
				if (edi_734 >= esi_129)
					runtime.panicindex(gs);
				ebp_130[esi_319 - 0x01].t0000.u0 = cl_737;
				ecx_207 = edx_211 << 0x1F | ecx_207 >> 0x01;
				edx_211 >>= 0x01;
				eax_24_8_519 = SLICE(dwArg10, word24, 8);
				esi_319 = edi_734;
			}
			goto l080B59C1;
		}
		if (dwArg10 == 0x08)
		{
			esi_319 = esi_129;
			while ((byte) (SEQ(eax_24_8_465, edx_211 > 0x00) | SEQ(SLICE(edi_163, word24, 8), edx_211 == 0x00) & SEQ(eax_24_8_465, ecx_207 >= 0x08)) != 0x00)
			{
				Eq_133139 cl_486 = (byte) ((ecx_207 & 0x07) + 0x30);
				Eq_4 edi_483 = esi_319 - 0x01;
				if (edi_483 >= esi_129)
					runtime.panicindex(gs);
				Mem488[esi_319 - 0x01 + ebp_130:byte] = cl_486;
				ecx_207 = edx_211 << 0x1D | ecx_207 >> 0x03;
				edx_211 >>= 0x03;
				eax_24_8_465 = SLICE(dwArg10, word24, 8);
				esi_319 = edi_483;
			}
			goto l080B59C1;
		}
l080B5E4D:
		runtime.gopanic(gs);
	}
}

// 080B5E80: void fmt.(*fmt).truncate(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*fmt).fmt_s
//      fmt.(*fmt).fmt_q
void fmt.(*fmt).truncate(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) dwArg04->b0005 != 0x00)
	{
		Eq_4 eax_24 = dwArg04->t0014;
		Eq_4 ecx_25 = 0x00;
		while (ecx_25 < dwArg0C)
		{
			Eq_4 ebp_64;
			if ((word32) Mem29[dwArg08 + ecx_25:byte] < 0x80)
				ebp_64 = (word32) ecx_25 + 1;
			else
			{
				runtime.decoderune(gs, dwArg08, dwArg0C, ecx_25);
				ebp_64 = dwLoc0C;
			}
			--eax_24;
			if (eax_24 < 0x00)
			{
				if (ecx_25 > dwArg0C)
					runtime.panicslice(gs);
				else
					return;
			}
			ecx_25 = ebp_64;
		}
	}
}

// 080B5F40: void fmt.(*fmt).fmt_s(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).fmtString
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).handleMethods
//      fmt.(*pp).printArg
void fmt.(*fmt).fmt_s(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.(*fmt).truncate(gs, dwArg04, dwArg08, dwArg0C);
	fmt.(*fmt).padString(gs, dwArg04, dwLoc08, dwLoc04);
}

// 080B5FA0: void fmt.(*fmt).fmt_sbx(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack (ptr32 Eq_133499) dwArg1C, Stack Eq_133500 dwArg20)
// Called from:
//      fmt.(*fmt).fmt_sx
//      fmt.(*fmt).fmt_bx
void fmt.(*fmt).fmt_sbx(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, struct Eq_133499 * dwArg1C, Eq_133500 dwArg20)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_21;
	if (dwArg10 != 0x00)
		ecx_21 = dwArg14;
	else
		ecx_21 = dwArg0C;
	Eq_4 ebx_31;
	if ((byte) (word32) dwArg04->b0005 != 0x00)
	{
		ebx_31 = dwArg04->t0014;
		if (ebx_31 < ecx_21)
		{
l080B5FE4:
			Eq_4 ebx_101 = ebx_31 << 0x01;
			if (ebx_101 <= 0x00)
			{
				if ((byte) (word32) dwArg04->b0004 != 0x00)
					fmt.(*fmt).writePadding(gs, dwArg04, dwArg04->t0010);
				return;
			}
			else
			{
				Eq_4 ecx_105;
				if ((byte) (word32) dwArg04->b0009 != 0x00)
				{
					Eq_4 ecx_119;
					if ((byte) (word32) dwArg04->b0008 != 0x00)
						ecx_119 = ebx_31 << 0x02;
					else
						ecx_119 = ebx_101;
					ecx_105 = (word32) ebx_31 + (ecx_119 - 0x01);
				}
				else
				{
					if ((byte) (word32) dwArg04->b0008 != 0x00)
						ebx_101 = (word32) ebx_101 + 2;
					ecx_105 = ebx_101;
				}
				if ((byte) (word32) dwArg04->b0004 != 0x00)
				{
					Eq_4 ebp_150 = dwArg04->t0010;
					if (ebp_150 > ecx_105 && (byte) ((word32) dwArg04->b0006) == 0x00)
						fmt.(*fmt).writePadding(gs, dwArg04, ebp_150 - ecx_105);
				}
				Eq_4 ecx_198;
				Eq_4 ebp_189 = dwArg04->t0000;
				Eq_4 esi_190 = *((word32) ebp_189 + 8);
				Eq_4 edi_191 = *((word32) ebp_189 + 4);
				Eq_4 ebp_192 = *ebp_189;
				if ((byte) (word32) dwArg04->b0008 != 0x00)
				{
					if (dwArg20 <= 0x10)
						runtime.panicindex(gs);
					ecx_198 = (word32) edi_191 + 2;
					byte al_209 = (byte) (word32) dwArg1C->b0010;
					if ((word32) edi_191 + 2 > esi_190)
					{
						word32 esi_894;
						runtime.growslice(gs, 0x080CF320, ebp_192, edi_191, esi_190, (word32) edi_191 + 2, out esi_894);
						ebp_192 = dwLoc28;
						esi_190 = dwLoc20;
						ecx_198 = dwLoc24 + 0x02;
						al_209 = (byte) (word32) al_209;
					}
					Mem239[ebp_192 + edi_191:byte] = 0x30;
					*((word32) edi_191 + ((word32) ebp_192 + 1)) = al_209;
				}
				else
					ecx_198 = edi_191;
				Eq_4 eax_243 = 0x00;
				while (eax_243 < ebx_31)
				{
					Eq_4 edx_328;
					bool Z_430;
					if ((byte) (word32) dwArg04->b0009 != 0x00)
					{
						if (eax_243 > 0x00)
						{
							Eq_4 edi_337 = (word32) ecx_198 + 1;
							if (edi_337 > esi_190)
							{
								word32 esi_895;
								runtime.growslice(gs, 0x080CF320, ebp_192, ecx_198, esi_190, edi_337, out esi_895);
								ebp_192 = dwLoc28;
								esi_190 = dwLoc20;
								edi_337 = dwLoc24 + 0x01;
							}
							Mem368[ebp_192 + ecx_198:byte] = 0x20;
							if ((byte) (word32) dwArg04->b0008 != 0x00)
							{
								if (dwArg20 <= 0x10)
									runtime.panicindex(gs);
								edx_328 = (word32) edi_337 + 2;
								byte bl_392 = (byte) (word32) dwArg1C->b0010;
								if (edx_328 <= esi_190)
									Z_430 = SLICE(cond(dwArg10), bool, 2);
								else
								{
									word32 esi_896;
									runtime.growslice(gs, 0x080CF320, ebp_192, edi_337, esi_190, edx_328, out esi_896);
									ebp_192 = dwLoc28;
									esi_190 = dwLoc20;
									edx_328 = dwLoc24 + 0x02;
									Z_430 = SLICE(cond(dwArg10), bool, 2);
									bl_392 = (byte) (word32) bl_392;
								}
								Mem426[ebp_192 + edi_337:byte] = 0x30;
								*((word32) edi_337 + ((word32) ebp_192 + 1)) = bl_392;
							}
							else
							{
								Z_430 = SLICE(cond(dwArg10), bool, 2);
								edx_328 = edi_337;
							}
						}
						else
						{
							Z_430 = SLICE(cond(dwArg10), bool, 2);
							edx_328 = ecx_198;
						}
					}
					else
					{
						Z_430 = SLICE(cond(dwArg10), bool, 2);
						edx_328 = ecx_198;
					}
					word32 edi_449;
					if (!Z_430)
					{
						if (eax_243 >= dwArg14)
							runtime.panicindex(gs);
						edi_449 = (word32) Mem439[dwArg10 + eax_243:byte];
					}
					else
					{
						if (eax_243 >= dwArg0C)
							runtime.panicindex(gs);
						edi_449 = (word32) Mem439[dwArg08 + eax_243:byte];
					}
					byte al_462 = (byte) edi_449;
					Eq_133500 eax_482 = (word32) ((byte) edi_449 >> 0x04);
					if (eax_482 >= dwArg20)
					{
l080B63A8:
						runtime.panicindex(gs);
					}
					word32 edi_490 = (word32) Mem464[dwArg1C + eax_482:byte];
					ui32 eax_491 = (word32) al_462;
					if ((eax_491 & 0x0F) >= dwArg20)
						goto l080B63A8;
					Eq_4 ebx_500 = (word32) edx_328 + 2;
					word32 eax_501 = (word32) dwArg1C[(eax_491 & 0x0F) / 0x0011];
					if (ebx_500 > esi_190)
					{
						word32 esi_897;
						runtime.growslice(gs, 0x080CF320, ebp_192, edx_328, esi_190, ebx_500, out esi_897);
						ebp_192 = dwLoc28;
						esi_190 = dwLoc20;
						ebx_500 = dwLoc24 + 0x02;
						eax_501 = (word32) (byte) eax_501;
						edi_490 = (word32) (byte) edi_490;
					}
					Mem553[ebp_192 + edx_328:byte] = SLICE(edi_490, byte, 0);
					*((word32) edx_328 + ((word32) ebp_192 + 1)) = (byte) eax_501;
					eax_243 = (word32) eax_243 + 1;
					ecx_198 = ebx_500;
				}
				Eq_4 eax_252 = dwArg04->t0000;
				*((word32) eax_252 + 4) = ecx_198;
				*((word32) eax_252 + 8) = esi_190;
				if (g_t81576F0 == 0x00)
					*eax_252 = ebp_192;
				else
					runtime.writebarrierptr(eax_252, ebp_192);
				if ((byte) (word32) dwArg04->b0004 != 0x00)
				{
					Eq_4 eax_282 = dwArg04->t0010;
					if (eax_282 > ecx_105 && (byte) ((word32) dwArg04->b0006) != 0x00)
						fmt.(*fmt).writePadding(gs, dwArg04, eax_282 - ecx_105);
				}
				return;
			}
		}
	}
	ebx_31 = ecx_21;
	goto l080B5FE4;
}

// 080B63E0: void fmt.(*fmt).fmt_sx(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_133499) dwArg10, Stack Eq_133500 dwArg14)
// Called from:
//      fmt.(*pp).fmtString
void fmt.(*fmt).fmt_sx(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_133499 * dwArg10, Eq_133500 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.(*fmt).fmt_sbx(gs, dwArg04, dwArg08, dwArg0C, 0x00, 0x00, dwArg10, dwArg14);
}

// 080B6450: void fmt.(*fmt).fmt_bx(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_133499) dwArg14, Stack Eq_133500 dwArg18)
// Called from:
//      fmt.(*pp).fmtBytes
void fmt.(*fmt).fmt_bx(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_133499 * dwArg14, Eq_133500 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.(*fmt).fmt_sbx(gs, dwArg04, 0x00, 0x00, dwArg08, dwArg0C, dwArg14, dwArg18);
}

// 080B64C0: void fmt.(*fmt).fmt_q(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).fmtString
//      fmt.(*pp).fmtBytes
void fmt.(*fmt).fmt_q(struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.(*fmt).truncate(gs, dwArg04, dwArg08, dwArg0C);
	byte bLoc3C_225 = (byte) dwArg0C;
	if ((byte) (word32) dwArg04->b0008 != 0x00)
	{
		strconv.CanBackquote(gs, dwLoc38, dwLoc34);
		if ((byte) (word32) bLoc3C_225 != 0x00)
		{
			runtime.concatstring3(gs, fp - 0x20);
			fmt.(*fmt).padString(gs, dwArg04, dwLoc28, dwLoc24);
			return;
		}
	}
	if ((byte) (word32) dwArg04->b0007 != 0x00)
	{
		strconv.AppendQuoteToASCII(gs, (char *) &dwArg04->t0014 + 4, 0x00, 0x44, dwLoc38, dwLoc34);
		fmt.(*fmt).pad(gs, dwArg04, dwLoc30, dwLoc2C);
	}
	else
	{
		strconv.AppendQuote(gs, (char *) &dwArg04->t0014 + 4, 0x00, 0x44, dwLoc38, dwLoc34);
		fmt.(*fmt).pad(gs, dwArg04, dwLoc30, dwLoc2C);
	}
}

// 080B6640: void fmt.(*fmt).fmt_c(Register Eq_132869 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_132585 fArg0C)
// Called from:
//      fmt.(*pp).fmtInteger
void fmt.(*fmt).fmt_c(Eq_132869 ebx, struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_132585 fArg0C)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_28 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	if ((byte) (SEQ(ecx_24_8_28, dwArg0C > 0x00) | SEQ(ebx_24_8, dwArg0C == 0x00) & SEQ(ecx_24_8_28, dwArg08 > 1114111)) != 0x00)
		dwArg08.u0 = 0xFF0000FD;
	unicode/utf8.EncodeRune(gs, (char *) &dwArg04->t0014 + 4, 0x04, dwArg08);
	if (dwLoc08 > 0x44)
		runtime.panicslice(gs);
	else
		fmt.(*fmt).pad(gs, dwArg04, (char *) &dwArg04->t0014 + 4, dwLoc08);
}

// 080B66F0: void fmt.(*fmt).fmt_qc(Register Eq_133997 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack Eq_4 dwArg08, Stack Eq_132585 dwArg0C)
// Called from:
//      fmt.(*pp).fmtInteger
void fmt.(*fmt).fmt_qc(Eq_133997 ebx, struct Eq_2 * gs, struct Eq_132028 * dwArg04, Eq_4 dwArg08, Eq_132585 dwArg0C)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_25 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	if ((byte) (SEQ(SLICE(dwArg0C, word24, 8), dwArg0C > 0x00) | SEQ(ecx_24_8_25, dwArg0C == 0x00) & SEQ(ebx_24_8, dwArg08 > 1114111)) != 0x00)
		dwArg08.u0 = 0xFF0000FD;
	if ((byte) (word32) dwArg04->b0007 != 0x00)
	{
		strconv.AppendQuoteRuneToASCII(gs, (char *) &dwArg04->t0014 + 4, 0x00, 0x44, dwArg08);
		fmt.(*fmt).pad(gs, dwArg04, dwLoc0C, dwLoc08);
	}
	else
	{
		strconv.AppendQuoteRune(gs, (char *) &dwArg04->t0014 + 4, 0x00, 0x44, dwArg08);
		fmt.(*fmt).pad(gs, dwArg04, dwLoc0C, dwLoc08);
	}
}

// 080B67E0: void fmt.(*fmt).fmt_float(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_132028) dwArg04, Stack real64 rArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      fmt.(*pp).fmtFloat
void fmt.(*fmt).fmt_float(struct Eq_2 * gs, struct Eq_132028 * dwArg04, real64 rArg08, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp - 0x14 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_24;
	if ((byte) (word32) dwArg04->b0005 != 0x00)
		ecx_24 = dwArg04->t0014;
	else
		ecx_24 = dwArg18;
	byte dl_40 = (byte) dwArg14;
	strconv.AppendFloat(gs, (char *) &dwArg04->t0014 + 4, 0x01, 0x44, (real64) (uint128) (uint64) rArg08, dl_40, dwArg10);
	Eq_4 eax_133 = dwLoc6C;
	Eq_4 ecx_165 = dwLoc70;
	Eq_4 dwLoc80_996 = SEQ(nLoc7F, dl_40);
	if (dwLoc70 <= 0x01)
		runtime.panicindex(gs);
	else
	{
		byte bl_65 = (byte) (word32) *((word32) dwLoc74 + 1);
		Eq_4 ebp_169 = (word32) dwLoc74 + 1;
		if (bl_65 == 0x2D || bl_65 == 0x2B)
		{
			ecx_165 = dwLoc70 - 0x01;
			eax_133 = dwLoc6C - 0x01;
		}
		else
		{
			*dwLoc74 = 0x2B;
			ebp_169 = dwLoc74;
		}
		if ((byte) (word32) dwArg04->b0009 != 0x00)
		{
			if (ecx_165 <= 0x00)
				runtime.panicindex(gs);
			if ((byte) (word32) *ebp_169 == 0x2B && (byte) ((word32) dwArg04->b0007) == 0x00)
				*ebp_169 = 0x20;
		}
		if (ecx_165 <= 0x01)
			runtime.panicindex(gs);
		else
		{
			byte bl_114 = (byte) (word32) *((word32) ebp_169 + 1);
			Eq_4 esi_113 = (word32) ebp_169 + 1;
			if (bl_114 == 0x49 || bl_114 == 0x4E)
			{
				byte bl_123 = (byte) (word32) dwArg04->b000A;
				dwArg04->b000A = 0x00;
				if ((byte) (word32) *((word32) ebp_169 + 1) == 0x4E && ((byte) ((word32) dwArg04->b0009) == 0x00 && (byte) ((word32) dwArg04->b0007) == 0x00))
				{
					--ecx_165;
					ebp_169 = esi_113;
				}
				fmt.(*fmt).pad(gs, dwArg04, ebp_169, ecx_165);
				dwArg04->b000A = (byte) (word32) bl_123;
			}
			else
			{
				Eq_4 ecx_205;
				Eq_4 edx_204;
				Eq_4 eax_206;
				if ((byte) (word32) dwArg04->b0008 != 0x00)
				{
					if (dwArg14 != 0x62)
					{
						Eq_4 ebx_219;
						if (dwArg14 == 0x47 || (dwArg14 == 0x67 || dwArg14 == 118))
						{
							ebx_219 = ecx_24;
							if (ecx_24 == ~0x00)
								ebx_219.u0 = 0x06;
						}
						else
							ebx_219.u0 = 0x00;
						Eq_4 esi_237 = 0x01;
						word32 edi_238 = 0x00;
						Eq_4 dwLoc64_1058 = 0x00;
						Eq_4 dwLoc20_1066 = fp - 0x3D;
						Eq_4 dwLoc60_1061 = 0x05;
						Eq_4 eax_254 = eax_133;
						Eq_4 ecx_255 = ecx_165;
						ebp_282 = ebp_169;
						while (true)
						{
							Eq_4 ebp_282;
							if (esi_237 >= ecx_255)
								break;
							if (esi_237 >= ecx_255)
								runtime.panicindex(gs);
							word32 edx_846;
							Eq_4 edi_843;
							byte dl_742 = SLICE((word32) Mem259[ebp_282 + esi_237:byte], byte, 0);
							if (dl_742 == 0x2E)
							{
								edx_846 = 0x01;
								edi_843 = dwLoc20_1066;
							}
							else if (dl_742 != 0x45 && dl_742 != 101)
							{
								--ebx_219;
								edx_846 = edi_238;
								edi_843 = dwLoc20_1066;
							}
							else
							{
								Eq_4 ecx_763 = ecx_255 - esi_237;
								byte al_757 = (byte) edi_238;
								word32 ebx_765 = ecx_763 + dwLoc64_1058;
								Eq_4 eax_772 = (word32) ebp_282 + (esi_237 - eax_254 >> 0x1F & esi_237);
								Eq_4 ebp_773 = dwLoc60_1061;
								if (ebx_765 > dwLoc60_1061)
								{
									word32 esi_1192;
									runtime.growslice(gs, 0x080CF320, dwLoc20_1066, dwLoc64_1058, dwLoc60_1061, ebx_765, out esi_1192);
									ebp_773 = dwArg10;
									dwLoc20_1066 = dwLoc80_996;
								}
								if (ebx_765 > ebp_773)
									runtime.panicslice(gs);
								word32 esi_1194;
								word32 ebp_1193;
								word32 edi_1195;
								runtime.memmove(dwLoc64_1058 + dwLoc20_1066, eax_772, ecx_763, out ebp_1193, out esi_1194, out edi_1195);
								dwLoc60_1061 = ebp_773;
								if (esi_237 > eax_133)
									runtime.panicslice(gs);
								eax_254 = eax_133;
								ebp_282 = ebp_169;
								ecx_255 = esi_237;
								edi_843 = dwLoc20_1066;
								dwLoc64_1058 = ebx_765;
								edx_846 = (word32) al_757;
							}
							esi_237 = (word32) esi_237 + 1;
							dwLoc20_1066 = edi_843;
							edi_238 = edx_846;
						}
						Eq_4 eax_274 = eax_254;
						if ((byte) edi_238 == 0x00)
						{
							Eq_4 esi_276 = (word32) ecx_255 + 1;
							if (esi_276 > eax_254)
							{
								word32 esi_1196;
								runtime.growslice(gs, 0x080CF320, ebp_282, ecx_255, eax_254, esi_276, out esi_1196);
								ebp_282 = dwLoc80_996;
								esi_276 = (word32) ecx_24 + 1;
								eax_274 = dwArg10;
							}
							Mem309[ebp_282 + ecx_255:byte] = 0x2E;
							ecx_255 = esi_276;
						}
						for (; ebx_219 > 0x00; --ebx_219)
						{
							Eq_4 esi_703 = (word32) ecx_255 + 1;
							if (esi_703 > eax_274)
							{
								word32 esi_1197;
								runtime.growslice(gs, 0x080CF320, ebp_282, ecx_255, eax_274, esi_703, out esi_1197);
								ebp_282 = dwLoc80_996;
								esi_703 = (word32) ecx_24 + 1;
								eax_274 = dwArg10;
							}
							Mem734[ebp_282 + ecx_255:byte] = 0x30;
							ecx_255 = esi_703;
						}
						word32 esi_319 = dwLoc64_1058 + ecx_255;
						if (esi_319 > eax_274)
						{
							word32 esi_1198;
							runtime.growslice(gs, 0x080CF320, ebp_282, ecx_255, eax_274, esi_319, out esi_1198);
							ebp_282 = dwLoc80_996;
							eax_274 = dwArg10;
						}
						if (esi_319 > eax_274)
							runtime.panicslice(gs);
						word32 ebp_1199;
						word32 esi_1200;
						word32 edi_1201;
						runtime.memmove(ebp_282 + ecx_255, dwLoc20_1066, dwLoc64_1058, out ebp_1199, out esi_1200, out edi_1201);
						eax_206 = ebp_282;
						ecx_205 = eax_274;
						edx_204 = esi_319;
					}
					else
					{
						edx_204 = ecx_165;
						ecx_205 = eax_133;
						eax_206 = ebp_169;
					}
				}
				else
				{
					edx_204 = ecx_165;
					ecx_205 = eax_133;
					eax_206 = ebp_169;
				}
				if ((byte) (word32) dwArg04->b0007 == 0x00)
				{
					if (edx_204 <= 0x00)
						runtime.panicindex(gs);
					if ((byte) (word32) *eax_206 == 0x2B)
					{
						fmt.(*fmt).pad(gs, dwArg04, (word32) eax_206 + (0x01 - ecx_205 >> 0x1F & 0x01), edx_204 - 0x01);
						return;
					}
				}
				if ((byte) (word32) dwArg04->b000A == 0x00 || ((byte) ((word32) dwArg04->b0004) == 0x00 || dwArg04->t0010 <= edx_204))
					fmt.(*fmt).pad(gs, dwArg04, eax_206, edx_204);
				else
				{
					Eq_4 ebp_493 = dwArg04->t0000;
					if (edx_204 <= 0x00)
						runtime.panicindex(gs);
					else
					{
						word32 esi_501 = (word32) *eax_206;
						Eq_4 edi_502 = *((word32) ebp_493 + 8);
						Eq_4 eax_503 = *((word32) ebp_493 + 4);
						Eq_4 ecx_504 = *ebp_493;
						if ((word32) eax_503 + 1 > edi_502)
						{
							word32 esi_1187;
							runtime.growslice(gs, 0x080CF320, ecx_504, eax_503, edi_502, (word32) eax_503 + 1, out esi_1187);
							*((word32) ebp_493 + 8) = dwArg10;
							byte al_512 = (byte) esi_501;
							if (g_t81576F0 == 0x00)
								*ebp_493 = dwLoc80_996;
							else
								runtime.writebarrierptr(ebp_493, dwLoc80_996);
							esi_501 = (word32) al_512;
							eax_503 = ecx_24;
							ecx_504 = dwLoc80_996;
						}
						*((word32) ebp_493 + 4) = (word32) eax_503 + 1;
						Mem581[ecx_504 + eax_503:byte] = SLICE(esi_501, byte, 0);
						fmt.(*fmt).writePadding(gs, dwArg04, dwArg04->t0010 - edx_204);
						Eq_4 eax_607 = dwArg04->t0000;
						Eq_4 edx_616 = *((word32) eax_607 + 4);
						Eq_4 ecx_615 = (word32) eax_206 + (0x01 - ecx_205 >> 0x1F & 0x01);
						word32 ebp_618 = edx_204 - 0x01 + edx_616;
						Eq_4 esi_620 = *((word32) eax_607 + 8);
						Eq_4 edi_621 = *eax_607;
						if (ebp_618 > esi_620)
						{
							word32 esi_1188;
							runtime.growslice(gs, 0x080CF320, edi_621, edx_616, esi_620, ebp_618, out esi_1188);
							edi_621 = dwLoc80_996;
							esi_620 = dwArg10;
						}
						if (ebp_618 > esi_620)
							runtime.panicslice(gs);
						else
						{
							word32 edi_1191;
							word32 ebp_1189;
							word32 esi_1190;
							runtime.memmove(edi_621 + edx_616, ecx_615, edx_204 - 0x01, out ebp_1189, out esi_1190, out edi_1191);
							*((word32) eax_607 + 4) = ebp_618;
							*((word32) eax_607 + 8) = esi_620;
							if (g_t81576F0 == 0x00)
								*eax_607 = edi_621;
							else
								runtime.writebarrierptr(eax_607, edi_621);
						}
					}
				}
			}
		}
	}
}

// 080B6F30: void fmt.(*buffer).WriteRune(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*pp).badVerb
//      fmt.(*pp).catchPanic
void fmt.(*buffer).WriteRune(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_121 = dwArg08;
	if (dwArg08 < 0x80)
	{
		Eq_4 edx_21 = *dwArg04;
		Eq_4 ebx_22 = *((word32) dwArg04 + 8);
		Eq_4 ebp_23 = *((word32) dwArg04 + 4);
		if ((word32) ebp_23 + 1 > ebx_22)
		{
			word32 esi_39;
			runtime.growslice(gs, 0x080CF320, edx_21, ebp_23, ebx_22, (word32) ebp_23 + 1, out esi_39);
			*((word32) dwArg04 + 8) = dwLoc18;
			if (g_t81576F0 == 0x00)
				*dwArg04 = dwLoc20;
			else
				runtime.writebarrierptr(dwArg04, dwLoc20);
			ebp_23 = dwLoc1C;
			edx_21 = dwLoc20;
		}
		*((word32) dwArg04 + 4) = (word32) ebp_23 + 1;
		Mem86[edx_21 + ebp_23:byte] = SLICE(dwArg08, byte, 0);
	}
	else
	{
		Eq_4 ebx_92 = *((word32) dwArg04 + 4);
		Eq_4 edx_183 = *((word32) dwArg04 + 8);
		Eq_4 ebp_107 = *dwArg04;
		Eq_4 esi_188 = ebx_92;
		ebx_159 = ebx_92;
		while (true)
		{
			Eq_4 ebx_159;
			Eq_4 edi_97 = (word32) esi_188 + 4;
			if (edi_97 <= edx_183)
				break;
			Eq_4 edi_160 = (word32) ebx_159 + 1;
			if (edi_160 > edx_183)
			{
				word32 esi_297;
				runtime.growslice(gs, 0x080CF320, ebp_107, ebx_159, edx_183, edi_160, out esi_297);
				dwLoc24 = edi_160;
				ebp_107 = dwLoc20;
				edx_183 = dwLoc18;
				edi_160 = (word32) dwLoc1C + 1;
				eax_121 = dwArg08;
				esi_188 = ebx_92;
			}
			Mem191[ebp_107 + ebx_159:byte] = 0x00;
			ebx_159 = edi_160;
		}
		if (esi_188 > edi_97 || edi_97 > edx_183)
			runtime.panicslice(gs);
		else
		{
			unicode/utf8.EncodeRune(gs, (word32) ebp_107 + (esi_188 - edx_183 >> 0x1F & esi_188), 0x04, eax_121);
			word32 eax_132 = dwLoc24 + ebx_92;
			if (eax_132 > edx_183)
				runtime.panicslice(gs);
			else
			{
				*((word32) dwArg04 + 4) = eax_132;
				*((word32) dwArg04 + 8) = edx_183;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_107;
				else
					runtime.writebarrierptr(dwArg04, ebp_107);
			}
		}
	}
}

// 080B70F0: void fmt.newPrinter(Register (ptr32 Eq_2) gs)
// Called from:
//      fmt.Fprintln
void fmt.newPrinter(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.(*Pool).Get(gs, 135538336);
	if (dwLoc0C != 0x080DC3E0)
		runtime.panicdottypeE(gs, dwLoc0C);
	else
	{
		((word32) dwLoc08 + 0x007E)->u1 = 0x00;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc08 + 32) = dwLoc08;
		else
			runtime.writebarrierptr((word32) dwLoc08 + 32, dwLoc08);
		((word32) dwLoc08 + 36)->u0 = 0x00;
		*((word32) dwLoc08 + 37) = 0x00;
		*((word32) dwLoc08 + 41) = 0x00;
	}
}

// 080B71A0: void fmt.(*pp).free(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      fmt.Fprintln
void fmt.(*pp).free(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 4) = 0x00;
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) dwArg04 + 16)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) dwArg04 + 16, 0x00);
	((word32) dwArg04 + 28)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 24)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 24, 0x00);
	}
	sync.(*Pool).Put(gs, 135538336, 0x080DC3E0, dwArg04);
}

// 080B7280: void fmt.(*pp).Width(Register (ptr32 Eq_134788) gs)
void fmt.(*pp).Width(struct Eq_134788 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080B72B0: void fmt.(*pp).Precision(Register (ptr32 Eq_134801) gs)
void fmt.(*pp).Precision(struct Eq_134801 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080B72E0: void fmt.(*pp).Flag(Register (ptr32 Eq_134814) gs, Stack (ptr32 Eq_134815) dwArg04, Stack int32 dwArg08)
void fmt.(*pp).Flag(struct Eq_134814 * gs, struct Eq_134815 * dwArg04, int32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg08 > 0x23)
	{
		if (dwArg08 != 0x2B)
		{
			if (dwArg08 == 0x2D)
				return;
			if (dwArg08 != 0x30)
				;
		}
		else
			(byte) (word32) dwArg04->b0027 == 0x00;
	}
	else
	{
		if (dwArg08 == 0x20)
			return;
		if (dwArg08 != 0x23)
			return;
		(byte) (word32) dwArg04->b0028 == 0x00;
	}
}

// 080B7390: void fmt.(*pp).Write(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void fmt.(*pp).Write(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 4);
	word32 ebx_20 = ecx_18 + dwArg0C;
	Eq_4 ebp_22 = *((word32) dwArg04 + 8);
	Eq_4 esi_23 = *dwArg04;
	if (ebx_20 > ebp_22)
	{
		word32 esi_154;
		runtime.growslice(gs, 0x080CF320, esi_23, ecx_18, ebp_22, ebx_20, out esi_154);
		esi_23 = dwLoc18;
		ebp_22 = dwLoc10;
	}
	if (ebx_20 > ebp_22)
		runtime.panicslice(gs);
	else
	{
		word32 esi_156;
		word32 edi_157;
		word32 ebp_155;
		runtime.memmove(esi_23 + ecx_18, dwArg08, dwArg0C, out ebp_155, out esi_156, out edi_157);
		*((word32) dwArg04 + 4) = ebx_20;
		*((word32) dwArg04 + 8) = ebp_22;
		if (g_t81576F0 == 0x00)
			*dwArg04 = esi_23;
		else
			runtime.writebarrierptr(dwArg04, esi_23);
	}
}

// 080B7490: void fmt.Fprintln(Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm1, Stack (ptr32 Eq_134923) dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_134925) dwArg0C, Stack int32 dwArg10, Stack word32 dwArg14)
// Called from:
//      fmt.Println
void fmt.Fprintln(struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm1, struct Eq_134923 * dwArg04, Eq_4 dwArg08, struct Eq_134925 * dwArg0C, int32 dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.newPrinter(gs);
	fmt.(*pp).doPrintln(gs, xmm0, xmm1, dwLoc2C, dwArg0C, dwArg10);
	<anonymous> * eax_55 = dwArg04->ptr0014;
	eax_55();
	fmt.(*pp).free(gs, dwLoc2C);
}

// 080B7550: void fmt.Println(Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm1, Stack (ptr32 Eq_134925) dwArg04, Stack int32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      main.main
void fmt.Println(struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm1, struct Eq_134925 * dwArg04, int32 dwArg08, word32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.Fprintln(gs, xmm0, xmm1, &g_t8136650, g_t8144F98, dwArg04, dwArg08, dwArg0C);
}

// 080B75C0: void fmt.getField(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*pp).printValue
void fmt.getField(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Field(gs, dwArg04, dwArg0C, dwArg10);
	byte bLoc1C_123 = (byte) dwArg10;
	if ((dwLoc10 & 0x1F) == 0x14)
	{
		reflect.Value.IsNil(gs, dwLoc10);
		if ((byte) (word32) bLoc1C_123 == 0x00)
			reflect.Value.Elem(gs, dwLoc18, dwLoc14, dwLoc10);
	}
}

// 080B7690: void fmt.(*pp).unknownType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*pp).printValue
void fmt.(*pp).unknownType(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg10 == 0x00)
	{
		Eq_4 ecx_22 = *((word32) dwArg04 + 4);
		Eq_4 ebx_25 = *dwArg04;
		Eq_4 ebp_26 = *((word32) dwArg04 + 8);
		if ((word32) ecx_22 + 5 > ebp_26)
		{
			word32 esi_496;
			runtime.growslice(gs, 0x080CF320, ebx_25, ecx_22, ebp_26, (word32) ecx_22 + 5, out esi_496);
			ebp_26 = dwLoc24;
			ebx_25 = dwLoc2C;
		}
		if ((word32) ecx_22 + 5 > ebp_26)
			runtime.panicslice(gs);
		else
		{
			word32 ebp_497;
			word32 esi_498;
			word32 edi_499;
			runtime.memmove(ebx_25 + ecx_22, 0x080E0FC5, 0x05, out ebp_497, out esi_498, out edi_499);
			*((word32) dwArg04 + 4) = (word32) ecx_22 + 5;
			*((word32) dwArg04 + 8) = ebp_26;
			if (g_t81576F0 == 0x00)
				*dwArg04 = ebx_25;
			else
				runtime.writebarrierptr(dwArg04, ebx_25);
		}
	}
	else
	{
		Eq_4 edx_104 = *((word32) dwArg04 + 8);
		Eq_4 ebx_105 = *dwArg04;
		Eq_4 ebp_106 = *((word32) dwArg04 + 4);
		if ((word32) ebp_106 + 1 > edx_104)
		{
			word32 esi_493;
			runtime.growslice(gs, 0x080CF320, ebx_105, ebp_106, edx_104, (word32) ebp_106 + 1, out esi_493);
			*((word32) dwArg04 + 8) = dwLoc24;
			dwLoc34 = edx_104;
			dwLoc30 = (word32) ebp_106 + 1;
			if (g_t81576F0 == 0x00)
				*dwArg04 = dwLoc2C;
			else
				runtime.writebarrierptr(dwArg04, dwLoc2C);
			ebp_106 = dwLoc28;
			ebx_105 = dwLoc2C;
		}
		*((word32) dwArg04 + 4) = (word32) ebp_106 + 1;
		Mem165[ebx_105 + ebp_106:byte] = 0x3F;
		reflect.Value.Type(gs, dwArg08, dwArg10);
		Eq_4 ecx_185 = *((word32) dwLoc34 + 0x0084);
		ecx_185();
		Eq_4 ebx_197 = *((word32) dwArg04 + 4);
		word32 ebp_198 = ebx_197 + dwArg10;
		Eq_4 esi_200 = *((word32) dwArg04 + 8);
		Eq_4 edi_201 = *dwArg04;
		if (ebp_198 > esi_200)
		{
			word32 esi_494;
			runtime.growslice(gs, 0x080CF320, edi_201, ebx_197, esi_200, ebp_198, out esi_494);
			esi_200 = dwLoc24;
			edi_201 = dwLoc2C;
		}
		if (ebp_198 > esi_200)
			runtime.panicslice(gs);
		else
		{
			word32 edi_248;
			word32 esi_249;
			word32 ebp_495;
			runtime.memmove(edi_201 + ebx_197, dwArg0C, dwArg10, out ebp_495, out esi_249, out edi_248);
			*((word32) dwArg04 + 4) = ebp_198;
			*((word32) dwArg04 + 8) = esi_200;
			if (g_t81576F0 == 0x00)
				*dwArg04 = edi_201;
			else
				runtime.writebarrierptr(dwArg04, edi_201);
			Eq_4 eax_292 = edi_201;
			Eq_4 edx_284 = *((word32) dwArg04 + 8);
			Eq_4 ebx_285 = *((word32) dwArg04 + 4);
			if ((word32) ebx_285 + 1 > edx_284)
			{
				word32 esi_304;
				runtime.growslice(gs, 0x080CF320, edi_201, ebx_285, edx_284, (word32) ebx_285 + 1, out esi_304);
				*((word32) dwArg04 + 8) = dwLoc24;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc2C;
				else
					runtime.writebarrierptr(dwArg04, dwLoc2C);
				eax_292 = dwLoc2C;
				ebx_285 = dwLoc28;
			}
			*((word32) dwArg04 + 4) = (word32) ebx_285 + 1;
			Mem345[eax_292 + ebx_285:byte] = 0x3F;
		}
	}
}

// 080B79A0: void fmt.(*pp).badVerb(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*pp).fmtBool
//      fmt.(*pp).fmtInteger
//      fmt.(*pp).fmtFloat
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtString
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).badVerb(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 0x007F) = 0x01;
	Eq_4 ecx_22 = *((word32) dwArg04 + 4);
	Eq_4 ebx_25 = *((word32) dwArg04 + 8);
	Eq_4 ebp_26 = *dwArg04;
	if ((word32) ecx_22 + 2 > ebx_25)
	{
		word32 esi_985;
		runtime.growslice(gs, 0x080CF320, ebp_26, ecx_22, ebx_25, (word32) ecx_22 + 2, out esi_985);
		dwLoc58 = ebx_25;
		dwLoc54 = (word32) ecx_22 + 2;
		ebx_25 = dwLoc48;
		ebp_26 = dwLoc50;
	}
	if ((word32) ecx_22 + 2 > ebx_25)
		runtime.panicslice(gs);
	else
	{
		word32 esi_987;
		word32 ebp_986;
		word32 edi_988;
		runtime.memmove(ebp_26 + ecx_22, 0x080E0DAD, 0x02, out ebp_986, out esi_987, out edi_988);
		*((word32) dwArg04 + 4) = (word32) ecx_22 + 2;
		*((word32) dwArg04 + 8) = ebx_25;
		Eq_4 dwLoc5C_750 = 0x02;
		if (g_t81576F0 == 0x00)
			*dwArg04 = ebp_26;
		else
			runtime.writebarrierptr(dwArg04, ebp_26);
		fmt.(*buffer).WriteRune(gs, dwArg04, dwArg08);
		Eq_4 dwLoc60_760 = dwArg08;
		Eq_4 ecx_120 = *((word32) dwArg04 + 8);
		Eq_4 edx_121 = *((word32) dwArg04 + 4);
		Eq_4 ebx_122 = *dwArg04;
		if ((word32) edx_121 + 1 > ecx_120)
		{
			word32 esi_989;
			runtime.growslice(gs, 0x080CF320, ebx_122, edx_121, ecx_120, (word32) edx_121 + 1, out esi_989);
			*((word32) dwArg04 + 8) = dwLoc48;
			dwLoc60_760 = ebx_122;
			dwLoc5C_750 = edx_121;
			dwLoc58 = ecx_120;
			dwLoc54 = (word32) edx_121 + 1;
			if (g_t81576F0 == 0x00)
				*dwArg04 = dwLoc50;
			else
			{
				runtime.writebarrierptr(dwArg04, dwLoc50);
				dwLoc60_760 = dwLoc50;
			}
			edx_121 = dwLoc4C;
			ebx_122 = dwLoc50;
		}
		*((word32) dwArg04 + 4) = (word32) edx_121 + 1;
		Mem180[ebx_122 + edx_121:byte] = 0x28;
		Eq_4 edx_182 = *((word32) dwArg04 + 0x0C);
		if (edx_182 != 0x00)
		{
			struct Eq_135346 * edx_471;
			Eq_4 ecx_467 = edx_182;
			if (edx_182 != 0x00)
				edx_471 = &g_t8138A00;
			else
			{
				edx_471 = null;
				ecx_467.u0 = 0x00;
			}
			edx_471->ptr0084();
			Eq_4 ebx_490 = *((word32) dwArg04 + 4);
			word32 ebp_491 = dwLoc5C_750 + ebx_490;
			Eq_4 esi_493 = *((word32) dwArg04 + 8);
			Eq_4 edi_494 = *dwArg04;
			if (ebp_491 > esi_493)
			{
				word32 esi_990;
				runtime.growslice(gs, 0x080CF320, edi_494, ebx_490, esi_493, ebp_491, out esi_990);
				esi_493 = dwLoc48;
				edi_494 = dwLoc50;
			}
			if (ebp_491 > esi_493)
				runtime.panicslice(gs);
			word32 edi_542;
			word32 esi_543;
			word32 ebp_991;
			runtime.memmove(edi_494 + ebx_490, dwLoc60_760, dwLoc5C_750, out ebp_991, out esi_543, out edi_542);
			*((word32) dwArg04 + 4) = ebp_491;
			*((word32) dwArg04 + 8) = esi_493;
			if (g_t81576F0 == 0x00)
				*dwArg04 = edi_494;
			else
				runtime.writebarrierptr(dwArg04, edi_494);
			Eq_4 eax_586 = edi_494;
			Eq_4 edx_578 = *((word32) dwArg04 + 4);
			Eq_4 ebx_579 = *((word32) dwArg04 + 8);
			if ((word32) edx_578 + 1 > ebx_579)
			{
				word32 esi_598;
				runtime.growslice(gs, 0x080CF320, edi_494, edx_578, ebx_579, (word32) edx_578 + 1, out esi_598);
				*((word32) dwArg04 + 8) = dwLoc48;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc50;
				else
					runtime.writebarrierptr(dwArg04, dwLoc50);
				eax_586 = dwLoc50;
				edx_578 = dwLoc4C;
			}
			*((word32) dwArg04 + 4) = (word32) edx_578 + 1;
			Mem638[eax_586 + edx_578:byte] = 0x3D;
			word128 xmm1_994;
			fmt.(*pp).printArg(gs, xmm0, xmm1, dwArg04, *((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 16), 118, out xmm1_994);
		}
		else
		{
			Eq_4 ecx_186 = *((word32) dwArg04 + 28);
			if (ecx_186 == 0x00)
			{
				Eq_4 ecx_386 = *((word32) dwArg04 + 4);
				Eq_4 ebx_389 = *((word32) dwArg04 + 8);
				Eq_4 ebp_390 = *dwArg04;
				if ((word32) ecx_386 + 5 > ebx_389)
				{
					word32 esi_995;
					runtime.growslice(gs, 0x080CF320, ebp_390, ecx_386, ebx_389, (word32) ecx_386 + 5, out esi_995);
					ebp_390 = dwLoc50;
					ebx_389 = dwLoc48;
				}
				if ((word32) ecx_386 + 5 > ebx_389)
					runtime.panicslice(gs);
				word32 edi_432;
				word32 esi_433;
				word32 ebp_996;
				runtime.memmove(ebp_390 + ecx_386, 0x080E0FC5, 0x05, out ebp_996, out esi_433, out edi_432);
				*((word32) dwArg04 + 4) = (word32) ecx_386 + 5;
				*((word32) dwArg04 + 8) = ebx_389;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_390;
				else
					runtime.writebarrierptr(dwArg04, ebp_390);
			}
			else
			{
				Eq_4 edx_190 = *((word32) dwArg04 + 24);
				reflect.Value.Type(gs, *((word32) dwArg04 + 20), ecx_186);
				Eq_4 ecx_208 = *((word32) dwLoc58 + 0x0084);
				ecx_208();
				Eq_4 ebx_219 = *((word32) dwArg04 + 4);
				word32 ebp_220 = ecx_186 + ebx_219;
				Eq_4 esi_222 = *dwArg04;
				Eq_4 edi_223 = *((word32) dwArg04 + 8);
				if (ebp_220 > edi_223)
				{
					word32 esi_997;
					runtime.growslice(gs, 0x080CF320, esi_222, ebx_219, edi_223, ebp_220, out esi_997);
					esi_222 = dwLoc50;
					edi_223 = dwLoc48;
				}
				if (ebp_220 > edi_223)
					runtime.panicslice(gs);
				word32 edi_270;
				word32 esi_271;
				word32 ebp_998;
				runtime.memmove(esi_222 + ebx_219, edx_190, ecx_186, out ebp_998, out esi_271, out edi_270);
				*((word32) dwArg04 + 4) = ebp_220;
				*((word32) dwArg04 + 8) = edi_223;
				if (g_t81576F0 == 0x00)
					*dwArg04 = esi_222;
				else
					runtime.writebarrierptr(dwArg04, esi_222);
				Eq_4 eax_314 = esi_222;
				Eq_4 edx_306 = *((word32) dwArg04 + 4);
				Eq_4 ebx_307 = *((word32) dwArg04 + 8);
				if ((word32) edx_306 + 1 > ebx_307)
				{
					word32 esi_326;
					runtime.growslice(gs, 0x080CF320, esi_222, edx_306, ebx_307, (word32) edx_306 + 1, out esi_326);
					*((word32) dwArg04 + 8) = dwLoc48;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc50;
					else
						runtime.writebarrierptr(dwArg04, dwLoc50);
					eax_314 = dwLoc50;
					edx_306 = dwLoc4C;
				}
				*((word32) dwArg04 + 4) = (word32) edx_306 + 1;
				Mem366[eax_314 + edx_306:byte] = 0x3D;
				fmt.(*pp).printValue(gs, dwArg04, *((word32) dwArg04 + 20), *((word32) dwArg04 + 24), *((word32) dwArg04 + 28), 118, 0x00);
				dwLoc50.u0 = 0x00;
			}
		}
		Eq_4 ecx_658 = *((word32) dwArg04 + 8);
		Eq_4 edx_659 = *((word32) dwArg04 + 4);
		Eq_4 ebx_660 = *dwArg04;
		if ((word32) edx_659 + 1 > ecx_658)
		{
			word32 esi_681;
			runtime.growslice(gs, 0x080CF320, ebx_660, edx_659, ecx_658, (word32) edx_659 + 1, out esi_681);
			*((word32) dwArg04 + 8) = dwLoc48;
			if (g_t81576F0 == 0x00)
				*dwArg04 = dwLoc50;
			else
				runtime.writebarrierptr(dwArg04, dwLoc50);
			edx_659 = dwLoc4C;
			ebx_660 = dwLoc50;
		}
		*((word32) dwArg04 + 4) = (word32) edx_659 + 1;
		Mem723[ebx_660 + edx_659:byte] = 0x29;
		*((word32) dwArg04 + 0x007F) = 0x00;
	}
}

// 080B8000: void fmt.(*pp).fmtBool(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtBool(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 116 || dwArg0C == 118)
		fmt.(*fmt).fmt_boolean(gs, (word32) dwArg04 + 32, (byte) (word32) bArg08);
	else
		fmt.(*pp).badVerb(gs, dwArg04, dwArg0C);
}

// 080B8060: void fmt.(*pp).fmt0x64(Register Eq_132869 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08, Stack byte bArg10)
// Called from:
//      fmt.(*pp).fmtInteger
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
void fmt.(*pp).fmt0x64(Eq_132869 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 qwArg08, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte cl_20 = (byte) (word32) *((word32) dwArg04 + 40);
	*((word32) dwArg04 + 40) = (byte) (word32) bArg10;
	fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x10, 0x00, &g_t80E26EC, 0x11);
	*((word32) dwArg04 + 40) = (byte) (word32) cl_20;
}

// 080B80E0: void fmt.(*pp).fmtInteger(Register Eq_135773 edx, Register Eq_4 ebx, Register word32 ebp, Register int32 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08, Stack byte bArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtInteger(Eq_135773 edx, Eq_4 ebx, word32 ebp, int32 edi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 qwArg08, byte bArg10, Eq_4 dwArg14)
{
	Eq_132869 ebx_24_8 = SLICE(ebx, word24, 8);
	Eq_4 dwArg08 = (word32) qwArg08;
	Eq_132585 dwArg0C = SLICE(qwArg08, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx_24_8 = SLICE(runtime.morestack_noctxt(), word24, 8);
	if (dwArg14 <= 99)
	{
		if (dwArg14 <= 88)
		{
			if (dwArg14 == 0x55)
			{
				fmt.(*fmt).fmt_unicode(edi, gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
				return;
			}
			if (dwArg14 == 88)
			{
				fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x10, (byte) (word32) bArg10, &g_t80E26DB, 0x11);
				return;
			}
		}
		else
		{
			if (dwArg14 == 0x62)
			{
				fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x02, (byte) (word32) bArg10, &g_t80E26EC, 0x11);
				return;
			}
			if (dwArg14 == 99)
			{
				fmt.(*fmt).fmt_c(ebx_24_8, gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
				return;
			}
		}
	}
	else if (dwArg14 <= 111)
	{
		if (dwArg14 == 100)
		{
			fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x0A, (byte) (word32) bArg10, &g_t80E26EC, 0x11);
			return;
		}
		if (dwArg14 == 111)
		{
			fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x08, (byte) (word32) bArg10, &g_t80E26EC, 0x11);
			return;
		}
	}
	else
	{
		if (dwArg14 == 113)
		{
			Eq_133997 ebx_24_8_168 = SLICE(dwArg0C, word24, 8);
			if ((byte) (SEQ(edx_24_8, Test(ULT,false)) | SEQ(SLICE(ebp, word24, 8), dwArg0C == 0x00) & SEQ(edx_24_8, dwArg08 <= 1114111)) != 0x00)
				fmt.(*fmt).fmt_qc(ebx_24_8_168, gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
			else
				fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
			return;
		}
		if (dwArg14 == 118)
		{
			byte cl_100;
			if ((byte) (word32) *((word32) dwArg04 + 44) != 0x00)
			{
				cl_100 = (byte) (word32) bArg10;
				if (cl_100 == 0x00)
				{
					fmt.(*pp).fmt0x64(ebx_24_8, gs, dwArg04, qwArg08, 0x01);
					return;
				}
			}
			else
				cl_100 = (byte) (word32) bArg10;
			fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x0A, cl_100, &g_t80E26EC, 0x11);
			return;
		}
		if (dwArg14 == 0x78)
		{
			fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x10, (byte) (word32) bArg10, &g_t80E26EC, 0x11);
			return;
		}
	}
	fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
}

// 080B8400: void fmt.(*pp).fmtFloat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack real64 rArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtFloat(struct Eq_2 * gs, Eq_4 dwArg04, real64 rArg08, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg14 <= 0x47)
	{
		if (dwArg14 == 0x45)
			goto l080B842B;
		if (dwArg14 == 0x46)
		{
			fmt.(*fmt).fmt_float(gs, (word32) dwArg04 + 32, (real64) (uint128) (uint64) rArg08, dwArg10, 0x66, 0x06);
			return;
		}
		if (dwArg14 == 0x47)
		{
l080B846A:
			fmt.(*fmt).fmt_float(gs, (word32) dwArg04 + 32, (real64) (uint128) (uint64) rArg08, dwArg10, dwArg14, ~0x00);
			return;
		}
	}
	else if (dwArg14 <= 0x66)
	{
		if (dwArg14 == 0x62)
			goto l080B846A;
		if (dwArg14 <= 0x66)
		{
l080B842B:
			fmt.(*fmt).fmt_float(gs, (word32) dwArg04 + 32, (real64) (uint128) (uint64) rArg08, dwArg10, dwArg14, 0x06);
			return;
		}
	}
	else
	{
		if (dwArg14 == 0x67)
			goto l080B846A;
		if (dwArg14 == 118)
		{
			fmt.(*fmt).fmt_float(gs, (word32) dwArg04 + 32, (real64) (uint128) (uint64) rArg08, dwArg10, 0x67, ~0x00);
			return;
		}
	}
	fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
}

// 080B8560: void fmt.(*pp).fmtComplex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack real64 rArg08, Stack real64 rArg10, Stack int32 dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtComplex(struct Eq_2 * gs, Eq_4 dwArg04, real64 rArg08, real64 rArg10, int32 dwArg18, Eq_4 dwArg1C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg1C <= 0x62)
	{
		if (dwArg1C <= 0x47 || dwArg1C == 0x62)
		{
l080B8592:
			byte dl_46 = (byte) (word32) *((word32) dwArg04 + 39);
			Eq_4 ebx_48 = *((word32) dwArg04 + 8);
			Eq_4 ebp_100 = *dwArg04;
			Eq_4 esi_106 = *((word32) dwArg04 + 4);
			if ((word32) esi_106 + 1 > ebx_48)
			{
				word32 esi_370;
				runtime.growslice(gs, 0x080CF320, ebp_100, esi_106, ebx_48, (word32) esi_106 + 1, out esi_370);
				*((word32) dwArg04 + 8) = dwLoc18;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc20;
				else
					runtime.writebarrierptr(dwArg04, dwLoc20);
				esi_106 = dwLoc1C;
				ebp_100 = dwLoc20;
			}
			*((word32) dwArg04 + 4) = (word32) esi_106 + 1;
			Mem111[ebp_100 + esi_106:byte] = 0x28;
			Eq_136073 edx_117 = (dwArg18 >> 0x1F >> 0x1F) + dwArg18;
			fmt.(*pp).fmtFloat(gs, dwArg04, (real64) (uint128) (uint64) rArg08, edx_117 >> 0x01, dwArg1C);
			*((word32) dwArg04 + 39) = 0x01;
			fmt.(*pp).fmtFloat(gs, dwArg04, (real64) (uint128) (uint64) rArg10, edx_117 >> 0x01, dwArg1C);
			Eq_4 ecx_149 = *((word32) dwArg04 + 4);
			Eq_4 ebx_152 = *((word32) dwArg04 + 8);
			Eq_4 ebp_153 = *dwArg04;
			if ((word32) ecx_149 + 2 > ebx_152)
			{
				word32 esi_371;
				runtime.growslice(gs, 0x080CF320, ebp_153, ecx_149, ebx_152, (word32) ecx_149 + 2, out esi_371);
				ebx_152 = dwLoc18;
				ebp_153 = dwLoc20;
			}
			if ((word32) ecx_149 + 2 > ebx_152)
				runtime.panicslice(gs);
			else
			{
				word32 edi_197;
				word32 esi_198;
				word32 ebp_201;
				runtime.memmove(ebp_153 + ecx_149, 135138835, 0x02, out ebp_201, out esi_198, out edi_197);
				*((word32) dwArg04 + 4) = (word32) ecx_149 + 2;
				*((word32) dwArg04 + 8) = ebx_152;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_153;
				else
					runtime.writebarrierptr(dwArg04, ebp_153);
				*((word32) dwArg04 + 39) = (byte) (word32) dl_46;
				return;
			}
		}
	}
	else if (dwArg1C <= 0x67 || dwArg1C == 118)
		goto l080B8592;
	fmt.(*pp).badVerb(gs, dwArg04, dwArg1C);
}

// 080B8790: void fmt.(*pp).fmtString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*pp).handleMethods
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg10 <= 113)
	{
		if (dwArg10 == 88)
		{
			fmt.(*fmt).fmt_sx(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, &g_t80E26DB, 0x11);
			return;
		}
		if (dwArg10 == 113)
		{
			fmt.(*fmt).fmt_q(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
			return;
		}
	}
	else
	{
		if (dwArg10 == 115)
		{
			fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
			return;
		}
		if (dwArg10 == 118)
		{
			if ((byte) (word32) *((word32) dwArg04 + 44) != 0x00)
				fmt.(*fmt).fmt_q(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
			else
				fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
			return;
		}
		if (dwArg10 == 0x78)
		{
			fmt.(*fmt).fmt_sx(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, &g_t80E26EC, 0x11);
			return;
		}
	}
	fmt.(*pp).badVerb(gs, dwArg04, dwArg10);
}

// 080B8900: void fmt.(*pp).fmtBytes(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtBytes(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C)
{
	while (fp - 0x1C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg14 <= 113)
	{
		if (dwArg14 == 88)
		{
			fmt.(*fmt).fmt_bx(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, &g_t80E26DB, 0x11);
			return;
		}
		if (dwArg14 == 100)
			goto l080B8942;
		if (dwArg14 == 113)
		{
			runtime.slicebytetostring(gs, fp - 0x60, dwArg08, dwArg0C);
			fmt.(*fmt).fmt_q(gs, (word32) dwArg04 + 32, dwLoc8C, dwLoc88);
			return;
		}
	}
	else
	{
		if (dwArg14 == 115)
		{
			runtime.slicebytetostring(gs, fp - 0x40, dwArg08, dwArg0C);
			fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, dwLoc8C, dwLoc88);
			return;
		}
		if (dwArg14 == 118)
		{
l080B8942:
			if ((byte) (word32) *((word32) dwArg04 + 44) == 0x00)
			{
				Eq_4 ecx_236 = *((word32) dwArg04 + 8);
				Eq_4 edx_237 = *((word32) dwArg04 + 4);
				Eq_4 ebx_238 = *dwArg04;
				if ((word32) edx_237 + 1 > ecx_236)
				{
					word32 esi_255;
					runtime.growslice(gs, 0x080CF320, ebx_238, edx_237, ecx_236, (word32) edx_237 + 1, out esi_255);
					*((word32) dwArg04 + 8) = dwLoc80;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc88;
					else
						runtime.writebarrierptr(dwArg04, dwLoc88);
					edx_237 = dwLoc84;
					ebx_238 = dwLoc88;
				}
				*((word32) dwArg04 + 4) = (word32) edx_237 + 1;
				Mem297[ebx_238 + edx_237:byte] = 0x5B;
				Eq_4 ecx_298 = 0x00;
				Eq_4 edx_302 = dwArg08;
				while (true)
				{
					Eq_132869 ebx_24_8_457 = SLICE(dwArg0C, word24, 8);
					if (ecx_298 >= dwArg0C)
						break;
					word32 ebp_375 = (word32) *edx_302;
					if (ecx_298 > 0x00)
					{
						Eq_4 ebx_380 = *((word32) dwArg04 + 8);
						Eq_4 esi_378 = *((word32) dwArg04 + 4);
						Eq_4 edi_379 = *dwArg04;
						ebx_24_8_457.u0 = SLICE(ebx_380, word24, 8);
						if ((word32) esi_378 + 1 > ebx_380)
						{
							word32 esi_1284;
							runtime.growslice(gs, 0x080CF320, edi_379, esi_378, ebx_380, (word32) esi_378 + 1, out esi_1284);
							*((word32) dwArg04 + 8) = dwLoc80;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc88;
							else
								runtime.writebarrierptr(dwArg04, dwLoc88);
							ebx_24_8_457.u0 = SLICE(dwArg04, word24, 8);
							esi_378 = dwLoc84;
							edi_379 = dwLoc88;
						}
						*((word32) dwArg04 + 4) = (word32) esi_378 + 1;
						Mem442[edi_379 + esi_378:byte] = 0x20;
					}
					fmt.(*fmt).fmt_integer(ebx_24_8_457, gs, (word32) dwArg04 + 32, (uint64) (uint32) ebp_375, 0x0A, 0x00, &g_t80E26EC, 0x11);
					dwLoc88.u0 = 0x080E26EC;
					dwLoc84.u0 = 0x11;
					edx_302 = (word32) edx_302 + 1;
					ecx_298 = (word32) ecx_298 + 1;
				}
				Eq_4 ecx_310 = *((word32) dwArg04 + 8);
				Eq_4 edx_311 = *((word32) dwArg04 + 4);
				Eq_4 ebx_312 = *dwArg04;
				if ((word32) edx_311 + 1 > ecx_310)
				{
					word32 esi_329;
					runtime.growslice(gs, 0x080CF320, ebx_312, edx_311, ecx_310, (word32) edx_311 + 1, out esi_329);
					*((word32) dwArg04 + 8) = dwLoc80;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc88;
					else
						runtime.writebarrierptr(dwArg04, dwLoc88);
					edx_311 = dwLoc84;
					ebx_312 = dwLoc88;
				}
				*((word32) dwArg04 + 4) = (word32) edx_311 + 1;
				Mem371[ebx_312 + edx_311:byte] = 0x5D;
				return;
			}
			else
			{
				Eq_4 ecx_482 = *((word32) dwArg04 + 4);
				word32 ebx_484 = ecx_482 + dwArg1C;
				Eq_4 ebp_486 = *((word32) dwArg04 + 8);
				Eq_4 esi_487 = *dwArg04;
				if (ebx_484 > ebp_486)
				{
					word32 esi_1273;
					runtime.growslice(gs, 0x080CF320, esi_487, ecx_482, ebp_486, ebx_484, out esi_1273);
					ebp_486 = dwLoc80;
					esi_487 = dwLoc88;
				}
				if (ebx_484 > ebp_486)
					runtime.panicslice(gs);
				else
				{
					word32 edi_531;
					word32 ebp_1274;
					word32 esi_1275;
					runtime.memmove(esi_487 + ecx_482, dwArg18, dwArg1C, out ebp_1274, out esi_1275, out edi_531);
					*((word32) dwArg04 + 4) = ebx_484;
					*((word32) dwArg04 + 8) = ebp_486;
					if (g_t81576F0 == 0x00)
						*dwArg04 = esi_487;
					else
						runtime.writebarrierptr(dwArg04, esi_487);
					Eq_4 eax_581 = esi_487;
					if (dwArg08 == 0x00)
					{
						Eq_4 edx_572 = *((word32) dwArg04 + 4);
						Eq_4 ebp_575 = *((word32) dwArg04 + 8);
						if ((word32) edx_572 + 5 > ebp_575)
						{
							word32 esi_1280;
							runtime.growslice(gs, 0x080CF320, esi_487, edx_572, ebp_575, (word32) edx_572 + 5, out esi_1280);
							eax_581 = dwLoc88;
							ebp_575 = dwLoc80;
						}
						if ((word32) edx_572 + 5 > ebp_575)
							runtime.panicslice(gs);
						else
						{
							word32 ebp_1281;
							word32 esi_1282;
							word32 edi_1283;
							runtime.memmove(eax_581 + edx_572, 0x080E0FB1, 0x05, out ebp_1281, out esi_1282, out edi_1283);
							*((word32) dwArg04 + 4) = (word32) edx_572 + 5;
							*((word32) dwArg04 + 8) = ebp_575;
							if (g_t81576F0 == 0x00)
								*dwArg04 = eax_581;
							else
								runtime.writebarrierptr(dwArg04, eax_581);
							return;
						}
					}
					else
					{
						Eq_4 ebx_654 = *((word32) dwArg04 + 8);
						Eq_4 ebp_655 = *((word32) dwArg04 + 4);
						if ((word32) ebp_655 + 1 > ebx_654)
						{
							word32 esi_671;
							runtime.growslice(gs, 0x080CF320, esi_487, ebp_655, ebx_654, (word32) ebp_655 + 1, out esi_671);
							*((word32) dwArg04 + 8) = dwLoc80;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc88;
							else
								runtime.writebarrierptr(dwArg04, dwLoc88);
							eax_581 = dwLoc88;
							ebp_655 = dwLoc84;
						}
						*((word32) dwArg04 + 4) = (word32) ebp_655 + 1;
						Mem714[eax_581 + ebp_655:byte] = 0x7B;
						Eq_4 edx_794 = dwArg08;
						Eq_4 eax_715 = 0x00;
						while (true)
						{
							Eq_132869 ebx_24_8_888 = SLICE(dwArg0C, word24, 8);
							if (eax_715 >= dwArg0C)
								break;
							word32 ebp_796 = (word32) *edx_794;
							if (eax_715 > 0x00)
							{
								Eq_4 esi_800 = *((word32) dwArg04 + 4);
								Eq_4 ebx_803 = *dwArg04;
								Eq_4 eax_804 = *((word32) dwArg04 + 8);
								if ((word32) esi_800 + 2 > eax_804)
								{
									word32 esi_1276;
									runtime.growslice(gs, 0x080CF320, ebx_803, esi_800, eax_804, (word32) esi_800 + 2, out esi_1276);
									ebx_803 = dwLoc88;
									eax_804 = dwLoc80;
								}
								if ((word32) esi_800 + 2 > eax_804)
									runtime.panicslice(gs);
								word32 ebp_1277;
								word32 esi_1278;
								word32 edi_1279;
								ebx_24_8_888 = SLICE(runtime.memmove(ebx_803 + esi_800, 0x080E0DB5, 0x02, out ebp_1277, out esi_1278, out edi_1279), word24, 8);
								*((word32) dwArg04 + 4) = (word32) esi_800 + 2;
								*((word32) dwArg04 + 8) = eax_804;
								if (g_t81576F0 == 0x00)
									*dwArg04 = ebx_803;
								else
									runtime.writebarrierptr(dwArg04, ebx_803);
							}
							fmt.(*pp).fmt0x64(ebx_24_8_888, gs, dwArg04, (uint64) (uint32) ebp_796, 0x01);
							edx_794 = (word32) edx_794 + 1;
							eax_715 = (word32) eax_715 + 1;
						}
						Eq_4 eax_725 = *((word32) dwArg04 + 8);
						Eq_4 edx_726 = *((word32) dwArg04 + 4);
						Eq_4 ebx_727 = *dwArg04;
						if ((word32) edx_726 + 1 > eax_725)
						{
							word32 esi_744;
							runtime.growslice(gs, 0x080CF320, ebx_727, edx_726, eax_725, (word32) edx_726 + 1, out esi_744);
							*((word32) dwArg04 + 8) = dwLoc80;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc88;
							else
								runtime.writebarrierptr(dwArg04, dwLoc88);
							edx_726 = dwLoc84;
							ebx_727 = dwLoc88;
						}
						*((word32) dwArg04 + 4) = (word32) edx_726 + 1;
						Mem785[ebx_727 + edx_726:byte] = 0x7D;
						return;
					}
				}
			}
		}
		if (dwArg14 == 0x78)
		{
			fmt.(*fmt).fmt_bx(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, &g_t80E26EC, 0x11);
			return;
		}
	}
	runtime.convT2Eslice(ebx, gs, 0x080CA1C0, fp - 0x0C);
	reflect.ValueOf(gs, dwLoc94, dwLoc90);
	fmt.(*pp).printValue(gs, dwArg04, dwLoc94, dwLoc90, dwLoc8C, dwArg14, 0x00);
}

// subject_text_0007.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text_0007.h"

// 080B91D0: void fmt.(*pp).fmtPointer(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtPointer(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	Eq_132869 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((dwArg10 & 0x1F) > 0x13 || (dwArg10 & 0x1F) < 0x12) && ((dwArg10 & 0x1F) > 0x17 && (dwArg10 & 0x1F) != 0x1A))
	{
		fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
		return;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	reflect.Value.Pointer(gs, stackArg4, dwArg10);
	if (dwArg14 <= 100)
	{
		if (dwArg14 == 88 || (dwArg14 == 0x62 || dwArg14 == 100))
			goto l080B9228;
		goto l080B9257;
	}
	if (dwArg14 <= 0x70)
	{
		if (dwArg14 != 111)
		{
			if (dwArg14 == 0x70)
			{
				fmt.(*pp).fmt0x64(ebx_24_8, gs, dwArg04, (uint64) (uint32) dwLoc38, (byte) ((word32) *((word32) dwArg04 + 40) ^ 0x01));
				return;
			}
			goto l080B9257;
		}
	}
	else
	{
		if (dwArg14 == 118)
		{
			if ((byte) (word32) *((word32) dwArg04 + 44) == 0x00)
			{
				if (dwLoc38 == 0x00)
					fmt.(*fmt).padString(gs, (word32) dwArg04 + 32, 0x080E0FC5, 0x05);
				else
					fmt.(*pp).fmt0x64(ebx_24_8, gs, dwArg04, (uint64) (uint32) dwLoc38, (byte) ((word32) *((word32) dwArg04 + 40) ^ 0x01));
				return;
			}
			else
			{
				Eq_4 dwLoc38_649;
				Eq_4 edx_116 = *((word32) dwArg04 + 8);
				Eq_4 ebx_117 = *((word32) dwArg04 + 4);
				Eq_4 ebp_118 = *dwArg04;
				dwLoc38_649 = dwLoc38;
				if ((word32) ebx_117 + 1 > edx_116)
				{
					word32 esi_886;
					runtime.growslice(gs, 0x080CF320, ebp_118, ebx_117, edx_116, (word32) ebx_117 + 1, out esi_886);
					*((word32) dwArg04 + 8) = dwLoc28;
					dwLoc38_649 = edx_116;
					dwLoc34 = (word32) ebx_117 + 1;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc30;
					else
						runtime.writebarrierptr(dwArg04, dwLoc30);
					ebx_117 = dwLoc2C;
					ebp_118 = dwLoc30;
				}
				*((word32) dwArg04 + 4) = (word32) ebx_117 + 1;
				Mem176[ebp_118 + ebx_117:byte] = 0x28;
				reflect.Value.Type(gs, dwArg08, dwArg10);
				Eq_4 eax_196 = *((word32) dwLoc38_649 + 0x0084);
				eax_196();
				Eq_4 ebx_209 = *((word32) dwArg04 + 4);
				word32 ebp_210 = ebx_209 + dwArg10;
				Eq_4 esi_212 = *((word32) dwArg04 + 8);
				Eq_4 edi_213 = *dwArg04;
				if (ebp_210 > esi_212)
				{
					word32 esi_887;
					runtime.growslice(gs, 0x080CF320, edi_213, ebx_209, esi_212, ebp_210, out esi_887);
					esi_212 = dwLoc28;
					edi_213 = dwLoc30;
				}
				if (ebp_210 > esi_212)
					runtime.panicslice(gs);
				else
				{
					word32 ebp_888;
					word32 esi_889;
					word32 edi_890;
					runtime.memmove(edi_213 + ebx_209, dwArg0C, dwArg10, out ebp_888, out esi_889, out edi_890);
					*((word32) dwArg04 + 4) = ebp_210;
					*((word32) dwArg04 + 8) = esi_212;
					if (g_t81576F0 == 0x00)
						*dwArg04 = edi_213;
					else
						runtime.writebarrierptr(dwArg04, edi_213);
					Eq_4 eax_306 = edi_213;
					Eq_4 edx_296 = *((word32) dwArg04 + 4);
					Eq_4 ebp_300 = *((word32) dwArg04 + 8);
					if ((word32) edx_296 + 2 > ebp_300)
					{
						word32 esi_891;
						runtime.growslice(gs, 0x080CF320, edi_213, edx_296, ebp_300, (word32) edx_296 + 2, out esi_891);
						eax_306 = dwLoc30;
						ebp_300 = dwLoc28;
					}
					if ((word32) edx_296 + 2 > ebp_300)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_892;
						word32 edi_894;
						word32 esi_893;
						word24 ebx_24_8_390 = SLICE(runtime.memmove(eax_306 + edx_296, 135138737, 0x02, out ebp_892, out esi_893, out edi_894), word24, 8);
						*((word32) dwArg04 + 4) = (word32) edx_296 + 2;
						*((word32) dwArg04 + 8) = ebp_300;
						if (g_t81576F0 == 0x00)
							*dwArg04 = eax_306;
						else
							runtime.writebarrierptr(dwArg04, eax_306);
						Eq_4 eax_414 = eax_306;
						if (dwLoc38 == 0x00)
						{
							Eq_4 edx_405 = *((word32) dwArg04 + 4);
							Eq_4 ebp_408 = *((word32) dwArg04 + 8);
							if ((word32) edx_405 + 3 > ebp_408)
							{
								word32 esi_895;
								runtime.growslice(gs, 0x080CF320, eax_306, edx_405, ebp_408, (word32) edx_405 + 3, out esi_895);
								ebp_408 = dwLoc28;
								eax_414 = dwLoc30;
							}
							if ((word32) edx_405 + 3 > ebp_408)
								runtime.panicslice(gs);
							word32 edi_451;
							word32 esi_452;
							word32 ebp_896;
							runtime.memmove(eax_414 + edx_405, 0x080E0E70, 0x03, out ebp_896, out esi_452, out edi_451);
							*((word32) dwArg04 + 4) = (word32) edx_405 + 3;
							*((word32) dwArg04 + 8) = ebp_408;
							if (g_t81576F0 == 0x00)
								*dwArg04 = eax_414;
							else
								runtime.writebarrierptr(dwArg04, eax_414);
						}
						else
							fmt.(*pp).fmt0x64(ebx_24_8_390, gs, dwArg04, (uint64) (uint32) dwLoc38, 0x01);
						Eq_4 eax_486 = *((word32) dwArg04 + 8);
						Eq_4 edx_487 = *((word32) dwArg04 + 4);
						Eq_4 ebx_488 = *dwArg04;
						if ((word32) edx_487 + 1 > eax_486)
						{
							word32 esi_506;
							runtime.growslice(gs, 0x080CF320, ebx_488, edx_487, eax_486, (word32) edx_487 + 1, out esi_506);
							*((word32) dwArg04 + 8) = dwLoc28;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc30;
							else
								runtime.writebarrierptr(dwArg04, dwLoc30);
							edx_487 = dwLoc2C;
							ebx_488 = dwLoc30;
						}
						*((word32) dwArg04 + 4) = (word32) edx_487 + 1;
						Mem547[ebx_488 + edx_487:byte] = 0x29;
						return;
					}
				}
			}
		}
		if (dwArg14 != 0x78)
		{
l080B9257:
			fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
			return;
		}
	}
l080B9228:
	fmt.(*pp).fmtInteger(SLICE(dwArg04, word24, 8), ebx, ebp, edi, gs, dwArg04, dwLoc38, 0x00, dwArg14);
}

// 080B9720: void fmt.(*pp).catchPanic(Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm1, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
void fmt.(*pp).catchPanic(struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm1, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	byte bLoc3C_499 = (byte) dwLoc3C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gorecover(gs, (word32) fp + 4);
	if (dwLoc44 == 0x00)
		return;
	reflect.ValueOf(gs, dwArg08, dwArg0C);
	if ((dwLoc38 & 0x1F) == 22)
	{
		reflect.Value.IsNil(gs, dwLoc38);
		if ((byte) (word32) bLoc3C_499 != 0x00)
		{
			Eq_4 ecx_69 = *((word32) dwArg04 + 4);
			Eq_4 ebx_100 = *((word32) dwArg04 + 8);
			Eq_4 ebp_106 = *dwArg04;
			if ((word32) ecx_69 + 5 > ebx_100)
			{
				word32 esi_716;
				runtime.growslice(gs, 0x080CF320, ebp_106, ecx_69, ebx_100, (word32) ecx_69 + 5, out esi_716);
				ebx_100 = dwLoc2C;
				ebp_106 = dwLoc34;
			}
			if ((word32) ecx_69 + 5 > ebx_100)
				runtime.panicslice(gs);
			else
			{
				word32 esi_718;
				word32 ebp_717;
				word32 edi_719;
				runtime.memmove(ebp_106 + ecx_69, 0x080E0FC5, 0x05, out ebp_717, out esi_718, out edi_719);
				*((word32) dwArg04 + 4) = (word32) ecx_69 + 5;
				*((word32) dwArg04 + 8) = ebx_100;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_106;
				else
					runtime.writebarrierptr(dwArg04, ebp_106);
				return;
			}
		}
	}
	if ((byte) (word32) *((word32) dwArg04 + 0x007E) != 0x00)
		runtime.gopanic(gs);
	else
	{
		word32 ecx_177 = *((word32) dwArg04 + 37);
		Eq_4 bLoc19_614 = *((word32) dwArg04 + 36);
		word32 edx_178 = *((word32) dwArg04 + 41);
		((word32) dwArg04 + 36)->u0 = 0x00;
		*((word32) dwArg04 + 37) = 0x00;
		*((word32) dwArg04 + 41) = 0x00;
		word24 nLoc18_615 = (word24) ecx_177;
		byte bLoc15_630 = SLICE(ecx_177, byte, 24);
		Eq_4 ecx_187 = *((word32) dwArg04 + 4);
		Eq_4 ebx_190 = *((word32) dwArg04 + 8);
		Eq_4 ebp_191 = *dwArg04;
		Eq_4 dwLoc19_613 = SEQ(nLoc18_615, bLoc19_614);
		dwLoc19_613 = SEQ(nLoc18_615, bLoc19_614);
		if ((word32) ecx_187 + 2 > ebx_190)
		{
			word32 esi_708;
			runtime.growslice(gs, 0x080CF320, ebp_191, ecx_187, ebx_190, (word32) ecx_187 + 2, out esi_708);
			ebx_190 = dwLoc2C;
			ebp_191 = dwLoc34;
		}
		word24 nLoc18_632 = SLICE(dwLoc19_613, word24, 8);
		if ((word32) ecx_187 + 2 > ebx_190)
			runtime.panicslice(gs);
		else
		{
			word32 esi_710;
			word32 edi_711;
			word32 ebp_709;
			runtime.memmove(ebp_191 + ecx_187, 0x080E0DAD, 0x02, out ebp_709, out esi_710, out edi_711);
			*((word32) dwArg04 + 4) = (word32) ecx_187 + 2;
			*((word32) dwArg04 + 8) = ebx_190;
			if (g_t81576F0 == 0x00)
				*dwArg04 = ebp_191;
			else
				runtime.writebarrierptr(dwArg04, ebp_191);
			fmt.(*buffer).WriteRune(gs, dwArg04, dwArg10);
			Eq_4 ecx_285 = *((word32) dwArg04 + 4);
			Eq_4 ebx_288 = *((word32) dwArg04 + 8);
			Eq_4 ebp_289 = *dwArg04;
			if ((word32) ecx_285 + 7 > ebx_288)
			{
				word32 esi_712;
				runtime.growslice(gs, 0x080CF320, ebp_289, ecx_285, ebx_288, (word32) ecx_285 + 7, out esi_712);
				ebx_288 = dwLoc2C;
				ebp_289 = dwLoc34;
			}
			if ((word32) ecx_285 + 7 > ebx_288)
				runtime.panicslice(gs);
			else
			{
				word32 edi_715;
				word32 esi_714;
				word32 ebp_713;
				runtime.memmove(ebp_289 + ecx_285, 0x080E11E6, 0x07, out ebp_713, out esi_714, out edi_715);
				*((word32) dwArg04 + 4) = (word32) ecx_285 + 7;
				*((word32) dwArg04 + 8) = ebx_288;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_289;
				else
					runtime.writebarrierptr(dwArg04, ebp_289);
				*((word32) dwArg04 + 0x007E) = 0x01;
				word128 xmm1_720;
				fmt.(*pp).printArg(gs, xmm0, xmm1, dwArg04, dwLoc44, dwLoc40, 118, out xmm1_720);
				*((word32) dwArg04 + 0x007E) = 0x00;
				Eq_4 ecx_405 = *((word32) dwArg04 + 8);
				Eq_4 edx_406 = *((word32) dwArg04 + 4);
				Eq_4 ebx_407 = *dwArg04;
				if ((word32) edx_406 + 1 > ecx_405)
				{
					word32 esi_423;
					runtime.growslice(gs, 0x080CF320, ebx_407, edx_406, ecx_405, (word32) edx_406 + 1, out esi_423);
					*((word32) dwArg04 + 8) = dwLoc2C;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc34;
					else
						runtime.writebarrierptr(dwArg04, dwLoc34);
					edx_406 = dwLoc30;
					ebx_407 = dwLoc34;
				}
				*((word32) dwArg04 + 4) = (word32) edx_406 + 1;
				Mem465[ebx_407 + edx_406:byte] = 0x29;
				*((word32) dwArg04 + 36) = dwLoc19_613;
				*((word32) dwArg04 + 37) = SEQ(bLoc15_630, nLoc18_632);
				*((word32) dwArg04 + 41) = edx_178;
			}
		}
	}
}

// 080B9B30: void fmt.(*pp).handleMethods(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).handleMethods(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((byte) (word32) *((word32) dwArg04 + 0x007F) != 0x00)
	{
		runtime.deferreturn(gs);
		return;
	}
	runtime.assertE2I2(gs, *((word32) dwArg04 + 0x0C));
	if ((byte) (word32) bLoc2C != 0x00)
	{
		Eq_4 ecx_60 = *((word32) dwArg04 + 16);
		byte bLoc2C_476 = (byte) dwArg08;
		word32 ebp_588;
		word32 esi_589;
		word32 edi_590;
		if (runtime.deferproc(gs, 0x10, 0x080E7B0C, dwArg04, out ebp_588, out esi_589, out edi_590) != 0x00)
		{
			runtime.deferreturn(gs);
			return;
		}
		else
		{
			<anonymous> * eax_99 = dwLoc34->ptr0014;
			eax_99();
			runtime.deferreturn(gs);
			return;
		}
	}
	if ((byte) (word32) *((word32) dwArg04 + 44) != 0x00)
	{
		runtime.assertE2I2(gs, *((word32) dwArg04 + 0x0C));
		if ((byte) (word32) bLoc2C != 0x00)
		{
			Eq_4 ecx_154 = *((word32) dwArg04 + 16);
			Eq_4 edx_155 = *((word32) dwArg04 + 0x0C);
			byte bLoc2C_490 = (byte) dwArg08;
			word32 ebp_601;
			word32 esi_602;
			word32 edi_603;
			if (runtime.deferproc(gs, 0x10, 0x080E7B0C, dwArg04, out ebp_601, out esi_602, out edi_603) != 0x00)
			{
				runtime.deferreturn(gs);
				return;
			}
			else
			{
				<anonymous> * eax_193 = dwLoc34->ptr0014;
				eax_193();
				fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, 0x080E7B0C, dwArg04);
				runtime.deferreturn(gs);
				return;
			}
		}
		goto l080B9BBF;
	}
	if (dwArg08 <= 113)
	{
		if (dwArg08 != 88 && dwArg08 != 113)
			goto l080B9BBF;
	}
	else if (dwArg08 != 115 && (dwArg08 != 118 && dwArg08 != 0x78))
		goto l080B9BBF;
	Eq_4 ebx_245 = *((word32) dwArg04 + 0x0C);
	if (ebx_245 != 0x00)
	{
		runtime.assertE2I2(gs, ebx_245);
		if ((byte) (word32) bLoc2C != 0x00)
		{
			Eq_4 ecx_364 = *((word32) dwArg04 + 16);
			Eq_4 edx_365 = *((word32) dwArg04 + 0x0C);
			byte bLoc2C_528 = (byte) dwArg08;
			word32 ebp_591;
			word32 esi_592;
			word32 edi_593;
			if (runtime.deferproc(gs, 0x10, 0x080E7B0C, dwArg04, out ebp_591, out esi_592, out edi_593) != 0x00)
			{
				runtime.deferreturn(gs);
				return;
			}
			else
			{
				<anonymous> * eax_403 = dwLoc34->ptr0014;
				eax_403();
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg8 = <invalid>;
				Eq_4 stackArg12 = <invalid>;
				fmt.(*pp).fmtString(gs, dwArg04, stackArg8, stackArg12, dwArg08);
				runtime.deferreturn(gs);
				return;
			}
		}
		runtime.assertE2I2(gs, ebx_245);
		if ((byte) (word32) bLoc2C != 0x00)
		{
			Eq_4 ecx_293 = *((word32) dwArg04 + 16);
			Eq_4 edx_294 = *((word32) dwArg04 + 0x0C);
			byte bLoc2C_515 = (byte) dwArg08;
			word32 ebp_596;
			word32 esi_597;
			word32 edi_598;
			if (runtime.deferproc(gs, 0x10, 0x080E7B0C, dwArg04, out ebp_596, out esi_597, out edi_598) != 0x00)
			{
				runtime.deferreturn(gs);
				return;
			}
			else
			{
				<anonymous> * eax_332 = dwLoc34->ptr0014;
				eax_332();
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg8 = <invalid>;
				Eq_4 stackArg12 = <invalid>;
				fmt.(*pp).fmtString(gs, dwArg04, stackArg8, stackArg12, dwArg08);
				runtime.deferreturn(gs);
				return;
			}
		}
	}
l080B9BBF:
	runtime.deferreturn(gs);
}

// 080B9EA0: Register Eq_661 fmt.(*pp).printArg(Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm1, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_661 xmm1Out)
// Called from:
//      fmt.(*pp).badVerb
//      fmt.(*pp).catchPanic
//      fmt.(*pp).doPrintln
Eq_661 fmt.(*pp).printArg(struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm1, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_661 & xmm1Out)
{
	byte bLoc30_1512 = (byte) dwLoc30;
	byte bLoc2C_1347 = (byte) dwLoc2C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 0x0C) = dwArg08;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 16) = dwArg0C;
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 16, dwArg0C);
		dwLoc34 = dwArg0C;
	}
	((word32) dwArg04 + 28)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 24)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 24, 0x00);
		dwLoc34.u0 = 0x00;
	}
	if (dwArg08 == 0x00)
	{
		if (dwArg10 == 0x54 || dwArg10 == 118)
			fmt.(*fmt).padString(gs, (word32) dwArg04 + 32, 0x080E0FC5, 0x05);
		else
			fmt.(*pp).badVerb(gs, dwArg04, dwArg10);
		xmm1Out = xmm1;
		return xmm0;
	}
	if (dwArg10 == 0x54)
	{
		struct Eq_137663 * edx_1060;
		Eq_4 eax_1055 = dwArg08;
		if (dwArg08 != 0x00)
			edx_1060 = (struct Eq_137663 *) &g_t8138A00;
		else
		{
			eax_1055.u0 = 0x00;
			edx_1060 = null;
		}
		edx_1060->ptr0084();
		fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, dwLoc34, dwLoc30);
		xmm1Out = xmm1;
		return xmm0;
	}
	if (dwArg10 == 0x70)
	{
		reflect.ValueOf(gs, dwArg08, dwArg0C);
		fmt.(*pp).fmtPointer(dwArg04, gs, dwArg04, dwLoc30, dwLoc2C, dwLoc28, 0x70);
		xmm1Out = xmm1;
		return xmm0;
	}
	if (dwArg08 != 0x00)
	{
		Eq_4 esi_162 = *((word32) dwArg08 + 8);
		if (esi_162 <= 0xB0C23ED3)
		{
			if (esi_162 <= 0x500C1ABC)
			{
				if (esi_162 > 0x2EA27FFB)
				{
					bool Z_735;
					if (esi_162 == 942571231)
					{
						Eq_4 ebx_706;
						Eq_4 ebp_707;
						if (dwArg08 == 0x080CA1C0)
						{
							ebx_706 = *((word32) dwArg0C + 4);
							ebp_707 = *dwArg0C;
						}
						else
						{
							ebx_706.u0 = 0x00;
							ebp_707.u0 = 0x00;
						}
						if (dwArg08 == 0x080CA1C0)
						{
							fmt.(*pp).fmtBytes(ebx, gs, dwArg04, ebp_707, ebx_706, dwArg10, 0x080E1154, 0x06);
							goto l080B9FDC;
						}
						Z_735 = SLICE(cond(esi_162 - 0x500C1ABC), bool, 2);
					}
					else
						Z_735 = SLICE(cond(esi_162 - 0x500C1ABC), bool, 2);
					if (!Z_735)
					{
						Eq_4 ebx_745;
						Eq_4 esi_744;
						Eq_4 ebp_743;
						if (dwArg08 == 0x080E08C0)
						{
							ebx_745 = *dwArg0C;
							ebp_743 = *((word32) dwArg0C + 8);
							esi_744 = *((word32) dwArg0C + 4);
						}
						else
						{
							ebp_743.u0 = 0x00;
							esi_744.u0 = 0x00;
							ebx_745.u0 = 0x00;
						}
						if (dwArg08 == 0x080E08C0)
						{
							if (ebp_743 != 0x00)
							{
								reflect.Value.CanInterface(gs, ebp_743);
								if ((byte) (word32) bLoc2C_1347 != 0x00)
								{
									xmm0 = reflect.Value.Interface(gs, ebx_745, esi_744, ebp_743, out xmm1);
									*((word32) dwArg04 + 0x0C) = dwLoc2C;
									byte bLoc30_1381 = (byte) ebp_743;
									if (g_t81576F0 == 0x00)
										*((word32) dwArg04 + 16) = dwLoc28;
									else
										runtime.writebarrierptr((word32) dwArg04 + 16, dwLoc28);
									fmt.(*pp).handleMethods(gs, dwArg04, dwArg10);
									if ((byte) (word32) bLoc30_1381 != 0x00)
									{
										xmm1Out = xmm1;
										return xmm0;
									}
								}
							}
							fmt.(*pp).printValue(gs, dwArg04, ebx_745, esi_744, ebp_743, dwArg10, 0x00);
							goto l080B9FDC;
						}
					}
					goto l080B9FC7;
				}
				else
				{
					bool Z_910;
					if (esi_162 == 0x13FF06C5)
					{
						uip32 ebx_1733;
						if (dwArg08 == 0x080CE760)
							ebx_1733 = (word32) *dwArg0C;
						else
							ebx_1733 = 0x00;
						byte bl_895 = (byte) ebx_1733;
						if (dwArg08 == 0x080CE760)
						{
							fmt.(*pp).fmtBool(gs, dwArg04, bl_895, dwArg10);
							goto l080B9FDC;
						}
						Z_910 = SLICE(cond(esi_162 - 0x2EA27FFB), bool, 2);
					}
					else
						Z_910 = SLICE(cond(esi_162 - 0x2EA27FFB), bool, 2);
					if (Z_910)
						goto l080B9FC7;
					if (dwArg08 == 0x080CE860)
						xmm0.u0 = (uint128) (uint64) *dwArg0C;
					else
						xmm0 = __xorps(xmm0, xmm0);
					if (dwArg08 != 0x080CE860)
						goto l080B9FC7;
					fmt.(*pp).fmtFloat(gs, dwArg04, (real64) xmm0, 0x40, dwArg10);
l080B9FDC:
					xmm1Out = xmm1;
					return xmm0;
				}
			}
			if (esi_162 <= 2032468620)
			{
				bool Z_651;
				if (esi_162 == 1715356255)
				{
					uip32 ebx_1735;
					if (dwArg08 == 0x080CF320)
						ebx_1735 = (word32) *dwArg0C;
					else
						ebx_1735 = 0x00;
					byte bl_633 = (byte) ebx_1735;
					if (dwArg08 == 0x080CF320)
					{
						fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, (word32) bl_633, 0x00, dwArg10);
						goto l080B9FDC;
					}
					Z_651 = SLICE(cond(esi_162 - 2032468620), bool, 2);
				}
				else
					Z_651 = SLICE(cond(esi_162 - 2032468620), bool, 2);
				if (Z_651)
					goto l080B9FC7;
				if (dwArg08 == 0x080CE7E0)
				{
					xmm0.u0 = (uint128) (uint32) *((word32) dwArg0C + 4);
					xmm1.u0 = (uint128) (uint32) *dwArg0C;
				}
				else
				{
					xmm0 = __xorps(xmm0, xmm0);
					xmm1 = __xorps(xmm1, xmm1);
				}
				if (dwArg08 == 0x080CE7E0)
				{
					fmt.(*pp).fmtComplex(gs, dwArg04, (real64) xmm1, (real64) xmm0, 0x40, dwArg10);
					goto l080B9FDC;
				}
			}
			else
			{
				if (esi_162 == 2251394350)
				{
					Eq_4 ebx_517;
					if (dwArg08 == 135066336)
						ebx_517 = *dwArg0C;
					else
						ebx_517.u0 = 0x00;
					if (dwArg08 == 135066336)
					{
						fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, ebx_517, 0x00, dwArg10);
						goto l080B9FDC;
					}
				}
				bool Z_582;
				if (esi_162 == ~0x69C06400)
				{
					Eq_4 ebx_548;
					if (dwArg08 == 0x080CEC20)
						ebx_548 = *dwArg0C;
					else
						ebx_548.u0 = 0x00;
					if (dwArg08 == 0x080CEC20)
					{
						fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, ebx_548, 0x01, dwArg10);
						goto l080B9FDC;
					}
					Z_582 = SLICE(cond(esi_162 - 0xB0C23ED3), bool, 2);
				}
				else
					Z_582 = SLICE(cond(esi_162 - 0xB0C23ED3), bool, 2);
				if (Z_582)
					goto l080B9FC7;
				if (dwArg08 == 0x080CE820)
					xmm0.u0 = (uint128) (uint32) *dwArg0C;
				else
					xmm0 = __xorps(xmm0, xmm0);
				if (dwArg08 == 0x080CE820)
				{
					fmt.(*pp).fmtFloat(gs, dwArg04, (real64) xmm0, 0x20, dwArg10);
					goto l080B9FDC;
				}
			}
		}
		else if (esi_162 <= 3494570045)
		{
			if (esi_162 <= 0xBBAD4102)
			{
				bool Z_468;
				if (esi_162 == 3004847213)
				{
					if (dwArg08 == 0x080CE7A0)
					{
						xmm0.u0 = (uint128) (uint64) *((word32) dwArg0C + 8);
						xmm1.u0 = (uint128) (uint64) *dwArg0C;
					}
					else
					{
						xmm1 = __xorps(xmm1, xmm1);
						xmm0 = __xorps(xmm0, xmm0);
					}
					if (dwArg08 == 0x080CE7A0)
					{
						fmt.(*pp).fmtComplex(gs, dwArg04, (real64) xmm1, (real64) xmm0, 0x80, dwArg10);
						goto l080B9FDC;
					}
					Z_468 = SLICE(cond(esi_162 - 0xBBAD4102), bool, 2);
				}
				else
					Z_468 = SLICE(cond(esi_162 - 0xBBAD4102), bool, 2);
				if (Z_468)
					goto l080B9FC7;
				Eq_4 ebx_476;
				if (dwArg08 == 0x080CEBE0)
					ebx_476 = *dwArg0C;
				else
					ebx_476.u0 = 0x00;
				if (dwArg08 == 0x080CEBE0)
				{
					fmt.(*pp).fmtInteger(edx, ebx_476 >> 0x1F, ebp, edi, gs, dwArg04, ebx_476, 0x01, dwArg10);
					goto l080B9FDC;
				}
			}
			else
			{
				if (esi_162 == 3175798674)
				{
					Eq_4 ebx_336;
					if (dwArg08 == 0x080CF360)
						ebx_336 = *dwArg0C;
					else
						ebx_336.u0 = 0x00;
					if (dwArg08 == 0x080CF360)
					{
						fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, ebx_336, 0x00, dwArg10);
						goto l080B9FDC;
					}
				}
				bool Z_395;
				if (esi_162 == 0xCC06C027)
				{
					uip32 ebx_1741;
					if (dwArg08 == 0x080CEC60)
						ebx_1741 = (word32) *dwArg0C;
					else
						ebx_1741 = 0x00;
					byte bl_375 = (byte) ebx_1741;
					if (dwArg08 == 0x080CEC60)
					{
						fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, (int32) bl_375, 0x01, dwArg10);
						goto l080B9FDC;
					}
					Z_395 = SLICE(cond(esi_162 - 3494570045), bool, 2);
				}
				else
					Z_395 = SLICE(cond(esi_162 - 3494570045), bool, 2);
				if (Z_395)
					goto l080B9FC7;
				Eq_4 ebx_403;
				if (dwArg08 == 0x080CF2A0)
					ebx_403 = *dwArg0C;
				else
					ebx_403.u0 = 0x00;
				if (dwArg08 == 0x080CF2A0)
				{
					fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, ebx_403, 0x00, dwArg10);
					goto l080B9FDC;
				}
			}
		}
		else if (esi_162 <= ~0x1F00A34B)
		{
			bool Z_294;
			if (esi_162 == 3585636114)
			{
				Eq_4 ebx_275;
				if (dwArg08 == 0x080CF220)
					ebx_275 = *dwArg0C;
				else
					ebx_275.u0 = 0x00;
				if (dwArg08 == 0x080CF220)
				{
					fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, ebx_275, 0x00, dwArg10);
					goto l080B9FDC;
				}
				Z_294 = SLICE(cond(esi_162 - ~0x1F00A34B), bool, 2);
			}
			else
				Z_294 = SLICE(cond(esi_162 - ~0x1F00A34B), bool, 2);
			if (Z_294)
				goto l080B9FC7;
			Eq_4 ebx_303;
			Eq_4 esi_302;
			if (dwArg08 == 135066016)
			{
				ebx_303 = *((word32) dwArg0C + 4);
				esi_302 = *dwArg0C;
			}
			else
			{
				esi_302.u0 = 0x00;
				ebx_303.u0 = 0x00;
			}
			if (dwArg08 == 135066016)
			{
				fmt.(*pp).fmtString(gs, dwArg04, esi_302, ebx_303, dwArg10);
				goto l080B9FDC;
			}
		}
		else
		{
			if (esi_162 == 0xECD580CE)
			{
				uipr32 ebx_1737;
				if (dwArg08 == 0x080CEBA0)
					ebx_1737 = (word32) *dwArg0C;
				else
					ebx_1737 = 0x00;
				word16 bx_180 = (word16) ebx_1737;
				if (dwArg08 == 0x080CEBA0)
				{
					fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, (int32) bx_180, 0x01, dwArg10);
					goto l080B9FDC;
				}
			}
			if (esi_162 == ~0x100DF15F)
			{
				uipr32 ebx_1739;
				if (dwArg08 == 0x080CF260)
					ebx_1739 = (word32) *dwArg0C;
				else
					ebx_1739 = 0x00;
				word16 bx_217 = (word16) ebx_1739;
				if (dwArg08 == 0x080CF260)
				{
					fmt.(*pp).fmtInteger(edx, ebx, ebp, edi, gs, dwArg04, (word32) bx_217, 0x00, dwArg10);
					goto l080B9FDC;
				}
			}
			if (esi_162 != 4149441018)
				goto l080B9FC7;
			Eq_4 ebx_242;
			if (dwArg08 == 0x080CEB60)
				ebx_242 = *dwArg0C;
			else
				ebx_242.u0 = 0x00;
			if (dwArg08 == 0x080CEB60)
			{
				fmt.(*pp).fmtInteger(edx, ebx_242 >> 0x1F, ebp, edi, gs, dwArg04, ebx_242, 0x01, dwArg10);
				goto l080B9FDC;
			}
		}
	}
l080B9FC7:
	fmt.(*pp).handleMethods(gs, dwArg04, dwArg10);
	if ((byte) (word32) bLoc30_1512 == 0x00)
	{
		reflect.ValueOf(gs, dwArg08, dwArg0C);
		fmt.(*pp).printValue(gs, dwArg04, dwLoc30, dwLoc2C, dwLoc28, dwArg10, 0x00);
	}
	goto l080B9FDC;
}

// 080BA7B0: void fmt.(*pp).printValue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).printValue(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	byte bLoc0110 = (byte) rLoc0110;
	Eq_4 dwLoc010C = SLICE(rLoc0110, word32, 32);
	Eq_4 dwLoc0108_3831 = (word32) rLoc0108;
	Eq_4 dwLoc0104_3904 = SLICE(rLoc0108, word32, 32);
	while (fp - 0x9C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 dwLoc010C_3794;
	Eq_4 dwLoc0110_3793;
	word24 nLoc010F_3800;
	byte bLoc0110_3812;
	struct Eq_138171 * esp_1067 = fp - 0x011C;
	if (dwArg18 > 0x00)
	{
		dwLoc0110_3793 = (word32) rLoc0110;
		dwLoc010C_3794 = dwLoc010C;
		nLoc010F_3800 = SLICE(dwLoc0110_3793, word24, 8);
		bLoc0110_3812 = (byte) dwLoc0110_3793;
		if (dwArg10 != 0x00)
		{
			reflect.Value.CanInterface(gs, dwArg10);
			Eq_4 dwLoc0110_3697 = (word32) rLoc0110;
			if ((byte) (word32) bLoc0110 != 0x00)
			{
				word128 xmm1_5479;
				reflect.Value.Interface(gs, dwArg08, dwArg0C, dwArg10, out xmm1_5479);
				*((word32) dwArg04 + 0x0C) = dwLoc0110_3697;
				byte bLoc0114_3718 = (byte) dwArg10;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg04 + 16) = dwLoc010C;
				else
					runtime.writebarrierptr((word32) dwArg04 + 16, dwLoc010C);
				fmt.(*pp).handleMethods(gs, dwArg04, dwArg14);
				if ((byte) (word32) bLoc0114_3718 != 0x00)
					return;
			}
		}
	}
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) dwArg04 + 16)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) dwArg04 + 16, 0x00);
	*((word32) dwArg04 + 28) = dwArg10;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 20) = dwArg08;
		*((word32) dwArg04 + 24) = dwArg0C;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, dwArg08);
		runtime.writebarrierptr((word32) dwArg04 + 24, dwArg0C);
	}
	if ((dwArg10 & 0x1F) <= 0x10)
	{
		if ((dwArg10 & 0x1F) > 0x0C)
		{
			if ((dwArg10 & 0x1F) <= 0x0E)
			{
				if ((dwArg10 & 0x1F) == 0x0D)
				{
					reflect.Value.Float(gs, dwArg10);
					fmt.(*pp).fmtFloat(gs, dwArg04, (real64) (uint128) (uint64) rLoc0110, 0x20, dwArg14);
				}
				else
				{
					reflect.Value.Float(gs, dwArg10);
					fmt.(*pp).fmtFloat(gs, dwArg04, (real64) (uint128) (uint64) rLoc0110, 0x40, dwArg14);
				}
			}
			else if ((dwArg10 & 0x1F) == 0x0F)
			{
				reflect.Value.Complex(gs, dwArg10);
				fmt.(*pp).fmtComplex(gs, dwArg04, (real64) (uint128) (uint64) rLoc0110, (real64) (uint128) (uint64) rLoc0108, 0x40, dwArg14);
			}
			else
			{
				reflect.Value.Complex(gs, dwArg10);
				fmt.(*pp).fmtComplex(gs, dwArg04, (real64) (uint128) (uint64) rLoc0110, (real64) (uint128) (uint64) rLoc0108, 0x80, dwArg14);
			}
			return;
		}
		if ((dwArg10 & 0x1F) <= 0x01)
		{
			if ((dwArg10 & 0x1F) != 0x00)
			{
				reflect.Value.Bool(gs, dwArg10);
				fmt.(*pp).fmtBool(gs, dwArg04, (byte) (word32) bLoc0110_3812, dwArg14);
				return;
			}
			else if (dwArg18 != 0x00)
			{
				if (dwArg14 != 118)
				{
					fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
					return;
				}
				else
				{
					Eq_4 eax_386 = *((word32) dwArg04 + 4);
					Eq_4 ebx_389 = *((word32) dwArg04 + 8);
					Eq_4 ebp_390 = *dwArg04;
					if ((word32) eax_386 + 5 > ebx_389)
					{
						word32 esi_5438;
						runtime.growslice(gs, 0x080CF320, ebp_390, eax_386, ebx_389, (word32) eax_386 + 5, out esi_5438);
						ebx_389 = dwLoc0100;
						ebp_390 = dwLoc0108_3831;
					}
					if ((word32) eax_386 + 5 > ebx_389)
						runtime.panicslice(gs);
					else
					{
						word32 esi_5440;
						word32 ebp_5439;
						word32 edi_5441;
						runtime.memmove(eax_386 + ebp_390, 0x080E0FC5, 0x05, out ebp_5439, out esi_5440, out edi_5441);
						*((word32) dwArg04 + 4) = (word32) eax_386 + 5;
						*((word32) dwArg04 + 8) = ebx_389;
						if (g_t81576F0 == 0x00)
							*dwArg04 = ebp_390;
						else
							runtime.writebarrierptr(dwArg04, ebp_390);
						return;
					}
				}
			}
			else
			{
				Eq_4 eax_465 = *((word32) dwArg04 + 4);
				Eq_4 ebx_468 = *((word32) dwArg04 + 8);
				Eq_4 ebp_469 = *dwArg04;
				if ((word32) eax_465 + 23 > ebx_468)
				{
					word32 esi_5427;
					runtime.growslice(gs, 0x080CF320, ebp_469, eax_465, ebx_468, (word32) eax_465 + 23, out esi_5427);
					ebx_468 = dwLoc0100;
					ebp_469 = dwLoc0108_3831;
				}
				if ((word32) eax_465 + 23 > ebx_468)
					runtime.panicslice(gs);
				else
				{
					word32 esi_5429;
					word32 ebp_5428;
					word32 edi_5430;
					runtime.memmove(eax_465 + ebp_469, 0x080E380D, 0x17, out ebp_5428, out esi_5429, out edi_5430);
					*((word32) dwArg04 + 4) = (word32) eax_465 + 23;
					*((word32) dwArg04 + 8) = ebx_468;
					if (g_t81576F0 == 0x00)
						*dwArg04 = ebp_469;
					else
						runtime.writebarrierptr(dwArg04, ebp_469);
					return;
				}
			}
		}
		if ((dwArg10 & 0x1F) <= 0x06)
		{
			reflect.Value.Int(gs, dwArg10);
			fmt.(*pp).fmtInteger(SLICE(dwArg04, word24, 8), ebx, ebp, edi, gs, dwArg04, dwLoc0110_3793, 0x01, dwArg14);
			return;
		}
		if ((dwArg10 & 0x1F) <= 0x0C)
		{
			reflect.Value.Uint(gs, dwArg10);
			fmt.(*pp).fmtInteger(SLICE(dwArg04, word24, 8), ebx, ebp, edi, gs, dwArg04, dwLoc0110_3793, 0x00, dwArg14);
			return;
		}
		goto l080BB330;
	}
	Eq_4 dwLoc0108_4124;
	Eq_4 dwLoc0104_4233;
	if ((dwArg10 & 0x1F) <= 0x15)
	{
		if ((dwArg10 & 0x1F) > 0x13)
		{
			if ((dwArg10 & 0x1F) == 0x14)
			{
				reflect.Value.Elem(gs, dwArg08, dwArg0C, dwArg10);
				dwLoc0108_4124 = (word32) rLoc0108;
				dwLoc0104_4233 = SLICE(rLoc0108, word32, 32);
				if (dwLoc0108_3831 != 0x00)
				{
					fmt.(*pp).printValue(gs, dwArg04, dwLoc0110_3793, dwLoc010C, dwLoc0108_3831, dwArg14, (word32) dwArg18 + 1);
					return;
				}
				else if ((byte) (word32) *((word32) dwArg04 + 44) != 0x00)
				{
					reflect.Value.Type(gs, dwArg08, dwArg10);
					Eq_4 ecx_1500 = *((word32) dwLoc0110_3793 + 0x0084);
					ecx_1500();
					Eq_4 ebx_1509 = *((word32) dwArg04 + 4);
					word32 ebp_1510 = dwArg10 + ebx_1509;
					Eq_4 esi_1512 = *((word32) dwArg04 + 8);
					Eq_4 edi_1513 = *dwArg04;
					if (ebp_1510 > esi_1512)
					{
						word32 esi_5467;
						runtime.growslice(gs, 0x080CF320, edi_1513, ebx_1509, esi_1512, ebp_1510, out esi_5467);
						esi_1512 = dwLoc0100;
						edi_1513 = dwLoc0108_4124;
					}
					if (ebp_1510 > esi_1512)
						runtime.panicslice(gs);
					else
					{
						word32 edi_5470;
						word32 esi_5469;
						word32 ebp_5468;
						runtime.memmove(edi_1513 + ebx_1509, dwArg0C, dwArg10, out ebp_5468, out esi_5469, out edi_5470);
						*((word32) dwArg04 + 4) = ebp_1510;
						*((word32) dwArg04 + 8) = esi_1512;
						if (g_t81576F0 == 0x00)
							*dwArg04 = edi_1513;
						else
							runtime.writebarrierptr(dwArg04, edi_1513);
						Eq_4 eax_1606 = edi_1513;
						Eq_4 edx_1596 = *((word32) dwArg04 + 4);
						Eq_4 ebp_1600 = *((word32) dwArg04 + 8);
						if ((word32) edx_1596 + 5 > ebp_1600)
						{
							word32 esi_5471;
							runtime.growslice(gs, 0x080CF320, edi_1513, edx_1596, ebp_1600, (word32) edx_1596 + 5, out esi_5471);
							ebp_1600 = dwLoc0100;
							eax_1606 = dwLoc0108_4124;
						}
						if ((word32) edx_1596 + 5 > ebp_1600)
							runtime.panicslice(gs);
						else
						{
							word32 ebp_5472;
							word32 esi_5473;
							word32 edi_5474;
							runtime.memmove(eax_1606 + edx_1596, 0x080E0FB1, 0x05, out ebp_5472, out esi_5473, out edi_5474);
							*((word32) dwArg04 + 4) = (word32) edx_1596 + 5;
							*((word32) dwArg04 + 8) = ebp_1600;
							if (g_t81576F0 == 0x00)
								*dwArg04 = eax_1606;
							else
								runtime.writebarrierptr(dwArg04, eax_1606);
							return;
						}
					}
				}
				else
				{
					Eq_4 ecx_1676 = *((word32) dwArg04 + 4);
					Eq_4 ebx_1679 = *((word32) dwArg04 + 8);
					Eq_4 ebp_1680 = *dwArg04;
					if ((word32) ecx_1676 + 5 > ebx_1679)
					{
						word32 esi_5463;
						runtime.growslice(gs, 0x080CF320, ebp_1680, ecx_1676, ebx_1679, (word32) ecx_1676 + 5, out esi_5463);
						ebx_1679 = dwLoc0100;
						ebp_1680 = dwLoc0108_4124;
					}
					if ((word32) ecx_1676 + 5 > ebx_1679)
						runtime.panicslice(gs);
					else
					{
						word32 edi_5466;
						word32 ebp_5464;
						word32 esi_5465;
						runtime.memmove(ebp_1680 + ecx_1676, 0x080E0FC5, 0x05, out ebp_5464, out esi_5465, out edi_5466);
						*((word32) dwArg04 + 4) = (word32) ecx_1676 + 5;
						*((word32) dwArg04 + 8) = ebx_1679;
						if (g_t81576F0 == 0x00)
							*dwArg04 = ebp_1680;
						else
							runtime.writebarrierptr(dwArg04, ebp_1680);
						return;
					}
				}
			}
			else
			{
				if ((byte) (word32) *((word32) dwArg04 + 44) == 0x00)
				{
					Eq_4 ecx_2029 = *((word32) dwArg04 + 4);
					Eq_4 eax_2032 = *((word32) dwArg04 + 8);
					Eq_4 esi_2033 = *dwArg04;
					if ((word32) ecx_2029 + 4 > eax_2032)
					{
						word32 esi_5422;
						runtime.growslice(gs, 0x080CF320, esi_2033, ecx_2029, eax_2032, (word32) ecx_2029 + 4, out esi_5422);
						dwLoc0110_3793 = eax_2032;
						dwLoc010C_3794 = (word32) ecx_2029 + 4;
						esi_2033 = dwLoc0108_4124;
						eax_2032 = dwLoc0100;
					}
					if ((word32) ecx_2029 + 4 > eax_2032)
						runtime.panicslice(gs);
					word32 edi_5425;
					word32 esi_5424;
					word32 ebp_5423;
					runtime.memmove(esi_2033 + ecx_2029, 135139130, 0x04, out ebp_5423, out esi_5424, out edi_5425);
					*((word32) dwArg04 + 4) = (word32) ecx_2029 + 4;
					*((word32) dwArg04 + 8) = eax_2032;
					if (g_t81576F0 == 0x00)
						*dwArg04 = esi_2033;
					else
						runtime.writebarrierptr(dwArg04, esi_2033);
				}
				else
				{
					reflect.Value.Type(gs, dwArg08, dwArg10);
					Eq_4 ecx_1772 = *((word32) dwLoc0110_3793 + 0x0084);
					ecx_1772();
					Eq_4 ebx_1781 = *((word32) dwArg04 + 4);
					word32 ebp_1782 = dwArg10 + ebx_1781;
					Eq_4 esi_1784 = *dwArg04;
					dwLoc0110_3793 = *((word32) dwArg04 + 8);
					if (ebp_1782 > dwLoc0110_3793)
					{
						word32 esi_5458;
						runtime.growslice(gs, 0x080CF320, esi_1784, ebx_1781, dwLoc0110_3793, ebp_1782, out esi_5458);
						dwLoc010C_3794 = ebp_1782;
						dwLoc0110_3793 = dwLoc0100;
						esi_1784 = dwLoc0108_4124;
					}
					byte bLoc0110_4203 = (byte) dwLoc0110_3793;
					if (ebp_1782 > dwLoc0110_3793)
						runtime.panicslice(gs);
					word32 edi_5461;
					word32 esi_5460;
					word32 ebp_5459;
					runtime.memmove(esi_1784 + ebx_1781, dwArg0C, dwArg10, out ebp_5459, out esi_5460, out edi_5461);
					*((word32) dwArg04 + 4) = ebp_1782;
					*((word32) dwArg04 + 8) = dwLoc0110_3793;
					if (g_t81576F0 == 0x00)
						*dwArg04 = esi_1784;
					else
						runtime.writebarrierptr(dwArg04, esi_1784);
					reflect.Value.IsNil(gs, dwArg10);
					if ((byte) (word32) bLoc0110_4203 != 0x00)
					{
						Eq_4 ecx_1886 = *((word32) dwArg04 + 4);
						Eq_4 ebx_1889 = *((word32) dwArg04 + 8);
						Eq_4 ebp_1890 = *dwArg04;
						if ((word32) ecx_1886 + 5 > ebx_1889)
						{
							word32 esi_5475;
							runtime.growslice(gs, 0x080CF320, ebp_1890, ecx_1886, ebx_1889, (word32) ecx_1886 + 5, out esi_5475);
							ebp_1890 = dwLoc0108_4124;
							ebx_1889 = dwLoc0100;
						}
						if ((word32) ecx_1886 + 5 > ebx_1889)
							runtime.panicslice(gs);
						else
						{
							word32 esi_5477;
							word32 edi_5478;
							word32 ebp_5476;
							runtime.memmove(ebp_1890 + ecx_1886, 0x080E0FB1, 0x05, out ebp_5476, out esi_5477, out edi_5478);
							*((word32) dwArg04 + 4) = (word32) ecx_1886 + 5;
							*((word32) dwArg04 + 8) = ebx_1889;
							if (g_t81576F0 == 0x00)
								*dwArg04 = ebp_1890;
							else
								runtime.writebarrierptr(dwArg04, ebp_1890);
							return;
						}
					}
					Eq_4 ecx_1968 = *((word32) dwArg04 + 8);
					Eq_4 edx_1969 = *dwArg04;
					Eq_4 ebx_1970 = *((word32) dwArg04 + 4);
					if ((word32) ebx_1970 + 1 > ecx_1968)
					{
						word32 esi_5462;
						runtime.growslice(gs, 0x080CF320, edx_1969, ebx_1970, ecx_1968, (word32) ebx_1970 + 1, out esi_5462);
						*((word32) dwArg04 + 8) = dwLoc0100;
						dwLoc0110_3793 = ecx_1968;
						dwLoc010C_3794 = (word32) ebx_1970 + 1;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4124;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
						ebx_1970 = dwLoc0104_4233;
						edx_1969 = dwLoc0108_4124;
					}
					*((word32) dwArg04 + 4) = (word32) ebx_1970 + 1;
					Mem2028[edx_1969 + ebx_1970:byte] = 0x7B;
				}
				reflect.Value.MapKeys(gs, dwArg08, dwArg0C, dwArg10);
				Eq_4 ecx_2136 = dwLoc0110_3793;
				Eq_4 edx_2137 = 0x00;
				while (edx_2137 < dwLoc010C_3794)
				{
					Eq_4 ebx_2276 = *((word32) ecx_2136 + 8);
					Eq_4 ebp_2278 = *((word32) ecx_2136 + 4);
					Eq_4 esi_2280 = *ecx_2136;
					if (edx_2137 > 0x00)
					{
						if ((byte) (word32) *((word32) dwArg04 + 44) != 0x00)
						{
							Eq_4 eax_2356 = *((word32) dwArg04 + 4);
							Eq_4 ecx_2359 = *dwArg04;
							Eq_4 ebx_2360 = *((word32) dwArg04 + 8);
							if ((word32) eax_2356 + 2 > ebx_2360)
							{
								word32 esi_5431;
								runtime.growslice(gs, 0x080CF320, ecx_2359, eax_2356, ebx_2360, (word32) eax_2356 + 2, out esi_5431);
								ebx_2360 = dwLoc0100;
								ecx_2359 = dwLoc0108_4124;
							}
							if ((word32) eax_2356 + 2 > ebx_2360)
								runtime.panicslice(gs);
							word32 edi_5434;
							word32 ebp_5432;
							word32 esi_5433;
							runtime.memmove(eax_2356 + ecx_2359, 0x080E0DB5, 0x02, out ebp_5432, out esi_5433, out edi_5434);
							*((word32) dwArg04 + 4) = (word32) eax_2356 + 2;
							*((word32) dwArg04 + 8) = ebx_2360;
							if (g_t81576F0 == 0x00)
								*dwArg04 = ecx_2359;
							else
								runtime.writebarrierptr(dwArg04, ecx_2359);
						}
						else
						{
							Eq_4 eax_2291 = *((word32) dwArg04 + 4);
							Eq_4 edx_2292 = *dwArg04;
							Eq_4 ecx_2293 = *((word32) dwArg04 + 8);
							if ((word32) eax_2291 + 1 > ecx_2293)
							{
								word32 esi_5437;
								runtime.growslice(gs, 0x080CF320, edx_2292, eax_2291, ecx_2293, (word32) eax_2291 + 1, out esi_5437);
								*((word32) dwArg04 + 8) = dwLoc0100;
								if (g_t81576F0 == 0x00)
									*dwArg04 = dwLoc0108_4124;
								else
									runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
								edx_2292 = dwLoc0108_4124;
								eax_2291 = dwLoc0104_4233;
							}
							*((word32) dwArg04 + 4) = (word32) eax_2291 + 1;
							Mem2354[edx_2292 + eax_2291:byte] = 0x20;
						}
					}
					fmt.(*pp).printValue(gs, dwArg04, esi_2280, ebp_2278, ebx_2276, dwArg14, (word32) dwArg18 + 1);
					Eq_4 ecx_2464 = *((word32) dwArg04 + 8);
					Eq_4 edx_2465 = *((word32) dwArg04 + 4);
					Eq_4 ebx_2466 = *dwArg04;
					if ((word32) edx_2465 + 1 > ecx_2464)
					{
						word32 esi_5436;
						runtime.growslice(gs, 0x080CF320, ebx_2466, edx_2465, ecx_2464, (word32) edx_2465 + 1, out esi_5436);
						*((word32) dwArg04 + 8) = dwLoc0100;
						if (g_t81576F0 == 0x00)
							*dwArg04 = (word32) dwArg18 + 1;
						else
							runtime.writebarrierptr(dwArg04, (word32) dwArg18 + 1);
						edx_2465 = dwLoc0104_4233;
						ebx_2466 = (word32) dwArg18 + 1;
					}
					*((word32) dwArg04 + 4) = (word32) edx_2465 + 1;
					Mem2527[ebx_2466 + edx_2465:byte] = 0x3A;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					reflect.Value.MapIndex(gs, stackArg4, dwArg10, esi_2280, ebp_2278, ebx_2276);
					fmt.(*pp).printValue(gs, dwArg04, dwLoc0104_4233, dwLoc0100, dwLocFC, dwArg14, (word32) dwArg18 + 1);
					dwLoc0108_4124 = (word32) dwArg18 + 1;
					ecx_2136 = (word32) ecx_2136 + 0x0C;
					edx_2137 = (word32) edx_2137 + 1;
				}
				if ((byte) (word32) *((word32) dwArg04 + 44) != 0x00)
				{
					Eq_4 ecx_2212 = *((word32) dwArg04 + 8);
					Eq_4 edx_2213 = *((word32) dwArg04 + 4);
					Eq_4 ebx_2214 = *dwArg04;
					if ((word32) edx_2213 + 1 > ecx_2212)
					{
						word32 esi_2230;
						runtime.growslice(gs, 0x080CF320, ebx_2214, edx_2213, ecx_2212, (word32) edx_2213 + 1, out esi_2230);
						*((word32) dwArg04 + 8) = dwLoc0100;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4124;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
						edx_2213 = dwLoc0104_4233;
						ebx_2214 = dwLoc0108_4124;
					}
					*((word32) dwArg04 + 4) = (word32) edx_2213 + 1;
					Mem2272[ebx_2214 + edx_2213:byte] = 0x7D;
				}
				else
				{
					Eq_4 ecx_2152 = *((word32) dwArg04 + 4);
					Eq_4 edx_2153 = *dwArg04;
					Eq_4 ebx_2154 = *((word32) dwArg04 + 8);
					if ((word32) ecx_2152 + 1 > ebx_2154)
					{
						word32 esi_2171;
						runtime.growslice(gs, 0x080CF320, edx_2153, ecx_2152, ebx_2154, (word32) ecx_2152 + 1, out esi_2171);
						*((word32) dwArg04 + 8) = dwLoc0100;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4124;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
						ecx_2152 = dwLoc0104_4233;
						edx_2153 = dwLoc0108_4124;
					}
					*((word32) dwArg04 + 4) = (word32) ecx_2152 + 1;
					Mem2211[edx_2153 + ecx_2152:byte] = 0x5D;
				}
				return;
			}
		}
		if ((dwArg10 & 0x1F) == 0x11)
		{
l080BA86B:
			if (dwArg14 <= 113)
			{
				if (dwArg14 != 88 && dwArg14 != 113)
					goto l080BAAF1;
			}
			else if (dwArg14 != 115 && dwArg14 != 0x78)
				goto l080BAAF1;
			reflect.Value.Type(gs, dwArg08, dwArg10);
			(*((word32) dwLoc0110_3793 + 44))();
			Eq_4 ecx_2671 = *((word32) dwArg0C + 84);
			ecx_2671();
			if (dwArg0C == 0x08)
			{
				Eq_4 dwLoc0118_4761;
				Eq_4 dwLoc0114_4762;
				Eq_4 edx_3473;
				Eq_4 ecx_3472;
				if ((dwArg10 & 0x1F) != 0x17)
				{
					if ((dwArg10 & 0x0100) == 0x00)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						reflect.Value.Len(gs, stackArg4, dwArg10);
						word32 edi_3547;
						runtime.makeslice(gs, 0x080CF320, dwLoc0110_3793, dwLoc0110_3793, out edi_3547);
						dwLoc0118_4761 = dwLoc0110_3793;
						dwLoc0114_4762 = dwLoc0110_3793;
						Eq_4 ebx_3560 = 0x00;
						while (true)
						{
							Eq_4 dwLoc0104_4834 = SLICE(rLoc0108, word32, 32);
							Eq_4 dwLoc0108_4835 = (word32) rLoc0108;
							edx_3473 = dwLoc0110_3793;
							ecx_3472 = dwLoc010C;
							if (ebx_3560 >= dwLoc010C)
								break;
							reflect.Value.Index(gs, dwArg08, dwArg0C, dwArg10, ebx_3560);
							reflect.Value.Uint(gs, dwLoc0104_4834);
							bLoc0110_3812 = (byte) ebx_3560;
							nLoc010F_3800 = SLICE(ebx_3560, word24, 8);
							dwLoc0118_4761 = dwLoc0108_4835;
							dwLoc0114_4762 = dwLoc0104_4834;
							byte al_3644 = (byte) ebx_3560;
							if (ebx_3560 >= dwLoc010C)
								runtime.panicindex(gs);
							Mem3645[dwLoc0110_3793 + ebx_3560:byte] = al_3644;
							ebx_3560 = (word32) ebx_3560 + 1;
						}
					}
					else
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						reflect.Value.Len(gs, stackArg4, dwArg10);
						reflect.Value.Slice(gs, dwArg08, dwArg0C, dwArg10, 0x00, dwLoc0110_3793);
						reflect.Value.Bytes(gs, dwLoc0108_4124, dwLoc0104_4233, dwLoc0100);
						bLoc0110_3812 = 0x00;
						nLoc010F_3800 = 0x00;
						dwLoc010C_3794 = dwLoc0110_3793;
						dwLoc0118_4761 = dwLoc0104_4233;
						dwLoc0114_4762 = dwLoc0100;
						ecx_3472 = dwLoc0110_3793;
						edx_3473.u0 = 0x00;
					}
				}
				else
				{
					reflect.Value.Bytes(gs, dwArg08, dwArg0C, dwArg10);
					dwLoc0118_4761 = dwArg0C;
					dwLoc0114_4762 = dwArg10;
					ecx_3472 = dwLoc010C;
					edx_3473 = dwLoc0110_3793;
				}
				(*((word32) dwLoc0110_3793 + 0x0084))();
				fmt.(*pp).fmtBytes(ebx, gs, dwArg04, edx_3473, ecx_3472, dwArg14, dwLoc0118_4761, dwLoc0114_4762);
				return;
			}
l080BAAF1:
			if ((byte) (word32) *((word32) dwArg04 + 44) != 0x00)
			{
				reflect.Value.Type(gs, dwArg08, dwArg10);
				Eq_4 ecx_2705 = *((word32) dwLoc0110_3793 + 0x0084);
				ecx_2705();
				Eq_4 ebx_2715 = *((word32) dwArg04 + 4);
				word32 ebp_2716 = dwArg10 + ebx_2715;
				Eq_4 esi_2718 = *dwArg04;
				dwLoc0110_3793 = *((word32) dwArg04 + 8);
				if (ebp_2716 > dwLoc0110_3793)
				{
					word32 esi_5411;
					runtime.growslice(gs, 0x080CF320, esi_2718, ebx_2715, dwLoc0110_3793, ebp_2716, out esi_5411);
					dwLoc010C_3794 = ebp_2716;
					esi_2718 = dwLoc0108_4124;
					dwLoc0110_3793 = dwLoc0100;
				}
				byte bLoc0110_4563 = (byte) dwLoc0110_3793;
				if (ebp_2716 > dwLoc0110_3793)
					runtime.panicslice(gs);
				else
				{
					word32 edi_2766;
					word32 esi_2767;
					word32 ebp_5412;
					runtime.memmove(esi_2718 + ebx_2715, dwArg0C, dwArg10, out ebp_5412, out esi_2767, out edi_2766);
					*((word32) dwArg04 + 4) = ebp_2716;
					*((word32) dwArg04 + 8) = dwLoc0110_3793;
					if (g_t81576F0 == 0x00)
						*dwArg04 = esi_2718;
					else
						runtime.writebarrierptr(dwArg04, esi_2718);
					Eq_4 dwLoc0110_4589;
					if ((dwArg10 & 0x1F) == 0x17)
					{
						reflect.Value.IsNil(gs, dwArg10);
						dwLoc0110_4589 = dwLoc0110_3793;
						if ((byte) (word32) bLoc0110_4563 != 0x00)
						{
							Eq_4 ecx_2824 = *((word32) dwArg04 + 4);
							Eq_4 ebx_2827 = *((word32) dwArg04 + 8);
							Eq_4 ebp_2828 = *dwArg04;
							if ((word32) ecx_2824 + 5 > ebx_2827)
							{
								word32 esi_5418;
								runtime.growslice(gs, 0x080CF320, ebp_2828, ecx_2824, ebx_2827, (word32) ecx_2824 + 5, out esi_5418);
								ebx_2827 = dwLoc0100;
								ebp_2828 = dwLoc0108_4124;
							}
							if ((word32) ecx_2824 + 5 > ebx_2827)
								runtime.panicslice(gs);
							else
							{
								word32 edi_5421;
								word32 ebp_5419;
								word32 esi_5420;
								runtime.memmove(ebp_2828 + ecx_2824, 0x080E0FB1, 0x05, out ebp_5419, out esi_5420, out edi_5421);
								*((word32) dwArg04 + 4) = (word32) ecx_2824 + 5;
								*((word32) dwArg04 + 8) = ebx_2827;
								if (g_t81576F0 == 0x00)
									*dwArg04 = ebp_2828;
								else
									runtime.writebarrierptr(dwArg04, ebp_2828);
								return;
							}
						}
					}
					Eq_4 eax_2909 = *((word32) dwArg04 + 4);
					Eq_4 edx_2910 = *dwArg04;
					Eq_4 ebx_2911 = *((word32) dwArg04 + 8);
					if ((word32) eax_2909 + 1 > ebx_2911)
					{
						word32 esi_2929;
						runtime.growslice(gs, 0x080CF320, edx_2910, eax_2909, ebx_2911, (word32) eax_2909 + 1, out esi_2929);
						*((word32) dwArg04 + 8) = dwLoc0100;
						dwLoc0110_4589 = ebx_2911;
						dwLoc010C_3794 = (word32) eax_2909 + 1;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4124;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
						edx_2910 = dwLoc0108_4124;
						eax_2909 = dwLoc0104_4233;
					}
					*((word32) dwArg04 + 4) = (word32) eax_2909 + 1;
					Mem2970[edx_2910 + eax_2909:byte] = 0x7B;
					Eq_4 eax_2971 = 0x00;
					while (true)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						reflect.Value.Len(gs, stackArg4, dwArg10);
						if (eax_2971 >= dwLoc0110_4589)
							break;
						if (eax_2971 > 0x00)
						{
							Eq_4 edx_3060 = *((word32) dwArg04 + 4);
							Eq_4 ebp_3063 = *((word32) dwArg04 + 8);
							Eq_4 esi_3064 = *dwArg04;
							if ((word32) edx_3060 + 2 > ebp_3063)
							{
								word32 esi_5414;
								runtime.growslice(gs, 0x080CF320, esi_3064, edx_3060, ebp_3063, (word32) edx_3060 + 2, out esi_5414);
								dwLoc010C_3794 = (word32) edx_3060 + 2;
								ebp_3063 = dwLoc0100;
								esi_3064 = dwLoc0108_4124;
							}
							if ((word32) edx_3060 + 2 > ebp_3063)
								runtime.panicslice(gs);
							word32 ebp_5415;
							word32 esi_5416;
							word32 edi_5417;
							runtime.memmove(esi_3064 + edx_3060, 0x080E0DB5, 0x02, out ebp_5415, out esi_5416, out edi_5417);
							*((word32) dwArg04 + 4) = (word32) edx_3060 + 2;
							*((word32) dwArg04 + 8) = ebp_3063;
							if (g_t81576F0 == 0x00)
								*dwArg04 = esi_3064;
							else
								runtime.writebarrierptr(dwArg04, esi_3064);
						}
						reflect.Value.Index(gs, dwArg08, dwArg0C, dwArg10, eax_2971);
						fmt.(*pp).printValue(gs, dwArg04, dwLoc010C_3794, dwLoc0108_4124, dwLoc0104_4233, dwArg14, (word32) dwArg18 + 1);
						dwLoc0110_4589 = dwLoc0104_4233;
						dwLoc010C_3794 = dwArg14;
						dwLoc0108_4124 = (word32) dwArg18 + 1;
						eax_2971 = (word32) eax_2971 + 1;
					}
					Eq_4 ecx_2996 = *((word32) dwArg04 + 8);
					Eq_4 edx_2997 = *((word32) dwArg04 + 4);
					Eq_4 ebx_2998 = *dwArg04;
					if ((word32) edx_2997 + 1 > ecx_2996)
					{
						word32 esi_3014;
						runtime.growslice(gs, 0x080CF320, ebx_2998, edx_2997, ecx_2996, (word32) edx_2997 + 1, out esi_3014);
						*((word32) dwArg04 + 8) = dwLoc0100;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4124;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
						edx_2997 = dwLoc0104_4233;
						ebx_2998 = dwLoc0108_4124;
					}
					*((word32) dwArg04 + 4) = (word32) edx_2997 + 1;
					Mem3056[ebx_2998 + edx_2997:byte] = 0x7D;
					return;
				}
			}
			else
			{
				Eq_4 ecx_3183 = *((word32) dwArg04 + 8);
				Eq_4 edx_3184 = *((word32) dwArg04 + 4);
				Eq_4 ebx_3185 = *dwArg04;
				if ((word32) edx_3184 + 1 > ecx_3183)
				{
					word32 esi_3201;
					runtime.growslice(gs, 0x080CF320, ebx_3185, edx_3184, ecx_3183, (word32) edx_3184 + 1, out esi_3201);
					*((word32) dwArg04 + 8) = dwLoc0100;
					dwLoc0110_3793 = ecx_3183;
					dwLoc010C_3794 = (word32) edx_3184 + 1;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc0108_4124;
					else
						runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
					edx_3184 = dwLoc0104_4233;
					ebx_3185 = dwLoc0108_4124;
				}
				*((word32) dwArg04 + 4) = (word32) edx_3184 + 1;
				Mem3243[ebx_3185 + edx_3184:byte] = 0x5B;
				Eq_4 ecx_3244 = 0x00;
				while (true)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					reflect.Value.Len(gs, stackArg4, dwArg10);
					if (ecx_3244 >= dwLoc0110_3793)
						break;
					if (ecx_3244 > 0x00)
					{
						Eq_4 edx_3346 = *((word32) dwArg04 + 4);
						Eq_4 ebx_3347 = *dwArg04;
						Eq_4 ebp_3348 = *((word32) dwArg04 + 8);
						if ((word32) edx_3346 + 1 > ebp_3348)
						{
							word32 esi_3364;
							runtime.growslice(gs, 0x080CF320, ebx_3347, edx_3346, ebp_3348, (word32) edx_3346 + 1, out esi_3364);
							*((word32) dwArg04 + 8) = dwLoc0100;
							dwLoc010C_3794 = (word32) edx_3346 + 1;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc0108_4124;
							else
								runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
							edx_3346 = dwLoc0104_4233;
							ebx_3347 = dwLoc0108_4124;
						}
						*((word32) dwArg04 + 4) = (word32) edx_3346 + 1;
						Mem3407[ebx_3347 + edx_3346:byte] = 0x20;
					}
					reflect.Value.Index(gs, dwArg08, dwArg0C, dwArg10, ecx_3244);
					fmt.(*pp).printValue(gs, dwArg04, dwLoc010C_3794, dwLoc0108_4124, dwLoc0104_4233, dwArg14, (word32) dwArg18 + 1);
					dwLoc0110_3793 = dwLoc0104_4233;
					dwLoc010C_3794 = dwArg14;
					dwLoc0108_4124 = (word32) dwArg18 + 1;
					ecx_3244 = (word32) ecx_3244 + 1;
				}
				Eq_4 ecx_3269 = *((word32) dwArg04 + 8);
				Eq_4 edx_3270 = *((word32) dwArg04 + 4);
				Eq_4 ebx_3271 = *dwArg04;
				if ((word32) edx_3270 + 1 > ecx_3269)
				{
					word32 esi_3287;
					runtime.growslice(gs, 0x080CF320, ebx_3271, edx_3270, ecx_3269, (word32) edx_3270 + 1, out esi_3287);
					*((word32) dwArg04 + 8) = dwLoc0100;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc0108_4124;
					else
						runtime.writebarrierptr(dwArg04, dwLoc0108_4124);
					edx_3270 = dwLoc0104_4233;
					ebx_3271 = dwLoc0108_4124;
				}
				*((word32) dwArg04 + 4) = (word32) edx_3270 + 1;
				Mem3329[ebx_3271 + edx_3270:byte] = 0x5D;
				return;
			}
		}
		if ((dwArg10 & 0x1F) <= 0x13)
		{
l080BB30C:
			fmt.(*pp).fmtPointer(dwArg08, gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			return;
		}
l080BB330:
		fmt.(*pp).unknownType(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
		return;
	}
	if ((dwArg10 & 0x1F) > 0x17)
	{
		if ((dwArg10 & 0x1F) == 0x18)
		{
			reflect.Value.String(gs, dwArg08, dwArg0C, dwArg10);
			fmt.(*pp).fmtString(gs, dwArg04, dwLoc0110_3793, dwLoc010C, dwArg14);
			return;
		}
		if ((dwArg10 & 0x1F) == 0x19)
		{
			if ((byte) (word32) *((word32) dwArg04 + 44) != 0x00)
			{
				reflect.Value.Type(gs, dwArg08, dwArg10);
				Eq_4 ecx_598 = *((word32) dwLoc0110_3793 + 0x0084);
				ecx_598();
				Eq_4 ebx_607 = *((word32) dwArg04 + 4);
				word32 ebp_608 = dwArg10 + ebx_607;
				Eq_4 esi_610 = *dwArg04;
				Eq_4 edi_611 = *((word32) dwArg04 + 8);
				if (ebp_608 > edi_611)
				{
					word32 esi_5454;
					runtime.growslice(gs, 0x080CF320, esi_610, ebx_607, edi_611, ebp_608, out esi_5454);
					bLoc0110_3812 = (byte) edi_611;
					nLoc010F_3800 = SLICE(edi_611, word24, 8);
					dwLoc010C_3794 = ebp_608;
					edi_611 = dwLoc0100;
					esi_610 = dwLoc0108_3831;
				}
				if (ebp_608 > edi_611)
					runtime.panicslice(gs);
				word32 esi_5456;
				word32 ebp_5455;
				word32 edi_5457;
				runtime.memmove(esi_610 + ebx_607, dwArg0C, dwArg10, out ebp_5455, out esi_5456, out edi_5457);
				*((word32) dwArg04 + 4) = ebp_608;
				*((word32) dwArg04 + 8) = edi_611;
				if (g_t81576F0 == 0x00)
					*dwArg04 = esi_610;
				else
					runtime.writebarrierptr(dwArg04, esi_610);
			}
			Eq_4 ecx_701 = *((word32) dwArg04 + 8);
			Eq_4 edi_702 = *((word32) dwArg04 + 4);
			Eq_4 eax_703 = *dwArg04;
			if ((word32) edi_702 + 1 > ecx_701)
			{
				word32 esi_722;
				runtime.growslice(gs, 0x080CF320, eax_703, edi_702, ecx_701, (word32) edi_702 + 1, out esi_722);
				*((word32) dwArg04 + 8) = dwLoc0100;
				bLoc0110_3812 = (byte) ecx_701;
				nLoc010F_3800 = SLICE(ecx_701, word24, 8);
				dwLoc010C_3794 = (word32) edi_702 + 1;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc0108_3831;
				else
					runtime.writebarrierptr(dwArg04, dwLoc0108_3831);
				eax_703 = dwLoc0108_3831;
				edi_702 = dwLoc0104_3904;
			}
			*((word32) dwArg04 + 4) = (word32) edi_702 + 1;
			Mem766[eax_703 + edi_702:byte] = 0x7B;
			Eq_4 ebp_1273 = dwArg0C;
			Eq_4 ebx_1272 = dwArg08;
			word32 ecx_1271 = 0x00;
			while (true)
			{
				esp_1067[24] = (struct Eq_138171) ecx_1271;
				esp_1067->t0000 = ebx_1272;
				esp_1067[1] = (struct Eq_138171) ebp_1273;
				esp_1067[2] = esp_1067[75];
				reflect.Value.NumField(gs, esp_1067[2]);
				int32 ecx_791 = esp_1067[24];
				if (ecx_791 >= esp_1067[3])
					break;
				Eq_4 ecx_1005;
				if (ecx_791 > 0x00)
				{
					Eq_4 eax_859 = esp_1067[72];
					if ((byte) (word32) *((word32) eax_859 + 44) != 0x00)
					{
						Eq_139520 edx_928 = *((word32) eax_859 + 4);
						esp_1067[0x0022] = (struct Eq_138171) ((word32) edx_928.u1 + 2);
						Eq_4 ebx_929 = (word32) edx_928.u1 + 2;
						Eq_4 ebp_931 = *((word32) eax_859 + 8);
						ptr32 esi_932 = *eax_859;
						if ((word32) edx_928.u1 + 2 > ebp_931)
						{
							esp_1067[33] = (struct Eq_138171) edx_928;
							esp_1067->t0000.u0 = 0x080CF320;
							esp_1067[1] = (struct Eq_138171) esi_932;
							esp_1067[2] = (struct Eq_138171) edx_928;
							esp_1067[3] = (struct Eq_138171) ebp_931;
							esp_1067[4] = (struct Eq_138171) ((word32) edx_928.u1 + 2);
							word32 esi_5443;
							runtime.growslice(gs, esp_1067->t0000, esp_1067[1], esp_1067[2], esp_1067[3], esp_1067[4], out esi_5443);
							ebp_931 = esp_1067[7];
							esi_932 = (ptr32) esp_1067[5];
							edx_928 = esp_1067[33];
							ebx_929 = esp_1067[0x0022];
						}
						if (ebx_929 > ebp_931)
							runtime.panicslice(gs);
						esp_1067[54] = (struct Eq_138171) esi_932;
						esp_1067[33] = (struct Eq_138171) ebp_931;
						esp_1067->t0000 = (word32) edx_928 + esi_932;
						esp_1067[1] = (struct Eq_138171) 0x080E0DB5;
						esp_1067[2] = (struct Eq_138171) 0x02;
						word32 esi_5445;
						word32 ebp_5444;
						word32 edi_5446;
						runtime.memmove(esp_1067->t0000, esp_1067[1], esp_1067[2], out ebp_5444, out esi_5445, out edi_5446);
						ecx_1005 = esp_1067[72];
						*((word32) ecx_1005 + 4) = esp_1067[0x0022];
						*((word32) ecx_1005 + 8) = esp_1067[33];
						if (g_t81576F0 == 0x00)
							*ecx_1005 = esp_1067[54];
						else
						{
							esp_1067->t0000 = ecx_1005;
							esp_1067[1] = esp_1067[54];
							runtime.writebarrierptr(esp_1067->t0000, esp_1067[1]);
							ecx_1005 = esp_1067[72];
						}
					}
					else
					{
						Eq_139520 edx_865 = *((word32) eax_859 + 4);
						ptr32 ebx_866 = *eax_859;
						Eq_4 ebp_867 = *((word32) eax_859 + 8);
						if ((word32) edx_865.u0 + 1 > ebp_867)
						{
							esp_1067->t0000.u0 = 0x080CF320;
							esp_1067[1] = (struct Eq_138171) ebx_866;
							esp_1067[2] = (struct Eq_138171) edx_865;
							esp_1067[3] = (struct Eq_138171) ebp_867;
							esp_1067[4] = (struct Eq_138171) ((word32) edx_865.u0 + 1);
							word32 esi_5453;
							runtime.growslice(gs, esp_1067->t0000, esp_1067[1], esp_1067[2], esp_1067[3], esp_1067[4], out esi_5453);
							ptr32 eax_888 = esp_1067[5];
							Eq_139520 ecx_889 = esp_1067[6];
							Eq_4 ebx_891 = esp_1067[72];
							*((word32) ebx_891 + 8) = esp_1067[7];
							if (g_t81576F0 == 0x00)
								*ebx_891 = eax_888;
							else
							{
								esp_1067[55] = (struct Eq_138171) eax_888;
								esp_1067[31] = (struct Eq_138171) ecx_889;
								esp_1067->t0000 = ebx_891;
								esp_1067[1] = (struct Eq_138171) eax_888;
								runtime.writebarrierptr(esp_1067->t0000, esp_1067[1]);
								eax_888 = (ptr32) esp_1067[55];
								ecx_889 = esp_1067[31];
							}
							edx_865 = ecx_889;
							ebx_866 = eax_888;
							eax_859 = esp_1067[72];
						}
						*((word32) eax_859 + 4) = (word32) edx_865.u0 + 1;
						*((word32) edx_865.u0 + ebx_866) = 0x20;
						ecx_1005 = eax_859;
					}
				}
				else
					ecx_1005 = esp_1067[72];
				if ((byte) (word32) *((word32) ecx_1005 + 43) != 0x00 || (byte) ((word32) (*((word32) ecx_1005 + 44))) != 0x00)
				{
					esp_1067->t0000 = esp_1067[73];
					esp_1067[1] = esp_1067[74];
					esp_1067[2] = esp_1067[75];
					reflect.Value.Type(gs, esp_1067->t0000, esp_1067[2]);
					Eq_4 eax_1042 = esp_1067[4];
					Eq_4 ecx_1044 = *((word32) esp_1067[3].dw001C + 20);
					word32 edx_1045 = esp_1067[24];
					esp_1067[1] = (struct Eq_138171) edx_1045;
					esp_1067->t0000 = eax_1042;
					ecx_1044();
					fn0809021E(esp_1067[50], esp_1067 + 58);
					esp_1067 = (struct Eq_138171 *) ((char *) esp_1067 - 4);
					word32 eax_1068 = esp_1067[59];
					word32 ecx_1069 = esp_1067[58];
					if (eax_1068 != 0x00)
					{
						struct Eq_139763 * edx_1074 = esp_1067[72];
						word32 ebx_1075 = edx_1074->dw0004;
						struct Eq_139771 * ebp_1076 = eax_1068 + ebx_1075;
						esp_1067[0x0022] = (struct Eq_138171) ebp_1076;
						struct Eq_139771 * esi_1078 = edx_1074->ptr0008;
						word32 edi_1079 = edx_1074->dw0000;
						if (ebp_1076 > esi_1078)
						{
							esp_1067[33] = (struct Eq_138171) ebx_1075;
							esp_1067[0x0F] = (struct Eq_138171) eax_1068;
							esp_1067[42] = (struct Eq_138171) ecx_1069;
							esp_1067->t0000.u0 = 0x080CF320;
							esp_1067[1] = (struct Eq_138171) edi_1079;
							esp_1067[2] = (struct Eq_138171) ebx_1075;
							esp_1067[3] = (struct Eq_138171) esi_1078;
							esp_1067[4] = (struct Eq_138171) ebp_1076;
							word32 esi_5447;
							runtime.growslice(gs, esp_1067->t0000, esp_1067[1], esp_1067[2], esp_1067[3], esp_1067[4], out esi_5447);
							edi_1079 = (word32) esp_1067[5];
							esi_1078 = (struct Eq_139771 *) esp_1067[7];
							eax_1068 = (word32) esp_1067[0x0F];
							ecx_1069 = (word32) esp_1067[42];
							ebx_1075 = (word32) esp_1067[33];
							ebp_1076 = (struct Eq_139771 *) esp_1067[0x0022];
						}
						if (ebp_1076 > esi_1078)
							runtime.panicslice(gs);
						ptr32 eax_1156;
						esp_1067[54] = (struct Eq_138171) edi_1079;
						esp_1067[33] = (struct Eq_138171) esi_1078;
						esp_1067->t0000 = edi_1079 + ebx_1075;
						esp_1067[1] = (struct Eq_138171) ecx_1069;
						esp_1067[2] = (struct Eq_138171) eax_1068;
						word32 ebp_5448;
						word32 edi_5450;
						word32 esi_5449;
						runtime.memmove(esp_1067->t0000, esp_1067[1], esp_1067[2], out ebp_5448, out esi_5449, out edi_5450);
						Eq_4 ecx_1137 = esp_1067[72];
						*((word32) ecx_1137 + 4) = esp_1067[0x0022];
						*((word32) ecx_1137 + 8) = esp_1067[33];
						if (g_t81576F0 == 0x00)
						{
							eax_1156 = (ptr32) esp_1067[54];
							*ecx_1137 = eax_1156;
						}
						else
						{
							esp_1067->t0000 = ecx_1137;
							esp_1067[1] = esp_1067[54];
							runtime.writebarrierptr(esp_1067->t0000, esp_1067[1]);
							eax_1156 = (ptr32) esp_1067[54];
							ecx_1137 = esp_1067[72];
						}
						Eq_4 edx_1162 = *((word32) ecx_1137 + 8);
						int32 ebx_1163 = *((word32) ecx_1137 + 4);
						if (ebx_1163 + 0x01 > edx_1162)
						{
							esp_1067->t0000.u0 = 0x080CF320;
							esp_1067[1] = (struct Eq_138171) eax_1156;
							esp_1067[2] = (struct Eq_138171) ebx_1163;
							esp_1067[3] = (struct Eq_138171) edx_1162;
							esp_1067[4] = (struct Eq_138171) (ebx_1163 + 0x01);
							word32 esi_5451;
							runtime.growslice(gs, esp_1067->t0000, esp_1067[1], esp_1067[2], esp_1067[3], esp_1067[4], out esi_5451);
							eax_1156 = (ptr32) esp_1067[5];
							int32 ecx_1188 = esp_1067[6];
							Eq_4 ebx_1190 = esp_1067[72];
							*((word32) ebx_1190 + 8) = esp_1067[7];
							if (g_t81576F0 == 0x00)
								*ebx_1190 = eax_1156;
							else
							{
								esp_1067[56] = (struct Eq_138171) eax_1156;
								esp_1067[32] = (struct Eq_138171) ecx_1188;
								esp_1067->t0000 = ebx_1190;
								esp_1067[1] = (struct Eq_138171) eax_1156;
								runtime.writebarrierptr(esp_1067->t0000, esp_1067[1]);
								eax_1156 = (ptr32) esp_1067[56];
								ecx_1188 = (int32) esp_1067[32];
							}
							ebx_1163 = ecx_1188;
							ecx_1137 = esp_1067[72];
						}
						*((word32) ecx_1137 + 4) = ebx_1163 + 0x01;
						eax_1156 + ebx_1163 = (byte *) 0x3A;
					}
				}
				esp_1067->t0000 = esp_1067[73];
				esp_1067[1] = esp_1067[74];
				esp_1067[2] = esp_1067[75];
				esp_1067[3] = esp_1067[24];
				fmt.getField(gs, esp_1067->t0000, esp_1067[2], esp_1067[3]);
				struct Eq_140037 * eax_1253 = esp_1067[6];
				word32 ecx_1254 = esp_1067[5];
				word32 edx_1255 = esp_1067[4];
				esp_1067->t0000 = esp_1067[72];
				esp_1067[1] = (struct Eq_138171) edx_1255;
				esp_1067[2] = (struct Eq_138171) ecx_1254;
				esp_1067[3] = (struct Eq_138171) eax_1253;
				esp_1067[4] = esp_1067[76];
				esp_1067[5] = (struct Eq_138171) ((word32) esp_1067[77].t0000 + 1);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg4 = <invalid>;
				fmt.(*pp).printValue(gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
				ecx_1271 = (word32) esp_1067[24].t0000 + 1;
				ebx_1272 = esp_1067[73];
				ebp_1273 = esp_1067[74];
			}
			Eq_4 eax_794 = esp_1067[72];
			ptr32 ecx_795 = *eax_794;
			Eq_4 edx_796 = *((word32) eax_794 + 8);
			int32 ebx_797 = *((word32) eax_794 + 4);
			if (ebx_797 + 0x01 > edx_796)
			{
				esp_1067->t0000.u0 = 0x080CF320;
				esp_1067[1] = (struct Eq_138171) ecx_795;
				esp_1067[2] = (struct Eq_138171) ebx_797;
				esp_1067[3] = (struct Eq_138171) edx_796;
				esp_1067[4] = (struct Eq_138171) (ebx_797 + 0x01);
				word32 esi_813;
				runtime.growslice(gs, esp_1067->t0000, esp_1067[1], esp_1067[2], esp_1067[3], esp_1067[4], out esi_813);
				ptr32 eax_818 = esp_1067[5];
				int32 ecx_819 = esp_1067[6];
				Eq_4 ebx_821 = esp_1067[72];
				*((word32) ebx_821 + 8) = esp_1067[7];
				if (g_t81576F0 == 0x00)
					*ebx_821 = eax_818;
				else
				{
					esp_1067[52] = (struct Eq_138171) eax_818;
					esp_1067[30] = (struct Eq_138171) ecx_819;
					esp_1067->t0000 = ebx_821;
					esp_1067[1] = (struct Eq_138171) eax_818;
					runtime.writebarrierptr(esp_1067->t0000, esp_1067[1]);
					eax_818 = (ptr32) esp_1067[52];
					ecx_819 = (int32) esp_1067[30];
					ebx_821 = esp_1067[72];
				}
				eax_794 = ebx_821;
				ebx_797 = ecx_819;
				ecx_795 = eax_818;
			}
			*((word32) eax_794 + 4) = ebx_797 + 0x01;
			ecx_795 + ebx_797 = (byte *) 0x7D;
			return;
		}
		if ((dwArg10 & 0x1F) == 0x1A)
			goto l080BB30C;
		goto l080BB330;
	}
	if ((dwArg10 & 0x1F) != 22)
		goto l080BA86B;
	if (dwArg18 != 0x00)
		goto l080BB30C;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	reflect.Value.Pointer(gs, stackArg4, dwArg10);
	if (dwLoc0110_3793 == 0x00)
		goto l080BB30C;
	reflect.Value.Elem(gs, dwArg08, dwArg0C, dwArg10);
	if ((dwLoc0108_3831 & 0x1F) <= 0x15)
	{
		if ((dwLoc0108_3831 & 0x1F) == 0x11 || (dwLoc0108_3831 & 0x1F) == 0x15)
		{
l080BBFEF:
			Eq_4 ebp_1339 = *((word32) dwArg04 + 4);
			Eq_4 esi_1340 = *((word32) dwArg04 + 8);
			Eq_4 edi_1341 = *dwArg04;
			if ((word32) ebp_1339 + 1 > esi_1340)
			{
				word32 esi_1362;
				runtime.growslice(gs, 0x080CF320, edi_1341, ebp_1339, esi_1340, (word32) ebp_1339 + 1, out esi_1362);
				*((word32) dwArg04 + 8) = dwLoc0100;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc0108_3831;
				else
					runtime.writebarrierptr(dwArg04, dwLoc0108_3831);
				ebp_1339 = dwLoc0104_3904;
				edi_1341 = dwLoc0108_3831;
			}
			*((word32) dwArg04 + 4) = (word32) ebp_1339 + 1;
			Mem1407[edi_1341 + ebp_1339:byte] = 0x26;
			fmt.(*pp).printValue(gs, dwArg04, dwLoc0110_3793, dwLoc010C, dwLoc0108_3831, dwArg14, (word32) dwArg18 + 1);
			return;
		}
	}
	else if ((dwLoc0108_3831 & 0x1F) == 0x17 || (dwLoc0108_3831 & 0x1F) == 0x19)
		goto l080BBFEF;
	goto l080BB30C;
}

// 080BCE80: void fmt.(*pp).doPrintln(Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm1, Stack Eq_4 dwArg04, Stack (ptr32 Eq_134925) dwArg08, Stack int32 dwArg0C)
// Called from:
//      fmt.Fprintln
void fmt.(*pp).doPrintln(struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm1, Eq_4 dwArg04, struct Eq_134925 * dwArg08, int32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	struct Eq_134925 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < dwArg0C; ++eax_17)
	{
		Eq_4 ebx_96 = ecx_20->dw0004;
		Eq_4 ebp_97 = ecx_20->dw0000;
		if (eax_17 > 0x00)
		{
			Eq_4 edi_102 = *((word32) dwArg04 + 8);
			Eq_4 edx_103 = *dwArg04;
			Eq_4 eax_104 = *((word32) dwArg04 + 4);
			if ((word32) eax_104 + 1 > edi_102)
			{
				word32 esi_310;
				runtime.growslice(gs, 0x080CF320, edx_103, eax_104, edi_102, (word32) eax_104 + 1, out esi_310);
				*((word32) dwArg04 + 8) = dwLoc24;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc2C;
				else
					runtime.writebarrierptr(dwArg04, dwLoc2C);
				edx_103 = dwLoc2C;
				eax_104 = dwLoc28;
			}
			*((word32) dwArg04 + 4) = (word32) eax_104 + 1;
			Mem166[edx_103 + eax_104:byte] = 0x20;
		}
		xmm0 = fmt.(*pp).printArg(gs, xmm0, xmm1, dwArg04, ebp_97, ebx_96, 118, out xmm1);
		++ecx_20;
	}
	Eq_4 ecx_28 = *((word32) dwArg04 + 8);
	Eq_4 edx_29 = *dwArg04;
	Eq_4 ebx_30 = *((word32) dwArg04 + 4);
	if ((word32) ebx_30 + 1 > ecx_28)
	{
		word32 esi_47;
		runtime.growslice(gs, 0x080CF320, edx_29, ebx_30, ecx_28, (word32) ebx_30 + 1, out esi_47);
		*((word32) dwArg04 + 8) = dwLoc24;
		if (g_t81576F0 == 0x00)
			*dwArg04 = dwLoc2C;
		else
			runtime.writebarrierptr(dwArg04, dwLoc2C);
		edx_29 = dwLoc2C;
		ebx_30 = dwLoc28;
	}
	*((word32) dwArg04 + 4) = (word32) ebx_30 + 1;
	Mem88[edx_29 + ebx_30:byte] = 0x0A;
}

// 080BD020: void fmt.glob..func1(Register (ptr32 Eq_2) gs)
void fmt.glob..func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080D9C00);
}

// 080BD060: Register word32 fmt.init(Register (ptr32 Eq_2) gs, Register out Eq_140846 xmm0Out, Register out Eq_140847 xmm1Out)
// Called from:
//      main.init
word32 fmt.init(struct Eq_2 * gs, union Eq_140846 & xmm0Out, union Eq_140847 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = (byte) (word32) g_b8157560;
	if (al_18 <= 0x01)
	{
		if (al_18 != 0x01)
		{
			g_b8157560 = 0x01;
			strconv.init(gs);
			io.init(gs);
			os.init(gs);
			Eq_140847 xmm1_67 = reflect.init(gs);
			word32 esi_78;
			Eq_140846 xmm0_80;
			word32 edi_230;
			sync.init(gs, out esi_78, out edi_230, out xmm0_80);
			errors.New(gs, 0x080E5FD4, 0x24);
			g_dw8145010 = dwLoc08;
			if (g_t81576F0 == 0x00)
				g_t8145014 = dwLoc04;
			else
				runtime.writebarrierptr(0x08145014, dwLoc04);
			errors.New(gs, 0x080E4D0E, 0x1D);
			g_dw8145008 = dwLoc08;
			if (g_t81576F0 == 0x00)
				g_t814500C = dwLoc04;
			else
				runtime.writebarrierptr(0x0814500C, dwLoc04);
			g_b8157560 = 0x02;
			xmm0Out = xmm0_80;
			xmm1Out = xmm1_67;
			return esi_78;
		}
		else
			runtime.throwinit(gs);
	}
	else
	{
		xmm0Out = xmm0;
		xmm1Out = xmm1;
		return esi;
	}
}

// 080BD160: void type..hash.fmt.fmt(Register (ptr32 Eq_2) gs, Register word64 mm0, Stack Eq_207 dwArg04, Stack Eq_207 dwArg08)
void type..hash.fmt.fmt(struct Eq_2 * gs, word64 mm0, Eq_207 dwArg04, Eq_207 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0D);
	runtime.memhash(gs, mm0, (word32) dwArg04 + 16, dwLoc04, 0x4C);
}

// 080BD1D0: void type..eq.fmt.fmt(Register (ptr32 Eq_140954) gs, Stack byte bArg00, Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08, Stack (ptr32 word32) dwArg0C)
void type..eq.fmt.fmt(struct Eq_140954 * gs, byte bArg00, word32 * dwArg04, word32 * dwArg08, word32 * dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uip32 ecx_125;
	struct Eq_140972 * esp_16 = fp - 0x10;
	word32 * eax_17 = dwArg04;
	word32 * edx_19 = dwArg08;
	if (*dwArg04 != *dwArg08)
		ecx_125 = 0x00;
	else
	{
		word32 edi_28;
		word32 esi_29;
		runtime.memequal(dwArg04 + 1, dwArg08 + 1, 0x09, out esi_29, out edi_28);
		esp_16 = fp - 0x0C;
		ecx_125 = (word32) bArg00;
		eax_17 = dwArg08;
		edx_19 = dwArg0C;
	}
	if ((byte) ecx_125 != 0x00)
	{
		esp_16->t0004 = edx_19 + 4;
		esp_16->t0000 = eax_17 + 4;
		esp_16->t0008.u0 = 0x4C;
		word32 edi_60;
		word32 esi_61;
		runtime.memequal(esp_16->t0000, esp_16->t0004, esp_16->t0008, out esi_61, out edi_60);
	}
}

// 080BD260: void main.main(Register (ptr32 Eq_2) gs, Register Eq_661 xmm0, Register Eq_661 xmm1)
// Called from:
//      runtime.main
void main.main(struct Eq_2 * gs, Eq_661 xmm0, Eq_661 xmm1)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.Println(gs, xmm0, xmm1, fp - 0x08, 0x01, 0x01);
}

// 080BD2C0: Register word32 main.init(Register (ptr32 Eq_2) gs, Register out Eq_46447 xmm0Out, Register out Eq_46448 xmm1Out)
// Called from:
//      runtime.main
word32 main.init(struct Eq_2 * gs, union Eq_46447 & xmm0Out, union Eq_46448 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_17 = (byte) (word32) g_b8157563;
	if (al_17 <= 0x01)
	{
		if (al_17 != 0x01)
		{
			g_b8157563 = 0x01;
			Eq_46447 xmm0_30;
			Eq_46448 xmm1_31;
			word32 esi_28 = fmt.init(gs, out xmm0_30, out xmm1_31);
			g_b8157563 = 0x02;
			xmm0Out = xmm0_30;
			xmm1Out = xmm1_31;
			return esi_28;
		}
		else
			runtime.throwinit(gs);
	}
	else
	{
		xmm0Out = xmm0;
		xmm1Out = xmm1;
		return esi;
	}
}

