//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <errno.h>
#include <getopt.h>
#include <libintl.h>
#include <locale.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <wchar.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct option {
    char * e0;
    int32_t e1;
    int32_t * e2;
    int32_t e3;
};

struct vtable_1ffe0_type {
    int64_t (*e0)();
    int64_t (*e1)();
};

// ------------------------- Classes --------------------------

// version

// ------------------- Function Prototypes --------------------

int64_t entry_point(int64_t a1);
int64_t function_1498(void);
int64_t function_14b0(void);
int64_t function_14e0(void);
int64_t function_1520(void);
int64_t function_1568(void);
int64_t function_1570(void);
int64_t function_1580(void);
int64_t function_16b8(void);
int64_t function_1738(void);
int64_t function_1740(void);
int64_t function_175c(int64_t a1);
int64_t function_d88(int64_t a1);
void function_dc0(int32_t status);
int32_t function_dd0(char * s, struct _IO_FILE * stream);
void function_de0(int32_t status);
void function_df0(int64_t * d);
int32_t function_e00(void (*func)(int64_t *), int64_t * arg, int64_t * dso_handle);
int32_t function_e10(int32_t c, struct _IO_FILE * stream);
int32_t function_e20(struct _IO_FILE * fp);
void (*function_e30(int32_t sig, void (*handler)(int32_t)))(int32_t);
int32_t function_e40(struct _IO_FILE * stream);
int64_t * function_e50(int32_t size);
char * function_e60(char * domainname, char * dirname);
int32_t function_e70(int64_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_e80(int32_t flag, char * format, ...);
int32_t function_e90(int32_t * s);
int64_t * function_ea0(int64_t * ptr, int32_t size);
void function_eb0(void);
void function_ec0(void);
int32_t function_ed0(struct _IO_FILE * stream);
char * function_ee0(char * domainname);
int32_t function_ef0(int32_t argc, char ** argv, char * shortopts, struct option * longopts, int32_t * longind);
int32_t function_f00(struct _IO_FILE * stream, int32_t flag, char * format, ...);
void function_f10(char * format, ...);
void function_f20(int64_t * ptr);
struct _IO_FILE * function_f30(char * filename, char * modes);
void function_f40(char * format, ...);
int32_t function_f50(int32_t * ws, struct _IO_FILE * stream);
char * function_f60(char * domainname, char * msgid, int32_t category);
int32_t * function_f70(void);
void function_f80(int32_t status, char * format, ...);
char * function_f90(int32_t category, char * locale);
int32_t function_fa0(struct _IO_FILE * stream);
int32_t * function_fb0(int32_t * ws, int32_t n, struct _IO_FILE * stream);
int64_t function_fc0(void);

// --------------------- Global Variables ---------------------

char * g1; // 0x1790
int64_t g2 = 0x1568; // 0x1fc10
int64_t g3 = 0x1520; // 0x1fc18
int64_t g4; // 0x1fc20
char (*g5)[8] = "version"; // 0x1fc28
void (*g6)() = (void (*)())0x1738; // 0x1ff98
int64_t g7 = 0; // 0x1ffd0
int64_t g10 = 4032; // 0x1ffe8
int64_t g11 = 0; // 0x20008
int32_t * g12 = NULL; // 0x20010
int32_t g13;
int64_t * g8 = &g4; // 0x1ffd8
struct vtable_1ffe0_type g9 = {
    .e0 = function_16b8,
    .e1 = function_fc0
}; // 0x1ffe0

// ------------------------ Functions -------------------------

// Address range: 0xd88 - 0xd9c
int64_t function_d88(int64_t a1) {
    // 0xd88
    int64_t result; // 0xd88
    return result;
}

// Address range: 0xdc0 - 0xdd0
void function_dc0(int32_t status) {
    // 0xdc0
    _exit(status);
}

// Address range: 0xdd0 - 0xde0
int32_t function_dd0(char * s, struct _IO_FILE * stream) {
    // 0xdd0
    return fputs(s, stream);
}

// Address range: 0xde0 - 0xdf0
void function_de0(int32_t status) {
    // 0xde0
    exit(status);
}

// Address range: 0xdf0 - 0xe00
void function_df0(int64_t * d) {
    // 0xdf0
    __cxa_finalize(d);
}

// Address range: 0xe00 - 0xe10
int32_t function_e00(void (*func)(int64_t *), int64_t * arg, int64_t * dso_handle) {
    // 0xe00
    return __cxa_atexit(func, arg, dso_handle);
}

// Address range: 0xe10 - 0xe20
int32_t function_e10(int32_t c, struct _IO_FILE * stream) {
    // 0xe10
    return fputc(c, stream);
}

// Address range: 0xe20 - 0xe30
int32_t function_e20(struct _IO_FILE * fp) {
    // 0xe20
    return __fpending(fp);
}

// Address range: 0xe30 - 0xe40
void (*function_e30(int32_t sig, void (*handler)(int32_t)))(int32_t) {
    // 0xe30
    return signal(sig, handler);
}

// Address range: 0xe40 - 0xe50
int32_t function_e40(struct _IO_FILE * stream) {
    // 0xe40
    return fclose(stream);
}

// Address range: 0xe50 - 0xe60
int64_t * function_e50(int32_t size) {
    // 0xe50
    return malloc(size);
}

// Address range: 0xe60 - 0xe70
char * function_e60(char * domainname, char * dirname) {
    // 0xe60
    return bindtextdomain(domainname, dirname);
}

// Address range: 0xe70 - 0xe80
int32_t function_e70(int64_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0xe70
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0xe80 - 0xe90
int32_t function_e80(int32_t flag, char * format, ...) {
    // 0xe80
    return __printf_chk(flag, format);
}

// Address range: 0xe90 - 0xea0
int32_t function_e90(int32_t * s) {
    // 0xe90
    return wcslen(s);
}

// Address range: 0xea0 - 0xeb0
int64_t * function_ea0(int64_t * ptr, int32_t size) {
    // 0xea0
    return realloc(ptr, size);
}

// Address range: 0xeb0 - 0xec0
void function_eb0(void) {
    // 0xeb0
    __gmon_start__();
}

// Address range: 0xec0 - 0xed0
void function_ec0(void) {
    // 0xec0
    abort();
}

// Address range: 0xed0 - 0xee0
int32_t function_ed0(struct _IO_FILE * stream) {
    // 0xed0
    return feof(stream);
}

// Address range: 0xee0 - 0xef0
char * function_ee0(char * domainname) {
    // 0xee0
    return textdomain(domainname);
}

// Address range: 0xef0 - 0xf00
int32_t function_ef0(int32_t argc, char ** argv, char * shortopts, struct option * longopts, int32_t * longind) {
    // 0xef0
    return getopt_long(argc, argv, shortopts, longopts, longind);
}

// Address range: 0xf00 - 0xf10
int32_t function_f00(struct _IO_FILE * stream, int32_t flag, char * format, ...) {
    // 0xf00
    return __fprintf_chk(stream, flag, format);
}

// Address range: 0xf10 - 0xf20
void function_f10(char * format, ...) {
    // 0xf10
    warn(format);
}

// Address range: 0xf20 - 0xf30
void function_f20(int64_t * ptr) {
    // 0xf20
    free(ptr);
}

// Address range: 0xf30 - 0xf40
struct _IO_FILE * function_f30(char * filename, char * modes) {
    // 0xf30
    return fopen64(filename, modes);
}

// Address range: 0xf40 - 0xf50
void function_f40(char * format, ...) {
    // 0xf40
    warnx(format);
}

// Address range: 0xf50 - 0xf60
int32_t function_f50(int32_t * ws, struct _IO_FILE * stream) {
    // 0xf50
    return fputws(ws, stream);
}

// Address range: 0xf60 - 0xf70
char * function_f60(char * domainname, char * msgid, int32_t category) {
    // 0xf60
    return dcgettext(domainname, msgid, category);
}

// Address range: 0xf70 - 0xf80
int32_t * function_f70(void) {
    // 0xf70
    return __errno_location();
}

// Address range: 0xf80 - 0xf90
void function_f80(int32_t status, char * format, ...) {
    // 0xf80
    err(status, format);
}

// Address range: 0xf90 - 0xfa0
char * function_f90(int32_t category, char * locale) {
    // 0xf90
    return setlocale(category, locale);
}

// Address range: 0xfa0 - 0xfb0
int32_t function_fa0(struct _IO_FILE * stream) {
    // 0xfa0
    return ferror(stream);
}

// Address range: 0xfb0 - 0xfc0
int32_t * function_fb0(int32_t * ws, int32_t n, struct _IO_FILE * stream) {
    // 0xfb0
    return fgetws(ws, n, stream);
}

// Address range: 0xfc0 - 0x1460
// From class:    version
// Type:          virtual member function
int64_t function_fc0(void) {
    // 0xfc0
    setlocale(LC_ALL, (char *)&g1);
    bindtextdomain("util-linux", "/usr/share/locale");
    textdomain("util-linux");
    function_1740();
    signal(SIGINT, 0x1570);
    signal(SIGTERM, 0x1570);
    int64_t v1; // 0xfc0
    int32_t v2 = getopt_long((int32_t)v1, (char **)v1, "Vh", (struct option *)&g5, NULL); // 0x105c
    int32_t v3 = v2; // 0xfc0
    int64_t v4; // 0xfc0
    int64_t v5; // 0xfc0
    int32_t v6; // 0xfc0
    int32_t v7; // 0xfc0
    char * v8; // 0xfc0
    int64_t v9; // 0xfc0
    int64_t v10; // 0xfc0
    int64_t v11; // 0xfc0
    int64_t v12; // 0xfc0
    switch (v2) {
        case -1: {
            int64_t * mem = malloc(0x8000); // 0x10c8
            if (mem == NULL) {
                // 0x1350
                err(1, "cannot allocate %zu bytes", 0x8000);
                goto lab_0x1364;
            } else {
                int64_t v13 = 8 * (int64_t)*(int32_t *)*(int64_t *)0x1ffb8 + v1; // 0x10e0
                int64_t v14 = *(int64_t *)v13; // 0x10f0
                g12 = (int32_t *)mem;
                v4 = v13;
                v6 = 0;
                v9 = v14;
                v10 = 0x2000;
                v5 = v13;
                v7 = 0;
                v8 = "stdin";
                v11 = 0x2000;
                v12 = *(int64_t *)*(int64_t *)0x1ffc8;
                if (v14 == 0) {
                    goto lab_0x1138;
                } else {
                    goto lab_0x1110;
                }
            }
        }
        case 86: {
            // 0x107c
            __printf_chk(1, dcgettext(NULL, "%s from %s\n", 5));
            exit(0);
            // UNREACHABLE
        }
        default: {
            goto lab_0x1304;
        }
    }
  lab_0x128c:;
    // 0x128c
    int64_t v15; // 0xfc0
    int64_t v16; // 0xfc0
    *(int32_t *)(v16 + v15) = 0;
    int64_t v17; // 0xfc0
    int64_t v18 = v17 - 1; // 0x1298
    int64_t v19; // 0xfc0
    int64_t v20 = v19; // 0x1298
    int64_t v21 = v16; // 0x1298
    goto lab_0x1204;
  lab_0x1204:;
    int64_t wstr = v21;
    uint64_t v22 = v18;
    if (v22 >= 2) {
        int64_t v23 = wstr; // 0x1214
        int64_t v24 = wstr + 4 * v22; // 0x1214
        v24 -= 4;
        int32_t * v25 = (int32_t *)v24; // 0x1218
        int32_t * v26 = (int32_t *)v23; // 0x121c
        *v26 = *v25;
        v23 += 4;
        *v25 = *v26;
        while (v23 != wstr + 4 * v22 / 2) {
            // 0x1218
            v24 -= 4;
            v25 = (int32_t *)v24;
            v26 = (int32_t *)v23;
            *v26 = *v25;
            v23 += 4;
            *v25 = *v26;
        }
    }
    // 0x1230
    int64_t * stream; // 0xfc0
    fputws((int32_t *)wstr, (struct _IO_FILE *)*stream);
    int64_t v27 = v20; // 0x123c
    goto lab_0x1140;
  lab_0x1304:
    // 0x1304
    if (v3 != 104) {
        int64_t v49 = *(int64_t *)*(int64_t *)0x1ffb0; // 0x1324
        __fprintf_chk((struct _IO_FILE *)v49, 1, dcgettext(NULL, "Try '%s --help' for more information.\n", 5));
        exit(1);
        // UNREACHABLE
    }
    goto lab_0x1364;
  lab_0x1364:;
    int64_t v50 = *(int64_t *)*(int64_t *)0x1ffc0; // 0x137c
    struct _IO_FILE * stream3 = (struct _IO_FILE *)v50; // 0x139c
    __fprintf_chk(stream3, 1, dcgettext(NULL, "Usage: %s [options] [file ...]\n", 5));
    fputc(10, stream3);
    fputs(dcgettext(NULL, "Reverse lines characterwise.\n", 5), stream3);
    fputs(dcgettext(NULL, "\nOptions:\n", 5), stream3);
    fputs(dcgettext(NULL, " -h, --help     display this help and exit\n", 5), stream3);
    fputs(dcgettext(NULL, " -V, --version  output version information and exit\n", 5), stream3);
    __fprintf_chk(stream3, 1, dcgettext(NULL, "\nFor more details see %s.\n", 5));
    exit((int32_t)(*(int64_t *)*(int64_t *)0x1ffb0 == v50));
    return &g13;
  lab_0x1138:;
    char * v51 = v8;
    struct _IO_FILE * stream2 = (struct _IO_FILE *)v12;
    stream = (int64_t *)*(int64_t *)0x1ffc0;
    v27 = v11;
    int64_t n; // 0xfc0
    while (true) {
      lab_0x1140:
        // 0x1140
        n = v27;
        if (fgetws(g12, (int32_t)n, stream2) == NULL) {
            // break (via goto) -> 0x1240
            goto lab_0x1240;
        }
        int32_t v28 = wcslen(g12); // 0x1164
        while (v28 == 0) {
            // 0x1148
            if (fgetws(g12, (int32_t)n, stream2) == NULL) {
                // break (via goto) -> 0x1240
                goto lab_0x1240;
            }
            // 0x115c
            v28 = wcslen(g12);
        }
        int64_t v29 = (int64_t)g12; // 0x115c
        int64_t v30 = v28; // 0x1164
        int64_t v31 = 4 * v30; // 0x1170
        int64_t v32 = v31 - 4; // 0x1174
        v17 = v30;
        v15 = v31;
        v19 = n;
        v16 = v29;
        if (*(int32_t *)(v32 + v29) == 10) {
            goto lab_0x128c;
        } else {
            int64_t v33 = v29; // 0x11f0
            int64_t v34 = v32; // 0x11f0
            int64_t v35 = v31; // 0x11f0
            int64_t n2 = n; // 0x11f0
            int64_t v36 = v30; // 0x11f0
            int64_t v37 = v30; // 0x11f0
            int64_t v38 = v31; // 0x11f0
            int64_t v39 = v32; // 0x11f0
            int64_t v40 = n; // 0x11f0
            if (feof(stream2) == 0) {
                int64_t v41 = 8 * n2; // 0x1188
                int64_t * mem2 = realloc((int64_t *)v33, (int32_t)v41); // 0x1194
                if (v41 != 0 && mem2 == NULL) {
                    // 0x12f0
                    err(1, "cannot allocate %zu bytes", v41);
                    v3 = &g13;
                    goto lab_0x1304;
                }
                int64_t v42 = 2 * n2; // 0x119c
                g12 = (int32_t *)mem2;
                int32_t * v43 = fgetws((int32_t *)(v35 + (int64_t)mem2), (int32_t)n2, stream2); // 0x11b8
                v37 = v36;
                v38 = v35;
                v39 = v34;
                v40 = v42;
                while (v43 != NULL) {
                    int64_t v44 = (int64_t)g12;
                    int64_t v45 = wcslen(g12); // 0x11c8
                    int64_t v46 = 4 * v45; // 0x11cc
                    int64_t v47 = v46 - 4; // 0x11d4
                    v17 = v45;
                    v15 = v46;
                    v19 = v42;
                    v16 = v44;
                    if (*(int32_t *)(v47 + v44) == 10) {
                        goto lab_0x128c;
                    }
                    // 0x11e8
                    v33 = v44;
                    v34 = v47;
                    v35 = v46;
                    n2 = v42;
                    v36 = v45;
                    v37 = v45;
                    v38 = v46;
                    v39 = v47;
                    v40 = v42;
                    if (feof(stream2) != 0) {
                        // break -> 0x11f4
                        break;
                    }
                    v41 = 8 * n2;
                    mem2 = realloc((int64_t *)v33, (int32_t)v41);
                    if (v41 != 0 && mem2 == NULL) {
                        // 0x12f0
                        err(1, "cannot allocate %zu bytes", v41);
                        v3 = &g13;
                        goto lab_0x1304;
                    }
                    // 0x11a8
                    v42 = 2 * n2;
                    g12 = (int32_t *)mem2;
                    v43 = fgetws((int32_t *)(v35 + (int64_t)mem2), (int32_t)n2, stream2);
                    v37 = v36;
                    v38 = v35;
                    v39 = v34;
                    v40 = v42;
                }
            }
            int64_t v48 = (int64_t)g12; // 0x11f4
            v18 = v37;
            v20 = v40;
            v21 = v48;
            v17 = v37;
            v15 = v38;
            v19 = v40;
            v16 = v48;
            if (*(int32_t *)(v39 + v48) == 10) {
                goto lab_0x128c;
            } else {
                goto lab_0x1204;
            }
        }
    }
  lab_0x1240:;
    int32_t v52 = v7; // 0x1248
    if (ferror(stream2) != 0) {
        // 0x12a8
        warn("%s", v51);
        v52 = 1;
    }
    // 0x124c
    fclose(stream2);
    int64_t v53 = v5; // 0x1250
    int32_t v54 = v52; // 0x1250
    int64_t v55 = n; // 0x1250
    goto lab_0x1254;
  lab_0x1110:;
    int64_t v57 = v10;
    int64_t v58 = v4;
    int64_t v59 = v58 + 8; // 0x111c
    struct _IO_FILE * v60 = fopen64((char *)v9, "r"); // 0x1120
    if (v60 == NULL) {
        // 0x12c4
        warn(dcgettext(NULL, "cannot open %s", 5));
        v53 = v59;
        v54 = 1;
        v55 = v57;
        goto lab_0x1254;
    } else {
        // 0x112c
        v5 = v59;
        v7 = v6;
        v8 = (char *)*(int64_t *)v58;
        v11 = v57;
        v12 = (int64_t)v60;
        goto lab_0x1138;
    }
  lab_0x1254:;
    int32_t result = v54;
    int64_t v56 = *(int64_t *)v53; // 0x1258
    v4 = v53;
    v6 = result;
    v9 = v56;
    v10 = v55;
    if (v56 == 0) {
        // 0x1260
        free((int64_t *)g12);
        return result;
    }
    goto lab_0x1110;
}

// Address range: 0x1460 - 0x1498
int64_t entry_point(int64_t a1) {
    void (*v1)() = *(void (**)())&g9;
    int64_t v2; // 0x1460
    int64_t v3; // 0x1460
    __libc_start_main(g10, (int32_t)a1, (char **)&v2, v1, g6, (void (*)())v3);
    abort();
    // UNREACHABLE
}

// Address range: 0x1498 - 0x14ac
int64_t function_1498(void) {
    // 0x1498
    if (g7 == 0) {
        // 0x14a8
        return 0;
    }
    // 0x14a4
    __gmon_start__();
    return &g13;
}

// Address range: 0x14b0 - 0x14dc
int64_t function_14b0(void) {
    // 0x14b0
    return &g11;
}

// Address range: 0x14e0 - 0x151c
int64_t function_14e0(void) {
    // 0x14e0
    return &g11;
}

// Address range: 0x1520 - 0x1568
int64_t function_1520(void) {
    unsigned char result = *(char *)&g11; // 0x1530
    if (result != 0) {
        // 0x155c
        return result;
    }
    // 0x1538
    if (*(int64_t *)0x1ffa8 != 0) {
        // 0x1544
        __cxa_finalize((int64_t *)0x1fc20);
    }
    // 0x1550
    function_14b0();
    *(char *)&g11 = 1;
    // 0x155c
    return 1;
}

// Address range: 0x1568 - 0x156c
int64_t function_1568(void) {
    // 0x1568
    return function_14e0();
}

// Address range: 0x1570 - 0x1580
int64_t function_1570(void) {
    // 0x1570
    _exit(0);
    // UNREACHABLE
}

// Address range: 0x1580 - 0x16b8
int64_t function_1580(void) {
    struct _IO_FILE * stream = (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x1ffc0; // 0x15a0
    int32_t v1 = __fpending(stream); // 0x15a0
    int32_t is_ferror = ferror(stream); // 0x15ac
    int32_t v2 = fclose(stream); // 0x15b8
    int32_t v3; // 0x15cc
    if (is_ferror == 0) {
        if (v2 == 0) {
            goto lab_0x161c;
        } else {
            // 0x15c8
            v3 = *__errno_location();
            if (v1 == 0 == v3 == 9) {
                goto lab_0x161c;
            } else {
                goto lab_0x15dc;
            }
        }
    } else {
        int32_t * v4 = __errno_location(); // 0x1608
        int32_t v5 = *v4; // 0x160c
        v3 = v5;
        if (v2 == 0) {
            if (v5 != 32) {
                // 0x1698
                *v4 = 0;
              lab_0x169c:
                // 0x169c
                warnx(dcgettext(NULL, "write error", 5));
                // 0x1664
                _exit(1);
                // UNREACHABLE
            }
            goto lab_0x161c;
        } else {
            goto lab_0x15dc;
        }
    }
  lab_0x161c:;
    struct _IO_FILE * stream2 = (struct _IO_FILE *)*(int64_t *)*(int64_t *)0x1ffb0; // 0x162c
    int32_t v6 = __fpending(stream2); // 0x162c
    int32_t is_ferror2 = ferror(stream2); // 0x1638
    int32_t v7 = fclose(stream2); // 0x1644
    if (is_ferror2 == 0) {
        // 0x1670
        if (v7 == 0) {
            // 0x1688
            return 0;
        }
        if (v6 != 0) {
            // 0x1664
            _exit(1);
            // UNREACHABLE
        }
        // 0x1678
        if (*__errno_location() == 9) {
            // 0x1688
            return 9;
        }
        // 0x1664
        _exit(1);
        // UNREACHABLE
    }
    if (v7 != 0) {
        // 0x1664
        _exit(1);
        // UNREACHABLE
    }
    int32_t * v8 = __errno_location(); // 0x1650
    if (*v8 != 32) {
        // 0x1660
        *v8 = 0;
    }
    // 0x1664
    _exit(1);
    // UNREACHABLE
  lab_0x15dc:
    // 0x15dc
    switch (v3) {
        case 32: {
            goto lab_0x161c;
        }
        case 0: {
            goto lab_0x169c;
        }
        default: {
            // 0x15e8
            warn(dcgettext(NULL, "write error", 5));
            // 0x1664
            _exit(1);
            // UNREACHABLE
        }
    }
}

// Address range: 0x16b8 - 0x1738
// From class:    version
// Type:          virtual member function
int64_t function_16b8(void) {
    // 0x16b8
    int64_t v1; // 0x16b8
    int64_t result = function_d88(v1); // 0x16f0
    if ((int64_t)&g3 - (int64_t)&g2 >> 3 == 0) {
        // 0x1724
        return result;
    }
    // 0x1700
    return v1 & 0xffffffff;
}

// Address range: 0x1738 - 0x173c
int64_t function_1738(void) {
    // 0x1738
    int64_t result; // 0x1738
    return result;
}

// Address range: 0x1740 - 0x175c
int64_t function_1740(void) {
    // 0x1740
    int64_t v1; // 0x1740
    return __cxa_atexit((void (*)(int64_t *))v1, NULL, g8);
}

// Address range: 0x175c - 0x176c
int64_t function_175c(int64_t a1) {
    // 0x175c
    int64_t result; // 0x175c
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// void __cxa_finalize(void * d);
// int * __errno_location(void);
// size_t __fpending(FILE * fp);
// int __fprintf_chk(FILE * restrict stream, int flag, const char * restrict format, ...);
// void __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int __printf_chk(int flag, const char * restrict format, ...);
// void _exit(int status);
// void abort(void);
// char * bindtextdomain(const char * domainname, const char * dirname);
// char * dcgettext(const char * domainname, const char * msgid, int category);
// void err(int status, const char * format, ...);
// void exit(int status);
// int fclose(FILE * stream);
// int feof(FILE * stream);
// int ferror(FILE * stream);
// wchar_t * fgetws(wchar_t * restrict ws, int n, __FILE * restrict stream);
// FILE * fopen64(const char * restrict filename, const char * restrict modes);
// int fputc(int c, FILE * stream);
// int fputs(const char * restrict s, FILE * restrict stream);
// int fputws(const wchar_t * restrict ws, __FILE * restrict stream);
// void free(void * ptr);
// int getopt_long(int argc, char * const * argv, const char * shortopts, const struct option * longopts, int * longind);
// void * malloc(size_t size);
// void * realloc(void * ptr, size_t size);
// char * setlocale(int category, const char * locale);
// __sighandler_t signal(int sig, __sighandler_t handler);
// char * textdomain(const char * domainname);
// void warn(const char * format, ...);
// void warnx(const char * format, ...);
// size_t wcslen(const wchar_t * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gc
// Detected functions: 46

