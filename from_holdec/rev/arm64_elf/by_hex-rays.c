/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2018 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void *init_proc();
// int fputs(const char *s, FILE *stream);
// void __noreturn exit(int status);
// int __fastcall __cxa_finalize(void *);
// int __fastcall __cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
// int fputc(int c, FILE *stream);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int fclose(FILE *stream);
// void *malloc(size_t size);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int __fastcall __libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// __int64 __fastcall __printf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// size_t wcslen(const wchar_t *s);
// void *realloc(void *ptr, size_t size);
// __int64 __gmon_start__(void); weak
// void __noreturn abort(void);
// int feof(FILE *stream);
// char *textdomain(const char *domainname);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void warn(const char *format, ...);
// void free(void *ptr);
// FILE *fopen64(const char *filename, const char *modes);
// int fputws(const wchar_t *ws, __FILE *stream);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// void __noreturn err(int status, const char *format, ...);
// char *setlocale(int category, const char *locale);
// int ferror(FILE *stream);
// wchar_t *fgetws(wchar_t *ws, int n, __FILE *stream);
__int64 __fastcall sub_FC0(int a1, char *const *a2);
void __fastcall __noreturn start(void (*rtld_fini)(void), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int argc, int ubp_av, char *a11);
void *sub_1498();
char *sub_14B0();
char *sub_14E0();
signed __int64 sub_1520();
__int64 __fastcall sub_1580(); // weak
__int64 __fastcall sub_16B8(unsigned int a1, __int64 a2, __int64 a3);
__int64 __fastcall nullsub_1(); // weak
__int64 __fastcall sub_1740(void (__fastcall *a1)(void *));
void term_proc();
// int __fastcall _cxa_finalize(void *);
// __int64 ITM_deregisterTMCloneTable(void); weak
// __int64 ITM_registerTMCloneTable(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN sub_1570; // weak
_UNKNOWN unk_1790; // weak
__int64 (__fastcall *off_1FC10[3])() = { &sub_1568, &sub_1520, &off_1FC20 }; // weak
void *off_1FC20 = &off_1FC20; // weak
char *off_1FC28 = "version"; // weak
char byte_20008; // weak
__int64 qword_20010; // weak
// extern _UNKNOWN stderr;
// extern int optind;
// extern _UNKNOWN stdout;
// extern struct _IO_FILE *stdin;
// extern char *program_invocation_short_name;
// extern _UNKNOWN _gmon_start__; weak


//----- (0000000000000D88) ----------------------------------------------------
void *init_proc()
{
  return sub_1498();
}

//----- (0000000000000FC0) ----------------------------------------------------
__int64 __fastcall sub_FC0(int a1, char *const *a2)
{
  char *const *v2; // x20
  int v3; // w21
  struct _IO_FILE *v4; // x22
  int v5; // w0
  char *v6; // x0
  signed __int64 v7; // x19
  void *v8; // x1
  signed __int64 v9; // x19
  const char *v10; // x0
  signed __int64 v11; // x20
  char *v12; // x27
  size_t v13; // x0
  size_t v14; // x19
  signed __int64 v15; // x21
  signed __int64 v16; // x24
  char *v17; // x0
  signed __int64 v18; // x25
  bool v19; // zf
  size_t v20; // x0
  size_t v21; // x4
  int *v22; // x0
  signed __int64 v23; // x19
  signed __int64 v24; // x4
  int v25; // w1
  char *v27; // x0
  const char **v28; // x1
  struct _IO_FILE *v29; // x19
  char *v30; // x0
  struct _IO_FILE *v31; // x19
  char *v32; // x0
  char *v33; // x0
  char *v34; // x0
  char *v35; // x0
  char *v36; // x0
  char *v37; // x0
  unsigned int v38; // [xsp+6Ch] [xbp+6Ch]
  const char *v39; // [xsp+70h] [xbp+70h]
  const char **v40; // [xsp+78h] [xbp+78h]

  v2 = a2;
  v3 = a1;
  v4 = stdin;
  setlocale(6, (const char *)&unk_1790);
  bindtextdomain("util-linux", "/usr/share/locale");
  textdomain("util-linux");
  sub_1740((void (__fastcall *)(void *))sub_1580);
  signal(2, (__sighandler_t)sub_1570);
  signal(15, (__sighandler_t)sub_1570);
  v5 = getopt_long(v3, v2, "Vh", (const struct option *)&off_1FC28, 0LL);
  if ( v5 != -1 )
  {
    if ( v5 == 86 )
    {
      v6 = dcgettext(0LL, "%s from %s\n", 5);
      __printf_chk(1LL, v6, program_invocation_short_name, "util-linux 2.30.2");
      exit(0);
    }
    if ( v5 != 104 )
    {
      v29 = stderr;
      v30 = dcgettext(0LL, "Try '%s --help' for more information.\n", 5);
      __fprintf_chk(v29, 1LL, v30, program_invocation_short_name);
      exit(1);
    }
    v31 = stdout;
    v32 = dcgettext(0LL, "Usage: %s [options] [file ...]\n", 5);
    __fprintf_chk(v31, 1LL, v32, program_invocation_short_name);
    fputc(10, v31);
    v33 = dcgettext(0LL, "Reverse lines characterwise.\n", 5);
    fputs(v33, v31);
    v34 = dcgettext(0LL, "\nOptions:\n", 5);
    fputs(v34, v31);
    v35 = dcgettext(0LL, " -h, --help     display this help and exit\n", 5);
    fputs(v35, v31);
    v36 = dcgettext(0LL, " -V, --version  output version information and exit\n", 5);
    fputs(v36, v31);
    v37 = dcgettext(0LL, "\nFor more details see %s.\n", 5);
    __fprintf_chk(v31, 1LL, v37, "rev(1)");
    exit(stderr == v31);
  }
  v7 = optind;
  v8 = malloc(0x8000uLL);
  v9 = v7;
  v40 = (const char **)&v2[v9];
  if ( !v8 )
    err(1, "cannot allocate %zu bytes", 0x8000LL);
  v10 = v2[v9];
  v38 = 0;
  qword_20010 = (__int64)v8;
  v39 = "stdin";
  v11 = 0x2000LL;
  if ( !v10 )
    goto LABEL_9;
  do
  {
    v4 = fopen64(v10, "r");
    if ( v4 )
    {
      v39 = *v40;
      ++v40;
LABEL_9:
      v12 = (char *)qword_20010;
      while ( fgetws((wchar_t *)v12, v11, v4) )
      {
        v12 = (char *)qword_20010;
        v13 = wcslen((const wchar_t *)qword_20010);
        v14 = v13;
        if ( v13 )
        {
          v15 = 4 * v13;
          v16 = 4 * v13 - 4;
          if ( *(_DWORD *)&v12[v16] == 10 )
            goto LABEL_46;
          while ( !feof(v4) )
          {
            v17 = (char *)realloc(v12, 8 * v11);
            v18 = 2 * v11;
            if ( v17 )
              v19 = 1;
            else
              v19 = 8 * v11 == 0;
            if ( !v19 )
              err(1, "cannot allocate %zu bytes", 8 * v11);
            qword_20010 = (__int64)v17;
            if ( !fgetws((wchar_t *)&v17[v15], v11, v4) )
            {
              v11 *= 2LL;
              break;
            }
            v12 = (char *)qword_20010;
            v20 = wcslen((const wchar_t *)qword_20010);
            v15 = 4 * v20;
            v14 = v20;
            v16 = 4 * v20 - 4;
            if ( *(_DWORD *)&v12[v16] == 10 )
              goto LABEL_34;
            v11 *= 2LL;
          }
          v12 = (char *)qword_20010;
          if ( *(_DWORD *)(qword_20010 + v16) == 10 )
          {
LABEL_46:
            v18 = v11;
LABEL_34:
            --v14;
            v11 = v18;
            *(_DWORD *)&v12[v15] = 0;
          }
          v21 = v14 >> 1;
          if ( v14 >> 1 )
          {
            v22 = (int *)v12;
            v23 = (signed __int64)&v12[4 * v14];
            v24 = (signed __int64)&v12[4 * v21];
            do
            {
              v25 = *v22;
              *v22 = *(_DWORD *)(v23 - 4);
              ++v22;
              *(_DWORD *)(v23 - 4) = v25;
              v23 -= 4LL;
            }
            while ( v22 != (int *)v24 );
          }
          fputws((const wchar_t *)v12, stdout);
          goto LABEL_9;
        }
      }
      if ( ferror(v4) )
      {
        v38 = 1;
        warn("%s", v39);
      }
      fclose(v4);
    }
    else
    {
      v27 = dcgettext(0LL, "cannot open %s", 5);
      v28 = v40;
      ++v40;
      v38 = 1;
      warn(v27, *v28);
    }
    v10 = *v40;
  }
  while ( *v40 );
  free((void *)qword_20010);
  return v38;
}
// E80: using guessed type __int64 __fastcall __printf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// F00: using guessed type __int64 __fastcall __fprintf_chk(_QWORD, _QWORD, _QWORD, _QWORD);
// 1570: using guessed type __int64 __fastcall sub_1570();
// 1580: using guessed type __int64 __fastcall sub_1580();
// 1FC28: using guessed type char *off_1FC28;
// 20010: using guessed type __int64 qword_20010;

//----- (0000000000001460) ----------------------------------------------------
void __fastcall __noreturn start(void (*rtld_fini)(void), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int argc, int ubp_av, char *a11)
{
  __libc_start_main(
    (int (__fastcall *)(int, char **, char **))sub_FC0,
    argc,
    (char **)&ubp_av,
    (void (*)(void))sub_16B8,
    (void (*)(void))nullsub_1,
    rtld_fini,
    &argc);
  abort();
}
// 1738: using guessed type __int64 __fastcall nullsub_1();

//----- (0000000000001498) ----------------------------------------------------
void *sub_1498()
{
  void *result; // x0

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (void *)__gmon_start__();
  return result;
}
// EB0: using guessed type __int64 __gmon_start__(void);

//----- (00000000000014B0) ----------------------------------------------------
char *sub_14B0()
{
  char *result; // x0

  result = &byte_20008;
  if ( &byte_20008 != &byte_20008 )
  {
    if ( &ITM_deregisterTMCloneTable )
      result = (char *)ITM_deregisterTMCloneTable();
  }
  return result;
}
// 20008: using guessed type char byte_20008;
// 20140: using guessed type __int64 ITM_deregisterTMCloneTable(void);

//----- (00000000000014E0) ----------------------------------------------------
char *sub_14E0()
{
  return &byte_20008;
}
// 20008: using guessed type char byte_20008;
// 20150: using guessed type __int64 ITM_registerTMCloneTable(void);

//----- (0000000000001520) ----------------------------------------------------
signed __int64 sub_1520()
{
  signed __int64 result; // x0

  result = (unsigned __int8)byte_20008;
  if ( !byte_20008 )
  {
    if ( &_cxa_finalize )
      __cxa_finalize(&off_1FC20);
    sub_14B0();
    result = 1LL;
    byte_20008 = 1;
  }
  return result;
}
// 1FC20: using guessed type void *off_1FC20;
// 20008: using guessed type char byte_20008;

//----- (00000000000016B8) ----------------------------------------------------
__int64 __fastcall sub_16B8(unsigned int a1, __int64 a2, __int64 a3)
{
  unsigned int v3; // w22
  __int64 v4; // x23
  __int64 v5; // x24
  __int64 i; // x19
  __int64 (__fastcall *v7)(); // x3
  __int64 result; // x0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  init_proc();
  for ( i = 0LL; i != 1; ++i )
  {
    v7 = off_1FC10[i];
    result = ((__int64 (__fastcall *)(_QWORD, __int64, __int64))v7)(v3, v4, v5);
  }
  return result;
}
// 1FC10: using guessed type __int64 (__fastcall *off_1FC10[3])();

//----- (0000000000001740) ----------------------------------------------------
__int64 __fastcall sub_1740(void (__fastcall *a1)(void *))
{
  void **v1; // x2

  v1 = 0LL;
  if ( &off_1FC20 )
    v1 = &off_1FC20;
  return __cxa_atexit(a1, 0LL, v1);
}
// 1FC20: using guessed type void *off_1FC20;

//----- (000000000000175C) ----------------------------------------------------
void term_proc()
{
  ;
}

// ALL OK, 10 function(s) have been successfully decompiled
