// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw20000160 = 0x00;
byte g_b2000022C = 0x00;
Eq_3978 g_t20000230 = 
	{
		0x00,
		0x00,
	};
byte g_b200007F4 = 0x00;
Eq_2 g_t200007F8 = 
	{
		0x00
	};
Eq_6268 g_t200007FC = 
	{
		null,
		0x00,
		0x00,
		0x00,
	};
word32 g_dw2000087C = 0x00;
word32 g_dw20000880 = 0x00;
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_a20000000[] = 
	{
	};
word32 g_dw200000BC = 0xAAAAAAAA;
word32 g_dw200000C0 = 0x01;
// subject_privileged_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_1322 g_t200000C4 = 
	{
		0x00,
		null,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
struct Eq_3201 * g_ptr200000C8 = null;
// subject_privileged_functions.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw0001 = 0x09200002;
word32 g_dw0005 = 0x01000080;
Eq_1053 g_t0008 = 
	{
		&g_t8001,
		0x8005,
		null,
		0x00,
		null,
		0x00,
		&g_t1715,
		0x00,
		&g_t1689,
		0x16E5,
		0x00,
		0x00,
		0x00,
		null,
		0x00,
		33033,
		&g_t4605B570,
		0x8C,
		0x4045F895,
		0x2C00B264,
		0x6A6BDD16,
		0xA3,
		177,
	};
word32 g_dw000D = 0x80;
// 00000058: void prvUnlockQueue(Register Eq_2 r0, Register ptr32 cpsr)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
void prvUnlockQueue(Eq_2 r0, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	int32 r4_133 = (int32) (int8) (word32) *((word32) r0 + 69);
	if (r4_133 > 0x00 && *((word32) r0 + 36) != 0x00)
	{
		do
		{
			if (xTaskRemoveFromEventList((word32) r0 + 36) != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_47 = (uint32) (byte) (r4_133 - 0x01);
				r4_133 = (int32) (int8) r3_47;
				if (r3_47 == 0x00)
					break;
			}
			else
			{
				uint32 r3_41 = (uint32) (byte) (r4_133 - 0x01);
				r4_133 = (int32) (int8) r3_41;
				if (r3_41 == 0x00)
					break;
			}
		} while (*((word32) r0 + 36) != 0x00);
	}
	((word32) r0 + 69)->u0 = ~0x00;
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	int32 r4_101 = (int32) (int8) (word32) *((word32) r0 + 0x0044);
	if (r4_101 > 0x00 && *((word32) r0 + 16) != 0x00)
	{
		do
		{
			if (xTaskRemoveFromEventList((word32) r0 + 16) != 0x00)
			{
				vTaskMissedYield();
				uint32 r3_100 = (uint32) (byte) (r4_101 - 0x01);
				r4_101 = (int32) (int8) r3_100;
				if (r3_100 == 0x00)
					break;
			}
			else
			{
				uint32 r3_94 = (uint32) (byte) (r4_101 - 0x01);
				r4_101 = (int32) (int8) r3_94;
				if (r3_94 == 0x00)
					break;
			}
		} while (*((word32) r0 + 16) != 0x00);
	}
	((word32) r0 + 0x0044)->u0 = ~0x00;
	vPortExitCritical(cpsr);
}

// 000000EC: FlagGroup bool prvCopyDataToQueue(Register Eq_2 r0, Register Eq_2 r1, Register Eq_2 r2, Register Eq_2 r7, Register Eq_122 lr, Register out Eq_122 r0Out, Register out Eq_2 r7Out, Register out Eq_122 lrOut)
// Called from:
//      xQueueGenericSend
//      xQueueGenericSendFromISR
//      xQueueCRSend
//      xQueueCRSendFromISR
bool prvCopyDataToQueue(Eq_2 r0, Eq_2 r1, Eq_2 r2, Eq_2 r7, Eq_122 lr, union Eq_122 & r0Out, union Eq_2 & r7Out, union Eq_122 & lrOut)
{
	bool Z_201;
	Eq_2 r5_114;
	Eq_2 r4_121 = r0;
	Eq_122 r0_106 = *((word32) r0 + 64);
	Eq_2 r5_15 = *((word32) r0 + 56);
	if (r0_106 == 0x00)
	{
		Eq_2 r6_102 = *r0;
		if (r6_102 != 0x00)
		{
			r5_114 = (word32) r5_15 + 1;
			Z_201 = SLICE(cond((word32) r5_15 + 1), bool, 2);
		}
		else
		{
			r0_106 = xTaskPriorityDisinherit(*((word32) r0 + 4), out lr);
			*((word32) r0 + 4) = r6_102;
			r5_114 = (word32) r5_15 + 1;
			Z_201 = SLICE(cond((word32) r5_15 + 1), bool, 2);
		}
	}
	else
	{
		if (r2 == 0x00)
		{
			Eq_122 lr_64;
			struct Eq_207 * r4_69;
			word32 r5_70;
			Eq_122 r6_71;
			Eq_2 r7_72;
			memcpy(*((word32) r0 + 8), r1, r0_106, r0, r5_15, r2, r7, lr, out r4_69, out r5_70, out r6_71, out r7_72, out lr_64);
			up32 r2_79 = r4_69->dw0004;
			up32 r3_80 = r4_69->dw0008 + r4_69->dw0040;
			r4_69->dw0008 = r3_80;
			if (r3_80 < r2_79)
			{
				r4_69->dw0038 = r5_70 + 0x01;
				r0Out = r6_71;
				r7Out = r7_72;
				lrOut = lr_64;
				return SLICE(cond(r5_70 + 0x01), bool, 2);
			}
			else
			{
				r4_69->dw0008 = r4_69->dw0000;
				r4_69->dw0038 = r5_70 + 0x01;
				r0Out = r6_71;
				r7Out = r7_72;
				lrOut = lr_64;
				return SLICE(cond(r5_70 + 0x01), bool, 2);
			}
		}
		word32 r6_29;
		memcpy(*((word32) r0 + 0x0C), r1, r0_106, r0, r5_15, r2, r7, lr, out r4_121, out r5_114, out r6_29, out r7, out lr);
		Eq_2 r3_36 = *((word32) r4_121 + 0x0C);
		Eq_2 r1_38 = *r4_121;
		*((word32) r4_121 + 0x0C) = r3_36;
		if (r3_36 < r1_38)
			*((word32) r4_121 + 0x0C) = *((word32) r4_121 + 4);
		Z_201 = SLICE(cond(r6_29 - 0x02), bool, 2);
		if (r6_29 != 0x02)
		{
			*((word32) r4_121 + 56) = (word32) r5_114 + 1;
			r0Out.u0 = 0x00;
			r7Out = r7;
			lrOut = lr;
			return SLICE(cond((word32) r5_114 + 1), bool, 2);
		}
		if (r5_114 == 0x00)
			r5_114.u0 = 0x01;
		r0_106.u0 = 0x00;
	}
	*((word32) r4_121 + 56) = r5_114;
	r0Out = r0_106;
	r7Out = r7;
	lrOut = lr;
	return Z_201;
}

Eq_1053 g_t00FF = 
	{
		&g_t16BD7063,
		2118517318,
		&g_tA68A0B9,
		~0x5C05A40F,
		&g_t626C2168,
		425763650,
		&g_t7063A560,
		586828784,
		&g_t5268E36C,
		0x2142,
		0xE3428B44,
		0x63D20260,
		0xE2441A68,
		&g_t72E0260,
		0x02,
		1885578528,
		&g_t303501BD,
		99,
		0x01B905BD,
		0xCE200025,
		23617767,
		0xF0,
		117,
	};
// 0000016C: Register Eq_2 prvCopyDataFromQueue(Register Eq_2 r0, Register Eq_2 r1, Register Eq_2 r4, Register Eq_2 r5, Register Eq_2 r6, Register Eq_2 r7, Register Eq_122 lr, Register out Eq_2 r5Out, Register out Eq_2 r6Out, Register out Eq_2 r7Out, Register out Eq_122 lrOut)
// Called from:
//      xQueuePeekFromISR
//      xQueueGenericReceive
//      xQueueReceiveFromISR
Eq_2 prvCopyDataFromQueue(Eq_2 r0, Eq_2 r1, Eq_2 r4, Eq_2 r5, Eq_2 r6, Eq_2 r7, Eq_122 lr, union Eq_2 & r5Out, union Eq_2 & r6Out, union Eq_2 & r7Out, union Eq_122 & lrOut)
{
	Eq_122 r2_5 = *((word32) r0 + 64);
	if (r2_5 == 0x00)
	{
		r5Out = r5;
		r6Out = r6;
		r7Out = r7;
		lrOut = lr;
		return r4;
	}
	else
	{
		Eq_2 r4_12 = *((word32) r0 + 4);
		word32 r1_13 = Mem10[r0 + 0x0C:word32] + r2_5;
		*((word32) r0 + 0x0C) = r1_13;
		if (r1_13 >= r4_12)
			r1_13 = *r0;
		*((word32) r0 + 0x0C) = r1_13;
		Eq_122 lr_35;
		Eq_2 r4_40;
		Eq_2 r5_41;
		Eq_2 r6_42;
		Eq_2 r7_43;
		memcpy(r1, r1_13, r2_5, r4, r5, r6, r7, lr, out r4_40, out r5_41, out r6_42, out r7_43, out lr_35);
		r5Out = r5_41;
		r6Out = r6_42;
		r7Out = r7_43;
		lrOut = lr_35;
		return r4_40;
	}
}

// 00000190: Register Eq_122 xQueueGenericSend(Register Eq_2 r0, Register Eq_2 r1, Register up32 r2, Register Eq_2 r3, Register Eq_122 lr, Register ptr32 cpsr)
// Called from:
//      xQueueGiveMutexRecursive
//      xQueueCreateMutex
//      MPU_xQueueGenericSend
Eq_122 xQueueGenericSend(Eq_2 r0, Eq_2 r1, up32 r2, Eq_2 r3, Eq_122 lr, ptr32 cpsr)
{
	word32 r5_124 = 0x00;
	word32 * r9_31 = g_ptr02A0;
	while (true)
	{
		vPortEnterCritical(cpsr);
		if (*((word32) r0 + 56) < *((word32) r0 + 60) || r3 == 0x02)
			break;
		if (r2 == 0x00)
		{
			vPortExitCritical(cpsr);
			return lr;
		}
		if (r5_124 == 0x00)
			vTaskSetTimeOutState(fp - 40);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		vPortEnterCritical(cpsr);
		if ((word32) *((word32) r0 + 0x0044) == 0xFF)
			((word32) r0 + 0x0044)->u0 = 0x00;
		if ((word32) *((word32) r0 + 69) == 0xFF)
			((word32) r0 + 69)->u0 = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 40, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			return lr;
		}
		vPortEnterCritical(cpsr);
		if (*((word32) r0 + 56) != *((word32) r0 + 60))
		{
			vPortExitCritical(cpsr);
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
		}
		else
		{
			vPortExitCritical(cpsr);
			vTaskPlaceOnEventList((word32) r0 + 16, r2);
			prvUnlockQueue(r0, cpsr);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*r9_31 = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
		}
		r5_124 = 0x01;
	}
	Eq_122 lr_57;
	word32 r0_58;
	word32 r7_402;
	prvCopyDataToQueue(r0, r1, r3, r3, lr, out r0_58, out r7_402, out lr_57);
	if (*((word32) r0 + 36) == 0x00)
	{
		if (r0_58 == 0x00)
			goto l00000266;
	}
	else if (xTaskRemoveFromEventList((word32) r0 + 36) == 0x00)
		goto l00000266;
	*g_ptr02A0 = 0x10000000;
	__dsb_sy();
	__isb_sy();
l00000266:
	vPortExitCritical(cpsr);
	return lr_57;
}

word32 * g_ptr02A0 = &g_dwE000ED04;
// 000002A4: void xQueuePeekFromISR(Register Eq_2 r0, Register Eq_2 r1, Register Eq_2 r7, Register Eq_122 lr, Register ptr32 cpsr)
// Called from:
//      MPU_xQueuePeekFromISR
void xQueuePeekFromISR(Eq_2 r0, Eq_2 r1, Eq_2 r7, Eq_122 lr, ptr32 cpsr)
{
	Eq_2 r5_13 = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (*((word32) r0 + 56) != 0x00)
	{
		Eq_2 r5_27;
		word32 r6_28;
		word32 r7_56;
		word32 lr_57;
		prvCopyDataFromQueue(r0, r1, r0, r5_13, *((word32) r0 + 0x0C), r7, lr, out r5_27, out r6_28, out r7_56, out lr_57)->dw000C = r6_28;
		__msr(cpsr, r5_27);
	}
	else
		__msr(cpsr, r5_13);
}

// 000002D8: Register Eq_2 xQueueGenericReceive(Register Eq_2 r0, Register Eq_2 r1, Register up32 r2, Register word32 r3, Register Eq_122 lr, Register ptr32 cpsr, Register out Eq_122 lrOut)
// Called from:
//      xQueueTakeMutexRecursive
//      MPU_xQueueGenericReceive
Eq_2 xQueueGenericReceive(Eq_2 r0, Eq_2 r1, up32 r2, word32 r3, Eq_122 lr, ptr32 cpsr, union Eq_122 & lrOut)
{
	word32 r5_133 = 0x00;
	word32 * r8_31 = g_ptr0424;
	while (true)
	{
		vPortEnterCritical(cpsr);
		Eq_2 r6_41 = *((word32) r0 + 56);
		if (r6_41 != 0x00)
			break;
		if (r2 == 0x00)
		{
l000003A4:
			vPortExitCritical(cpsr);
			lrOut = lr;
			return 0x00;
		}
		if (r5_133 == 0x00)
			vTaskSetTimeOutState(fp - 40);
		vPortExitCritical(cpsr);
		vTaskSuspendAll();
		vPortEnterCritical(cpsr);
		if ((word32) *((word32) r0 + 0x0044) == 0xFF)
			((word32) r0 + 0x0044)->u0 = 0x00;
		if ((word32) *((word32) r0 + 69) == 0xFF)
			((word32) r0 + 69)->u0 = 0x00;
		vPortExitCritical(cpsr);
		if (xTaskCheckForTimeOut(fp - 40, fp - 44, cpsr) != 0x00)
		{
			prvUnlockQueue(r0, cpsr);
			xTaskResumeAll(cpsr);
			vPortEnterCritical(cpsr);
			if (*((word32) r0 + 56) == 0x00)
				goto l000003A4;
			vPortExitCritical(cpsr);
		}
		else
		{
			vPortEnterCritical(cpsr);
			if (*((word32) r0 + 56) != 0x00)
			{
				vPortExitCritical(cpsr);
				prvUnlockQueue(r0, cpsr);
				xTaskResumeAll(cpsr);
			}
			else
			{
				vPortExitCritical(cpsr);
				if (*r0 == 0x00)
				{
					vPortEnterCritical(cpsr);
					vTaskPriorityInherit(*((word32) r0 + 4));
					vPortExitCritical(cpsr);
				}
				vTaskPlaceOnEventList((word32) r0 + 36, r2);
				prvUnlockQueue(r0, cpsr);
				if (xTaskResumeAll(cpsr) == 0x00)
				{
					*r8_31 = 0x10000000;
					__dsb_sy();
					__isb_sy();
				}
			}
		}
		r5_133 = 0x01;
	}
	Eq_122 lr_51;
	word32 r5_56;
	word32 r6_57;
	word32 r7_483;
	struct Eq_530 * r4_55 = prvCopyDataFromQueue(r0, r1, r0, *((word32) r0 + 0x0C), r6_41, 0x00, lr, out r5_56, out r6_57, out r7_483, out lr_51);
	if (r3 == 0x00)
	{
		word32 r3_76 = r4_55->dw0000;
		r4_55->dw0038 = r6_57 - 0x01;
		if (r3_76 == 0x00)
			r4_55->dw0004 = pvTaskIncrementMutexHeldCount();
		if (r4_55->dw0010 == 0x00 || xTaskRemoveFromEventList(&r4_55->dw0010) == 0x00)
		{
l000003CC:
			vPortExitCritical(cpsr);
			lrOut = lr_51;
			return 0x01;
		}
	}
	else
	{
		word32 r3_62 = r4_55->dw0024;
		r4_55->dw000C = r5_56;
		if (r3_62 == 0x00 || xTaskRemoveFromEventList(&r4_55->dw0024) == 0x00)
			goto l000003CC;
	}
	*g_ptr0424 = 0x10000000;
	__dsb_sy();
	__isb_sy();
	goto l000003CC;
}

word32 * g_ptr0424 = &g_dwE000ED04;
// 00000428: void uxQueueMessagesWaiting(Register ptr32 cpsr)
// Called from:
//      MPU_uxQueueMessagesWaiting
void uxQueueMessagesWaiting(ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	vPortExitCritical(cpsr);
}

// 0000043C: void uxQueueSpacesAvailable(Register ptr32 cpsr)
// Called from:
//      MPU_uxQueueSpacesAvailable
void uxQueueSpacesAvailable(ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	vPortExitCritical(cpsr);
}

// 00000454: void vQueueDelete()
// Called from:
//      MPU_vQueueDelete
void vQueueDelete()
{
	vPortFree();
}

// 00000458: void xQueueGenericSendFromISR(Register Eq_2 r0, Register Eq_2 r1, Register Eq_2 r2, Register Eq_2 r3, Register Eq_122 lr, Register ptr32 cpsr)
// Called from:
//      vUART_ISR
void xQueueGenericSendFromISR(Eq_2 r0, Eq_2 r1, Eq_2 r2, Eq_2 r3, Eq_122 lr, ptr32 cpsr)
{
	Eq_2 r6_17 = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (*((word32) r0 + 56) < *((word32) r0 + 60) || r3 == 0x02)
	{
		int32 r4_32 = (int32) (int8) (word32) *((word32) r0 + 69);
		word32 r0_162;
		word32 * r7_44;
		word32 lr_163;
		if (!prvCopyDataToQueue(r0, r1, r3, r2, lr, out r0_162, out r7_44, out lr_163))
			((word32) r0 + 69)->u0 = (byte) (int32) (int8) (r4_32 + 0x01);
		else if (*((word32) r0 + 36) != 0x00 && (xTaskRemoveFromEventList((word32) r0 + 36) != 0x00 && r7_44 != null))
		{
			*r7_44 = 0x01;
			goto l0000047C;
		}
		__msr(cpsr, r6_17);
	}
	else
	{
l0000047C:
		__msr(cpsr, r6_17);
	}
}

// 000004C4: void xQueueGiveFromISR(Register (ptr32 Eq_824) r0, Register (ptr32 word32) r1, Register ptr32 cpsr)
void xQueueGiveFromISR(struct Eq_824 * r0, word32 * r1, ptr32 cpsr)
{
	Eq_2 r4_13 = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	up32 r2_16 = r0->dw0038;
	if (r2_16 >= r0->dw003C)
	{
		__msr(cpsr, r4_13);
		return;
	}
	int32 r3_28 = (int32) (int8) (word32) r0->b0045;
	r0->dw0038 = r2_16 + 0x01;
	if (r2_16 != 0x01)
		r0->b0045 = (byte) (int32) (int8) (r3_28 + 0x01);
	else if (r0->dw0024 != 0x00 && (xTaskRemoveFromEventList(&r0->dw0024) != 0x00 && r1 != null))
	{
		*r1 = 0x01;
l000004FA:
		__msr(cpsr, r4_13);
		return;
	}
	goto l000004FA;
}

// 00000524: void xQueueReceiveFromISR(Register Eq_2 r0, Register Eq_2 r1, Register (ptr32 word32) r2, Register Eq_122 lr, Register ptr32 cpsr)
void xQueueReceiveFromISR(Eq_2 r0, Eq_2 r1, word32 * r2, Eq_122 lr, ptr32 cpsr)
{
	Eq_2 r6_17 = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_2 r4_20 = *((word32) r0 + 56);
	if (r4_20 != 0x00)
	{
		word32 r5_33;
		struct Eq_910 * r7_35;
		word32 lr_150;
		struct Eq_530 * r4_32 = prvCopyDataFromQueue(r0, r1, r4_20, (int32) (int8) (word32) *((word32) r0 + 0x0044), r6_17, r0, lr, out r5_33, out r6_17, out r7_35, out lr_150);
		r7_35->dw0038 = r4_32 - &g_dw0001;
		if (r4_32 != &g_dw0001)
			r7_35->b0044 = (byte) (int32) (int8) (r5_33 + 0x01);
		else if (r7_35->dw0010 != 0x00 && (xTaskRemoveFromEventList(&r7_35->dw0010) != 0x00 && r2 != null))
		{
			*r2 = 0x01;
			goto l00000542;
		}
		__msr(cpsr, r6_17);
	}
	else
	{
l00000542:
		__msr(cpsr, r6_17);
	}
}

// 00000594: void xQueueIsQueueEmptyFromISR(Register (ptr32 Eq_960) r0)
void xQueueIsQueueEmptyFromISR(struct Eq_960 * r0)
{
	__clz(r0->dw0038);
}

// 000005A0: void xQueueIsQueueFullFromISR(Register (ptr32 Eq_968) r0)
void xQueueIsQueueFullFromISR(struct Eq_968 * r0)
{
	__clz(r0->dw003C - r0->dw0038);
}

// 000005B0: void uxQueueMessagesWaitingFromISR()
void uxQueueMessagesWaitingFromISR()
{
}

// 000005B4: void xQueueGetMutexHolder(Register (ptr32 word32) r0, Register ptr32 cpsr)
// Called from:
//      MPU_xQueueGetMutexHolder
void xQueueGetMutexHolder(word32 * r0, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	if (*r0 != 0x00)
		vPortExitCritical(cpsr);
	else
		vPortExitCritical(cpsr);
}

// 000005D4: void xQueueTakeMutexRecursive(Register Eq_2 r0, Register up32 r1, Register Eq_122 lr, Register ptr32 cpsr)
// Called from:
//      MPU_xQueueTakeMutexRecursive
void xQueueTakeMutexRecursive(Eq_2 r0, up32 r1, Eq_122 lr, ptr32 cpsr)
{
	if (*((word32) r0 + 4) == xTaskGetCurrentTaskHandle())
		*((word32) r0 + 0x0C) = (word32) *((word32) r0 + 0x0C) + 1;
	else
	{
		word32 lr_92;
		if (xQueueGenericReceive(r0, 0x00, r1, 0x00, lr, cpsr, out lr_92) != 0x00)
			*((word32) r0 + 0x0C) = (word32) *((word32) r0 + 0x0C) + 1;
	}
}

// 00000604: void xQueueGiveMutexRecursive(Register Eq_2 r0, Register Eq_122 lr, Register ptr32 cpsr)
// Called from:
//      MPU_xQueueGiveMutexRecursive
void xQueueGiveMutexRecursive(Eq_2 r0, Eq_122 lr, ptr32 cpsr)
{
	if (*((word32) r0 + 4) != xTaskGetCurrentTaskHandle())
		return;
	Eq_2 r3_19 = *((word32) r0 + 0x0C);
	*((word32) r0 + 0x0C) = r3_19 - 0x01;
	if (r3_19 != 0x01)
		return;
	xQueueGenericSend(r0, r3_19 - 0x01, r3_19 - 0x01, r3_19 - 0x01, lr, cpsr);
}

// 00000630: void xQueueGenericReset(Register (ptr32 Eq_1053) r0, Register word32 r1, Register ptr32 cpsr)
// Called from:
//      xQueueGenericCreate
//      MPU_xQueueGenericReset
void xQueueGenericReset(struct Eq_1053 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	ui32 r3_25 = r0->dw0040;
	ui32 r2_28 = r0->dw003C * r3_25;
	struct Eq_1053 * r0_27 = r0->ptr0000;
	r0->dw0038 = 0x00;
	r0->dw0004 = r0_27 + r2_28 / 0x0066;
	r0->ptr0044 = (struct Eq_1053 *) &g_tFFFFFFFF;
	r0->dw000C = r0_27 + (r2_28 - r3_25) / 0x0066;
	r0->ptr0008 = r0_27;
	r0->b0045 = ~0x00;
	if (r1 != 0x00)
	{
		vListInitialise(&r0->ptr0010);
		vListInitialise(&r0->ptr0024);
		vPortExitCritical(cpsr);
	}
	else if (r0->ptr0010 != null && xTaskRemoveFromEventList(&r0->ptr0010) != 0x00)
	{
		*g_ptr06A8 = 0x10000000;
		__dsb_sy();
		__isb_sy();
		vPortExitCritical(cpsr);
	}
	else
		vPortExitCritical(cpsr);
}

word32 * g_ptr06A8 = &g_dwE000ED04;
// 000006AC: void xQueueGenericCreate(Register ui32 r0, Register ui32 r1, Register ptr32 cpsr)
// Called from:
//      xQueueCreateMutex
//      MPU_xQueueGenericCreate
void xQueueGenericCreate(ui32 r0, ui32 r1, ptr32 cpsr)
{
	struct Eq_1053 * r0_20 = pvPortMalloc(r0 * r1 + 0x48, cpsr);
	if (r0_20 != null)
	{
		if (r1 != 0x00)
			r0_20->ptr0000 = &r0_20->b0045 + 3;
		else
			r0_20->ptr0000 = r0_20;
		r0_20->dw003C = r0;
		r0_20->dw0040 = r1;
		xQueueGenericReset(r0_20, 0x01, cpsr);
	}
}

// 000006DC: void xQueueCreateMutex(Register Eq_122 lr, Register ptr32 cpsr)
// Called from:
//      MPU_xQueueCreateMutex
void xQueueCreateMutex(Eq_122 lr, ptr32 cpsr)
{
	xQueueGenericCreate(0x01, 0x00, cpsr);
	g_dw0005 = 0x00;
	g_dw0001 = 0x00;
	g_dw000D = 0x00;
	xQueueGenericSend(0x01, 0x00, 0x00, 0x00, lr, cpsr);
}

// 00000700: void prvInitialiseNewTask(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_1053)) dwArg04, Stack (ptr32 Eq_1053) dwArg08, Stack (ptr32 Eq_1197) dwArg0C)
// Called from:
//      xTaskCreate
//      xTaskCreateRestricted
void prvInitialiseNewTask(ui32 r0, word32 r1, ui32 r2, word32 r3, int32 dwArg00, struct Eq_1053 ** dwArg04, struct Eq_1053 * dwArg08, struct Eq_1197 * dwArg0C)
{
	byte * r3_36 = r1 - 0x01 + 1;
	struct Eq_1203 * r5_38 = dwArg08->ptr0050 + (r2 + 0x3FFFFFFF << 0x02) / 0x0066 & ~0x07;
	byte * r0_41 = (char *) &dwArg08->ptr0050 + 4;
	uint32 r2_42 = dwArg00 & ~0x80000000;
	do
	{
		*r0_41 = (byte) (word32) *r3_36;
		++r3_36;
		++r0_41;
	} while ((word32) *r3_36 != 0x00 && r3_36 != r1 + 0x02);
	if (r2_42 >= 0x01)
		r2_42 = 0x01;
	dwArg08->dw004C = r2_42;
	dwArg08->dw0058 = r2_42;
	dwArg08->b0056 = 0x00;
	dwArg08->dw005C = 0x00;
	vListInitialiseItem(&dwArg08->ptr0024);
	vListInitialiseItem(&dwArg08->dw0038);
	dwArg08->dw0038 = 0x02 - r2_42;
	struct Eq_1053 * r2_75 = dwArg08->ptr0050;
	dwArg08->ptr0030 = dwArg08;
	dwArg08->ptr0044 = dwArg08;
	vPortStoreTaskMPUSettings(&dwArg08->dw0004, dwArg0C, r2_75, r2);
	dwArg08->dw0060 = 0x00;
	dwArg08->b0064 = 0x00;
	dwArg08->ptr0000 = pxPortInitialiseStack(r5_38, r0, r3, dwArg00 >> 0x1F);
	if (dwArg04 != null)
		*dwArg04 = (struct Eq_1053 **) dwArg08;
}

// 00000798: void prvAddNewTaskToReadyList(Register (ptr32 Eq_1053) r0, Register ptr32 cpsr)
// Called from:
//      xTaskCreate
//      xTaskCreateRestricted
void prvAddNewTaskToReadyList(struct Eq_1053 * r0, ptr32 cpsr)
{
	uint32 r0_60;
	struct Eq_1322 * r4_16 = g_ptr0854;
	vPortEnterCritical(cpsr);
	++r4_16->dw0000;
	if (r4_16->ptr0004 != null)
	{
		if (r4_16->dw0074 != 0x00)
		{
l000007B4:
			r0_60 = r0->dw004C;
			goto l000007BA;
		}
		r0_60 = r0->dw004C;
		if (r4_16->ptr0004->dw004C <= r0_60)
			r4_16->ptr0004 = r0;
	}
	else
	{
		r4_16->ptr0004 = r0;
		if (r4_16->dw0000 != 0x01)
			goto l000007B4;
		vListInitialise((char *) &r4_16->ptr0004 + 4);
		vListInitialise((char *) &r4_16->ptr0004 + 24);
		vListInitialise((char *) &r4_16->ptr0004 + 44);
		vListInitialise((char *) &r4_16->ptr0004 + 64);
		vListInitialise((char *) &r4_16->ptr0004 + 84);
		r4_16->ptr006C = (char *) &r4_16->ptr0004 + 44;
		r0_60 = r0->dw004C;
		r4_16->ptr0070 = (char *) &r4_16->ptr0004 + 64;
	}
l000007BA:
	word32 r2_81 = r4_16->dw0078;
	r4_16->dw007C = 0x01 << r0_60 | r4_16->dw007C;
	r4_16->dw0078 = r2_81 + 0x01;
	vListInsertEnd((char *) &r4_16->ptr0004 + 4 + r0_60 * 0x14, &r0->ptr0024);
	vPortExitCritical(cpsr);
	if (r4_16->dw0074 != 0x00 && (r4_16->ptr0004)->dw004C < r0->dw004C)
	{
		*g_ptr0858 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
}

struct Eq_1322 * g_ptr0854 = &g_t200000C4;
word32 * g_ptr0858 = &g_dwE000ED04;
// 0000085C: void prvAddCurrentTaskToDelayedList.isra.0(Register up32 r0)
// Called from:
//      xTaskNotifyWait
//      ulTaskNotifyTake
//      vTaskDelay
//      vTaskDelayUntil
//      vTaskPlaceOnEventList
//      vTaskPlaceOnUnorderedEventList
void prvAddCurrentTaskToDelayedList.isra.0(up32 r0)
{
	struct Eq_1458 * r4_12 = g_ptr08B0;
	up32 r6_15 = r4_12->dw0080;
	if (uxListRemove(&r4_12->ptr0004->dw0024) == 0x00)
		r4_12->dw007C &= ~(0x01 << (r4_12->ptr0004)->dw004C);
	up32 r5_37 = r0 + r6_15;
	r4_12->ptr0004->dw0024 = r5_37;
	if (r6_15 > r5_37)
	{
		struct Eq_466 * r0_44 = r4_12->ptr0070;
		struct Eq_1470 * r1_45 = r4_12->ptr0004;
		vListInsert(r0_44, &r1_45->dw0024);
	}
	else
	{
		vListInsert(r4_12->ptr006C, &r4_12->ptr0004->dw0024);
		if (r5_37 < r4_12->dw0084)
			r4_12->dw0084 = r5_37;
	}
}

struct Eq_1458 * g_ptr08B0 = &g_t200000C4;
// 000008B4: Register ui32 xTaskCreate(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Register ptr32 cpsr, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_1053)) dwArg04)
// Called from:
//      vTaskStartScheduler
//      MPU_xTaskCreate
ui32 xTaskCreate(ui32 r0, word32 r1, ui32 r2, word32 r3, ptr32 cpsr, int32 dwArg00, struct Eq_1053 ** dwArg04)
{
	struct Eq_1053 * r0_32 = pvPortMalloc(r2 << 2, cpsr);
	if (r0_32 == null)
		return ~0x00;
	ui32 r0_130;
	struct Eq_1053 * r0_52 = pvPortMalloc(0x68, cpsr);
	if (r0_52 != null)
	{
		r0_52->ptr0050 = r0_32;
		r0_52->b0065 = 0x00;
		prvInitialiseNewTask(r0, r1, r2, r3, dwArg00, dwArg04, r0_52, null);
		prvAddNewTaskToReadyList(r0_52, cpsr);
		r0_130 = 0x01;
	}
	else
	{
		vPortFree();
		r0_130 = ~0x00;
	}
	return r0_130;
}

// 0000091C: void xTaskCreateRestricted(Register (ptr32 Eq_1573) r0, Register (ptr32 (ptr32 Eq_1053)) r1, Register ptr32 cpsr)
// Called from:
//      MPU_xTaskCreateRestricted
void xTaskCreateRestricted(struct Eq_1573 * r0, struct Eq_1053 ** r1, ptr32 cpsr)
{
	if (r0->ptr0014 == null)
		return;
	struct Eq_1053 * r0_24 = pvPortMalloc(0x68, cpsr);
	if (r0_24 != null)
	{
		struct Eq_1053 * r1_35 = r0->ptr0014;
		r0_24->b0065 = 0x01;
		word32 r3_37 = r0->dw000C;
		ui32 r2_38 = (word32) r0->w0008;
		int32 lr_39 = r0->dw0010;
		r0_24->ptr0050 = r1_35;
		prvInitialiseNewTask(r0->dw0000, r0->dw0004, r2_38, r3_37, lr_39, r1, r0_24, (char *) &r0->ptr0014 + 4);
		prvAddNewTaskToReadyList(r0_24, cpsr);
	}
}

// 00000970: void vTaskAllocateMPURegions(Register word32 r0, Register (ptr32 Eq_1197) r1)
// Called from:
//      MPU_vTaskAllocateMPURegions
void vTaskAllocateMPURegions(word32 r0, struct Eq_1197 * r1)
{
	if (r0 == 0x00)
	{
		word32 r0_6 = g_ptr098C->dw0004;
		vPortStoreTaskMPUSettings(r0_6 + 0x04, r1, null, 0x00);
	}
	else
		vPortStoreTaskMPUSettings(r0 + 0x04, r1, null, 0x00);
}

struct Eq_1629 * g_ptr098C = &g_t200000C4;
// 00000990: void vTaskStartScheduler(Register ptr32 cpsr)
// Called from:
//      ResetISR
void vTaskStartScheduler(ptr32 cpsr)
{
	struct Eq_1646 * r4_9 = g_ptr09E0;
	word32 r0_19 = xTaskCreate(g_dw09E8, g_dw09E4, 0x3B, 0x00, cpsr, 0x80000000, &r4_9->dw0084 + 1);
	if (r0_19 != 0x01)
		return;
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	r4_9->dw0084 = ~0x00;
	r4_9->dw0074 = r0_19;
	r4_9->dw0080 = 0x00;
	xPortStartScheduler(cpsr);
}

struct Eq_1646 * g_ptr09E0 = &g_t200000C4;
word32 g_dw09E4 = 0xA27C;
ui32 g_dw09E8 = 34093;
// 000009EC: void vTaskEndScheduler(Register ptr32 cpsr)
void vTaskEndScheduler(ptr32 cpsr)
{
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	g_ptr0A08->dw0074 = 0x00;
	vPortEndScheduler();
}

struct Eq_1696 * g_ptr0A08 = &g_t200000C4;
// 00000A0C: FlagGroup bool vTaskSuspendAll()
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
//      pvPortMalloc
//      xEventGroupWaitBits
//      xEventGroupSetBits
//      xEventGroupSync
//      vEventGroupDelete
//      MPU_vTaskSuspendAll
bool vTaskSuspendAll()
{
	struct Eq_1704 * r2_4 = g_ptr0A1C;
	word32 r3_5 = r2_4->dw008C;
	r2_4->dw008C = r3_5 + 0x01;
	return SLICE(cond(r3_5 + 0x01), bool, 1);
}

struct Eq_1704 * g_ptr0A1C = &g_t200000C4;
// 00000A20: void xTaskGetTickCount()
// Called from:
//      MPU_xTaskGetTickCount
void xTaskGetTickCount()
{
}

// 00000A2C: void xTaskGetTickCountFromISR()
void xTaskGetTickCountFromISR()
{
}

// 00000A38: void uxTaskGetNumberOfTasks()
// Called from:
//      MPU_uxTaskGetNumberOfTasks
void uxTaskGetNumberOfTasks()
{
}

// 00000A44: void pcTaskGetName(Register word32 r0)
// Called from:
//      MPU_pcTaskGetName
void pcTaskGetName(word32 r0)
{
	if (r0 == 0x00)
		;
}

// 00000A58: void xTaskGenericNotify(Register (ptr32 Eq_1722) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr)
// Called from:
//      MPU_xTaskGenericNotify
void xTaskGenericNotify(struct Eq_1722 * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_35 = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_39 = (uint32) (byte) r4_35;
	if (r2 <= 0x04)
	{
		switch (r2)
		{
		case 0x01:
			r0->dw0060 = r1 | r0->dw0060;
			break;
		case 0x02:
			++r0->dw0060;
			if (r4_39 == 0x01)
				goto l00000AA6;
			goto l00000A90;
		case 0x03:
l00000A8A:
			r0->dw0060 = r1;
			break;
		case 0x04:
			if (r4_39 != 0x02)
				goto l00000A8A;
			goto l00000A92;
		}
	}
	if (r4_39 == 0x01)
	{
l00000AA6:
		struct Eq_1777 * r5_67 = g_ptr0B04;
		uxListRemove((char *) r0 + 36);
		uint32 r0_77 = r0->dw004C;
		r5_67->dw007C = r4_39 << r0_77 | r5_67->dw007C;
		vListInsertEnd((char *) &r5_67->ptr0004 + 4 + r0_77 * 0x14, (char *) r0 + 36);
		if (r0->dw004C > (r5_67->ptr0004)->dw004C)
		{
			*g_ptr0B08 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return;
		}
	}
l00000A90:
l00000A92:
	vPortExitCritical(cpsr);
}

struct Eq_1777 * g_ptr0B04 = &g_t200000C4;
word32 * g_ptr0B08 = &g_dwE000ED04;
// 00000B0C: void xTaskGenericNotifyFromISR(Register (ptr32 Eq_1828) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr, Stack (ptr32 word32) dwArg00)
void xTaskGenericNotifyFromISR(struct Eq_1828 * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr, word32 * dwArg00)
{
	Eq_2 r5_17 = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (r3 != null)
		*r3 = r0->dw0060;
	word32 r4_26 = (word32) r0->b0064;
	r0->b0064 = 0x02;
	uint32 r4_31 = (uint32) (byte) r4_26;
	if (r2 <= 0x04)
	{
		switch (r2)
		{
		case 0x01:
			r0->dw0060 = r1 | r0->dw0060;
			break;
		case 0x02:
			++r0->dw0060;
			if (r4_31 == 0x01)
				goto l00000B64;
			goto l00000B4E;
		case 0x03:
l00000B48:
			r0->dw0060 = r1;
			break;
		case 0x04:
			if (r4_31 != 0x02)
				goto l00000B48;
			goto l00000B50;
		}
	}
	if (r4_31 == 0x01)
	{
l00000B64:
		struct Eq_1892 * r6_57 = g_ptr0BD0;
		if (r6_57->dw008C != 0x00)
			vListInsertEnd((char *) &r6_57->ptr0004 + 84, (char *) r0 + 56);
		else
		{
			uxListRemove((char *) r0 + 36);
			uint32 r0_72 = r0->dw004C;
			r6_57->dw007C = r4_31 << r0_72 | r6_57->dw007C;
			vListInsertEnd((char *) &r6_57->ptr0004 + 4 + r0_72 * 0x14, (char *) r0 + 36);
		}
		if (r0->dw004C > (r6_57->ptr0004)->dw004C)
		{
			if (dwArg00 != null)
			{
				*dwArg00 = 0x01;
				__msr(cpsr, r5_17);
				return;
			}
			r6_57->dw0090 = 0x01;
l00000B50:
			__msr(cpsr, r5_17);
			return;
		}
	}
l00000B4E:
	goto l00000B50;
}

struct Eq_1892 * g_ptr0BD0 = &g_t200000C4;
// 00000BD4: void xTaskNotifyWait(Register word32 r0, Register word32 r1, Register (ptr32 ui32) r2, Register up32 r3, Register ptr32 cpsr)
// Called from:
//      MPU_xTaskNotifyWait
void xTaskNotifyWait(word32 r0, word32 r1, ui32 * r2, up32 r3, ptr32 cpsr)
{
	struct Eq_1959 * r4_16 = g_ptr0C58;
	vPortEnterCritical(cpsr);
	if ((word32) r4_16->ptr0004->b0064 != 0x02)
	{
		struct Eq_1966 * r1_37 = r4_16->ptr0004;
		r1_37->dw0060 &= ~r0;
		r4_16->ptr0004->b0064 = 0x01;
		if (r3 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r3);
			*g_ptr0C5C = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	if (r2 != null)
		*r2 = r4_16->ptr0004->dw0060;
	if ((word32) r4_16->ptr0004->b0064 != 0x01)
	{
		struct Eq_1966 * r3_82 = r4_16->ptr0004;
		r3_82->dw0060 &= ~r1;
	}
	r4_16->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

struct Eq_1959 * g_ptr0C58 = &g_t200000C4;
word32 * g_ptr0C5C = &g_dwE000ED04;
// 00000C60: void vTaskNotifyGiveFromISR(Register (ptr32 Eq_2052) r0, Register (ptr32 word32) r1, Register ptr32 cpsr)
void vTaskNotifyGiveFromISR(struct Eq_2052 * r0, word32 * r1, ptr32 cpsr)
{
	Eq_2 r6_21 = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	word32 r5_25 = (word32) r0->b0064;
	r0->b0064 = 0x02;
	++r0->dw0060;
	uint32 r5_28 = (uint32) (byte) r5_25;
	if (r5_28 == 0x01)
	{
		struct Eq_2087 * r7_33 = g_ptr0CFC;
		if (r7_33->dw008C != 0x00)
			vListInsertEnd((char *) &r7_33->ptr0004 + 84, (char *) r0 + 56);
		else
		{
			uxListRemove((char *) r0 + 36);
			uint32 r0_48 = r0->dw004C;
			r7_33->dw007C = r5_28 << r0_48 | r7_33->dw007C;
			vListInsertEnd((char *) &r7_33->ptr0004 + 4 + r0_48 * 0x14, (char *) r0 + 36);
		}
		if (r0->dw004C > (r7_33->ptr0004)->dw004C)
		{
			if (r1 != null)
			{
				*r1 = 0x01;
				__msr(cpsr, r6_21);
				return;
			}
			r7_33->dw0090 = 0x01;
		}
	}
	__msr(cpsr, r6_21);
}

struct Eq_2087 * g_ptr0CFC = &g_t200000C4;
// 00000D00: void ulTaskNotifyTake(Register word32 r0, Register up32 r1, Register ptr32 cpsr)
// Called from:
//      MPU_ulTaskNotifyTake
void ulTaskNotifyTake(word32 r0, up32 r1, ptr32 cpsr)
{
	struct Eq_2152 * r4_12 = g_ptr0D64;
	vPortEnterCritical(cpsr);
	if (r4_12->ptr0004->dw0060 == 0x00)
	{
		r4_12->ptr0004->b0064 = 0x01;
		if (r1 != 0x00)
		{
			prvAddCurrentTaskToDelayedList.isra.0(r1);
			*g_ptr0D68 = 0x10000000;
			__dsb_sy();
			__isb_sy();
		}
	}
	vPortExitCritical(cpsr);
	vPortEnterCritical(cpsr);
	word32 r5_57 = r4_12->ptr0004->dw0060;
	if (r5_57 != 0x00)
	{
		if (r0 == 0x00)
			r4_12->ptr0004->dw0060 = r5_57 - 0x01;
		else
			r4_12->ptr0004->dw0060 = 0x00;
	}
	r4_12->ptr0004->b0064 = 0x00;
	vPortExitCritical(cpsr);
}

struct Eq_2152 * g_ptr0D64 = &g_t200000C4;
word32 * g_ptr0D68 = &g_dwE000ED04;
// 00000D6C: Register word32 xTaskIncrementTick()
// Called from:
//      xTaskResumeAll
//      xPortSysTickHandler
word32 xTaskIncrementTick()
{
	word32 r6_127;
	struct Eq_2227 * r4_20 = g_ptr0E64;
	if (r4_20->dw008C != 0x00)
	{
		++r4_20->dw0098;
		r6_127 = 0x00;
		goto l00000E28;
	}
	up32 r7_29 = r4_20->dw0080;
	r4_20->dw0080 = r7_29 + 0x01;
	if (r7_29 == 0x01)
	{
		struct Eq_2261 * r3_33 = r4_20->ptr006C;
		r4_20->ptr006C = r4_20->ptr0070;
		r4_20->ptr0070 = r3_33;
		++r4_20->dw0094;
		if (r4_20->ptr006C->dw0000 != 0x00)
		{
			r4_20->dw0084 = r4_20->ptr006C->ptr000C->ptr000C->dw0024;
			r6_127 = 0x00;
			if (r7_29 + 0x01 < r4_20->dw0084)
				goto l00000E14;
l00000DB2:
			r6_127 = 0x00;
			word32 r8_64 = g_dw0E68;
			while (r4_20->ptr006C->dw0000 != 0x00)
			{
				struct Eq_2298 * r5_73 = r4_20->ptr006C->ptr000C->ptr000C;
				up32 r3_74 = r5_73->dw0024;
				if (r7_29 + 0x01 < r3_74)
				{
					r4_20->dw0084 = r3_74;
					goto l00000E14;
				}
				uxListRemove(&r5_73->dw0024);
				if (r5_73->dw0048 != 0x00)
					uxListRemove(&r5_73->dw0024 + 5);
				uint32 r0_101 = r5_73->dw004C;
				r4_20->dw007C = 0x01 << r0_101 | r4_20->dw007C;
				vListInsertEnd(r8_64 + r0_101 * 0x14, &r5_73->dw0024);
				if (r5_73->dw004C >= (r4_20->ptr0004)->dw004C)
					r6_127 = 0x01;
			}
			r4_20->dw0084 = ~0x00;
l00000E14:
			if (*((char *) &(r4_20 + ((r4_20->ptr0004)->dw004C * 0x14) / 0x009C)->ptr0004 + 4) >= 0x02)
				r6_127 = 0x01;
l00000E28:
			if (r4_20->dw0090 != 0x00)
				r6_127 = 0x01;
			return r6_127;
		}
		r4_20->dw0084 = ~0x00;
	}
	r6_127 = 0x00;
	if (r7_29 + 0x01 < r4_20->dw0084)
		goto l00000E14;
	goto l00000DB2;
}

struct Eq_2227 * g_ptr0E64 = &g_t200000C4;
word32 g_dw0E68 = 0x200000CC;
// 00000E6C: Register word32 xTaskResumeAll(Register ptr32 cpsr)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
//      vTaskDelay
//      vTaskDelayUntil
//      pvPortMalloc
//      xEventGroupWaitBits
//      xEventGroupSetBits
//      xEventGroupSync
//      vEventGroupDelete
//      MPU_xTaskResumeAll
word32 xTaskResumeAll(ptr32 cpsr)
{
	struct Eq_2415 * r4_16 = g_ptr0F40;
	vPortEnterCritical(cpsr);
	--r4_16->ptr008C;
	struct Eq_2422 * r5_27 = r4_16->ptr008C;
	if (r5_27 == null && r4_16->dw0000 != 0x00)
	{
		while (r4_16->dw0058 != 0x00)
		{
			r5_27 = r4_16->ptr0064->ptr000C;
			uxListRemove((char *) r5_27 + 56);
			uxListRemove((char *) r5_27 + 36);
			uint32 r0_61 = r5_27->dw004C;
			r4_16->dw007C = 0x01 << r0_61 | r4_16->dw007C;
			vListInsertEnd((char *) &r4_16->ptr0004 + 4 + r0_61 * 0x14, (char *) r5_27 + 36);
			if (r5_27->dw004C >= (r4_16->ptr0004)->dw004C)
				r4_16->dw0090 = 0x01;
		}
		if (r5_27 != null)
		{
			if (r4_16->ptr006C->dw0000 == 0x00)
				r4_16->dw0084 = ~0x00;
			else
				r4_16->dw0084 = r4_16->ptr006C->ptr000C->ptr000C->dw0024;
		}
		word32 r5_108 = r4_16->dw0098;
		if (r5_108 != 0x00)
		{
			do
			{
				if (xTaskIncrementTick() != 0x00)
					r4_16->dw0090 = 0x01;
				--r5_108;
			} while (r5_108 != 0x00);
			r4_16->dw0098 = r5_108;
		}
		if (r4_16->dw0090 != 0x00)
		{
			*g_ptr0F44 = 0x10000000;
			__dsb_sy();
			__isb_sy();
			vPortExitCritical(cpsr);
			return 0x01;
		}
	}
	vPortExitCritical(cpsr);
	return 0x00;
}

struct Eq_2415 * g_ptr0F40 = &g_t200000C4;
word32 * g_ptr0F44 = &g_dwE000ED04;
// 00000F48: void vTaskDelay(Register up32 r0, Register ptr32 cpsr)
// Called from:
//      MPU_vTaskDelay
void vTaskDelay(up32 r0, ptr32 cpsr)
{
	if (r0 != 0x00)
	{
		struct Eq_2569 * r2_9 = g_ptr0F7C;
		++r2_9->dw008C;
		prvAddCurrentTaskToDelayedList.isra.0(r0);
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
	}
	*g_ptr0F78 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

word32 * g_ptr0F78 = &g_dwE000ED04;
struct Eq_2569 * g_ptr0F7C = &g_t200000C4;
// 00000F80: void vTaskDelayUntil(Register (ptr32 up32) r0, Register word32 r1, Register ptr32 cpsr)
// Called from:
//      MPU_vTaskDelayUntil
void vTaskDelayUntil(up32 * r0, word32 r1, ptr32 cpsr)
{
	struct Eq_2599 * r2_4 = g_ptr0FD4;
	up32 r3_12 = *r0;
	++r2_4->dw008C;
	up32 r2_15 = r2_4->dw0080;
	up32 r1_17 = r1 + r3_12;
	if (r2_15 < r3_12)
	{
		if (r3_12 <= r1_17)
			goto l00000F9E;
	}
	else if (r3_12 > r1_17)
		goto l00000FC0;
	if (r2_15 >= r1_17)
	{
l00000F9E:
		*r0 = r1_17;
		if (xTaskResumeAll(cpsr) != 0x00)
			return;
		goto l00000FA6;
	}
l00000FC0:
	*r0 = r1_17;
	prvAddCurrentTaskToDelayedList.isra.0(r1_17 - r2_15);
	if (xTaskResumeAll(cpsr) != 0x00)
		return;
l00000FA6:
	*g_ptr0FD8 = 0x10000000;
	__dsb_sy();
	__isb_sy();
}

struct Eq_2599 * g_ptr0FD4 = &g_t200000C4;
word32 * g_ptr0FD8 = &g_dwE000ED04;
// 00000FDC: void vTaskPlaceOnEventList(Register (ptr32 Eq_466) r0, Register up32 r1)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
void vTaskPlaceOnEventList(struct Eq_466 * r0, up32 r1)
{
	vListInsert(r0, g_ptr0FF4->dw0004 + 0x38);
	prvAddCurrentTaskToDelayedList.isra.0(r1);
}

struct Eq_2653 * g_ptr0FF4 = &g_t200000C4;
// 00000FF8: void vTaskPlaceOnUnorderedEventList(Register (ptr32 Eq_1437) r0, Register ui32 r1, Register up32 r2)
// Called from:
//      xEventGroupWaitBits
//      xEventGroupSync
void vTaskPlaceOnUnorderedEventList(struct Eq_1437 * r0, ui32 r1, up32 r2)
{
	struct Eq_2665 * r3_14 = g_ptr1018;
	struct Eq_2668 * r3_18 = r3_14->ptr0004;
	r3_14->ptr0004->dw0038 = r1 | 0x80000000;
	vListInsertEnd(r0, &r3_18->dw0038);
	prvAddCurrentTaskToDelayedList.isra.0(r2);
}

struct Eq_2665 * g_ptr1018 = &g_t200000C4;
// 0000101C: Register (ptr32 Eq_43) xTaskRemoveFromEventList(Register (ptr32 Eq_43) r0)
// Called from:
//      prvUnlockQueue
//      xQueueGenericSend
//      xQueueGenericReceive
//      xQueueGenericSendFromISR
//      xQueueGiveFromISR
//      xQueueReceiveFromISR
//      xQueueGenericReset
struct Eq_43 * xTaskRemoveFromEventList(struct Eq_43 * r0)
{
	struct Eq_1437 * r0_32;
	struct Eq_2687 * r4_18 = g_ptr107C;
	struct Eq_2690 * r5_19 = r0->ptr000C->ptr000C;
	uxListRemove((char *) r5_19 + 56);
	if (r4_18->dw008C == 0x00)
	{
		uxListRemove((char *) r5_19 + 36);
		uint32 r0_50 = r5_19->dw004C;
		r4_18->dw007C = 0x01 << r0_50 | r4_18->dw007C;
		r0_32 = (struct Eq_1437 *) ((char *) &r4_18->ptr0004 + 4 + r0_50 * 0x14);
		vListInsertEnd(r0_32, (char *) r5_19 + 36);
	}
	else
	{
		vListInsertEnd((char *) &r4_18->ptr0004 + 84, (char *) r5_19 + 56);
		r0_32 = (struct Eq_1437 *) ((char *) &r4_18->ptr0004 + 84);
	}
	if (r5_19->dw004C > (r4_18->ptr0004)->dw004C)
		r0_32 = (struct Eq_1437 *) &g_dw0001;
	r4_18->ptr0090 = r0_32;
	return null;
}

struct Eq_2687 * g_ptr107C = &g_t200000C4;
// 00001080: void xTaskRemoveFromUnorderedEventList(Register (ptr32 Eq_1438) r0, Register ui32 r1)
// Called from:
//      xEventGroupSetBits
//      vEventGroupDelete
void xTaskRemoveFromUnorderedEventList(struct Eq_1438 * r0, ui32 r1)
{
	struct Eq_2754 * r6_18 = r0->ptr000C;
	r0->dw0000 = r1 | 0x80000000;
	uxListRemove(r0);
	struct Eq_2765 * r4_31 = g_ptr10D4;
	uxListRemove((char *) r6_18 + 36);
	uint32 r3_41 = r6_18->dw004C;
	r4_31->dw007C = 0x01 << r3_41 | r4_31->dw007C;
	vListInsertEnd((char *) &r4_31->ptr0004 + 4 + r3_41 * 0x14, (char *) r6_18 + 36);
	r6_18->dw004C <= (r4_31->ptr0004)->dw004C;
	r4_31->dw0090 = 0x01;
}

struct Eq_2765 * g_ptr10D4 = &g_t200000C4;
// 000010D8: void vTaskSwitchContext()
// Called from:
//      xPortPendSVHandler
void vTaskSwitchContext()
{
	struct Eq_2807 * r2_4 = g_ptr111C;
	word32 r3_5 = r2_4->dw008C;
	if (r3_5 != 0x00)
		r2_4->dw0090 = 0x01;
	else
	{
		struct Eq_2820 * r1_23;
		r2_4->dw0090 = r3_5;
		struct Eq_2824 * r0_15 = r2_4 + ((0x1F - (uint32) ((byte) __clz(r2_4->dw007C))) * 0x14) / 0x0094;
		struct Eq_2820 * r1_19 = r0_15->ptr000C->ptr0004;
		r0_15->ptr000C = r1_19;
		r1_23 = r1_19;
		if (r1_19 == (char *) (&r0_15->ptr000C) + 4)
			r1_23 = r1_19->ptr0004;
		word32 r3_26 = r1_23->dw000C;
		if (r1_19 == (char *) (&r0_15->ptr000C) + 4)
			r0_15->ptr000C = r1_23;
		r2_4->dw0004 = r3_26;
	}
}

struct Eq_2807 * g_ptr111C = &g_t200000C4;
// 00001120: Register word32 uxTaskResetEventItemValue()
// Called from:
//      xEventGroupWaitBits
//      xEventGroupSync
word32 uxTaskResetEventItemValue()
{
	struct Eq_2866 * r3_4 = g_ptr1134;
	word32 r0_8 = r3_4->ptr0004->dw0038;
	r3_4->ptr0004->dw0038 = 0x02 - (r3_4->ptr0004)->dw004C;
	return r0_8;
}

struct Eq_2866 * g_ptr1134 = &g_t200000C4;
// 00001138: Register word32 xTaskGetCurrentTaskHandle()
// Called from:
//      xQueueTakeMutexRecursive
//      xQueueGiveMutexRecursive
word32 xTaskGetCurrentTaskHandle()
{
	return g_ptr1140->dw0004;
}

struct Eq_2892 * g_ptr1140 = &g_t200000C4;
// 00001144: void vTaskSetTimeOutState(Register (ptr32 Eq_391) r0)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
//      MPU_vTaskSetTimeOutState
void vTaskSetTimeOutState(struct Eq_391 * r0)
{
	struct Eq_2896 * r3_4 = g_ptr1154;
	word32 r3_6 = r3_4->dw0080;
	r0->dw0000 = r3_4->dw0094;
	r0->dw0004 = r3_6;
}

struct Eq_2896 * g_ptr1154 = &g_t200000C4;
// 00001158: Register (ptr32 Eq_432) xTaskCheckForTimeOut(Register (ptr32 Eq_432) r0, Register (ptr32 up32) r1, Register ptr32 cpsr)
// Called from:
//      xQueueGenericSend
//      xQueueGenericReceive
//      MPU_xTaskCheckForTimeOut
struct Eq_432 * xTaskCheckForTimeOut(struct Eq_432 * r0, up32 * r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	struct Eq_2914 * r3_23 = g_ptr11A8;
	up32 r5_25 = r3_23->dw0080;
	up32 r0_27 = r0->dw0004;
	if (r0->dw0000 == r3_23->dw0094 || r5_25 < r0_27)
	{
		up32 r2_34 = *r1;
		if (r5_25 - r0_27 < r2_34)
		{
			word32 r1_60 = r3_23->dw0094;
			up32 r3_61 = r3_23->dw0080;
			*r1 = r2_34 - r5_25 + r0_27;
			r0->dw0000 = r1_60;
			r0->dw0004 = r3_61;
			vPortExitCritical(cpsr);
			return null;
		}
	}
	vPortExitCritical(cpsr);
	return &g_dw0001;
}

struct Eq_2914 * g_ptr11A8 = &g_t200000C4;
// 000011AC: void vTaskMissedYield()
// Called from:
//      prvUnlockQueue
void vTaskMissedYield()
{
	g_ptr11B8->dw0090 = 0x01;
}

struct Eq_2966 * g_ptr11B8 = &g_t200000C4;
// 000011BC: void vTaskPriorityInherit(Register Eq_2 r0)
// Called from:
//      xQueueGenericReceive
void vTaskPriorityInherit(Eq_2 r0)
{
	if (r0 == 0x00)
		return;
	struct Eq_2972 * r4_19 = g_ptr1248;
	uint32 r3_20 = *((word32) r0 + 76);
	if (r3_20 >= (r4_19->ptr0004)->dw004C)
		return;
	if (*((word32) r0 + 56) >= 0x00)
		*((word32) r0 + 56) = 0x02 - (r4_19->ptr0004)->dw004C;
	word32 r5_33 = g_dw124C;
	if (*((word32) r0 + 52) == r5_33 + r3_20 * 0x14)
	{
		if (uxListRemove((word32) r0 + 36) == 0x00)
		{
			uint32 r2_52 = *((word32) r0 + 76);
			if (*((char *) &(r4_19 + (r2_52 * 0x14) / 0x0080)->ptr0004 + 4) == 0x00)
				r4_19->dw007C &= ~(0x01 << r2_52);
		}
		uint32 r2_67 = r4_19->ptr0004->dw004C;
		ui32 r3_72 = 0x01 << r2_67 | r4_19->dw007C;
		*((word32) r0 + 76) = r2_67;
		r4_19->dw007C = r3_72;
		struct Eq_1437 * r0_77 = r5_33 + r2_67 * 0x14;
		vListInsertEnd(r0_77, (word32) r0 + 36);
	}
	else
		*((word32) r0 + 76) = r4_19->ptr0004->dw004C;
}

struct Eq_2972 * g_ptr1248 = &g_t200000C4;
word32 g_dw124C = 0x200000CC;
// 00001250: Register Eq_2 xTaskPriorityDisinherit(Register Eq_2 r0, Register out Eq_150 lrOut)
// Called from:
//      prvCopyDataToQueue
Eq_2 xTaskPriorityDisinherit(Eq_2 r0, union Eq_150 & lrOut)
{
	if (r0 == 0x00)
	{
		lrOut = lr;
		return 0x00;
	}
	else
	{
		uint32 r1_20 = *((word32) r0 + 76);
		word32 r3_21 = *((word32) r0 + 92);
		uint32 r2_22 = *((word32) r0 + 88);
		*((word32) r0 + 92) = r3_21 - 0x01;
		if (r1_20 == r2_22 || r3_21 != 0x01)
		{
			lrOut = lr;
			return 0x00;
		}
		else
		{
			struct Eq_3101 * r2_38;
			if (uxListRemove((word32) r0 + 36) == 0x00)
			{
				uint32 r1_39 = *((word32) r0 + 76);
				r2_38 = g_ptr12CC;
				if (*((char *) (r2_38 + (r1_39 * 0x14) / 0x0080) + 8) == 0x00)
					r2_38->t007C &= ~(0x01 << r1_39);
			}
			else
				r2_38 = g_ptr12CC;
			uint32 r3_52 = *((word32) r0 + 88);
			Eq_150 lr_54 = r2_38->t007C;
			word32 r0_55 = g_dw12D0;
			*((word32) r0 + 76) = r3_52;
			*((word32) r0 + 56) = 0x02 - r3_52;
			r2_38->t007C = 0x01 << r3_52 | lr_54;
			vListInsertEnd(r0_55 + r3_52 * 0x14, (word32) r0 + 36);
			lrOut = lr_54;
			return 0x01;
		}
	}
}

struct Eq_3101 * g_ptr12CC = &g_t200000C4;
word32 g_dw12D0 = 0x200000CC;
// 000012D4: Register (ptr32 Eq_3166) pvTaskIncrementMutexHeldCount()
// Called from:
//      xQueueGenericReceive
struct Eq_3166 * pvTaskIncrementMutexHeldCount()
{
	struct Eq_3167 * r3_4 = g_ptr12E8;
	if (r3_4->ptr0004 != null)
	{
		struct Eq_3166 * r1_6 = r3_4->ptr0004;
		++r1_6->dw005C;
	}
	return r3_4->ptr0004;
}

struct Eq_3167 * g_ptr12E8 = &g_t200000C4;
// 000012F0: void prvRestoreContextOfFirstTask(Register ptr32 cpsr)
// Called from:
//      prvSVCHandler
void prvRestoreContextOfFirstTask(ptr32 cpsr)
{
	__msr(cpsr, **g_ptr1724);
	struct Eq_3201 * r1_9 = *g_ptr1330;
	union Eq_2 * r0_10 = r1_9->ptr0000;
	struct Eq_3211 * r2_12 = g_ptr1728;
	word32 r5_14 = r1_9->dw0008;
	word32 r6_15 = r1_9->dw000C;
	word32 r7_16 = r1_9->dw0010;
	word32 r8_17 = r1_9->dw0014;
	word32 r9_18 = r1_9->dw0018;
	word32 r10_19 = r1_9->dw001C;
	word32 fp_20 = r1_9->dw0020;
	r2_12->dw0000 = r1_9->dw0004;
	r2_12->dw0004 = r5_14;
	r2_12->dw0008 = r6_15;
	r2_12->dw000C = r7_16;
	r2_12->dw0010 = r8_17;
	r2_12->dw0014 = r9_18;
	r2_12->dw0018 = r10_19;
	r2_12->dw001C = fp_20;
	__msr(cpsr, *r0_10);
	__msr(cpsr, (char *) r0_10 + 36);
	__msr(cpsr, 0x00);
}

struct Eq_3201 ** g_ptr1330 = &g_ptr200000C8;
// 00001334: void prvSVCHandler(Register Eq_2 r0, Register ptr32 cpsr)
// Called from:
//      vPortSVCHandler
void prvSVCHandler(Eq_2 r0, ptr32 cpsr)
{
	up32 r3_6 = (word32) *((word32) *((word32) r0 + 24) - 2);
	if (r3_6 == 0x01)
	{
		*g_ptr1378 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	else if (r3_6 < 0x01)
	{
		ui32 * r2_13 = g_ptr1374;
		*r2_13 |= 0xBE000000;
		prvRestoreContextOfFirstTask(cpsr);
	}
	else
	{
		if (r3_6 != 0x02)
			return;
		__msr(cpsr, __mrs(cpsr) & ~0x01);
	}
}

ui32 * g_ptr1374 = &g_dwE000ED1C;
word32 * g_ptr1378 = &g_dwE000ED04;
// 0000137C: Register (ptr32 Eq_1203) pxPortInitialiseStack(Register (ptr32 Eq_1203) r0, Register ui32 r1, Register word32 r2, Register int32 r3)
// Called from:
//      prvInitialiseNewTask
struct Eq_1203 * pxPortInitialiseStack(struct Eq_1203 * r0, ui32 r1, word32 r2, int32 r3)
{
	int32 r3_11;
	r3_11 = r3;
	if (r3 == 0x01)
		r3_11 = 0x02;
	if (r3 != 0x01)
		r3_11 = 0x03;
	r0->dwFFFFFFE0 = r2;
	r0->dwFFFFFFF8 = r1 & ~0x01;
	r0->dwFFFFFFFC = 0x01000000;
	r0->dwFFFFFFF4 = 0x00;
	r0->dwFFFFFFBC = r3_11;
	return r0 - 0x44;
}

// 000013B0: void xPortStartScheduler(Register ptr32 cpsr)
// Called from:
//      vTaskStartScheduler
void xPortStartScheduler(ptr32 cpsr)
{
	ui32 * r3_4 = g_ptr14E8;
	word32 * r1_13 = g_ptr14EC;
	*r3_4 |= 0x00FF0000;
	*r3_4 |= 0xFF000000;
	if (*r1_13 == 0x0800)
	{
		ui32 r2_30;
		ui32 r0_22 = g_dw14FC;
		uint32 r1_25 = g_dw1500 - r0_22;
		*g_ptr1504 = r0_22 | 0x10;
		if (r1_25 > 0x20)
		{
			uint32 r3_31 = 0x40;
			ui32 r2_32;
			for (r2_32 = 0x05; r2_32 != 0x1F; ++r2_32)
			{
				r3_31 <<= 0x01;
				if (r1_25 <= r3_31)
				{
					r2_30 = g_dw1508 | r2_32 << 0x01;
					goto l0000142C;
				}
			}
			r2_30 = g_dw1538;
		}
		else
			r2_30 = g_dw1548;
l0000142C:
		ui32 r2_59;
		uint32 r1_51 = g_dw150C - r0_22;
		ui32 * r3_52 = g_ptr1504;
		g_ptr1510->dw0000 = r2_30;
		*r3_52 = r0_22 | 0x11;
		if (r1_51 > 0x20)
		{
			uint32 r3_60 = 0x40;
			ui32 r2_61;
			for (r2_61 = 0x05; r2_61 != 0x1F; ++r2_61)
			{
				r3_60 <<= 0x01;
				if (r1_51 <= r3_60)
				{
					r2_59 = g_dw1514 | r2_61 << 0x01;
					goto l0000145A;
				}
			}
			r2_59 = g_dw153C;
		}
		else
			r2_59 = g_dw1544;
l0000145A:
		ui32 r0_100;
		ui32 r3_76 = g_dw1518;
		ui32 * r0_79 = g_ptr1504;
		uint32 r1_80 = g_dw151C - r3_76;
		g_ptr1510->dw0000 = r2_59;
		*r0_79 = r3_76 | 0x12;
		if (r1_80 > 0x20)
		{
			uint32 r3_88 = 0x40;
			ui32 r2_89;
			for (r2_89 = 0x05; r2_89 != 0x1F; ++r2_89)
			{
				r3_88 <<= 0x01;
				if (r1_80 <= r3_88)
				{
					r0_100 = g_dw1520 | r2_89 << 0x01;
					goto l0000148A;
				}
			}
			r0_100 = g_dw1540;
		}
		else
			r0_100 = g_dw154C;
l0000148A:
		ui32 * r4_107 = g_ptr1504;
		ui32 r5_108 = g_dw1524;
		uint32 r1_109 = g_dw1528;
		g_ptr1510->dw0000 = r0_100;
		*r4_107 = r5_108;
		ui32 r3_103 = 0x05;
		uint32 r2_104 = 0x40;
		do
		{
			ui32 r3_120;
			++r3_103;
			r2_104 <<= 0x01;
			if (r3_103 == 0x1F)
			{
				r3_120 = g_dw1534;
				goto l000014AE;
			}
		} while (r2_104 <= r1_109);
		r3_120 = g_dw152C | r3_103 << 0x01;
l000014AE:
		struct Eq_3464 * r2_127 = g_ptr1510;
		ui32 * r1_128 = g_ptr1530;
		r2_127->dw0000 = r3_120;
		*r1_128 |= 0x00010000;
		r2_127->dwFFFFFFF4 |= 0x05;
	}
	word32 * r2_142 = g_ptr14F4;
	word32 * r3_143 = g_ptr14F8;
	*g_ptr14F0 = 19999;
	*r2_142 = 0x07;
	*r3_143 = 0x00;
	__msr(cpsr, **g_ptr1724);
	__cps();
	__cps();
	__dsb_sy();
	__isb_sy();
	__syscall(0x00);
}

ui32 * g_ptr14E8 = &g_dwE000ED20;
word32 * g_ptr14EC = &g_dwE000ED90;
word32 * g_ptr14F0 = &g_dwE000E014;
word32 * g_ptr14F4 = &g_dwE000E010;
word32 * g_ptr14F8 = &g_dw200000BC;
ui32 g_dw14FC = 0x00;
word32 g_dw1500 = 0x00020000;
ui32 * g_ptr1504 = &g_dwE000ED9C;
ui32 g_dw1508 = 0x06070001;
word32 g_dw150C = 0x8000;
struct Eq_3464 * g_ptr1510 = &g_tE000EDA0;
ui32 g_dw1514 = 0x05070001;
ui32 g_dw1518 = 0x20000000;
word32 g_dw151C = 0x20000200;
ui32 g_dw1520 = 0x01070001;
ui32 g_dw1524 = 0x40000013;
uint32 g_dw1528 = 0x1FFFFFFE;
ui32 g_dw152C = 0x13000001;
ui32 * g_ptr1530 = &g_dwE000ED24;
ui32 g_dw1534 = 0x1300003F;
ui32 g_dw1538 = 101122111;
ui32 g_dw153C = 0x0507003F;
ui32 g_dw1540 = 0x0107003F;
ui32 g_dw1544 = 0x05070009;
ui32 g_dw1548 = 0x06070009;
ui32 g_dw154C = 0x01070009;
// 00001550: void vPortEndScheduler()
// Called from:
//      vTaskEndScheduler
void vPortEndScheduler()
{
}

// 00001554: void vPortStoreTaskMPUSettings(Register (ptr32 Eq_1286) r0, Register (ptr32 Eq_1197) r1, Register (ptr32 Eq_1053) r2, Register ui32 r3)
// Called from:
//      prvInitialiseNewTask
//      vTaskAllocateMPURegions
void vPortStoreTaskMPUSettings(struct Eq_1286 * r0, struct Eq_1197 * r1, struct Eq_1053 * r2, ui32 r3)
{
	if (r1 == null)
	{
		ui32 r2_19;
		ui32 r3_11 = g_dw1668;
		uint32 r1_14 = g_dw166C - r3_11;
		r0->dw0000 = r3_11 | 0x14;
		if (r1_14 > 0x20)
		{
			uint32 r3_20 = 0x40;
			ui32 r2_21;
			for (r2_21 = 0x05; r2_21 != 0x1F; ++r2_21)
			{
				r3_20 <<= 0x01;
				if (r3_20 >= r1_14)
				{
					r2_19 = g_dw1660 | r2_21 << 0x01;
					goto l00001608;
				}
			}
			r2_19 = g_dw1664;
		}
		else
			r2_19 = g_dw1680;
l00001608:
		ui32 r2_47;
		ui32 r3_36 = g_dw1670;
		uint32 r1_39 = g_dw1674 - r3_36;
		r0->dw0004 = r2_19;
		r0[1] = (struct Eq_1286) (r3_36 | 0x15);
		if (r1_39 > 0x20)
		{
			ui32 r2_48;
			uint32 r3_49 = 0x40;
			for (r2_48 = 0x05; r2_48 != 0x1F; ++r2_48)
			{
				r3_49 <<= 0x01;
				if (r1_39 <= r3_49)
				{
					r2_47 = g_dw1678 | r2_48 << 0x01;
					goto l00001634;
				}
			}
			r2_47 = g_dw167C;
		}
		else
			r2_47 = g_dw1684;
l00001634:
		r0[2] = (struct Eq_1286) 22;
		r0->dw000C = r2_47;
		r0->dw0014 = 0x00;
		r0->dw001C = 0x00;
		r0[3] = (struct Eq_1286) 0x17;
	}
	else
	{
		if (r3 != 0x00)
		{
			ui32 r4_101;
			r0->dw0000 = r2 | 0x14;
			if (r3 << 2 > 0x20)
			{
				uint32 r2_89 = 0x40;
				ui32 r4_90;
				for (r4_90 = 0x05; r4_90 != 0x1F; ++r4_90)
				{
					r2_89 <<= 0x01;
					if (r3 << 2 <= r2_89)
					{
						r4_101 = g_dw1660 | r4_90 << 0x01;
						goto l000015D6;
					}
				}
				r4_101 = g_dw1664;
			}
			else
				r4_101 = g_dw1680;
l000015D6:
			r0->dw0004 = r4_101;
		}
		ui32 r5_108;
		for (r5_108 = 0x05; r5_108 != 0x08; ++r5_108)
		{
			uint32 r4_111 = r1->dw0004;
			if (r4_111 != 0x00)
			{
				ui32 r3_123;
				r0[1] = (struct Eq_1286) (r1->dw0000 | (r5_108 | 0x10));
				if (r4_111 > 0x20)
				{
					uint32 r2_124 = 0x40;
					ui32 r3_125;
					for (r3_125 = 0x05; r3_125 != 0x1F; ++r3_125)
					{
						r2_124 <<= 0x01;
						if (r4_111 <= r2_124)
						{
							r3_123 = r3_125 << 1;
							goto l00001586;
						}
					}
					r3_123 = 0x3E;
				}
				else
					r3_123 = 0x08;
l00001586:
				r0->dw000C = r3_123 | (r1->dw0008 | 0x01);
			}
			else
			{
				r0->dw000C = r4_111;
				r0[1] = (struct Eq_1286) (r5_108 | 0x10);
			}
			++r1;
			++r0;
		}
	}
}

ui32 g_dw1660 = 0x03070001;
ui32 g_dw1664 = 0x0307003F;
ui32 g_dw1668 = 0x20000000;
word32 g_dw166C = 0x20002000;
ui32 g_dw1670 = 0x20000000;
word32 g_dw1674 = 0x20000200;
ui32 g_dw1678 = 0x01070001;
ui32 g_dw167C = 0x0107003F;
ui32 g_dw1680 = 0x03070009;
ui32 g_dw1684 = 0x01070009;
// 00001688: void xPortPendSVHandler(Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 r9, Register word32 r10, Register word32 fp, Register ptr32 cpsr)
void xPortPendSVHandler(word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 r9, word32 r10, word32 fp, ptr32 cpsr)
{
	Eq_2 r0_4 = __mrs(cpsr);
	struct Eq_3812 ** r3_6 = g_ptr16E0;
	struct Eq_3812 * r2_7 = *r3_6;
	*((word32) r0_4 - 36) = __mrs(cpsr);
	*((word32) r0_4 - 32) = r4;
	*((word32) r0_4 - 28) = r5;
	*((word32) r0_4 - 24) = r6;
	*((word32) r0_4 - 20) = r7;
	*((word32) r0_4 - 16) = r8;
	*((word32) r0_4 - 0x0C) = r9;
	*((word32) r0_4 - 8) = r10;
	*((word32) r0_4 - 4) = fp;
	r2_7->ptr0000 = r0_4 - 36;
	__msr(cpsr, 191);
	vTaskSwitchContext();
	__msr(cpsr, 0x00);
	struct Eq_3812 * r1_39 = *r3_6;
	union Eq_2 * r0_40 = r1_39->ptr0000;
	struct Eq_3211 * r2_42 = g_ptr1728;
	word32 r5_44 = r1_39->dw0008;
	word32 r6_45 = r1_39->dw000C;
	word32 r7_46 = r1_39->dw0010;
	word32 r8_47 = r1_39->dw0014;
	word32 r9_48 = r1_39->dw0018;
	word32 r10_49 = r1_39->dw001C;
	word32 fp_50 = r1_39->dw0020;
	r2_42->dw0000 = r1_39->dw0004;
	r2_42->dw0004 = r5_44;
	r2_42->dw0008 = r6_45;
	r2_42->dw000C = r7_46;
	r2_42->dw0010 = r8_47;
	r2_42->dw0014 = r9_48;
	r2_42->dw0018 = r10_49;
	r2_42->dw001C = fp_50;
	__msr(cpsr, *r0_40);
	__msr(cpsr, (char *) r0_40 + 36);
}

Eq_1053 g_t1689 = 
	{
		&g_t148009F3,
		4016577099,
		&g_t208114F3,
		0x100FF2E9,
		&g_t8E92D60,
		0x11F38000,
		&g_t11F38000,
		0x08681940,
		&g_t4F10168,
		0x1A01,
		0xA20FF0E8,
		0xB00FF0E8,
		0x830FF8E8,
		&g_t808814F3,
		0x14,
		~0x5040FFB8,
		&g_tAF8000F3,
		0x80,
		0x10200000,
		0x11F3EFB5,
		~0x400FB07B,
		0x03,
		131,
	};
struct Eq_3812 ** g_ptr16E0 = &g_ptr200000C8;
// 000016E4: void xPortSysTickHandler(Register ptr32 cpsr)
void xPortSysTickHandler(ptr32 cpsr)
{
	Eq_2 r4_9 = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	if (xTaskIncrementTick() != 0x00)
		*g_ptr1710 = 0x10000000;
	__msr(cpsr, r4_9);
}

word32 * g_ptr1710 = &g_dwE000ED04;
// 00001714: void vPortSVCHandler(Register ui32 lr, Register ptr32 cpsr)
void vPortSVCHandler(ui32 lr, ptr32 cpsr)
{
	if ((lr & 0x04) == 0x00)
		__mrs(cpsr);
	Eq_2 r0_9 = __mrs(cpsr);
	prvSVCHandler(r0_9, cpsr);
}

Eq_1053 g_t1715 = 
	{
		&g_tC0F04F0,
		0x08F3EFBF,
		&g_t9F3EF80,
		0x08E60780,
		&g_t9CE000ED,
		0x434604B5,
		&g_t67F7FF34,
		1085385320,
		&g_tD351B3F2,
		49400,
		0x09428C44,
		0x0742A2D8,
		3278379474,
		&g_t8C45C0F8,
		0xC0,
		0x104620FB,
		&g_tFF2400BD,
		~0x04,
		62722118,
		0x22020CF1,
		0x1A0207F0,
		0x60,
		227,
	};
union Eq_2 ** g_ptr1724 = &g_ptrE000ED08;
struct Eq_3211 * g_ptr1728 = &g_tE000ED9C;
// 0000172C: Register ui32 pvPortMalloc(Register ui32 r0, Register ptr32 cpsr)
// Called from:
//      xQueueGenericCreate
//      xTaskCreate
//      xTaskCreateRestricted
//      xEventGroupCreate
//      MPU_pvPortMalloc
//      xCoRoutineCreate
ui32 pvPortMalloc(ui32 r0, ptr32 cpsr)
{
	ui32 r4_13 = r0;
	if (r0 << 29 != 0x00)
		r4_13 = r0 & ~0x07;
	vTaskSuspendAll();
	struct Eq_3978 * r3_24 = g_ptr177C;
	word32 r4_15 = r4_13 + 0x08;
	if (r3_24->dw0000 == 0x00)
		Mem28[r3_24 + 0x00:word32] = r3_24 + 0x0C & ~0x07;
	up32 r2_32 = r3_24->dw05C0;
	up32 r4_34 = r4_15 + r2_32;
	if (r4_34 > 0x05B3 || r2_32 >= r4_34)
	{
		xTaskResumeAll(cpsr);
		return 0x00;
	}
	else
	{
		ui32 r1_59 = r3_24->dw0000;
		r3_24->dw05C0 = r4_34;
		xTaskResumeAll(cpsr);
		return r1_59 + r2_32;
	}
}

struct Eq_3978 * g_ptr177C = &g_t20000230;
// 00001780: void vPortFree()
// Called from:
//      vQueueDelete
//      xTaskCreate
//      vEventGroupDelete
//      MPU_vPortFree
void vPortFree()
{
}

// 00001784: void vPortInitialiseBlocks()
// Called from:
//      MPU_vPortInitialiseBlocks
void vPortInitialiseBlocks()
{
	g_ptr1790->dw05C0 = 0x00;
}

struct Eq_4024 * g_ptr1790 = &g_t20000230;
// 00001794: void xPortGetFreeHeapSize()
// Called from:
//      MPU_xPortGetFreeHeapSize
void xPortGetFreeHeapSize()
{
}

// 000017A8: void xEventGroupCreate(Register ptr32 cpsr)
// Called from:
//      MPU_xEventGroupCreate
void xEventGroupCreate(ptr32 cpsr)
{
	struct Eq_1053 * r0_10 = pvPortMalloc(0x18, cpsr);
	if (r0_10 != null)
	{
		r0_10->ptr0000 = null;
		vListInitialise(&r0_10->dw0004);
	}
}

// 000017C4: void xEventGroupWaitBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 r2, Register word32 r3, Register ptr32 cpsr, Stack up32 dwArg00)
// Called from:
//      MPU_xEventGroupWaitBits
void xEventGroupWaitBits(ui32 * r0, ui32 r1, word32 r2, word32 r3, ptr32 cpsr, up32 dwArg00)
{
	Eq_380 C_28 = vTaskSuspendAll();
	ui32 r5_112 = r1;
	ui32 r4_157 = *r0;
	if (r3 == 0x00)
	{
		r4_157 = (word32) C_28 + (r4_157 + r1);
		if (r4_157 != 0x00)
		{
l000017DC:
			if (r2 != 0x00)
				*r0 = r4_157 & ~r1;
l000017E8:
			xTaskResumeAll(cpsr);
			return;
		}
	}
	else if ((r1 & ~r4_157) == 0x00)
		goto l000017DC;
	if (dwArg00 == 0x00)
		goto l000017E8;
	ui32 r1_46 = 0x01000000;
	if (r3 != 0x00)
		r1_46 = 0x05000000;
	vTaskPlaceOnUnorderedEventList(r0 + 1, r1_46 | r1, dwArg00);
	if (xTaskResumeAll(cpsr) == 0x00)
	{
		*g_ptr1870 = 0x10000000;
		__dsb_sy();
		__isb_sy();
	}
	if (uxTaskResetEventItemValue() << 6 < 0x00)
		return;
	bool C_101 = vPortEnterCritical(cpsr);
	ui32 r4_105 = *r0;
	if (r3 == 0x00)
	{
		r5_112 = r1 + r4_105 + C_101;
		if (r5_112 == 0x00)
			goto l0000185C;
	}
	else if ((r1 & ~r4_105) != 0x00)
		goto l0000185C;
	if (r2 != 0x00)
		*r0 = r4_105 & ~r5_112;
l0000185C:
	vPortExitCritical(cpsr);
}

word32 * g_ptr1870 = &g_dwE000ED04;
// 00001874: void xEventGroupClearBits(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
// Called from:
//      MPU_xEventGroupClearBits
void xEventGroupClearBits(ui32 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	*r0 &= ~r1;
	vPortExitCritical(cpsr);
}

// 00001890: void xEventGroupSetBits(Register (ptr32 Eq_4153) r0, Register ui32 r1, Register ptr32 cpsr)
// Called from:
//      xEventGroupSync
//      vEventGroupSetBitsCallback
//      MPU_xEventGroupSetBits
void xEventGroupSetBits(struct Eq_4153 * r0, ui32 r1, ptr32 cpsr)
{
	ui32 r7_33;
	vTaskSuspendAll();
	struct Eq_1438 * r0_27 = r0->ptr0010;
	ui32 r1_29 = r0->dw0000 | r1;
	r0->dw0000 = r1_29;
	if (&r0->dw0000 + 3 != r0_27)
	{
		ui32 r7_34 = 0x00;
		do
		{
			ui32 r3_37 = r0_27->dw0000;
			struct Eq_1438 * r4_38 = r0_27->ptr0004;
			ui32 r2_40 = r3_37 & ~0xFF000000;
			if ((r3_37 & 0x04000000) == 0x00)
			{
				r2_40 = r2_40 + r1_29 + ((r3_37 & 0x04000000) < 0x00);
				if (r2_40 != 0x00)
				{
l000018B2:
					if (r3_37 << 7 < 0x00)
						r7_34 |= r2_40;
					xTaskRemoveFromUnorderedEventList(r0_27, r1_29 | 0x02000000);
					r1_29 = r0->dw0000;
				}
				r0_27 = r4_38;
				if (&r0->dw0000 + 3 != r4_38)
					continue;
				break;
			}
			if ((r2_40 & ~r1_29) == 0x00)
				goto l000018B2;
			r0_27 = r4_38;
		} while (&r0->dw0000 + 3 != r4_38);
		r7_33 = ~r7_34;
	}
	else
		r7_33 = ~0x00;
	r0->dw0000 = r1_29 & r7_33;
	xTaskResumeAll(cpsr);
}

// 000018F8: void xEventGroupSync(Register (ptr32 Eq_4153) r0, Register ui32 r1, Register ui32 r2, Register up32 r3, Register ptr32 cpsr)
// Called from:
//      MPU_xEventGroupSync
void xEventGroupSync(struct Eq_4153 * r0, ui32 r1, ui32 r2, up32 r3, ptr32 cpsr)
{
	vTaskSuspendAll();
	ui32 r4_33 = r0->dw0000 | r1;
	xEventGroupSetBits(r0, r1, cpsr);
	ui32 r6_21 = r2;
	if ((r2 & ~r4_33) != 0x00)
	{
		if (r3 != 0x00)
		{
			vTaskPlaceOnUnorderedEventList(&r0->dw0000 + 1, r2 | 0x05000000, r3);
			if (xTaskResumeAll(cpsr) == 0x00)
			{
				*g_ptr1984 = 0x10000000;
				__dsb_sy();
				__isb_sy();
			}
			if (uxTaskResetEventItemValue() << 6 >= 0x00)
			{
				vPortEnterCritical(cpsr);
				ui32 r4_89 = r0->dw0000;
				if ((r2 & ~r4_89) == 0x00)
					r6_21 = r4_89 & ~r2;
				r0->dw0000 = r6_21;
				vPortExitCritical(cpsr);
			}
			return;
		}
	}
	else
		r0->dw0000 &= ~r2;
	xTaskResumeAll(cpsr);
}

word32 * g_ptr1984 = &g_dwE000ED04;
// 00001988: void xEventGroupGetBitsFromISR(Register ptr32 cpsr)
void xEventGroupGetBitsFromISR(ptr32 cpsr)
{
	Eq_2 r3_4 = __mrs(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	__msr(cpsr, r3_4);
}

// 000019A4: void vEventGroupDelete(Register (ptr32 Eq_4316) r0, Register ptr32 cpsr)
// Called from:
//      MPU_vEventGroupDelete
void vEventGroupDelete(struct Eq_4316 * r0, ptr32 cpsr)
{
	vTaskSuspendAll();
	while (r0->dw0004 != 0x00)
		xTaskRemoveFromUnorderedEventList(r0->ptr0010, 0x02000000);
	vPortFree();
	xTaskResumeAll(cpsr);
}

// 000019D0: void vEventGroupSetBitsCallback(Register (ptr32 Eq_4153) r0, Register ui32 r1, Register ptr32 cpsr)
void vEventGroupSetBitsCallback(struct Eq_4153 * r0, ui32 r1, ptr32 cpsr)
{
	xEventGroupSetBits(r0, r1, cpsr);
}

// 000019D4: void vEventGroupClearBitsCallback(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
void vEventGroupClearBitsCallback(ui32 * r0, word32 r1, ptr32 cpsr)
{
	vPortEnterCritical(cpsr);
	*r0 &= ~r1;
	vPortExitCritical(cpsr);
}

// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00008000: void NmiSR()
void NmiSR()
{
	while (true)
		;
}

Eq_1053 g_t8001 = 
	{
		&g_tFEBF00E7,
		0x08BF00E7,
		&g_t8348094B,
		0xDAD20A42,
		&g_t2210043,
		439485442,
		&g_t3BF000D1,
		0x80200001,
		&g_tFE200008,
		0xE7,
		153354421,
		0x01B0834D,
		0x003401A9,
		&g_tFFF04F23,
		0x4F,
		33394416,
		&g_t4FB96F0,
		0x02,
		0x01013FF0,
		3052405144,
		2162683387,
		0x08,
		0x00,
	};
// 00008004: void FaultISR()
void FaultISR()
{
	while (true)
		;
}

// 00008008: void ResetISR(Register ptr32 cpsr)
void ResetISR(ptr32 cpsr)
{
	word32 * r3_16 = g_ptr802C;
	word32 * r0_5 = g_ptr8030;
	if (r3_16 < r0_5)
	{
		word32 * r2_13 = r3_16 + ((r0_5 + ~r3_16 & ~0x03) + 0x04);
		do
		{
			*r3_16 = 0x00;
			++r3_16;
		} while (r3_16 != r2_13);
	}
	Main(cpsr);
}

word32 * g_ptr802C = &g_dw20000160;
word32 * g_ptr8030 = &g_dw20000880;
// 00008034: void raise()
void raise()
{
	while (true)
		;
}

// 00008038: void vPrintTask(Register Eq_122 lr, Register ptr32 cpsr)
void vPrintTask(Eq_122 lr, ptr32 cpsr)
{
	ui32 r4_10 = 0x00;
	union Eq_2 * r5_11 = g_ptr8064;
	while (true)
	{
		lr = MPU_xQueueGenericReceive(*r5_11, fp - 20, ~0x00, 0x00, lr, cpsr);
		OSRAMClear();
		++r4_10;
		OSRAMStringDraw(dwLoc14, r4_10 & 0x3F, r4_10 & 0x01);
	}
}

union Eq_2 * g_ptr8064 = &g_t20000880;
// 00008068: void vCheckTask(Register Eq_122 lr, Register ptr32 cpsr)
void vCheckTask(Eq_122 lr, ptr32 cpsr)
{
	MPU_xTaskGetTickCount(cpsr);
	union Eq_2 * r5_20 = g_ptr809C;
	while (true)
	{
		MPU_vTaskDelayUntil(fp - 24, 5000, cpsr);
		lr = MPU_xQueueGenericSend(*r5_20, fp - 20, ~0x00, 0x00, lr, cpsr);
	}
}

union Eq_2 * g_ptr809C = &g_t20000880;
// 000080A0: void Main(Register ptr32 cpsr)
// Called from:
//      ResetISR
void Main(ptr32 cpsr)
{
	MPU_xQueueGenericCreate(0x03, 0x04, cpsr);
	*g_ptr80F0 = 0x03;
	OSRAMInit(0x00);
	MPU_xTaskCreate(g_dw80F8, g_dw80F4, 0x3B, 0x00, cpsr, 0x03, null);
	MPU_xTaskCreate(g_dw8100, g_dw80FC, 0x3B, 0x00, cpsr, 0x02, null);
	vTaskStartScheduler(cpsr);
	OSRAMStringDraw(g_ptr8104, 0x00, 0x00);
	while (true)
		;
}

word32 * g_ptr80F0 = &g_dw20000880;
word32 g_dw80F4 = 0xA258;
ui32 g_dw80F8 = 0x8069;
word32 g_dw80FC = 0xA260;
ui32 g_dw8100 = 0x8039;
byte * g_ptr8104 = &g_bA268;
// 00008108: void vUART_ISR(Register Eq_122 lr, Register ptr32 cpsr)
void vUART_ISR(Eq_122 lr, ptr32 cpsr)
{
	struct Eq_4521 * r5_13 = g_ptr8174;
	Eq_2 r0_18 = UARTIntStatus(r5_13, 0x01);
	UARTIntClear(r5_13, r0_18);
	if (r0_18 << 27 < 0x00 && *g_ptr8178 << 25 < 0x00)
		xQueueGenericSendFromISR(fp - 0x15, r0_18, fp - 20, 0x00, lr, cpsr);
	if (r0_18 << 26 < 0x00)
	{
		byte * r2_49 = g_ptr817C;
		up32 r3_50 = (word32) *r2_49;
		if (r3_50 <= 122)
		{
			ui32 r1_54 = *g_ptr8178;
			struct Eq_4521 * r1_55 = r1_54 << 26;
			if (r1_54 << 26 >= 0x00)
				r1_55 = g_ptr8174;
			r1_55->dw0000 = r3_50;
			*r2_49 = (byte) (r3_50 + 0x01);
		}
	}
}

struct Eq_4521 * g_ptr8174 = &g_t4000C000;
ui32 * g_ptr8178 = &g_dw4000C018;
byte * g_ptr817C = &g_b2000022C;
// 00008184: Register word32 vSetErrorLED(Register ptr32 cpsr)
// Called from:
//      prvSetAndCheckRegisters
word32 vSetErrorLED(ptr32 cpsr)
{
	return vParTestSetLED(0x07, 0x01, cpsr);
}

// 0000818C: Register word32 prvSetAndCheckRegisters(Register ptr32 cpsr, Register out ptr32 r4Out, Register out ptr32 r5Out, Register out ptr32 r6Out, Register out ptr32 r7Out, Register out ptr32 r8Out)
// Called from:
//      vApplicationIdleHook
word32 prvSetAndCheckRegisters(ptr32 cpsr, ptr32 & r4Out, ptr32 & r5Out, ptr32 & r6Out, ptr32 & r7Out, ptr32 & r8Out)
{
	r4Out = <invalid>;
	r5Out = <invalid>;
	r6Out = <invalid>;
	r7Out = <invalid>;
	r8Out = <invalid>;
	return 11;
}

// 00008210: void vApplicationIdleHook(Register (ptr32 Eq_1437) r0, Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 lr, Register ptr32 cpsr)
// Called from:
//      prvIdleTask
void vApplicationIdleHook(struct Eq_1437 * r0, word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 lr, ptr32 cpsr)
{
	while (true)
	{
		lr = vCoRoutineSchedule(r0, r4, r5, r6, r7, r8, lr, cpsr, out cpsr);
		r0 = prvSetAndCheckRegisters(cpsr, out r4, out r5, out r6, out r7, out r8);
	}
}

// 00008220: void PDCInit()
// Called from:
//      vParTestInitialise
void PDCInit()
{
	SysCtlPeripheralEnable(g_dw828C);
	SysCtlPeripheralEnable(g_dw8290);
	GPIODirModeSet((struct Eq_4655 *) 0x40004000, 0x34, 0x02);
	GPIODirModeSet((struct Eq_4655 *) 0x40004000, 0x08, 0x01);
	GPIOPadConfigSet((struct Eq_4669 *) 0x40004000, 0x04, 0x02, 0x0A);
	struct Eq_4678 * r5_55 = g_ptr8294;
	SSIConfig(r5_55, 0x00, 0x00, g_dw8298, 0x08);
	SSIEnable(r5_55);
	GPIOPinWrite((word32 (*)[]) 0x40004000, 0x08, 0x00);
	GPIOPinWrite((word32 (*)[]) 0x40004000, 0x08, 0x08);
}

uint32 g_dw828C = 0x10000010;
uint32 g_dw8290 = 0x20000001;
struct Eq_4678 * g_ptr8294 = &g_t40008000;
uint32 g_dw8298 = 1000000;
// 0000829C: Register (ptr32 Eq_4712) PDCWrite(Register (ptr32 Eq_4712) r0, Register ui32 r1)
// Called from:
//      vParTestInitialise
//      vParTestSetLED
//      vParTestToggleLED
struct Eq_4712 * PDCWrite(struct Eq_4712 * r0, ui32 r1)
{
	struct Eq_4712 * r4_12 = g_ptr82CC;
	SSIDataPut(r4_12, r0 & 0x0F);
	SSIDataPut(r4_12, r1);
	SSIDataGet(r4_12, fp - 20);
	SSIDataGet(r4_12, fp - 20);
	return r4_12;
}

struct Eq_4712 * g_ptr82CC = &g_t40008000;
// 000082D0: void vListInitialise(Register (ptr32 Eq_1099) r0)
// Called from:
//      xQueueGenericReset
//      prvAddNewTaskToReadyList
//      xEventGroupCreate
//      xCoRoutineCreate
void vListInitialise(struct Eq_1099 * r0)
{
	r0->dw0008 = ~0x00;
	r0->dw0000 = 0x00;
	r0->ptr0004 = &r0->dw0008;
	r0->ptr000C = &r0->dw0008;
	r0->ptr0010 = &r0->dw0008;
}

// 000082E8: void vListInitialiseItem(Register (ptr32 Eq_1261) r0)
// Called from:
//      prvInitialiseNewTask
//      xCoRoutineCreate
void vListInitialiseItem(struct Eq_1261 * r0)
{
	r0->dw0010 = 0x00;
}

// 000082F0: void vListInsertEnd(Register (ptr32 Eq_1437) r0, Register (ptr32 Eq_1438) r1)
// Called from:
//      prvAddNewTaskToReadyList
//      xTaskGenericNotify
//      xTaskGenericNotifyFromISR
//      vTaskNotifyGiveFromISR
//      xTaskIncrementTick
//      xTaskResumeAll
//      vTaskPlaceOnUnorderedEventList
//      xTaskRemoveFromEventList
//      xTaskRemoveFromUnorderedEventList
//      vTaskPriorityInherit
//      xTaskPriorityDisinherit
//      xCoRoutineCreate
//      vCoRoutineSchedule
//      xCoRoutineRemoveFromEventList
void vListInsertEnd(struct Eq_1437 * r0, struct Eq_1438 * r1)
{
	struct Eq_1438 * r3_6 = r0->ptr0004;
	word32 r2_5 = r0->dw0000;
	r1->ptr0008 = r3_6->ptr0008;
	struct Eq_1438 * r4_15 = r3_6->ptr0008;
	r1->ptr0004 = r3_6;
	r4_15->ptr0004 = r1;
	r3_6->ptr0008 = r1;
	r1->ptr0010 = r0;
	r0->dw0000 = r2_5 + 0x01;
}

// 0000830C: FlagGroup bool vListInsert(Register (ptr32 Eq_466) r0, Register (ptr32 Eq_1512) r1)
// Called from:
//      prvAddCurrentTaskToDelayedList.isra.0
//      vTaskPlaceOnEventList
//      vCoRoutineAddToDelayedList
bool vListInsert(struct Eq_466 * r0, struct Eq_1512 * r1)
{
	struct Eq_1512 * r2_13;
	struct Eq_1512 * r3_14;
	up32 r5_9 = r1->dw0000;
	if (!Z)
	{
		r2_13 = (struct Eq_1512 *) (&r0->dw0000 + 2);
		while (true)
		{
			r3_14 = r2_13->ptr0004;
			if (r5_9 < r3_14->dw0000)
				break;
			r2_13 = r3_14;
		}
	}
	else
	{
		r2_13 = r0->ptr0010;
		r3_14 = r2_13->ptr0004;
	}
	word32 r4_27 = r0->dw0000;
	r1->ptr0004 = r3_14;
	r3_14->ptr0008 = r1;
	r1->ptr0008 = r2_13;
	r2_13->ptr0004 = r1;
	r1->ptr0010 = r0;
	r0->dw0000 = r4_27 + 0x01;
	return SLICE(cond(r4_27 + 0x01), bool, 2);
}

// 00008340: Register (ptr32 Eq_1438) uxListRemove(Register (ptr32 Eq_1438) r0)
// Called from:
//      prvAddCurrentTaskToDelayedList.isra.0
//      xTaskGenericNotify
//      xTaskGenericNotifyFromISR
//      vTaskNotifyGiveFromISR
//      xTaskIncrementTick
//      xTaskResumeAll
//      xTaskRemoveFromEventList
//      xTaskRemoveFromUnorderedEventList
//      vTaskPriorityInherit
//      xTaskPriorityDisinherit
//      vCoRoutineAddToDelayedList
//      vCoRoutineSchedule
//      xCoRoutineRemoveFromEventList
struct Eq_1438 * uxListRemove(struct Eq_1438 * r0)
{
	struct Eq_1437 * r2_5 = r0->ptr0010;
	struct Eq_1438 * r3_6 = r0->ptr0004;
	r3_6->ptr0008 = r0->ptr0008;
	struct Eq_1438 * r4_12 = r2_5->ptr0004;
	struct Eq_1438 * r1_13 = r0->ptr0008;
	r1_13->ptr0004 = r3_6;
	if (r0 == r4_12)
		r2_5->ptr0004 = r1_13;
	word32 r3_21 = r2_5->dw0000;
	r0->ptr0010 = null;
	r2_5->dw0000 = r3_21 - 0x01;
	return r3_21 - 0x01;
}

// 00008364: FlagGroup bool xQueueCRSend(Register Eq_2 r0, Register Eq_2 r1, Register Eq_2 r2, Register Eq_2 r7, Register Eq_122 lr, Register ptr32 cpsr, Register out Eq_2 r0Out)
// Called from:
//      prvFixedDelayCoRoutine
bool xQueueCRSend(Eq_2 r0, Eq_2 r1, Eq_2 r2, Eq_2 r7, Eq_122 lr, ptr32 cpsr, union Eq_2 & r0Out)
{
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	vPortEnterCritical(cpsr);
	if (*((word32) r0 + 56) == *((word32) r0 + 60))
	{
		bool Z_33 = vPortExitCritical(cpsr);
		if (r2 != 0x00)
		{
			bool Z_43 = vCoRoutineAddToDelayedList(r2, (word32) r0 + 16);
			__msr(cpsr, 0x00);
			r0Out = ~0x03;
			return Z_43;
		}
		else
		{
			__msr(cpsr, r2);
			r0Out = r2;
			return Z_33;
		}
	}
	vPortExitCritical(cpsr);
	__msr(cpsr, 0x00);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_2 r2_65 = *((word32) r0 + 56);
	Eq_2 r3_66 = *((word32) r0 + 60);
	Eq_2 r0_136 = 0x00;
	bool Z_157 = SLICE(cond(r2_65 - r3_66), bool, 2);
	if (r2_65 < r3_66)
	{
		word32 r0_161;
		word32 r7_162;
		word32 lr_163;
		Z_157 = prvCopyDataToQueue(r0, r1, 0x00, r7, lr, out r0_161, out r7_162, out lr_163);
		if (*((word32) r0 + 36) != 0x00)
		{
			word32 r0_85;
			xCoRoutineRemoveFromEventList((word32) r0 + 36, out r0_85);
			Z_157 = SLICE(cond(r0_85), bool, 2);
			if (r0_85 != 0x00)
			{
				r0_136 = ~0x04;
				goto l000083AA;
			}
		}
		__msr(cpsr, 0x00);
		r0Out.u0 = 0x01;
		return Z_157;
	}
	else
	{
l000083AA:
		__msr(cpsr, 0x00);
		r0Out = r0_136;
		return Z_157;
	}
}

// 00008400: FlagGroup bool xQueueCRReceive(Register Eq_2 r0, Register Eq_2 r1, Register Eq_2 r2, Register Eq_2 r6, Register Eq_2 r7, Register Eq_122 lr, Register ptr32 cpsr, Register out Eq_2 r0Out, Register out Eq_2 r6Out, Register out Eq_2 r7Out, Register out Eq_122 lrOut)
// Called from:
//      prvFlashCoRoutine
bool xQueueCRReceive(Eq_2 r0, Eq_2 r1, Eq_2 r2, Eq_2 r6, Eq_2 r7, Eq_122 lr, ptr32 cpsr, union Eq_2 & r0Out, union Eq_2 & r6Out, union Eq_2 & r7Out, union Eq_122 & lrOut)
{
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_2 r5_16 = *((word32) r0 + 56);
	if (r5_16 == 0x00)
	{
		bool Z_105 = SLICE(cond(r2), bool, 2);
		if (r2 != 0x00)
		{
			bool Z_113 = vCoRoutineAddToDelayedList(r2, (word32) r0 + 36);
			__msr(cpsr, r5_16);
			r0Out = ~0x03;
			r6Out = r6;
			r7Out = r7;
			lrOut = lr;
			return Z_113;
		}
		else
		{
			__msr(cpsr, r2);
			r0Out = r2;
			r6Out = r6;
			r7Out = r7;
			lrOut = lr;
			return Z_105;
		}
	}
	Eq_2 r0_158;
	__msr(cpsr, 0x00);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	Eq_2 r2_19 = *((word32) r0 + 56);
	if (r2_19 != 0x00)
	{
		Eq_2 r1_30;
		Eq_122 r2_22 = *((word32) r0 + 64);
		Eq_2 r3_24 = *((word32) r0 + 4);
		word32 r1_25 = Mem11[r0 + 0x0C:word32] + r2_22;
		Eq_2 r3_27 = *((word32) r0 + 56);
		*((word32) r0 + 0x0C) = r1_25;
		r1_30 = r1_25;
		if (r1_25 >= r3_24)
			r1_30 = *r0;
		*((word32) r0 + 56) = (word32) r3_27 - 1;
		if (r1_25 >= r3_24)
			*((word32) r0 + 0x0C) = r1_30;
		struct Eq_5086 * r4_59;
		word32 r5_189;
		Z = memcpy(r1, r1_30, r2_22, r0, r5_16, r6, r7, lr, out r4_59, out r5_189, out r6, out r7, out lr);
		if (r4_59->dw0010 != 0x00)
		{
			word32 r0_70;
			xCoRoutineRemoveFromEventList(&r4_59->dw0010, out r0_70);
			Z = SLICE(cond(r0_70), bool, 2);
			if (r0_70 != 0x00)
			{
				r0_158 = ~0x04;
l00008440:
				__msr(cpsr, 0x00);
				r0Out = r0_158;
				r6Out = r6;
				r7Out = r7;
				lrOut = lr;
				return Z;
			}
		}
		__msr(cpsr, 0x00);
		r0Out.u0 = 0x01;
		r6Out = r6;
		r7Out = r7;
		lrOut = lr;
		return Z;
	}
	else
	{
		r0_158 = r2_19;
		goto l00008440;
	}
}

// 000084A0: void xQueueCRSendFromISR(Register Eq_2 r0, Register Eq_2 r1, Register word32 r2, Register Eq_2 r7, Register Eq_122 lr)
void xQueueCRSendFromISR(Eq_2 r0, Eq_2 r1, word32 r2, Eq_2 r7, Eq_122 lr)
{
	if (*((word32) r0 + 56) < *((word32) r0 + 60))
	{
		word32 lr_99;
		word32 r7_98;
		word32 r0_97;
		prvCopyDataToQueue(r0, r1, 0x00, r7, lr, out r0_97, out r7_98, out lr_99);
		if (r2 == 0x00 && *((word32) r0 + 36) != 0x00)
		{
			word32 r0_100;
			xCoRoutineRemoveFromEventList((word32) r0 + 36, out r0_100);
		}
	}
}

// 000084D4: void xQueueCRReceiveFromISR(Register Eq_2 r0, Register Eq_2 r1, Register Eq_2 r2)
void xQueueCRReceiveFromISR(Eq_2 r0, Eq_2 r1, Eq_2 r2)
{
	if (*((word32) r0 + 56) == 0x00)
		return;
	Eq_2 r3_38;
	Eq_122 lr_26 = *((word32) r0 + 64);
	Eq_2 r4_27 = *((word32) r0 + 4);
	word32 r3_28 = Mem15[r0 + 0x0C:word32] + lr_26;
	Eq_2 r7_35 = *((word32) r0 + 56);
	*((word32) r0 + 0x0C) = r3_28;
	r3_38 = r3_28;
	if (r3_28 >= r4_27)
		r3_38 = *r0;
	if (r3_28 >= r4_27)
		*((word32) r0 + 0x0C) = r3_38;
	*((word32) r0 + 56) = (word32) r7_35 - 1;
	word32 r6_153;
	struct Eq_5196 * r4_64;
	word32 * r5_65;
	word32 r7_154;
	word32 lr_155;
	memcpy(r1, r3_38, lr_26, r0, r2, r1, (word32) r7_35 - 1, lr_26, out r4_64, out r5_65, out r6_153, out r7_154, out lr_155);
	if (*r5_65 != 0x00 || r4_64->dw0010 == 0x00)
		return;
	word32 r0_75;
	xCoRoutineRemoveFromEventList(&r4_64->dw0010, out r0_75);
	if (r0_75 == 0x00)
		return;
	*r5_65 = 0x01;
}

// 0000852C: void prvIdleTask(Register (ptr32 Eq_1437) r0, Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 lr, Register ptr32 cpsr)
void prvIdleTask(struct Eq_1437 * r0, word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 lr, ptr32 cpsr)
{
	vApplicationIdleHook(r0, r4, r5, r6, r7, r8, lr, cpsr);
}

// 00008534: void xTaskNotifyStateClear(Register (ptr32 Eq_5244) r0, Register ptr32 cpsr)
// Called from:
//      MPU_xTaskNotifyStateClear
void xTaskNotifyStateClear(struct Eq_5244 * r0, ptr32 cpsr)
{
	struct Eq_5244 * r4_14;
	if (r0 != null)
		r4_14 = r0;
	else
		r4_14 = g_ptr8560->ptr0004;
	vPortEnterCritical(cpsr);
	word32 r3_26 = (word32) r4_14->b0064;
	if (r3_26 == 0x02)
		r3_26 = 0x00;
	r4_14->b0064 = (byte) r3_26;
	vPortExitCritical(cpsr);
}

struct Eq_5250 * g_ptr8560 = &g_t200000C4;
// 00008564: Register word32 xPortRaisePrivilege(Register ptr32 cpsr)
// Called from:
//      vPortEnterCritical
//      vPortExitCritical
//      MPU_xTaskCreateRestricted
//      MPU_xTaskCreate
//      MPU_vTaskAllocateMPURegions
//      MPU_vTaskDelayUntil
//      MPU_vTaskDelay
//      MPU_vTaskSuspendAll
//      MPU_xTaskResumeAll
//      MPU_xTaskGetTickCount
//      MPU_uxTaskGetNumberOfTasks
//      MPU_pcTaskGetName
//      MPU_vTaskSetTimeOutState
//      MPU_xTaskCheckForTimeOut
//      MPU_xTaskGenericNotify
//      MPU_xTaskNotifyWait
//      MPU_ulTaskNotifyTake
//      MPU_xTaskNotifyStateClear
//      MPU_xQueueGenericCreate
//      MPU_xQueueGenericReset
//      MPU_xQueueGenericSend
//      MPU_uxQueueMessagesWaiting
//      MPU_uxQueueSpacesAvailable
//      MPU_xQueueGenericReceive
//      MPU_xQueuePeekFromISR
//      MPU_xQueueGetMutexHolder
//      MPU_xQueueCreateMutex
//      MPU_xQueueTakeMutexRecursive
//      MPU_xQueueGiveMutexRecursive
//      MPU_vQueueDelete
//      MPU_pvPortMalloc
//      MPU_vPortFree
//      MPU_vPortInitialiseBlocks
//      MPU_xPortGetFreeHeapSize
//      MPU_xEventGroupCreate
//      MPU_xEventGroupWaitBits
//      MPU_xEventGroupClearBits
//      MPU_xEventGroupSetBits
//      MPU_xEventGroupSync
//      MPU_vEventGroupDelete
word32 xPortRaisePrivilege(ptr32 cpsr)
{
	(__mrs(cpsr) & 0x01) == 0x00;
	__syscall(0x02);
	return 0x01;
}

// 00008578: FlagGroup bool vPortEnterCritical(Register ptr32 cpsr)
// Called from:
//      prvUnlockQueue
//      xQueueGenericSend
//      xQueueGenericReceive
//      uxQueueMessagesWaiting
//      uxQueueSpacesAvailable
//      xQueueGetMutexHolder
//      xQueueGenericReset
//      prvAddNewTaskToReadyList
//      xTaskGenericNotify
//      xTaskNotifyWait
//      ulTaskNotifyTake
//      xTaskResumeAll
//      xTaskCheckForTimeOut
//      xEventGroupWaitBits
//      xEventGroupClearBits
//      xEventGroupSync
//      vEventGroupClearBitsCallback
//      xQueueCRSend
//      xTaskNotifyStateClear
bool vPortEnterCritical(ptr32 cpsr)
{
	ui32 r0_9 = xPortRaisePrivilege(cpsr);
	__msr(cpsr, 191);
	__isb_sy();
	__dsb_sy();
	word32 * r2_14 = g_ptr85AC;
	++*r2_14;
	bool C_30 = SLICE(cond(r0_9 - 0x01), bool, 1);
	if (r0_9 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return C_30;
}

word32 * g_ptr85AC = &g_dw200000BC;
// 000085B0: FlagGroup bool vPortExitCritical(Register ptr32 cpsr)
// Called from:
//      prvUnlockQueue
//      xQueueGenericSend
//      xQueueGenericReceive
//      uxQueueMessagesWaiting
//      uxQueueSpacesAvailable
//      xQueueGetMutexHolder
//      xQueueGenericReset
//      prvAddNewTaskToReadyList
//      xTaskGenericNotify
//      xTaskNotifyWait
//      ulTaskNotifyTake
//      xTaskResumeAll
//      xTaskCheckForTimeOut
//      xEventGroupWaitBits
//      xEventGroupClearBits
//      xEventGroupSync
//      vEventGroupClearBitsCallback
//      xQueueCRSend
//      xTaskNotifyStateClear
bool vPortExitCritical(ptr32 cpsr)
{
	ui32 r0_9 = xPortRaisePrivilege(cpsr);
	word32 * r2_13 = g_ptr85D8;
	word32 r3_14 = *r2_13;
	*r2_13 = r3_14 - 0x01;
	if (r3_14 == 0x01)
		__msr(cpsr, r3_14 - 0x01);
	bool Z_20 = SLICE(cond(r0_9 - 0x01), bool, 2);
	if (r0_9 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return Z_20;
}

word32 * g_ptr85D8 = &g_dw200000BC;
// 000085DC: void vParTestInitialise()
void vParTestInitialise()
{
	PDCInit();
	ui32 r1_18 = (word32) *g_ptr85F0;
	PDCWrite(&g_dw0005, r1_18);
}

byte * g_ptr85F0 = &g_b200007F4;
// 000085F4: Register up32 vParTestSetLED(Register up32 r0, Register word32 r1, Register ptr32 cpsr)
// Called from:
//      vSetErrorLED
up32 vParTestSetLED(up32 r0, word32 r1, ptr32 cpsr)
{
	up32 r0_17 = MPU_vTaskSuspendAll(cpsr);
	if (r0 <= 0x07)
	{
		byte * r3_28 = g_ptr862C;
		uint32 r0_29 = (uint32) (byte) (0x01 << r0);
		ui32 r2_30 = (word32) *r3_28;
		if (r1 != 0x00)
			*r3_28 = (byte) (r0_29 | r2_30);
		else
			*r3_28 = (byte) (r2_30 & ~r0_29);
		r0_17 = PDCWrite(&g_dw0005, (word32) *r3_28);
	}
	MPU_xTaskResumeAll(cpsr);
	return r0_17;
}

byte * g_ptr862C = &g_b200007F4;
// 00008630: void vParTestToggleLED(Register up32 r0, Register ptr32 cpsr)
// Called from:
//      prvFlashCoRoutine
void vParTestToggleLED(up32 r0, ptr32 cpsr)
{
	MPU_vTaskSuspendAll(cpsr);
	if (r0 <= 0x07)
	{
		byte * r3_21 = g_ptr866C;
		ui32 r0_22 = 0x01 << r0;
		uint32 r2_26 = (uint32) (byte) r0_22 + (word32) (*r3_21) + (r0 < 0x07);
		if (r2_26 == 0x00)
			*r3_21 = (byte) (r2_26 | (word32) (*r3_21));
		else
			*r3_21 = (byte) ((word32) *r3_21 & ~r0_22);
		PDCWrite(&g_dw0005, (word32) *r3_21);
	}
	MPU_xTaskResumeAll(cpsr);
}

byte * g_ptr866C = &g_b200007F4;
// 00008670: void prvFlashCoRoutine(Register (ptr32 Eq_5460) r0, Register Eq_2 r7, Register Eq_122 lr, Register ptr32 cpsr)
void prvFlashCoRoutine(struct Eq_5460 * r0, Eq_2 r7, Eq_122 lr, ptr32 cpsr)
{
	union Eq_2 * r5_107;
	Eq_2 r6_105;
	word32 r0_26;
	word32 r3_13 = (word32) r0->w0034;
	if (r3_13 != 0x01C2)
	{
		if (r3_13 == 0x01C3)
		{
			r5_107 = g_ptr86E0;
			r6_105 = fp - 20;
			goto l00008690;
		}
		if (r3_13 != 0x00)
			return;
		r5_107 = g_ptr86E0;
		r6_105 = fp - 20;
l00008696:
		bool Z_59 = xQueueCRReceive(*r5_107, r6_105, ~0x00, r6_105, r7, lr, cpsr, out r0_26, out r6_105, out r7, out lr);
		if (Z_59)
		{
			r0->w0034 = 0x01C2;
			return;
		}
		if (!Z_59)
		{
l000086AA:
			if (r0_26 != 0x01)
			{
				*g_ptr86E4 = 0x00;
				goto l00008696;
			}
l00008690:
			vParTestToggleLED(dwLoc14, cpsr);
			goto l00008696;
		}
	}
	else
	{
		r5_107 = g_ptr86E0;
		if (xQueueCRReceive(*r5_107, fp - 20, 0x00, fp - 20, r7, lr, cpsr, out r0_26, out r6_105, out r7, out lr))
			goto l000086AA;
	}
	r0->w0034 = 0x01C3;
}

Eq_1053 g_t8671 = 
	{
		&g_t828E83B5,
		3790975920,
		&g_t1B46047F,
		3287433424,
		&g_t2429312,
		0x14BD70B0,
		&g_tFFF04FFF,
		2952265576,
		&g_t181D02FE,
		0x43D0,
		0xF02801D0,
		0x0C2200D0,
		4016052811,
		&g_t14D0AE7,
		0x0A,
		0xFF220046,
		&g_t43FE9EF7,
		0xD1,
		0xA313C3F2,
		0x70B00286,
		21824445,
		~0x51,
		222,
	};
union Eq_2 * g_ptr86E0 = &g_t200007F8;
word32 * g_ptr86E4 = &g_dw200000C0;
// 000086E8: void prvFixedDelayCoRoutine(Register (ptr32 Eq_5534) r0, Register ui32 r1, Register Eq_2 r7, Register Eq_122 lr, Register ptr32 cpsr)
void prvFixedDelayCoRoutine(struct Eq_5534 * r0, ui32 r1, Eq_2 r7, Eq_122 lr, ptr32 cpsr)
{
	bool v18_111;
	Eq_2 r0_81;
	word32 r0_22;
	up32 r3_9 = (word32) r0->w0034;
	if (r3_9 != 0x0182)
	{
		if (r3_9 > 0x0182)
		{
			if (r3_9 == 0x0183)
				goto l00008702;
			if (r3_9 != 0x0196)
				return;
		}
		else if (r3_9 != 0x00)
			return;
		v18_111 = xQueueCRSend(*g_ptr877C, fp - 0x0C, 0x00, r7, lr, cpsr, out r0_22);
		if (v18_111)
		{
			r0->w0034 = 0x0182;
			return;
		}
	}
	else
		v18_111 = xQueueCRSend(*g_ptr877C, fp - 0x0C, 0x00, r7, lr, cpsr, out r0_22);
	if (v18_111)
	{
		r0->w0034 = 0x0183;
		return;
	}
	if (r0_22 != 0x01)
	{
		*g_ptr8780 = 0x00;
		r0_81 = g_ptr8778[r1];
		if (r0_81 == 0x00)
		{
l0000870C:
			r0->w0034 = 0x0196;
			return;
		}
l0000875E:
		vCoRoutineAddToDelayedList(r0_81, null);
		goto l0000870C;
	}
l00008702:
	r0_81 = g_ptr8778[r1];
	if (r0_81 == 0x00)
		goto l0000870C;
	goto l0000875E;
}

Eq_1053 g_t86E9 = 
	{
		&g_t828E83B5,
		~0x3E0A4C4F,
		&g_t146047F,
		0x26D02B91,
		&g_t83F240D9,
		0x014B1DD1,
		&g_tA373CBF4,
		3421877181,
		&g_t17D1FA7F,
		0x4B,
		4289266024,
		50208503,
		1137713181,
		&g_t1D01A1D,
		0x1A,
		0x1A4B1222,
		&g_t14B0F60,
		~0x07,
		0xE2280000,
		0x00E00AD0,
		0x02D0E72B,
		0xB0,
		0x10,
	};
Eq_2 (* g_ptr8778)[] = &g_aA284;
union Eq_2 * g_ptr877C = &g_t200007F8;
word32 * g_ptr8780 = &g_dw200000C0;
// 00008784: void vStartFlashCoRoutines(Register (ptr32 Eq_1053) r0, Register ptr32 cpsr)
void vStartFlashCoRoutines(struct Eq_1053 * r0, ptr32 cpsr)
{
	if (r0 >= &g_t0008)
		r0 = &g_t0008;
	MPU_xQueueGenericCreate(0x01, 0x04, cpsr);
	*g_ptr87C4 = 0x01;
	if (r0 != null)
	{
		struct Eq_1053 * r4_40 = null;
		struct Eq_1053 * r6_41 = g_ptr87C8;
		do
		{
			xCoRoutineCreate(r6_41, 0x00, r4_40, cpsr);
			r4_40 = (struct Eq_1053 *) ((char *) &r4_40->ptr0000 + 1);
		} while (r4_40 != r0);
	}
	struct Eq_1053 * r0_71 = g_ptr87CC;
	xCoRoutineCreate(r0_71, 0x01, null, cpsr);
}

word32 * g_ptr87C4 = &g_dw200007F8;
struct Eq_1053 * g_ptr87C8 = &g_t86E9;
struct Eq_1053 * g_ptr87CC = &g_t8671;
// 000087D0: void xAreFlashCoRoutinesStillRunning()
void xAreFlashCoRoutinesStillRunning()
{
}

// 000087DC: void MPU_xTaskCreateRestricted(Register (ptr32 Eq_1573) r0, Register (ptr32 (ptr32 Eq_1053)) r1, Register ptr32 cpsr)
void MPU_xTaskCreateRestricted(struct Eq_1573 * r0, struct Eq_1053 ** r1, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	xTaskCreateRestricted(r0, r1, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008808: void MPU_xTaskCreate(Register ui32 r0, Register word32 r1, Register ui32 r2, Register word32 r3, Register ptr32 cpsr, Stack int32 dwArg00, Stack (ptr32 (ptr32 Eq_1053)) dwArg04)
// Called from:
//      ResetISR
void MPU_xTaskCreate(ui32 r0, word32 r1, ui32 r2, word32 r3, ptr32 cpsr, int32 dwArg00, struct Eq_1053 ** dwArg04)
{
	ui32 r0_32 = xPortRaisePrivilege(cpsr);
	xTaskCreate(r0, r1, r2, r3, cpsr, dwArg00, dwArg04);
	if (r0_32 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000884C: void MPU_vTaskAllocateMPURegions(Register word32 r0, Register (ptr32 Eq_1197) r1, Register ptr32 cpsr)
void MPU_vTaskAllocateMPURegions(word32 r0, struct Eq_1197 * r1, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	vTaskAllocateMPURegions(r0, r1);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008874: void MPU_vTaskDelayUntil(Register (ptr32 up32) r0, Register word32 r1, Register ptr32 cpsr)
// Called from:
//      vCheckTask
void MPU_vTaskDelayUntil(up32 * r0, word32 r1, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	vTaskDelayUntil(r0, r1, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000889C: void MPU_vTaskDelay(Register up32 r0, Register ptr32 cpsr)
void MPU_vTaskDelay(up32 r0, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	vTaskDelay(r0, cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000088C0: Register ui32 MPU_vTaskSuspendAll(Register ptr32 cpsr)
// Called from:
//      vParTestSetLED
//      vParTestToggleLED
ui32 MPU_vTaskSuspendAll(ptr32 cpsr)
{
	ui32 r0_23 = xPortRaisePrivilege(cpsr);
	vTaskSuspendAll();
	if (r0_23 != 0x01)
	{
		Eq_2 r0_22 = __mrs(cpsr);
		__msr(cpsr, r0_22 | 0x01);
		r0_23 = r0_22 | 0x01;
	}
	return r0_23;
}

// 000088E0: void MPU_xTaskResumeAll(Register ptr32 cpsr)
// Called from:
//      vParTestSetLED
//      vParTestToggleLED
void MPU_xTaskResumeAll(ptr32 cpsr)
{
	ui32 r0_9 = xPortRaisePrivilege(cpsr);
	xTaskResumeAll(cpsr);
	if (r0_9 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008904: void MPU_xTaskGetTickCount(Register ptr32 cpsr)
// Called from:
//      vCheckTask
//      vCoRoutineSchedule
void MPU_xTaskGetTickCount(ptr32 cpsr)
{
	ui32 r0_9 = xPortRaisePrivilege(cpsr);
	xTaskGetTickCount();
	if (r0_9 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008928: void MPU_uxTaskGetNumberOfTasks(Register ptr32 cpsr)
void MPU_uxTaskGetNumberOfTasks(ptr32 cpsr)
{
	ui32 r0_9 = xPortRaisePrivilege(cpsr);
	uxTaskGetNumberOfTasks();
	if (r0_9 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 0000894C: void MPU_pcTaskGetName(Register word32 r0, Register ptr32 cpsr)
void MPU_pcTaskGetName(word32 r0, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	pcTaskGetName(r0);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008974: void MPU_vTaskSetTimeOutState(Register (ptr32 Eq_391) r0, Register ptr32 cpsr)
void MPU_vTaskSetTimeOutState(struct Eq_391 * r0, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	vTaskSetTimeOutState(r0);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008998: void MPU_xTaskCheckForTimeOut(Register (ptr32 Eq_432) r0, Register (ptr32 up32) r1, Register ptr32 cpsr)
void MPU_xTaskCheckForTimeOut(struct Eq_432 * r0, up32 * r1, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	xTaskCheckForTimeOut(r0, r1, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000089C4: void MPU_xTaskGenericNotify(Register (ptr32 Eq_1722) r0, Register ui32 r1, Register up32 r2, Register (ptr32 ui32) r3, Register ptr32 cpsr)
void MPU_xTaskGenericNotify(struct Eq_1722 * r0, ui32 r1, up32 r2, ui32 * r3, ptr32 cpsr)
{
	ui32 r0_25 = xPortRaisePrivilege(cpsr);
	xTaskGenericNotify(r0, r1, r2, r3, cpsr);
	if (r0_25 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 000089FC: void MPU_xTaskNotifyWait(Register word32 r0, Register word32 r1, Register (ptr32 ui32) r2, Register up32 r3, Register ptr32 cpsr)
void MPU_xTaskNotifyWait(word32 r0, word32 r1, ui32 * r2, up32 r3, ptr32 cpsr)
{
	ui32 r0_25 = xPortRaisePrivilege(cpsr);
	xTaskNotifyWait(r0, r1, r2, r3, cpsr);
	if (r0_25 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A34: void MPU_ulTaskNotifyTake(Register word32 r0, Register up32 r1, Register ptr32 cpsr)
void MPU_ulTaskNotifyTake(word32 r0, up32 r1, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	ulTaskNotifyTake(r0, r1, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A60: void MPU_xTaskNotifyStateClear(Register (ptr32 Eq_5244) r0, Register ptr32 cpsr)
void MPU_xTaskNotifyStateClear(struct Eq_5244 * r0, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	xTaskNotifyStateClear(r0, cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008A88: void MPU_xQueueGenericCreate(Register ui32 r0, Register ui32 r1, Register ptr32 cpsr)
// Called from:
//      ResetISR
//      vStartFlashCoRoutines
void MPU_xQueueGenericCreate(ui32 r0, ui32 r1, ptr32 cpsr)
{
	ui32 r0_23 = xPortRaisePrivilege(cpsr);
	xQueueGenericCreate(r0, r1, cpsr);
	if (r0_23 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008AB8: void MPU_xQueueGenericReset(Register (ptr32 Eq_1053) r0, Register word32 r1, Register ptr32 cpsr)
void MPU_xQueueGenericReset(struct Eq_1053 * r0, word32 r1, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	xQueueGenericReset(r0, r1, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008AE4: Register Eq_122 MPU_xQueueGenericSend(Register Eq_2 r0, Register Eq_2 r1, Register up32 r2, Register Eq_2 r3, Register Eq_122 lr, Register ptr32 cpsr)
// Called from:
//      vCheckTask
Eq_122 MPU_xQueueGenericSend(Eq_2 r0, Eq_2 r1, up32 r2, Eq_2 r3, Eq_122 lr, ptr32 cpsr)
{
	ui32 r0_25 = xPortRaisePrivilege(cpsr);
	Eq_122 lr_34 = xQueueGenericSend(r0, r1, r2, r3, lr, cpsr);
	if (r0_25 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return lr_34;
}

// 00008B1C: void MPU_uxQueueMessagesWaiting(Register ptr32 cpsr)
void MPU_uxQueueMessagesWaiting(ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	uxQueueMessagesWaiting(cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008B44: void MPU_uxQueueSpacesAvailable(Register ptr32 cpsr)
void MPU_uxQueueSpacesAvailable(ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	uxQueueSpacesAvailable(cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008B6C: Register Eq_122 MPU_xQueueGenericReceive(Register Eq_2 r0, Register Eq_2 r1, Register up32 r2, Register word32 r3, Register Eq_122 lr, Register ptr32 cpsr)
// Called from:
//      vPrintTask
Eq_122 MPU_xQueueGenericReceive(Eq_2 r0, Eq_2 r1, up32 r2, word32 r3, Eq_122 lr, ptr32 cpsr)
{
	ui32 r0_25 = xPortRaisePrivilege(cpsr);
	Eq_122 lr_34;
	xQueueGenericReceive(r0, r1, r2, r3, lr, cpsr, out lr_34);
	if (r0_25 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
	return lr_34;
}

// 00008BA4: void MPU_xQueuePeekFromISR(Register Eq_2 r0, Register Eq_2 r1, Register Eq_2 r7, Register Eq_122 lr, Register ptr32 cpsr)
void MPU_xQueuePeekFromISR(Eq_2 r0, Eq_2 r1, Eq_2 r7, Eq_122 lr, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	xQueuePeekFromISR(r0, r1, r7, lr, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008BD0: void MPU_xQueueGetMutexHolder(Register (ptr32 word32) r0, Register ptr32 cpsr)
void MPU_xQueueGetMutexHolder(word32 * r0, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	xQueueGetMutexHolder(r0, cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008BF8: void MPU_xQueueCreateMutex(Register Eq_122 lr, Register ptr32 cpsr)
void MPU_xQueueCreateMutex(Eq_122 lr, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	xQueueCreateMutex(lr, cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C20: void MPU_xQueueTakeMutexRecursive(Register Eq_2 r0, Register up32 r1, Register Eq_122 lr, Register ptr32 cpsr)
void MPU_xQueueTakeMutexRecursive(Eq_2 r0, up32 r1, Eq_122 lr, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	xQueueTakeMutexRecursive(r0, r1, lr, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C4C: void MPU_xQueueGiveMutexRecursive(Register Eq_2 r0, Register Eq_122 lr, Register ptr32 cpsr)
void MPU_xQueueGiveMutexRecursive(Eq_2 r0, Eq_122 lr, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	xQueueGiveMutexRecursive(r0, lr, cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C74: void MPU_vQueueDelete(Register ptr32 cpsr)
void MPU_vQueueDelete(ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	vQueueDelete();
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008C98: void MPU_pvPortMalloc(Register ui32 r0, Register ptr32 cpsr)
void MPU_pvPortMalloc(ui32 r0, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	pvPortMalloc(r0, cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008CC0: void MPU_vPortFree(Register ptr32 cpsr)
void MPU_vPortFree(ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	vPortFree();
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008CE4: void MPU_vPortInitialiseBlocks(Register ptr32 cpsr)
void MPU_vPortInitialiseBlocks(ptr32 cpsr)
{
	ui32 r0_9 = xPortRaisePrivilege(cpsr);
	vPortInitialiseBlocks();
	if (r0_9 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D04: void MPU_xPortGetFreeHeapSize(Register ptr32 cpsr)
void MPU_xPortGetFreeHeapSize(ptr32 cpsr)
{
	ui32 r0_9 = xPortRaisePrivilege(cpsr);
	xPortGetFreeHeapSize();
	if (r0_9 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D28: void MPU_xEventGroupCreate(Register ptr32 cpsr)
void MPU_xEventGroupCreate(ptr32 cpsr)
{
	ui32 r0_9 = xPortRaisePrivilege(cpsr);
	xEventGroupCreate(cpsr);
	if (r0_9 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D4C: void MPU_xEventGroupWaitBits(Register (ptr32 ui32) r0, Register ui32 r1, Register word32 r2, Register word32 r3, Register ptr32 cpsr, Stack up32 dwArg00)
void MPU_xEventGroupWaitBits(ui32 * r0, ui32 r1, word32 r2, word32 r3, ptr32 cpsr, up32 dwArg00)
{
	ui32 r0_29 = xPortRaisePrivilege(cpsr);
	xEventGroupWaitBits(r0, r1, r2, r3, cpsr, dwArg00);
	if (r0_29 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008D8C: void MPU_xEventGroupClearBits(Register (ptr32 ui32) r0, Register word32 r1, Register ptr32 cpsr)
void MPU_xEventGroupClearBits(ui32 * r0, word32 r1, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	xEventGroupClearBits(r0, r1, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008DB8: void MPU_xEventGroupSetBits(Register (ptr32 Eq_4153) r0, Register ui32 r1, Register ptr32 cpsr)
void MPU_xEventGroupSetBits(struct Eq_4153 * r0, ui32 r1, ptr32 cpsr)
{
	ui32 r0_17 = xPortRaisePrivilege(cpsr);
	xEventGroupSetBits(r0, r1, cpsr);
	if (r0_17 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008DE4: void MPU_xEventGroupSync(Register (ptr32 Eq_4153) r0, Register ui32 r1, Register ui32 r2, Register up32 r3, Register ptr32 cpsr)
void MPU_xEventGroupSync(struct Eq_4153 * r0, ui32 r1, ui32 r2, up32 r3, ptr32 cpsr)
{
	ui32 r0_25 = xPortRaisePrivilege(cpsr);
	xEventGroupSync(r0, r1, r2, r3, cpsr);
	if (r0_25 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008E1C: void MPU_vEventGroupDelete(Register (ptr32 Eq_4316) r0, Register ptr32 cpsr)
void MPU_vEventGroupDelete(struct Eq_4316 * r0, ptr32 cpsr)
{
	ui32 r0_15 = xPortRaisePrivilege(cpsr);
	vEventGroupDelete(r0, cpsr);
	if (r0_15 != 0x01)
		__msr(cpsr, __mrs(cpsr) | 0x01);
}

// 00008E40: void xCoRoutineCreate(Register (ptr32 Eq_1053) r0, Register uint32 r1, Register (ptr32 Eq_1053) r2, Register ptr32 cpsr)
// Called from:
//      vStartFlashCoRoutines
void xCoRoutineCreate(struct Eq_1053 * r0, uint32 r1, struct Eq_1053 * r2, ptr32 cpsr)
{
	uint32 r5_28 = r1;
	struct Eq_1053 * r0_32 = pvPortMalloc(0x38, cpsr);
	if (r0_32 == null)
		return;
	struct Eq_6268 * r7_53 = g_ptr8EEC;
	if (r7_53->ptr0000 == null)
	{
		r7_53->ptr0000 = r0_32;
		vListInitialise((char *) &r7_53->ptr0000 + 4);
		vListInitialise((char *) &r7_53->ptr0000 + 24);
		vListInitialise((char *) &r7_53->ptr0000 + 44);
		vListInitialise((char *) &r7_53->ptr0000 + 64);
		vListInitialise((char *) &r7_53->ptr0000 + 84);
		r7_53->ptr0068 = (char *) &r7_53->ptr0000 + 44;
		r7_53->ptr006C = (char *) &r7_53->ptr0000 + 64;
	}
	if (r1 >= 0x01)
		r5_28 = 0x01;
	r0_32->w0034 = 0x00;
	r0_32->dw002C = r5_28;
	r0_32->ptr0030 = r2;
	r0_32->ptr0000 = r0;
	vListInitialiseItem(&r0_32->dw0004);
	vListInitialiseItem(&r0_32->dw0018);
	uint32 r0_106 = r0_32->dw002C;
	word32 r5_110 = 0x02 - r5_28;
	if (r0_106 > r7_53->dw0070)
		r7_53->dw0070 = r0_106;
	r0_32->dw0018 = r5_110;
	r0_32->ptr0010 = r0_32;
	r0_32->ptr0024 = r0_32;
	vListInsertEnd((char *) &r7_53->ptr0000 + 4 + r0_106 * 0x14, &r0_32->dw0004);
}

struct Eq_6268 * g_ptr8EEC = &g_t200007FC;
// 00008EF0: FlagGroup bool vCoRoutineAddToDelayedList(Register Eq_2 r0, Register (ptr32 Eq_466) r1)
// Called from:
//      xQueueCRSend
//      xQueueCRReceive
//      prvFixedDelayCoRoutine
bool vCoRoutineAddToDelayedList(Eq_2 r0, struct Eq_466 * r1)
{
	struct Eq_6363 * r4_14 = g_ptr8F28;
	up32 r5_18 = (word32) r0 + r4_14->dw0074;
	uxListRemove(&r4_14->ptr0000->dw0004);
	up32 r3_29 = r4_14->dw0074;
	struct Eq_6374 * r1_30 = r4_14->ptr0000;
	r1_30->dw0004 = r5_18;
	bool Z_44 = vListInsert(r4_14->ptr0068, &r1_30->dw0004);
	if (r1 == null)
		return Z_44;
	struct Eq_6374 * r1_53 = r4_14->ptr0000;
	return vListInsert(r1, &r1_53->dw0004 + 5);
}

struct Eq_6363 * g_ptr8F28 = &g_t200007FC;
// 00008F2C: Register word32 vCoRoutineSchedule(Register (ptr32 Eq_1437) r0, Register word32 r4, Register word32 r5, Register word32 r6, Register word32 r7, Register word32 r8, Register word32 lr, Register ptr32 cpsr, Register out ptr32 cpsrOut)
// Called from:
//      vApplicationIdleHook
word32 vCoRoutineSchedule(struct Eq_1437 * r0, word32 r4, word32 r5, word32 r6, word32 r7, word32 r8, word32 lr, ptr32 cpsr, ptr32 & cpsrOut)
{
	struct Eq_6408 * r5_16 = g_ptr9088;
	while (r5_16->dw0054 != 0x00)
	{
		__msr(cpsr, 191);
		__isb_sy();
		__dsb_sy();
		struct Eq_6434 * r4_25 = r5_16->ptr0060->ptr000C;
		uxListRemove((char *) r4_25 + 24);
		__msr(cpsr, 0x00);
		uxListRemove((char *) r4_25 + 4);
		uint32 r3_46 = r4_25->dw002C;
		r0 = (struct Eq_1437 *) ((char *) &r5_16->ptr0000 + 4 + r3_46 * 0x14);
		if (r3_46 > r5_16->dw0070)
			r5_16->dw0070 = r3_46;
		vListInsertEnd(r0, (char *) r4_25 + 4);
	}
	MPU_xTaskGetTickCount(cpsr);
	up32 r3_171 = r5_16->dw0074;
	word32 r0_179 = r0 - r5_16->dw0078;
	word32 r8_84 = g_dw9090;
	r5_16->dw007C = r0_179;
l00008F94:
	while (r0_179 != 0x00)
	{
		struct Eq_6466 * r2_102;
		++r3_171;
		r5_16->dw0074 = r3_171;
		--r0_179;
		r5_16->dw007C = r0_179;
		if (r3_171 != 0x00)
			r2_102 = r5_16->ptr0068;
		else
		{
			r2_102 = r5_16->ptr006C;
			r5_16->ptr006C = r5_16->ptr0068;
			r5_16->ptr0068 = r2_102;
		}
		if (r2_102->dw0000 == 0x00)
			goto l00008F94;
		struct Eq_6496 * r4_109 = r2_102->ptr000C->ptr000C;
		if (r3_171 < r4_109->dw0004)
			goto l00008F94;
		do
		{
			__msr(cpsr, 191);
			__isb_sy();
			__dsb_sy();
			struct Eq_1438 * r6_117 = &r4_109->dw0004;
			uxListRemove(r6_117);
			struct Eq_1438 * r0_129 = &r4_109->dw0004 + 5;
			if (r4_109->dw0028 != 0x00)
				uxListRemove(r0_129);
			__msr(cpsr, 0x00);
			uint32 r3_143 = r4_109->dw002C;
			struct Eq_1437 * r0_153 = r8_84 + r3_143 * 0x14;
			if (r3_143 > r5_16->dw0070)
				r5_16->dw0070 = r3_143;
			vListInsertEnd(r0_153, r6_117);
			struct Eq_6466 * r3_166 = r5_16->ptr0068;
			if (r3_166->dw0000 == 0x00)
			{
				r3_171 = r5_16->dw0074;
				break;
			}
			r4_109 = r3_166->ptr000C->ptr000C;
			r3_171 = r5_16->dw0074;
		} while (r4_109->dw0004 <= r3_171);
		r0_179 = r5_16->dw007C;
	}
	uint32 r2_197;
	uint32 r1_186 = r5_16->dw0070;
	r5_16->dw0078 = r3_171;
	ui32 r3_191 = r1_186 << 2;
	if (*((char *) &(r5_16 + (r1_186 * 0x14) / 0x0080)->ptr0000 + 4) == 0x00)
	{
		if (r1_186 == 0x00)
		{
			cpsrOut = cpsr;
			return lr;
		}
		r3_191 = r1_186 - 0x01 << 2;
		r2_197 = r1_186 - 0x01;
		if (*((char *) &(r5_16 + (r3_191 + (r1_186 - 0x01) << 0x02) / 0x0080)->ptr0000 + 4) == 0x00)
		{
			if (r1_186 == 0x01)
			{
l00009046:
				r5_16->dw0070 = r2_197;
				cpsrOut = cpsr;
				return lr;
			}
			r3_191 = r1_186 - 0x02 << 2;
			r2_197 = r1_186 - 0x02;
			if (*((char *) &(r5_16 + (r3_191 + (r1_186 - 0x02) << 0x02) / 0x0080)->ptr0000 + 4) == 0x00)
				goto l00009046;
		}
		r5_16->dw0070 = r2_197;
	}
	else
		r2_197 = r1_186;
	struct Eq_6660 * r2_242;
	ui32 r3_230 = r3_191 + r2_197;
	struct Eq_6679 * r1_233 = r5_16 + (r3_230 << 2) / 0x0080;
	struct Eq_6660 * r2_237 = r1_233->ptr0008->ptr0004;
	struct Eq_6660 * r3_238 = (r3_230 << 2) + g_dw908C;
	r1_233->ptr0008 = r2_237;
	r2_242 = r2_237;
	if (r2_237 == r3_238)
		r2_242 = r2_237->ptr0004;
	<anonymous> ** r0_245 = r2_242->ptr000C;
	if (r2_237 == r3_238)
		r1_233->ptr0008 = r2_242;
	r5_16->ptr0000 = r0_245;
	word32 lr_280;
	word32 pc_281;
	ptr32 cpsr_283;
	(*r0_245)();
	cpsrOut = cpsr_283;
	return lr_280;
}

struct Eq_6408 * g_ptr9088 = &g_t200007FC;
word32 g_dw908C = 0x20000808;
word32 g_dw9090 = 0x20000800;
// 00009094: FlagGroup bool xCoRoutineRemoveFromEventList(Register (ptr32 Eq_4981) r0, Register out ptr32 r0Out)
// Called from:
//      xQueueCRSend
//      xQueueCRReceive
//      xQueueCRSendFromISR
//      xQueueCRReceiveFromISR
bool xCoRoutineRemoveFromEventList(struct Eq_4981 * r0, ptr32 & r0Out)
{
	struct Eq_6703 * r4_15 = r0->ptr000C->ptr000C;
	struct Eq_6729 ** r5_16 = g_ptr90C0;
	uxListRemove((char *) r4_15 + 24);
	vListInsertEnd((char *) r5_16 + 84, (char *) r4_15 + 24);
	up32 r0_36 = r4_15->dw002C;
	up32 r3_37 = *((char *) *r5_16 + 44);
	bool Z_64 = SLICE(cond(r0_36 - r3_37), bool, 2);
	r0Out = 0x01;
	return Z_64;
}

struct Eq_6729 ** g_ptr90C0 = &g_ptr200007FC;
// 000090C4: void GPIOGetIntNumber(Register up32 r0)
void GPIOGetIntNumber(up32 r0)
{
	up32 r3_4 = g_dw9104;
	if (r0 == r3_4)
		return;
	if (r0 > r3_4)
	{
		up32 r3_10 = g_dw9108;
		if (r0 == r3_10)
			return;
		if (r0 != r3_10 + 0x0001D000)
			;
	}
	else
	{
		if (r0 == 0x40004000)
			return;
		if (r0 != r3_4 - 0x1000)
			;
	}
}

up32 g_dw9104 = 0x40006000;
up32 g_dw9108 = 0x40007000;
// 0000910C: void GPIODirModeSet(Register (ptr32 Eq_4655) r0, Register ui32 r1, Register ui32 r2)
// Called from:
//      PDCInit
void GPIODirModeSet(struct Eq_4655 * r0, ui32 r1, ui32 r2)
{
	ui32 r3_10 = r0->dw0400;
	if ((r2 & 0x01) != 0x00)
		r3_10 |= r1;
	r0->dw0400 = r3_10 & ~r1;
	ui32 r3_16 = r0->dw0420;
	if (r2 << 30 < 0x00)
		r1 |= r3_16;
	r0->dw0420 = r3_16 & ~r1;
}

// 00009134: void GPIODirModeGet(Register (ptr32 Eq_6785) r0, Register word32 r1)
void GPIODirModeGet(struct Eq_6785 * r0, word32 r1)
{
	uint32 r1_11 = (uint32) (byte) (0x01 << r1);
	word32 r2_12 = r0->dw0420;
	up32 r4_14 = (bool) C + (r0->dw0400 + r1_11);
}

// 0000915C: void GPIOIntTypeSet(Register (ptr32 Eq_6811) r0, Register ui32 r1, Register ui32 r2)
void GPIOIntTypeSet(struct Eq_6811 * r0, ui32 r1, ui32 r2)
{
	ui32 r3_10 = r0->dw0408;
	if ((r2 & 0x01) != 0x00)
		r3_10 |= r1;
	r0->dw0408 = r3_10 & ~r1;
	ui32 r3_16 = r0->dw0404;
	if ((r2 & 0x02) != 0x00)
		r3_16 |= r1;
	r0->dw0404 = r3_16 & ~r1;
	ui32 r3_26 = r0->dw040C;
	if (r2 << 29 < 0x00)
		r1 |= r3_26;
	r0->dw040C = r3_26 & ~r1;
}

// 00009194: void GPIOIntTypeGet(Register (ptr32 Eq_6856) r0, Register word32 r1)
void GPIOIntTypeGet(struct Eq_6856 * r0, word32 r1)
{
	uint32 r1_9 = (uint32) (byte) (0x01 << r1);
	word32 r3_10 = r0->dw0404;
	up32 r2_12 = (bool) C + (r0->dw0408 + r1_9);
	word32 r0_14 = r0->dw040C;
	up32 r3_22 = (bool) (r2_12 < 0x00) + (r3_10 + r1_9);
}

// 000091C8: void GPIOPadConfigSet(Register (ptr32 Eq_4669) r0, Register ui32 r1, Register ui32 r2, Register ui32 r3)
// Called from:
//      PDCInit
//      GPIOPinTypeComparator
//      GPIOPinTypeI2C
//      GPIOPinTypeQEI
//      GPIOPinTypePWM
void GPIOPadConfigSet(struct Eq_4669 * r0, ui32 r1, ui32 r2, ui32 r3)
{
	ui32 r4_12 = r0->dw0500;
	if ((r2 & 0x01) != 0x00)
		r4_12 |= r1;
	r0->dw0500 = r4_12 & ~r1;
	ui32 r4_18 = r0->dw0504;
	if ((r2 & 0x02) != 0x00)
		r4_18 |= r1;
	r0->dw0504 = r4_18 & ~r1;
	ui32 r4_28 = r0->dw0508;
	if ((r2 & 0x04) != 0x00)
		r4_28 |= r1;
	r0->dw0508 = r4_28 & ~r1;
	ui32 r2_40 = r0->dw0518;
	if ((r2 & 0x08) != 0x00)
		r2_40 |= r1;
	r0->dw0518 = r2_40 & ~r1;
	ui32 r2_48 = r0->dw050C;
	if (r3 << 31 < 0x00)
		r2_48 |= r1;
	r0->dw050C = r2_48 & ~r1;
	ui32 r2_63 = r0->dw0510;
	if (r3 << 30 < 0x00)
		r2_63 |= r1;
	r0->dw0510 = r2_63 & ~r1;
	ui32 r2_74 = r0->dw0514;
	if (r3 << 29 < 0x00)
		r2_74 |= r1;
	r0->dw0514 = r2_74 & ~r1;
	ui32 r3_87 = r0->dw051C;
	if ((r3 & 0x08) != 0x00)
		r1 |= r3_87;
	r0->dw051C = r3_87 & ~r1;
}

// 0000925C: void GPIOPadConfigGet(Register (ptr32 Eq_7005) r0, Register word32 r1, Register (ptr32 word32) r2, Register (ptr32 word32) r3)
void GPIOPadConfigGet(struct Eq_7005 * r0, word32 r1, word32 * r2, word32 * r3)
{
	uint32 r1_17 = (uint32) (byte) (0x01 << r1);
	word32 r4_18 = r0->dw0504;
	up32 r5_20 = (bool) C + (r0->dw0500 + r1_17);
	word32 r5_22 = r0->dw0508;
	up32 r4_30 = (bool) (r5_20 < 0x00) + (r4_18 + r1_17);
	word32 r4_34 = r0->dw0518;
	up32 r5_43 = (bool) (r4_30 < 0x00) + (r5_22 + r1_17);
	*r2 = 0x00;
	word32 r5_130 = 0x00;
	word32 r4_78 = r0->dw0510;
	uint32 r1_81 = r1_17 + r0->dw050C;
	word32 r6_83 = r0->dw0514;
	if (r1_81 != 0x00)
		r5_130 = 0x01;
	word32 r2_88 = r0->dw051C;
	if (r1_81 == 0x00)
		r5_130 = 0x00;
	uint32 r1_98 = r1_81 + r4_78 + (r1_81 < 0x00);
	uint32 r1_109 = r1_98 + r6_83 + (r1_98 < 0x00);
	*r3 = r5_130;
}

// 000092E0: void GPIOPinIntEnable(Register (ptr32 Eq_7107) r0, Register ui32 r1)
void GPIOPinIntEnable(struct Eq_7107 * r0, ui32 r1)
{
	r0->dw0410 = r1 | r0->dw0410;
}

// 000092EC: void GPIOPinIntDisable(Register (ptr32 Eq_7116) r0, Register word32 r1)
void GPIOPinIntDisable(struct Eq_7116 * r0, word32 r1)
{
	r0->dw0410 &= ~r1;
}

// 000092FC: void GPIOPinIntStatus(Register word32 r1)
void GPIOPinIntStatus(word32 r1)
{
	if (r1 != 0x00)
		;
}

// 0000930C: void GPIOPinIntClear(Register (ptr32 Eq_7129) r0, Register word32 r1)
void GPIOPinIntClear(struct Eq_7129 * r0, word32 r1)
{
	r0->dw041C = r1;
}

// 00009314: void GPIOPortIntRegister(Register up32 r0, Register word32 r1)
void GPIOPortIntRegister(up32 r0, word32 r1)
{
	up32 r3_4 = g_dw93A8;
	if (r0 == r3_4)
	{
		IntRegister(0x12, r1);
		IntEnable(0x12);
	}
	else
	{
		if (r0 <= r3_4)
		{
			if (r0 == 0x40004000)
			{
				IntRegister(0x10, r1);
				IntEnable(0x10);
				return;
			}
			if (r0 == r3_4 - 0x1000)
			{
				IntRegister(0x11, r1);
				IntEnable(0x11);
				return;
			}
		}
		else
		{
			up32 r3_34 = g_dw93AC;
			if (r0 == r3_34)
			{
				IntRegister(0x13, r1);
				IntEnable(0x13);
				return;
			}
			if (r0 == r3_34 + 0x0001D000)
			{
				IntRegister(0x14, r1);
				IntEnable(0x14);
				return;
			}
		}
		IntRegister(~0x00, r1);
		IntEnable(~0x00);
	}
}

up32 g_dw93A8 = 0x40006000;
up32 g_dw93AC = 0x40007000;
// 000093B0: void GPIOPortIntUnregister(Register up32 r0)
void GPIOPortIntUnregister(up32 r0)
{
	up32 r3_4 = g_dw9444;
	if (r0 == r3_4)
	{
		IntDisable(0x12);
		IntUnregister(0x12);
	}
	else
	{
		if (r0 <= r3_4)
		{
			if (r0 == 0x40004000)
			{
				IntDisable(0x10);
				IntUnregister(0x10);
				return;
			}
			if (r0 == r3_4 - 0x1000)
			{
				IntDisable(0x11);
				IntUnregister(0x11);
				return;
			}
		}
		else
		{
			up32 r3_29 = g_dw9448;
			if (r0 == r3_29)
			{
				IntDisable(0x13);
				IntUnregister(0x13);
				return;
			}
			if (r0 == r3_29 + 0x0001D000)
			{
				IntDisable(0x14);
				IntUnregister(0x14);
				return;
			}
		}
		IntDisable(~0x00);
		IntUnregister(~0x00);
	}
}

up32 g_dw9444 = 0x40006000;
up32 g_dw9448 = 0x40007000;
// 0000944C: void GPIOPinRead()
void GPIOPinRead()
{
}

// 00009454: void GPIOPinWrite(Register (arr word32) r0, Register ui32 r1, Register word32 r2)
// Called from:
//      PDCInit
void GPIOPinWrite(word32 r0[], ui32 r1, word32 r2)
{
	r0[r1] = r2;
}

// 0000945C: void GPIOPinTypeComparator(Register (ptr32 Eq_4669) r0, Register ui32 r1)
void GPIOPinTypeComparator(struct Eq_4669 * r0, ui32 r1)
{
	ui32 r5_11 = ~r1;
	r0->dw0400 &= r5_11;
	r0->dw0420 = r5_11 & r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x00);
}

// 00009480: void GPIOPinTypeI2C(Register (ptr32 Eq_4669) r0, Register ui32 r1)
// Called from:
//      OSRAMInit
void GPIOPinTypeI2C(struct Eq_4669 * r0, ui32 r1)
{
	r0->dw0400 &= ~r1;
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 11);
}

// 000094A4: void GPIOPinTypeQEI(Register (ptr32 Eq_4669) r0, Register ui32 r1)
void GPIOPinTypeQEI(struct Eq_4669 * r0, ui32 r1)
{
	r0->dw0400 &= ~r1;
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x0A);
}

// 000094C8: void GPIOPinTypeUART(Register (ptr32 Eq_4669) r0, Register ui32 r1)
// Called from:
//      GPIOPinTypeTimer
//      GPIOPinTypeSSI
//      GPIOPinTypePWM
void GPIOPinTypeUART(struct Eq_4669 * r0, ui32 r1)
{
	r0->dw0400 &= ~r1;
	r0->dw0420 = r1 | r0->dw0420;
	GPIOPadConfigSet(r0, r1, 0x01, 0x08);
}

// 000094EC: void GPIOPinTypeTimer(Register (ptr32 Eq_4669) r0, Register ui32 r1)
void GPIOPinTypeTimer(struct Eq_4669 * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F0: void GPIOPinTypeSSI(Register (ptr32 Eq_4669) r0, Register ui32 r1)
void GPIOPinTypeSSI(struct Eq_4669 * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F4: void GPIOPinTypePWM(Register (ptr32 Eq_4669) r0, Register ui32 r1)
void GPIOPinTypePWM(struct Eq_4669 * r0, ui32 r1)
{
	GPIOPinTypeUART(r0, r1);
}

// 000094F8: void IntDefaultHandler()
void IntDefaultHandler()
{
	while (true)
		;
}

// 000094FC: void IntMasterEnable()
void IntMasterEnable()
{
	CPUcpsie();
}

// 00009500: void IntMasterDisable()
void IntMasterDisable()
{
	CPUcpsid();
}

// 00009504: void IntRegister(Register ui32 r0, Register word32 r1)
// Called from:
//      GPIOPortIntRegister
//      SSIIntRegister
//      SysCtlIntRegister
//      UARTIntRegister
//      I2CIntRegister
void IntRegister(ui32 r0, word32 r1)
{
	word32 r4_11[] = g_ptr9534;
	if (*g_ptr9530 != r4_11)
	{
		word32 r3_14[] = r4_11;
		do
		{
			Mem21[r3_14 + 0x00:word32] = Mem19[r3_14 - r4_11:word32];
			r3_14 = (word32 (*)[]) (r3_14 + 1);
		} while (r3_14 != r4_11 + 46);
		*g_ptr9530 = r4_11;
	}
	r4_11[r0] = r1;
}

word32 (** g_ptr9530)[] = &g_ptrE000ED08;
word32 (* g_ptr9534)[] = &g_a20000000;
// 00009538: void IntUnregister(Register ui32 r0)
// Called from:
//      GPIOPortIntUnregister
//      SSIIntUnregister
//      SysCtlIntUnregister
//      UARTIntUnregister
//      I2CIntUnregister
void IntUnregister(ui32 r0)
{
	g_ptr9544[r0] = g_dw9548;
}

word32 (* g_ptr9544)[] = &g_a20000000;
word32 g_dw9548 = 0x94F9;
// 0000954C: void IntPriorityGroupingSet(Register ui32 r0)
void IntPriorityGroupingSet(ui32 r0)
{
	*g_ptr9564 = g_ptr9560[r0] | 0x05F80000 | 0x00020000;
}

ui32 (* g_ptr9560)[] = &g_aA2A4;
ui32 * g_ptr9564 = &g_dwE000ED0C;
// 00009568: void IntPriorityGroupingGet()
void IntPriorityGroupingGet()
{
	ui32 r3_11 = 0x0700;
	word32 r0_15 = 0x00;
	ui32 r1_7 = *g_ptr9588;
	word32 * r2_19 = g_ptr958C;
	while (r3_11 != (r1_7 & 0x0700))
	{
		++r0_15;
		if (r0_15 == 0x08)
			return;
		++r2_19;
		r3_11 = *r2_19;
	}
}

ui32 * g_ptr9588 = &g_dwE000ED0C;
word32 * g_ptr958C = &g_dwA2A8;
// 00009590: void IntPrioritySet(Register ui32 r0, Register ui32 r1)
void IntPrioritySet(ui32 r0, ui32 r1)
{
	ui32 * r4_13 = (g_ptr95B8 + (r0 & ~0x03))->ptr0020;
	ui32 r0_16 = (r0 & 0x03) << 3;
	*r4_13 = r1 << r0_16 | *r4_13 & ~(0xFF << r0_16);
}

ptr32 g_ptr95B8 = 0xA2A4;
// 000095BC: void IntPriorityGet()
void IntPriorityGet()
{
}

// 000095DC: void IntEnable(Register up32 r0)
// Called from:
//      GPIOPortIntRegister
//      SSIIntRegister
//      SysCtlIntRegister
//      UARTIntRegister
//      I2CIntRegister
void IntEnable(up32 r0)
{
	if (r0 == 0x04)
	{
		ui32 * r2_7 = g_ptr9634;
		*r2_7 |= 0x00010000;
	}
	else if (r0 == 0x05)
	{
		ui32 * r2_13 = g_ptr9634;
		*r2_13 |= 0x00020000;
	}
	else if (r0 == 0x06)
	{
		ui32 * r2_19 = g_ptr9634;
		*r2_19 |= 0x00040000;
	}
	else if (r0 == 0x0F)
	{
		ui32 * r2_25 = g_ptr9630;
		*r2_25 |= 0x02;
	}
	else if (r0 > 0x0F)
		*g_ptr962C = 0x01 << r0 - 0x10;
}

ui32 * g_ptr962C = &g_dwE000E100;
ui32 * g_ptr9630 = &g_dwE000E010;
ui32 * g_ptr9634 = &g_dwE000ED24;
// 00009638: void IntDisable(Register up32 r0)
// Called from:
//      GPIOPortIntUnregister
//      SSIIntUnregister
//      SysCtlIntUnregister
//      UARTIntUnregister
//      I2CIntUnregister
void IntDisable(up32 r0)
{
	if (r0 == 0x04)
	{
		ui32 * r2_7 = g_ptr9690;
		*r2_7 &= ~0x00010000;
	}
	else if (r0 == 0x05)
	{
		ui32 * r2_13 = g_ptr9690;
		*r2_13 &= ~0x00020000;
	}
	else if (r0 == 0x06)
	{
		ui32 * r2_19 = g_ptr9690;
		*r2_19 &= ~0x00040000;
	}
	else if (r0 == 0x0F)
	{
		ui32 * r2_25 = g_ptr968C;
		*r2_25 &= ~0x02;
	}
	else if (r0 > 0x0F)
		*g_ptr9688 = 0x01 << r0 - 0x10;
}

ui32 * g_ptr9688 = &g_dwE000E180;
ui32 * g_ptr968C = &g_dwE000E010;
ui32 * g_ptr9690 = &g_dwE000ED24;
// 00009694: void OSRAMDelay(Register word32 r0)
// Called from:
//      OSRAMWriteArray
//      OSRAMWriteByte
//      OSRAMWriteFinal
void OSRAMDelay(word32 r0)
{
	do
		--r0;
	while (r0 != 0x00);
}

// 0000969C: void OSRAMWriteFirst(Register ui32 r0)
// Called from:
//      OSRAMStringDraw
//      OSRAMImageDraw
//      OSRAMInit
//      OSRAMDisplayOn
//      OSRAMDisplayOff
void OSRAMWriteFirst(ui32 r0)
{
	struct Eq_7597 * r4_14 = g_ptr96C0;
	I2CMasterSlaveAddrSet(r4_14, 0x3D, 0x00);
	I2CMasterDataPut(r4_14, r0);
	I2CMasterControl(r4_14, 0x03);
}

struct Eq_7597 * g_ptr96C0 = &g_t40020000;
// 000096C4: void OSRAMWriteArray(Register (ptr32 Eq_7619) r0, Register int32 r1)
// Called from:
//      OSRAMStringDraw
//      OSRAMImageDraw
//      OSRAMInit
//      OSRAMDisplayOn
void OSRAMWriteArray(struct Eq_7619 * r0, int32 r1)
{
	if (r1 == 0x00)
		return;
	struct Eq_7619 * r5_18 = r0;
	word32 * r7_19 = g_ptr96FC;
	struct Eq_7597 * r4_20 = g_ptr9700;
	struct Eq_7619 * r6_21 = r0 + r1;
	do
	{
		do
			;
		while (I2CMasterIntStatus(r4_20, 0x00) == 0x00);
		OSRAMDelay(*r7_19);
		I2CMasterDataPut(r4_20, (word32) r5_18->b0000);
		I2CMasterControl(r4_20, 0x01);
		++r5_18;
	} while (r6_21 != r5_18);
}

word32 * g_ptr96FC = &g_dw2000087C;
struct Eq_7597 * g_ptr9700 = &g_t40020000;
// 00009704: void OSRAMWriteByte(Register ui32 r0)
// Called from:
//      OSRAMStringDraw
//      OSRAMImageDraw
//      OSRAMInit
//      OSRAMDisplayOff
void OSRAMWriteByte(ui32 r0)
{
	do
		;
	while (I2CMasterIntStatus(g_ptr9730, 0x00) == 0x00);
	OSRAMDelay(*g_ptr9734);
	I2CMasterDataPut(g_ptr9730, r0);
	struct Eq_7597 * r0_35 = g_ptr9730;
	I2CMasterControl(r0_35, 0x01);
}

struct Eq_7597 * g_ptr9730 = &g_t40020000;
word32 * g_ptr9734 = &g_dw2000087C;
// 00009738: void OSRAMWriteFinal(Register ui32 r0)
// Called from:
//      OSRAMStringDraw
//      OSRAMImageDraw
//      OSRAMInit
//      OSRAMDisplayOn
//      OSRAMDisplayOff
void OSRAMWriteFinal(ui32 r0)
{
	struct Eq_7597 * r4_14 = g_ptr9778;
	do
		;
	while (I2CMasterIntStatus(r4_14, 0x00) == 0x00);
	word32 * r5_26 = g_ptr977C;
	struct Eq_7597 * r4_27 = g_ptr9778;
	OSRAMDelay(*r5_26);
	I2CMasterDataPut(r4_27, r0);
	I2CMasterControl(r4_27, 0x05);
	do
		;
	while (I2CMasterIntStatus(r4_27, 0x00) == 0x00);
	word32 r0_51 = *r5_26;
	OSRAMDelay(r0_51);
}

struct Eq_7597 * g_ptr9778 = &g_t40020000;
word32 * g_ptr977C = &g_dw2000087C;
// 00009780: void OSRAMClear()
// Called from:
//      vPrintTask
//      OSRAMInit
void OSRAMClear()
{
	OSRAMWriteFirst(0x80);
	OSRAMWriteArray(g_ptr97C4, 0x06);
	ui32 r4_20;
	for (r4_20 = 0x5F; r4_20 != 0x00; --r4_20)
		OSRAMWriteByte(0x00);
	OSRAMWriteFinal(r4_20);
	OSRAMWriteFirst(0x80);
	OSRAMWriteArray(g_ptr97C8, 0x06);
	ui32 r4_53;
	for (r4_53 = 0x5F; r4_53 != 0x00; --r4_53)
		OSRAMWriteByte(0x00);
	OSRAMWriteFinal(r4_53);
}

struct Eq_7619 * g_ptr97C4 = &g_tA2F4;
struct Eq_7619 * g_ptr97C8 = &g_tA2FC;
// 000097CC: void OSRAMStringDraw(Register (ptr32 byte) r0, Register uint32 r1, Register ui32 r2)
// Called from:
//      ResetISR
//      vPrintTask
void OSRAMStringDraw(byte * r0, uint32 r1, ui32 r2)
{
	OSRAMWriteFirst(0x80);
	uint32 r4_100 = r1;
	byte * r5_104 = r0;
	OSRAMWriteByte(177);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte(r1 + 0x24 & 0x0F);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte((uint32) SLICE(r1 + 0x24, ui4, 4) | 0x10);
	OSRAMWriteByte(0x40);
	ui32 r3_117 = (word32) *r0;
	if (r3_117 == 0x00)
		return;
	word32 r6_85 = g_dw9878;
	if (r1 <= 0x5A)
	{
		do
		{
			OSRAMWriteArray(r6_85 + (r3_117 - 0x20) * 0x05, 0x05);
			if (r4_100 == 0x5A)
			{
l00009846:
				OSRAMWriteFinal(0x00);
				return;
			}
			++r5_104;
			r4_100 += 0x06;
			if ((word32) *r5_104 == 0x00)
				goto l00009846;
			OSRAMWriteByte(0x00);
			r3_117 = (word32) *r5_104;
			if (r3_117 == 0x00)
				return;
		} while (r4_100 <= 0x5A);
	}
	int32 r4_144 = 0x5F - r4_100;
	OSRAMWriteArray(r6_85 + (r3_117 - 0x20) * 0x05, r4_144);
	Eq_7825 r3_156 = (word32) *r5_104;
	ui32 r0_163 = (word32) (r3_156 - 0x20 + (r3_156 - 0x20 << 0x02) + g_dw987C + r4_144)->b0010;
	OSRAMWriteFinal(r0_163);
}

word32 g_dw9878 = 0xA304;
int32 g_dw987C = 41716;
// 00009880: void OSRAMImageDraw(Register (ptr32 Eq_7619) r0, Register word32 r1, Register word32 r2, Register word32 r3, Stack word32 dwArg00)
void OSRAMImageDraw(struct Eq_7619 * r0, word32 r1, word32 r2, word32 r3, word32 dwArg00)
{
	if (dwArg00 != 0x00)
	{
		struct Eq_7619 * r5_103 = r0;
		word32 r4_112 = r2;
		uint32 r8_29 = (uint32) SLICE(r1 + 0x24, ui4, 4);
		word32 r6_30 = dwArg00 + r2;
		ui32 r7_33 = r1 + 0x24 & 0x0F;
		do
		{
			OSRAMWriteFirst(0x80);
			OSRAMWriteByte(0xB0);
			OSRAMWriteByte(0x80);
			OSRAMWriteByte(r7_33);
			OSRAMWriteByte(0x80);
			OSRAMWriteByte(r8_29 | 0x10);
			OSRAMWriteByte(0x40);
			OSRAMWriteArray(r5_103, r3 + ~0x00);
			r5_103 += r3;
			OSRAMWriteFinal((word32) r5_103->bFFFFFFFF);
			++r4_112;
		} while (r6_30 != r4_112);
	}
}

// 000098F0: void OSRAMInit(Register word32 r0)
// Called from:
//      ResetISR
void OSRAMInit(word32 r0)
{
	SysCtlPeripheralEnable(0x10001000);
	SysCtlPeripheralEnable(g_dw9960);
	GPIOPinTypeI2C(g_ptr9964, 0x0C);
	I2CMasterInit(g_ptr9968, r0);
	word32 r7_51 = g_dw9970;
	*g_ptr996C = 0x01;
	ui32 r6_52 = 227;
	int32 r4_53 = 0x04;
	ui32 r0_54 = 0x80;
	up32 r5_55 = 0x00;
	while (true)
	{
		OSRAMWriteFirst(r0_54);
		OSRAMWriteArray(r5_55 + 0x02 + (r7_51 + 0x01EC), r4_53 - 0x02);
		OSRAMWriteFinal(r6_52);
		r5_55 += r4_53 + 0x01;
		struct Eq_7981 * r3_88 = r7_51 + r5_55;
		if (r5_55 > 0x70)
			break;
		r4_53 = (word32) r3_88->b01EC;
		r0_54 = (word32) r3_88->b01ED;
		r6_52 = (word32) (r3_88 + r4_53 / 494)->b01EC;
	}
	OSRAMClear();
}

uint32 g_dw9960 = 0x20000002;
struct Eq_4669 * g_ptr9964 = &g_t40005000;
struct Eq_7943 * g_ptr9968 = &g_t40020000;
word32 * g_ptr996C = &g_dw2000087C;
word32 g_dw9970 = 41716;
// 00009974: void OSRAMDisplayOn()
void OSRAMDisplayOn()
{
	word32 r7_16 = g_dw99BC;
	ui32 r6_17 = 227;
	int32 r4_18 = 0x04;
	ui32 r0_19 = 0x80;
	up32 r5_20 = 0x00;
	while (true)
	{
		OSRAMWriteFirst(r0_19);
		OSRAMWriteArray(r5_20 + 0x02 + (r7_16 + 0x01EC), r4_18 - 0x02);
		OSRAMWriteFinal(r6_17);
		r5_20 += r4_18 + 0x01;
		struct Eq_8027 * r3_52 = r7_16 + r5_20;
		if (r5_20 > 0x70)
			break;
		r4_18 = (word32) r3_52->b01EC;
		r0_19 = (word32) r3_52->b01ED;
		r6_17 = (word32) (r3_52 + r4_18 / 494)->b01EC;
	}
}

word32 g_dw99BC = 41716;
// 000099C0: void OSRAMDisplayOff()
void OSRAMDisplayOff()
{
	OSRAMWriteFirst(0x80);
	OSRAMWriteByte(0xAE);
	OSRAMWriteByte(0x80);
	OSRAMWriteByte(0xAD);
	OSRAMWriteByte(0x80);
	OSRAMWriteFinal(0x8A);
}

// 000099E8: void SSIConfig(Register (ptr32 Eq_4678) r0, Register ui32 r1, Register ui32 r2, Register uint32 r3, Stack ui32 dwArg00)
// Called from:
//      PDCInit
void SSIConfig(struct Eq_4678 * r0, ui32 r1, ui32 r2, uint32 r3, ui32 dwArg00)
{
	ui32 r7_17 = r2;
	uint32 r0_25 = SysCtlClockGet();
	if (r2 != 0x02)
	{
		if (r2 != 0x00)
			r7_17 = 0x04;
	}
	else
		r7_17 = 0x0C;
	r0->dw0004 = r7_17;
	uint32 r3_41 = r0_25 /u r3;
	uint32 r4_42 = 0x00;
	do
	{
		r4_42 += 0x02;
		uint32 r2_49 = r3_41 /u r4_42;
	} while (r2_49 > 0x0100);
	r0->dw0010 = r4_42;
	r0->dw0000 = dwArg00 - 0x01 | (r1 & 0x30 | r1 << 0x06) | r2_49 - 0x01 << 0x08;
}

// 00009A34: void SSIEnable(Register (ptr32 Eq_4678) r0)
// Called from:
//      PDCInit
void SSIEnable(struct Eq_4678 * r0)
{
	r0->dw0004 |= 0x02;
}

// 00009A40: void SSIDisable(Register (ptr32 Eq_8113) r0)
void SSIDisable(struct Eq_8113 * r0)
{
	r0->dw0004 &= ~0x02;
}

// 00009A4C: void SSIIntRegister(Register word32 r1)
void SSIIntRegister(word32 r1)
{
	IntRegister(0x17, r1);
	IntEnable(0x17);
}

// 00009A60: void SSIIntUnregister()
void SSIIntUnregister()
{
	IntDisable(0x17);
	IntUnregister(0x17);
}

// 00009A74: void SSIIntEnable(Register (ptr32 Eq_8136) r0, Register ui32 r1)
void SSIIntEnable(struct Eq_8136 * r0, ui32 r1)
{
	r0->dw0014 = r1 | r0->dw0014;
}

// 00009A7C: void SSIIntDisable(Register (ptr32 Eq_8145) r0, Register word32 r1)
void SSIIntDisable(struct Eq_8145 * r0, word32 r1)
{
	r0->dw0014 &= ~r1;
}

// 00009A88: void SSIIntStatus(Register word32 r1)
void SSIIntStatus(word32 r1)
{
	if (r1 != 0x00)
		;
}

// 00009A94: void SSIIntClear(Register (ptr32 Eq_8158) r0, Register word32 r1)
void SSIIntClear(struct Eq_8158 * r0, word32 r1)
{
	r0->dw0020 = r1;
}

// 00009A98: void SSIDataPut(Register (ptr32 Eq_4712) r0, Register ui32 r1)
// Called from:
//      PDCWrite
void SSIDataPut(struct Eq_4712 * r0, ui32 r1)
{
	do
		;
	while (r0->dw000C << 30 >= 0x00);
	r0->dw0008 = r1;
}

// 00009AA8: void SSIDataNonBlockingPut(Register (ptr32 Eq_8173) r0, Register word32 r1)
void SSIDataNonBlockingPut(struct Eq_8173 * r0, word32 r1)
{
	if ((r0->dw000C & 0x02) != 0x00)
		r0->dw0008 = r1;
}

// 00009AB8: void SSIDataGet(Register (ptr32 Eq_4712) r0, Register (ptr32 ui32) r1)
// Called from:
//      PDCWrite
void SSIDataGet(struct Eq_4712 * r0, ui32 * r1)
{
	do
		;
	while (r0->dw000C << 29 >= 0x00);
	*r1 = r0->dw0008;
}

// 00009AC8: void SSIDataNonBlockingGet(Register (ptr32 Eq_8198) r0, Register (ptr32 ui32) r1)
void SSIDataNonBlockingGet(struct Eq_8198 * r0, ui32 * r1)
{
	ui32 r3_5 = r0->dw000C;
	ui32 r3_10 = r3_5 & 0x04;
	if ((r3_5 & 0x04) != 0x00)
		r3_10 = r0->dw0008;
	*r1 = r3_10;
}

// 00009ADC: void SysCtlSRAMSizeGet()
void SysCtlSRAMSizeGet()
{
}

// 00009AF4: void SysCtlFlashSizeGet()
void SysCtlFlashSizeGet()
{
}

// 00009B0C: void SysCtlPinPresent(Register word32 r0)
void SysCtlPinPresent(word32 r0)
{
	(bool) C + (*g_ptr9B1C + r0) == 0x00;
}

word32 * g_ptr9B1C = &g_dw400FE018;
// 00009B20: void SysCtlPeripheralPresent(Register uint32 r0)
void SysCtlPeripheralPresent(uint32 r0)
{
	(r0 & ~0xF0000000) + *g_ptr9B38[r0 >> 28] + (r0 >> 28 < 0x00) == 0x00;
}

word32 * (* g_ptr9B38)[] = &g_aA554;
// 00009B3C: void SysCtlPeripheralReset(Register uint32 r0)
void SysCtlPeripheralReset(uint32 r0)
{
	ui32 * r2_12 = (g_ptr9B78 + ((r0 >> 28) << 0x02))->ptr0010;
	*r2_12 = r0 & ~0xF0000000 | *r2_12;
	*r2_12 &= ~r0;
}

ptr32 g_ptr9B78 = 42324;
// 00009B7C: void SysCtlPeripheralEnable(Register uint32 r0)
// Called from:
//      PDCInit
//      OSRAMInit
void SysCtlPeripheralEnable(uint32 r0)
{
	ui32 * r3_8 = (g_ptr9B94 + ((r0 >> 28) << 0x02))->ptr001C;
	*r3_8 = r0 & ~0xF0000000 | *r3_8;
}

ptr32 g_ptr9B94 = 42324;
// 00009B98: void SysCtlPeripheralDisable(Register uint32 r0)
void SysCtlPeripheralDisable(uint32 r0)
{
	ui32 * r2_9 = (g_ptr9BB0 + ((r0 >> 28) << 0x02))->ptr001C;
	*r2_9 &= ~(r0 & ~0xF0000000);
}

ptr32 g_ptr9BB0 = 42324;
// 00009BB4: void SysCtlPeripheralSleepEnable(Register uint32 r0)
void SysCtlPeripheralSleepEnable(uint32 r0)
{
	ui32 * r3_8 = (g_ptr9BCC + ((r0 >> 28) << 0x02))->ptr0028;
	*r3_8 = r0 & ~0xF0000000 | *r3_8;
}

ptr32 g_ptr9BCC = 42324;
// 00009BD0: void SysCtlPeripheralSleepDisable(Register uint32 r0)
void SysCtlPeripheralSleepDisable(uint32 r0)
{
	ui32 * r2_9 = (g_ptr9BE8 + ((r0 >> 28) << 0x02))->ptr0028;
	*r2_9 &= ~(r0 & ~0xF0000000);
}

ptr32 g_ptr9BE8 = 42324;
// 00009BEC: void SysCtlPeripheralDeepSleepEnable(Register uint32 r0)
void SysCtlPeripheralDeepSleepEnable(uint32 r0)
{
	ui32 * r3_8 = (g_ptr9C04 + ((r0 >> 28) << 0x02))->ptr0034;
	*r3_8 = r0 & ~0xF0000000 | *r3_8;
}

ptr32 g_ptr9C04 = 42324;
// 00009C08: void SysCtlPeripheralDeepSleepDisable(Register uint32 r0)
void SysCtlPeripheralDeepSleepDisable(uint32 r0)
{
	ui32 * r2_9 = (g_ptr9C20 + ((r0 >> 28) << 0x02))->ptr0034;
	*r2_9 &= ~(r0 & ~0xF0000000);
}

ptr32 g_ptr9C20 = 42324;
// 00009C24: void SysCtlPeripheralClockGating(Register word32 r0)
void SysCtlPeripheralClockGating(word32 r0)
{
	ui32 * r2_4 = g_ptr9C3C;
	ui32 r3_5 = *r2_4;
	if (r0 != 0x00)
		*r2_4 = r3_5 | 0x08000000;
	else
		*r2_4 = r3_5 & ~0x08000000;
}

ui32 * g_ptr9C3C = &g_dw400FE060;
// 00009C40: void SysCtlIntRegister(Register word32 r0)
void SysCtlIntRegister(word32 r0)
{
	IntRegister(44, r0);
	IntEnable(44);
}

// 00009C54: void SysCtlIntUnregister()
void SysCtlIntUnregister()
{
	IntDisable(44);
	IntUnregister(44);
}

// 00009C68: void SysCtlIntEnable(Register ui32 r0)
void SysCtlIntEnable(ui32 r0)
{
	ui32 * r2_4 = g_ptr9C74;
	*r2_4 = r0 | *r2_4;
}

ui32 * g_ptr9C74 = &g_dw400FE054;
// 00009C78: void SysCtlIntDisable(Register word32 r0)
void SysCtlIntDisable(word32 r0)
{
	ui32 * r2_4 = g_ptr9C84;
	*r2_4 &= ~r0;
}

ui32 * g_ptr9C84 = &g_dw400FE054;
// 00009C88: void SysCtlIntClear(Register word32 r0)
void SysCtlIntClear(word32 r0)
{
	*g_ptr9C90 = r0;
}

word32 * g_ptr9C90 = &g_dw400FE058;
// 00009C94: void SysCtlIntStatus(Register word32 r0)
void SysCtlIntStatus(word32 r0)
{
	if (r0 != 0x00)
		;
}

// 00009CAC: void SysCtlLDOSet(Register word32 r0)
void SysCtlLDOSet(word32 r0)
{
	*g_ptr9CB4 = r0;
}

word32 * g_ptr9CB4 = &g_dw400FE034;
// 00009CB8: void SysCtlLDOGet()
void SysCtlLDOGet()
{
}

// 00009CC4: void SysCtlLDOConfigSet(Register word32 r0)
void SysCtlLDOConfigSet(word32 r0)
{
	*g_ptr9CCC = r0;
}

word32 * g_ptr9CCC = &g_dw400FE160;
// 00009CD0: void SysCtlReset()
void SysCtlReset()
{
	*g_ptr9CD8 = g_dw9CDC;
	while (true)
		;
}

word32 * g_ptr9CD8 = &g_dwE000ED0C;
word32 g_dw9CDC = 0x05FA0004;
// 00009CE0: void SysCtlSleep()
void SysCtlSleep()
{
	CPUwfi();
}

// 00009CE4: void SysCtlDeepSleep()
void SysCtlDeepSleep()
{
	ui32 * r4_8 = g_ptr9D00;
	*r4_8 |= 0x04;
	CPUwfi();
	*r4_8 &= ~0x04;
}

ui32 * g_ptr9D00 = &g_dwE000ED10;
// 00009D04: void SysCtlResetCauseGet()
void SysCtlResetCauseGet()
{
}

// 00009D10: void SysCtlResetCauseClear(Register word32 r0)
void SysCtlResetCauseClear(word32 r0)
{
	ui32 * r2_4 = g_ptr9D1C;
	*r2_4 &= ~r0;
}

ui32 * g_ptr9D1C = &g_dw400FE05C;
// 00009D20: void SysCtlBrownOutConfigSet(Register ui32 r0, Register ui32 r1)
void SysCtlBrownOutConfigSet(ui32 r0, ui32 r1)
{
	*g_ptr9D2C = r0 | r1 << 0x02;
}

ui32 * g_ptr9D2C = &g_dw400FE030;
// 00009D30: void SysCtlClockSet(Register ui32 r0)
void SysCtlClockSet(ui32 r0)
{
SysCtlClockSet_entry:
	ui32 * r4_15 = g_ptr9DE0
	ui32 r3_17 = *r4_15
	word32 * r5_25 = g_ptr9DE8
	ui32 r2_28 = r0 & 0x33F0 | (g_dw9DE4 & r3_17 | 0x0800) & (r0 | ~0x03)
	*r4_15 = r3_17 & ~0x00400000 | 0x0800
	*r5_25 = 0x40
	*r4_15 = r2_28
	ui32 r2_52 = r2_28 & ~0x03 | r0 & 0x03
	*g_ptr9DE0 = r2_52
	ui32 r1_58 = r0 & 0x07C00000 | r2_52 & ~0x07C00000
	branch r0 << 20 < 0x00 l00009DBE
	goto l00009D94
l00009D30:
l00009D76:
l00009D94:
	word32 dwLoc14_120 = 0x8000
	ui32 * r2_64 = g_ptr9DEC
	branch *r2_64 << 25 >= 0x00 l00009DAE
	goto l00009DA6
l00009D9E:
l00009DA6:
l00009DA8:
l00009DAE:
	dwLoc14_120 = dwLoc14_120 - 0x01
	branch dwLoc14_120 != 0x00 l00009DA8
	branch *r2_64 << 25 < 0x00 l00009DBA
	goto l00009DAE
l00009DBE:
	*g_ptr9DE0 = r1_58
	return
l00009DD8:
SysCtlClockSet_exit:
}

ui32 * g_ptr9DE0 = &g_dw400FE060;
ui32 g_dw9DE4 = ~0x004033F0;
word32 * g_ptr9DE8 = &g_dw400FE058;
ui32 * g_ptr9DEC = &g_dw400FE050;
// 00009DF0: Register uint32 SysCtlClockGet()
// Called from:
//      SSIConfig
//      UARTConfigSet
//      UARTConfigGet
//      I2CMasterInit
uint32 SysCtlClockGet()
{
	uint32 r0_12;
	ui32 r3_5 = *g_ptr9E54;
	if ((r3_5 & 0x30) != 0x10)
	{
		if ((r3_5 & 0x30) != 0x20)
		{
			if ((r3_5 & 0x30) != 0x00)
			{
				r0_12 = 0x00;
				return r0_12;
			}
			r0_12 = (g_ptr9E58 + ((uint32) SLICE(r3_5, ui4, 6) << 0x02))->dw0030;
		}
		else
			r0_12 = g_dw9E60;
	}
	else
		r0_12 = g_dw9E64;
	if (r3_5 << 20 >= 0x00)
	{
		ui32 r2_23 = *g_ptr9E5C;
		r0_12 = r0_12 * ((uint32) SLICE(r2_23, ui9, 5) + 0x02) /u ((r2_23 & 0x1F) + 0x02);
		if (r2_23 << 0x0011 < 0x00)
			r0_12 >>= 1;
		if (r2_23 << 16 < 0x00)
			r0_12 >>= 2;
	}
	if (r3_5 << 9 >= 0x00)
		return r0_12;
	return r0_12 /u ((uint32) SLICE(r3_5, ui4, 23) + 0x01);
}

ui32 * g_ptr9E54 = &g_dw400FE060;
ptr32 g_ptr9E58 = 42324;
ui32 * g_ptr9E5C = &g_dw400FE064;
uint32 g_dw9E60 = 3750000;
uint32 g_dw9E64 = 15000000;
// 00009E68: void SysCtlPWMClockSet(Register ui32 r0)
void SysCtlPWMClockSet(ui32 r0)
{
	ui32 * r2_4 = g_ptr9E78;
	*r2_4 = r0 | *r2_4 & ~0x001E0000;
}

ui32 * g_ptr9E78 = &g_dw400FE060;
// 00009E7C: void SysCtlPWMClockGet()
void SysCtlPWMClockGet()
{
}

// 00009E8C: void SysCtlADCSpeedSet(Register ui32 r0)
void SysCtlADCSpeedSet(ui32 r0)
{
	ui32 * r4_6 = g_ptr9EB8;
	ui32 * r1_7 = g_ptr9EBC;
	ui32 * r2_9 = g_ptr9EC0;
	*r4_6 = *r4_6 & ~0x0F00 | r0;
	*r1_7 = *r1_7 & ~0x0F00 | r0;
	*r2_9 = r0 | *r2_9 & ~0x0F00;
}

ui32 * g_ptr9EB8 = &g_dw400FE100;
ui32 * g_ptr9EBC = &g_dw400FE110;
ui32 * g_ptr9EC0 = &g_dw400FE120;
// 00009EC4: void SysCtlADCSpeedGet()
void SysCtlADCSpeedGet()
{
}

// 00009ED4: void SysCtlIOSCVerificationSet(Register word32 r0)
void SysCtlIOSCVerificationSet(word32 r0)
{
	ui32 * r2_4 = g_ptr9EEC;
	ui32 r3_5 = *r2_4;
	if (r0 != 0x00)
		*r2_4 = r3_5 | 0x08;
	else
		*r2_4 = r3_5 & ~0x08;
}

ui32 * g_ptr9EEC = &g_dw400FE060;
// 00009EF0: void SysCtlMOSCVerificationSet(Register word32 r0)
void SysCtlMOSCVerificationSet(word32 r0)
{
	ui32 * r2_4 = g_ptr9F08;
	ui32 r3_5 = *r2_4;
	if (r0 != 0x00)
		*r2_4 = r3_5 | 0x04;
	else
		*r2_4 = r3_5 & ~0x04;
}

ui32 * g_ptr9F08 = &g_dw400FE060;
// 00009F0C: void SysCtlPLLVerificationSet(Register word32 r0)
void SysCtlPLLVerificationSet(word32 r0)
{
	ui32 * r2_4 = g_ptr9F24;
	ui32 r3_5 = *r2_4;
	if (r0 != 0x00)
		*r2_4 = r3_5 | 0x0400;
	else
		*r2_4 = r3_5 & ~0x0400;
}

ui32 * g_ptr9F24 = &g_dw400FE060;
// 00009F28: void SysCtlClkVerificationClear()
void SysCtlClkVerificationClear()
{
	word32 * r3_6 = g_ptr9F34;
	*r3_6 = 0x01;
	*r3_6 = 0x00;
}

word32 * g_ptr9F34 = &g_dw400FE150;
// 00009F38: void UARTParityModeSet(Register (ptr32 Eq_8836) r0, Register ui32 r1)
void UARTParityModeSet(struct Eq_8836 * r0, ui32 r1)
{
	r0->dw002C = r1 | r0->dw002C & ~0x86;
}

// 00009F44: void UARTParityModeGet()
void UARTParityModeGet()
{
}

// 00009F4C: void UARTConfigSet(Register (ptr32 Eq_8848) r0, Register uint32 r1, Register ui32 r2)
void UARTConfigSet(struct Eq_8848 * r0, uint32 r1, ui32 r2)
{
	do
	{
		ui32 r4_26 = r0->dw0018;
	} while ((r4_26 & 0x08) != 0x00);
	r0->dw002C &= ~0x10;
	r0->dw0030 = r0->dw0030 & ~0x0300 & ~0x01;
	uint32 r0_38 = SysCtlClockGet();
	uint32 r2_48 = r0_38 /u (r1 << 4);
	r0->dw0024 = r2_48;
	r0->dw0028 = (r0_38 - (r1 << 4) * r2_48 << 3) /u r1 + 0x01 >> 1;
	r0->dw002C = r2;
	r0->dw0018 = r4_26 & 0x08;
	r0->dw002C |= 0x10;
	r0->dw0030 = r0->dw0030 | 0x0300 | 0x01;
}

// 00009FA8: void UARTConfigGet(Register (ptr32 Eq_8928) r0, Register (ptr32 uint32) r1, Register (ptr32 ui32) r2)
void UARTConfigGet(struct Eq_8928 * r0, uint32 * r1, ui32 * r2)
{
	*r1 = (SysCtlClockGet() << 2) /u (r0->dw0028 + (r0->dw0024 << 0x06));
	*r2 = r0->dw002C & 0xEE;
}

// 00009FD4: void UARTEnable(Register (ptr32 Eq_8956) r0)
void UARTEnable(struct Eq_8956 * r0)
{
	r0->dw002C |= 0x10;
	r0->dw0030 = r0->dw0030 | 0x0300 | 0x01;
}

// 00009FEC: void UARTDisable(Register (ptr32 Eq_8975) r0)
void UARTDisable(struct Eq_8975 * r0)
{
	do
		;
	while (r0->dw0018 << 28 < 0x00);
	r0->dw002C &= ~0x10;
	r0->dw0030 = r0->dw0030 & ~0x0300 & ~0x01;
}

// 0000A00C: void UARTCharsAvail()
void UARTCharsAvail()
{
}

// 0000A018: void UARTSpaceAvail()
void UARTSpaceAvail()
{
}

// 0000A024: void UARTCharNonBlockingGet(Register (ptr32 Eq_9004) r0)
void UARTCharNonBlockingGet(struct Eq_9004 * r0)
{
	r0->dw0018 << 27 < 0x00;
}

// 0000A034: void UARTCharGet(Register (ptr32 Eq_9012) r0)
void UARTCharGet(struct Eq_9012 * r0)
{
	do
		;
	while (r0->dw0018 << 27 < 0x00);
}

// 0000A044: void UARTCharNonBlockingPut(Register (ptr32 Eq_9020) r0, Register word32 r1)
void UARTCharNonBlockingPut(struct Eq_9020 * r0, word32 r1)
{
	if (r0->dw0018 << 26 >= 0x00)
		r0->dw0000 = r1;
}

// 0000A054: void UARTCharPut(Register (ptr32 Eq_9032) r0, Register word32 r1)
void UARTCharPut(struct Eq_9032 * r0, word32 r1)
{
	do
		;
	while (r0->dw0018 << 26 < 0x00);
	r0->dw0000 = r1;
}

// 0000A064: void UARTBreakCtl(Register (ptr32 Eq_9044) r0, Register word32 r1)
void UARTBreakCtl(struct Eq_9044 * r0, word32 r1)
{
	ui32 r3_5 = r0->dw002C;
	if (r1 != 0x00)
		r0->dw002C = r3_5 | 0x01;
	else
		r0->dw002C = r3_5 & ~0x01;
}

// 0000A078: void UARTIntRegister(Register word32 r0, Register word32 r1)
void UARTIntRegister(word32 r0, word32 r1)
{
	IntRegister(22, r1);
	IntEnable(22);
}

word32 g_dwA094 = 0x4000C000;
// 0000A098: void UARTIntUnregister(Register word32 r0)
void UARTIntUnregister(word32 r0)
{
	IntDisable(22);
	IntUnregister(22);
}

word32 g_dwA0B4 = 0x4000C000;
// 0000A0B8: void UARTIntEnable(Register (ptr32 Eq_9084) r0, Register ui32 r1)
void UARTIntEnable(struct Eq_9084 * r0, ui32 r1)
{
	r0->dw0038 = r1 | r0->dw0038;
}

// 0000A0C0: void UARTIntDisable(Register (ptr32 Eq_9093) r0, Register word32 r1)
void UARTIntDisable(struct Eq_9093 * r0, word32 r1)
{
	r0->dw0038 &= ~r1;
}

// 0000A0CC: Register (ptr32 Eq_4521) UARTIntStatus(Register (ptr32 Eq_4521) r0, Register word32 r1)
// Called from:
//      vUART_ISR
struct Eq_4521 * UARTIntStatus(struct Eq_4521 * r0, word32 r1)
{
	if (r1 != 0x00)
		return r0->ptr0040;
	return r0->ptr003C;
}

// 0000A0D8: void UARTIntClear(Register (ptr32 Eq_4521) r0, Register Eq_2 r1)
// Called from:
//      vUART_ISR
void UARTIntClear(struct Eq_4521 * r0, Eq_2 r1)
{
	r0->t0044 = r1;
}

// 0000A0DC: void CPUcpsie()
// Called from:
//      IntMasterEnable
void CPUcpsie()
{
	__cps();
}

// 0000A0E4: void CPUcpsid()
// Called from:
//      IntMasterDisable
void CPUcpsid()
{
	__cps();
}

// 0000A0EC: void CPUwfi()
// Called from:
//      SysCtlSleep
//      SysCtlDeepSleep
void CPUwfi()
{
	__wait_for_interrupt();
}

// 0000A0F4: void I2CMasterInit(Register (ptr32 Eq_7943) r0, Register word32 r1)
// Called from:
//      OSRAMInit
void I2CMasterInit(struct Eq_7943 * r0, word32 r1)
{
	r0->dw0020 |= 0x10;
	uint32 r0_19 = SysCtlClockGet();
	uint32 r3_27 = g_dwA120;
	uint32 r2_28 = g_dwA124;
	if (r1 == 0x01)
		r3_27 = r2_28;
	r0->dw000C = (r0_19 - 0x01 + r3_27) /u r3_27 - 0x01;
}

uint32 g_dwA120 = 2000000;
uint32 g_dwA124 = 8000000;
// 0000A128: void I2CSlaveInit(Register (ptr32 Eq_9149) r0, Register word32 r1)
void I2CSlaveInit(struct Eq_9149 * r0, word32 r1)
{
	r0->dwFFFFF820 |= 0x20;
	r0->dw0004 = 0x01;
	r0->dw0000 = r1;
}

// 0000A140: void I2CMasterEnable(Register (ptr32 Eq_9166) r0)
void I2CMasterEnable(struct Eq_9166 * r0)
{
	r0->dw0020 |= 0x10;
}

// 0000A14C: void I2CSlaveEnable(Register (ptr32 Eq_9175) r0)
void I2CSlaveEnable(struct Eq_9175 * r0)
{
	r0->dwFFFFF820 |= 0x20;
	r0->dw0004 = 0x01;
}

// 0000A160: void I2CMasterDisable(Register (ptr32 Eq_9188) r0)
void I2CMasterDisable(struct Eq_9188 * r0)
{
	r0->dw0020 &= ~0x10;
}

// 0000A16C: void I2CSlaveDisable(Register (ptr32 Eq_9198) r0)
void I2CSlaveDisable(struct Eq_9198 * r0)
{
	r0->dw0004 = 0x00;
	r0->dwFFFFF820 &= ~0x20;
}

// 0000A180: void I2CIntRegister(Register word32 r1)
void I2CIntRegister(word32 r1)
{
	IntRegister(0x18, r1);
	IntEnable(0x18);
}

// 0000A194: void I2CIntUnregister()
void I2CIntUnregister()
{
	IntDisable(0x18);
	IntUnregister(0x18);
}

// 0000A1A8: void I2CMasterIntEnable(Register (ptr32 Eq_9225) r0)
void I2CMasterIntEnable(struct Eq_9225 * r0)
{
	r0->dw0010 = 0x01;
}

// 0000A1B0: void I2CSlaveIntEnable(Register (ptr32 Eq_9230) r0)
void I2CSlaveIntEnable(struct Eq_9230 * r0)
{
	r0->dw000C = 0x01;
}

// 0000A1B8: void I2CMasterIntDisable(Register (ptr32 Eq_9235) r0)
void I2CMasterIntDisable(struct Eq_9235 * r0)
{
	r0->dw0010 = 0x00;
}

// 0000A1C0: void I2CSlaveIntDisable(Register (ptr32 Eq_9240) r0)
void I2CSlaveIntDisable(struct Eq_9240 * r0)
{
	r0->dw000C = 0x00;
}

// 0000A1C8: Register (ptr32 Eq_7597) I2CMasterIntStatus(Register (ptr32 Eq_7597) r0, Register word32 r1)
// Called from:
//      OSRAMWriteArray
//      OSRAMWriteByte
//      OSRAMWriteFinal
struct Eq_7597 * I2CMasterIntStatus(struct Eq_7597 * r0, word32 r1)
{
	if (r1 != 0x00)
	{
		struct Eq_7597 * r0_6 = r0->ptr0018;
		struct Eq_7597 * r0_10 = r0_6;
		if (r0_6 != null)
			r0_10 = (struct Eq_7597 *) &g_dw0001;
		return r0_10;
	}
	else
	{
		struct Eq_7597 * r0_11 = r0->ptr0014;
		struct Eq_7597 * r0_12 = r0_11;
		if (r0_11 != null)
			r0_12 = (struct Eq_7597 *) &g_dw0001;
		return r0_12;
	}
}

// 0000A1E0: void I2CSlaveIntStatus(Register (ptr32 Eq_9263) r0, Register word32 r1)
void I2CSlaveIntStatus(struct Eq_9263 * r0, word32 r1)
{
	if (r1 != 0x00)
		r0->dw0014 == 0x00;
	else
		r0->dw0010 == 0x00;
}

// 0000A1F8: void I2CMasterIntClear(Register (ptr32 Eq_9277) r0)
void I2CMasterIntClear(struct Eq_9277 * r0)
{
	r0->dw001C = 0x01;
	r0->dw0018 = 0x01;
}

// 0000A200: void I2CSlaveIntClear(Register (ptr32 Eq_9286) r0)
void I2CSlaveIntClear(struct Eq_9286 * r0)
{
	r0->dw0018 = 0x01;
}

// 0000A208: void I2CMasterSlaveAddrSet(Register (ptr32 Eq_7597) r0, Register ui32 r1, Register ui32 r2)
// Called from:
//      OSRAMWriteFirst
void I2CMasterSlaveAddrSet(struct Eq_7597 * r0, ui32 r1, ui32 r2)
{
	r0->dw0000 = r2 | r1 << 0x01;
}

// 0000A210: void I2CMasterBusy()
void I2CMasterBusy()
{
}

// 0000A218: void I2CMasterBusBusy()
void I2CMasterBusBusy()
{
}

// 0000A220: void I2CMasterControl(Register (ptr32 Eq_7597) r0, Register word32 r1)
// Called from:
//      OSRAMWriteFirst
//      OSRAMWriteArray
//      OSRAMWriteByte
//      OSRAMWriteFinal
void I2CMasterControl(struct Eq_7597 * r0, word32 r1)
{
	r0->dw0004 = r1;
}

// 0000A224: void I2CMasterErr(Register (ptr32 Eq_9300) r0)
void I2CMasterErr(struct Eq_9300 * r0)
{
	ui32 r3_5 = r0->dw0004;
	if (r3_5 << 31 < 0x00 || (r3_5 & 0x02) == 0x00)
		;
}

// 0000A23C: void I2CMasterDataPut(Register (ptr32 Eq_7597) r0, Register ui32 r1)
// Called from:
//      OSRAMWriteFirst
//      OSRAMWriteArray
//      OSRAMWriteByte
//      OSRAMWriteFinal
void I2CMasterDataPut(struct Eq_7597 * r0, ui32 r1)
{
	r0->dw0008 = r1;
}

// 0000A240: void I2CMasterDataGet()
void I2CMasterDataGet()
{
}

// 0000A244: void I2CSlaveStatus()
void I2CSlaveStatus()
{
}

// 0000A248: void I2CSlaveDataPut(Register (ptr32 Eq_9316) r0, Register word32 r1)
void I2CSlaveDataPut(struct Eq_9316 * r0, word32 r1)
{
	r0->dw0008 = r1;
}

// 0000A24C: void I2CSlaveDataGet()
void I2CSlaveDataGet()
{
}

byte g_bA268 = 0x53;
Eq_2 g_aA284[] = 
	{
	};
ui32 g_aA2A4[] = 
	{
	};
word32 g_dwA2A8 = 0x0600;
Eq_7619 g_tA2F4 = 
	{
		0xE0,
		0xB0,
	};
Eq_7619 g_tA2FC = 
	{
		0x00,
		177,
	};
word32 * g_aA554[] = 
	{
	};
// subject_text_memcpy.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000A5C4: FlagGroup bool memcpy(Register Eq_2 r0, Register Eq_2 r1, Register Eq_122 r2, Register Eq_2 r4, Register Eq_2 r5, Register Eq_2 r6, Register Eq_2 r7, Register Eq_122 lr, Register out ptr32 r4Out, Register out ptr32 r5Out, Register out ptr32 r6Out, Register out ptr32 r7Out, Register out ptr32 lrOut)
// Called from:
//      prvCopyDataToQueue
//      prvCopyDataFromQueue
//      xQueueCRReceive
//      xQueueCRReceiveFromISR
bool memcpy(Eq_2 r0, Eq_2 r1, Eq_122 r2, Eq_2 r4, Eq_2 r5, Eq_2 r6, Eq_2 r7, Eq_122 lr, ptr32 & r4Out, ptr32 & r5Out, ptr32 & r6Out, ptr32 & r7Out, ptr32 & lrOut)
{
	Eq_2 r5_146 = r0;
	if (r2 > 0x0F)
	{
		if ((r1 | r0) << 30 != 0x00)
		{
			r5_146 = r0;
l0000A630:
			Eq_122 r3_101 = 0x00;
			do
			{
				Mem100[r5_146 + r3_101:byte] = SLICE(CONVERT(Mem97[r1 + r3_101:byte], byte, word32), byte, 0);
				r3_101 = (word32) r3_101 + 1;
			} while (r3_101 != r2);
l0000A63C:
			ptr32 r4_133;
			ptr32 r5_134;
			ptr32 r6_135;
			ptr32 r7_136;
			ptr32 lr_137;
			byte NZCV_142;
			lr();
			r4Out = r4_133;
			r5Out = r5_134;
			r6Out = r6_135;
			r7Out = r7_136;
			lrOut = lr_137;
			return SLICE(NZCV_142, bool, 2);
		}
		Eq_2 r4_27 = r1;
		Eq_2 r3_28 = r0;
		Eq_2 r5_35 = (word32) r0 + ((r2 - 0x10 >> 4) + 0x01 << 4);
		do
		{
			*r3_28 = *r4_27;
			*((word32) r3_28 + 4) = *((word32) r4_27 + 4);
			*((word32) r3_28 + 8) = *((word32) r4_27 + 8);
			*((word32) r3_28 + 0x0C) = *((word32) r4_27 + 0x0C);
			r3_28 = (word32) r3_28 + 16;
			r4_27 = (word32) r4_27 + 16;
		} while (r5_35 != r3_28);
		ui32 r6_54 = r2 - 0x10 & ~0x0F;
		r5_146 = (word32) r0 + (r6_54 + 0x10);
		r1 = (word32) r1 + (r6_54 + 0x10);
		if ((r2 & 0x0F) > 0x03)
		{
			uint32 r6_65 = (r2 & 0x0F) - 0x04;
			int32 r3_66 = 0x00;
			uint32 r4_68 = (r6_65 >> 2) + 0x01;
			do
			{
				*((word32) r5_146 + r3_66) = *((word32) r1 + r3_66);
				r3_66 += 0x04;
			} while (r3_66 != r4_68 << 2);
			union Eq_2 * r6_84 = r6_65 & ~0x03;
			r2 &= 0x03;
			r1 += r6_84 + 0x04;
			r5_146 += r6_84 + 0x04;
		}
		else
			r2 &= 0x0F;
	}
	if (r2 == 0x00)
		goto l0000A63C;
	goto l0000A630;
}

