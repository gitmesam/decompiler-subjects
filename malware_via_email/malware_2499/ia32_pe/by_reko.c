// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00411B71: Register uint32 fn00411B71(Register uint32 ecx, Register ui32 edx, Register out ptr32 edxOut)
uint32 fn00411B71(uint32 ecx, ui32 edx, ptr32 & edxOut)
{
	GetCommandLineA();
	uint32 eax_73 = 0x01 - edx + 0xC4 & dwLoc54;
	word32 edx_82;
	*edxOut = (word32) (SEQ(dwLoc016C, dwLoc8C + eax_73) + SEQ(dwLoc029C, eax_73));
	return 0x0A87;
}

// 00411DB0: Register ui32 fn00411DB0(Register ui32 ecx, Register (ptr word32) esi, Register ui32 edi, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
ui32 fn00411DB0(ui32 ecx, word32 * esi, ui32 edi, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	GetCursor();
	GetOEMCP();
	ui32 edx_31 = (byte) ((dwLoc01C0 ^ 0x00) + dwLoc01FC < 0x00) + (dwLocD4 + 0x034E) ^ dwLoc0138;
	uint32 ecx_87 = ((dwLoc0214 & 0x00 & dwLoc01B4) + 0x01 | edx_31) - edx_31 + edx_31;
	if (dwLoc0134 < ecx_87)
		dwLoc0120 = dwLoc0120 ^ ecx_87;
	Eq_66 eax_105 = LoadLibraryA(&globals->t40406D);
	if (eax_105 == 0x00)
		ExitProcess(0x00);
	ui32 v30_189 = dwLoc0130 & dwLoc84;
	Eq_66 dwLoc0284_239 = eax_105;
	do
	{
		memmove(fp - 44, dwLoc0284_239, 0x04);
		uint32 esi_271 = (edi | 181 | edi) - 0x1E00 ^ edi;
		dwLoc0284_239 = dwLoc0284_239 + 0x01;
		Eq_100 C_1827 = cond(esi_271);
		if (esi_271 <= 0x00)
		{
			dwLoc023C = dwLoc023C | 3770;
			edi = esi_271 + 4794;
			C_1827.u0 = false;
		}
		edi = (ui32) ((byte) C_1827 + (edi + dwLoc0198));
	} while (dwLoc2C != 0x33FFFFFF);
	ui32 edx_1807 = dwLoc01F8 - 0x1C01;
	if (dwLoc01F8 < 7989)
	{
		ui32 eax_1790 = (dwLoc01F8 - 0x1C01 ^ 0x66) + 0x13 + v30_189;
		dwLoc0250 = dwLoc0250 + 0x01;
		dwLoc0190 = dwLoc0190 + eax_1790;
		edx_1807 = dwLoc01F8 - 0x1C01 ^ eax_1790 ^ eax_1790;
	}
	uint32 eax_340 = dwLoc0190 ^ 3755;
	ui32 eax_353 = eax_340 + 0x0100 + (((edx_1807 - dwLoc01B8) - dwLoc0174) - (eax_340 < 0x0100));
	Eq_7 eax_337 = GetCommandLineA();
	VirtualAllocEx((void *) ~0x00, 0x00, 0x0600, dwLoc0170, dwLocAC);
	uint32 edx_1754 = eax_353 + 0x0340 & eax_353 + 0x0300;
	word32 ecx_398 = dwLoc0100 + edx_1754;
	uint32 ecx_1775 = (word32) (SEQ(ecx_398 + 0x01, ecx_398 + 0x01) + SEQ(dwLoc60, edx_1754)) ^ dwLocCC ^ edx_1754;
	word32 v63_410 = dwLoc0178 + edx_1754;
	if (ecx_1775 >= 0x00)
	{
		edx_1754 = ecx_1775 + 232 | dwLoc0110;
		ecx_1775 = (ecx_1775 - 0xCB | dwLoc01C4) - dwLoc01E0;
	}
	GetCursor();
	word32 edx_452;
	fn00411B71(ecx_1775, edx_1754 ^ dwLoc01F4 | dwLocCC, out edx_452);
	ui32 edx_467 = dwLoc01F8 & 0x00 ^ dwLoc026C;
	uint32 ecx_495 = (dwLoc023C ^ 0xA5) + dwLoc0180 ^ GetOEMCP();
	ui32 ecx_513 = v63_410 + dwLoc018C ^ dwLoc0250;
	ui32 edx_1723 = edx_467 + 0x19;
	if (ecx_513 + 0x01 > dwLoc01E4)
	{
		dwLoc010C = dwLoc010C & ecx_513 + 0x01;
		edx_1723 = dwLoc023C + 0xE0 + dwLoc0120;
	}
	up32 v82_550 = dwLoc0108 - edx_1723;
	Eq_35 eax_554 = GetOEMCP();
	if (0x00 - esi_271 + esi_271 < 0x01)
		dwLoc01D0 = v86;
	word32 eax_591;
	word32 edx_592;
	fn00412F4E(eax_554, out eax_591, out edx_592);
	Eq_290 eax_665 = IsChild(0xE7, dwLoc0188);
	if ((eax_665 & 0x00) != dwLoc01F8 - 0x01)
		dwLoc01D0 = dwLoc01D0 - (eax_665 | dwLoc0254);
	word32 eax_730;
	word32 edx_731;
	fn00412F4E(GetCursor(), out eax_730, out edx_731);
	ui32 esi_712 = (0xE7 - dwLocE8 & 0x0246) + 0x01;
	ui32 edi_715 = dwLoc010C & esi_712 - 0x01;
	Eq_85 v113_719 = dwLoc01F8 - 0x01 + (esi_712 - 0x01);
	IsChild(dwLoc58, v113_719);
	word32 ecx_772;
	fn00416E0A(v113_719, out ecx_772);
	GetVersionExA(fp - 0x0270);
	word32 edx_832 = eax_337 - (dwLocA0 & 0x00) + (dwLoc0214 - 0x01);
	Eq_85 ecx_1543 = dwLoc0214 - (CHAR *) 0x01;
	Eq_164 v137_817 = dwLoc01D0 - 0x01;
	uint32 edx_840 = (word32) (SEQ(dwLoc01CC, edx_832) - SEQ(edx_832, dwLocA0 & 0x00)) | dwLoc0214 - (CHAR *) 0x01;
	if (edx_840 == 0xFA)
		ecx_1543 = edx_840 + dwLoc60 + (edx_840 < 0xFA) + 0x4B;
	GetVersionExA(fp - 0x0104);
	word32 ecx_879;
	fn00416E0A(ecx_1543, out ecx_879);
	word32 ebx_920;
	word32 esi_921;
	ui32 edi_922;
	fn0041899F(VirtualAllocEx((void *) ~0x00, 0x00, 0x0400, dwLoc94, v137_817), edi_715, out ebx_920, out esi_921, out edi_922);
	*(fp - 0x0264) = *(fp - 0x0264) + 0xFD;
	ui32 eax_936 = *(fp - 0x0144) ^ 0xFD;
	*(fp - 0x0204) = *(fp - 0x0204) + eax_936;
	*(fp - 0x88) = eax_936;
	*(fp - 0x02DC) = 0x00;
	Eq_66 eax_1496 = GetModuleHandleA(*(fp - 0x02DC));
	uint32 edx_1501 = (*(fp - 252) | 0x0B26) + *(fp - 0x0110) ^ eax_1496;
	*(fp - 0x0110) = *(fp - 0x0110) | edx_1501;
	*(fp - 600) = *(fp - 600) & edx_1501;
	*(fp - 0x0208) = edx_1501;
	if (*(fp - 344) <= edx_1501)
	{
		ui32 eax_1490 = *(fp - 0x0234);
		*(fp - 0x0154) = *(fp - 0x0154) ^ eax_1490;
		eax_1496 = eax_1490 - (edx_1501 - 0x018E) - 0x01 & edx_1501 - 0x018E;
		edx_1501 = edx_1501 - 399 ^ eax_1496;
	}
	word32 ecx_975 = *(fp - 332);
	uint32 ecx_986 = (ecx_975 - *(fp - 0x5C) - ((((word32) eax_1496 + edx_1501) + ecx_975 & *(fp - 88)) - *(fp - 0x0224) < 0x00) ^ *(fp - 0x01F8)) + *(fp - 0x01B0) - *(fp - 0x88);
	word32 edx_985 = *(fp - 0x013C);
	ui32 ecx_990 = ecx_986 - *(fp - 600) - (ecx_986 < 0x00) & *(fp - 0x026C);
	ui32 eax_995 = 0xCE - *(fp - 0x0110) - *(fp - 0xEC);
	*(fp - 0xA0) = *(fp - 0xA0) + edi_922;
	*(fp - 0xB0) = *(fp - 0xB0) & edi_922;
	*(fp - 0x0130) = eax_995;
	*(fp - 332) = *(fp - 332) & eax_995;
	*(fp - 336) = *(fp - 336) + 0x01;
	*(fp - 220) = *(fp - 220) + eax_995;
	*(fp - 0x02E0) = *(fp - 0x011C);
	word32 edx_1016;
	word32 ecx_1017 = fn00411B71(ecx_990 + 0x01, edx_985 - 0x01, out edx_1016);
	ui32 edx_1021 = (*(fp - 244) ^ 177 ^ ecx_1017) + ecx_1017;
	*(fp - 0x0234) = *(fp - 0x0234) ^ edx_1021;
	ui32 ecx_1030 = ecx_1017 - 0x6C;
	if (edx_1021 != 0x00)
	{
		*(fp - 0x019C) = *(fp - 0x019C) + 0x01;
		*(fp - 0x0108) = *(fp - 0x0108) - 0x01;
		*(fp - 0x011C) = 0x00;
		ecx_1030 = 0x00;
		if (edx_1021 != 0x00)
			ecx_1030 = *(fp - 252) ^ 0x00;
	}
	GetOEMCP();
	uint32 edx_1047 = (ecx_1030 & 0x00 ^ 0x0B00) - 0x0E00;
	ui32 edx_1050 = edx_1047 - *(fp - 0x022C) - (edx_1047 < 0x00);
	*(fp - 616) = edx_1050;
	*(fp - 0x6C) = *(fp - 0x6C) ^ edx_1050;
	ui32 edx_1058 = (edx_1050 & *(fp - 0x0180)) + *(fp - 0xB0);
	*(fp - 0x80) = *(fp - 0x80);
	*(fp - 0xE0) = *(fp - 0xE0) & 0x00;
	*(fp - 388) = edx_1058;
	up32 ecx_1064 = 0x00 - edx_1058;
	*(fp - 0x9C) = (word32) ((byte) (ecx_1064 < 0x0D00) + (*(fp - 0x9C) + edx_1058));
	ui32 edi_1073 = (eax_995 | 0x0BFF) & 0x00;
	*(fp - 0x0230) = *(fp - 0x0230) - (edi_1073 + 0x01);
	*(fp - 0x68) = *(fp - 0x68) | edi_1073 + 0x01;
	*(fp - 0x0138) = edi_1073 + 0x01;
	uint32 edx_1082 = *(fp - 0x023C);
	*(fp - 0xB4) = (word32) ((byte) (edx_1082 < 0x00) + (*(fp - 0xB4) + 4000));
	*(fp - 0x020C) = *(fp - 0x020C) ^ 4000;
	*(fp - 0x01F8) = *(fp - 0x01F8) + 4000;
	*(fp - 0x0214) = *(fp - 0x0214) + (edx_1082 & 4000);
	ui32 edi_1096 = edx_1082 & 4000 & *(fp - 0x01E0);
	*(fp - 0xC4) = *(fp - 0xC4) + 0x01;
	*(fp - 0x0108) = *(fp - 0x0108) - 0x01;
	*(fp - 0x02E4) = edx_1082;
	*(fp - 744) = *(fp - 0xD0);
	*(fp - 0x02EC) = edi_1096;
	*(fp - 0x02F0) = *(fp - 0x01D4);
	word32 ecx_1113;
	fn00416E0A(ecx_1064 - 0x0D00, out ecx_1113);
	uint32 edx_1119 = *(fp - 0xB0) - *(fp - 0x0168);
	*(fp - 220) = *(fp - 220) ^ edx_1119 + 0x01;
	up32 v181_1124 = *(fp - 0x01DC) + (edx_1119 + 0x01);
	*(fp - 0x01DC) = v181_1124;
	*(fp - 0x88) = (word32) ((byte) (v181_1124 < 0x00) + (*(fp - 0x88) + (edx_1119 + 0x01)));
	if (edx_1119 - 0x0ABD != *(fp - 0x01F8))
	{
		*(fp - 500) = 0x00;
		if (edx_1119 - 0x0ABD < *(fp - 0xF0))
		{
l004128B1:
			*(fp - 0x02F4) = 0x00;
			GetModuleHandleA(*(fp - 0x02F4));
			ui32 ecx_1154 = ecx_1113 + 0xFE & 0x01;
			up32 eax_1158 = 0x01 - *(fp - 0x6C) - 0x01 + ecx_1154;
			*(fp - 244) = (word32) ((byte) (eax_1158 < 0x00) + (*(fp - 244) + eax_1158));
			*(fp - 232) = *(fp - 232) - eax_1158;
			uint32 ecx_1172 = ecx_1154 - 0xA2 + (eax_1158 + 0x01);
			ui32 ecx_1176 = ecx_1172 + 0x2F - *(fp - 0x54) - (ecx_1172 < 0x2F);
			if (eax_1158 != ~0xA0)
			{
				*(fp - 0x01DC) = *(fp - 0x01DC) - ecx_1176;
				*(fp - 0x0228) = *(fp - 0x0228) + 0x01;
				*(fp - 488) = *(fp - 488);
				*(fp - 100) = *(fp - 100) & 0x00;
				ecx_1176 = 0x00;
			}
			ui32 ecx_1190;
			fn00416E0A(ecx_1176 + 0x1F, out ecx_1190);
			ui32 edx_1197 = (*(fp - 292) ^ 0x48) + *(fp - 0x0164) & ecx_1190 - 0x48;
			*(fp - 0x0128) = edx_1197;
			*(fp - 484) = *(fp - 484) | edx_1197;
			*(fp - 0x023C) = *(fp - 0x023C) - edx_1197;
			*(fp - 0x70) = *(fp - 0x70) ^ edx_1197;
			ui32 ecx_1193 = ecx_1190 - 0x48;
			if (edx_1197 == *(fp - 0xA8))
			{
				*(fp - 404) = *(fp - 404) + 0x01;
				*(fp - 0x0260) = *(fp - 0x0260) + 0x01;
				*(fp - 424) = *(fp - 424);
				*(fp - 0x01DC) = *(fp - 0x01DC);
				ui32 edx_1382 = edx_1197 ^ edx_1197 - 0x01;
				*(fp - 0x0230) = *(fp - 0x0230) + edx_1382;
				*(fp - 0x01C4) = *(fp - 0x01C4) + 0x01;
				*(fp - 0x023C) = *(fp - 0x023C) ^ edx_1382;
				*(fp - 0x0244) = *(fp - 0x0244) - edx_1382;
				ecx_1193 = edx_1197 + 0x56;
			}
			*(fp - 0x02F8) = *(fp - 0x013C);
			*(fp - 0x02FC) = *(fp - 0x0270);
			IsChild(*(fp - 0x02FC), *(fp - 0x02F8));
			*(fp - 0x70) = (word32) ((byte) ((*(fp - 600) + 0x18FF & *(fp - 0x0238)) < 0x0FD5) + (*(fp - 0x70) + 0x0FD5));
			*(fp - 0x021C) = *(fp - 0x021C) - 0x01;
			uint32 eax_1253 = *(fp - 0xA0) ^ *(fp - 0x0270);
			*(fp - 388) = *(fp - 388) - 0x01;
			ui32 ecx_1220 = ecx_1193 + 0x4E;
			if (eax_1253 >= 6656)
			{
				*(fp - 0x88) = *(fp - 0x88) & 0x00;
				*(fp - 0x0230) = 0x00;
				if (eax_1253 != 3364)
				{
l00412A34:
					word32 edx_1288;
					word32 edi_1289;
					ui32 eax_1290 = fn0041736A(ecx_1220, out edx_1288, out edi_1289);
					*(fp - 0x01B4) = *(fp - 0x01B4) - 0x01;
					ui32 ecx_1293 = (eax_1290 | 232) + eax_1290;
					*(fp - 0x0224) = *(fp - 0x0224) + ecx_1293;
					ui32 eax_1299 = *(fp - 0x0204);
					return ecx_1293 - eax_1299 + 0x01 ^ eax_1299;
				}
			}
			goto l00412A34;
		}
		*(fp - 444) = *(fp - 444) | edx_1119 - 0x0ABD;
		up32 v184_1445 = *(fp - 0x0270) - (edx_1119 - 0x0ABD);
		*(fp - 0x0270) = v184_1445;
		up32 v185_1449 = (byte) (v184_1445 < 0x00) + (*(fp - 0x8C) + (edx_1119 - 0x0ABD));
		*(fp - 0x8C) = v185_1449;
		*(fp - 0x01F0) = *(fp - 0x01F0) - (edx_1119 - 0x0ABD) - (v185_1449 < 0x00);
		*(fp - 0x6C) = *(fp - 0x6C) + 0x01;
	}
	goto l004128B1;
}

// 00412F4E: FlagGroup byte fn00412F4E(Register Eq_35 eax, Register out ptr32 eaxOut, Register out ptr32 edxOut)
byte fn00412F4E(Eq_35 eax, ptr32 & eaxOut, ptr32 & edxOut)
{
	uint32 edx_141 = (0x00 - dwLoc013C | eax) - 212 + dwLoc90 - dwLoc0284;
	if (edx_141 >= 0x0FD5)
		edx_141 = edx_141 + 0xC2;
	VirtualAllocEx((void *) ~0x00, 0x00, 0x0600, dwLoc020C, dwLoc028C);
	uint32 edx_35 = edx_141 - dwLoc0138;
	uint32 edx_70 = edx_35 + dwLocE0;
	uint32 eax_67 = (dwLoc9C - 0x01 & dwLoc018C) - dwLoc34 & edx_35;
	*eaxOut = eax_67;
	uint32 edx_116 = edx_70 + 0x01;
	byte C_126 = cond(eax_67);
	if (eax_67 > 0x00)
	{
		uint32 eax_103 = eax_67 - 0x01 - (edx_70 + 0x01);
		edx_116 = eax_103 - 0x36 - dwLoc027C;
		ui32 eax_123 = ((eax_103 ^ edx_116) + 0x0E00 & edx_116) - edx_116;
		*eaxOut = eax_123;
		C_126 = cond(eax_123);
	}
	ui32 edx_92 = (((word32) dwLoc020C + edx_116 + C_126 | dwLoc01C8) & dwLoc0100) + dwLoc016C;
	*edxOut = edx_92;
	return cond(edx_92);
}

// 0041324C: Register Eq_164 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	GetModuleHandleA(null);
	byte cl_12;
	byte ch_13;
	byte * edx_14;
	ptr32 ebx_15;
	word32 ebp_16;
	struct Eq_1716 * esi_17;
	word32 edi_18;
	byte * eax_19 = fn0041560A(ecx, fp - 0x04, out cl_12, out ch_13, out edx_14, out ebx_15, out ebp_16, out esi_17, out edi_18);
	byte al_20 = (byte) eax_19;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	*eax_19 = *eax_19 + al_20;
	cu8 * eax_241 = esi_17->ptr0000;
	byte al_242 = (byte) eax_241;
	*eax_241 = *eax_241 + al_242;
	null[eax_241].b0000 = null[eax_241].b0000 + al_242;
	*eax_241 = *eax_241 + al_242;
	*eax_241 = *eax_241 + al_242;
	byte cl_235 = cl_12 + SLICE(eax_19, byte, 8);
	byte * ecx_236 = DPB(ecx, cl_235, 0);
	*ecx_236 = *ecx_236 + ch_13;
	byte al_258;
	byte ah_259;
	__aas(al_242, SLICE(eax_241, byte, 8), &al_258, &ah_259);
	*eax_241 = *eax_241 + al_258;
	__outdw(dx, eax_241);
	*eax_241 = *eax_241 + al_258;
	*eax_241 = *eax_241 + al_258;
	*eax_241 = *eax_241 + al_258;
	*eax_241 = *eax_241 + al_258;
	cu8 v136_277 = *eax_241 + al_258;
	*eax_241 = v136_277;
	byte bh_270 = SLICE(ebx_15 - 0x01, byte, 8);
	*eax_241 = *eax_241 + al_258;
	*eax_241 = *eax_241 + al_258;
	*eax_241 = *eax_241 + al_258;
	esi_17->b140C = esi_17->b140C + ah_259;
	*eax_241 = *eax_241 + al_258;
	*eax_241 = *eax_241 + al_258;
	byte ah_293 = ah_259 + al_258;
	cu8 * eax_294 = DPB(eax_241, ah_293, 8);
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	byte * edi_303 = *(fp - 0x66);
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	*(ebx_15 - 0x01) = *(ebx_15 - 0x01) + ch_13;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	byte ch_317 = ch_13 + cl_235;
	byte * ecx_318 = DPB(ecx_236, ch_317, 8);
	Mem322[ecx_318 + eax_294:byte] = Mem320[ecx_318 + eax_294:byte] + bh_270;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + al_258;
	*eax_294 = *eax_294 + cl_235;
	*eax_294 = *eax_294 + al_258;
	cu8 v164_337 = *eax_294 + al_258;
	*eax_294 = v164_337;
	*edi_303 = *edi_303 + ch_317;
	*(fp - 0x66) = (byte **) edx_14;
	__lock();
	byte al_341 = al_258 + (v164_337 < 0x00);
	__outb(0x1C, al_341);
	DWORD eax_342 = DPB(eax_294, al_341, 0);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	esi_17->b000C = esi_17->b000C + cl_235;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	esi_17->b000C = esi_17->b000C + dh;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*edx_14 = *edx_14 + ch_317;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*(fp - 0x6A) = ~0x37;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	esi_17->b91F6000C = esi_17->b91F6000C + ah_293;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	cu8 v183_383 = (word32) *eax_342 + al_341;
	*eax_342 = (Eq_164) v183_383;
	if (v183_383 <= 0x00)
	{
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		__outb(dx, al_341);
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		esi_17->b000D = esi_17->b000D + dl;
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
		*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	}
	*edx_14 = *edx_14 + dl;
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	*eax_342 = (Eq_164) ((word32) *eax_342 + al_341);
	return eax_342;
}

// 0041560A: Register ui32 fn0041560A(Register word32 ecx, Register ptr32 ebp, Register out Eq_1723 clOut, Register out Eq_1724 chOut, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
ui32 fn0041560A(word32 ecx, ptr32 ebp, Eq_1723 & clOut, Eq_1724 & chOut, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	uint32 eax_20 = 1700 - *(ebp - 88) + ecx;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	if (*(ebp - 88) <= eax_20)
	{
		*(ebp - 0x54) = 0x04;
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		*(ebp - 0x54) = *(ebp - 0x54) - 0x04 - (*(ebp - 88) < eax_20);
		eax_20 = (eax_20 & *(ebp - 88)) + *(ebp - 88);
	}
	ui32 eax_21 = eax_20 | *(ebp - 0x54);
	*(ebp - 0x50) = *(ebp - 0x50) & 0x00;
	if (eax_21 * 0x02 == 0x0FBF)
	{
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		*(ebp - 0x54) = eax_21 * 0x02;
		up32 v17_2612 = (byte) (eax_21 * 0x02 < 0x0FBF) + (*(ebp - 0x54) + eax_21 * 0x02);
		*(ebp - 0x54) = v17_2612;
		*(ebp - 0x50) = (word32) ((byte) (v17_2612 < 0x00) + (*(ebp - 0x50) + eax_21 * 0x02));
		*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
		word32 eax_2620 = *(ebp - 0x50);
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		uint32 edx_2627 = eax_21 * 0x02 - (((eax_2620 + 0x01 | eax_21 * 0x02) ^ eax_21 * 0x02) & *(ebp - 0x50));
		*(ebp - 88) = (word32) ((byte) (edx_2627 < 0x00) + (*(ebp - 88) + edx_2627));
		*(ebp - 88) = *(ebp - 88) - edx_2627;
		*(ebp - 88) = *(ebp - 88) | edx_2627;
		*(ebp - 88) = *(ebp - 88) - edx_2627;
		*(ebp - 88) = *(ebp - 88) + edx_2627;
	}
	Eq_35 eax_43 = GetOEMCP();
	up32 edx_46 = *(ebp - 88) + 889;
	*(ebp - 0x50) = edx_46;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	*(ebp - 0x50) = (word32) ((byte) (edx_46 < 0x00) + (*(ebp - 0x50) + edx_46));
	ui32 edx_54 = edx_46 ^ eax_43;
	if (edx_54 == 0x0899)
	{
		*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
		*(ebp - 0x54) = *(ebp - 0x54);
		*(ebp - 0x50) = *(ebp - 0x50) & 0x00;
		*(ebp - 88) = (edx_54 + 0x0900 & (0x00 - (edx_54 + 0x0900) ^ edx_54 + 0x0900) - *(ebp - 88)) - 0x01;
	}
	*(ebp - 0x54) = *(ebp - 0x54) + 0x20;
	*(ebp - 0x54) = *(ebp - 0x54) + 0x20;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	*(ebp - 88) = *(ebp - 88) & 116;
	*(ebp - 0x50) = *(ebp - 0x50) | 116;
	*(ebp - 0x54) = *(ebp - 0x54) - 116;
	*(ebp - 0x50) = *(ebp - 0x50) ^ 0x20;
	*(ebp - 88) = *(ebp - 88) ^ 116;
	ui32 ecx_102 = (0x0EF5 - *(ebp - 0x50) & 116) + 0x01;
	*(ebp - 88) = *(ebp - 88) - 0x01;
	up32 v40_106 = *(ebp - 88) - (ecx_102 - 0x01);
	*(ebp - 88) = v40_106;
	*(ebp - 88) = (word32) ((byte) (v40_106 < 0x00) + (*(ebp - 88) + (ecx_102 - 0x01)));
	uint32 eax_117 = 116;
	if (ecx_102 + 0xE7 < *(ebp - 0x50))
	{
		*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
		*(ebp - 88) = *(ebp - 88);
		eax_117 = 0xCB - *(ebp - 0x50);
	}
	ui32 edx_121 = ((*(ebp - 0x54) ^ 0x00) & *(ebp - 0x54)) + eax_117;
	*(ebp - 0x54) = *(ebp - 0x54) | edx_121;
	uint32 edx_128 = edx_121 - ((eax_117 & edx_121) + 0x7B);
	if (edx_128 == 0x1D)
	{
		*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
		if (*(ebp - 88) <= edx_128)
		{
l0041575D:
			uint32 ecx_141 = *(ebp - 0x54) & edx_128 | edx_128;
			*(ebp - 0x50) = *(ebp - 0x50) + ecx_141;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			if (ecx_141 <= 0xC5)
			{
				*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
				edx_128 = 0x0276 - *(ebp - 0x54);
			}
			*(ebp - 0x50) = *(ebp - 0x50) + 110;
			*(ebp - 88) = *(ebp - 88) | 110;
			uint32 edx_166 = edx_128 + 0x01;
			uint32 eax_171 = 110 - *(ebp - 88) & (edx_166 ^ 110);
			*(ebp - 0x54) = eax_171;
			*(ebp - 88) = eax_171;
			*(ebp - 0x50) = *(ebp - 0x50) ^ eax_171;
			*(ebp - 0x54) = *(ebp - 0x54) ^ eax_171;
			ui32 edx_167 = edx_166 ^ 110;
			if (*(ebp - 88) <= eax_171)
			{
				up32 v55_2511 = *(ebp - 0x54);
				*(ebp - 0x54) = v55_2511;
				*(ebp - 88) = *(ebp - 88) - (v55_2511 < 0x00);
				*(ebp - 88) = *(ebp - 88) & 0x00;
				ui32 edx_2520 = *(ebp - 0x50) & 0x00;
				*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
				uint32 edx_2525 = (edx_2520 & *(ebp - 0x54)) + *(ebp - 0x50);
				edx_167 = edx_2525 + *(ebp - 0x54) + (edx_2525 < 0x00) + *(ebp - 88);
			}
			*(ebp - 0x50) = *(ebp - 0x50);
			*(ebp - 88) = *(ebp - 88);
			*(ebp - 88) = *(ebp - 88) - 0x01;
			ui32 eax_200 = *(ebp - 0x54);
			ui32 ecx_201 = ((eax_171 | ~0x00) ^ eax_171) - *(ebp - 0x54) | eax_200;
			*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
			ui32 ecx_209 = ecx_201 ^ eax_200 ^ eax_200 | eax_200 | eax_200;
			*(ebp - 0x54) = *(ebp - 0x54) + ecx_209;
			*(ebp - 88) = ecx_209;
			up32 v65_216 = *(ebp - 88) - ecx_209;
			*(ebp - 88) = v65_216;
			*(ebp - 88) = (word32) ((byte) (v65_216 < 0x00) + (*(ebp - 88) + ecx_209));
			ui32 eax_222 = *(ebp - 88);
			ui32 edx_223 = edx_167 | eax_222;
			*(ebp - 88) = *(ebp - 88) | edx_223;
			*(ebp - 0x54) = *(ebp - 0x54) | edx_223;
			uint32 eax_232 = eax_222 - *(ebp - 0x50) + *(ebp - 0x50);
			ui32 eax_239 = (eax_232 - *(ebp - 0x50) - (eax_232 < 0x00) + *(ebp - 0x54) ^ 0x00) - 0x01;
			up32 v69_242 = *(ebp - 88) - ~0x08FF;
			*(ebp - 88) = v69_242;
			ui32 edx_252 = 0x04FB - *(ebp - 88) - ((byte) (v69_242 < 0x00) + (*(ebp - 0x54) + ~0x08FF) < 0x00) + ecx_209 + ecx_209;
			*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) + ecx_209;
			*(ebp - 0x50) = *(ebp - 0x50) & edx_252;
			uint32 edx_261 = edx_252 - 0x1500 & ecx_209;
			Eq_4049 C_2508 = cond(edx_261 - 0x0C20);
			if (edx_261 == 0x0C20)
			{
				*(ebp - 0x54) = *(ebp - 0x54);
				*(ebp - 0x50) = *(ebp - 0x50);
				ecx_209 = 0x00;
				C_2508 = cond(edx_261 - 0x0936);
			}
			*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
			*(ebp - 88) = (word32) C_2508 + (*(ebp - 88) + ecx_209);
			uint32 ecx_2445 = ecx_209 - 0x90;
			uint32 edx_285 = 0x0444 - *(ebp - 0x54) - (ecx_2445 < 0x00) - ecx_2445;
			*(ebp - 0x50) = edx_285;
			*(ebp - 0x54) = *(ebp - 0x54) - edx_285;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) & edx_285;
			*(ebp - 88) = *(ebp - 88) ^ ecx_2445;
			if (*(ebp - 0x50) <= edx_285)
			{
				ecx_2445 = *(ebp - 0x54) ^ ~0xEE | *(ebp - 0x50);
				uint32 edx_2481 = edx_285 + ecx_2445;
				*(ebp - 0x54) = *(ebp - 0x54) | edx_2481;
				*(ebp - 88) = *(ebp - 88) | edx_2481;
			}
			up32 v83_308 = *(ebp - 88);
			*(ebp - 88) = v83_308;
			*(ebp - 0x54) = *(ebp - 0x54) - (v83_308 < 0x00);
			up32 edx_315 = ~0x00 - ecx_2445;
			if (edx_315 + 0x01 != *(ebp - 0x50))
			{
				word32 ecx_2449 = *(ebp - 88);
				up32 v85_2450 = *(ebp - 0x54) + ecx_2449;
				*(ebp - 0x54) = v85_2450;
				*(ebp - 88) = ecx_2449;
				*(ebp - 0x50) = (word32) ((byte) (v85_2450 < 0x00) + (*(ebp - 0x50) + ecx_2449));
				ecx_2445 = ecx_2449 - 0x01 ^ edx_315 + 0x01 ^ *(ebp - 0x50);
				*(ebp - 0x54) = *(ebp - 0x54) + (edx_315 + 0x01);
				if (edx_315 < ~0x09D9)
				{
l004158E7:
					uint32 edx_331 = *(ebp - 88) + 202 + eax_239;
					*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
					*(ebp - 0x54) = *(ebp - 0x54) | edx_331 - 0x01;
					ui32 ecx_2405 = ecx_2445 - (edx_315 + 0x01) + (edx_315 + 0x01) | edx_315 + 0x01;
					ui32 edx_2358 = edx_331 - 0x01;
					if (edx_331 != 0x0FB5)
					{
						*(ebp - 0x50) = *(ebp - 0x50);
						*(ebp - 88) = *(ebp - 88) - 0x01;
						ui32 eax_2423 = edx_331 - 0x01 + *(ebp - 0x54);
						if (edx_331 - 0x01 >= *(ebp - 0x50))
							*(ebp - 88) = *(ebp - 88) ^ eax_2423 - 0x01;
					}
					ui32 eax_352 = *(ebp - 0x50) ^ ecx_2405;
					*(ebp - 88) = *(ebp - 88) - eax_352;
					uint32 eax_356 = eax_352 - ecx_2405;
					if (eax_356 == 0x00)
					{
						ui32 ecx_2399 = *(ebp - 88);
						*(ebp - 0x50) = (word32) ((byte) (eax_356 < 0x00) + (*(ebp - 0x50) + ecx_2399));
						*(ebp - 88) = ecx_2399;
						*(ebp - 0x54) = *(ebp - 0x54) + ecx_2399;
						ecx_2405 = ecx_2399 & eax_356;
						if (*(ebp - 0x50) <= eax_356)
							*(ebp - 88) = *(ebp - 88) ^ eax_356;
					}
					*(ebp - 88) = *(ebp - 88) | 226;
					*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
					*(ebp - 0x54) = *(ebp - 0x54) & 226;
					*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
					*(ebp - 88) = *(ebp - 88) + 0x01;
					ui32 ecx_2390 = ecx_2405 - 0x4C;
					if (false)
					{
						*(ebp - 0x50) = *(ebp - 0x50) | ecx_2390;
						ui32 ecx_2374 = (*(ebp - 0x54) & 166) - *(ebp - 88);
						ui32 eax_2376 = ecx_2374 | ~0x18A9 | ecx_2374;
						*(ebp - 0x50) = *(ebp - 0x50) & eax_2376;
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
						*(ebp - 88) = *(ebp - 88) & eax_2376;
						*(ebp - 0x54) = *(ebp - 0x54) - eax_2376;
						ecx_2390 = ecx_2374 | *(ebp - 88);
					}
					ui32 ecx_399 = ecx_2390 - *(ebp - 0x50);
					*(ebp - 0x54) = *(ebp - 0x54) | edx_331 - 0x01;
					up32 v109_407 = *(ebp - 0x54) - (edx_331 - 0x01);
					*(ebp - 0x54) = v109_407;
					*(ebp - 0x50) = *(ebp - 0x50) - (edx_331 - 0x01) - (v109_407 < 0x00);
					*(ebp - 88) = *(ebp - 88) & 0x4F;
					uint32 eax_417 = (edx_331 - 0x01 | 0x4F) - (edx_331 - 0x01);
					if (eax_417 < 22)
					{
						*(ebp - 0x54) = *(ebp - 0x54) & eax_417;
						*(ebp - 0x50) = *(ebp - 0x50) ^ eax_417;
						*(ebp - 88) = *(ebp - 88) & eax_417;
						edx_2358 = *(ebp - 0x50) | ~0x8D;
						*(ebp - 88) = *(ebp - 88) - 0x01;
					}
					ui32 edx_2322 = edx_2358 & 0x00;
					uint32 eax_431 = (0x00 - *(ebp - 88) | edx_2322) - 0x01 - edx_2322;
					*(ebp - 88) = (word32) ((byte) (eax_431 < 0x00) + (*(ebp - 88) + eax_431));
					*(ebp - 0x54) = *(ebp - 0x54) + eax_431;
					*(ebp - 88) = v118;
					ui32 eax_2338 = eax_431 & edx_2322;
					if (true)
					{
						edx_2322 = *(ebp - 88) + 0x0104 + *(ebp - 0x50);
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						ui32 eax_2325 = eax_2338 + edx_2322 + edx_2322 + 100 | edx_2322;
						*(ebp - 0x50) = *(ebp - 0x50) | eax_2325;
						*(ebp - 88) = *(ebp - 88) + eax_2325;
						*(ebp - 0x54) = edx_2322;
						*(ebp - 0x54) = *(ebp - 0x54) | eax_2325;
						eax_2338 = eax_2325 & edx_2322;
					}
					*(ebp - 0x54) = *(ebp - 0x54) + eax_2338;
					*(ebp - 0x50) = *(ebp - 0x50) ^ eax_2338;
					*(ebp - 88) = *(ebp - 88) ^ eax_2338;
					*(ebp - 0x54) = *(ebp - 0x54) - edx_2322;
					uint32 eax_470 = *(ebp - 88) + *(ebp - 0x50) - 0xC2 - edx_2322;
					if (eax_470 >= 0x86)
					{
						*(ebp - 0x50) = *(ebp - 0x50) ^ 0x00;
						ui32 eax_2306 = eax_470 ^ ((eax_470 ^ 0x00 | eax_470) + *(ebp - 0x50) ^ *(ebp - 0x54));
						*(ebp - 0x50) = *(ebp - 0x50) + eax_2306;
						*(ebp - 0x54) = *(ebp - 0x54) + eax_2306;
					}
					ui32 eax_482 = *(ebp - 88);
					*(ebp - 0x50) = eax_482 - 0x01;
					*(ebp - 88) = *(ebp - 88) + (eax_482 - 0x01);
					ui32 eax_487 = eax_482 - 0x01 & ecx_399;
					*(ebp - 0x50) = *(ebp - 0x50) + (eax_487 + 0x1500);
					ui32 eax_2267 = eax_487 + 0x1500;
					if (*(ebp - 0x50) < eax_487 + 0x1500)
					{
						*(ebp - 88) = ecx_399;
						*(ebp - 0x50) = *(ebp - 0x50) + ecx_399;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						*(ebp - 88) = 0x00;
						ui32 eax_2275 = eax_487 + 0x1500 ^ ecx_399;
						*(ebp - 0x54) = eax_2275 + 0x01;
						*(ebp - 0x54) = eax_2275 + 0x01;
						*(ebp - 0x54) = *(ebp - 0x54) + (eax_2275 + 0x01);
						eax_2267 = eax_2275 + 0x01;
					}
					*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
					uint32 ecx_504 = eax_2267 & 0x01;
					if (ecx_504 == *(ebp - 88))
					{
						word32 eax_2260 = *(ebp - 88);
						*(ebp - 0x54) = *(ebp - 0x54) + eax_2260;
						*(ebp - 0x54) = eax_2260;
						eax_2267 = eax_2260 + 0x0EE7 - *(ebp - 0x50) - *(ebp - 0x54);
						*(ebp - 0x50) = *(ebp - 0x50) + ecx_504;
					}
					ui32 ecx_513 = ecx_504 & eax_2267;
					ui32 edx_516 = 0x00 - *(ebp - 0x54) | ecx_513;
					*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
					if (((edx_516 | ecx_513 | ecx_513) & *(ebp - 88)) <= *(ebp - 88))
					{
						*(ebp - 0x54) = *(ebp - 0x54) | 2472;
						*(ebp - 88) = *(ebp - 88) + 2472;
					}
					GetCommandLineA();
					*(ebp - 0x54) = (union Eq_66 *) GetModuleHandleA(null);
					GetOEMCP();
					GetOEMCP();
					VirtualAllocEx((void *) ~0x00, 0x00, 0x0B00, *(ebp - 0x54), *(ebp - 88));
					Eq_85 esi_559 = *(ebp - 88);
					IsChild(esi_559, *(ebp - 0x54));
					*(ebp - 0x50) = (union Eq_35 *) GetCursor();
					GetVersionExA(ebp - 0x50);
					*(ebp - 0x50) = (union Eq_35 *) GetOEMCP();
					GetVersionExA(ebp - 88);
					*(ebp - 0x54) = (int32) GetVersionExA(ebp - 0x50);
					Eq_5370 edx_2227 = ebp - 0x50;
					uint32 ecx_585 = ebp - 0x50 ^ ebp - 0x50;
					if (ecx_585 <= 0x18E3)
					{
						*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						*(ebp - 0x54) = 0x00;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						ui32 edx_2216 = *(ebp - 88) ^ ~0x00 ^ *(ebp - 88);
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						up32 v148_2221 = *(ebp - 0x50) - edx_2216;
						*(ebp - 0x50) = v148_2221;
						*(ebp - 0x50) = *(ebp - 0x50) - edx_2216 - (v148_2221 < 0x00);
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
						edx_2227 = edx_2216 & (ecx_585 + 0x2A00 & edx_2216);
						*(ebp - 0x50) = *(ebp - 0x50) & edx_2227;
						*(ebp - 0x54) = (word32) edx_2227 + *(ebp - 0x54);
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
					}
					*(ebp - 0x54) = *(ebp - 0x54) | edx_2227;
					*(ebp - 88) = (word32) edx_2227 + *(ebp - 88);
					*(ebp - 0x54) = *(ebp - 0x54) ^ edx_2227;
					*(ebp - 0x50) = *(ebp - 0x50) & edx_2227;
					*(ebp - 0x54) = (union Eq_5370 *) edx_2227;
					*(ebp - 0x50) = (union Eq_35 *) GetOEMCP();
					Eq_66 eax_613 = GetModuleHandleA(null);
					*(ebp - 0x50) = (union Eq_66 *) eax_613;
					ui32 ecx_619 = *(ebp - 0x54) ^ 0x26;
					*(ebp - 0x50) = *(ebp - 0x50) ^ ecx_619 + 0x07;
					*(ebp - 0x54) = *(ebp - 0x54) - (ecx_619 + 0x07);
					ui32 ecx_2192 = ecx_619 + 131;
					if (*(ebp - 88) > ecx_619 + 131)
					{
						*(ebp - 0x54) = *(ebp - 0x54);
						uint32 ecx_2191 = ecx_619 + 131 ^ 0x00;
						ecx_2192 = ecx_2191 - 0x01;
						if (ecx_2191 - 0x01 >= *(ebp - 0x54))
							*(ebp - 88) = *(ebp - 88) ^ ecx_2191 - 0x01;
					}
					ui32 ecx_637 = ecx_2192 | *(ebp - 0x50);
					*(ebp - 0x50) = *(ebp - 0x50) + (eax_613 ^ 0x0D33);
					*(ebp - 0x54) = *(ebp - 0x54) + (eax_613 ^ 0x0D33);
					*(ebp - 88) = *(ebp - 88) + (eax_613 ^ 0x0D33);
					*(ebp - 88) = *(ebp - 88) - 0x01;
					ui32 edx_668 = *(ebp - 0x54) - 0x01 | ecx_637;
					*(ebp - 0x54) = *(ebp - 0x54) & ecx_637;
					*(ebp - 0x54) = *(ebp - 0x54) - ecx_637;
					uint32 ecx_674 = ecx_637 + *(ebp - 88);
					ui32 ecx_677 = ecx_674 + *(ebp - 0x50) + (ecx_674 < 0x00);
					uint32 edx_684 = (edx_668 + ecx_677 - 116 | ecx_677) + 0x0E65 - *(ebp - 0x50);
					word32 ecx_681 = *(ebp - 0x54);
					up32 v168_687 = (byte) (edx_684 < 0x00) + (*(ebp - 88) + edx_684);
					*(ebp - 88) = v168_687;
					*(ebp - 0x54) = (word32) ((byte) (v168_687 < 0x00) + (*(ebp - 0x54) + ecx_681));
					ptr32 esp_694;
					word32 eax_695;
					word32 * ebp_696;
					byte SCZO_697;
					word32 ecx_698;
					byte SZO_699;
					byte CZ_700;
					byte C_701;
					word32 edx_702;
					byte Z_703;
					word32 esi_704;
					word32 edi_705;
					struct Eq_5818 * fs_706;
					byte cl_707;
					byte ch_708;
					word32 ebx_709;
					MSVCRT.dll!log10();
					*(ebp_696 - 0x0C) = ecx_698;
					ui32 eax_712 = *(ebp_696 - 0x50);
					ui32 edx_714 = edx_702 + 161 | eax_712;
					uint32 edx_2162 = edx_714 - 0x51;
					uint32 eax_2166 = (eax_712 - *(ebp_696 - 0x50) + (edx_714 - 0x51) - 66 | edx_714 - 0x51) + *(ebp_696 - 88);
					if (*(ebp_696 - 88) > eax_2166)
					{
						*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - (edx_714 - 0x51);
						*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
						edx_2162 = (eax_2166 + 0x035B ^ *(ebp_696 - 0x50)) - *(ebp_696 - 0x50);
						eax_2166 = eax_2166 - 0x01 - edx_2162 - edx_2162;
						*(ebp_696 - 88) = eax_2166;
						up32 v172_2173 = *(ebp_696 - 88) - edx_2162 - (eax_2166 < 0x00);
						*(ebp_696 - 88) = v172_2173;
						*(ebp_696 - 0x50) = (word32) ((byte) (v172_2173 < 0x00) + (*(ebp_696 - 0x50) + edx_2162));
						*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ edx_2162;
					}
					ui32 edx_732 = edx_2162 | *(ebp_696 - 88);
					*(ebp_696 - 0x54) = eax_2166;
					*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + eax_2166;
					*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x01;
					ui32 eax_741 = eax_2166 ^ *(ebp_696 - 88);
					up32 v177_746 = *(ebp_696 - 88);
					*(ebp_696 - 88) = v177_746;
					*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - (v177_746 < 0x00);
					*(ebp_696 - 0x54) = *(ebp_696 - 0x54) & 0x00;
					uint32 ecx_756 = eax_741 & 0x00 | eax_741;
					if (ecx_756 > 0x00)
					{
						word32 eax_2141 = *(ebp_696 - 0x54);
						*(ebp_696 - 0x54) = eax_2141;
						*(ebp_696 - 88) = (word32) ((byte) (ecx_756 < 0x00) + (*(ebp_696 - 88) + eax_2141));
						if ((eax_2141 ^ ecx_756 ^ ecx_756 ^ *(ebp_696 - 0x54)) < *(ebp_696 - 88))
						{
l00415CF2:
							GetCommandLineA();
							*(ebp_696 - 88) = *(ebp_696 - 88) & edx_732;
							ui32 eax_774 = *(ebp_696 - 0x50);
							*(ebp_696 - 88) = *(ebp_696 - 88) ^ ((eax_774 ^ 0x00) ^ eax_774);
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - eax_774;
							*(ebp_696 - 88) = *(ebp_696 - 88) | eax_774;
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x01;
							*(esp_694 - 0x04) = 0x00;
							*(ebp_696 - 88) = (union Eq_66 *) GetModuleHandleA(*(esp_694 - 0x04));
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x01;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - 0x01;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
							*(ebp_696 - 88) = *(ebp_696 - 88) | 114;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - 114;
							GetOEMCP();
							*(esp_694 - 0x08) = ebp_696 - 88;
							GetVersionExA(*(esp_694 - 0x08));
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) ^ 3613;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) ^ 0x0E1E;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
							*(ebp_696 - 0x50) = (word32) ((byte) ((*(ebp_696 - 88) | 0x0E1E) < 0x0E1E) + (*(ebp_696 - 0x50) + 0x0E1E));
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + 0x01;
							up32 v196_837 = *(ebp_696 - 88) - 0x0E1E;
							*(ebp_696 - 88) = v196_837;
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x0E1E - (v196_837 < 0x00);
							*(ebp_696 - 88) = *(ebp_696 - 88) - 0x01;
							GetCursor();
							*(esp_694 - 0x0C) = *(ebp_696 - 0x50);
							*(esp_694 - 0x10) = *(ebp_696 - 88);
							*(esp_694 - 0x14) = 0x0A00;
							*(esp_694 - 0x18) = 0x00;
							*(esp_694 - 0x1C) = ~0x00;
							VirtualAllocEx(*(esp_694 - 0x1C), *(esp_694 - 0x18), *(esp_694 - 0x14), *(esp_694 - 0x10), *(esp_694 - 0x0C));
							word32 edx_860 = *(ebp_696 - 88);
							*(esp_694 - 0x20) = edx_860;
							*(esp_694 - 0x24) = *(ebp_696 - 88);
							IsChild(*(esp_694 - 0x24), *(esp_694 - 0x20));
							*(esp_694 - 0x28) = *(ebp_696 - 0x54);
							ui32 edi_870 = *(ebp_696 - 88);
							*(esp_694 - 44) = edi_870;
							IsChild(*(esp_694 - 44), *(esp_694 - 0x28));
							struct Eq_6509 * esi_874 = fs_706->ptr0030;
							ui32 edx_2120 = edx_860 + esi_874->dwFFFEE1D1;
							*(esp_694 - 0x30) = *(ebp_696 - 0x0C);
							int32 eax_1163 = lstrlenA(*(esp_694 - 0x30));
							up32 ecx_888 = *(ebp_696 - 0x50);
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - (ecx_888 + 0x01) - (ecx_888 < 0x00);
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) & ecx_888 + 0x01;
							uint32 ecx_897 = ecx_888 + 0x01 & edx_2120;
							if (*(ebp_696 - 88) >= ecx_897)
							{
								*(ebp_696 - 88) = *(ebp_696 - 88);
								*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
								up32 edx_2117 = 0x01 - ecx_897;
								edx_2120 = (ui32) ((byte) (edx_2117 < 0x00) + (edx_2117 + *(ebp_696 - 88)));
								if (edx_2120 == 0x00)
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + ecx_897;
							}
							if (eax_1163 != 0x05)
							{
								*(esp_694 - 0x34) = 0x09;
								*(esp_694 - 0x38) = 0x13;
								*(esp_694 - 0x3C) = ebp_696 - 88;
								*(esp_694 - 0x40) = ebp_696 - 0x54;
								*(esp_694 - 0x44) = ebp_696 - 88;
								int32 eax_923 = GetMenuItemCount(*(esp_694 - 0x44));
								*(esp_694 - 0x48) = 0x5E;
								*(esp_694 - 0x4C) = 0x69;
								*(esp_694 - 0x50) = ebp_696 - 0x50;
								*(esp_694 - 0x54) = 88;
								*(esp_694 - 88) = ebp_696 - 88;
								*(esp_694 - 0x5C) = eax_923;
								GetKeyNameTextA(*(esp_694 - 0x5C), *(esp_694 - 88), *(esp_694 - 0x54));
								*(esp_694 - 0x60) = 0x2F;
								*(esp_694 - 100) = 22;
								*(esp_694 - 0x68) = 0x4F;
								*(esp_694 - 0x6C) = ebp_696 - 88;
								Eq_290 eax_947 = GetKeyboardState(*(esp_694 - 0x6C));
								*(esp_694 - 0x70) = 0x5B;
								*(esp_694 - 116) = ebp_696 - 88;
								*(esp_694 - 0x78) = ebp_696 - 0x50;
								*(esp_694 - 0x7C) = (int32) eax_947;
								GetKeyboardLayoutNameA(*(esp_694 - 0x7C));
								*(esp_694 - 0x80) = 0x57;
								*(esp_694 - 0x84) = 0x67;
								*(esp_694 - 0x88) = ebp_696 - 0x54;
								*(esp_694 - 0x8C) = ebp_696 - 88;
								GetKeyboardLayout(*(esp_694 - 0x8C));
								*(esp_694 - 0x90) = 0x54;
								*(esp_694 - 0x94) = ebp_696 - 0x54;
								*(esp_694 - 0x98) = 0x69;
								GetMenuStringA(*(esp_694 - 0x98), *(esp_694 - 0x94), *(esp_694 - 0x90), *(esp_694 - 0x8C), *(esp_694 - 0x88));
								*(esp_694 - 0x9C) = ebp_696 - 88;
								*(esp_694 - 0xA0) = 0x5C;
								*(esp_694 - 0xA4) = ebp_696 - 88;
								GetMenuState(*(esp_694 - 0xA4), *(esp_694 - 0xA0), *(esp_694 - 0x9C));
								*(esp_694 - 0xA8) = ebp_696 - 88;
								*(esp_694 - 0xAC) = 0x1A;
								*(esp_694 - 0xB0) = ebp_696 - 88;
								GetKeyboardLayoutList(*(esp_694 - 0xB0), *(esp_694 - 0xAC));
								*(esp_694 - 0xB4) = 0x57;
								*(esp_694 - 0xB8) = ebp_696 - 0x50;
								GetMenuItemCount(*(esp_694 - 0xB8));
								*(esp_694 - 188) = 0x0E;
								*(esp_694 - 0xC0) = ebp_696 - 88;
								*(esp_694 - 0xC4) = 88;
								*(esp_694 - 200) = 0x46;
								GetKeyboardLayoutList(*(esp_694 - 200), *(esp_694 - 0xC4));
								*(esp_694 - 0xCC) = 0x00;
								ExitProcess(*(esp_694 - 0xCC));
							}
							*(ebp_696 - 88) = *(ebp_696 - 88) + edx_2120;
							ui32 edx_1015 = edx_2120 - *(ebp_696 - 0x50);
							ui32 edx_1022 = (edx_1015 + 0xBB ^ *(ebp_696 - 0x54)) - *(ebp_696 - 0x54);
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - edx_1022;
							*(ebp_696 - 88) = *(ebp_696 - 88) - edx_1022;
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ edx_1022;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | edx_1022;
							ui32 ecx_1018 = 0x01 - edx_1015 ^ edx_1015;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + ecx_1018;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | ecx_1018;
							ui32 ecx_1041 = ecx_1018 + *(ebp_696 - 0x54) ^ *(ebp_696 - 0x54);
							*(ebp_696 - 88) = *(ebp_696 - 88) + ecx_1041;
							*(ebp_696 - 88) = *(ebp_696 - 88) | ecx_1041;
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + (ecx_1041 - *(ebp_696 - 0x50) ^ *(ebp_696 - 0x50));
							uint32 edx_1057 = (0x00 - *(ebp_696 - 0x54) & *(ebp_696 - 88)) + *(ebp_696 - 0x54);
							*(ebp_696 - 88) = *(ebp_696 - 88) - *(ebp_696 - 0x50);
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) & edx_1057;
							*(ebp_696 - 88) = *(ebp_696 - 88) + edx_1057;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - edx_1057;
							uint32 ecx_1074 = *(ebp_696 - 0x54) & 0x00 ^ *(ebp_696 - 88);
							*(ebp_696 - 88) = *(ebp_696 - 88) + ecx_1074;
							uint32 ecx_1078 = ecx_1074 - 0x02;
							if (ecx_1074 - 0x02 < *(ebp_696 - 88))
							{
								*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
								edx_1057 = (ecx_1074 - 0x02 & 0x00) + *(ebp_696 - 0x50);
								ecx_1078 = ecx_1074 - 0x02 ^ edx_1057;
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - ecx_1078;
								*(ebp_696 - 88) = *(ebp_696 - 88) & ecx_1078;
								*(ebp_696 - 88) = *(ebp_696 - 88) ^ ecx_1078;
							}
							ui32 edx_1090 = 166 - *(ebp_696 - 0x50) - (edx_1057 - ecx_1078 < 0x00);
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | ecx_1078;
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x01;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
							*(ebp_696 - 88) = edx_1090;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) & edx_1090;
							ui32 edx_1108 = edx_1090 - *(ebp_696 - 0x50) + *(ebp_696 - 88);
							*(ebp_696 - 88) = *(ebp_696 - 88);
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50);
							*(ebp_696 - 88) = *(ebp_696 - 88);
							up32 ecx_1118 = *(ebp_696 - 0x50) + 0x6A;
							*(ebp_696 - 88) = *(ebp_696 - 88) - ecx_1118 - (ecx_1118 < 0x00);
							ui32 ecx_1123 = ecx_1118 ^ edx_1108;
							if (true)
							{
								*(ebp_696 - 0x50) = 0x41;
								ui32 edx_2065 = (ecx_1123 | 66) + *(ebp_696 - 0x54);
								*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | (ecx_1123 & edx_2065) + 117;
								*(ebp_696 - 88) = *(ebp_696 - 88) - 0x01;
								*(ebp_696 - 88) = *(ebp_696 - 88) - edx_2065;
							}
							uint32 ecx_1149 = (*(ebp_696 - 0x54) & *(ebp_696 - 0x50)) - *(ebp_696 - 88) - 0x01 | eax_1163;
							*(ebp_696 - 88) = *(ebp_696 - 88) + ecx_1149;
							if (*(ebp_696 - 0x50) > ecx_1149 - 0x0E00)
							{
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x59 - (*(ebp_696 - 0x50) < ecx_1149 - 0x0E00);
								eax_1163 = 0x9A;
								if (ecx_1149 <= 3688 && ecx_1149 >= 0x0E00)
								{
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + 0x01;
									eax_1163 = ecx_1149 - 0x0E00 | 0x9A;
								}
							}
							*(ebp_696 - 0x50) = eax_1163;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
							int32 eax_1167 = eax_1163 + 0x01;
							word32 ecx_1172 = *(ebp_696 - 0x54);
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) | eax_1167 - 0xB7;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | eax_1167 - 0xB7;
							*(ebp_696 - 88) = *(ebp_696 - 88) + (eax_1167 - 0xB7);
							word32 ecx_1183 = ecx_1172 + (eax_1167 - 0xB7) - *(ebp_696 - 0x50);
							*(ebp_696 - 88) = *(ebp_696 - 88) + (ecx_1183 - 0x9C);
							int32 eax_1168 = eax_1167 - 0xB7;
							ui32 ecx_1187 = ecx_1183 - 0x9D;
							if (true)
							{
								*(ebp_696 - 88) = *(ebp_696 - 88) - (eax_1167 - 0xB7);
								*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - (eax_1167 - 0xB7);
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) & 121;
								eax_1168 = (ecx_1183 - 0x9D ^ ~0x1686) + *(ebp_696 - 88) + *(ebp_696 - 88);
								ecx_1187 = ecx_1183 - 0x9D - eax_1168 - 0x01 - eax_1168;
							}
							ui32 eax_1199 = eax_1168 - 0x01 | ecx_1187;
							uint32 edx_1208 = ((0x00 - *(ebp_696 - 0x54) | *(ebp_696 - 88)) & *(ebp_696 - 0x54)) + *(ebp_696 - 0x54) & eax_1199;
							*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + edx_1208;
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) | edx_1208;
							if (edx_1208 - 0x0B00 > *(ebp_696 - 88))
							{
								*(ebp_696 - 88) = 0x00;
								*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
								ui32 edx_1984 = edx_1208 - 0x0B00 | eax_1199;
								ui32 edx_1993 = edx_1984 - 0x01 - edx_1984;
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ edx_1993;
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - edx_1993;
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) & edx_1993;
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ edx_1993;
								*(ebp_696 - 0x50) = edx_1984;
								*(ebp_696 - 88) = *(ebp_696 - 88) & edx_1984;
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + edx_1993;
							}
							*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
							uint32 eax_1244 = (*(ebp_696 - 88) | *(ebp_696 - 0x50)) & ecx_1187;
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - eax_1244;
							ui32 edx_1237 = 0x00;
							ui32 eax_1248 = eax_1244 + 0x07;
							if (eax_1244 <= 0x07)
							{
								ui32 ecx_1969 = (eax_1244 + 0x07 & 0x0900) - 0xA3 | *(ebp_696 - 88);
								ui32 eax_1970 = eax_1244 + 0x07 & ecx_1969;
								*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + (eax_1970 - 0x01);
								*(ebp_696 - 0x50) = *(ebp_696 - 0x50) & eax_1970 - 0x01;
								eax_1248 = eax_1970 - 0xF1 - ecx_1969;
							}
							*(ebp_696 - 0x54) = *(ebp_696 - 0x54) & eax_1248;
							*(ebp_696 - 0x50) = *(ebp_696 - 0x50) | 2524;
							word32 eax_1266 = 2525;
							if (*(ebp_696 - 88) >= 2525)
							{
								edx_1237 = *(ebp_696 - 0x54) ^ 0x00;
								if (*(ebp_696 - 0x50) >= 2525)
								{
l00416193:
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + edx_1237;
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + edx_1237;
									*(ebp_696 - 88) = *(ebp_696 - 88) | edx_1237;
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x3A;
									uint32 ecx_1285 = (*(ebp_696 - 88) & 0x3A) + *(ebp_696 - 0x54);
									ui32 ecx_1290 = (word32) (SEQ(ecx_1285, ecx_1285) + *(ebp_696 - 0x54)) | *(ebp_696 - 88);
									*(ebp_696 - 88) = eax_1266;
									uint32 ecx_1296 = ecx_1290 + *(ebp_696 - 0x50) + *(ebp_696 - 0x54);
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - (SEQ(ecx_1296, ecx_1296) < 0x00);
									*(ebp_696 - 88) = 0x00;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - 0x01;
									ui32 eax_1309 = *(ebp_696 - 88) & 0x00 | *(ebp_696 - 0x50);
									*(ebp_696 - 88) = *(ebp_696 - 88) - eax_1309;
									ui32 edx_1313 = *(ebp_696 - 88);
									ui32 edx_1315 = edx_1313 | *(ebp_696 - 0x54);
									ui32 eax_1321 = (eax_1309 + edx_1313 + edx_1315 ^ edx_1315) + *(ebp_696 - 0x54) + *(ebp_696 - 0x50);
									uint32 ecx_1327 = *(ebp_696 - 0x50) - eax_1321 | eax_1321;
									*(ebp_696 - 88) = *(ebp_696 - 88) ^ eax_1321;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | eax_1321;
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ ecx_1327;
									*(ebp_696 - 88) = *(ebp_696 - 88) + ecx_1327;
									if (*(ebp_696 - 0x50) >= ecx_1327)
									{
										*(ebp_696 - 88) = *(ebp_696 - 88);
										*(ebp_696 - 88) = 0x00;
										*(ebp_696 - 0x54) = *(ebp_696 - 0x54) & 0x00;
										eax_1321 = ecx_1327 ^ 0x00;
										if (*(ebp_696 - 88) >= (ecx_1327 ^ 0x00))
											eax_1321 = (ecx_1327 ^ 0x00) + 0x01;
									}
									if (edx_1315 != *(ebp_696 - 88))
									{
										*(ebp_696 - 88) = *(ebp_696 - 88) - 0x01;
										*(ebp_696 - 88) = *(ebp_696 - 88) + 0x8B;
										uint32 edx_1902 = *(ebp_696 - 0x50) | 0x8B;
										if (edx_1902 > 0x00)
											*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | edx_1902;
									}
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | eax_1321;
									*(ebp_696 - 0x50) = 0x03B6;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | 0x03B6;
									up32 v286_1371 = *(ebp_696 - 0x50) + 0x03B6;
									*(ebp_696 - 0x50) = v286_1371;
									*(ebp_696 - 88) = (word32) ((byte) (v286_1371 < 0x00) + (*(ebp_696 - 88) + 0x03B6));
									up32 v288_1377 = *(ebp_696 - 0x50) + eax_1321;
									*(ebp_696 - 0x50) = v288_1377;
									*(ebp_696 - 88) = (word32) ((byte) (v288_1377 < 0x00) + (*(ebp_696 - 88) + eax_1321));
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) ^ 0x03B6;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - 0x03B6;
									uint32 edx_1397 = *(ebp_696 - 88) + 0x0BF9;
									up32 v292_1403 = *(ebp_696 - 88) - edx_1397 - (edx_1397 < 0x00);
									*(ebp_696 - 88) = v292_1403;
									*(ebp_696 - 0x54) = (word32) ((byte) (v292_1403 < 0x00) + (*(ebp_696 - 0x54) + edx_1397));
									ui32 eax_1393 = 299;
									if (*(ebp_696 - 0x50) > edx_1397)
									{
										*(ebp_696 - 0x54) = (word32) ((byte) (*(ebp_696 - 0x50) < edx_1397) + (*(ebp_696 - 0x54) + 299));
										eax_1393 = (*(ebp_696 - 0x50) ^ *(ebp_696 - 0x54)) + *(ebp_696 - 0x50);
										edx_1397 = edx_1397 | eax_1393;
										*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + edx_1397;
										*(ebp_696 - 88) = *(ebp_696 - 88) - edx_1397;
										*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
										*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | edx_1397;
										*(ebp_696 - 0x54) = *(ebp_696 - 0x54) & edx_1397;
									}
									uint32 eax_1416 = eax_1393 + edx_1397;
									ui32 edx_1422 = *(ebp_696 - 0x54) - *(ebp_696 - 88) - (eax_1416 < 0x00) & eax_1416;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
									*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
									*(ebp_696 - 88) = *(ebp_696 - 88) - edx_1422;
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - edx_1422;
									*(ebp_696 - 88) = *(ebp_696 - 88) ^ edx_1422;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) & edx_1422;
									uint32 edx_1437 = edx_1422 + eax_1416;
									if (true)
									{
										*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + 0x01;
										*(ebp_696 - 88) = *(ebp_696 - 88) | 0xF6;
										*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + 0xF6;
									}
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) | edx_1437;
									ui32 eax_1460 = *(ebp_696 - 0x54);
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x01;
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ 9447;
									ui32 ecx_1467 = eax_1460 | 9447 | eax_1460;
									ui32 eax_1468 = *(ebp_696 - 0x54);
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - ecx_1467;
									*(ebp_696 - 88) = ecx_1467;
									*(ebp_696 - 88) = *(ebp_696 - 88) | ecx_1467 + 0x02;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ 0x00;
									*(ebp_696 - 88) = 0x00;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) & 0x00;
									*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - eax_1468;
									uint32 edx_1499 = *(ebp_696 - 0x50) ^ 0x00 ^ eax_1468 | eax_1468;
									*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - (edx_1499 + 0x01);
									ui32 ecx_1479 = 0x00;
									ui32 eax_1483 = eax_1468;
									if (edx_1499 <= ~0x4C)
									{
										*(ebp_696 - 0x54) = *(ebp_696 - 0x54) ^ 0x00;
										*(ebp_696 - 88) = edx_1499 + 0x01;
										*(ebp_696 - 88) = *(ebp_696 - 88) - (edx_1499 + 0x01);
										eax_1483 = 0x00;
										if (edx_1499 + 0x01 == *(ebp_696 - 88))
										{
l00416363:
											*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - 0x68;
											*(ebp_696 - 88) = *(ebp_696 - 88) & 0x68;
											if (0x01 != 0x00)
											{
												up32 v323_1812 = *(ebp_696 - 0x54);
												*(ebp_696 - 0x54) = v323_1812;
												*(ebp_696 - 0x54) = 0x00;
												*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x01;
												ecx_1479 = (ui32) ((byte) (v323_1812 < 0x00) + *(ebp_696 - 0x54));
											}
											uint32 edx_1535 = *(ebp_696 - 0x54) | ecx_1479;
											*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - edx_1535;
											Eq_9052 C_1545 = cond(*(ebp_696 - 0x54) - edx_1535);
											if (*(ebp_696 - 0x54) >= edx_1535)
											{
												*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - ecx_1479 - (*(ebp_696 - 0x54) < edx_1535);
												*(ebp_696 - 0x54) = *(ebp_696 - 0x54) ^ ecx_1479;
												*(ebp_696 - 0x54) = *(ebp_696 - 0x54);
												*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - 0x01;
												*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ 0x00;
												ui32 edx_1775 = edx_1535 & ecx_1479;
												ecx_1479 = (edx_1775 - 0x01 & 0x00 ^ edx_1775 - 0x01) - *(ebp_696 - 0x54);
												*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + 0x01;
												*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + 0x01;
												*(ebp_696 - 0x50) = *(ebp_696 - 0x50) & ecx_1479;
												ui32 edx_1793 = edx_1775 - 0x01 + ecx_1479;
												*(ebp_696 - 0x54) = edx_1793;
												*(ebp_696 - 0x54) = edx_1793;
												C_1545.u0 = false;
											}
											up32 edx_1555 = 0x04DE - eax_1483;
											ui32 ecx_1550 = ecx_1479 - *(ebp_696 - 0x50) - C_1545;
											*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + (edx_1555 + 0x01);
											if (edx_1555 + 0x81 <= *(ebp_696 - 88))
											{
												*(ebp_696 - 0x50) = *(ebp_696 - 0x50) + 0x01;
												*(ebp_696 - 88) = *(ebp_696 - 88) - 151;
												if (false)
												{
l00416404:
													ui32 eax_1575 = *(ebp_696 - 0x50) + 0x01 - ecx_1550 & ecx_1550 | *(ebp_696 - 88);
													*(ebp_696 - 0x54) = eax_1575;
													*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - eax_1575;
													*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - eax_1575;
													if (true)
													{
														word32 ecx_1722 = *(ebp_696 - 88);
														*(ebp_696 - 0x50) = *(ebp_696 - 0x50) - ecx_1722;
														*(ebp_696 - 88) = *(ebp_696 - 88) ^ ecx_1722;
														*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
														up32 ecx_1730 = ecx_1722 - (eax_1575 + 0x01);
														ecx_1550 = (ui32) ((byte) (ecx_1730 < 0x00) + (ecx_1730 + *(ebp_696 - 88)));
													}
													ui32 eax_1594 = eax_1575 + 0x01 ^ *(ebp_696 - 0x54);
													uint32 edx_1601 = (*(ebp_696 - 0x50) & 166) - *(ebp_696 - 0x54) ^ eax_1594 | eax_1594 | eax_1594;
													if (edx_1601 <= 0x00)
													{
														*(ebp_696 - 0x50) = 0x25;
														*(ebp_696 - 88) = *(ebp_696 - 88) - 0x25;
														ui32 eax_1706 = (edx_1601 & 0x25) - *(ebp_696 - 0x50) | *(ebp_696 - 0x50);
														if (true)
														{
															*(ebp_696 - 0x54) = *(ebp_696 - 0x54) + eax_1706;
															edx_1601 = edx_1601 - 0xFA;
														}
													}
													ui32 eax_1613 = 0x00 - *(ebp_696 - 0x54) + *(ebp_696 - 88) + edx_1601 | edx_1601;
													*(ebp_696 - 0x50) = *(ebp_696 - 0x50) | eax_1613;
													*(ebp_696 - 0x54) = eax_1613;
													*(ebp_696 - 0x50) = *(ebp_696 - 0x50) ^ edx_1601;
													*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - edx_1601;
													*(ebp_696 - 88) = edx_1601;
													uint32 eax_1618 = eax_1613 & edx_1601;
													if (*(ebp_696 - 88) != eax_1618)
													{
														ui32 eax_1680 = eax_1618 - *(ebp_696 - 88) - (*(ebp_696 - 88) < eax_1618);
														*(ebp_696 - 88) = *(ebp_696 - 88) + 0x01;
														*(ebp_696 - 88) = *(ebp_696 - 88) - 0x01;
														*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - 0x01;
														*(ebp_696 - 88) = *(ebp_696 - 88) & eax_1680;
													}
													word32 edx_1639;
													word32 ebx_1640;
													word32 esi_1641;
													word32 edi_1642;
													*(ebp_696 - 0x54) = *(ebp_696 - 0x54) | fn00411DB0(ecx_1550, &esi_874->dwFFFEE1D1, edi_870, out edx_1639, out ebx_1640, out esi_1641, out edi_1642);
													ui32 ecx_1652 = *(ebp_696 - 0x50) + 0x5E;
													ui32 eax_1656 = *(ebp_696 - 0x50) ^ 3227;
													*(ebp_696 - 0x50) = *(ebp_696 - 0x50) & ecx_1652;
													*(ebp_696 - 0x54) = *(ebp_696 - 0x54) - eax_1656;
													ui32 eax_1662 = eax_1656 + *(ebp_696 - 88);
													*(esp_694 - 0x34) = *(ebp_696 - 88);
													ExitThread(*(esp_694 - 0x34));
													byte cl_1654;
													*clOut = (byte) ecx_1652;
													byte ch_1655;
													*chOut = SLICE(ecx_1652, byte, 8);
													word32 ebp_1671;
													*ebpOut = *ebp_696;
													return eax_1662;
												}
											}
											goto l00416404;
										}
									}
									eax_1483 = eax_1483 & *(ebp_696 - 0x54);
									goto l00416363;
								}
								up32 eax_1954 = 2525 - edx_1237 + 0x12 + *(ebp_696 - 0x50);
								up32 eax_1957 = (byte) (eax_1954 < 0x00) + (eax_1954 + *(ebp_696 - 88));
								eax_1266 = eax_1957 - *(ebp_696 - 88) - (eax_1957 < 0x00);
							}
							*(ebp_696 - 88) = *(ebp_696 - 88) - 0x01;
							*(ebp_696 - 0x54) = eax_1266;
							goto l00416193;
						}
					}
					goto l00415CF2;
				}
				ecx_2445 = ecx_2445 | *(ebp - 0x50);
			}
			*(ebp - 0x50) = *(ebp - 0x50) + (edx_315 + 0x01);
			goto l004158E7;
		}
	}
	*(ebp - 0x54) = *(ebp - 0x54) + edx_128;
	*(ebp - 0x54) = edx_128;
	goto l0041575D;
}

// 004167AD: Register Eq_85 fn004167AD()
Eq_85 fn004167AD()
{
	GetCursor();
	Eq_66 eax_10 = GetModuleHandleA(null);
	if (false || eax_10 >= 3358)
		;
	IsChild(dwLoc0300, dwLoc0318);
	GetOEMCP();
	GetVersionExA(fp - 0x0188);
	ui32 edx_89 = dwLoc0288 - dwLocE0 ^ IsChild(dwLoc0248, dwLoc0150);
	GetCommandLineA();
	word32 ecx_120;
	fn00416E0A(dwLoc0150, out ecx_120);
	GetModuleHandleA(null);
	ui32 v21_124 = dwLoc0240 ^ ecx_120;
	if (dwLoc88 > 0x05B2)
		dwLoc98 = dwLoc98 - 0xF6;
	word32 ecx_200;
	uint32 edx_221 = (dwLoc02DC ^ dwLoc0118) - dwLoc68 & fn00416E0A(0x00, out ecx_200);
	if (edx_221 >= dwLoc0134 || (edx_221 ^ 0x00) - dwLoc026C == 0x00)
		;
	uint32 edx_258 = 0x00 - dwLoc98;
	word32 ecx_294;
	fn00416E0A(dwLoc0108 - v21_124 - (SEQ(edx_258, edx_258) + _ < 0x00) + 0x01 | dwLoc0338, out ecx_294);
	return dwLoc0318;
}

// 00416E0A: Register word32 fn00416E0A(Register Eq_85 ecx, Register out ptr32 ecxOut)
word32 fn00416E0A(Eq_85 ecx, ptr32 & ecxOut)
{
	BOOL eax_56 = IsChild(dwLocE0, dwLoc01F4);
	word32 ecx_68;
	*ecxOut = (word32) eax_56 + ((dwLocA8 ^ eax_56) - 0x01) + 0x0300 ^ 0x00;
	return 0x00;
}

// 0041736A: Register ui32 fn0041736A(Register ui32 ecx, Register out ptr32 edxOut, Register out ptr32 ediOut)
ui32 fn0041736A(ui32 ecx, ptr32 & edxOut, ptr32 & ediOut)
{
	word32 edi_33;
	*ediOut = fn004167AD();
	word32 eax_62 = VirtualAllocEx((void *) ~0x00, 0x00, 0x0200, dwLoc01AC, dwLocDC) + dwLoc017C + dwLoc01F0;
	ui32 edx_65 = dwLoc01B4 - dwLoc0184 - (dwLoc01B4 < 0x00) & eax_62 ^ eax_62 | eax_62;
	ui32 eax_70 = (edx_65 ^ 191) + dwLoc68;
	word32 edx_76;
	*edxOut = (edx_65 - eax_70 & eax_70) - eax_70;
	return eax_70;
}

// 0041762E: FlagGroup bool fn0041762E(Register Eq_35 eax, Register ui32 ecx, Register ui32 edi, Register out ptr32 eaxOut, Register out ptr32 ecxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
bool fn0041762E(Eq_35 eax, ui32 ecx, ui32 edi, ptr32 & eaxOut, ptr32 & ecxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
}

// 0041899F: Register Eq_162 fn0041899F(Register Eq_162 eax, Register ui32 edi, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_162 fn0041899F(Eq_162 eax, ui32 edi, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 eax_37;
	ui32 edx_262;
	fn00412F4E(dwLoc0120 + dwLoc40 - 0x77 + dwLoc0174 ^ dwLoc0248 | dwLoc0298, out eax_37, out edx_262);
	GetOEMCP();
	GetCommandLineA();
	Eq_85 ecx_275 = (edx_262 & 1021) + edx_262;
	if (ecx_275 >= 0x00)
	{
		edx_262 = ((word32) ecx_275 + 0x0900 | ~0x1EDF) & (dwLoc0288 ^ 1021);
		dwLoc0108 = dwLoc0108 ^ 0x20;
		ecx_275 = (word32) ecx_275 + 0x00001301 + edx_262 - 0x01;
	}
	ui32 eax_80 = dwLocBC & edx_262;
	if (dwLoc0224 <= eax_80 + 0x01 && (byte) (dwLoc024C < 0x00) + (dwLoc0294 + ~0x01) < 0x00)
	{
		dwLoc38 = dwLoc38 & eax_80 + 0x01;
		dwLoc01EC = dwLoc01EC - 0x01;
	}
	uint32 ecx_117;
	fn00416E0A(ecx_275, out ecx_117);
	uint32 edx_105 = dwLoc38 ^ 0x68 | ecx_117;
	if (dwLoc01EC >= edx_105)
	{
		ecx_117 = (edx_105 & 133) + dwLoc0108 & dwLoc015C;
		if (ecx_117 >= 0x0146)
		{
l00418AF2:
			Eq_162 eax_154;
			ui32 ecx_155;
			word32 ebx_156;
			word32 esi_157;
			word32 edi_158;
			ui32 edx_162 = (byte) fn0041762E(dwLoc0158 & (dwLoc01C0 - GetCommandLineA()) + 0x01, ecx_117 | edx_105, edi, out eax_154, out ecx_155, out ebx_156, out esi_157, out edi_158) + (*(fp - 0x0214) + *(fp - 0x88));
			*(fp - 0x0200) = *(fp - 0x0200) | ecx_155;
			*(fp - 0x0144) = *(fp - 0x0144) + edx_162;
			*(fp - 0x0224) = *(fp - 0x0224) | edx_162;
			*(fp - 500) = *(fp - 500) - edx_162;
			*(fp - 0x3C) = *(fp - 0x3C) ^ edx_162;
			*(fp - 0x9C) = *(fp - 0x9C) ^ edx_162;
			*(fp - 0x01A0) = *(fp - 0x01A0) & edx_162;
			return eax_154;
		}
	}
	ecx_117 = ecx_117 + dwLoc40;
	goto l00418AF2;
}

