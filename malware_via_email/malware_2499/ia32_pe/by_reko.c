// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00411B71: Register uint32 fn00411B71(Register uint32 ecx, Register ui32 edx, Register out ptr32 edxOut)
uint32 fn00411B71(uint32 ecx, ui32 edx, ptr32 & edxOut)
{
	GetCommandLineA();
	uint32 eax_73 = 0x01 - edx + 0xC4 & dwLoc54;
	word32 edx_82;
	*edxOut = (word32) (SEQ(dwLoc016C, dwLoc8C + eax_73) + SEQ(dwLoc029C, eax_73));
	return 0x0A87;
}

// 00411DB0: Register ui32 fn00411DB0(Register ui32 ecx, Register (ptr32 word32) esi, Register ui32 edi, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
ui32 fn00411DB0(ui32 ecx, word32 * esi, ui32 edi, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	GetCursor();
	GetOEMCP();
	word32 edx_31 = dwLocD4 + 0x034E + ((dwLoc01C0 ^ 0x00) + dwLoc01FC <u 0x00) ^ dwLoc0138;
	uint32 ecx_87 = ((dwLoc0214 & 0x00 & dwLoc01B4) + 0x01 | edx_31) - edx_31 + edx_31;
	if (dwLoc0134 < ecx_87)
		dwLoc0120 = dwLoc0120 ^ ecx_87;
	Eq_66 eax_105 = LoadLibraryA(&globals->t40406D);
	if (eax_105 == 0x00)
		ExitProcess(0x00);
	ui32 v30_190 = dwLoc0130 & dwLoc84;
	Eq_66 dwLoc0280_240 = eax_105;
	do
	{
		memmove(fp - 44, dwLoc0280_240, 0x04);
		uint32 esi_272 = (edi | 181 | edi) - 0x1E00 ^ edi;
		dwLoc0280_240 = dwLoc0280_240 + 0x01;
		Eq_100 C_1837 = (bool) cond(esi_272);
		if (esi_272 <= 0x00)
		{
			dwLoc023C = dwLoc023C | 3770;
			edi = esi_272 + 4794;
			C_1837.u0 = false;
		}
		edi = (ui32) ((bool) C_1837 + (edi + dwLoc0198));
	} while (dwLoc2C != 0x33FFFFFF);
	ui32 edx_1817 = dwLoc01F8 - 0x1C01;
	if (dwLoc01F8 < 7989)
	{
		ui32 eax_1800 = (dwLoc01F8 - 0x1C01 ^ 0x66) + 0x13 + v30_190;
		dwLoc0250 = dwLoc0250 + 0x01;
		dwLoc0190 = dwLoc0190 + eax_1800;
		edx_1817 = dwLoc01F8 - 0x1C01 ^ eax_1800 ^ eax_1800;
	}
	uint32 eax_341 = dwLoc0190 ^ 3755;
	ui32 eax_354 = eax_341 + 0x0100 + (((edx_1817 - dwLoc01B8) - dwLoc0174) - (eax_341 < 0x0100));
	Eq_7 eax_338 = GetCommandLineA();
	VirtualAllocEx((void *) ~0x00, 0x00, 0x0600, dwLoc0170, dwLocAC);
	uint32 edx_1764 = eax_354 + 0x0340 & eax_354 + 0x0300;
	word32 ecx_400 = dwLoc0100 + edx_1764;
	uint32 ecx_1785 = (word32) (SEQ(ecx_400 + 0x01, ecx_400 + 0x01) + SEQ(dwLoc60, edx_1764)) ^ dwLocCC ^ edx_1764;
	word32 v63_412 = dwLoc0178 + edx_1764;
	if (ecx_1785 >= 0x00)
	{
		edx_1764 = ecx_1785 + 232 | dwLoc0110;
		ecx_1785 = (ecx_1785 - 0xCB | dwLoc01C4) - dwLoc01E0;
	}
	GetCursor();
	word32 edx_454;
	fn00411B71(ecx_1785, edx_1764 ^ dwLoc01F4 | dwLocCC, out edx_454);
	ui32 edx_469 = dwLoc01F8 & 0x00 ^ dwLoc026C;
	uint32 ecx_497 = (dwLoc023C ^ 0xA5) + dwLoc0180 ^ GetOEMCP();
	ui32 ecx_515 = v63_412 + dwLoc018C ^ dwLoc0250;
	ui32 edx_1733 = edx_469 + 0x19;
	if (ecx_515 + 0x01 > dwLoc01E4)
	{
		dwLoc010C = dwLoc010C & ecx_515 + 0x01;
		edx_1733 = dwLoc023C + 0xE0 + dwLoc0120;
	}
	up32 ecx_569 = 0x00 - esi_272 + esi_272;
	up32 v82_552 = dwLoc0108 - edx_1733;
	Eq_35 eax_556 = GetOEMCP();
	byte CZ_1675 = cond(ecx_569 + 0x01);
	if (ecx_569 < 0x01)
		dwLoc01D0 = v86;
	word32 eax_593;
	word32 edx_594;
	fn00412F4E(eax_556, out eax_593, out edx_594);
	if (v82_552 >= 0x1101)
		CZ_1675 = cond(dwLocD8 - (eax_338 + 0xDA));
	Eq_296 eax_667 = IsChild(0xE7, dwLoc0188);
	if ((eax_667 & 0x00) != dwLoc01F8 - 0x01)
		dwLoc01D0 = dwLoc01D0 - (eax_667 | dwLoc0254);
	word32 eax_733;
	word32 edx_734;
	fn00412F4E(GetCursor(), out eax_733, out edx_734);
	ui32 esi_715 = (0xE7 - dwLocE8 & 0x0246) + 0x01;
	ui32 edi_718 = dwLoc010C & esi_715 - 0x01;
	Eq_85 v113_722 = dwLoc01F8 - 0x01 + (esi_715 - 0x01);
	IsChild(dwLoc58, v113_722);
	word32 ecx_776;
	fn00416E0A(v113_722, out ecx_776);
	GetVersionExA(fp - 0x0270);
	word32 edx_837 = eax_338 - (dwLocA0 & 0x00) + (dwLoc0214 - 0x01);
	Eq_85 ecx_1553 = dwLoc0214 - (CHAR *) 0x01;
	Eq_165 v137_822 = dwLoc01D0 - 0x01;
	uint32 edx_845 = (word32) (SEQ(dwLoc01CC, edx_837) - SEQ(edx_837, dwLocA0 & 0x00)) | dwLoc0214 - (CHAR *) 0x01;
	if (edx_845 == 0xFA)
		ecx_1553 = edx_845 + dwLoc60 + (edx_845 < 0xFA) + 0x4B;
	GetVersionExA(fp - 0x0104);
	word32 ecx_885;
	fn00416E0A(ecx_1553, out ecx_885);
	word32 ebx_927;
	word32 esi_928;
	ui32 edi_929;
	fn0041899F(VirtualAllocEx((void *) ~0x00, 0x00, 0x0400, dwLoc94, v137_822), edi_718, out ebx_927, out esi_928, out edi_929);
	*(fp - 0x0264) = *(fp - 0x0264) + 0xFD;
	ui32 eax_943 = *(fp - 0x0144) ^ 0xFD;
	*(fp - 0x0204) = *(fp - 0x0204) + eax_943;
	*(fp - 0x88) = eax_943;
	*(fp - 664) = 0x00;
	Eq_66 eax_1506 = GetModuleHandleA(*(fp - 664));
	uint32 edx_1511 = (*(fp - 252) | 0x0B26) + *(fp - 0x0110) ^ eax_1506;
	*(fp - 0x0110) = *(fp - 0x0110) | edx_1511;
	*(fp - 600) = *(fp - 600) & edx_1511;
	*(fp - 0x0208) = edx_1511;
	if (*(fp - 344) <= edx_1511)
	{
		ui32 eax_1500 = *(fp - 0x0234);
		*(fp - 0x0154) = *(fp - 0x0154) ^ eax_1500;
		eax_1506 = eax_1500 - (edx_1511 - 0x018E) - 0x01 & edx_1511 - 0x018E;
		edx_1511 = edx_1511 - 399 ^ eax_1506;
	}
	word32 ecx_983 = *(fp - 332);
	uint32 ecx_994 = (ecx_983 - *(fp - 0x5C) - ((((word32) eax_1506 + edx_1511) + ecx_983 & *(fp - 88)) - *(fp - 0x0224) < 0x00) ^ *(fp - 0x01F8)) + *(fp - 0x01B0) - *(fp - 0x88);
	word32 edx_993 = *(fp - 0x013C);
	ui32 ecx_998 = ecx_994 - *(fp - 600) - (ecx_994 < 0x00) & *(fp - 0x026C);
	ui32 eax_1003 = 0xCE - *(fp - 0x0110) - *(fp - 0xEC);
	*(fp - 0xA0) = *(fp - 0xA0) + edi_929;
	*(fp - 0xB0) = *(fp - 0xB0) & edi_929;
	*(fp - 0x0130) = eax_1003;
	*(fp - 332) = *(fp - 332) & eax_1003;
	*(fp - 336) = *(fp - 336) + 0x01;
	*(fp - 220) = *(fp - 220) + eax_1003;
	*(fp - 664) = *(fp - 0x011C);
	word32 edx_1024;
	word32 ecx_1025 = fn00411B71(ecx_998 + 0x01, edx_993 - 0x01, out edx_1024);
	ui32 edx_1029 = (*(fp - 244) ^ 177 ^ ecx_1025) + ecx_1025;
	*(fp - 0x0234) = *(fp - 0x0234) ^ edx_1029;
	ui32 ecx_1038 = ecx_1025 - 0x6C;
	if (edx_1029 != 0x00)
	{
		*(fp - 0x019C) = *(fp - 0x019C) + 0x01;
		*(fp - 0x0108) = *(fp - 0x0108) - 0x01;
		*(fp - 0x011C) = 0x00;
		ecx_1038 = 0x00;
		if (edx_1029 != 0x00)
			ecx_1038 = *(fp - 252) ^ 0x00;
	}
	GetOEMCP();
	uint32 edx_1055 = (ecx_1038 & 0x00 ^ 0x0B00) - 0x0E00;
	ui32 edx_1058 = edx_1055 - *(fp - 0x022C) - (edx_1055 < 0x00);
	*(fp - 616) = edx_1058;
	*(fp - 0x6C) = *(fp - 0x6C) ^ edx_1058;
	ui32 edx_1066 = (edx_1058 & *(fp - 0x0180)) + *(fp - 0xB0);
	*(fp - 0x80) = *(fp - 0x80);
	*(fp - 0xE0) = *(fp - 0xE0) & 0x00;
	*(fp - 388) = edx_1066;
	up32 ecx_1072 = 0x00 - edx_1066;
	*(fp - 0x9C) = (word32) ((bool) (ecx_1072 < 0x0D00) + (*(fp - 0x9C) + edx_1066));
	ui32 edi_1081 = (eax_1003 | 0x0BFF) & 0x00;
	*(fp - 0x0230) = *(fp - 0x0230) - (edi_1081 + 0x01);
	*(fp - 0x68) = *(fp - 0x68) | edi_1081 + 0x01;
	*(fp - 0x0138) = edi_1081 + 0x01;
	uint32 edx_1090 = *(fp - 0x023C);
	*(fp - 0xB4) = (word32) ((bool) (edx_1090 < 0x00) + (*(fp - 0xB4) + 4000));
	*(fp - 0x020C) = *(fp - 0x020C) ^ 4000;
	*(fp - 0x01F8) = *(fp - 0x01F8) + 4000;
	*(fp - 0x0214) = *(fp - 0x0214) + (edx_1090 & 4000);
	ui32 edi_1104 = edx_1090 & 4000 & *(fp - 0x01E0);
	*(fp - 0xC4) = *(fp - 0xC4) + 0x01;
	*(fp - 0x0108) = *(fp - 0x0108) - 0x01;
	*(fp - 668) = edx_1090;
	*(fp - 0x02A0) = *(fp - 0xD0);
	*(fp - 676) = edi_1104;
	*(fp - 0x02A8) = *(fp - 0x01D4);
	word32 ecx_1121;
	fn00416E0A(ecx_1072 - 0x0D00, out ecx_1121);
	uint32 edx_1127 = *(fp - 0xB0) - *(fp - 0x0168);
	*(fp - 220) = *(fp - 220) ^ edx_1127 + 0x01;
	up32 v181_1132 = *(fp - 0x01DC) + (edx_1127 + 0x01);
	*(fp - 0x01DC) = v181_1132;
	*(fp - 0x88) = (word32) ((bool) (v181_1132 < 0x00) + (*(fp - 0x88) + (edx_1127 + 0x01)));
	if (edx_1127 - 0x0ABD != *(fp - 0x01F8))
	{
		*(fp - 500) = 0x00;
		if (edx_1127 - 0x0ABD < *(fp - 0xF0))
		{
l004128B1:
			*(fp - 0x02AC) = 0x00;
			GetModuleHandleA(*(fp - 0x02AC));
			ui32 ecx_1163 = ecx_1121 + 0xFE & 0x01;
			up32 eax_1167 = 0x01 - *(fp - 0x6C) - 0x01 + ecx_1163;
			*(fp - 244) = (word32) ((bool) (eax_1167 < 0x00) + (*(fp - 244) + eax_1167));
			*(fp - 232) = *(fp - 232) - eax_1167;
			uint32 ecx_1181 = ecx_1163 - 0xA2 + (eax_1167 + 0x01);
			ui32 ecx_1185 = ecx_1181 + 0x2F - *(fp - 0x54) - (ecx_1181 < 0x2F);
			if (eax_1167 != ~0xA0)
			{
				*(fp - 0x01DC) = *(fp - 0x01DC) - ecx_1185;
				*(fp - 0x0228) = *(fp - 0x0228) + 0x01;
				*(fp - 488) = *(fp - 488);
				*(fp - 100) = *(fp - 100) & 0x00;
				ecx_1185 = 0x00;
			}
			ui32 ecx_1199;
			fn00416E0A(ecx_1185 + 0x1F, out ecx_1199);
			ui32 edx_1206 = (*(fp - 292) ^ 0x48) + *(fp - 0x0164) & ecx_1199 - 0x48;
			*(fp - 0x0128) = edx_1206;
			*(fp - 484) = *(fp - 484) | edx_1206;
			*(fp - 0x023C) = *(fp - 0x023C) - edx_1206;
			*(fp - 0x70) = *(fp - 0x70) ^ edx_1206;
			ui32 ecx_1202 = ecx_1199 - 0x48;
			if (edx_1206 == *(fp - 0xA8))
			{
				*(fp - 404) = *(fp - 404) + 0x01;
				*(fp - 0x0260) = *(fp - 0x0260) + 0x01;
				*(fp - 424) = *(fp - 424);
				*(fp - 0x01DC) = *(fp - 0x01DC);
				ui32 edx_1392 = edx_1206 ^ edx_1206 - 0x01;
				*(fp - 0x0230) = *(fp - 0x0230) + edx_1392;
				*(fp - 0x01C4) = *(fp - 0x01C4) + 0x01;
				*(fp - 0x023C) = *(fp - 0x023C) ^ edx_1392;
				*(fp - 0x0244) = *(fp - 0x0244) - edx_1392;
				ecx_1202 = edx_1206 + 0x56;
			}
			*(fp - 0x02AC) = *(fp - 0x013C);
			*(fp - 688) = *(fp - 0x0270);
			IsChild(*(fp - 688), *(fp - 0x02AC));
			*(fp - 0x70) = (word32) ((bool) ((*(fp - 600) + 0x18FF & *(fp - 0x0238)) < 0x0FD5) + (*(fp - 0x70) + 0x0FD5));
			*(fp - 0x021C) = *(fp - 0x021C) - 0x01;
			uint32 eax_1263 = *(fp - 0xA0) ^ *(fp - 0x0270);
			*(fp - 388) = *(fp - 388) - 0x01;
			ui32 ecx_1229 = ecx_1202 + 0x4E;
			if (eax_1263 >= 6656)
			{
				*(fp - 0x88) = *(fp - 0x88) & 0x00;
				*(fp - 0x0230) = 0x00;
				if (eax_1263 != 3364)
				{
l00412A34:
					word32 edx_1298;
					word32 edi_1299;
					ui32 eax_1300 = fn0041736A(ecx_1229, out edx_1298, out edi_1299);
					*(fp - 0x01B4) = *(fp - 0x01B4) - 0x01;
					ui32 ecx_1303 = (eax_1300 | 232) + eax_1300;
					*(fp - 0x0224) = *(fp - 0x0224) + ecx_1303;
					ui32 eax_1309 = *(fp - 0x0204);
					return ecx_1303 - eax_1309 + 0x01 ^ eax_1309;
				}
			}
			goto l00412A34;
		}
		*(fp - 444) = *(fp - 444) | edx_1127 - 0x0ABD;
		up32 v184_1455 = *(fp - 0x0270) - (edx_1127 - 0x0ABD);
		*(fp - 0x0270) = v184_1455;
		up32 v185_1459 = (bool) (v184_1455 < 0x00) + (*(fp - 0x8C) + (edx_1127 - 0x0ABD));
		*(fp - 0x8C) = v185_1459;
		*(fp - 0x01F0) = *(fp - 0x01F0) - (edx_1127 - 0x0ABD) - (v185_1459 < 0x00);
		*(fp - 0x6C) = *(fp - 0x6C) + 0x01;
	}
	goto l004128B1;
}

// 00412F4E: FlagGroup bool fn00412F4E(Register Eq_35 eax, Register out ptr32 eaxOut, Register out ptr32 edxOut)
bool fn00412F4E(Eq_35 eax, ptr32 & eaxOut, ptr32 & edxOut)
{
	uint32 edx_142 = (0x00 - dwLoc013C | eax) - 212 + dwLoc90 - dwLoc0284;
	if (edx_142 >= 0x0FD5)
		edx_142 = edx_142 + 0xC2;
	VirtualAllocEx((void *) ~0x00, 0x00, 0x0600, dwLoc020C, dwLoc028C);
	uint32 edx_35 = edx_142 - dwLoc0138;
	uint32 edx_71 = edx_35 + dwLocE0;
	uint32 eax_68 = (dwLoc9C - 0x01 & dwLoc018C) - dwLoc34 & edx_35;
	*eaxOut = eax_68;
	uint32 edx_117 = edx_71 + 0x01;
	bool C_127 = (bool) cond(eax_68);
	if (eax_68 > 0x00)
	{
		uint32 eax_104 = eax_68 - 0x01 - (edx_71 + 0x01);
		edx_117 = eax_104 - 0x36 - dwLoc027C;
		ui32 eax_124 = ((eax_104 ^ edx_117) + 0x0E00 & edx_117) - edx_117;
		*eaxOut = eax_124;
		C_127 = (bool) cond(eax_124);
	}
	ui32 edx_93 = (((word32) dwLoc020C + edx_117 + C_127 | dwLoc01C8) & dwLoc0100) + dwLoc016C;
	*edxOut = edx_93;
	return (bool) cond(edx_93);
}

// 0041324C: Register Eq_165 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	GetModuleHandleA(null);
	byte cl_13;
	byte ch_14;
	byte * edx_15;
	ptr32 ebx_16;
	word32 ebp_17;
	struct Eq_1729 * esi_18;
	word32 edi_19;
	byte * eax_20 = fn0041560A(ecx, fp - 0x04, out cl_13, out ch_14, out edx_15, out ebx_16, out ebp_17, out esi_18, out edi_19);
	byte al_21 = (byte) eax_20;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	*eax_20 = *eax_20 + al_21;
	cu8 * eax_242 = esi_18->ptr0000;
	byte al_243 = (byte) eax_242;
	*eax_242 = *eax_242 + al_243;
	null[eax_242].b0000 = null[eax_242].b0000 + al_243;
	*eax_242 = *eax_242 + al_243;
	*eax_242 = *eax_242 + al_243;
	byte cl_236 = cl_13 + SLICE(eax_20, byte, 8);
	byte * ecx_237 = DPB(ecx, cl_236, 0);
	*ecx_237 = *ecx_237 + ch_14;
	byte al_259;
	byte ah_260;
	__aas(al_243, SLICE(eax_242, byte, 8), &al_259, &ah_260);
	*eax_242 = *eax_242 + al_259;
	__outdw(dx, eax_242);
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	cu8 v136_278 = *eax_242 + al_259;
	*eax_242 = v136_278;
	byte bh_271 = SLICE(ebx_16 - 0x01, byte, 8);
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	esi_18->b140C = esi_18->b140C + ah_260;
	*eax_242 = *eax_242 + al_259;
	*eax_242 = *eax_242 + al_259;
	byte ah_294 = ah_260 + al_259;
	cu8 * eax_295 = DPB(eax_242, ah_294, 8);
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	byte * edi_304 = *(fp - 0x62);
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	*(ebx_16 - 0x01) = *(ebx_16 - 0x01) + ch_14;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	byte ch_318 = ch_14 + cl_236;
	byte * ecx_319 = DPB(ecx_237, ch_318, 8);
	Mem323[ecx_319 + eax_295:byte] = Mem321[ecx_319 + eax_295:byte] + bh_271;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + al_259;
	*eax_295 = *eax_295 + cl_236;
	*eax_295 = *eax_295 + al_259;
	cu8 v164_338 = *eax_295 + al_259;
	*eax_295 = v164_338;
	*edi_304 = *edi_304 + ch_318;
	*(fp - 0x62) = (byte **) edx_15;
	__lock();
	byte al_342 = (bool) (v164_338 < 0x00) + al_259;
	__outb(0x1C, al_342);
	DWORD eax_343 = DPB(eax_295, al_342, 0);
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	esi_18->b000C = esi_18->b000C + cl_236;
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	esi_18->b000C = esi_18->b000C + dh;
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*edx_15 = *edx_15 + ch_318;
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*(fp - 0x66) = ~0x37;
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	esi_18->b91F6000C = esi_18->b91F6000C + ah_294;
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	cu8 v183_384 = (word32) *eax_343 + al_342;
	*eax_343 = (Eq_165) v183_384;
	if (v183_384 <= 0x00)
	{
		*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
		*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
		__outb(dx, al_342);
		*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
		*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
		esi_18->b000D = esi_18->b000D + dl;
		*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
		*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	}
	*edx_15 = *edx_15 + dl;
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	*eax_343 = (Eq_165) ((word32) *eax_343 + al_342);
	return eax_343;
}

// 0041560A: Register ui32 fn0041560A(Register word32 ecx, Register ptr32 ebp, Register out Eq_1736 clOut, Register out Eq_1737 chOut, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
ui32 fn0041560A(word32 ecx, ptr32 ebp, Eq_1736 & clOut, Eq_1737 & chOut, ptr32 & edxOut, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	uint32 eax_20 = 1700 - *(ebp - 88) + ecx;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	if (*(ebp - 88) <= eax_20)
	{
		*(ebp - 0x54) = 0x04;
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		*(ebp - 0x54) = *(ebp - 0x54) - 0x04 - (*(ebp - 88) < eax_20);
		eax_20 = (eax_20 & *(ebp - 88)) + *(ebp - 88);
		*(ebp - 88) < eax_20;
	}
	ui32 eax_21 = eax_20 | *(ebp - 0x54);
	*(ebp - 0x50) = *(ebp - 0x50) & 0x00;
	if (eax_21 * 0x02 == 0x0FBF)
	{
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		*(ebp - 0x54) = eax_21 * 0x02;
		up32 v17_2637 = (bool) (eax_21 * 0x02 < 0x0FBF) + (*(ebp - 0x54) + eax_21 * 0x02);
		*(ebp - 0x54) = v17_2637;
		*(ebp - 0x50) = (word32) ((bool) (v17_2637 < 0x00) + (*(ebp - 0x50) + eax_21 * 0x02));
		*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
		word32 eax_2645 = *(ebp - 0x50);
		*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
		uint32 edx_2652 = eax_21 * 0x02 - (((eax_2645 + 0x01 | eax_21 * 0x02) ^ eax_21 * 0x02) & *(ebp - 0x50));
		*(ebp - 88) = (word32) ((bool) (edx_2652 < 0x00) + (*(ebp - 88) + edx_2652));
		*(ebp - 88) = *(ebp - 88) - edx_2652;
		*(ebp - 88) = *(ebp - 88) | edx_2652;
		*(ebp - 88) = *(ebp - 88) - edx_2652;
		*(ebp - 88) = *(ebp - 88) + edx_2652;
	}
	Eq_35 eax_43 = GetOEMCP();
	up32 edx_46 = *(ebp - 88) + 889;
	*(ebp - 0x50) = edx_46;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	*(ebp - 0x50) = (word32) ((bool) (edx_46 < 0x00) + (*(ebp - 0x50) + edx_46));
	ui32 edx_54 = edx_46 ^ eax_43;
	if (edx_54 == 0x0899)
	{
		*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
		*(ebp - 0x54) = *(ebp - 0x54);
		*(ebp - 0x50) = *(ebp - 0x50) & 0x00;
		*(ebp - 88) = (edx_54 + 0x0900 & (0x00 - (edx_54 + 0x0900) ^ edx_54 + 0x0900) - *(ebp - 88)) - 0x01;
	}
	*(ebp - 0x54) = *(ebp - 0x54) + 0x20;
	*(ebp - 0x54) = *(ebp - 0x54) + 0x20;
	*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
	*(ebp - 88) = *(ebp - 88) & 116;
	*(ebp - 0x50) = *(ebp - 0x50) | 116;
	*(ebp - 0x54) = *(ebp - 0x54) - 116;
	*(ebp - 0x50) = *(ebp - 0x50) ^ 0x20;
	*(ebp - 88) = *(ebp - 88) ^ 116;
	ui32 ecx_102 = (0x0EF5 - *(ebp - 0x50) & 116) + 0x01;
	*(ebp - 88) = *(ebp - 88) - 0x01;
	up32 v40_106 = *(ebp - 88) - (ecx_102 - 0x01);
	*(ebp - 88) = v40_106;
	*(ebp - 88) = (word32) ((bool) (v40_106 < 0x00) + (*(ebp - 88) + (ecx_102 - 0x01)));
	uint32 eax_117 = 116;
	if (ecx_102 + 0xE7 < *(ebp - 0x50))
	{
		*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
		*(ebp - 88) = *(ebp - 88);
		eax_117 = 0xCB - *(ebp - 0x50);
	}
	ui32 edx_121 = ((*(ebp - 0x54) ^ 0x00) & *(ebp - 0x54)) + eax_117;
	*(ebp - 0x54) = *(ebp - 0x54) | edx_121;
	uint32 edx_128 = edx_121 - ((eax_117 & edx_121) + 0x7B);
	if (edx_128 == 0x1D)
	{
		*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
		if (*(ebp - 88) <= edx_128)
		{
l0041575D:
			uint32 ecx_141 = *(ebp - 0x54) & edx_128 | edx_128;
			*(ebp - 0x50) = *(ebp - 0x50) + ecx_141;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			if (ecx_141 <= 0xC5)
			{
				*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
				edx_128 = 0x0276 - *(ebp - 0x54);
			}
			*(ebp - 0x50) = *(ebp - 0x50) + 110;
			*(ebp - 88) = *(ebp - 88) | 110;
			uint32 edx_166 = edx_128 + 0x01;
			uint32 eax_171 = 110 - *(ebp - 88) & (edx_166 ^ 110);
			*(ebp - 0x54) = eax_171;
			*(ebp - 88) = eax_171;
			*(ebp - 0x50) = *(ebp - 0x50) ^ eax_171;
			*(ebp - 0x54) = *(ebp - 0x54) ^ eax_171;
			ui32 edx_167 = edx_166 ^ 110;
			if (*(ebp - 88) <= eax_171)
			{
				up32 v55_2536 = *(ebp - 0x54);
				*(ebp - 0x54) = v55_2536;
				*(ebp - 88) = *(ebp - 88) - (v55_2536 < 0x00);
				*(ebp - 88) = *(ebp - 88) & 0x00;
				ui32 edx_2545 = *(ebp - 0x50) & 0x00;
				*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
				uint32 edx_2550 = (edx_2545 & *(ebp - 0x54)) + *(ebp - 0x50);
				edx_167 = edx_2550 + *(ebp - 0x54) + (edx_2550 < 0x00) + *(ebp - 88);
			}
			*(ebp - 0x50) = *(ebp - 0x50);
			*(ebp - 88) = *(ebp - 88);
			*(ebp - 88) = *(ebp - 88) - 0x01;
			ui32 eax_200 = *(ebp - 0x54);
			ui32 ecx_201 = ((eax_171 | ~0x00) ^ eax_171) - *(ebp - 0x54) | eax_200;
			*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
			ui32 ecx_209 = ecx_201 ^ eax_200 ^ eax_200 | eax_200 | eax_200;
			*(ebp - 0x54) = *(ebp - 0x54) + ecx_209;
			*(ebp - 88) = ecx_209;
			up32 v65_216 = *(ebp - 88) - ecx_209;
			*(ebp - 88) = v65_216;
			*(ebp - 88) = (word32) ((bool) (v65_216 < 0x00) + (*(ebp - 88) + ecx_209));
			ui32 eax_222 = *(ebp - 88);
			ui32 edx_223 = edx_167 | eax_222;
			*(ebp - 88) = *(ebp - 88) | edx_223;
			*(ebp - 0x54) = *(ebp - 0x54) | edx_223;
			uint32 eax_232 = eax_222 - *(ebp - 0x50) + *(ebp - 0x50);
			ui32 eax_239 = (eax_232 - *(ebp - 0x50) - (eax_232 < 0x00) + *(ebp - 0x54) ^ 0x00) - 0x01;
			up32 v69_242 = *(ebp - 88) - ~0x08FF;
			*(ebp - 88) = v69_242;
			ui32 edx_252 = 0x04FB - *(ebp - 88) - ((bool) (v69_242 < 0x00) + (*(ebp - 0x54) + ~0x08FF) < 0x00) + ecx_209 + ecx_209;
			*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) + ecx_209;
			*(ebp - 0x50) = *(ebp - 0x50) & edx_252;
			uint32 edx_261 = edx_252 - 0x1500 & ecx_209;
			Eq_4062 C_2533 = (bool) cond(edx_261 - 0x0C20);
			if (edx_261 == 0x0C20)
			{
				*(ebp - 0x54) = *(ebp - 0x54);
				*(ebp - 0x50) = *(ebp - 0x50);
				ecx_209 = 0x00;
				C_2533 = (bool) cond(edx_261 - 0x0936);
			}
			*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
			*(ebp - 88) = (word32) C_2533 + (*(ebp - 88) + ecx_209);
			uint32 ecx_2470 = ecx_209 - 0x90;
			uint32 edx_285 = 0x0444 - *(ebp - 0x54) - (ecx_2470 < 0x00) - ecx_2470;
			*(ebp - 0x50) = edx_285;
			*(ebp - 0x54) = *(ebp - 0x54) - edx_285;
			*(ebp - 88) = *(ebp - 88) + 0x01;
			*(ebp - 0x50) = *(ebp - 0x50) & edx_285;
			*(ebp - 88) = *(ebp - 88) ^ ecx_2470;
			if (*(ebp - 0x50) <= edx_285)
			{
				ecx_2470 = *(ebp - 0x54) ^ ~0xEE | *(ebp - 0x50);
				uint32 edx_2506 = edx_285 + ecx_2470;
				*(ebp - 0x54) = *(ebp - 0x54) | edx_2506;
				*(ebp - 88) = *(ebp - 88) | edx_2506;
			}
			up32 v83_308 = *(ebp - 88);
			*(ebp - 88) = v83_308;
			*(ebp - 0x54) = *(ebp - 0x54) - (v83_308 < 0x00);
			up32 edx_315 = ~0x00 - ecx_2470;
			if (edx_315 + 0x01 != *(ebp - 0x50))
			{
				word32 ecx_2474 = *(ebp - 88);
				up32 v85_2475 = *(ebp - 0x54) + ecx_2474;
				*(ebp - 0x54) = v85_2475;
				*(ebp - 88) = ecx_2474;
				*(ebp - 0x50) = (word32) ((bool) (v85_2475 < 0x00) + (*(ebp - 0x50) + ecx_2474));
				ecx_2470 = ecx_2474 - 0x01 ^ edx_315 + 0x01 ^ *(ebp - 0x50);
				*(ebp - 0x54) = *(ebp - 0x54) + (edx_315 + 0x01);
				if (edx_315 < ~0x09D9)
				{
l004158E7:
					uint32 edx_331 = *(ebp - 88) + 202 + eax_239;
					*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
					*(ebp - 0x54) = *(ebp - 0x54) | edx_331 - 0x01;
					ui32 ecx_2430 = ecx_2470 - (edx_315 + 0x01) + (edx_315 + 0x01) | edx_315 + 0x01;
					ui32 edx_2383 = edx_331 - 0x01;
					if (edx_331 != 0x0FB5)
					{
						*(ebp - 0x50) = *(ebp - 0x50);
						*(ebp - 88) = *(ebp - 88) - 0x01;
						ui32 eax_2448 = edx_331 - 0x01 + *(ebp - 0x54);
						if (edx_331 - 0x01 >= *(ebp - 0x50))
							*(ebp - 88) = *(ebp - 88) ^ eax_2448 - 0x01;
					}
					ui32 eax_352 = *(ebp - 0x50) ^ ecx_2430;
					*(ebp - 88) = *(ebp - 88) - eax_352;
					uint32 eax_356 = eax_352 - ecx_2430;
					if (eax_356 == 0x00)
					{
						ui32 ecx_2424 = *(ebp - 88);
						*(ebp - 0x50) = (word32) ((bool) (eax_356 < 0x00) + (*(ebp - 0x50) + ecx_2424));
						*(ebp - 88) = ecx_2424;
						*(ebp - 0x54) = *(ebp - 0x54) + ecx_2424;
						ecx_2430 = ecx_2424 & eax_356;
						if (*(ebp - 0x50) <= eax_356)
							*(ebp - 88) = *(ebp - 88) ^ eax_356;
					}
					*(ebp - 88) = *(ebp - 88) | 226;
					*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
					*(ebp - 0x54) = *(ebp - 0x54) & 226;
					*(ebp - 0x50) = *(ebp - 0x50) + 0x01;
					*(ebp - 88) = *(ebp - 88) + 0x01;
					ui32 ecx_2415 = ecx_2430 - 0x4C;
					if (false)
					{
						*(ebp - 0x50) = *(ebp - 0x50) | ecx_2415;
						ui32 ecx_2399 = (*(ebp - 0x54) & 166) - *(ebp - 88);
						ui32 eax_2401 = ecx_2399 | ~0x18A9 | ecx_2399;
						*(ebp - 0x50) = *(ebp - 0x50) & eax_2401;
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
						*(ebp - 88) = *(ebp - 88) & eax_2401;
						*(ebp - 0x54) = *(ebp - 0x54) - eax_2401;
						ecx_2415 = ecx_2399 | *(ebp - 88);
					}
					ui32 ecx_401 = ecx_2415 - *(ebp - 0x50);
					*(ebp - 0x54) = *(ebp - 0x54) | edx_331 - 0x01;
					up32 v109_409 = *(ebp - 0x54) - (edx_331 - 0x01);
					*(ebp - 0x54) = v109_409;
					*(ebp - 0x50) = *(ebp - 0x50) - (edx_331 - 0x01) - (v109_409 < 0x00);
					*(ebp - 88) = *(ebp - 88) & 0x4F;
					uint32 eax_419 = (edx_331 - 0x01 | 0x4F) - (edx_331 - 0x01);
					if (eax_419 < 22)
					{
						*(ebp - 0x54) = *(ebp - 0x54) & eax_419;
						*(ebp - 0x50) = *(ebp - 0x50) ^ eax_419;
						*(ebp - 88) = *(ebp - 88) & eax_419;
						edx_2383 = *(ebp - 0x50) | ~0x8D;
						*(ebp - 88) = *(ebp - 88) - 0x01;
					}
					ui32 edx_2347 = edx_2383 & 0x00;
					uint32 eax_433 = (0x00 - *(ebp - 88) | edx_2347) - 0x01 - edx_2347;
					*(ebp - 88) = (word32) ((bool) (eax_433 < 0x00) + (*(ebp - 88) + eax_433));
					*(ebp - 0x54) = *(ebp - 0x54) + eax_433;
					*(ebp - 88) = v118;
					ui32 eax_2363 = eax_433 & edx_2347;
					if (true)
					{
						edx_2347 = *(ebp - 88) + 0x0104 + *(ebp - 0x50);
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						ui32 eax_2350 = eax_2363 + edx_2347 + edx_2347 + 100 | edx_2347;
						*(ebp - 0x50) = *(ebp - 0x50) | eax_2350;
						*(ebp - 88) = *(ebp - 88) + eax_2350;
						*(ebp - 0x54) = edx_2347;
						*(ebp - 0x54) = *(ebp - 0x54) | eax_2350;
						eax_2363 = eax_2350 & edx_2347;
					}
					*(ebp - 0x54) = *(ebp - 0x54) + eax_2363;
					*(ebp - 0x50) = *(ebp - 0x50) ^ eax_2363;
					*(ebp - 88) = *(ebp - 88) ^ eax_2363;
					*(ebp - 0x54) = *(ebp - 0x54) - edx_2347;
					uint32 eax_472 = *(ebp - 88) + *(ebp - 0x50) - 0xC2 - edx_2347;
					if (eax_472 >= 0x86)
					{
						*(ebp - 0x50) = *(ebp - 0x50) ^ 0x00;
						ui32 eax_2331 = eax_472 ^ ((eax_472 ^ 0x00 | eax_472) + *(ebp - 0x50) ^ *(ebp - 0x54));
						*(ebp - 0x50) = *(ebp - 0x50) + eax_2331;
						*(ebp - 0x54) = *(ebp - 0x54) + eax_2331;
					}
					ui32 eax_484 = *(ebp - 88);
					*(ebp - 0x50) = eax_484 - 0x01;
					*(ebp - 88) = *(ebp - 88) + (eax_484 - 0x01);
					ui32 eax_489 = eax_484 - 0x01 & ecx_401;
					*(ebp - 0x50) = *(ebp - 0x50) + (eax_489 + 0x1500);
					ui32 eax_2292 = eax_489 + 0x1500;
					if (*(ebp - 0x50) < eax_489 + 0x1500)
					{
						*(ebp - 88) = ecx_401;
						*(ebp - 0x50) = *(ebp - 0x50) + ecx_401;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						*(ebp - 88) = 0x00;
						ui32 eax_2300 = eax_489 + 0x1500 ^ ecx_401;
						*(ebp - 0x54) = eax_2300 + 0x01;
						*(ebp - 0x54) = eax_2300 + 0x01;
						*(ebp - 0x54) = *(ebp - 0x54) + (eax_2300 + 0x01);
						eax_2292 = eax_2300 + 0x01;
					}
					*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
					uint32 ecx_506 = eax_2292 & 0x01;
					if (ecx_506 == *(ebp - 88))
					{
						word32 eax_2285 = *(ebp - 88);
						*(ebp - 0x54) = *(ebp - 0x54) + eax_2285;
						*(ebp - 0x54) = eax_2285;
						eax_2292 = eax_2285 + 0x0EE7 - *(ebp - 0x50) - *(ebp - 0x54);
						*(ebp - 0x50) = *(ebp - 0x50) + ecx_506;
						*(ebp - 0x54) >= ecx_506;
					}
					ui32 ecx_515 = ecx_506 & eax_2292;
					ui32 edx_518 = 0x00 - *(ebp - 0x54) | ecx_515;
					*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
					if (((edx_518 | ecx_515 | ecx_515) & *(ebp - 88)) <= *(ebp - 88))
					{
						*(ebp - 0x54) = *(ebp - 0x54) | 2472;
						*(ebp - 88) = *(ebp - 88) + 2472;
					}
					GetCommandLineA();
					*(ebp - 0x54) = (union Eq_66 *) GetModuleHandleA(null);
					GetOEMCP();
					GetOEMCP();
					VirtualAllocEx((void *) ~0x00, 0x00, 0x0B00, *(ebp - 0x54), *(ebp - 88));
					Eq_85 esi_563 = *(ebp - 88);
					IsChild(esi_563, *(ebp - 0x54));
					*(ebp - 0x50) = (union Eq_35 *) GetCursor();
					GetVersionExA(ebp - 0x50);
					*(ebp - 0x50) = (union Eq_35 *) GetOEMCP();
					GetVersionExA(ebp - 88);
					*(ebp - 0x54) = (int32) GetVersionExA(ebp - 0x50);
					Eq_5385 edx_2252 = ebp - 0x50;
					uint32 ecx_593 = ebp - 0x50 ^ ebp - 0x50;
					if (ecx_593 <= 0x18E3)
					{
						*(ebp - 0x54) = *(ebp - 0x54) - 0x01;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						*(ebp - 0x54) = 0x00;
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						ui32 edx_2241 = *(ebp - 88) ^ ~0x00 ^ *(ebp - 88);
						*(ebp - 0x50) = *(ebp - 0x50) - 0x01;
						up32 v148_2246 = *(ebp - 0x50) - edx_2241;
						*(ebp - 0x50) = v148_2246;
						*(ebp - 0x50) = *(ebp - 0x50) - edx_2241 - (v148_2246 < 0x00);
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
						edx_2252 = edx_2241 & (ecx_593 + 0x2A00 & edx_2241);
						*(ebp - 0x50) = *(ebp - 0x50) & edx_2252;
						*(ebp - 0x54) = (word32) edx_2252 + *(ebp - 0x54);
						*(ebp - 0x54) = *(ebp - 0x54) + 0x01;
					}
					*(ebp - 0x54) = *(ebp - 0x54) | edx_2252;
					*(ebp - 88) = (word32) edx_2252 + *(ebp - 88);
					*(ebp - 0x54) = *(ebp - 0x54) ^ edx_2252;
					*(ebp - 0x50) = *(ebp - 0x50) & edx_2252;
					*(ebp - 0x54) = (union Eq_5385 *) edx_2252;
					*(ebp - 0x50) = (union Eq_35 *) GetOEMCP();
					Eq_66 eax_621 = GetModuleHandleA(null);
					*(ebp - 0x50) = (union Eq_66 *) eax_621;
					ui32 ecx_628 = *(ebp - 0x54) ^ 0x26;
					*(ebp - 0x50) = *(ebp - 0x50) ^ ecx_628 + 0x07;
					*(ebp - 0x54) = *(ebp - 0x54) - (ecx_628 + 0x07);
					ui32 ecx_2217 = ecx_628 + 131;
					if (*(ebp - 88) > ecx_628 + 131)
					{
						*(ebp - 0x54) = *(ebp - 0x54);
						uint32 ecx_2216 = ecx_628 + 131 ^ 0x00;
						ecx_2217 = ecx_2216 - 0x01;
						if (ecx_2216 - 0x01 >= *(ebp - 0x54))
							*(ebp - 88) = *(ebp - 88) ^ ecx_2216 - 0x01;
					}
					ui32 ecx_646 = ecx_2217 | *(ebp - 0x50);
					*(ebp - 0x50) = *(ebp - 0x50) + (eax_621 ^ 0x0D33);
					*(ebp - 0x54) = *(ebp - 0x54) + (eax_621 ^ 0x0D33);
					*(ebp - 88) = *(ebp - 88) + (eax_621 ^ 0x0D33);
					*(ebp - 88) = *(ebp - 88) - 0x01;
					ui32 edx_677 = *(ebp - 0x54) - 0x01 | ecx_646;
					*(ebp - 0x54) = *(ebp - 0x54) & ecx_646;
					*(ebp - 0x54) = *(ebp - 0x54) - ecx_646;
					uint32 ecx_683 = ecx_646 + *(ebp - 88);
					ui32 ecx_686 = ecx_683 + *(ebp - 0x50) + (ecx_683 < 0x00);
					uint32 edx_693 = (edx_677 + ecx_686 - 116 | ecx_686) + 0x0E65 - *(ebp - 0x50);
					word32 ecx_690 = *(ebp - 0x54);
					up32 v168_696 = (bool) (edx_693 < 0x00) + (*(ebp - 88) + edx_693);
					*(ebp - 88) = v168_696;
					*(ebp - 0x54) = (word32) ((bool) (v168_696 < 0x00) + (*(ebp - 0x54) + ecx_690));
					ptr32 esp_703;
					word32 eax_704;
					word32 * ebp_705;
					byte SCZO_706;
					word32 ecx_707;
					byte SZO_708;
					byte CZ_709;
					bool C_710;
					word32 edx_711;
					bool Z_712;
					word32 esi_713;
					word32 edi_714;
					struct Eq_5833 * fs_715;
					byte cl_716;
					byte ch_717;
					word32 ebx_718;
					MSVCRT.dll!log10();
					*(ebp_705 - 0x0C) = ecx_707;
					ui32 eax_721 = *(ebp_705 - 0x50);
					ui32 edx_723 = edx_711 + 161 | eax_721;
					uint32 edx_2187 = edx_723 - 0x51;
					uint32 eax_2191 = (eax_721 - *(ebp_705 - 0x50) + (edx_723 - 0x51) - 66 | edx_723 - 0x51) + *(ebp_705 - 88);
					if (*(ebp_705 - 88) > eax_2191)
					{
						*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - (edx_723 - 0x51);
						*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
						edx_2187 = (eax_2191 + 0x035B ^ *(ebp_705 - 0x50)) - *(ebp_705 - 0x50);
						eax_2191 = eax_2191 - 0x01 - edx_2187 - edx_2187;
						*(ebp_705 - 88) = eax_2191;
						up32 v172_2198 = *(ebp_705 - 88) - edx_2187 - (eax_2191 < 0x00);
						*(ebp_705 - 88) = v172_2198;
						*(ebp_705 - 0x50) = (word32) ((bool) (v172_2198 < 0x00) + (*(ebp_705 - 0x50) + edx_2187));
						*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ edx_2187;
					}
					ui32 edx_741 = edx_2187 | *(ebp_705 - 88);
					*(ebp_705 - 0x54) = eax_2191;
					*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + eax_2191;
					*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x01;
					ui32 eax_750 = eax_2191 ^ *(ebp_705 - 88);
					up32 v177_755 = *(ebp_705 - 88);
					*(ebp_705 - 88) = v177_755;
					*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - (v177_755 < 0x00);
					*(ebp_705 - 0x54) = *(ebp_705 - 0x54) & 0x00;
					uint32 ecx_765 = eax_750 & 0x00 | eax_750;
					if (ecx_765 > 0x00)
					{
						word32 eax_2166 = *(ebp_705 - 0x54);
						*(ebp_705 - 0x54) = eax_2166;
						*(ebp_705 - 88) = (word32) ((bool) (ecx_765 < 0x00) + (*(ebp_705 - 88) + eax_2166));
						if ((eax_2166 ^ ecx_765 ^ ecx_765 ^ *(ebp_705 - 0x54)) < *(ebp_705 - 88))
						{
l00415CF2:
							GetCommandLineA();
							*(ebp_705 - 88) = *(ebp_705 - 88) & edx_741;
							ui32 eax_783 = *(ebp_705 - 0x50);
							*(ebp_705 - 88) = *(ebp_705 - 88) ^ ((eax_783 ^ 0x00) ^ eax_783);
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - eax_783;
							*(ebp_705 - 88) = *(ebp_705 - 88) | eax_783;
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x01;
							*(esp_703 - 0x04) = 0x00;
							*(ebp_705 - 88) = (union Eq_66 *) GetModuleHandleA(*(esp_703 - 0x04));
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x01;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - 0x01;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
							*(ebp_705 - 88) = *(ebp_705 - 88) | 114;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - 114;
							GetOEMCP();
							*(esp_703 - 0x04) = ebp_705 - 88;
							GetVersionExA(*(esp_703 - 0x04));
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) ^ 3613;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) ^ 0x0E1E;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
							*(ebp_705 - 0x50) = (word32) ((bool) ((*(ebp_705 - 88) | 0x0E1E) < 0x0E1E) + (*(ebp_705 - 0x50) + 0x0E1E));
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + 0x01;
							up32 v196_848 = *(ebp_705 - 88) - 0x0E1E;
							*(ebp_705 - 88) = v196_848;
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x0E1E - (v196_848 < 0x00);
							*(ebp_705 - 88) = *(ebp_705 - 88) - 0x01;
							GetCursor();
							*(esp_703 - 0x04) = *(ebp_705 - 0x50);
							*(esp_703 - 0x08) = *(ebp_705 - 88);
							*(esp_703 - 0x0C) = 0x0A00;
							*(esp_703 - 0x10) = 0x00;
							*(esp_703 - 0x14) = ~0x00;
							VirtualAllocEx(*(esp_703 - 0x14), *(esp_703 - 0x10), *(esp_703 - 0x0C), *(esp_703 - 0x08), *(esp_703 - 0x04));
							word32 edx_872 = *(ebp_705 - 88);
							*(esp_703 - 0x04) = edx_872;
							*(esp_703 - 0x08) = *(ebp_705 - 88);
							IsChild(*(esp_703 - 0x08), *(esp_703 - 0x04));
							*(esp_703 - 0x04) = *(ebp_705 - 0x54);
							ui32 edi_883 = *(ebp_705 - 88);
							*(esp_703 - 0x08) = edi_883;
							IsChild(*(esp_703 - 0x08), *(esp_703 - 0x04));
							struct Eq_6525 * esi_888 = fs_715->ptr0030;
							ui32 edx_2145 = edx_872 + esi_888->dwFFFEE1D1;
							*(esp_703 - 0x04) = *(ebp_705 - 0x0C);
							int32 eax_1188 = lstrlenA(*(esp_703 - 0x04));
							up32 ecx_903 = *(ebp_705 - 0x50);
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - (ecx_903 + 0x01) - (ecx_903 < 0x00);
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) & ecx_903 + 0x01;
							uint32 ecx_912 = ecx_903 + 0x01 & edx_2145;
							if (*(ebp_705 - 88) >= ecx_912)
							{
								*(ebp_705 - 88) = *(ebp_705 - 88);
								*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
								up32 edx_2142 = 0x01 - ecx_912;
								edx_2145 = (ui32) ((bool) (edx_2142 < 0x00) + (edx_2142 + *(ebp_705 - 88)));
								if (edx_2145 == 0x00)
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + ecx_912;
							}
							if (eax_1188 != 0x05)
							{
								*(esp_703 - 0x04) = 0x09;
								*(esp_703 - 0x08) = 0x13;
								*(esp_703 - 0x0C) = ebp_705 - 88;
								*(esp_703 - 0x10) = ebp_705 - 0x54;
								*(esp_703 - 0x14) = ebp_705 - 88;
								int32 eax_938 = GetMenuItemCount(*(esp_703 - 0x14));
								*(esp_703 - 0x14) = 0x5E;
								*(esp_703 - 0x18) = 0x69;
								*(esp_703 - 0x1C) = ebp_705 - 0x50;
								*(esp_703 - 0x20) = 88;
								*(esp_703 - 0x24) = ebp_705 - 88;
								*(esp_703 - 0x28) = eax_938;
								GetKeyNameTextA(*(esp_703 - 0x28), *(esp_703 - 0x24), *(esp_703 - 0x20));
								*(esp_703 - 0x20) = 0x2F;
								*(esp_703 - 0x24) = 22;
								*(esp_703 - 0x28) = 0x4F;
								*(esp_703 - 44) = ebp_705 - 88;
								Eq_296 eax_964 = GetKeyboardState(*(esp_703 - 44));
								*(esp_703 - 44) = 0x5B;
								*(esp_703 - 0x30) = ebp_705 - 88;
								*(esp_703 - 0x34) = ebp_705 - 0x50;
								*(esp_703 - 0x38) = (int32) eax_964;
								GetKeyboardLayoutNameA(*(esp_703 - 0x38));
								*(esp_703 - 0x38) = 0x57;
								*(esp_703 - 0x3C) = 0x67;
								*(esp_703 - 0x40) = ebp_705 - 0x54;
								*(esp_703 - 0x44) = ebp_705 - 88;
								GetKeyboardLayout(*(esp_703 - 0x44));
								*(esp_703 - 0x44) = 0x54;
								*(esp_703 - 0x48) = ebp_705 - 0x54;
								*(esp_703 - 0x4C) = 0x69;
								GetMenuStringA(*(esp_703 - 0x4C), *(esp_703 - 0x48), *(esp_703 - 0x44), *(esp_703 - 0x40), *(esp_703 - 0x3C));
								*(esp_703 - 0x3C) = ebp_705 - 88;
								*(esp_703 - 0x40) = 0x5C;
								*(esp_703 - 0x44) = ebp_705 - 88;
								GetMenuState(*(esp_703 - 0x44), *(esp_703 - 0x40), *(esp_703 - 0x3C));
								*(esp_703 - 0x3C) = ebp_705 - 88;
								*(esp_703 - 0x40) = 0x1A;
								*(esp_703 - 0x44) = ebp_705 - 88;
								GetKeyboardLayoutList(*(esp_703 - 0x44), *(esp_703 - 0x40));
								*(esp_703 - 0x40) = 0x57;
								*(esp_703 - 0x44) = ebp_705 - 0x50;
								GetMenuItemCount(*(esp_703 - 0x44));
								*(esp_703 - 0x44) = 0x0E;
								*(esp_703 - 0x48) = ebp_705 - 88;
								*(esp_703 - 0x4C) = 88;
								*(esp_703 - 0x50) = 0x46;
								GetKeyboardLayoutList(*(esp_703 - 0x50), *(esp_703 - 0x4C));
								*(esp_703 - 0x4C) = 0x00;
								ExitProcess(*(esp_703 - 0x4C));
							}
							*(ebp_705 - 88) = *(ebp_705 - 88) + edx_2145;
							ui32 edx_1040 = edx_2145 - *(ebp_705 - 0x50);
							ui32 edx_1047 = (edx_1040 + 0xBB ^ *(ebp_705 - 0x54)) - *(ebp_705 - 0x54);
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - edx_1047;
							*(ebp_705 - 88) = *(ebp_705 - 88) - edx_1047;
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ edx_1047;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | edx_1047;
							ui32 ecx_1043 = 0x01 - edx_1040 ^ edx_1040;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + ecx_1043;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | ecx_1043;
							ui32 ecx_1066 = ecx_1043 + *(ebp_705 - 0x54) ^ *(ebp_705 - 0x54);
							*(ebp_705 - 88) = *(ebp_705 - 88) + ecx_1066;
							*(ebp_705 - 88) = *(ebp_705 - 88) | ecx_1066;
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + (ecx_1066 - *(ebp_705 - 0x50) ^ *(ebp_705 - 0x50));
							uint32 edx_1082 = (0x00 - *(ebp_705 - 0x54) & *(ebp_705 - 88)) + *(ebp_705 - 0x54);
							*(ebp_705 - 88) = *(ebp_705 - 88) - *(ebp_705 - 0x50);
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) & edx_1082;
							*(ebp_705 - 88) = *(ebp_705 - 88) + edx_1082;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - edx_1082;
							uint32 ecx_1099 = *(ebp_705 - 0x54) & 0x00 ^ *(ebp_705 - 88);
							*(ebp_705 - 88) = *(ebp_705 - 88) + ecx_1099;
							uint32 ecx_1103 = ecx_1099 - 0x02;
							if (ecx_1099 - 0x02 < *(ebp_705 - 88))
							{
								*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
								edx_1082 = (ecx_1099 - 0x02 & 0x00) + *(ebp_705 - 0x50);
								ecx_1103 = ecx_1099 - 0x02 ^ edx_1082;
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - ecx_1103;
								*(ebp_705 - 88) = *(ebp_705 - 88) & ecx_1103;
								*(ebp_705 - 88) = *(ebp_705 - 88) ^ ecx_1103;
							}
							ui32 edx_1115 = 166 - *(ebp_705 - 0x50) - (edx_1082 - ecx_1103 < 0x00);
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | ecx_1103;
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x01;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
							*(ebp_705 - 88) = edx_1115;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) & edx_1115;
							ui32 edx_1133 = edx_1115 - *(ebp_705 - 0x50) + *(ebp_705 - 88);
							*(ebp_705 - 88) = *(ebp_705 - 88);
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50);
							*(ebp_705 - 88) = *(ebp_705 - 88);
							up32 ecx_1143 = *(ebp_705 - 0x50) + 0x6A;
							*(ebp_705 - 88) = *(ebp_705 - 88) - ecx_1143 - (ecx_1143 < 0x00);
							ui32 ecx_1148 = ecx_1143 ^ edx_1133;
							if (true)
							{
								*(ebp_705 - 0x50) = 0x41;
								ui32 edx_2090 = (ecx_1148 | 66) + *(ebp_705 - 0x54);
								*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | (ecx_1148 & edx_2090) + 117;
								*(ebp_705 - 88) = *(ebp_705 - 88) - 0x01;
								*(ebp_705 - 88) = *(ebp_705 - 88) - edx_2090;
							}
							uint32 ecx_1174 = (*(ebp_705 - 0x54) & *(ebp_705 - 0x50)) - *(ebp_705 - 88) - 0x01 | eax_1188;
							*(ebp_705 - 88) = *(ebp_705 - 88) + ecx_1174;
							if (*(ebp_705 - 0x50) > ecx_1174 - 0x0E00)
							{
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x59 - (*(ebp_705 - 0x50) < ecx_1174 - 0x0E00);
								eax_1188 = 0x9A;
								if (ecx_1174 <= 3688 && ecx_1174 >= 0x0E00)
								{
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + 0x01;
									eax_1188 = ecx_1174 - 0x0E00 | 0x9A;
								}
							}
							*(ebp_705 - 0x50) = eax_1188;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
							int32 eax_1192 = eax_1188 + 0x01;
							word32 ecx_1197 = *(ebp_705 - 0x54);
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) | eax_1192 - 0xB7;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | eax_1192 - 0xB7;
							*(ebp_705 - 88) = *(ebp_705 - 88) + (eax_1192 - 0xB7);
							word32 ecx_1208 = ecx_1197 + (eax_1192 - 0xB7) - *(ebp_705 - 0x50);
							*(ebp_705 - 88) = *(ebp_705 - 88) + (ecx_1208 - 0x9C);
							int32 eax_1193 = eax_1192 - 0xB7;
							ui32 ecx_1212 = ecx_1208 - 0x9D;
							if (true)
							{
								*(ebp_705 - 88) = *(ebp_705 - 88) - (eax_1192 - 0xB7);
								*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - (eax_1192 - 0xB7);
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) & 121;
								eax_1193 = (ecx_1208 - 0x9D ^ ~0x1686) + *(ebp_705 - 88) + *(ebp_705 - 88);
								ecx_1212 = ecx_1208 - 0x9D - eax_1193 - 0x01 - eax_1193;
							}
							ui32 eax_1224 = eax_1193 - 0x01 | ecx_1212;
							uint32 edx_1233 = ((0x00 - *(ebp_705 - 0x54) | *(ebp_705 - 88)) & *(ebp_705 - 0x54)) + *(ebp_705 - 0x54) & eax_1224;
							*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + edx_1233;
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) | edx_1233;
							if (edx_1233 - 0x0B00 > *(ebp_705 - 88))
							{
								*(ebp_705 - 88) = 0x00;
								*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
								ui32 edx_2009 = edx_1233 - 0x0B00 | eax_1224;
								ui32 edx_2018 = edx_2009 - 0x01 - edx_2009;
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ edx_2018;
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - edx_2018;
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) & edx_2018;
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ edx_2018;
								*(ebp_705 - 0x50) = edx_2009;
								*(ebp_705 - 88) = *(ebp_705 - 88) & edx_2009;
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + edx_2018;
							}
							*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
							uint32 eax_1269 = (*(ebp_705 - 88) | *(ebp_705 - 0x50)) & ecx_1212;
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - eax_1269;
							ui32 edx_1262 = 0x00;
							ui32 eax_1273 = eax_1269 + 0x07;
							if (eax_1269 <= 0x07)
							{
								ui32 ecx_1994 = (eax_1269 + 0x07 & 0x0900) - 0xA3 | *(ebp_705 - 88);
								ui32 eax_1995 = eax_1269 + 0x07 & ecx_1994;
								*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + (eax_1995 - 0x01);
								*(ebp_705 - 0x50) = *(ebp_705 - 0x50) & eax_1995 - 0x01;
								eax_1273 = eax_1995 - 0xF1 - ecx_1994;
							}
							*(ebp_705 - 0x54) = *(ebp_705 - 0x54) & eax_1273;
							*(ebp_705 - 0x50) = *(ebp_705 - 0x50) | 2524;
							word32 eax_1291 = 2525;
							if (*(ebp_705 - 88) >= 2525)
							{
								edx_1262 = *(ebp_705 - 0x54) ^ 0x00;
								if (*(ebp_705 - 0x50) >= 2525)
								{
l00416193:
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + edx_1262;
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + edx_1262;
									*(ebp_705 - 88) = *(ebp_705 - 88) | edx_1262;
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x3A;
									uint32 ecx_1310 = (*(ebp_705 - 88) & 0x3A) + *(ebp_705 - 0x54);
									ui32 ecx_1315 = (word32) (SEQ(ecx_1310, ecx_1310) + *(ebp_705 - 0x54)) | *(ebp_705 - 88);
									*(ebp_705 - 88) = eax_1291;
									uint32 ecx_1321 = ecx_1315 + *(ebp_705 - 0x50) + *(ebp_705 - 0x54);
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - (SEQ(ecx_1321, ecx_1321) < 0x00);
									*(ebp_705 - 88) = 0x00;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - 0x01;
									ui32 eax_1334 = *(ebp_705 - 88) & 0x00 | *(ebp_705 - 0x50);
									*(ebp_705 - 88) = *(ebp_705 - 88) - eax_1334;
									ui32 edx_1338 = *(ebp_705 - 88);
									ui32 edx_1340 = edx_1338 | *(ebp_705 - 0x54);
									ui32 eax_1346 = (eax_1334 + edx_1338 + edx_1340 ^ edx_1340) + *(ebp_705 - 0x54) + *(ebp_705 - 0x50);
									uint32 ecx_1352 = *(ebp_705 - 0x50) - eax_1346 | eax_1346;
									*(ebp_705 - 88) = *(ebp_705 - 88) ^ eax_1346;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | eax_1346;
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ ecx_1352;
									*(ebp_705 - 88) = *(ebp_705 - 88) + ecx_1352;
									if (*(ebp_705 - 0x50) >= ecx_1352)
									{
										*(ebp_705 - 88) = *(ebp_705 - 88);
										*(ebp_705 - 88) = 0x00;
										*(ebp_705 - 0x54) = *(ebp_705 - 0x54) & 0x00;
										eax_1346 = ecx_1352 ^ 0x00;
										if (*(ebp_705 - 88) >= (ecx_1352 ^ 0x00))
											eax_1346 = (ecx_1352 ^ 0x00) + 0x01;
									}
									if (edx_1340 != *(ebp_705 - 88))
									{
										*(ebp_705 - 88) = *(ebp_705 - 88) - 0x01;
										*(ebp_705 - 88) = *(ebp_705 - 88) + 0x8B;
										uint32 edx_1927 = *(ebp_705 - 0x50) | 0x8B;
										if (edx_1927 > 0x00)
											*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | edx_1927;
									}
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | eax_1346;
									*(ebp_705 - 0x50) = 0x03B6;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | 0x03B6;
									up32 v286_1396 = *(ebp_705 - 0x50) + 0x03B6;
									*(ebp_705 - 0x50) = v286_1396;
									*(ebp_705 - 88) = (word32) ((bool) (v286_1396 < 0x00) + (*(ebp_705 - 88) + 0x03B6));
									up32 v288_1402 = *(ebp_705 - 0x50) + eax_1346;
									*(ebp_705 - 0x50) = v288_1402;
									*(ebp_705 - 88) = (word32) ((bool) (v288_1402 < 0x00) + (*(ebp_705 - 88) + eax_1346));
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) ^ 0x03B6;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - 0x03B6;
									uint32 edx_1422 = *(ebp_705 - 88) + 0x0BF9;
									up32 v292_1428 = *(ebp_705 - 88) - edx_1422 - (edx_1422 < 0x00);
									*(ebp_705 - 88) = v292_1428;
									*(ebp_705 - 0x54) = (word32) ((bool) (v292_1428 < 0x00) + (*(ebp_705 - 0x54) + edx_1422));
									ui32 eax_1418 = 299;
									byte SCZO_1434 = cond(*(ebp_705 - 0x50) - edx_1422);
									if (*(ebp_705 - 0x50) > edx_1422)
									{
										*(ebp_705 - 0x54) = (word32) ((bool) (*(ebp_705 - 0x50) < edx_1422) + (*(ebp_705 - 0x54) + 299));
										eax_1418 = (*(ebp_705 - 0x50) ^ *(ebp_705 - 0x54)) + *(ebp_705 - 0x50);
										edx_1422 = edx_1422 | eax_1418;
										*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + edx_1422;
										*(ebp_705 - 88) = *(ebp_705 - 88) - edx_1422;
										*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
										*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | edx_1422;
										*(ebp_705 - 0x54) = *(ebp_705 - 0x54) & edx_1422;
									}
									uint32 eax_1441 = eax_1418 + edx_1422;
									ui32 edx_1447 = *(ebp_705 - 0x54) - *(ebp_705 - 88) - (eax_1441 < 0x00) & eax_1441;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
									*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
									*(ebp_705 - 88) = *(ebp_705 - 88) - edx_1447;
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - edx_1447;
									*(ebp_705 - 88) = *(ebp_705 - 88) ^ edx_1447;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) & edx_1447;
									uint32 edx_1462 = edx_1447 + eax_1441;
									if (!DPB(SCZO_1434, false, 0))
									{
										*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + 0x01;
										*(ebp_705 - 88) = *(ebp_705 - 88) | 0xF6;
										*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + 0xF6;
									}
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) | edx_1462;
									ui32 eax_1485 = *(ebp_705 - 0x54);
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x01;
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ 9447;
									ui32 ecx_1492 = eax_1485 | 9447 | eax_1485;
									ui32 eax_1493 = *(ebp_705 - 0x54);
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - ecx_1492;
									*(ebp_705 - 88) = ecx_1492;
									*(ebp_705 - 88) = *(ebp_705 - 88) | ecx_1492 + 0x02;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ 0x00;
									*(ebp_705 - 88) = 0x00;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) & 0x00;
									*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - eax_1493;
									uint32 edx_1524 = *(ebp_705 - 0x50) ^ 0x00 ^ eax_1493 | eax_1493;
									*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - (edx_1524 + 0x01);
									ui32 ecx_1504 = 0x00;
									ui32 eax_1508 = eax_1493;
									if (edx_1524 <= ~0x4C)
									{
										*(ebp_705 - 0x54) = *(ebp_705 - 0x54) ^ 0x00;
										*(ebp_705 - 88) = edx_1524 + 0x01;
										*(ebp_705 - 88) = *(ebp_705 - 88) - (edx_1524 + 0x01);
										eax_1508 = 0x00;
										if (edx_1524 + 0x01 == *(ebp_705 - 88))
										{
l00416363:
											*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - 0x68;
											*(ebp_705 - 88) = *(ebp_705 - 88) & 0x68;
											if (0x01 != 0x00)
											{
												up32 v323_1837 = *(ebp_705 - 0x54);
												*(ebp_705 - 0x54) = v323_1837;
												*(ebp_705 - 0x54) = 0x00;
												*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x01;
												ecx_1504 = (ui32) ((bool) (v323_1837 < 0x00) + *(ebp_705 - 0x54));
												0x01 == *(ebp_705 - 0x54);
											}
											uint32 edx_1560 = *(ebp_705 - 0x54) | ecx_1504;
											*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - edx_1560;
											Eq_9077 C_1570 = (bool) cond(*(ebp_705 - 0x54) - edx_1560);
											if (*(ebp_705 - 0x54) >= edx_1560)
											{
												*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - ecx_1504 - (*(ebp_705 - 0x54) < edx_1560);
												*(ebp_705 - 0x54) = *(ebp_705 - 0x54) ^ ecx_1504;
												*(ebp_705 - 0x54) = *(ebp_705 - 0x54);
												*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - 0x01;
												*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ 0x00;
												ui32 edx_1800 = edx_1560 & ecx_1504;
												ecx_1504 = (edx_1800 - 0x01 & 0x00 ^ edx_1800 - 0x01) - *(ebp_705 - 0x54);
												*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + 0x01;
												*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + 0x01;
												*(ebp_705 - 0x50) = *(ebp_705 - 0x50) & ecx_1504;
												ui32 edx_1818 = edx_1800 - 0x01 + ecx_1504;
												*(ebp_705 - 0x54) = edx_1818;
												*(ebp_705 - 0x54) = edx_1818;
												C_1570.u0 = false;
											}
											up32 edx_1580 = 0x04DE - eax_1508;
											ui32 ecx_1575 = ecx_1504 - *(ebp_705 - 0x50) - C_1570;
											*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + (edx_1580 + 0x01);
											byte SCZO_1588 = cond(edx_1580 + 0x81 - *(ebp_705 - 88));
											if (edx_1580 + 0x81 <= *(ebp_705 - 88))
											{
												*(ebp_705 - 0x50) = *(ebp_705 - 0x50) + 0x01;
												*(ebp_705 - 88) = *(ebp_705 - 88) - 151;
												if (DPB(SCZO_1588, false, 0))
												{
l00416404:
													ui32 eax_1600 = *(ebp_705 - 0x50) + 0x01 - ecx_1575 & ecx_1575 | *(ebp_705 - 88);
													*(ebp_705 - 0x54) = eax_1600;
													*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - eax_1600;
													*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - eax_1600;
													if (true)
													{
														word32 ecx_1747 = *(ebp_705 - 88);
														*(ebp_705 - 0x50) = *(ebp_705 - 0x50) - ecx_1747;
														*(ebp_705 - 88) = *(ebp_705 - 88) ^ ecx_1747;
														*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
														up32 ecx_1755 = ecx_1747 - (eax_1600 + 0x01);
														ecx_1575 = (ui32) ((bool) (ecx_1755 < 0x00) + (ecx_1755 + *(ebp_705 - 88)));
													}
													ui32 eax_1619 = eax_1600 + 0x01 ^ *(ebp_705 - 0x54);
													uint32 edx_1626 = (*(ebp_705 - 0x50) & 166) - *(ebp_705 - 0x54) ^ eax_1619 | eax_1619 | eax_1619;
													byte SCZO_1630 = cond(edx_1626);
													if (edx_1626 <= 0x00)
													{
														*(ebp_705 - 0x50) = 0x25;
														*(ebp_705 - 88) = *(ebp_705 - 88) - 0x25;
														ui32 eax_1731 = (edx_1626 & 0x25) - *(ebp_705 - 0x50) | *(ebp_705 - 0x50);
														if (!DPB(SCZO_1630, false, 0))
														{
															*(ebp_705 - 0x54) = *(ebp_705 - 0x54) + eax_1731;
															edx_1626 = edx_1626 - 0xFA;
														}
													}
													ui32 eax_1638 = 0x00 - *(ebp_705 - 0x54) + *(ebp_705 - 88) + edx_1626 | edx_1626;
													*(ebp_705 - 0x50) = *(ebp_705 - 0x50) | eax_1638;
													*(ebp_705 - 0x54) = eax_1638;
													*(ebp_705 - 0x50) = *(ebp_705 - 0x50) ^ edx_1626;
													*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - edx_1626;
													*(ebp_705 - 88) = edx_1626;
													uint32 eax_1643 = eax_1638 & edx_1626;
													if (*(ebp_705 - 88) != eax_1643)
													{
														ui32 eax_1705 = eax_1643 - *(ebp_705 - 88) - (*(ebp_705 - 88) < eax_1643);
														*(ebp_705 - 88) = *(ebp_705 - 88) + 0x01;
														*(ebp_705 - 88) = *(ebp_705 - 88) - 0x01;
														*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - 0x01;
														*(ebp_705 - 88) = *(ebp_705 - 88) & eax_1705;
													}
													word32 edx_1664;
													word32 ebx_1665;
													word32 esi_1666;
													word32 edi_1667;
													*(ebp_705 - 0x54) = *(ebp_705 - 0x54) | fn00411DB0(ecx_1575, &esi_888->dwFFFEE1D1, edi_883, out edx_1664, out ebx_1665, out esi_1666, out edi_1667);
													ui32 ecx_1677 = *(ebp_705 - 0x50) + 0x5E;
													ui32 eax_1681 = *(ebp_705 - 0x50) ^ 3227;
													*(ebp_705 - 0x50) = *(ebp_705 - 0x50) & ecx_1677;
													*(ebp_705 - 0x54) = *(ebp_705 - 0x54) - eax_1681;
													ui32 eax_1687 = eax_1681 + *(ebp_705 - 88);
													*(esp_703 - 0x04) = *(ebp_705 - 88);
													ExitThread(*(esp_703 - 0x04));
													byte cl_1679;
													*clOut = (byte) ecx_1677;
													byte ch_1680;
													*chOut = SLICE(ecx_1677, byte, 8);
													word32 ebp_1696;
													*ebpOut = *ebp_705;
													return eax_1687;
												}
											}
											goto l00416404;
										}
									}
									eax_1508 = eax_1508 & *(ebp_705 - 0x54);
									goto l00416363;
								}
								up32 eax_1979 = 2525 - edx_1262 + 0x12 + *(ebp_705 - 0x50);
								up32 eax_1982 = (bool) (eax_1979 < 0x00) + (eax_1979 + *(ebp_705 - 88));
								eax_1291 = eax_1982 - *(ebp_705 - 88) - (eax_1982 < 0x00);
							}
							*(ebp_705 - 88) = *(ebp_705 - 88) - 0x01;
							*(ebp_705 - 0x54) = eax_1291;
							goto l00416193;
						}
					}
					goto l00415CF2;
				}
				ecx_2470 = ecx_2470 | *(ebp - 0x50);
			}
			*(ebp - 0x50) = *(ebp - 0x50) + (edx_315 + 0x01);
			goto l004158E7;
		}
	}
	*(ebp - 0x54) = *(ebp - 0x54) + edx_128;
	*(ebp - 0x54) = edx_128;
	goto l0041575D;
}

// 004167AD: Register Eq_85 fn004167AD()
Eq_85 fn004167AD()
{
	GetCursor();
	Eq_66 eax_10 = GetModuleHandleA(null);
	if (false || eax_10 >= 3358)
		;
	IsChild(dwLoc0300, dwLoc0318);
	GetOEMCP();
	GetVersionExA(fp - 0x0188);
	ui32 edx_93 = dwLoc0288 - dwLocE0 ^ IsChild(dwLoc0248, dwLoc0150);
	GetCommandLineA();
	word32 ecx_124;
	fn00416E0A(dwLoc0150, out ecx_124);
	GetModuleHandleA(null);
	ui32 v21_128 = dwLoc0240 ^ ecx_124;
	if (dwLoc88 > 0x05B2)
		dwLoc98 = dwLoc98 - 0xF6;
	word32 ecx_205;
	uint32 edx_226 = (dwLoc02DC ^ dwLoc0118) - dwLoc68 & fn00416E0A(0x00, out ecx_205);
	if (edx_226 >= dwLoc0134 || (edx_226 ^ 0x00) - dwLoc026C == 0x00)
		;
	uint32 edx_263 = 0x00 - dwLoc98;
	word32 ecx_299;
	fn00416E0A(dwLoc0108 - v21_128 - (SEQ(edx_263, edx_263) + _ < 0x00) + 0x01 | dwLoc0338, out ecx_299);
	return dwLoc0318;
}

// 00416E0A: Register word32 fn00416E0A(Register Eq_85 ecx, Register out ptr32 ecxOut)
word32 fn00416E0A(Eq_85 ecx, ptr32 & ecxOut)
{
	BOOL eax_56 = IsChild(dwLocE0, dwLoc01F4);
	word32 ecx_68;
	*ecxOut = (word32) eax_56 + ((dwLocA8 ^ eax_56) - 0x01) + 0x0300 ^ 0x00;
	return 0x00;
}

// 0041736A: Register ui32 fn0041736A(Register ui32 ecx, Register out ptr32 edxOut, Register out ptr32 ediOut)
ui32 fn0041736A(ui32 ecx, ptr32 & edxOut, ptr32 & ediOut)
{
	word32 edi_33;
	*ediOut = fn004167AD();
	word32 eax_62 = VirtualAllocEx((void *) ~0x00, 0x00, 0x0200, dwLoc01AC, dwLocDC) + dwLoc017C + dwLoc01F0;
	ui32 edx_65 = dwLoc01B4 - dwLoc0184 - (dwLoc01B4 < 0x00) & eax_62 ^ eax_62 | eax_62;
	ui32 eax_70 = (edx_65 ^ 191) + dwLoc68;
	word32 edx_76;
	*edxOut = (edx_65 - eax_70 & eax_70) - eax_70;
	return eax_70;
}

// 0041762E: FlagGroup bool fn0041762E(Register Eq_35 eax, Register ui32 ecx, Register ui32 edi, Register out ptr32 eaxOut, Register out ptr32 ecxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
bool fn0041762E(Eq_35 eax, ui32 ecx, ui32 edi, ptr32 & eaxOut, ptr32 & ecxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	*ebxOut = ebx;
	uint32 edx_17 = dwLoc0134 - ecx + ecx;
	if (edx_17 > dwLoc01D4)
	{
		dwLoc013C = dwLoc013C | edx_17;
		dwLoc0118 = dwLoc0118 + edx_17;
		dwLocA4 = dwLocA4 + edx_17;
	}
	Eq_35 eax_55;
	word32 edx_56;
	up32 ecx_112 = ~0x00 - dwLoc01C0 - fn00412F4E(eax, out eax_55, out edx_56);
	up32 edx_75 = 1901 - dwLoc01CC - (ecx_112 < 0x00);
	uint32 dwLoc0208_1141 = dwLoc0208 & ~0x00;
	if (dwLoc013C != (bool) (edx_75 < 0x00) + (edx_75 + dwLoc01A0))
	{
		ecx_112 = dwLoc0220 + 0x0310;
		dwLoc0230 = dwLoc0230 + 0x0F;
		dwLoc0190 = dwLoc0190 - 0x01;
		dwLoc0174 = dwLoc0174 + 0x01;
	}
	uint32 ecx_114 = ecx_112 - dwLocF4;
	uint32 edx_133 = 0x00 - dwLocF8 & (word32) (SEQ(ecx_114, ecx_114) - _) + 0x01;
	ui32 eax_166;
	word32 edx_167;
	fn00412F4E(eax_55, out eax_166, out edx_167);
	ui32 ecx_188 = (dwLoc0168 & eax_166) - 0x01 & eax_166;
	if (ecx_188 != 0x00)
	{
		uint32 eax_2873 = (dwLoc0168 | ecx_188) - dwLoc0218 - dwLoc0108;
		if (eax_2873 <= 0x00)
		{
			dwLoc0200 = dwLoc0200 | eax_2873;
			dwLoc0150 = dwLoc0150 & eax_2873;
		}
	}
	ui32 ecx_234 = ecx_188 | dwLoc0124;
	Eq_66 esi_251 = LoadLibraryA(&globals->t404098);
	do
	{
		Eq_10065 v36_299 = (char *) &dwLoc98->unused + 0x06AD;
		uint32 edx_303 = 0x06AC - edi;
		uint32 v38_304 = dwLoc0174 - edx_303;
		word32 v39_306 = dwLoc0188 - edx_303;
		dwLoc98 = v36_299;
		dwLoc0174 = v38_304;
		dwLoc0188 = v39_306;
		if (edx_303 >= 0xC3)
		{
			dwLoc022C = dwLoc022C ^ 0xE6;
			dwLoc0130 = dwLoc0130 - 0xE6;
			edi = (edx_303 - 0x4F - dwLoc01A0 | 0xE6) - 0x01;
		}
		esi_251 = (word32) esi_251 + 0x01;
		uint32 eax_352 = (dwLoc0224 ^ 228) - dwLoc019C + 0x4C ^ ecx_234;
		if (true)
		{
			ui32 ecx_2804 = (eax_352 - 0x1564 ^ 0x00) - (eax_352 - 0x1564) ^ dwLoc0160 ^ eax_352 - 0x1564 | eax_352 - 0x1564;
			ecx_234 = ecx_2804 - 0x01;
			if (eax_352 > 0x1564)
				goto l0041785B;
			ecx_234 = ecx_2804 - 0x01 - dwLocA8 - (eax_352 < 0x1564);
		}
l0041785B:
	} while (*esi_251 != 0x75FF1075);
	ui32 edx_401 = *((word32) esi_251 - 0x01);
	Eq_163 eax_413 = VirtualAllocEx((void *) ~0x00, 0x00, 0x0001A000, 0x1000, 0x40);
	GetVersionExA(fp - 0x01E0);
	IsChild(dwLoc01B4 - 0x01, dwLoc90 + 0x01);
	ui32 v51_452 = dwLoc01A4 & (GetCursor() - (struct HICON__ *) 0xB6 ^ dwLoc0110);
	GetOEMCP();
	ui32 eax_476 = (445 - dwLoc01FC ^ 0x00) - ecx_234;
	uint32 v55_482 = dwLoc010C & eax_476;
	ui32 v56_486 = (dwLoc01CC & 0x00) + eax_476;
	uint32 eax_488 = eax_476 | ((ecx_234 + eax_476) - eax_476) + 0x01;
	GetVersionExA(fp - 0xD8);
	GetCursor();
	ui32 eax_544 = dwLoc0144 - 0x02 + dwLoc01DC + ((bool) (dwLoc0168 + dwLoc0144 < 0x00) + (dwLoc0230 + dwLoc0144) < 0x00) | dwLocC4;
	if (eax_544 != 0x00)
	{
		dwLocDC = (word32) dwLocDC + 88;
		dwLoc01F0 = dwLoc01F0 + (eax_544 - 0x1E01);
	}
	GetCommandLineA();
	Eq_10173 CZ_1023 = cond(dwLoc01B8);
	if (dwLoc01B8 <= 0x00)
	{
		ui32 eax_2646 = dwLoc0134 ^ 0xA3 ^ dwLoc015C;
		dwLoc0160 = (Eq_10044) ((word32) dwLoc0160 + 0x00A3);
		dwLoc01F0 = dwLoc01F0 ^ ((dwLoc01B8 ^ eax_2646) - eax_2646) + 0xE0;
	}
	GetVersionExA(fp - 0x021C);
	Eq_85 ecx_706 = dwLoc020C & 0x0A00 ^ fp - 0x021C;
	ui32 dwLocD4_2545 = dwLocD4 + 0x01;
	Eq_85 v72_646 = dwLoc0150 - ~0xAE;
	ui32 v74_660 = dwLoc0200 | ~0xAE;
	Eq_35 eax_2553 = GetOEMCP();
	ui32 ecx_709 = ecx_706 | fp - 0x021C | fp - 0x021C;
	if (true)
	{
		dwLoc0190 = dwLoc0190 + 1135;
		dwLocEC = fp - (struct _OSVERSIONINFOA *) 0x021C + (ecx_709 + 0x01) / 0x0098 ^ fp - (struct _OSVERSIONINFOA *) 0x021C;
	}
	ui32 edi_746 = dwLoc0220 ^ dwLocEC;
	word32 v82_748 = dwLoc01DC - ~0xAE + edi_746;
	ui32 edi_2547 = edi_746 | eax_2553 | eax_2553;
	if (true)
	{
		dwLoc0208_1141 = 118;
		eax_2553 = ((edi_2547 ^ 118) & edi_2547) - dwLocF0;
		if (dwLoc0170 == eax_2553)
		{
l00417BB2:
			word32 edi_805 = dwLoc022C & 3431 ^ ((eax_2553 + 0x4C | edi_2547) + 0x01) + edi_2547;
			ui32 edi_1140 = edi_805 - 0x01;
			if (edi_805 < 0x01)
			{
				up32 eax_2513 = 0x042D - dwLoc01AC;
				CZ_1023 = cond(eax_2513);
				if (eax_2513 <= 0x00)
				{
l00417C07:
					memcpy(eax_413, edx_401 + 19904270, 0x0EC6);
					GetCommandLineA();
					GetVersionExA(fp - (struct _OSVERSIONINFOA *) 0xD8);
					uint32 v94_820 = dwLoc014C - ~0xAE & edi_805 - 0x01;
					Eq_85 edx_2431 = dwLocDC;
					up32 ecx_875 = 2245 - (IsChild(dwLocDC, dwLoc0164) - 2245);
					GetCommandLineA();
					GetOEMCP();
					uint32 eax_916 = (dwLoc01D8 ^ ~0xAE) - dwLocD4_2545 - dwLocDC;
					word32 eax_921 = (word32) (SEQ(v30, eax_916) - SEQ(eax_916, dwLocDC));
					if (true)
						edx_2431 = 0x00 - dwLoc023C - (v55_482 < 0x00);
					GetModuleHandleA(null);
					uint32 v106_962 = (word32) edx_2431 + dwLoc01F0;
					uint32 ecx_988 = (dwLoc01C4 | ~0xAE) + 133 + (v106_962 < 0x00);
					uint32 dwLoc010C_1667 = v55_482;
					Eq_10362 v103_955 = eax_921 + 0x3C & ~0xAE;
					Eq_85 v104_958 = dwLoc0110 + 0x01;
					ui32 v107_991 = dwLoc0190 - ecx_988 - (ecx_988 < 0x00);
					if (ecx_988 == 2737)
					{
						dwLoc01F8 = dwLoc01F8 + 0x01;
						CZ_1023 = DPB(CZ_1023, false, 0);
						if (CZ_1023)
						{
l00417D49:
							IsChild(ecx_706, dwLocB0 + 0x01);
							IsChild(dwLoc0130, dwLoc0178);
							word32 edx_1069 = dwLoc0178 + v36_299;
							ui32 ecx_1081 = edx_1069 + ((dwLoc0144 ^ 0x0C0F) & edx_1069) / 0x04;
							ui32 v110_1044 = dwLoc0180 | ((dwLocD0 | dwLocB0 + 0x01) + 0x1600 | dwLocB0 + 0x01) + 0x1C00;
							uint32 v111_1091 = dwLoc01F4 | ecx_1081;
							Eq_163 edx_1106 = eax_413;
							word32 eax_1115 = 0x1000;
							do
							{
								ui32 edi_1158 = dwLocA4 & v107_991;
								uint32 v119_1160 = dwLoc0208_1141 - edi_1158;
								*edx_1106 = (((*edx_1106 ^ 3932659152) + 3932659152 ^ 3932659152) + 3932659152 ^ 3932659152) + 3932659152;
								ui32 v116_1148 = dwLoc015C + 0x69;
								ui32 v117_1150 = dwLoc0220 - 0x01;
								word32 v118_1152 = dwLocCC + 0x01;
								uint32 v120_1164 = dwLocD0 - edi_1158 - (v119_1160 < 0x00);
								uint32 edi_1167 = edi_1158 + dwLoc01C8;
								dwLoc015C = v116_1148;
								dwLoc0220 = v117_1150;
								dwLocCC = v118_1152;
								dwLoc0208_1141 = v119_1160;
								dwLocD0 = v120_1164;
								edi_1140 = (word32) (SEQ(edi_1167, edi_1167) + _) - 0x8E - v110_1044;
								edx_1106 = edx_1106 + 0x04;
								eax_1115 = eax_1115 - 0x01;
								ui32 edi_2988 = edi_1140;
							} while (eax_1115 != 0x00);
							ui32 ecx_1238 = GetVersionExA(fp - (struct _OSVERSIONINFOA *) 0x015C) - dwLoc0160 - v103_955 | (dwLoc01E0 & 0x00) + dwLocC4 | v119_1160;
							GetModuleHandleA(null);
							ui32 ecx_1244 = ecx_1238 ^ dwLoc022C;
							GetCursor();
							GetCommandLineA();
							uint32 eax_1262 = (ecx_1244 ^ 0x1E) - 0x01;
							ui32 edx_1300 = 0x24 - dwLoc01AC & (v106_962 & (ecx_1244 ^ 0x1E));
							word32 edi_1218;
							*ediOut = fp - (struct _OSVERSIONINFOA *) 0x015C;
							word32 v127_1274 = v74_660 - ~0xAE - eax_1262 - (((dwLoc0214 - 0x01) - eax_1262) - (dwLocB4 - (((dwLoc0164 + (dwLocF8 ^ 0x00)) + ((ecx_1244 + dwLoc0128) + v39_306 <u 0x00) | dwLoc01AC) | v116_1148) <u 0x00) <u 0x00);
							word32 dwLoc0140_1281 = dwLoc0140 - 0x01;
							ui32 v134_1311 = (word32) edx_1106 + v82_748 | edx_1300;
							word32 esi_1332;
							*esiOut = ~0x00EF8A00;
							if (edx_401 != ~0x00EF8A00)
							{
								GetCursor();
								uint32 ecx_2142 = v118_1152 + v111_1091;
								if ((((word32) (SEQ(dwLoc0118, ecx_2142 - 0x1500) + SEQ(ecx_2142 - 0x1500, v111_1091)) ^ edx_1300) & edx_1300) < 0x1F00)
									edx_1300 = 0xB9;
								ui32 ecx_2173 = (dwLoc0238 ^ 0x00) + edx_1300;
								word32 ecx_2181;
								*ecxOut = ecx_2173 + 0x1E00;
								uint32 eax_2214 = v127_1274 + 0xFE | dwLocAC;
								word32 eax_2216;
								*eaxOut = eax_2214 + 6655;
								bool C_2239 = (bool) cond(eax_2214 + 6655 - dwLocF0);
								if (eax_2214 + 6655 >= dwLocF0)
									C_2239 = (bool) cond(eax_2214 + 0x19BF);
								return C_2239;
							}
							GetCursor();
							GetCommandLineA();
							ui32 edx_1504 = (edi_2988 - dwLocC0 ^ dwLoc01F8) + 0x0300 | (word32) (SEQ(dwLocA0 + 0x01, ~0x5C) + SEQ(~0x5C, v94_820));
							ui32 eax_1520 = v36_299 & edx_401;
							uint32 v144_1521 = dwLoc01A8 - ~0xAD & eax_1520;
							uint32 eax_1524 = eax_1520 ^ edx_401;
							if (eax_1524 < 2502 || eax_1524 > dwLoc01D0)
								;
							uint32 ecx_1551 = 177 - edx_1504;
							ui32 v154_1562 = dwLoc0170 | edx_1504;
							if (ecx_1551 < 1517 || ecx_1551 <= v144_1521)
								;
							IsChild(v72_646, v104_958);
							Eq_85 esi_1594 = v104_958;
							uint32 edx_1609 = (0x00 - dwLoc0144 + 232 ^ ecx_1551) + ecx_1551 + ecx_1551 | ecx_1551;
							if (edx_1609 >= 0x00)
								ecx_1551 = 0x02;
							uint32 edx_1640 = ecx_1551 + 0x15 & ecx_1551;
							uint32 edx_1641 = edx_1640 - 0x01;
							if (edx_1640 < 0x0827)
							{
								edx_1641 = edx_1640 + 0x1CDF;
								dwLoc010C_1667 = edx_1640 + 0x1CDF;
							}
							GetCursor();
							GetCommandLineA();
							ui32 edx_1677 = edx_1641 & v56_486 ^ dwLocA8;
							byte SCZO_1699 = cond((edx_1677 | ~0x22) - dwLoc0108);
							if ((edx_1677 | ~0x22) > dwLoc0108)
							{
								edx_1677 = 0x11;
								dwLoc0140_1281 = dwLoc0140 - 0x01 + ((((edx_1677 | ~0x22) & dwLocC4 ^ dwLoc0204) ^ 0x11) + 0x11);
							}
							GetCursor();
							GetCommandLineA();
							GetOEMCP();
							ui32 ecx_1733 = (edx_1677 ^ 0x0231) + eax_476;
							ui32 v185_1741 = v154_1562 + ecx_1733;
							ui32 v187_1748 = v103_955 & ecx_1733;
							word32 ebx_1781;
							*ebxOut = GetModuleHandleA(&globals->t4040BA);
							ui32 ecx_1790 = v158 ^ 0x24 ^ v104_958;
							if (!DPB(SCZO_1699, false, 0))
							{
								esi_1594 = (eax_476 ^ ecx_1790) - v117_1150 + dwLoc0140_1281;
								if (esi_1594 == 0xDD)
								{
l00418756:
									Eq_10733 ecx_1825 = ((word32) esi_1594 + ((v187_1748 & dwLoc0124) - dwLocF0) - esi_1594 ^ esi_1594) + 0x0F00 ^ esi_1594;
									*ecxOut = ecx_1825;
									ui32 v195_1836 = dwLoc010C_1667 | ecx_1825;
									if (ecx_1825 < null)
									{
										*ecxOut = (ecx_1825 & esi_1594) + dwLocC8 + 0x01;
										esi_1594 = v185_1741 + 0x058F & v134_1311;
									}
									word32 esi_1856;
									*esiOut = esi_1594 + 0x1600 - ecx_1825;
									word32 eax_1871;
									*eaxOut = v195_1836 + 0x1DE3 ^ 0x00;
									return false;
								}
								esi_1594 = (esi_1594 ^ ecx_1790) + 220;
							}
							goto l00418756;
						}
					}
					goto l00417D49;
				}
				dwLoc0124 = dwLoc0124 - (edi_805 - 0x01) - ((v51_452 + (edi_805 - 0x01)) + (eax_2513 < 0x00) < 0x00);
			}
			goto l00417C07;
		}
		dwLoc0110 = dwLoc0110 ^ eax_2553;
		edi_2547 = edi_2547 - 0x2A | eax_2553;
		dwLocD4_2545 = dwLocD4;
		dwLoc0128 = dwLoc0128 - 0x01;
	}
	eax_2553 = eax_2553 & dwLocB8;
	goto l00417BB2;
}

// 0041899F: Register Eq_163 fn0041899F(Register Eq_163 eax, Register ui32 edi, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_163 fn0041899F(Eq_163 eax, ui32 edi, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 eax_37;
	ui32 edx_262;
	fn00412F4E(dwLoc0120 + dwLoc40 - 0x77 + dwLoc0174 ^ dwLoc0248 | dwLoc0298, out eax_37, out edx_262);
	GetOEMCP();
	GetCommandLineA();
	Eq_85 ecx_275 = (edx_262 & 1021) + edx_262;
	if (ecx_275 >= 0x00)
	{
		edx_262 = ((word32) ecx_275 + 0x0900 | ~0x1EDF) & (dwLoc0288 ^ 1021);
		dwLoc0108 = dwLoc0108 ^ 0x20;
		ecx_275 = (word32) ecx_275 + 0x00001301 + edx_262 - 0x01;
	}
	ui32 eax_80 = dwLocBC & edx_262;
	if (dwLoc0224 <= eax_80 + 0x01 && (bool) (dwLoc024C < 0x00) + (dwLoc0294 + ~0x01) < 0x00)
	{
		dwLoc38 = dwLoc38 & eax_80 + 0x01;
		dwLoc01EC = dwLoc01EC - 0x01;
	}
	uint32 ecx_117;
	fn00416E0A(ecx_275, out ecx_117);
	uint32 edx_105 = dwLoc38 ^ 0x68 | ecx_117;
	if (dwLoc01EC >= edx_105)
	{
		ecx_117 = (edx_105 & 133) + dwLoc0108 & dwLoc015C;
		if (ecx_117 >= 0x0146)
		{
l00418AF2:
			Eq_163 eax_154;
			ui32 ecx_155;
			word32 ebx_156;
			word32 esi_157;
			word32 edi_158;
			ui32 edx_162 = (bool) fn0041762E(dwLoc0158 & (dwLoc01C0 - GetCommandLineA()) + 0x01, ecx_117 | edx_105, edi, out eax_154, out ecx_155, out ebx_156, out esi_157, out edi_158) + (*(fp - 0x0214) + *(fp - 0x88));
			*(fp - 0x0200) = *(fp - 0x0200) | ecx_155;
			*(fp - 0x0144) = *(fp - 0x0144) + edx_162;
			*(fp - 0x0224) = *(fp - 0x0224) | edx_162;
			*(fp - 500) = *(fp - 500) - edx_162;
			*(fp - 0x3C) = *(fp - 0x3C) ^ edx_162;
			*(fp - 0x9C) = *(fp - 0x9C) ^ edx_162;
			*(fp - 0x01A0) = *(fp - 0x01A0) & edx_162;
			return eax_154;
		}
	}
	ecx_117 = ecx_117 + dwLoc40;
	goto l00418AF2;
}

