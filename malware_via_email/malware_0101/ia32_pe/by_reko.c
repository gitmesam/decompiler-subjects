// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 eax_28 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 esi_15 = 0x00;
	struct Eq_19 * esp_32 = fp - 0x34;
	word32 edi_255 = eax_28 + 0x15;
	if (AreAnyAccessesGranted(~0x00, ~0x00) == 0x00)
		edi_255 = eax_28 - 0x0D;
	struct Eq_35 * ecx_47 = null;
	do
	{
		if (esi_15 == edi_255)
			esi_15.u0 = 0x00;
		ecx_47[0x00401190] = (struct Eq_35) (ecx_47[0x00401190] ^ *((word32) esi_15 + 0x00404000));
		ecx_47 = ecx_47 + 0x01;
		esi_15 = (word32) esi_15 + 0x01;
	} while (ecx_47 < (struct Eq_35 *) 0x1440);
	up32 ebx_103 = 0x00;
	struct Eq_59 * ecx_107 = &globals->t402490;
	up32 dwLoc24_105 = 0x00;
	do
	{
		Eq_65 eax_88 = ecx_107->t0004;
		word16 * edx_227 = (char *) &ecx_107->t0004 + 0x04;
		if (eax_88 - 0x08 >> 0x01 > 0x00)
		{
			uint32 esi_226 = eax_88 - 0x08 >> 0x01;
			do
			{
				ui32 eax_229 = (word32) *edx_227;
				if ((eax_229 & 0xF000) == 0x3000)
				{
					struct Eq_199 * eax_245 = (eax_229 & 0x0FFF) + ecx_107->dw0000;
					eax_245->dw400F10 = eax_245->dw400F10 + 4030730000;
				}
				edx_227 = edx_227 + 0x01;
				esi_226 = esi_226 - 0x01;
			} while (esi_226 != 0x00);
			ebx_103 = dwLoc24_105;
		}
		ebx_103 = (word32) ecx_107->t0004 + ebx_103;
		dwLoc24_105 = ebx_103;
		ecx_107 = ecx_107 + Mem65[ecx_107 + 0x04:word32];
	} while (ebx_103 < 228);
	struct Eq_98 * esi_110 = &globals->t401C84;
	esi_138 = esi_110;
	esp_141 = esp_32;
	if (globals->dw401C94 != 0x00)
	{
		do
		{
			struct Eq_98 * esi_138;
			struct Eq_19 * esp_141;
			esp_141 = esp_141 - 0x04;
			esp_141->dw0000 = esi_138->dw000C + 0x00400F10;
			Eq_146 eax_146 = LoadLibraryA(esp_141->dw0000);
			esp_141[0x05] = (struct Eq_19) eax_146;
			Eq_146 edx_147 = eax_146;
			if (eax_146 != null)
			{
				word32 ebx_169 = esi_138->dw0000;
				if (ebx_169 == 0x00)
					ebx_169 = esi_138->dw0010;
				word32 * ebx_174 = ebx_169 + 0x00400F10;
				word32 * esi_177 = esi_138->dw0010 + 0x00400F10;
				if (*ebx_174 != 0x00)
				{
					while (true)
					{
						word32 * esp_208;
						int32 eax_201 = *ebx_174;
						word16 ax_203 = (word16) eax_201;
						if (eax_201 < 0x00)
						{
							esp_208 = esp_141 - 0x04;
							*esp_208 = (word32) ax_203;
						}
						else
						{
							esp_208 = esp_141 - 0x04;
							*esp_208 = eax_201 + 0x00400F12;
						}
						esp_141 = esp_208 - 0x04;
						esp_141->dw0000 = (word32) edx_147;
						*esi_177 = (word32) GetProcAddress(esp_141->dw0000, esp_141[0x01]);
						ebx_174 = ebx_174 + 0x01;
						esi_177 = esi_177 + 0x01;
						if (*ebx_174 == 0x00)
							break;
						edx_147 = (Eq_146) esp_141[0x05];
					}
				}
				esi_138 = (struct Eq_98 *) esp_141[0x04];
			}
			esi_138 = esi_138 + 0x01;
			esp_141[0x04] = (struct Eq_19) esi_138;
		} while (esi_138->dw0010 != 0x00);
	}
	ptr32 esp_117;
	byte SCZO_118;
	word32 ebx_119;
	word32 ebp_120;
	word32 esi_121;
	word32 edi_122;
	byte SZO_123;
	byte C_124;
	word32 edx_125;
	word32 eax_126;
	byte Z_127;
	word32 ecx_128;
	byte al_129;
	byte S_130;
	word16 ax_131;
	globals->t401960();
	*(esp_117 - 0x04) = 0x00;
	ExitProcess(*(esp_117 - 0x04));
}

