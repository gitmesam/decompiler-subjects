// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040108B: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
}

// 0040143B: Register word32 fn0040143B(Register word16 cx, Register (ptr (ptr Eq_144)) esi, Stack (ptr Eq_19) dwArg04, Stack word32 dwArg08)
word32 fn0040143B(word16 cx, Eq_144 * * esi, Eq_19 * dwArg04, word32 dwArg08)
{
	__ror(cx, 0x02);
	struct Eq_321 * ecx_38 = dwArg04 + (*((word32) (dwArg04)[0x003C].t0000 + (dwArg04 - ~0x77)) - ~0x1B);
	word32 edi_41[] = dwArg04 + ecx_38->dw0000;
	word32 * ecx_48 = dwArg04 + ecx_38->dw0004;
	word16 eax_56[] = dwArg04 + ecx_38->dw0008;
	__wait();
	__wait();
	word32 * edi_111 = ecx_48;
	ui32 dwLoc1C_110 = 0x00;
	byte * eax_113 = dwArg04 + *ecx_48;
	ui32 ecx_115 = 0x00;
	byte cl_117 = 0x00;
	while (true)
	{
		do
		{
			ui32 ecx_95 = __ror(DPB(ecx_115, cl_117 + *eax_113, 0), 0x17);
			ecx_115 = ecx_95 ^ 1200148887;
			cl_117 = (byte) (ecx_95 ^ 1200148887);
			eax_113 = eax_113 + 0x01;
		} while (*eax_113 != 0x00);
		if ((ecx_95 ^ 1200148887 ^ dwArg08) == 0x00)
			break;
		edi_111 = edi_111 - ~0x03;
		dwLoc1C_110 = dwLoc1C_110 + 0x01;
		eax_113 = (byte *) (dwArg04 + *edi_111);
		ecx_115 = 0x00;
		cl_117 = 0x00;
	}
	return dwArg04 + edi_41[(word32) eax_56[dwLoc1C_110]];
}

