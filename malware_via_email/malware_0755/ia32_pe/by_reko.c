// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401040: void fn00401040(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08, Stack (ptr Eq_4) dwArg0C)
void fn00401040(HMODULE dwArg04, Eq_3 dwArg08, Eq_4 * dwArg0C)
{
	globals->ptr406708 = null;
	while (globals->ptr406708 < dwArg0C)
	{
		Mem25[dwArg04 + Mem6[0x00406708:word32]:byte] = Mem6[dwArg08 + Mem6[0x00406708:word32]:byte];
		globals->ptr406708 = (struct Eq_4 *) (globals->ptr406708->a0000 + 0x01)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000;
	}
}

// 004010E0: Register Eq_25 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_2 eax_18 = GetModuleHandleA(0x00);
	LoadIconA(null, 0x7F00);
	GetWindowsDirectoryA(fp - 332, 300);
	if ((word32) bLoc014B != 0x3A)
		int3();
	lstrcatA(fp - 332, 4220340);
	if (CreateFileA(fp - 332, 0x01, 0x03, null, 0x03, 0x80, null) == (void *) ~0x00)
		return 0x00;
	GetWindowsDirectoryA(fp - 332, 300);
	if ((word32) bLoc014B != 0x3A)
		int3();
	lstrcatA(fp - 332, 4220348);
	word32 * esp_165 = fp - 0x01C4;
	if (CreateFileA(fp - 332, 0x01, 0x03, null, 0x03, 0x80, null) != (void *) ~0x00)
		return 0x00;
	Eq_2 eax_176 = globals->t402333;
	Eq_2 edx_179 = globals->t402337;
	Eq_2 dwLoc08_181 = null;
	while (dwLoc08_181 < eax_176)
	{
		esp_165 = esp_165 - 0x04;
		*esp_165 = 0x00;
		GetModuleHandleA(*esp_165);
		*((char *) &dwLoc08_181->unused + 4203323) = (Eq_2) (*((char *) &dwLoc08_181->unused + 4203323) ^ 22);
		dwLoc08_181 = (Eq_2) (&dwLoc08_181->unused + 0x02);
	}
	HMODULE * esp_205 = esp_165 - 0x04;
	*esp_205 = (HMODULE *) edx_179;
	globals->t406718 = fn00401730(dwArg00);
	*esp_205 = (HMODULE *) eax_176;
	*(esp_205 - 0x04) = (HMODULE *) globals->t406718;
	*(esp_205 - 0x08) = 4203323;
	fn004018F0(dwArg00, dwArg04, dwArg08);
	globals->dw40670C = edi;
	globals->dw406704 = esi;
	globals->dw406714 = ebx;
	globals->ptr40671C = fs->ptr0018;
	globals->ptr406710 = fp - 0x04;
	*esp_205 = (HMODULE *) eax_18;
	word32 ecx_239 = 4199055 - eax_18;
	*(esp_205 - 0x04) = ecx_239;
	word32 ebp_243 = fn00401760(fp - 0x04, dwArg00, dwArg04);
	Eq_2 edx_246 = globals->t406718;
	*esp_205 = (HMODULE *) edx_246;
	word32 eax_249 = fn004012F0(ebp_243, dwArg00);
	word32 esp_257;
	word32 ebp_258;
	byte SCZO_259;
	word32 ebx_260;
	word32 esi_261;
	word32 edi_262;
	Eq_25 eax_263;
	word32 ecx_264;
	byte Z_265;
	word32 edx_266;
	byte SZO_267;
	byte C_268;
	struct Eq_221 * fs_269;
	globals->ptr406720();
	return eax_263;
}

// 004012D0: Register Eq_245 fn004012D0(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08)
FARPROC fn004012D0(HMODULE dwArg04, Eq_3 dwArg08)
{
	return GetProcAddress(dwArg04, dwArg08);
}

// 004012F0: Register word32 fn004012F0(Register word32 ebp, Stack Eq_3 dwArg04)
word32 fn004012F0(word32 ebp, Eq_3 dwArg04)
{
	Eq_2 eax_9 = GetModuleHandleA(4220372);
	lstrcpyA(fp - 188, 0x004065E4);
	Eq_245 eax_22 = GetProcAddress(eax_9, 4220408);
	lstrcpyA(fp - 188, 4220424);
	GetProcAddress(eax_9, 4220444);
	lstrcpyA(fp - 188, 4220460);
	Eq_245 eax_48 = GetProcAddress(eax_9, 0x00406634);
	lstrcpyA(fp - 188, 0x00406648);
	Eq_245 eax_61 = GetProcAddress(eax_9, 0x0040665C);
	lstrcpyA(fp - 188, 0x0040666C);
	Eq_245 eax_74 = GetProcAddress(eax_9, 4220540);
	lstrcpyA(fp - 188, 0x0040668C);
	GetProcAddress(eax_9, 0x004066A4);
	word32 edx_95 = dwArg04 + Mem0[dwArg04 + 0x3C:word32];
	struct Eq_319 * dwLoc30_102 = &edx_95->w0014 + 0x02 + (word32) edx_95->w0014 / 22;
	struct Eq_327 * eax_116 = eax_61();
	fn00401040(dwArg00, dwArg04, dwArg08);
	up32 dwLoc10_142 = 0x00;
	while (dwLoc10_142 < (word32) edx_95->w0006)
	{
		if (dwLoc30_102->dw0014 != 0x00 && dwLoc30_102->dw0010 != 0x00)
			fn00401040(dwArg00, dwArg04, dwArg08);
		dwLoc30_102 = dwLoc30_102 + 0x01;
		dwLoc10_142 = dwLoc10_142 + 0x01;
	}
	struct Eq_341 * ecx_205 = eax_116 + eax_116->dw003C / 0x0040;
	Eq_68 eax_225 = eax_48();
	ptr32 * esp_222 = fp - 344;
	struct Eq_351 * dwLocCC_236 = eax_116 + ecx_205->dw0080 / 0x0040;
	while (dwLocCC_236->dw0010 != 0x00)
	{
		word32 * dwLoc3C_276;
		ui32 * dwLoc2C_275;
		ptr32 * esp_260 = esp_222 - 0x04;
		*esp_260 = eax_116 + dwLocCC_236->dw000C / 0x0040;
		int32 eax_265 = eax_74();
		if (dwLocCC_236->dw0000 != 0x00)
		{
			dwLoc2C_275 = (ui32 *) (eax_116 + dwLocCC_236->dw0000 / 0x0040);
			dwLoc3C_276 = (word32 *) (eax_116 + dwLocCC_236->dw0010 / 0x0040);
		}
		else
		{
			dwLoc2C_275 = (ui32 *) (eax_116 + dwLocCC_236->dw0010 / 0x0040);
			dwLoc3C_276 = (word32 *) (eax_116 + dwLocCC_236->dw0000 / 0x0040);
		}
		word32 dwLoc1C_279 = 0x00;
		if (dwLocCC_236->dw0010 != 0x00 && dwLocCC_236->dw0000 != 0x00)
			dwLoc1C_279 = 0x01;
		while (true)
		{
			esp_222 = esp_260;
			if (*dwLoc2C_275 == 0x00)
				break;
			if ((*dwLoc2C_275 & 0x80000000) != 0x00)
			{
				*(esp_260 - 0x04) = *dwLoc2C_275 & 0x7FFFFFFF;
				*(esp_260 - 0x08) = eax_265;
				*dwLoc2C_275 = fn004012D0(dwArg00, dwArg04);
			}
			else
			{
				*(esp_260 - 0x04) = eax_116 + (*dwLoc2C_275 + 0x02) / 0x0040;
				*(esp_260 - 0x08) = eax_265;
				*dwLoc2C_275 = fn004012D0(dwArg00, dwArg04);
			}
			if (dwLoc1C_279 != 0x00)
				*dwLoc3C_276 = *dwLoc2C_275;
			dwLoc2C_275 = dwLoc2C_275 + 0x01;
			dwLoc3C_276 = dwLoc3C_276 + 0x01;
		}
		dwLocCC_236 = dwLocCC_236 + 0x01;
	}
	word32 eax_407;
	union Eq_376 * esp_377 = esp_222 - 0x04;
	*esp_377 = (union Eq_376 *) ecx_205->t0034;
	*(esp_377 - 0x04) = 0x00;
	*(esp_377 - 0x08) = 0x00;
	*(esp_377 - 0x0C) = 0x00;
	*(esp_377 - 0x10) = 0x22;
	*(esp_377 - 0x14) = (HANDLE *) eax_225;
	globals->t406700 = eax_22();
	ptr32 esp_390 = esp_377 - 0x14;
	if (globals->t406700 == 0x00)
	{
		*(esp_377 - 0x18) = (union Eq_376 *) ecx_205->t0034;
		ptr32 esp_449 = esp_377 - 0x18;
		if (UnmapViewOfFile(*(esp_377 - 0x18)) == 0x00)
		{
			*(esp_377 - 0x1C) = 0x8000;
			*(esp_377 - 0x20) = 0x00;
			*(esp_377 - 0x24) = (union Eq_376 *) ecx_205->t0034;
			esp_449 = esp_377 - 0x24;
			if (VirtualFree(*(esp_377 - 0x24), *(esp_377 - 0x20), *(esp_377 - 0x1C)) == 0x00)
			{
				eax_407 = 0x00;
				return eax_407;
			}
		}
		union Eq_376 * esp_460 = esp_449 - 0x04;
		*esp_460 = (union Eq_376 *) ecx_205->t0034;
		*(esp_460 - 0x04) = 0x00;
		*(esp_460 - 0x08) = 0x00;
		*(esp_460 - 0x0C) = 0x00;
		*(esp_460 - 0x10) = 0x22;
		*(esp_460 - 0x14) = (HANDLE *) eax_225;
		globals->t406700 = MapViewOfFileEx(*(esp_460 - 0x14), *(esp_460 - 0x10), *(esp_460 - 0x0C), *(esp_460 - 0x08), *(esp_460 - 0x04), *esp_460);
		esp_390 = esp_460 - 0x14;
		if (globals->t406700 == 0x00)
		{
			*(esp_460 - 0x18) = 0x40;
			*(esp_460 - 0x1C) = 0x3000;
			*(esp_460 - 0x20) = ecx_205->dw0050;
			*(esp_460 - 0x24) = (union Eq_376 *) ecx_205->t0034;
			globals->t406700 = VirtualAlloc(*(esp_460 - 0x24), *(esp_460 - 0x20), *(esp_460 - 0x1C), *(esp_460 - 0x18));
			esp_390 = esp_460 - 0x24;
		}
	}
	HANDLE * esp_418 = esp_390 - 0x04;
	*esp_418 = (HANDLE *) eax_225;
	CloseHandle(*esp_418);
	*(esp_418 - 0x04) = ecx_205->dw0050;
	*(esp_418 - 0x08) = (struct Eq_327 **) eax_116;
	*(esp_418 - 0x0C) = (union Eq_376 *) globals->t406700;
	fn00401040(dwArg00, dwArg04, dwArg08);
	*(esp_418 - 0x04) = (union Eq_376 *) globals->t406700;
	fn004018C0(dwArg00);
	Mem441[4220704:word32] = Mem435[0x00406700:word32] + Mem435[ecx_205 + 0x28:word32];
	ecx_205->ptr0028 = globals->ptr406720;
	eax_407 = 0x01;
	return eax_407;
}

// 00401730: Register Eq_376 fn00401730(Stack Eq_3 dwArg04)
Eq_376 fn00401730(Eq_3 dwArg04)
{
	return VirtualAlloc(0x00, dwArg04, 0x3000, 0x04);
}

// 00401760: Register ptr32 fn00401760(Register ptr32 ebp, Stack Eq_3 dwArg04, Stack (ptr Eq_4) dwArg08)
ptr32 fn00401760(ptr32 ebp, Eq_3 dwArg04, Eq_4 * dwArg08)
{
	struct Eq_809 * edx_16 = dwArg08 + dwArg08->dw003C / 0x0040;
	globals->t406700 = GetProcAddress(GetModuleHandleA(0x004066C0), &globals->t4066C0)();
	if (globals->t406700 == 0x00)
		return ebp;
	fn00401040(dwArg00, dwArg04, dwArg08);
	ui32 eax_90 = globals->t406700 - dwArg08;
	if (edx_16->dw00A4 != 0x00)
	{
		struct Eq_852 * dwLoc0C_117 = dwArg08 + edx_16->dw00A0 / 0x0040;
		while (dwLoc0C_117->t0004 != 0x00)
		{
			uint32 eax_132 = dwLoc0C_117->t0004 - 0x08 >> 0x01;
			word16 ecx_135[] = (char *) &dwLoc0C_117->t0004 + 0x04;
			uint32 dwLoc08_138 = 0x00;
			while (dwLoc08_138 < eax_132)
			{
				if ((word32) ecx_135[dwLoc08_138] >> 0x0C == 0x03)
					(word32) globals->t406700 + dwLoc0C_117->dw0000 + ((word32) ecx_135[dwLoc08_138] & 0x0FFF) = (struct Eq_897 *) ((word32) globals->t406700 + dwLoc0C_117->dw0000 + ((word32) ecx_135[dwLoc08_138] & 0x0FFF) + eax_90);
				dwLoc08_138 = dwLoc08_138 + 0x01;
			}
			dwLoc0C_117 = dwLoc0C_117 + Mem85[dwLoc0C_117 + 0x04:word32];
		}
	}
	word32 edx_101 = dwArg04 + Mem85[0x00406700:word32];
	word32 esp_103;
	ptr32 ebp_104;
	byte SCZO_105;
	word32 esi_106;
	word32 eax_107;
	word32 ecx_108;
	word32 edx_109;
	byte Z_110;
	byte C_111;
	byte SZO_112;
	edx_101();
	return ebp_104;
}

// 004018C0: void fn004018C0(Stack Eq_2 dwArg04)
void fn004018C0(HMODULE dwArg04)
{
	globals->ptr40671C->ptr0030->t0008 = dwArg04;
}

// 004018F0: void fn004018F0(Stack Eq_3 dwArg04, Stack (ptr Eq_4) dwArg08, Stack Eq_156 dwArg0C)
void fn004018F0(Eq_3 dwArg04, Eq_4 * dwArg08, Eq_156 dwArg0C)
{
	Eq_927 cl_12 = *dwArg04;
	lstrcpyA(fp - 0x94, 0x004066DC);
	Eq_156 dwLoc0C_119 = 0x01;
	int32 dwLoc18_125 = 0x00;
	do
	{
		Eq_156 edx_41 = (word32) dwLoc0C_119 + 0x01;
		byte cl_38 = Mem0[dwArg04 + dwLoc0C_119:byte];
		dwLoc0C_119 = edx_41;
		if ((word32) cl_38 == (word32) cl_12)
		{
			if ((word32) Mem0[dwArg04 + edx_41:byte] == 0x00)
			{
				dwArg08[dwLoc18_125 / 0x0040] = (struct Eq_4) cl_12;
				dwLoc18_125 = dwLoc18_125 + 0x01;
				dwLoc0C_119 = (word32) edx_41.u0 + 0x01;
			}
			else
			{
				word32 eax_105 = fn00401A10(fp - 0x10, dwArg04 + edx_41) + edx_41;
				dwLoc0C_119 = fn00401A10(fp - 0x20, (word32) dwArg04 + eax_105) + eax_105;
				up32 dwLoc1C_120 = 0x00;
				while (dwLoc1C_120 < dwLoc10)
				{
					dwArg08[dwLoc18_125 / 0x0040] = dwArg08[(dwLoc18_125 - dwLoc20) / 0x0040];
					dwLoc18_125 = dwLoc18_125 + 0x01;
					dwLoc1C_120 = dwLoc1C_120 + 0x01;
				}
			}
		}
		else
		{
			dwArg08[dwLoc18_125 / 0x0040] = (struct Eq_4) cl_38;
			dwLoc18_125 = dwLoc18_125 + 0x01;
		}
	} while (dwLoc0C_119 < dwArg0C);
}

// 00401A10: Register word32 fn00401A10(Stack (ptr ui32) dwArg04, Stack (ptr byte) dwArg08)
word32 fn00401A10(ui32 * dwArg04, byte * dwArg08)
{
	lstrcpyA(fp - 0x84, 0x004066D0);
	ui32 dwLoc08_18 = 0x00;
	word32 dwLoc10_19 = 0x00;
	do
	{
		ui32 edx_22 = (word32) *dwArg08;
		ui32 edx_32 = edx_22 & 0x7F | dwLoc08_18 << 0x07;
		word32 eax_35 = dwLoc10_19 + 0x01;
		dwArg08 = dwArg08 + 0x01;
		dwLoc08_18 = edx_32;
		dwLoc10_19 = eax_35;
	} while ((edx_22 & 0x80) != 0x00);
	*dwArg04 = edx_32;
	return eax_35;
}

