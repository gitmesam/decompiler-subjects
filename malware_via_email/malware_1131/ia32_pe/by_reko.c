// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401010: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn004011F0();
	struct Eq_6 * eax_21 = (4558864 - (dwLoc20 << 0x0F) & 0xFFFF0000) + ((word32) dwLoc20 - 0x0A << 0x0D);
	Eq_19 ecx_23 = dwLoc20 << 0x0F >> 0x02;
	Mem30[fp - 0x1F + dwLoc20:word32] = Mem0[eax_21 + ~0x00015F8B + ecx_23:word32];
	Eq_32 ecx_35 = ((eax_21->aFFFEA074 + 135188)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000 + -(ecx_23 >> 0x01)).a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000;
	VirtualProtect(ecx_35, dwLoc14, 0x04, fp - 0x08);
	fn00401190(ecx_35, dwLoc14, dwLoc20);
	word32 ebx_70 = Mem30[ecx_35 + 0x47 - dwLoc20 + 0x00:word32] + ecx_35;
	word32 dwLoc1C_103 = (word32) ebx_70->b0006;
	Eq_32 eax_85 = VirtualAlloc(ebx_70->t0034, ebx_70->t0050, 0x3000, 0x40);
	fn004011D0(Mem30[ebx_70 + 0x5F - dwLoc20 + 0x00:word32], ecx_35, eax_85);
	struct Eq_97 * esi_101 = (char *) &ebx_70->t0050 + 0x00A8;
	do
	{
		fn004011D0(esi_101->dw0010, ecx_35 + Mem30[esi_101 + 0x14:word32], eax_85 + Mem30[esi_101 + 0x0C:word32]);
		word32 v24_121 = dwLoc1C_103 - 0x01;
		esi_101 = esi_101 + 0x01;
		dwLoc1C_103 = v24_121;
	} while (v24_121 != 0x00);
	Mem131[fp + 11 - dwLoc20 + 0x00:word32] = Mem30[ebx_70 + 0x1D + dwLoc20:word32] + eax_85;
	fn004011D0(0x38, dwLoc20 + 0x0040114A, fp - 88);
	fn00401190(fp - 88, 0x38, dwLoc20);
	Eq_32 eax_159 = eax_85;
	do
		eax_159 = eax_159 + 0x04;
	while (Mem131[eax_159 + 0x00:word32] != dwLoc20 + 2864434386);
	return fn004011D0(0x43 - dwLoc20, fp - 99 + dwLoc20, eax_159);
}

// 00401190: void fn00401190(Stack Eq_32 dwArg04, Stack Eq_42 dwArg08, Stack Eq_8 dwArg0C)
void fn00401190(Eq_32 dwArg04, Eq_42 dwArg08, Eq_8 dwArg0C)
{
	Eq_32 ebx_26 = dwArg04;
	Eq_42 ecx_10 = dwArg08;
	word32 eax_16 = (word32) dwArg0C + 0x0EE2C9C7;
	word32 dwLoc08_22 = 0x01;
	while (true)
	{
		*ebx_26 = *ebx_26 ^ eax_16;
		ecx_10 = ecx_10 - 0x04;
		if (ecx_10 <= 0x00)
			break;
		eax_16 = eax_16 + 475489042 + dwLoc08_22;
		ebx_26 = (word32) ebx_26 + 0x0F - dwArg0C;
		dwLoc08_22 = -*(fp - 0x08);
	}
}

// 004011D0: Register word32 fn004011D0(Stack word32 dwArg04, Stack Eq_32 dwArg08, Stack Eq_32 dwArg0C)
word32 fn004011D0(word32 dwArg04, Eq_32 dwArg08, Eq_32 dwArg0C)
{
	Eq_32 edi_13 = dwArg0C;
	Eq_32 esi_15 = dwArg08;
	word32 ecx_17 = dwArg04;
	do
	{
		byte al_24 = *esi_15;
		*edi_13 = al_24;
		eax = DPB(eax, al_24, 0);
		esi_15 = (word32) esi_15 + 0x01;
		edi_13 = (word32) edi_13 + 0x01;
		ecx_17 = ecx_17 - 0x01;
	} while (ecx_17 != 0x00);
	return eax;
}

// 004011F0: void fn004011F0()
void fn004011F0()
{
	struct Eq_210 * esp_9;
	ui32 eax_10;
	byte SCZO_11;
	byte SZO_12;
	word32 edx_13;
	bool C_14;
	word32 ecx_15;
	((<anonymous> **) 0x7FFE0300)();
	*esp_9->ptr0004 = (eax_10 & 0xF0000000) - 0x10000000 >> 0x1C;
}

