// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401040: void fn00401040(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08, Stack Eq_2 dwArg0C)
void fn00401040(HMODULE dwArg04, Eq_3 dwArg08, HMODULE dwArg0C)
{
	globals->t428628 = null;
	while (globals->t428628 < dwArg0C)
	{
		Mem25[dwArg04 + Mem6[0x00428628:word32]:byte] = Mem6[dwArg08 + Mem6[0x00428628:word32]:byte];
		globals->t428628 = (Eq_2) ((char *) &globals->t428628->unused + 0x01);
	}
}

// 004010E0: Register Eq_25 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	lstrcpyA(&globals->t428660, 0x004284A4);
	Eq_2 eax_24 = GetModuleHandleA(0x00);
	LoadIconA(null, 0x7F00);
	GetWindowsDirectoryA(fp - 332, 300);
	if ((word32) bLoc014B != 0x3A)
		return 0x00;
	lstrcatA(fp - 332, 4359336);
	lstrcatA(fp - 332, 4359344);
	if (CreateFileA(fp - 332, 0x01, 0x03, null, 0x03, 0x80, 0x00) != ~0x00)
	{
		lstrcpyA(&globals->t428660, 0x004284C4);
		GetWindowsDirectoryA(fp - 332, 300);
		if ((word32) bLoc014B == 0x3A)
		{
			lstrcatA(fp - 332, 0x004284E0);
			if (CreateFileA(fp - 332, 0x01, 0x03, null, 0x03, 0x80, 0x00) == ~0x00)
			{
				struct Eq_130 * ecx_214 = globals->ptr424222;
				Eq_133 eax_217 = globals->t424226;
				lstrcpyA(&globals->t428660, 4359436);
				struct Eq_130 * dwLoc08_225 = null;
				while (dwLoc08_225 < ecx_214)
				{
					GetModuleHandleA(0x00);
					dwLoc08_225->dw42422A = dwLoc08_225->dw42422A ^ 44444;
					dwLoc08_225 = dwLoc08_225 + 0x01;
				}
				globals->t428638 = fn004017B0(eax_217);
				fn00401970(globals->a42422A, globals->t428638, ecx_214);
				globals->dw42862C = edi;
				globals->dw428624 = esi;
				globals->dw428634 = ebx;
				globals->ptr42863C = fs->ptr0018;
				globals->ptr428630 = fp - 0x04;
				Eq_3 edx_282 = 0x00401310 - eax_24;
				word32 ebp_286 = fn004017E0(fp - 0x04, edx_282, eax_24);
				word32 eax_292 = fn00401370(ebp_286, globals->t428638);
				word32 esp_300;
				word32 ebp_301;
				byte SCZO_302;
				word32 ebx_303;
				word32 esi_304;
				word32 edi_305;
				Eq_25 eax_306;
				word32 ecx_307;
				bool Z_308;
				byte SZO_309;
				bool C_310;
				word32 edx_311;
				struct Eq_211 * fs_312;
				globals->ptr428640();
				return eax_306;
			}
			else
			{
				lstrcpyA(&globals->t428660, 0x004284F4);
				return 0x00;
			}
		}
		else
		{
			lstrcpyA(&globals->t428660, 0x004284D4);
			return 0x00;
		}
	}
	else
	{
		lstrcpyA(&globals->t428660, 0x004284B4);
		return 0x00;
	}
}

// 00401350: Register Eq_227 fn00401350(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08)
FARPROC fn00401350(HMODULE dwArg04, Eq_3 dwArg08)
{
	return GetProcAddress(dwArg04, dwArg08);
}

// 00401370: Register word32 fn00401370(Register word32 ebp, Stack Eq_3 dwArg04)
word32 fn00401370(word32 ebp, Eq_3 dwArg04)
{
	Eq_2 eax_9 = GetModuleHandleA(4359444);
	lstrcpyA(fp - 188, 0x00428524);
	GetProcAddress(eax_9, 0x00428538);
	Eq_227 eax_34 = GetProcAddress(eax_9, 0x00428548);
	Eq_227 eax_43 = GetProcAddress(eax_9, 0x0042855C);
	lstrcpyA(fp - 188, 4359532);
	Eq_227 eax_58 = GetProcAddress(eax_9, 4359544);
	lstrcpyA(fp - 188, 0x00428588);
	Eq_227 eax_73 = GetProcAddress(eax_9, 0x00428590);
	lstrcpyA(fp - 188, 4359584);
	GetProcAddress(eax_9, 4359596);
	Eq_227 eax_97 = GetProcAddress(eax_9, 0x004285B8);
	word32 ecx_106 = dwArg04 + Mem0[dwArg04 + 0x3C:word32];
	struct Eq_292 * dwLoc30_113 = &ecx_106->w0014 + 0x02 + (word32) ecx_106->w0014 / 22;
	struct Eq_300 * eax_127 = eax_43();
	fn00401040(dwArg00, dwArg04, dwArg08);
	up32 dwLoc10_153 = 0x00;
	while (dwLoc10_153 < (word32) ecx_106->w0006)
	{
		if (dwLoc30_113->dw0014 != 0x00 && dwLoc30_113->dw0010 != 0x00)
			fn00401040(dwArg00, dwArg04, dwArg08);
		dwLoc30_113 = dwLoc30_113 + 0x01;
		dwLoc10_153 = dwLoc10_153 + 0x01;
	}
	struct Eq_314 * ecx_216 = eax_127 + eax_127->dw003C / 0x0040;
	Eq_80 eax_236 = eax_34();
	ptr32 * esp_233 = fp - 244;
	struct Eq_324 * dwLocCC_247 = eax_127 + ecx_216->dw0080 / 0x0040;
	while (dwLocCC_247->dw0010 != 0x00)
	{
		word32 * dwLoc3C_287;
		ui32 * dwLoc2C_286;
		ptr32 * esp_271 = esp_233 - 0x04;
		*esp_271 = eax_127 + dwLocCC_247->dw000C / 0x0040;
		int32 eax_276 = eax_58();
		if (dwLocCC_247->dw0000 != 0x00)
		{
			dwLoc2C_286 = (ui32 *) (eax_127 + dwLocCC_247->dw0000 / 0x0040);
			dwLoc3C_287 = (word32 *) (eax_127 + dwLocCC_247->dw0010 / 0x0040);
		}
		else
		{
			dwLoc2C_286 = (ui32 *) (eax_127 + dwLocCC_247->dw0010 / 0x0040);
			dwLoc3C_287 = (word32 *) (eax_127 + dwLocCC_247->dw0000 / 0x0040);
		}
		word32 dwLoc1C_290 = 0x00;
		if (dwLocCC_247->dw0010 != 0x00 && dwLocCC_247->dw0000 != 0x00)
			dwLoc1C_290 = 0x01;
		while (true)
		{
			esp_233 = esp_271;
			if (*dwLoc2C_286 == 0x00)
				break;
			if ((*dwLoc2C_286 & 0x80000000) != 0x00)
			{
				*(esp_271 - 0x04) = *dwLoc2C_286 & 0x7FFFFFFF;
				*(esp_271 - 0x08) = eax_276;
				*dwLoc2C_286 = fn00401350(dwArg00, dwArg04);
			}
			else
			{
				*(esp_271 - 0x04) = eax_127 + (*dwLoc2C_286 + 0x02) / 0x0040;
				*(esp_271 - 0x08) = eax_276;
				*dwLoc2C_286 = fn00401350(dwArg00, dwArg04);
			}
			if (dwLoc1C_290 != 0x00)
				*dwLoc3C_287 = *dwLoc2C_286;
			dwLoc2C_286 = dwLoc2C_286 + 0x01;
			dwLoc3C_287 = dwLoc3C_287 + 0x01;
		}
		dwLocCC_247 = dwLocCC_247 + 0x01;
	}
	word32 eax_419;
	word32 * esp_388 = esp_233 - 0x04;
	*esp_388 = ecx_216->dw0034;
	*(esp_388 - 0x04) = 0x00;
	*(esp_388 - 0x08) = 0x00;
	*(esp_388 - 0x0C) = 0x00;
	*(esp_388 - 0x10) = 0x22;
	*(esp_388 - 0x14) = (union Eq_80 *) eax_236;
	globals->t428620 = eax_73();
	ptr32 esp_401 = esp_388 - 0x14;
	if (globals->t428620 == 0x00)
	{
		*(esp_388 - 0x18) = ecx_216->dw0034;
		if (eax_97() == 0x00)
		{
			*(esp_388 - 0x1C) = 0x8000;
			*(esp_388 - 0x20) = 0x00;
			*(esp_388 - 0x24) = ecx_216->dw0034;
			if (VirtualFree(*(esp_388 - 0x24), *(esp_388 - 0x20), *(esp_388 - 0x1C)) == 0x00)
			{
				eax_419 = 0x00;
				return eax_419;
			}
		}
		ptr32 esp_478 = esp_233 - 0x1C;
		*(esp_478 - 0x04) = ecx_216->dw0034;
		*(esp_478 - 0x08) = 0x00;
		*(esp_478 - 0x0C) = 0x00;
		*(esp_478 - 0x10) = 0x00;
		*(esp_478 - 0x14) = 0x22;
		*(esp_478 - 0x18) = (union Eq_80 *) eax_236;
		globals->t428620 = MapViewOfFileEx(*(esp_478 - 0x18), *(esp_478 - 0x14), *(esp_478 - 0x10), *(esp_478 - 0x0C), *(esp_478 - 0x08), *(esp_478 - 0x04));
		esp_401 = esp_478;
		if (globals->t428620 == 0x00)
		{
			*(esp_478 - 0x04) = 0x40;
			*(esp_478 - 0x08) = 0x3000;
			*(esp_478 - 0x0C) = (union Eq_80 *) ecx_216->t0050;
			*(esp_478 - 0x10) = ecx_216->dw0034;
			globals->t428620 = VirtualAlloc(*(esp_478 - 0x10), *(esp_478 - 0x0C), *(esp_478 - 0x08), *(esp_478 - 0x04));
			esp_401 = esp_478;
		}
	}
	union Eq_80 * esp_430 = esp_401 - 0x04;
	*esp_430 = (union Eq_80 *) eax_236;
	CloseHandle(*esp_430);
	*esp_430 = (union Eq_80 *) ecx_216->t0050;
	*(esp_430 - 0x04) = (struct Eq_300 **) eax_127;
	*(esp_430 - 0x08) = (union Eq_80 *) globals->t428620;
	fn00401040(dwArg00, dwArg04, dwArg08);
	*esp_430 = (union Eq_80 *) globals->t428620;
	fn00401940(dwArg00);
	Mem454[4359744:word32] = Mem448[0x00428620:word32] + Mem448[ecx_216 + 0x28:word32];
	ecx_216->ptr0028 = globals->ptr428640;
	eax_419 = 0x01;
	return eax_419;
}

// 004017B0: Register Eq_80 fn004017B0(Stack Eq_133 dwArg04)
Eq_80 fn004017B0(SIZE_T dwArg04)
{
	return VirtualAlloc(0x00, dwArg04, 0x3000, 0x04);
}

// 004017E0: Register ptr32 fn004017E0(Register ptr32 ebp, Stack Eq_3 dwArg04, Stack Eq_2 dwArg08)
ptr32 fn004017E0(ptr32 ebp, Eq_3 dwArg04, HMODULE dwArg08)
{
	struct Eq_769 * edx_16 = dwArg08 + (&dwArg08->unused)[0x0F] / 0x04;
	globals->t428620 = GetProcAddress(GetModuleHandleA(0x004285D8), 0x004285C8)();
	if (globals->t428620 == 0x00)
		return ebp;
	fn00401040(dwArg00, dwArg04, dwArg08);
	ui32 eax_92 = globals->t428620 - dwArg08;
	if (edx_16->dw00A4 != 0x00)
	{
		struct Eq_813 * dwLoc0C_120 = dwArg08 + edx_16->dw00A0 / 0x04;
		while (dwLoc0C_120->t0004 != 0x00)
		{
			uint32 eax_135 = dwLoc0C_120->t0004 - 0x08 >> 0x01;
			word16 ecx_138[] = (char *) &dwLoc0C_120->t0004 + 0x04;
			uint32 dwLoc08_141 = 0x00;
			while (dwLoc08_141 < eax_135)
			{
				if ((word32) ecx_138[dwLoc08_141] >> 0x0C == 0x03)
					(word32) globals->t428620 + dwLoc0C_120->dw0000 + ((word32) ecx_138[dwLoc08_141] & 0x0FFF) = (struct Eq_858 *) ((word32) globals->t428620 + dwLoc0C_120->dw0000 + ((word32) ecx_138[dwLoc08_141] & 0x0FFF) + eax_92);
				dwLoc08_141 = dwLoc08_141 + 0x01;
			}
			dwLoc0C_120 = dwLoc0C_120 + Mem87[dwLoc0C_120 + 0x04:word32];
		}
	}
	word32 edx_104 = dwArg04 + Mem87[0x00428620:word32];
	word32 esp_106;
	ptr32 ebp_107;
	byte SCZO_108;
	word32 esi_109;
	word32 eax_110;
	word32 ecx_111;
	word32 edx_112;
	bool Z_113;
	bool C_114;
	byte SZO_115;
	edx_104();
	return ebp_107;
}

// 00401940: void fn00401940(Stack Eq_2 dwArg04)
void fn00401940(HMODULE dwArg04)
{
	globals->ptr42863C->ptr0030->t0008 = dwArg04;
}

// 00401970: void fn00401970(Stack (arr Eq_888) dwArg04, Stack Eq_3 dwArg08, Stack (ptr32 Eq_130) dwArg0C)
void fn00401970(Eq_888 dwArg04[], Eq_3 dwArg08, Eq_130 * dwArg0C)
{
	Eq_888 cl_12 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg04[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
	lstrcpyA(fp - 0x94, 4359676);
	struct Eq_130 * dwLoc0C_118 = (struct Eq_130 *) 0x01;
	int32 dwLoc18_124 = 0x00;
	do
	{
		struct Eq_130 * edx_40 = (char *) dwLoc0C_118 + 0x01;
		byte cl_37 = Mem0[dwArg04 + dwLoc0C_118:byte];
		dwLoc0C_118 = edx_40;
		if ((word32) cl_37 == (word32) cl_12)
		{
			if ((word32) Mem0[dwArg04 + edx_40:byte] == 0x00)
			{
				*((word32) dwArg08 + dwLoc18_124) = cl_12;
				dwLoc18_124 = dwLoc18_124 + 0x01;
				dwLoc0C_118 = (struct Eq_130 *) ((char *) edx_40 + 0x01);
			}
			else
			{
				word32 eax_104 = fn00401A90(fp - 0x10, dwArg04 + edx_40) + edx_40;
				dwLoc0C_118 = fn00401A90(fp - 0x20, (dwArg04 + eax_104)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000) + eax_104;
				up32 dwLoc1C_119 = 0x00;
				while (dwLoc1C_119 < dwLoc10)
				{
					*((word32) dwArg08 + dwLoc18_124) = *((word32) dwArg08 + (dwLoc18_124 - dwLoc20));
					dwLoc18_124 = dwLoc18_124 + 0x01;
					dwLoc1C_119 = dwLoc1C_119 + 0x01;
				}
			}
		}
		else
		{
			*((word32) dwArg08 + dwLoc18_124) = cl_37;
			dwLoc18_124 = dwLoc18_124 + 0x01;
		}
	} while (dwLoc0C_118 < dwArg0C);
}

// 00401A90: Register word32 fn00401A90(Stack (ptr32 ui32) dwArg04, Stack (ptr32 byte) dwArg08)
word32 fn00401A90(ui32 * dwArg04, byte * dwArg08)
{
	lstrcpyA(fp - 0x84, 4359656);
	ui32 dwLoc08_19 = 0x00;
	word32 dwLoc10_20 = 0x00;
	do
	{
		ui32 edx_23 = (word32) *dwArg08;
		ui32 edx_33 = edx_23 & 0x7F | dwLoc08_19 << 0x07;
		word32 eax_36 = dwLoc10_20 + 0x01;
		dwArg08 = dwArg08 + 0x01;
		dwLoc08_19 = edx_33;
		dwLoc10_20 = eax_36;
	} while ((edx_23 & 0x80) != 0x00);
	*dwArg04 = edx_33;
	return eax_36;
}

