// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004010A0: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
}

// 0040149E: Register (ptr (arr word16)) fn0040149E(Stack (ptr Eq_113) dwArg04, Stack word32 dwArg08, Register out ptr32 esiOut)
word16 * fn0040149E[](Eq_113 * dwArg04, word32 dwArg08, ptr32 & esiOut)
{
	__wait();
	word32 eax_13 = dwArg04 - ~0x77 + *(dwArg04 - ~0x3B);
	__wait();
	struct Eq_369 * eax_16 = dwArg04 + (eax_13 - ~0x1B);
	int32 * eax_29 = dwArg04 + eax_16->dw0004;
	word32 esi_26 = dwArg04 + eax_16->dw0000;
	word16 ecx_36[] = dwArg04 + eax_16->dw0008;
	byte * ecx_56 = dwArg04 + *eax_29;
	__wait();
	int32 * esi_43 = eax_29;
	ui32 dwLoc0C_50 = 0x00;
	ui32 eax_58 = 0x00;
	byte al_59 = 0x00;
	while (true)
	{
		do
		{
			ui32 eax_74 = __ror(DPB(eax_58, al_59 + *ecx_56, 0), 0x05);
			ecx_56 = ecx_56 + 0x01;
			eax_58 = eax_74 ^ 4187147681;
			al_59 = (byte) (eax_74 ^ 4187147681);
		} while (*ecx_56 != 0x00);
		if ((eax_74 ^ 4187147681 ^ dwArg08) == 0x00)
			break;
		esi_43 = esi_43 + 0x01;
		dwLoc0C_50 = dwLoc0C_50 + 0x01;
		ecx_56 = (byte *) (dwArg04 + *esi_43);
		eax_58 = 0x00;
		al_59 = 0x00;
	}
	word32 * eax_106 = esi_26 + ((word32) ecx_36[dwLoc0C_50] << 0x02);
	__wait();
	word32 esi_112;
	*esiOut = dwArg04 + *eax_106;
	__wait();
	return ecx_36;
}

