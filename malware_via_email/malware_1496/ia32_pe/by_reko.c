// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040107C: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
}

// 00401437: Register word32 fn00401437(Register word32 ecx, Register ui32 edx, Register (ptr (ptr (ptr Eq_130))) ebp, Stack (ptr Eq_88) dwArg04, Stack word32 dwArg08)
word32 fn00401437(word32 ecx, ui32 edx, Eq_130 * * * ebp, Eq_88 * dwArg04, word32 dwArg08)
{
	word32 ecx_35 = Mem0[dwArg04 - ~0x77 + Mem0[(dwArg04 - ~0x3B) + 0x00:word32]:word32] + 0x1C + dwArg04;
	word32 * ecx_41 = dwArg04 + ecx_35->dw0004;
	word32 edi_38[] = dwArg04 + ecx_35->dw0000;
	word16 eax_44[] = dwArg04 + *(ecx_35 - ~0x07);
	word32 * edi_53 = ecx_41;
	ui32 dwLoc1C_58 = 0x00;
	byte * eax_61 = dwArg04 + *ecx_41;
	ui32 ecx_62 = 0x00;
	byte cl_63 = 0x00;
	while (true)
	{
		do
		{
			word32 ecx_78 = __ror(DPB(ecx_62, cl_63 + *eax_61, 0), 0x08);
			eax_61 = eax_61 + 0x01;
			ecx_62 = ecx_78 ^ 1265358885;
			cl_63 = (byte) (ecx_78 ^ 1265358885);
		} while (*eax_61 != 0x00);
		if ((ecx_78 ^ 1265358885 ^ dwArg08) == 0x00)
			break;
		edi_53 = edi_53 + 0x01;
		dwLoc1C_58 = dwLoc1C_58 + 0x01;
		eax_61 = (byte *) (dwArg04 + *edi_53);
		ecx_62 = 0x00;
		cl_63 = 0x00;
	}
	return dwArg04 + edi_38[(word32) eax_44[dwLoc1C_58]];
}

