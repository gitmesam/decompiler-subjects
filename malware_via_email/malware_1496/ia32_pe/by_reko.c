// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040107C: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ui32 ecx_12 = __rol(0x2AFFC5C8, 0x01);
	__ror(edx, 0x15);
	union Eq_30 ** edx_27 = __rol(155616, 0x03) + (fp & __rol(0xFE000001, 0x07));
	union Eq_30 * eax_30 = *edx_27;
	union Eq_30 ** edx_265 = -edx_27;
	while (true)
	{
		eax_30 = (union Eq_30 *) ((char *) eax_30 + 0x01);
		if (*eax_30 == ~0x6F)
			break;
		word32 edx_260 = __ror(edx_265, 0x0D);
		if (*eax_30 == ecx_12 << 0x11)
		{
			byte dl_275 = (byte) __ror((union Eq_30 **) 0x4800, 0x07);
			if (*(eax_30 - 0x01) == dl_275)
				goto l004010F1;
			word32 esp_286;
			word32 ecx_287;
			byte SCZO_288;
			word32 esi_289;
			word32 edi_290;
			Eq_2 eax_291;
			bool C_292;
			word32 edx_293;
			word32 ebx_294;
			byte SZO_295;
			bool Z_296;
			byte dl_297;
			word32 ebp_298;
			word16 si_299;
			word16 ax_300;
			word16 dx_301;
			struct Eq_333 * fs_302;
			struct Eq_334 * ds_303;
			word16 di_304;
			byte ah_305;
			ebx();
			return eax_291;
		}
		edx_265 = edx_260 + 2855740095;
	}
	ui32 edx_312 = __rol(0x8000007F, 0x01);
	bool Z_317 = (bool) cond(*(eax_30 - ~0x03) - (byte) edx_312);
	while (!Z_317)
	{
		edx_312 = edx_312 & ebp;
		Z_317 = (bool) cond(edx_312);
	}
l004010F1:
	__ror(~0x6F, 0x0C);
	struct Eq_89 * esi_66 = dwArg00;
	do
		esi_66 = esi_66 - 0x01;
	while (esi_66->t0000 != __rol(0x18000006, 0x05));
	ptr32 esp_88;
	word32 ecx_89;
	byte SCZO_90;
	ui32 esi_91;
	word32 edi_92;
	word32 eax_93;
	bool C_94;
	word32 edx_95;
	ui32 ebx_96;
	byte SZO_97;
	bool Z_98;
	byte dl_99;
	struct Eq_132 *** ebp_100;
	word16 si_101;
	word16 ax_102;
	word16 dx_103;
	struct Eq_111 * fs_104;
	struct Eq_112 * ds_105;
	word16 di_106;
	byte ah_107;
	esi_66();
	struct Eq_115 * eax_115 = fs_104->ptr0030->ptr000C;
	__rol(esi_91 & ebx_96, 0x12);
	struct Eq_132 ** edx_122 = eax_115->ptr001C;
	word32 esi_126 = *((char *) *edx_122 + 0x08);
	*(esp_88 - 0x04) = 0xCE9119BC;
	*(esp_88 - 0x08) = esi_126;
	word32 edi_137 = fn00401437(0x1D, -edx_122 + ebp_100 & 0x381334F0, ebp_100, dwArg00, dwArg04);
	*(esp_88 - 0x04) = 0x6C;
	*(esp_88 - 0x08) = 1818504812;
	*(esp_88 - 0x0C) = 0x6C64746E;
	*(esp_88 - 0x10) = esp_88 - 0x0C;
	struct Eq_186 * esp_156;
	word32 ecx_157;
	byte SCZO_158;
	word32 esi_159;
	word32 edi_160;
	word32 eax_161;
	bool C_162;
	ui32 edx_163;
	word32 ebx_164;
	byte SZO_165;
	bool Z_166;
	byte dl_167;
	struct Eq_132 *** ebp_168;
	word16 si_169;
	word16 ax_170;
	word16 dx_171;
	struct Eq_202 * fs_172;
	struct Eq_203 * ds_173;
	word16 di_174;
	byte ah_175;
	edi_137();
	esp_156->ptr0008 = (<anonymous> *) ~0x44142C9B;
	esp_156->dw0004 = eax_161;
	<anonymous> * edi_183 = fn00401437(ecx_157 + 0x63BAE338, edx_163, ebp_168, dwArg00, dwArg04);
	esp_156->ptr0008 = edi_183;
	<anonymous> * ecx_187 = esp_156->ptr0008;
	esp_156->ptr0008 = null;
	esp_156->dw0004 = 0x00;
	esp_156->dw0000 = 0x00;
	*(esp_156 - 0x04) = 0x00C0FA14;
	*(esp_156 - 0x08) = 2976644998;
	*(esp_156 - 0x0C) = 2287;
	word32 esp_204;
	word32 ecx_205;
	byte SCZO_206;
	word32 esi_207;
	word32 edi_208;
	word32 eax_209;
	bool C_210;
	word32 edx_211;
	word32 ebx_212;
	byte SZO_213;
	bool Z_214;
	byte dl_215;
	word32 ebp_216;
	word16 si_217;
	word16 ax_218;
	word16 dx_219;
	struct Eq_270 * fs_220;
	struct Eq_271 * ds_221;
	word16 di_222;
	byte ah_223;
	ecx_187();
	word16 di_230 = __rol((word16) (edi_208 - 0x01), 11);
	<anonymous> * eax_234 = (<anonymous> **) 2842311;
	word32 esp_238;
	word32 ecx_239;
	byte SCZO_240;
	word32 esi_241;
	word32 edi_242;
	word32 eax_243;
	bool C_244;
	word32 edx_245;
	word32 ebx_246;
	byte SZO_247;
	bool Z_248;
	byte dl_249;
	word32 ebp_250;
	word16 si_251;
	word16 ax_252;
	word16 dx_253;
	struct Eq_303 * fs_254;
	struct Eq_304 * ds_255;
	word16 di_256;
	byte ah_257;
	eax_234();
}

// 00401437: Register word32 fn00401437(Register word32 ecx, Register ui32 edx, Register (ptr32 (ptr32 (ptr32 Eq_132))) ebp, Stack (ptr32 Eq_89) dwArg04, Stack word32 dwArg08)
word32 fn00401437(word32 ecx, ui32 edx, Eq_132 * * * ebp, Eq_89 * dwArg04, word32 dwArg08)
{
	word32 ecx_35 = Mem0[dwArg04 - ~0x77 + Mem0[(dwArg04 - ~0x3B) + 0x00:word32]:word32] + 0x1C + dwArg04;
	word32 * ecx_41 = dwArg04 + ecx_35->dw0004;
	word32 edi_38[] = dwArg04 + ecx_35->dw0000;
	word16 eax_44[] = dwArg04 + *(ecx_35 - ~0x07);
	word32 * edi_53 = ecx_41;
	ui32 dwLoc1C_58 = 0x00;
	byte * eax_61 = dwArg04 + *ecx_41;
	ui32 ecx_62 = 0x00;
	byte cl_63 = 0x00;
	while (true)
	{
		do
		{
			word32 ecx_78 = __ror(DPB(ecx_62, cl_63 + *eax_61, 0), 0x08);
			eax_61 = eax_61 + 0x01;
			ecx_62 = ecx_78 ^ 1265358885;
			cl_63 = (byte) (ecx_78 ^ 1265358885);
		} while (*eax_61 != 0x00);
		if ((ecx_78 ^ 1265358885 ^ dwArg08) == 0x00)
			break;
		edi_53 = edi_53 + 0x01;
		dwLoc1C_58 = dwLoc1C_58 + 0x01;
		eax_61 = (byte *) (dwArg04 + *edi_53);
		ecx_62 = 0x00;
		cl_63 = 0x00;
	}
	return dwArg04 + edi_38[(word32) eax_44[dwLoc1C_58]];
}

