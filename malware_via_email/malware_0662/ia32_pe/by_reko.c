// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 ebx_15 = null;
	Eq_3 ebp_21 = (struct <anonymous> *) 0x28;
	Eq_2 eax_22 = AddUsersToEncryptedFile(&globals->t403020, null);
	if (eax_22 == 0x00)
		return eax_22;
	Eq_17 eax_31 = AreAllAccessesGranted(~0x00, ~0x00);
	if (eax_31 == 0x00)
		ebp_21 = eax_31 + 0x26;
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x20);
	struct Eq_40 * eax_49 = null;
	struct Eq_42 * esp_52 = fp - 0x44;
	do
	{
		if (ebx_15 == ebp_21)
			ebx_15 = null;
		eax_49[4199896] = (struct Eq_40) (ebx_15[0x00404000] ^ eax_49[4199896] ^ 0x54);
		eax_49 = eax_49 + 0x01;
		ebx_15 = (Eq_3) (ebx_15 + 0x01);
	} while (eax_49 < (struct Eq_40 *) 0x1440);
	word32 esi_80 = 0x00401358;
	struct Eq_69 * ecx_224 = &globals->t4028D8;
	up32 dwLoc2C_223 = 0x00;
	if (true)
	{
		do
		{
			Eq_83 eax_232 = ecx_224->t0004 - 0x08 >> 0x01;
			word16 * edx_235 = (char *) &ecx_224->t0004 + 0x04;
			if (eax_232 > 0x00)
			{
				Eq_83 ebx_247 = eax_232;
				do
				{
					ui32 eax_250 = (word32) *edx_235;
					if ((eax_250 & 0xF000) == 0x3000)
					{
						struct Eq_202 * eax_261 = (eax_250 & 0x0FFF) + ecx_224->dw0000;
						eax_261->dw401358 = eax_261->dw401358 + 0xF0401358;
					}
					edx_235 = edx_235 + 0x01;
					ebx_247 = ebx_247 - 0x01;
				} while (ebx_247 != 0x00);
			}
			Eq_86 eax_239 = ecx_224->t0004;
			up32 edx_241 = (word32) eax_239 + dwLoc2C_223;
			ecx_224 = ecx_224 + eax_239;
			dwLoc2C_223 = edx_241;
		} while (edx_241 < ~0x00);
	}
	struct Eq_74 * ebx_97 = &globals->t4020C4;
	esi_122 = esi_80;
	ebx_124 = ebx_97;
	esp_126 = esp_52;
	if (globals->dw4020D4 != 0x00)
	{
		do
		{
			word32 esi_122;
			struct Eq_74 * ebx_124;
			struct Eq_42 * esp_126;
			esp_126 = esp_126 - 0x04 + 0x18;
			esp_126->dw0000 = ebx_124->dw000C + esi_122;
			Eq_137 eax_131 = LoadLibraryA(esp_126->dw0000);
			esp_126->dw001C = (word32) eax_131;
			Eq_137 edx_132 = eax_131;
			if (eax_131 != null)
			{
				word32 ebp_154 = ebx_124->dw0000;
				if (ebp_154 == 0x00)
					ebp_154 = ebx_124->dw0010;
				word32 * ebp_159 = ebp_154 + esi_122;
				int32 eax_163 = *ebp_159;
				word32 * edi_164 = (word32) ((word32) esp_126[0x03].dw0000 + 0x0010)->dw0000 + esi_122;
				if (eax_163 != 0x00)
				{
					while (true)
					{
						Eq_220 eax_195;
						if (eax_163 < 0x00)
						{
							struct Eq_257 * esp_208 = esp_126 - 0x04;
							esp_208->t0000 = (word32) *ebp_159;
							*(esp_208 - 0x04) = (HMODULE *) edx_132;
							eax_195 = GetProcAddress(*(esp_208 - 0x04), esp_208->t0000);
							esi_122 = esp_208->dw001C;
						}
						else
						{
							LPCSTR * esp_217 = esp_126 - 0x04;
							*esp_217 = (LPCSTR *) (eax_163 + 0x02 + esi_122);
							*(esp_217 - 0x04) = (HMODULE *) edx_132;
							eax_195 = GetProcAddress(*(esp_217 - 0x04), *esp_217);
						}
						*edi_164 = (word32) eax_195;
						ebp_159 = ebp_159 + 0x01;
						esp_126 = esp_126 - 0x08;
						eax_163 = *ebp_159;
						edi_164 = edi_164 + 0x01;
						if (eax_163 == 0x00)
							break;
						edx_132 = (Eq_137) esp_126->dw001C;
					}
				}
				ebx_124 = esp_126->dw0000;
			}
			ebx_124 = ebx_124 + 0x01;
			esp_126[0x03] = (struct Eq_42) ebx_124;
		} while (ebx_124->dw0010 != 0x00);
	}
	ptr32 esp_101;
	byte SCZO_102;
	word32 ebx_103;
	word32 ebp_104;
	word32 esi_105;
	word32 edi_106;
	byte SZO_107;
	byte C_108;
	word32 eax_109;
	byte Z_110;
	word32 edx_111;
	byte cl_112;
	word32 ecx_113;
	byte CZ_114;
	byte S_115;
	globals->t401DB8();
	*(esp_101 - 0x04) = 0x00;
	ExitProcess(*(esp_101 - 0x04));
}

