// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401020: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00403640(35116, dwLoc14);
	Eq_10 eax_17 = fn00403590();
	if (eax_17 == 0x00)
		return 0x00;
	Eq_17 eax_130 = globals->t40603C;
	struct Eq_20 * ecx_132 = globals->a401C00;
	ui32 * ebx_136 = (word32) fp - 14948;
	do
	{
		*ebx_136 = (globals->t40603C | 0xA605EF2A) ^ ecx_132->dw0000;
		ecx_132 = ecx_132 + 0x01;
		ebx_136 = ebx_136 - eax_130 * 0x05 + 0x04;
	} while (ecx_132 <= (struct Eq_20 *) ~0x00400490);
	struct Eq_46 * ecx_159 = null;
	int32 eax_164 = ((word32) eax_130 + 0x01) * 0x04;
	do
	{
		*ebx_136 = (word32) (eax_130 >= ~0x59FA10D4) - 1509560534 ^ ecx_159->dw404060;
		ebx_136 = ebx_136 + eax_164;
		ecx_159 = ecx_159 + (uint32) (0x04 /u ((word32) eax_130 + 0x01));
	} while (ecx_159 <= (struct Eq_46 *) 0x1A57);
	ui32 edx_1763 = (word32) fp - 2204 ^ (word32) fp - 2204;
	byte * dwLoc88D4_1745 = (word32) fp - 14948;
	struct Eq_81 * dwLoc890C_1776 = (word32) fp - 2204;
	byte dl_1764 = (byte) edx_1763;
	word16 dx_1765 = (word16) edx_1763;
	do
	{
		dwLoc890C_1776->w0000 = dx_1765;
		if ((dl_1764 & 0x01) == 0x00)
		{
			dwLoc890C_1776->b0004 = (byte) ((word32) *dwLoc88D4_1745 >> (byte) ((word32) bLoc8914));
			edx_1763 = edx_1763 + 0x01;
			dl_1764 = (byte) edx_1763;
			dx_1765 = (word16) edx_1763;
			dwLoc890C_1776 = dwLoc890C_1776 + 0x01;
			if (edx_1763 == (eax_130 | 0x0108))
				break;
			continue;
		}
		dwLoc890C_1776->b0004 = (byte) ((word32) *dwLoc88D4_1745 & 0x0F);
		edx_1763 = edx_1763 + 0x01;
		dl_1764 = (byte) edx_1763;
		dx_1765 = (word16) edx_1763;
		dwLoc88D4_1745 = dwLoc88D4_1745 + 0x01;
		dwLoc890C_1776 = dwLoc890C_1776 + 0x01;
	} while (edx_1763 != (eax_130 | 0x0108));
	int32 eax_235 = 0x02;
	do
	{
		eax_235 - 0x1F + (fp - 0x04) = (byte *) 0x00;
		eax_235 = eax_235 + 0x01;
	} while (eax_235 != 0x11);
	word32 ecx_248 = ~0x0893;
	do
	{
		ci8 al_261 = (byte) (word32) *((word32) (fp - (uint32 *) 0x04) + (ecx_248 + 0x00));
		if (al_261 > 0x00)
		{
			Eq_154 edx_1757 = (uint32) ((uint64) (uint32) (int32) al_261 % (eax_130 - 0x01));
			Mem1760[fp - 0x22 + edx_1757:byte] = Mem240[fp - 0x22 + edx_1757:byte] + 0x01;
		}
		ecx_248 = ecx_248 + 0x06;
	} while (ecx_248 != 0x0EC4);
	ui32 ebx_273 = 0x00;
	int32 edx_276 = 0x01;
	do
	{
		ebx_273 = ebx_273 + (int32) (*((word32) (fp - (uint32 *) 0x04) + (edx_276 - 0x1F))) << (byte) ((0x00 - (eax_130 < 0x01)) + 0x02);
		*((word32) (fp - 100) + edx_276 * 0x04) = (word32) eax_130 + ebx_273;
		edx_276 = edx_276 + 0x01;
	} while (edx_276 != 0x10);
	word32 ecx_300 = fp + ~0x0897;
	do
	{
		int32 edx_305 = (int32) *ecx_300;
		word32 eax_306 = *((word32) (fp - 100) + edx_305 * 0x04);
		*(ecx_300 - 0x02) = (word16) eax_306;
		*((word32) (fp - 100) + edx_305 * 0x04) = eax_306 + 0x01;
		ecx_300 = ecx_300 + 0x06;
	} while (ecx_300 != fp - 616);
	uint32 ebx_347;
	uint32 eax_321 = (uint32) (0x0108 /u ((word32) eax_130 + 0x01));
	byte cl_323 = 0x00;
	uint32 edx_325 = 0x00;
	if (0x00 >= eax_321 - 0x01)
	{
		do
		{
			if (cl_323 == 0x00)
			{
				int32 edi_1004 = 0x80;
				uint32 edx_459 = SLICE(eax_130 * ~0x00FF00FE, word32, 32);
				Eq_293 dwLoc88CC_463 = -eax_130;
				while (true)
				{
					while (true)
					{
						int32 ebx_1003 = edi_1004;
						ui32 esi_1668 = 0x00;
						int32 edi_494 = 0x00;
						int32 dwLoc88A4_496 = 0x00;
						struct Eq_402 * dwLoc88D0_1698 = (struct Eq_402 *) ~0x00;
						do
						{
							ui32 edx_516 = eax_130 | 0x01;
							ui32 ecx_1748 = 0x00;
							do
							{
								ecx_1748 = ecx_1748 * 0x02;
								if (((word32) *dwLoc88D4_1745 & ebx_1003) != 0x00)
									ecx_1748 = ecx_1748 | 0x01;
								ebx_1003 = ebx_1003 >> 0x01;
								if (ebx_1003 == 0x00)
								{
									dwLoc88D4_1745 = dwLoc88D4_1745 + 0x01;
									ebx_1003 = 0x80;
								}
								edx_516 = edx_516 - 0x01;
							} while (edx_516 != 0x00);
							int32 v30_563 = dwLoc88A4_496 << 0x01 | ecx_1748;
							edi_494 = edi_494 + 0x01;
							dwLoc88A4_496 = v30_563;
							int32 edx_1734 = (int32) *((word32) fp + (esi_1668 * 0x06 - 0x0898));
							if (edi_494 > edx_1734)
							{
								word32 eax_1728 = fp + ~0x089B + esi_1668 * 0x06 + 0x0A;
								do
								{
									edx_1734 = (int32) *eax_1728;
									esi_1668 = esi_1668 + 0x01;
									eax_1728 = eax_1728 + 0x06;
								} while (edi_494 > edx_1734);
							}
							if (edi_494 == edx_1734)
							{
								ui32 eax_1679 = esi_1668 * 0x03;
								word32 edx_1685 = fp + ~0x089B + eax_1679 * 0x02;
								if ((int32) *((word32) fp + (eax_1679 * 0x02 - 2202)) != v30_563)
								{
									do
									{
										esi_1668 = esi_1668 + 0x01;
										if ((int32) *((word32) edx_1794 + 0x0A) != edi_494)
											goto l0040177D;
										edx_1685 = (word32) edx_1794 + 0x06;
										Eq_408 edx_1794 = edx_1685;
									} while ((int32) *((word32) edx_1794 + 0x08) != v30_563);
								}
								int32 eax_1694 = (int32) *((word32) fp + (esi_1668 * 0x06 - 2204));
								dwLoc88D0_1698 = (struct Eq_402 *) ~0x00;
								if (eax_1694 == ~0x00)
									continue;
								struct Eq_402 * edx_1704 = (uint32) ((uint64) (uint32) eax_1694 % (eax_130 - 0x01));
								dwLoc88D0_1698 = edx_1704;
								if (edx_1704 >= null)
									break;
								continue;
							}
l0040177D:
						} while (dwLoc88D0_1698 < null);
						word32 edx_599 = eax_130 + 0x01 << 0x08;
						if (dwLoc88D0_1698 >= edx_599)
							break;
						Mem611[fp + 4294932324 + dwLoc88CC_463:byte] = (byte) (word32) bLoc88D0;
						edi_1004 = ebx_1003;
						dwLoc88CC_463 = dwLoc88CC_463 + 0x01;
					}
					if (dwLoc88D0_1698 == (edx_459 >> 0x08) + 0x0100)
						break;
					byte cl_1007;
					ui32 esi_1010;
					byte bLoc88ED_1009;
					Eq_486 dwLoc88C0_652;
					word32 v33_623 = dwLoc88D0_1698 - (edx_599 + (eax_130 + 0x01));
					word32 eax_632 = (uint32) ((uint64) (uint32) (int32) (v33_623 * 0x03)->a405AC0[v33_623].w0000 /u (eax_130 + 0x01));
					word16 ax_639 = (word16) (word32) (v33_623 * 0x03)->a405AC2[v33_623].w0000;
					word16 di_641 = (word16) (word32) (v33_623 * 0x03)->a405AC4[v33_623].w0000;
					if (eax_632 != 0x00)
					{
						cl_1007 = (byte) (word32) *dwLoc88D4_1745;
						dwLoc88C0_652 = eax_632;
						edi_1004 = ebx_1003 >> 0x01;
						bLoc88ED_1009 = cl_1007;
						esi_1010 = (word32) cl_1007;
					}
					else
					{
						int32 edx_913 = (int32) ax_639;
						cl_1007 = (byte) (word32) *dwLoc88D4_1745;
						ui32 dwLoc88BC_1021 = 0x00;
						int32 eax_1014 = edx_913 - (edx_913 | 0x01) *s eax_130;
						bLoc88ED_1009 = cl_1007;
						do
						{
							ui32 v38_945 = dwLoc88BC_1021 << 0x01;
							esi_1010 = (word32) cl_1007;
							dwLoc88BC_1021 = v38_945;
							if ((esi_1010 & ebx_1003) != 0x00)
								dwLoc88BC_1021 = v38_945 | 0x01;
							ebx_1003 = ebx_1003 >> 0x01;
							if (ebx_1003 == 0x00)
							{
								byte * v41_994 = dwLoc88D4_1745 + 0x01;
								cl_1007 = (byte) (word32) *v41_994;
								dwLoc88D4_1745 = v41_994;
								eax_1014 = eax_1014 - 0x01;
								ebx_1003 = 0x80;
								edi_1004 = 0x40;
								bLoc88ED_1009 = cl_1007;
								esi_1010 = (word32) cl_1007;
								if (eax_1014 == 0x00)
									break;
								continue;
							}
							edi_1004 = ebx_1003 >> 0x01;
							eax_1014 = eax_1014 - 0x01;
						} while (eax_1014 != 0x00);
						int32 eax_968 = (int32) di_641;
						uint32 edx_979 = eax_968 + (uint32) ((uint64) ((uint32) eax_130) /u (eax_968 | 0x01));
						dwLoc88C0_652 = (uint32) ((uint64) (uint32) eax_130 /u (edx_979 | 0x01)) + edx_979 + dwLoc88BC_1021;
					}
					int32 dwLoc88B4_669;
					ui32 eax_676;
					if (edi_1004 != 0x00)
					{
						dwLoc88B4_669 = edi_1004 >> 0x01;
						eax_676 = esi_1010;
					}
					else
					{
						byte * v40_887 = dwLoc88D4_1745 + 0x01;
						cl_1007 = (byte) (word32) *v40_887;
						dwLoc88D4_1745 = v40_887;
						edi_1004 = 0x80;
						dwLoc88B4_669 = 0x40;
						eax_676 = (word32) cl_1007;
						bLoc88ED_1009 = cl_1007;
					}
					ui32 dwLoc88C4_686 = 0x07;
					if ((esi_1010 & ebx_1003) != 0x00)
					{
						if (dwLoc88B4_669 == 0x00)
						{
							byte * v36_871 = dwLoc88D4_1745 + 0x01;
							dwLoc88D4_1745 = v36_871;
							dwLoc88B4_669 = 0x80;
							bLoc88ED_1009 = (byte) (word32) *v36_871;
						}
						cl_1007 = (byte) (word32) bLoc88ED_1009;
						edi_1004 = dwLoc88B4_669;
						dwLoc88C4_686 = (word32) ((eax_676 & edi_1004) != 0x00) + (eax_130 | 0x08);
					}
					struct Eq_559 * eax_703 = dwLoc88C4_686 * 0x03;
					uint32 edx_700 = ~0x00;
					word32 ebx_705 = (int32) Mem315[eax_703 + 0x00405AC2 + eax_703:word16];
					if (ebx_705 != ~0x00)
						edx_700 = (uint32) ((uint64) (uint32) ebx_705 % (eax_130 - (struct Eq_604 *) 0x01));
					Eq_600 esi_714 = 0x00;
					while (true)
					{
						esi_714 = esi_714 * 0x02;
						if (((word32) cl_1007 & edi_1004) != 0x00)
							esi_714 = esi_714 | 0x01;
						edi_1004 = edi_1004 >> 0x01;
						if (edi_1004 == 0x00)
						{
							dwLoc88D4_1745 = dwLoc88D4_1745 + 0x01;
							edi_1004 = 0x80;
						}
						edx_700 = edx_700 - 0x01;
						if (edx_700 == 0x00)
							break;
						cl_1007 = (byte) (word32) *dwLoc88D4_1745;
					}
					struct Eq_1524 * eax_752 = dwLoc88C4_686 * 0x03;
					word32 edx_756 = (int32) Mem315[eax_752 + 0x00405AC4 + eax_752:word16];
					if (eax_130 != 0x00)
						edx_756 = edx_756 * 0x02;
					if (dwLoc88C0_652 > 0x00)
					{
						word32 ebx_788 = fp + 4294932324 + dwLoc88CC_463;
						word32 dwLoc890C_794 = ebx_788 - ((esi_714 + eax_130) + edx_756);
						Eq_486 esi_795 = 0x00;
						do
						{
							*ebx_788 = (byte) (uint32) ((uint64) (uint32) (word32) *dwLoc890C_794 /u ((word32) globals->t40603C + 0x01));
							esi_795 = (word32) esi_795 + 0x01;
							dwLoc890C_794 = dwLoc890C_794 + 0x01;
							ebx_788 = ebx_788 + 0x01;
						} while (esi_795 != dwLoc88C0_652);
					}
					dwLoc88CC_463 = dwLoc88CC_463 + dwLoc88C0_652 - (dwLoc88C0_652 | 0x01) *s Mem315[0x0040603C:word32];
				}
				if (dwLoc88CC_463 > 0x00)
				{
					word32 edi_1543 = eax_130 + 0x01 + (eax_130 + 0x01) * 0x02;
					struct Eq_871 * esi_1544 = (struct Eq_871 *) ~0x00;
					Eq_293 ebx_1549 = 0x00;
					Eq_17 edi_1550 = 0x00;
					ui32 v44_1555 = 0x40 - eax_130 * 0x41;
					do
					{
						Eq_882 eax_1571 = (word32) *((word32) (fp - (uint32 *) 0x04) + ((word32) ebx_1549 - 0x00008898));
						byte al_1573 = (byte) eax_1571;
						if (eax_130 != 0x00)
						{
							eax_1571 = (uint32) ((uint64) (uint32) eax_1571 /u eax_130);
							al_1573 = (byte) eax_1571;
						}
						Eq_882 edx_1583 = eax_1571;
						if (esi_1544 <= (struct Eq_871 *) 0x43)
						{
							if (edi_1550 < (eax_130 | 0x10))
							{
								if (*((word32) edi_1550 + 0x00404000) != al_1573)
								{
									edi_1550 = eax_130;
									edx_1583 = eax_1571;
								}
								else
								{
									edi_1550 = (word32) edi_1550 + 0x01;
									edx_1583 = eax_1571;
								}
							}
							else
							{
								esi_1544 = esi_1544 + 0x01;
								if (esi_1544 <= (struct Eq_871 *) 0x2F)
								{
									int32 eax_1624 = (int32) esi_1544[0x00404010];
									edx_1583.u0 = ~0x00;
									if (eax_1624 != ~0x00)
										edx_1583 = (uint32) ((uint64) (uint32) eax_1624 % (eax_130 - (struct Eq_1515 *) 0x01));
								}
								else if (esi_1544 <= (struct Eq_871 *) 0x3F)
									edx_1583 = (int32) (esi_1544 - (edi_1543 << 0x04))->b404040;
								else
									edx_1583 = (int32) (esi_1544 - v44_1555)->b406000;
							}
						}
						Mem1600[ebx_1549 + ~0x8897 + (fp - 0x04):byte] = (byte) (edx_1583 *s (eax_130 + 0x01));
						ebx_1549 = (word32) ebx_1549 + 0x01;
					} while (ebx_1549 != dwLoc88CC_463);
				}
				globals->dw406028 = 0x00;
				globals->dw406028 = fn00403390(4219229612, eax_17);
				int32 eax_1042 = fn00403390(3424463584, eax_17);
				Eq_17 edx_1043 = globals->t40603C;
				globals->dw406014 = eax_1042;
				<anonymous> * eax_1048 = eax_1042 *s ((word32) edx_1043 + 0x01);
				struct Eq_695 * esp_1050;
				word32 ebp_1051;
				word32 eax_1052;
				word32 edi_1053;
				word32 esi_1054;
				word32 ebx_1055;
				byte SZO_1056;
				bool C_1057;
				bool Z_1058;
				word32 edx_1059;
				word32 ecx_1060;
				byte SCZO_1061;
				byte CZ_1062;
				byte al_1063;
				byte dl_1064;
				word16 dx_1065;
				byte cl_1066;
				word16 ax_1067;
				word16 cx_1068;
				bool S_1069;
				word16 di_1070;
				eax_1048();
				*(esp_1050 - 0x04) = esi_1054;
				*(esp_1050 - 0x08) = ~0x6B8AA076;
				int32 eax_1077 = fn00403390(dwArg00, dwArg04);
				Eq_17 edx_1078 = globals->t40603C;
				*(esp_1050 - 0x08) = (union Eq_736 *) (fp - 0x026C);
				esp_1050->dw0000 = 0x00;
				*(esp_1050 - 0x04) = 0x00;
				globals->dw406010 = eax_1077;
				esp_1050->t0004 = fp - 0x0168;
				<anonymous> * eax_1084 = eax_1077 *s ((word32) edx_1078 + 0x01);
				struct Eq_762 * esp_1088;
				word32 ebp_1089;
				word32 eax_1090;
				word32 edi_1091;
				word32 esi_1092;
				word32 ebx_1093;
				byte SZO_1094;
				bool C_1095;
				bool Z_1096;
				word32 edx_1097;
				word32 ecx_1098;
				byte SCZO_1099;
				byte CZ_1100;
				byte al_1101;
				byte dl_1102;
				word16 dx_1103;
				byte cl_1104;
				word16 ax_1105;
				word16 cx_1106;
				bool S_1107;
				word16 di_1108;
				eax_1084();
				*(esp_1088 - 0x0C) = esi_1092;
				*(esp_1088 - 0x10) = 2165515512;
				int32 eax_1114 = fn00403390(dwArg00, dwArg04);
				Eq_17 edx_1115 = globals->t40603C;
				esp_1088->dw0008 = 0x00;
				esp_1088->dw0004 = 0x00;
				esp_1088->dw0000 = 0x02;
				*(esp_1088 - 0x04) = 0x00;
				globals->dw406004 = eax_1114;
				*(esp_1088 - 0x08) = 0x01;
				*(esp_1088 - 0x0C) = 0xC0000000;
				*(esp_1088 - 0x10) = (union Eq_833 *) (fp - 0x0168);
				<anonymous> * eax_1122 = eax_1114 *s ((word32) edx_1115 + 0x01);
				ptr32 esp_1127;
				word32 ebp_1128;
				word32 eax_1129;
				word32 edi_1130;
				word32 esi_1131;
				word32 ebx_1132;
				byte SZO_1133;
				bool C_1134;
				bool Z_1135;
				word32 edx_1136;
				word32 ecx_1137;
				byte SCZO_1138;
				byte CZ_1139;
				byte al_1140;
				byte dl_1141;
				word16 dx_1142;
				byte cl_1143;
				word16 ax_1144;
				word16 cx_1145;
				bool S_1146;
				word16 di_1147;
				eax_1122();
				if (eax_1129 != ~0x00)
				{
					*(esp_1127 - 0x1C) = 2390103535;
					*(esp_1127 - 0x18) = (union Eq_10 *) eax_17;
					int32 eax_1156 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1157 = globals->t40603C;
					*(esp_1127 - 0x08) = 0x00;
					*(esp_1127 - 0x10) = 0x00;
					*(esp_1127 - 0x14) = 0x04;
					*(esp_1127 - 0x18) = 0x00;
					globals->dw40602C = eax_1156;
					*(esp_1127 - 0x1C) = eax_1129;
					word32 edx_1167 = dwLoc88CC_463 + 0x01;
					*(esp_1127 - 0x0C) = (union Eq_955 *) edx_1167;
					<anonymous> * eax_1164 = eax_1156 *s ((word32) edx_1157 + 0x01);
					ptr32 esp_1170;
					word32 ebp_1171;
					word32 eax_1172;
					word32 edi_1173;
					word32 esi_1174;
					word32 ebx_1175;
					byte SZO_1176;
					bool C_1177;
					bool Z_1178;
					word32 edx_1179;
					word32 ecx_1180;
					byte SCZO_1181;
					byte CZ_1182;
					byte al_1183;
					byte dl_1184;
					word16 dx_1185;
					byte cl_1186;
					word16 ax_1187;
					word16 cx_1188;
					bool S_1189;
					word16 di_1190;
					eax_1164();
					*(esp_1170 - 0x14) = (union Eq_10 *) eax_17;
					*(esp_1170 - 0x18) = 0xFC1F1484;
					int32 eax_1197 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1198 = globals->t40603C;
					*(esp_1170 - 0x08) = 0x00;
					*(esp_1170 - 0x0C) = 0x00;
					*(esp_1170 - 0x10) = 0x00;
					globals->dw406030 = eax_1197;
					*(esp_1170 - 0x14) = 0x02;
					*(esp_1170 - 0x18) = eax_1172;
					<anonymous> * eax_1205 = eax_1197 *s ((word32) edx_1198 + 0x01);
					word32 esp_1209;
					word32 ebp_1210;
					word32 eax_1211;
					word32 edi_1212;
					word32 esi_1213;
					word32 ebx_1214;
					byte SZO_1215;
					bool C_1216;
					bool Z_1217;
					word32 edx_1218;
					word32 ecx_1219;
					byte SCZO_1220;
					byte CZ_1221;
					byte al_1222;
					byte dl_1223;
					word16 dx_1224;
					byte cl_1225;
					word16 ax_1226;
					word16 cx_1227;
					bool S_1228;
					word16 di_1229;
					eax_1205();
					word32 esi_1231 = eax_1211;
					struct Eq_1061 * esp_1233 = esp_1209 - 0x14;
					if (dwLoc88CC_463 > 0x00)
					{
						Eq_293 ebx_1500 = 0x00;
						do
						{
							Eq_17 edx_1508 = globals->t40603C;
							esp_1233->t0004 = fp - 0x12;
							word32 eax_1513 = (word32) ebx_1500 + esi_1231;
							<anonymous> * edx_1515 = ((word32) edx_1508 + 0x01) *s globals->dw406028;
							esp_1233->dw0000 = eax_1513;
							word32 esp_1518;
							word32 ebp_1519;
							word32 eax_1520;
							word32 edi_1521;
							byte SZO_1524;
							bool C_1525;
							bool Z_1526;
							word32 edx_1527;
							word32 ecx_1528;
							byte SCZO_1529;
							byte CZ_1530;
							byte al_1531;
							byte dl_1532;
							word16 dx_1533;
							byte cl_1534;
							word16 ax_1535;
							word16 cx_1536;
							bool S_1537;
							word16 di_1538;
							edx_1515();
							esp_1233 = esp_1518 - 0x08;
						} while (ebx_1500 != dwLoc88CC_463);
					}
					esp_1233->dw0000 = ~0x3489B267;
					esp_1233->t0004 = eax_17;
					int32 eax_1242 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1243 = globals->t40603C;
					esp_1233->dw0000 = esi_1231;
					globals->dw406034 = eax_1242;
					<anonymous> * eax_1247 = eax_1242 *s ((word32) edx_1243 + 0x01);
					union Eq_10 * esp_1249;
					word32 ebp_1250;
					word32 eax_1251;
					word32 edi_1252;
					word32 esi_1253;
					word32 ebx_1254;
					byte SZO_1255;
					bool C_1256;
					bool Z_1257;
					word32 edx_1258;
					word32 ecx_1259;
					byte SCZO_1260;
					byte CZ_1261;
					byte al_1262;
					byte dl_1263;
					word16 dx_1264;
					byte cl_1265;
					word16 ax_1266;
					word16 cx_1267;
					bool S_1268;
					word16 di_1269;
					eax_1247();
					*esp_1249 = (union Eq_10 *) eax_17;
					*(esp_1249 - 0x04) = 0x941A1EE1;
					int32 eax_1275 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1276 = globals->t40603C;
					*(esp_1249 - 0x04) = eax_1172;
					globals->dw406008 = eax_1275;
					<anonymous> * eax_1282 = eax_1275 *s ((word32) edx_1276 + 0x01);
					ptr32 esp_1284;
					word32 ebp_1285;
					word32 eax_1286;
					word32 edi_1287;
					word32 esi_1288;
					word32 ebx_1289;
					byte SZO_1290;
					bool C_1291;
					bool Z_1292;
					word32 edx_1293;
					word32 ecx_1294;
					byte SCZO_1295;
					byte CZ_1296;
					byte al_1297;
					byte dl_1298;
					word16 dx_1299;
					byte cl_1300;
					word16 ax_1301;
					word16 cx_1302;
					bool S_1303;
					word16 di_1304;
					eax_1282();
					<anonymous> * eax_1307 = ((word32) globals->t40603C + 0x01) *s globals->dw406008;
					*(esp_1284 - 0x04) = edi_1287;
					union Eq_10 * esp_1311;
					word32 ebp_1312;
					word32 eax_1313;
					word32 edi_1314;
					word32 esi_1315;
					word32 ebx_1316;
					byte SZO_1317;
					bool C_1318;
					bool Z_1319;
					word32 edx_1320;
					word32 ecx_1321;
					byte SCZO_1322;
					byte CZ_1323;
					byte al_1324;
					byte dl_1325;
					word16 dx_1326;
					byte cl_1327;
					word16 ax_1328;
					word16 cx_1329;
					bool S_1330;
					word16 di_1331;
					eax_1307();
					*esp_1311 = (union Eq_10 *) eax_17;
					*(esp_1311 - 0x04) = 0xDE0B22C2;
					int32 eax_1337 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1338 = globals->t40603C;
					globals->dw40601C = eax_1337;
					*(esp_1311 - 0x04) = (union Eq_1207 *) (fp - 0x0168);
					<anonymous> * eax_1341 = eax_1337 *s ((word32) edx_1338 + 0x01);
					struct Eq_1216 * esp_1345;
					word32 ebp_1346;
					word32 eax_1347;
					Eq_1219 edi_1348;
					word32 esi_1349;
					word32 ebx_1350;
					byte SZO_1351;
					bool C_1352;
					bool Z_1353;
					word32 edx_1354;
					word32 ecx_1355;
					byte SCZO_1356;
					byte CZ_1357;
					byte al_1358;
					byte dl_1359;
					word16 dx_1360;
					byte cl_1361;
					word16 ax_1362;
					word16 cx_1363;
					bool S_1364;
					word16 di_1365;
					eax_1341();
					esp_1345->t0000 = edi_1348;
					*(esp_1345 - 0x04) = 2843221742;
					int32 eax_1371 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1372 = globals->t40603C;
					esp_1345->t0000 = fp - 0x026C;
					esp_1345->dw0004 = 0x0104;
					*(esp_1345 - 0x04) = 0x00;
					globals->dw406018 = eax_1371;
					<anonymous> * eax_1379 = eax_1371 *s ((word32) edx_1372 + 0x01);
					ptr32 esp_1381;
					word32 ebp_1382;
					word32 eax_1383;
					word32 edi_1384;
					word32 esi_1385;
					word32 ebx_1386;
					byte SZO_1387;
					bool C_1388;
					bool Z_1389;
					word32 edx_1390;
					word32 ecx_1391;
					byte SCZO_1392;
					byte CZ_1393;
					byte al_1394;
					byte dl_1395;
					word16 dx_1396;
					byte cl_1397;
					word16 ax_1398;
					word16 cx_1399;
					bool S_1400;
					word16 di_1401;
					eax_1379();
					*(esp_1381 - 0x08) = ebx_1386;
					*(esp_1381 - 0x0C) = 4229121209;
					int32 eax_1406 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1407 = globals->t40603C;
					*(esp_1381 - 0x0C) = (union Eq_1311 *) (fp - 0x026C);
					globals->dw406038 = eax_1406;
					<anonymous> * eax_1411 = eax_1406 *s ((word32) edx_1407 + 0x01);
					word32 * esp_1413;
					word32 ebp_1414;
					word32 eax_1415;
					word32 edi_1416;
					word32 esi_1417;
					word32 ebx_1418;
					byte SZO_1419;
					bool C_1420;
					bool Z_1421;
					word32 edx_1422;
					word32 ecx_1423;
					byte SCZO_1424;
					byte CZ_1425;
					byte al_1426;
					byte dl_1427;
					word16 dx_1428;
					byte cl_1429;
					word16 ax_1430;
					word16 cx_1431;
					bool S_1432;
					word16 di_1433;
					eax_1411();
					*esp_1413 = edi_1416;
					*(esp_1413 - 0x04) = ~0x61F0C037;
					int32 eax_1438 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1439 = globals->t40603C;
					*(esp_1413 - 0x04) = ebx_1418;
					globals->dw406020 = eax_1438;
					<anonymous> * eax_1443 = eax_1438 *s ((word32) edx_1439 + 0x01);
					word32 * esp_1445;
					word32 ebp_1446;
					word32 eax_1447;
					word32 edi_1448;
					word32 esi_1449;
					word32 ebx_1450;
					byte SZO_1451;
					bool C_1452;
					bool Z_1453;
					word32 edx_1454;
					word32 ecx_1455;
					byte SCZO_1456;
					byte CZ_1457;
					byte al_1458;
					byte dl_1459;
					word16 dx_1460;
					byte cl_1461;
					word16 ax_1462;
					word16 cx_1463;
					bool S_1464;
					word16 di_1465;
					eax_1443();
					*esp_1445 = edi_1448;
					*(esp_1445 - 0x04) = 2651074515;
					int32 eax_1470 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1471 = globals->t40603C;
					*(esp_1445 - 0x04) = 0x00;
					globals->dw406024 = eax_1470;
					<anonymous> * eax_1475 = eax_1470 *s ((word32) edx_1471 + 0x01);
					word32 esp_1477;
					word32 ebp_1478;
					word32 eax_1479;
					word32 edi_1480;
					word32 esi_1481;
					word32 ebx_1482;
					byte SZO_1483;
					bool C_1484;
					bool Z_1485;
					word32 edx_1486;
					word32 ecx_1487;
					byte SCZO_1488;
					byte CZ_1489;
					byte al_1490;
					byte dl_1491;
					word16 dx_1492;
					byte cl_1493;
					word16 ax_1494;
					word16 cx_1495;
					bool S_1496;
					word16 di_1497;
					eax_1475();
				}
				return 0x00;
			}
			cl_323 = 0x00;
			ebx_347 = 0x00;
l00401249:
			edx_325 = ebx_347;
l0040124B:
		} while (edx_325 >= eax_321 - 0x01);
	}
	word32 edi_341 = fp - 0x10 + edx_325 * 0x06;
	ebx_347 = edx_325 + 0x01;
	byte al_346 = (byte) (word32) *((word32) edi_341 - 0x0888);
	word32 eax_352 = fp - 0x10 + ebx_347 * 0x06;
	if ((byte) (word32) al_346 > *(eax_352 - 0x0888))
	{
		word16 dx_364 = (word16) (word32) *((word32) edi_341 - 0x088A);
		Eq_303 cx_366 = (word16) (word32) *((word32) edi_341 - 0x088C);
		*((word32) edi_341 - 0x088C) = *((word32) eax_352 - 0x088C);
		*((word32) edi_341 - 0x0888) = (word16) (word32) *(eax_352 - 0x0888);
		*(eax_352 - 0x088A) = dx_364;
		*(eax_352 - 0x0888) = (byte) (word32) al_346;
		*((word32) eax_352 - 0x088C) = cx_366;
		cl_323 = 0x01;
		edx_325 = ebx_347;
		goto l0040124B;
	}
	goto l00401249;
}

// 00403390: Register uint32 fn00403390(Stack ui32 dwArg04, Stack Eq_10 dwArg08)
uint32 fn00403390(ui32 dwArg04, Eq_10 dwArg08)
{
	uint32 edx_132;
	Eq_17 ebx_155 = globals->t40603C;
	word16 * edi_26 = dwArg08 | ebx_155;
	word32 edx_30 = dwArg08 - (dwArg08 | 0x01) *s ebx_155 + Mem0[(edi_26 + 0x78) + Mem0[dwArg08 + 0x3C:word32]:word32];
	struct Eq_1611 * esp_15 = fp - 0xAC;
	Eq_17 dwLoc84_161 = ebx_155;
	word16 * eax_31 = edx_30->ptr0024;
	ui32 ecx_34 = edx_30->dw0020;
	if ((uint32) ((uint64) (uint32) edx_30->dw0018 /u ((word32) ebx_155 + 0x01)) != 0x00)
	{
		uint32 dwLoc88_141 = 0x00;
		struct Eq_1809 * ecx_143[] = (word32) dwArg08 + (ecx_34 - (ecx_34 | 0x01) *s ebx_155);
		word32 dwLoc8C_146 = edi_26 + eax_31;
		while (true)
		{
			word32 ecx_165 = dwArg08 + ecx_143[dwLoc88_141 * 0x04];
			Eq_1646 esi_166 = 0x00;
			byte al_171 = (byte) (word32) ecx_165->a0000[0x00].t0000;
			if (al_171 != 0x00)
			{
				Eq_1646 edi_302 = 0x00;
				do
				{
					Eq_1653 eax_321 = (int32) al_171;
					if (ebx_155 != 0x00)
						eax_321 = (uint32) ((uint64) (uint32) eax_321 /u ebx_155);
					Eq_1658 eax_330 = (word32) ebx_155 + 0x01;
					byte dl_328 = (byte) eax_321;
					<anonymous> * ecx_333 = eax_330 *s globals->dw406028;
					if (ecx_333 == null)
					{
						int32 edx_355 = (int32) dl_328;
						esi_166 - 110 + (fp - 0x04) = (byte *) (byte) (edx_355 - (edx_355 | 0x01) *s ebx_155);
					}
					else
					{
						esp_15->dw0004 = (uint32) ((uint64) (uint32) (fp - 0x12) /u eax_330);
						ptr32 eax_371 = (word32) edi_302.u0 + (fp - 114);
						esp_15->ptr0000 = eax_371;
						word32 esp_374;
						word32 ebp_375;
						word32 edi_376;
						word32 ebx_378;
						byte SCZO_379;
						word32 eax_380;
						word32 ecx_381;
						word32 edx_382;
						byte SZO_383;
						bool C_384;
						bool Z_385;
						byte al_386;
						byte dl_387;
						byte CZ_388;
						ecx_333();
						ebx_155 = globals->t40603C;
						esp_15 = esp_374 - 0x08;
					}
					esi_166 = (word32) esi_166.u0 + 0x01;
					edi_302 = esi_166;
					al_171 = (byte) (word32) Mem0[ecx_165 + esi_166:byte];
				} while (al_171 != 0x00);
			}
			Eq_1646 edx_188 = (word32) ebx_155 + 0x0030;
			if (edx_188 > esi_166)
			{
				byte * eax_288 = (word32) esi_166.u0 + (fp - 114);
				Eq_1646 esi_292 = esi_166;
				do
				{
					*eax_288 = 0x00;
					esi_292 = (word32) esi_292.u0 + 0x01;
					eax_288 = eax_288 + 0x01;
				} while (edx_188 > esi_292);
			}
			ui32 ecx_196 = 0x01;
			ui32 eax_198 = dwLoc84_161 | dwArg04;
			do
			{
				ui32 edx_210 = (fp - 118)[ecx_196];
				if (ebx_155 != 0x00)
					edx_210 = edx_210 * 0x02;
				ecx_196 = ecx_196 + 0x01;
				eax_198 = eax_198 ^ edx_210;
			} while (ecx_196 != 0x0D);
			if (eax_198 != ~0x00)
			{
				Eq_1777 ecx_244 = ebx_155 - 0x01;
				if ((uint32) ((uint64) (uint32) eax_198 % ecx_244) == 2305906339)
				{
					edx_132 = ~0x00;
					word32 eax_260 = ((ebx_155 + 0x01) *s (dwArg08 + Mem0[edx_30 + 0x1C:word32]))[(word32) Mem0[dwLoc8C_146 + 0x00:word16] * 0x04] + dwArg08;
					if (eax_260 == ~0x00)
						return edx_132;
					return (uint32) ((uint64) (uint32) eax_260 % ecx_244);
				}
			}
			uint32 v21_228 = dwLoc88_141 + 0x01;
			dwLoc88_141 = v21_228;
			if ((uint32) ((uint64) (uint32) edx_30->dw0018 /u ((word32) ebx_155 + 0x01)) <= v21_228)
				break;
			dwLoc8C_146 = dwLoc8C_146 + 0x02;
			dwLoc84_161 = ebx_155;
		}
	}
	edx_132 = 0x00;
	return edx_132;
}

// 00403590: Register uint32 fn00403590()
uint32 fn00403590()
{
	Eq_17 esi_21 = globals->t40603C;
	int32 ebx_22 = fs->ptr0018->ptr0030->dw000C;
	ui32 edi_30 = (word32) (uint32) ((uint64) (uint32) esi_21 /u (ebx_22 | 0x01)) + 0x001C + ebx_22;
	struct Eq_1848 * ecx_36 = edi_30 - (edi_30 | 0x01) *s esi_21;
	byte al_38 = (byte) (((word32) esi_21 + 0x01) *s 0x6B);
	byte al_47 = (byte) (((word32) esi_21 + 0x01) *s 114);
	byte dl_50 = (byte) (((esi_21 - 1148159575 >> 0x01) + 1148159575 >> 0x06) + 101);
	do
	{
		uint32 edx_107;
		struct Eq_1877 * eax_59 = (uint32) ((uint64) (uint32) ecx_36->dw0020 /u ((word32) esi_21 + 0x01));
		if (eax_59->b0000 == (byte) ((word32) al_38) && (eax_59->b0002 == (byte) ((word32) dl_50) && eax_59->b0004 == (byte) ((word32) al_47)))
		{
			word32 ebx_106 = ecx_36->dw0008;
			edx_107 = ~0x00;
			if (ebx_106 != ~0x00)
				edx_107 = (uint32) ((uint64) (uint32) ebx_106 % (esi_21 - 0x01));
			return edx_107;
		}
		ecx_36 = ecx_36->dw0000 | esi_21;
	} while (edi_30 != ecx_36->dw0000);
	edx_107 = 0x00;
	return edx_107;
}

// 00403640: void fn00403640(Register uint32 eax, Stack (ptr32 code) dwArg00)
void fn00403640(uint32 eax, code * dwArg00)
{
	struct Eq_1926 * ecx_10 = fp + 0x04;
	while (eax >= 0x1000)
	{
		ecx_10 = ecx_10 - 0x1000;
		ecx_10->dw0000 = ecx_10->dw0000;
		eax = eax - 0x1000;
	}
	word32 * ecx_22 = ecx_10 - eax;
	*ecx_22 = *ecx_22;
	word32 esp_32;
	word32 ecx_33;
	byte SCZO_34;
	word32 eax_35;
	bool C_36;
	byte SZO_37;
	dwArg00();
}

