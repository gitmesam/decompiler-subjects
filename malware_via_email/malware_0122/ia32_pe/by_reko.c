// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
}

// 00403350: Register int32 fn00403350(Stack int32 dwArg04, Stack Eq_1761 dwArg08, Stack (ptr byte) dwArg0C)
int32 fn00403350(int32 dwArg04, Eq_1761 dwArg08, byte * dwArg0C)
{
	Eq_250 edx_8 = globals->t40603C;
	int32 edi_118 = dwArg04;
	int32 ecx_24 = (0x00 - (edx_8 < 0x01) & ~0x63) + 200;
	byte bl_29 = (byte) (word32) *dwArg0C;
	if (bl_29 != 0x00)
	{
		byte cl_67 = (byte) edx_8;
		ui32 ebx_84 = edx_8 - 0x01 & 0x33;
		int32 esi_91 = dwArg08 *s dwArg04;
		Eq_1761 edx_90 = ((uint32) (100 % (edx_8 - 0x01)) *s (((word32) edx_8 + 0x01) *s 0x55 + (0x25 << cl_67) *s ecx_24) + ebx_84) *s dwArg08;
		int32 eax_96 = fn00403350((word32) bl_29 + esi_91, edx_90, dwArg0C + 0x01);
		<anonymous> * eax_99 = globals->ptr406028;
		if (eax_99 != null)
		{
			word32 esp_122;
			word32 ebp_123;
			byte SCZO_124;
			word32 edx_125;
			word32 eax_126;
			word32 esi_127;
			word32 edi_128;
			byte C_129;
			word32 ecx_130;
			byte SZO_131;
			word32 ebx_132;
			byte bl_133;
			byte Z_134;
			byte cl_135;
			eax_99();
		}
		edi_118 = eax_96;
	}
	return edi_118;
}

// 00403420: Register ui32 fn00403420(Stack ui32 dwArg04, Stack (ptr byte) dwArg08)
ui32 fn00403420(ui32 dwArg04, byte * dwArg08)
{
	Eq_250 esi_16 = globals->t40603C;
	uint32 edx_23 = SLICE(esi_16 * 98685563, word32, 32);
	return dwArg04 ^ fn00403350(0x00, (((word32) (edx_23 + (esi_16 - edx_23 >> 0x01) >> 0x09) + 1000) *s ((word32) ((esi_16 - 0x04104105 >> 0x01) + 0x04104105 >> 0x05) + 0x003F) + 0x02B1) + (SLICE(esi_16 * 797903939, word32, 32) >> 0x07), dwArg08);
}

// 004034A0: Register ptr32 fn004034A0(Stack ui32 dwArg04, Stack int32 dwArg08, Stack (ptr Eq_40) dwArg0C)
ptr32 fn004034A0(ui32 dwArg04, int32 dwArg08, Eq_40 * dwArg0C)
{
}

// 004035B0: Register ui32 fn004035B0()
ui32 fn004035B0()
{
}

// 00403640: void fn00403640(Register uint32 eax, Stack (ptr code) dwArg00)
void fn00403640(uint32 eax, code * dwArg00)
{
	struct Eq_2060 * ecx_10 = fp + 0x04;
	while (eax >= 0x1000)
	{
		ecx_10 = ecx_10 - 0x1000;
		ecx_10->dw0000 = ecx_10->dw0000;
		eax = eax - 0x1000;
	}
	word32 * ecx_22 = ecx_10 - eax;
	*ecx_22 = *ecx_22;
	word32 esp_32;
	word32 ecx_33;
	byte SCZO_34;
	word32 eax_35;
	byte C_36;
	byte SZO_37;
	bcuisposr0 None_38;
	dwArg00();
}

