// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_13;
	byte SCZO_14;
	word32 esi_15;
	byte SZO_16;
	byte C_17;
	word32 eax_18;
	byte Z_19;
	word32 ebx_20;
	word32 ebp_21;
	word32 edi_22;
	byte cl_23;
	byte dl_24;
	word32 edx_25;
	word32 ecx_26;
	byte S_27;
	SHLWAPI.dll!StrChrA();
	if (eax_18 != 0x00)
		return 0x00;
	*(esp_13 - 0x04) = eax_18;
	*(esp_13 - 0x08) = 0x00404070;
	ptr32 esp_53;
	byte SCZO_54;
	word32 esi_55;
	byte SZO_56;
	byte C_57;
	word32 eax_58;
	byte Z_59;
	word32 ebx_60;
	word32 ebp_61;
	word32 edi_62;
	byte cl_63;
	byte dl_64;
	word32 edx_65;
	word32 ecx_66;
	byte S_67;
	SHLWAPI.dll!StrStrIA();
	if (eax_58 != 0x00)
		return 0x00;
	*(esp_53 - 0x04) = ebx_60;
	*(esp_53 - 0x08) = ebp_61;
	*(esp_53 - 0x0C) = edi_62;
	*(esp_53 - 0x10) = 0x0040407C;
	*(esp_53 - 0x14) = 0x00404084;
	*(esp_53 - 0x18) = (HMODULE *) LoadLibraryA(*(esp_53 - 0x14));
	Eq_91 eax_84 = GetProcAddress(*(esp_53 - 0x18), *(esp_53 - 0x14));
	*(esp_53 - 0x1C) = 0x00;
	*(esp_53 - 0x20) = 0x00;
	*(esp_53 - 0x24) = 0x00;
	*(esp_53 - 0x28) = 0x00;
	*(esp_53 - 44) = 0x00;
	int32 eax_100 = eax_84();
	*(esp_53 - 0x30) = ~0x00;
	*(esp_53 - 0x34) = ~0x00;
	struct Eq_150 * edi_111 = eax_100 + 0x1C;
	if (AreAllAccessesGranted(*(esp_53 - 0x34), *(esp_53 - 0x30)) == 0x00)
		edi_111 = eax_100 + 0x1C ^ 0x0E;
	*(esp_53 - 0x38) = esp_53 - 0x24;
	*(esp_53 - 0x3C) = 0x40;
	*(esp_53 - 0x40) = 0x3000;
	*(esp_53 - 0x44) = 0x00401000;
	VirtualProtect(*(esp_53 - 0x44), *(esp_53 - 0x40), *(esp_53 - 0x3C), *(esp_53 - 0x38));
	struct Eq_220 * esp_128 = esp_53 - 0x44;
	struct Eq_222 * eax_131 = null;
	do
	{
		struct Eq_150 * esi_141;
		if (esi_141 == edi_111)
			esi_141 = null;
		eax_131[700564] = (struct Eq_222) (esi_141[0x00405000] ^ eax_131[700564] ^ 0x5A);
		struct Eq_150 * esi_149 = esi_141 + 0x01;
		if (esi_149 == edi_111)
			esi_149 = null;
		eax_131->b402379 = esi_149[0x00405000] ^ eax_131->b402379 ^ 0x5A;
		struct Eq_150 * esi_159 = esi_149 + 0x01;
		if (esi_159 == edi_111)
			esi_159 = null;
		eax_131->b40237A = esi_159[0x00405000] ^ eax_131->b40237A ^ 0x5A;
		struct Eq_150 * esi_169 = esi_159 + 0x01;
		if (esi_169 == edi_111)
			esi_169 = null;
		eax_131->b40237B = esi_169[0x00405000] ^ eax_131->b40237B ^ 0x5A;
		struct Eq_150 * esi_179 = esi_169 + 0x01;
		if (esi_179 == edi_111)
			esi_179 = null;
		eax_131->b40237C = esi_179[0x00405000] ^ eax_131->b40237C ^ 0x5A;
		struct Eq_150 * esi_189 = esi_179 + 0x01;
		if (esi_189 == edi_111)
			esi_189 = null;
		eax_131 = eax_131 + 0x01;
		eax_131->b402377 = esi_189[0x00405000] ^ eax_131->b40237D ^ 0x5A;
		esi_141 = esi_189 + 0x01;
	} while (eax_131 < (struct Eq_222 *) 0x1440);
	*(esp_53 - 0x30) = 4202744;
	*(esp_53 - 44) = 0x00;
	struct Eq_345 * esi_206 = &globals->t403678;
	word32 ebp_209 = 4202744;
	up32 ecx_217 = 0x00;
	do
	{
		Eq_353 eax_225 = esi_206->t0004;
		word16 * edx_231 = (char *) &esi_206->t0004 + 0x04;
		if (eax_225 - 0x08 >> 0x01 > 0x00)
		{
			uint32 ebx_375 = eax_225 - 0x08 >> 0x01;
			do
			{
				ui32 eax_379 = (word32) *edx_231;
				if ((eax_379 & 0xF000) == 0x3000)
				{
					struct Eq_379 * eax_393 = (eax_379 & 0x0FFF) + esi_206->dw0000;
					eax_393->dw4020F8 = eax_393->dw4020F8 + 0xF04020F8;
				}
				edx_231 = edx_231 + 0x01;
				ebx_375 = ebx_375 - 0x01;
			} while (ebx_375 != 0x00);
			ecx_217 = *(esp_53 - 44);
		}
		ecx_217 = (word32) esi_206->t0004 + ecx_217;
		*(esp_53 - 44) = ecx_217;
		esi_206 = esi_206 + Mem241[esi_206 + 0x04:word32];
	} while (ecx_217 < 232);
	*(esp_53 - 44) = 0x00402E6C;
	struct Eq_409 * edi_246 = &globals->t402E6C;
	if (globals->dw402E7C != 0x00)
	{
		edi_272 = edi_246;
		ebp_273 = ebp_209;
		esp_276 = esp_128;
		do
		{
			struct Eq_409 * edi_272;
			word32 ebp_273;
			struct Eq_220 * esp_276;
			esp_276 = esp_276 - 0x04 + 0x14;
			esp_276->dw0000 = edi_272->dw000C + ebp_273;
			Eq_85 eax_282 = LoadLibraryA(esp_276->dw0000);
			esp_276->dw001C = (word32) eax_282;
			Eq_85 ecx_283 = eax_282;
			if (eax_282 != null)
			{
				word32 eax_306 = edi_272->dw0000;
				if (eax_306 == 0x00)
					eax_306 = edi_272->dw0010;
				word32 * ebp_311 = ebp_273 + eax_306;
				int32 eax_314 = *ebp_311;
				word32 * edi_315 = edi_272->dw0010 + esp_276->dw0014;
				if (eax_314 != 0x00)
				{
					while (true)
					{
						Eq_91 eax_347;
						if (eax_314 < 0x00)
						{
							LPCSTR * esp_360 = esp_276 - 0x04;
							*esp_360 = (LPCSTR *) (word32) *ebp_311;
							*(esp_360 - 0x04) = (HMODULE *) ecx_283;
							eax_347 = GetProcAddress(*(esp_360 - 0x04), *esp_360);
						}
						else
						{
							LPCSTR * esp_369 = esp_276 - 0x04;
							*esp_369 = (LPCSTR *) (eax_314 + 0x02 + esp_276->dw0000);
							*(esp_369 - 0x04) = (HMODULE *) ecx_283;
							eax_347 = GetProcAddress(*(esp_369 - 0x04), *esp_369);
						}
						*edi_315 = (word32) eax_347;
						ebp_311 = ebp_311 + 0x01;
						esp_276 = esp_276 - 0x08;
						eax_314 = *ebp_311;
						edi_315 = edi_315 + 0x01;
						if (eax_314 == 0x00)
							break;
						ecx_283 = (Eq_85) esp_276->dw001C;
					}
				}
				ebp_273 = esp_276->dw0014;
				edi_272 = (struct Eq_409 *) esp_276[0x03];
			}
			edi_272 = edi_272 + 0x01;
			esp_276[0x03] = (struct Eq_220) edi_272;
		} while (edi_272->dw0010 != 0x00);
	}
	ptr32 esp_253;
	byte SCZO_254;
	word32 esi_255;
	byte SZO_256;
	byte C_257;
	word32 eax_258;
	byte Z_259;
	word32 ebx_260;
	word32 ebp_261;
	word32 edi_262;
	byte cl_263;
	byte dl_264;
	word32 edx_265;
	word32 ecx_266;
	byte S_267;
	globals->t402B58();
	*(esp_253 - 0x04) = 0x00;
	ExitProcess(*(esp_253 - 0x04));
}

