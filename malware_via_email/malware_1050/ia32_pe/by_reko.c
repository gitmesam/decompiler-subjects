// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401108: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	do
	{
		struct Eq_3 * psegLoc06_36 = (struct Eq_3 **) 0x02;
		*fs = fp - 0x08;
		null = (union Eq_12 *) ecx;
		ebx = ebx + 0x01;
		ui8 al_46 = null ^ 0x00;
		*ebx = *ebx | dl;
		byte al_56;
		__das(al_46, &al_56);
		dl = dl | (byte) ss;
		ebp = (struct Eq_41 *) ((char *) &ebp->ptr0000 + 0x01);
		byte bh_44 = SLICE(ebx, byte, 8);
		dwLoc0E = DPB(dwLoc0E, ss, 0);
		ptr32 eax_67 = DPB(dwLoc0A, 100, 8);
		edx = DPB(edx, dl, 0);
		struct Eq_3 * ds_1436 = psegLoc06_36;
		if (!OVERFLOW(dl))
		{
			Eq_61 ds_esi_1435 = dwLoc0E->t0000;
			ds_1436 = SLICE(ds_esi_1435, selector, 32);
			esi = ds_esi_1435;
		}
		else
			ebp = (struct Eq_41 *) ((char *) &ebp->ptr0000 + 0x01);
		Eq_61 esi_1019;
		struct Eq_235 * ecx_1243;
		struct Eq_88 * edi_1102;
		byte bh_1257;
		byte * ebx_1245;
		struct Eq_41 * ebp_1244;
		Eq_236 dl_1250;
		struct Eq_237 * edx_1258;
		Eq_9 fs_1240;
		struct Eq_3 * ss_1247;
		struct Eq_78 * cs_1267;
		bool P_1269;
		struct Eq_3 ** esp_1097;
		word32 eax_1087;
		Eq_12 ecx_1096;
		word32 edx_1093;
		struct Eq_3 * ds_1053;
		struct Eq_238 * esp_1055;
		Eq_239 C_1028;
		union Eq_236 * eax_1023;
		byte al_1024;
		byte ah_1025;
		Eq_243 C_181;
		Eq_244 eax_186;
		char al_547;
		struct Eq_3 ** esp_508;
		Eq_247 C_507;
		word32 eax_506;
		byte al_505;
		byte * edi_500;
		byte * esi_499;
		byte bh_498;
		union Eq_236 * ebx_497;
		word16 dx_265;
		union Eq_236 * eax_283;
		byte al_282;
		bool Z_272;
		byte al_97 = (byte) (eax_67 - 1772256572) + *(eax_67 - 1772256572);
		byte ah_93 = SLICE(eax_67 - 1772256572, byte, 8);
		ecx = &dwLoc0E->t0001;
		byte cl_95 = (byte) &dwLoc0E->t0001;
		ptr32 eax_99 = DPB(eax_67 - 1772256572, al_97 ^ 0x1E, 0);
		if ((al_97 ^ 0x1E) < 0x00)
		{
			esp_1097 = fp - 0x08;
			eax_1087 = DPB(eax_99, ah_93 - cl_95, 8);
			P_1269 = P;
			cs_1267 = cs;
			ss_1247 = ss;
			fs_1240 = fs;
			ds_1053 = ds_1436;
			edx_1093 = edx;
			ebp_1244 = ebp;
			ebx_1245 = ebx;
			bh_1257 = bh_44;
			esi_1019 = esi;
			edi_1102 = edi;
			ecx_1096 = ecx;
			goto l004011B9;
		}
	} while (dwLoc0E == (struct Eq_46 *) 0x01);
	ptr32 eax_1155;
	Eq_12 ecx_1151;
	struct Eq_88 * edi_1142;
	Eq_61 esi_1141;
	byte * ebx_1139;
	word32 edx_1133;
	struct Eq_3 * ss_1128;
	ptr32 esp_1006;
	struct Eq_101 * eax_1005;
	byte ch_1001;
	word16 dx_1260;
	byte dh_1262;
	Eq_105 esp_1158 = fp - ~0x1346 | dwLoc0E->t0001;
	bool O_1145 = (bool) cond(esp_1158);
	ss_1128 = ss;
	edx_1133 = edx;
	ebx_1139 = ebx;
	esi_1141 = esi;
	edi_1142 = edi;
	ecx_1151 = ecx;
	eax_1155 = eax_99;
	if (true)
	{
		byte bh_1401 = bh_44 - ah_93;
		ebx_1139 = DPB(ebx, bh_1401, 8);
		O_1145 = (bool) cond(bh_1401);
		ss_1128 = ss;
		edx_1133 = edx;
		esi_1141 = esi;
		edi_1142 = edi;
		ecx_1151 = ecx;
		eax_1155 = eax_99;
l00401153:
		if (O_1145)
		{
			byte SZO_1368;
			bool C_1369;
			byte al_1373;
			real64 rArg0_1375;
			byte ah_1378;
			byte cl_1379;
			struct Eq_180 * ds_1380;
			bool O_1381;
			byte SCZO_1382;
			byte SO_1383;
			bool D_1388;
			bool S_1391;
			byte SCZDOP_1392;
			bool Z_1393;
			bool FPUF_1395;
			byte bl_1397;
			struct Eq_190 * es_1398;
			byte CZ_1399;
			word16 ax_1400;
			fn0E5C4A6D();
			goto l00401179;
		}
	}
	struct Eq_3 ** esp_1159 = esp_1158 - 0x02;
	*esp_1159 = (struct Eq_3 **) ss_1128;
	*(esp_1159 - 0x04) = eax_1155;
	*(esp_1159 - 0x08) = (union Eq_12 *) ecx_1151;
	*(esp_1159 - 0x0C) = edx_1133;
	*(esp_1159 - 0x10) = (byte **) ebx_1139;
	*(esp_1159 - 0x14) = (struct Eq_3 ***) esp_1159;
	*(esp_1159 - 0x18) = (union Eq_148 *) (fp - 0x08);
	*(esp_1159 - 0x1C) = (union Eq_61 *) esi_1141;
	*(esp_1159 - 0x20) = (struct Eq_88 **) edi_1142;
	esp_1158 = esp_1159 - 0x20;
	ecx_1151 = ecx_1151 - 0x01;
	if (ecx_1151 == 0x00)
	{
		word32 eax_1275;
		struct Eq_198 * fs_1276;
		byte SZO_1277;
		Eq_200 C_1278;
		word32 ebp_1280;
		byte al_1282;
		real64 rArg0_1284;
		byte dl_1286;
		byte ah_1287;
		byte cl_1288;
		struct Eq_207 * ds_1289;
		bool O_1290;
		byte SCZO_1291;
		byte SO_1292;
		byte bh_1293;
		word16 dx_1296;
		bool D_1297;
		byte dh_1298;
		byte ch_1299;
		bool S_1300;
		byte SCZDOP_1301;
		bool Z_1302;
		struct Eq_219 * cs_1303;
		bool FPUF_1304;
		bool P_1305;
		byte bl_1306;
		struct Eq_223 * es_1307;
		byte CZ_1308;
		word16 ax_1309;
		fn0A9DF44C();
		__lock();
		eax_1155 = 0x55C70F26 - C_1278;
		O_1145 = (bool) cond(eax_1155);
	}
	if (ecx_1151 != 0x00)
	{
		byte SZO_1241;
		bool C_1242;
		byte al_1246;
		real64 rArg0_1248;
		byte ah_1251;
		byte cl_1252;
		struct Eq_285 * ds_1253;
		bool O_1254;
		byte SCZO_1255;
		byte SO_1256;
		bool D_1261;
		bool S_1264;
		byte SCZDOP_1265;
		bool Z_1266;
		bool FPUF_1268;
		byte bl_1270;
		struct Eq_295 * es_1271;
		byte CZ_1272;
		word16 ax_1273;
		fn0E5C4A6D();
l00401179:
		eax_1005->dw001F = 279713124;
		bool v28_1013 = (edi_1102[0x1B70E1C3] & 0x00) != 0x00;
		edi_1102[0x1B70E1C3] = (struct Eq_88) __rol(edi_1102[0x1B70E1C3], 0xA0);
		bool C_1015 = v28_1013;
		do
		{
			eax_1023 = eax_1005 - 0x10701EC8 - C_1015;
			union Eq_236 ** esp_1037 = esp_1006 - 0x04;
			*esp_1037 = (union Eq_236 **) eax_1023;
			*(esp_1037 - 0x04) = (struct Eq_235 **) ecx_1243;
			*(esp_1037 - 0x08) = (struct Eq_237 **) edx_1258;
			*(esp_1037 - 0x0C) = (byte **) ebx_1245;
			*(esp_1037 - 0x10) = esp_1006;
			*(esp_1037 - 0x14) = (union Eq_396 *) (fp - 0x08);
			*(esp_1037 - 0x18) = (union Eq_61 *) esi_1019;
			*(esp_1037 - 0x1C) = (struct Eq_88 **) edi_1102;
			al_1024 = (byte) eax_1023;
			ah_1025 = SLICE(eax_1023, byte, 8);
			C_1028 = (bool) cond(eax_1023);
			ds_1053 = (struct Eq_3 *) *(esp_1037 - 0x1C);
			esp_1055 = esp_1037 - 0x1A;
			if (!OVERFLOW(eax_1023))
			{
				if (eax_1023 >= null)
					goto l004011CC;
				if (!OVERFLOW(eax_1023))
					goto l0040123E;
				goto l00401277;
			}
			struct Eq_3 ** eax_1058 = DPB(eax_1023, al_1024 - 0x0E - (eax_1023 < null) ^ 0x15, 0);
			ds_1053 = (struct Eq_3 *) *eax_1058;
			Eq_339 al_1066 = __inb(dx_1260);
			eax_1005 = DPB(esp_1037 - 0x1A, (word32) al_1066 + 0x00B2, 0);
			byte v32_1072 = Mem1052[eax_1005 + ~0x18618618:byte] + bh_1257 + (al_1066 <u 0xB2);
			eax_1005->bE79E79E7 = v32_1072;
			esp_1006 = (char *) eax_1058 + 0x02;
			C_1015 = (bool) cond(v32_1072);
			&esi_1019.u0->dw0000 = 0xD0CA82C4;
		} while (v32_1072 < 0x00);
		ecx_1096 = DPB(ecx_1243, (byte) ecx_1243[0x1813F2C3] + ch_1001, 8);
		*eax_1058 = (struct Eq_3 **) ss_1247;
		eax_1087 = 0xD0CA82C4;
		edx_1093 = DPB(edx_1258, (byte) dl_1250.u1 + dh_1262, 8);
		esp_1097 = eax_1058;
		esi_1019 = &eax_1005->bE79E79E7 + 0x1861861A;
		edi_1102 = edi_1102 + 0x01;
		int3();
l004011B9:
		edx_1258 = edx_1093 + 0x01;
		eax_283 = eax_1087 ^ edx_1258;
		dx_265 = (word16) edx_1258;
		esp_1055 = esp_1097 - 0x01;
		al_282 = (byte) eax_283;
		ah_1025 = SLICE(eax_283, byte, 8);
		Z_272 = (bool) cond(eax_283);
		ecx_1243 = ecx_1096 - 0x01;
		if (ecx_1243 != null)
		{
l0040122F:
			ecx_1243 = ecx_1243 - 0x01;
			if (!Z_272 || ecx_1243 == null)
				goto l00401231;
			__outb(dx_265, al_282);
			Eq_339 al_302 = __inb(dx_265);
			(union Eq_9 *) 3605544070 = (union Eq_9 *) fs_1240;
			Eq_2 eax_303 = DPB(eax_283, al_302, 0);
			if (edi_1102[ecx_1243 * 0x04] != 0x86 && ecx_1243 != (struct Eq_235 *) 0x01 || edi_1102[ecx_1243 * 0x04] == 0x86)
			{
				byte al_335;
				byte ah_336;
				__aaa(al_302, ah_1025, &al_335, &ah_336);
				return eax_303 - ~0x05977A4A;
			}
			Eq_782 SO_350;
			int3();
			if (edi_1102[ecx_1243 * 0x04] != 0x86 || ecx_1243 == (struct Eq_235 *) 0x02)
			{
				byte al_405;
				__daa(al_302, &al_405);
l004012B7:
				struct Eq_41 * esp_384 = esp_1055 - 0x04;
				esp_384->ptr0000 = ebp_1244;
				*(esp_384 - 0x70F1) = 2268892950;
				ebp_1244 = esp_384;
				SO_350 = cond(eax_303 - 3161842681);
				esp_1055 = esp_384 - 0x70F1;
			}
			else
			{
				struct Eq_3 ** esp_407 = esp_1055 - 0x02;
				*esp_407 = (struct Eq_3 **) ss_1247;
				if (OVERFLOW(edi_1102[ecx_1243 * 0x04] - 0x86))
					__syscall(0x04);
				__bound(3605544070, *((word32) esi_1019 + 114));
				int3();
				*(esp_407 - 0x04) = 3605544070;
				Eq_849 edx_411 = &edx_1258->bF037BB23 + 0x0FC844DE;
				edi_1102->t0000.u6 = al_302;
				esp_1055 = esp_407 - 0x04;
				word16 dx_413 = (word16) edx_411;
				cu8 dh_414 = SLICE(edx_411, byte, 8);
				struct Eq_860 * edi_424 = edi_1102 + 0x01;
				if (edx_411 > 0x00)
				{
					if (OVERFLOW(edx_411))
						__syscall(0x04);
					*eax_303 = 0x29CF10C3;
					if (al_302 + (eax_303 + 0xB8B3E022)[ebp_1244 * 0x02] + (edi_1102[ecx_1243 * 0x04] <u 0x86) >= 0x00)
					{
						edi_424->b0000 = __in(dx_413);
						*(ecx_1243 - 0x02) = *(ecx_1243 - 0x02) + ~0x18;
					}
					else
						__inb(110);
				}
				Mem472[3605544070:byte] = Mem423[3605544070:byte] + al_302;
				SO_350 = cond(dh_414 - ((edi_424->a0078))[edx_411].b0000);
				if (dh_414 > ((edi_424->a0078))[edx_411].b0000)
					return eax_303;
			}
			eax_303 = __indw(~0x4C);
			(union Eq_2 *) 2815483851 = (union Eq_2 *) eax_303;
			__syscall(~0x0C);
			if (!SO_350)
				return eax_303 - ~0x05977A4A;
			goto l004012B7;
		}
		*eax_283 = (union Eq_236 *) (*eax_283 - ebx_1245);
		eax_1023 = DPB(eax_283, al_282 & ~0x45, 0);
		al_1024 = al_282 & ~0x45;
		C_1028 = (bool) cond(eax_1023 - ebx_1245);
		dl_1250.u1 = 0x5B;
l004011CC:
		int32 v39_839 = *((word32) esi_1019 + 0x69DB8DD9) - 0x7C - C_1028;
		*((word32) esi_1019 + 0x69DB8DD9) = v39_839;
		if (v39_839 > 0x00)
		{
			__outb(0x00, al_1024);
			esp_1055->w0002 = ds_1053;
			return DPB(eax_1023, al_1024 | 0x14, 0);
		}
		__wait();
		struct Eq_78 ** esp_872 = esp_1055 - 0x02;
		*esp_872 = (struct Eq_78 **) cs_1267;
		al_547 = al_1024 + 0x15;
		*DPB(eax_1023, al_547, 0) = (union Eq_236 *) dl_1250;
		bh_1257 = 0x11;
		ebx_1245 = DPB(ebx_1245, 0x11, 8);
		if (al_547 < 0x00)
		{
			*(esp_872 - 0x02) = (struct Eq_78 **) cs_1267;
			char al_880 = al_547 - 0x1B - (al_547 < 0x00);
			ebp_1244 = (struct Eq_41 *) *(esp_872 - 0x02);
			Eq_604 eax_881 = DPB(eax_1023, al_880, 0);
			*(esp_872 - 0x02) = (union Eq_604 *) eax_881;
			eax_186 = eax_881 - 0x0E789A94 - (al_880 < 0x00);
			C_181 = (bool) cond(eax_186);
l00401207:
			Eq_628 eax_662 = (bool) C_181.u0 + ((bool) eax_186.u0 + 0x10A07058);
			__wait();
			cu8 al_667 = (byte) eax_662 - ~0x01 - (eax_662 < 0x00);
			word16 * esp_661 = ebx_1245 - 0x01;
			Eq_619 eax_668 = DPB(eax_662, al_667, 0);
			bool S_676 = (bool) cond(al_667);
			ecx_1243 = ecx_1243 - 0x01;
			if (al_667 == 0x00 && ecx_1243 != null)
			{
				while (true)
				{
					if (!P_1269)
					{
						edx_1258 = (struct Eq_237 *) 2531646578;
						if (S_676)
						{
							byte SZO_773;
							real64 rArg0_780;
							byte dl_782;
							byte ah_783;
							byte cl_784;
							struct Eq_678 * ds_785;
							bool O_786;
							byte SCZO_787;
							byte SO_788;
							bool D_793;
							byte dh_794;
							byte ch_795;
							bool S_796;
							byte SCZDOP_797;
							bool Z_798;
							struct Eq_688 * cs_799;
							bool FPUF_800;
							byte bl_802;
							struct Eq_691 * es_803;
							byte CZ_804;
							word16 ax_805;
							fn0E5C4A43();
l00401222:
							cu8 al_511 = al_505 - 0x15 - C_507;
							byte * eax_512 = DPB(eax_506, al_511, 0);
							ds_1053 = (struct Eq_3 *) *esp_508;
							*eax_512 = (bool) (al_511 < 0x00) + (*eax_512 + bh_498);
							*edi_500 = *esi_499;
							byte * eax_518 = DPB(eax_506, al_511 - 0x22, 0);
							esp_1055 = (struct Eq_238 *) ((char *) esp_508 + 0x02);
							Z_272 = (bool) cond(al_511 - 0x22);
							esi_1019 = esi_499 + 0x01;
							edi_1102 = (struct Eq_88 *) (edi_500 + 0x01);
							ebx_1245 = eax_518;
							bh_1257 = SLICE(eax_518, byte, 8);
							eax_283 = ebx_497;
							al_282 = (byte) ebx_497;
							ah_1025 = SLICE(ebx_497, byte, 8);
							goto l0040122F;
						}
						if (ecx_1243 == null)
						{
l00401231:
							edi_1102->t0000 = *esi_1019;
							esi_1019 = esi_1019 + 0x01;
							edi_1102 = edi_1102 + 0x01;
l0040123E:
							__inb(0x2E);
							C_181.u0 = false;
							eax_186.u0 = 4030184230;
							ecx_1243 = ecx_1243 - 0x01;
							if (ecx_1243 == null)
							{
								if (ecx_1243 == null)
								{
									edx_1258->bF037BB23 = edx_1258->bF037BB23 + bh_1257;
									return 4030184348;
								}
								else
									edi_1102->dwDC4C83A4 = edi_1102->dwDC4C83A4 - 0x30;
							}
							goto l00401207;
						}
						esp_661 = esp_661 - 0x02;
						*esp_661 = ds_1053;
					}
					*((word32) esi_1019 + (ebp_1244 * 0x08 + 0x006D)) = *((word32) esi_1019 + (ebp_1244 * 0x08 + 0x006D)) | ~0x67;
					if (*((word32) esi_1019 + (ebp_1244 * 0x08 + 0x006D)) == 0x00)
						break;
					esp_661 = esp_661 - 0x01;
					S_676 = (bool) cond(esp_661);
				}
l00401277:
			}
			word32 eax_682 = (bool) (al_667 < 0x00) + ((word32) eax_668 + 0x1C2B157C);
			al_547 = (byte) eax_682;
			ah_1025 = SLICE(eax_682, byte, 8);
		}
		byte al_548;
		byte ah_549;
		bool C_550 = __aas(al_547, ah_1025, &al_548, &ah_549);
		byte SZO_563;
		real64 rArg0_570;
		byte dl_572;
		byte ah_573;
		byte cl_574;
		struct Eq_571 * ds_575;
		bool O_576;
		byte SCZO_577;
		byte SO_578;
		bool D_583;
		byte dh_584;
		byte ch_585;
		bool S_586;
		byte SCZDOP_587;
		bool Z_588;
		struct Eq_581 * cs_589;
		bool FPUF_590;
		byte bl_592;
		struct Eq_584 * es_593;
		byte CZ_594;
		word16 ax_595;
		fn1F2830FE();
		goto l00401222;
	}
	goto l00401153;
}

