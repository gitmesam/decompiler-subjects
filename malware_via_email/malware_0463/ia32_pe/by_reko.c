// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_18;
	byte SCZO_19;
	byte SZO_22;
	byte C_23;
	word32 eax_24;
	byte Z_25;
	word32 ebp_26;
	word32 edi_27;
	byte cl_28;
	byte dl_29;
	word32 ecx_30;
	byte CZ_31;
	word32 edx_32;
	byte S_33;
	Eq_17 ebx_20;
	Eq_17 esi_101;
	SHLWAPI.dll!StrStrIA();
	if (eax_24 != 0x00)
		return 0x00;
	*(esp_18 - 0x04) = 0x00;
	*(esp_18 - 0x08) = 0x00;
	Eq_2 eax_57 = AddUsersToEncryptedFile(*(esp_18 - 0x08), *(esp_18 - 0x04));
	if (eax_57 == 0x00)
		return eax_57;
	*(esp_18 - 0x0C) = ~0x00;
	*(esp_18 - 0x10) = ~0x00;
	Eq_64 eax_65 = AreAllAccessesGranted(*(esp_18 - 0x10), *(esp_18 - 0x0C));
	if (eax_65 == 0x00)
		ebx_20 = eax_65 + 0x19;
	*(esp_18 - 0x14) = ebp_26;
	*(esp_18 - 0x18) = edi_27;
	*(esp_18 - 0x1C) = esp_18 - 0x04;
	*(esp_18 - 0x20) = 0x40;
	*(esp_18 - 0x24) = 0x3000;
	*(esp_18 - 0x28) = 0x00401000;
	VirtualProtect(*(esp_18 - 0x28), *(esp_18 - 0x24), *(esp_18 - 0x20), *(esp_18 - 0x1C));
	*(esp_18 - 0x18) = *(esp_18 - 0x18) - 0x01;
	struct Eq_154 * eax_153 = null;
	struct Eq_156 * esp_90 = esp_18 - 0x28;
	do
	{
		if (esi_101 == ebx_20)
			esi_101 = null;
		eax_153->b401678 = esi_101[0x00404000] ^ eax_153->b401678 ^ 0xAA;
		Eq_17 esi_104 = esi_101 + 0x01;
		if (esi_104 == ebx_20)
			esi_104 = null;
		eax_153->b401679 = esi_104[0x00404000] ^ eax_153->b401679 ^ 0xAA;
		Eq_17 esi_114 = esi_104 + 0x01;
		if (esi_114 == ebx_20)
			esi_114 = null;
		eax_153->b40167A = esi_114[0x00404000] ^ eax_153->b40167A ^ 0xAA;
		Eq_17 esi_124 = esi_114 + 0x01;
		if (esi_124 == ebx_20)
			esi_124 = null;
		eax_153->b40167B = esi_124[0x00404000] ^ eax_153->b40167B ^ 0xAA;
		Eq_17 esi_134 = esi_124 + 0x01;
		if (esi_134 == ebx_20)
			esi_134 = null;
		eax_153[700010] = (struct Eq_154) (esi_134[0x00404000] ^ eax_153[700010] ^ 0xAA);
		Eq_17 esi_144 = esi_134 + 0x01;
		if (esi_144 == ebx_20)
			esi_144 = null;
		eax_153 = eax_153 + 0x01;
		eax_153->b401677 = esi_144[0x00404000] ^ eax_153->b40167D ^ 0xAA;
		esi_101 = (Eq_17) (esi_144 + 0x01);
	} while (eax_153 < (struct Eq_154 *) 0x1440);
	*(esp_18 - 0x18) = *(esp_18 - 0x18) + 0x01;
	*(esp_18 - 0x0C) = 4199416;
	*(esp_18 - 0x10) = 0x00;
	int32 edi_162 = 4199416;
	struct Eq_291 * ecx_163 = &globals->t402978;
	if (*(esp_18 - 0x18) > 0x00)
	{
		do
		{
			Eq_315 eax_300 = ecx_163->t0004 - 0x08 >> 0x01;
			word16 * edx_303 = (char *) &ecx_163->t0004 + 0x04;
			if (eax_300 > 0x00)
			{
				Eq_315 ebx_317 = eax_300;
				do
				{
					ui32 eax_321 = (word32) *edx_303;
					if ((eax_321 & 0xF000) == 0x3000)
					{
						struct Eq_452 * eax_333 = (eax_321 & 0x0FFF) + ecx_163->dw0000;
						eax_333->dw4013F8 = eax_333->dw4013F8 + 0xF04013F8;
					}
					edx_303 = edx_303 + 0x01;
					ebx_317 = ebx_317 - 0x01;
				} while (ebx_317 != 0x00);
			}
			Eq_318 eax_309 = ecx_163->t0004;
			up32 edx_311 = (word32) eax_309 + *(esp_18 - 0x10);
			*(esp_18 - 0x10) = edx_311;
			ecx_163 = ecx_163 + eax_309;
		} while (edx_311 < *(esp_18 - 0x18));
	}
	*(esp_18 - 0x10) = 4202860;
	struct Eq_306 * ebx_181 = &globals->t40216C;
	edi_204 = edi_162;
	ebx_207 = ebx_181;
	esp_208 = esp_90;
	if (globals->dw40217C != 0x00)
	{
		do
		{
			int32 edi_204;
			struct Eq_306 * ebx_207;
			struct Eq_156 * esp_208;
			esp_208 = esp_208 - 0x04;
			esp_208->dw0000 = ebx_207->dw000C + edi_204;
			Eq_401 eax_214 = LoadLibraryA(esp_208->dw0000);
			esp_208[0x08] = (struct Eq_156) eax_214;
			Eq_401 ecx_215 = eax_214;
			if (eax_214 != null)
			{
				ptr32 ebp_238 = ebx_207->dw0000;
				if (ebp_238 == 0x00)
					ebp_238 = ebx_207->dw0010;
				Eq_431 eax_244 = ebp_238 + edi_204;
				struct Eq_434 * ebp_245 = ebp_238 + edi_204;
				word32 * esi_246 = ebx_207->dw0010 + edi_204;
				if (eax_244 != 0x00)
				{
					while (true)
					{
						Eq_466 eax_264;
						if (eax_244 < 0x00)
						{
							LPCSTR * esp_279 = esp_208 - 0x04;
							*esp_279 = (LPCSTR *) (word32) ebp_245->w0000;
							*(esp_279 - 0x04) = (HMODULE *) ecx_215;
							eax_264 = GetProcAddress(*(esp_279 - 0x04), *esp_279);
						}
						else
						{
							LPCSTR * esp_286 = esp_208 - 0x04;
							*esp_286 = (LPCSTR *) ((word32) eax_244 + 0x02 + edi_204);
							*(esp_286 - 0x04) = (HMODULE *) ecx_215;
							eax_264 = GetProcAddress(*(esp_286 - 0x04), *esp_286);
						}
						*esi_246 = (word32) eax_264;
						ebp_245 = ebp_245 + 0x01;
						esp_208 = esp_208 - 0x08;
						eax_244.u1 = ebp_245->w0000;
						edi_204 = (int32) esp_208[0x07];
						esi_246 = esi_246 + 0x01;
						if (eax_244 == 0x00)
							break;
						ecx_215 = (Eq_401) esp_208[0x08];
					}
					ebx_207 = (struct Eq_306 *) esp_208[0x06];
				}
			}
			ebx_207 = ebx_207 + 0x01;
			esp_208[0x06] = (struct Eq_156) ebx_207;
		} while (ebx_207->dw0010 != 0x00);
	}
	ptr32 esp_184;
	byte SCZO_185;
	word32 ebx_186;
	word32 esi_187;
	byte SZO_188;
	byte C_189;
	word32 eax_190;
	byte Z_191;
	word32 ebp_192;
	word32 edi_193;
	byte cl_194;
	byte dl_195;
	word32 ecx_196;
	byte CZ_197;
	word32 edx_198;
	byte S_199;
	globals->t401E58();
	*(esp_184 - 0x04) = 0x00;
	ExitProcess(*(esp_184 - 0x04));
}

