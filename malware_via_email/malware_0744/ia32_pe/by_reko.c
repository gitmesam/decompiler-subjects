// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004011CB: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ui32 ecx_9;
	byte * ebx_10;
	word32 esi_11;
	word32 edi_12;
	Eq_2 eax_13 = fn004011D9(eax, ecx, dx, ebx, ebp, dwLoc04, dwArg00, out ecx_9, out ebx_10, out esi_11, out edi_12);
	eax_13->b0000 = eax_13->b0000 + (byte) eax_13;
	*ebx_10 = *ebx_10 + ch;
	int64 edx_eax_22 = (int64) eax_13;
	int32 eax_23 = (word32) edx_eax_22;
	cui16 dx_25 = SLICE(edx_eax_22, word16, 32);
	word32 ecx_30;
	word32 ebx_31;
	word32 esi_32;
	word32 edi_33;
	return fn004011D9(eax_23, ecx_9, dx_25, ebx_10, ebp, dwLoc04, dwArg00, out ecx_30, out ebx_31, out esi_32, out edi_33);
}

// 004011D9: Register int32 fn004011D9(Register int32 eax, Register ui32 ecx, Register cui16 dx, Register (ptr32 byte) ebx, Register word32 ebp, Stack word32 dwArg00, Stack Eq_16 dwArg04, Register out ptr32 ecxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
int32 fn004011D9(int32 eax, ui32 ecx, cui16 dx, byte * ebx, word32 ebp, word32 dwArg00, Eq_16 dwArg04, ptr32 & ecxOut, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	*ebxOut = ebx;
	word16 ax_144;
	struct Eq_67 * ecx_141;
	ui32 edi_125;
	ci8 * eax_119;
	__ror((word16) dwArg00, 0x01);
	union Eq_88 ** esp_122 = fp + 0x04;
	word32 eax_24 = (word32) *(dwArg04 - ~0x06);
	union Eq_88 * edx_117 = DPB(edx, dx | ~0x3B, 0);
	byte dl_30 = (byte) (dx | ~0x3B);
	if (eax_24 != 0x90)
	{
		eax_119 = __ror(eax_24, 22);
		Mem213[(ecx | 0x9E1501B5) + eax_119:word32] = dwArg04;
		__lock();
		byte al_210 = (byte) eax_119;
		*eax_119 = *eax_119 + al_210;
		*eax_119 = *eax_119 + al_210;
		*ebx = *ebx + dl_30;
		ci8 v21_224 = *eax_119 + al_210;
		*eax_119 = v21_224;
		ax_144 = (word16) eax_119;
		esp_122 = fp + 0x08;
		edi_125 = dwArg04 - ~0x06 >> 0x19 ^ ebx;
		if (v21_224 > 0x00)
			goto l004012C0;
		ecx_141 = (ecx | 0x9E1501B5) - 0x01;
		if (v21_224 != 0x00 || ecx_141 == null)
		{
			__outb(dx | ~0x3B, al_210);
			word16 dx_236;
			byte SZO_237;
			bool C_238;
			word32 esi_239;
			word16 si_240;
			word32 edi_241;
			word32 eax_242;
			byte SCZO_243;
			word32 ecx_244;
			byte al_245;
			bool Z_246;
			byte dl_248;
			word32 edx_249;
			word16 ax_250;
			word16 di_252;
			fnD837FD69();
l004012DE:
			Eq_238 eax_49 = ebx + 4163496;
			union Eq_238 * esp_51 = esp_122 - 0x04;
			*esp_51 = (union Eq_238 *) eax_49;
			*(esp_51 - 0x04) = fs->dw0000;
			*(esp_51 - 0x08) = esp_51 - 0x04;
			word32 edi_64 = *(esp_51 - 0x08);
			fs->dw0000 = edi_64;
			*(esp_51 - 0x08) = 0x00;
			word32 edi_72;
			*ediOut = __rol(edi_64, 0x12);
			*(esp_51 - 0x0C) = ebp;
			word32 ecx_74;
			*ecxOut = ebp;
			word32 esi_80;
			*esiOut = ebp;
			return ((word32) eax_49 + 0x01 >> 0x07) + ~0x7EA2A602;
		}
l00401258:
		word32 esi_162 = ecx_141->dw0000;
		ax_144 = __rol(ax_144, 0x07);
		if (esi_162 - edi_125 == 0x00)
		{
			*ebxOut = (word32) *(ecx_141 - 0x03);
			union Eq_88 ** esp_193 = esp_122 - 0x04;
			*esp_193 = *esp_122;
			edx_117 = (union Eq_88 *) *esp_193;
			esp_122 = (union Eq_88 **) ((char *) esp_193 + 0x04);
			eax_119 = globals->ptr40102B;
l004012B7:
			edi_125 = *edx_117;
			edx_117 = (union Eq_88 *) ((char *) edx_117 + 0x01);
l004012C0:
			if ((edi_125 ^ eax_119) == 0x00)
				goto l004012DE;
			goto l004012B7;
		}
	}
	else
	{
		word16 dx_258 = (word16) (fp + 0x04);
		ax_144 = dx_258;
		ecx_141 = DPB(1206072, dx_258, 0) + 0x00;
		edi_125 = globals->dw4010C8;
	}
	ecx_141 = ecx_141 - ~0x00;
	goto l00401258;
}

