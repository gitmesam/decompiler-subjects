// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004190D4: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
}

// 004190D5: Register Eq_3 fn004190D5(Register Eq_3 eax, Register Eq_3 ecx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register Eq_8 mm6, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_3 fn004190D5(Eq_3 eax, Eq_3 ecx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, Eq_8 mm6, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	esp = fp;
	v5 = Mem0[eax + 0x60:word32] + ebp;
	*((word32) eax + 0x0060) = v5;
	SCZO = cond(v5);
	ecx = fn004190D8(ecx, ebp, esi, edi, mm6, out ebp, out esi, out edi);
	return ecx;
}

// 004190D8: Register Eq_3 fn004190D8(Register Eq_3 ecx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register Eq_8 mm6, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_3 fn004190D8(Eq_3 ecx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, Eq_8 mm6, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_3 ebp_8;
	Eq_3 esi_9;
	Eq_3 edi_10;
	real64 rLoc1_11;
	Eq_3 ecx_12 = fn004190DD(ecx, ebp, esi, edi, mm6, dwLoc04, out ebp_8, out esi_9, out edi_10, out rLoc1_11);
	word32 ebp_14;
	word32 esi_15;
	word32 edi_16;
	real64 rLoc1_17;
	return fn004190DD(ecx_12, ebp_8, esi_9, edi_10, mm6, dwArg00, out ebp_14, out esi_15, out edi_16, out rLoc1_17);
}

// 004190DD: Register Eq_3 fn004190DD(Register Eq_3 ecx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register Eq_8 mm6, Stack (ptr32 Eq_88) dwArg00, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut, FpuStack out Eq_92 rLoc1Out)
Eq_3 fn004190DD(Eq_3 ecx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, Eq_8 mm6, Eq_88 * dwArg00, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut, Eq_92 & rLoc1Out)
{
	*ebpOut = ebp;
	*esiOut = esi;
	*ediOut = edi;
	struct Eq_136 * esp_1 = fp;
	struct Eq_88 * ebx_101 = dwArg00;
	do
	{
		struct Eq_143 * ebx_31 = (char *) ebx_101 + 0x0012;
		ebx_31->dw0000 = ebx_31->dw0000 - 0x0006B1E8;
		*(ebx_31 - 0x03) = *(ebx_31 - 0x03) - 0x01;
		esp_289->t0000 = esp_289->t0000 - 0xAC;
		if (esp_289 != null)
		{
			if (esp_289 == null)
			{
				*((word32) ecx + 0x7AD70473) = 0x73812FF7;
				*edi = *edi - esi;
			}
			else
			{
				ebx_31->dw0004 = ebx_31->dw0004 ^ 0x2FF77AD7;
				ebx_31->dw0019 = ebx_31->dw0019 ^ 0xB7430077;
			}
			return ecx;
		}
		if (false)
		{
			word32 esi_284;
			*esiOut = *((word32) edi - 0x00070000) *s ~0x1C;
			word32 ebp_287;
			*ebpOut = *ebp;
			return ecx;
		}
		ecx = esp_289->t0018;
		byte * eax_112 = esp_289->ptr001C;
		int32 edx_106 = esp_289->dw0014;
		edi = esp_289->t0000;
		*ediOut = edi;
		word32 esi_96 = esp_289->dw0004;
		*ebpOut = esp_289->dw0008;
		ebx_101 = esp_289->ptr0010;
		word16 dx_116 = (word16) (edx_106 + 0x01);
		__outdw(dx_116, eax_112);
		byte cl_109 = (byte) ecx;
		byte al_113 = (byte) eax_112;
		esp_1 = (struct Eq_136 *) ((char *) &esp_289->t001F + 0x01);
		*esiOut = esi_96 + 0x04;
		struct Eq_136 * esp_289 = esp_1;
	} while (edx_106 < 0x01);
	*eax_112 = *eax_112 + al_113;
	*((word32) ecx + 110) = (word32) *((word32) ecx + 110) + cl_109;
	Eq_275 esi_124 = ebx_101->a006F[eax_112].dw0000 *s 0x6E6F6D6D;
	__outdw(dx_116, eax_112);
	__outb(dx_116, al_113);
	if (ebx_101 == (struct Eq_88 *) 0x01)
		;
	__outdw(dx_116, eax_112);
	*edi = __in(dx_116);
	*eax_112 = *eax_112 + al_113;
	__outdw(dx_116, eax_112);
	Eq_3 eax_159 = esp_289->t003B;
	struct Eq_316 * edx_152 = esp_289->ptr0033;
	struct Eq_320 * ebx_147 = esp_289->ptr002F;
	Eq_3 ecx_155 = esp_289->t0037;
	byte al_160 = (byte) eax_159;
	Eq_3 edi_140 = esp_289->t001F;
	*ediOut = edi_140;
	Eq_3 esi_142 = esp_289->t0023;
	*esiOut = esi_142;
	Eq_3 ebp_144 = esp_289->t0027;
	*ebpOut = ebp_144;
	word32 * esp_163 = edx_152->dw0072 *s 1098478177;
	*eax_159 = (word32) *eax_159 + al_160;
	cu8 v26_166 = (word32) *((word32) edi_140 + 101) + al_160;
	*((word32) edi_140 + 101) = v26_166;
	word16 bx_148 = (word16) ebx_147;
	byte bl_149 = (byte) ebx_147;
	byte ch_157 = SLICE(ecx_155, byte, 8);
	if (v26_166 != 0x00)
	{
		if (v26_166 < 0x00)
		{
			__sti();
			ebx_147 = DPB(ebx_147, bl_149 + ch_157, 0);
			ebx_147->dw404F0D95 = ebx_147->dw404F0D95 - 0x01;
			goto l00419143;
		}
		__arpl(*((word32) ecx_155 + 100), bx_148, &*((word32) ecx_155 + 100));
		if (v26_166 >= 0x00)
		{
			if (v26_166 < 0x00)
			{
				word32 ebp_237;
				word32 esi_238;
				word32 edi_239;
				return fn004190D5(eax_159, ecx_155, ebp_144, esi_142, edi_140, mm6, out ebp_237, out esi_238, out edi_239);
			}
		}
	}
	else
	{
		word32 esp_253;
		byte SCZO_255;
		byte SZO_256;
		real64 rLoc1_257;
		word32 esi_258;
		bool C_259;
		bool Z_260;
		Eq_3 ecx_261;
		word32 edi_262;
		word32 * ebp_263;
		word32 edx_264;
		word32 eax_265;
		word16 dx_266;
		bool S_267;
		byte al_268;
		byte cl_269;
		word16 bx_270;
		byte bl_271;
		byte ch_272;
		byte bh_273;
		(*((word32) ebp_144 + 0x0033))();
		*ebpOut = *ebp_263;
		esp_163 = ebp_263 + 0x01;
		ecx_155 = ecx_261;
		if (ecx_261 == 0x00)
			fn0041912F(dwLoc04);
	}
	edx_152 = (struct Eq_316 *) *((word32) ebp_144 + 4214541);
l00419143:
	word32 eax_193 = edx_152->dw003C;
	*((word32) ebp_144 + 4214551) = edx_152 + eax_193 / 118;
	if (true)
	{
		fn00419167();
		__pmaddwd(mm6, ebx_147->t0011);
		fn00419167();
		return ecx_155;
	}
	else if (true)
	{
		fn00419168();
		return ecx_155;
	}
	else
	{
		*esp_163 = *esp_163 + 0x17;
		return ecx_155;
	}
}

// 0041912F: void fn0041912F(Stack ptr32 dwArg00)
void fn0041912F(ptr32 dwArg00)
{
	word32 esp_7;
	word32 edx_8;
	byte SCZO_9;
	(dwArg00 - 11)();
}

// 00419167: void fn00419167()
void fn00419167()
{
}

// 00419168: void fn00419168()
void fn00419168()
{
	esp = fp;
	esp = fp - 0x02;
	wLoc02 = es;
}

