// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401020: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00401270();
	ui32 eax_17 = (dwLoc20 << 0x0E) + 0x000BD020;
	Eq_404 ecx_20[] = (eax_17 & 0xFFFF0000) + ~0x000181B3;
	word32 * edx_26 = fp - 229 + dwLoc20;
	*edx_26 = ecx_20[dwLoc20].dw0000 - 0x28;
	<anonymous> ** eax_46 = 0x004010DD - dwLoc20;
	ptr32 esp_48;
	word32 ebp_49;
	byte SCZO_50;
	word32 eax_51;
	word32 ecx_52;
	word32 edx_53;
	byte SZO_54;
	bool C_55;
	word32 ebx_56;
	word32 esi_57;
	byte dl_58;
	bool Z_59;
	(*eax_46)();
	ui32 eax_31 = (eax_17 & 0xFFFF0000) + *(&(ecx_20 + (dwLoc20 << 0x09) / 0x0200)->dw0000 - 0x04) + 0xF9 - dwLoc20;
	*(esp_48 - 0x04) = dwLoc20;
	*(esp_48 - 0x08) = dwLoc14;
	*(esp_48 - 0x0C) = eax_31;
	fn00401200(dwArg00, dwArg04, dwArg08);
	struct Eq_87 * ebx_78 = *(eax_31 + 0x010D - dwLoc20) + eax_31;
	byte dl_80 = ebx_78->b0006;
	*(esp_48 - 0x04) = (dwLoc20 << 0x05) + ~0x19DF;
	*(esp_48 - 0x08) = 0x3000;
	*(esp_48 - 0x0C) = *(&ebx_78->dw0034 + 0x034B - ((dwLoc20 << 0x05) >> 0x01));
	*(esp_48 - 0x10) = ebx_78->dw0034;
	Eq_136 eax_100 = VirtualAlloc(*(esp_48 - 0x10), *(esp_48 - 0x0C), *(esp_48 - 0x08), *(esp_48 - 0x04));
	*(esp_48 - 0x04) = (union Eq_136 *) eax_100;
	*(esp_48 - 0x08) = eax_31;
	*(esp_48 - 0x0C) = *((char *) &ebx_78->dw0034 + 0x00F1 - dwLoc20);
	fn00401250(dwArg00, dwArg04, dwArg08);
	word32 dwLoc1C_117 = (word32) dl_80;
	struct Eq_192 * esi_116 = &ebx_78->dw0034 + 0x0031;
	do
	{
		*(esp_48 - 0x04) = (word32) eax_100 + esi_116->t000C;
		*(esp_48 - 0x08) = eax_31 + esi_116->dw0014;
		*(esp_48 - 0x0C) = esi_116->dw0010;
		fn00401250(dwArg00, dwArg04, dwArg08);
		word32 v23_137 = dwLoc1C_117 - 0x01;
		esi_116 = esi_116 + 0x01;
		dwLoc1C_117 = v23_137;
	} while (v23_137 != 0x00);
	Mem147[fp + 0xD1 - dwLoc20 + 0x00:word32] = Mem132[ebx_78 - 0xA9 + dwLoc20:word32] + eax_100;
	*(esp_48 - 0x04) = fp - 0x0129 + dwLoc20;
	*(esp_48 - 0x08) = 1427582266 - dwLoc20 - 1423383235;
	*(esp_48 - 0x0C) = dwLoc20 + ~0x98;
	ptr32 esp_167;
	word32 ebp_168;
	byte SCZO_169;
	word32 eax_170;
	word32 ecx_171;
	word32 edx_172;
	byte SZO_173;
	bool C_174;
	word32 ebx_175;
	word32 esi_176;
	byte dl_177;
	bool Z_178;
	fn003FDE10();
	*(esp_167 - 0x04) = dwLoc20;
	*(esp_167 - 0x08) = 0x38;
	*(esp_167 - 0x0C) = fp - 88;
	fn00401200(dwArg00, dwArg04, dwArg08);
	Eq_136 eax_193 = eax_100;
	do
		eax_193 = eax_193 + 0x01;
	while (*eax_193 != dwLoc20 + 0xAABBCC0C);
	*(esp_167 - 0x04) = (union Eq_136 *) eax_193;
	*(esp_167 - 0x08) = fp - 0x0129 + dwLoc20;
	*(esp_167 - 0x0C) = 0x0109 - dwLoc20;
	return fn00401250(dwArg00, dwArg04, dwArg08);
}

// 00401200: void fn00401200(Stack (ptr32 ui32) dwArg04, Stack (ptr32 byte) dwArg08, Stack (ptr32 byte) dwArg0C)
void fn00401200(ui32 * dwArg04, byte * dwArg08, byte * dwArg0C)
{
	ui32 * ebx_26 = dwArg04;
	byte * ecx_10 = dwArg08;
	word32 eax_16 = dwArg0C + 0x37FA334C;
	word32 dwLoc08_22 = 0x01;
	while (true)
	{
		*ebx_26 = *ebx_26 ^ eax_16;
		ecx_10 = ecx_10 - 0x04;
		if (ecx_10 <= null)
			break;
		eax_16 = eax_16 + 0x0BA9F4A6 + dwLoc08_22;
		ebx_26 = (char *) ebx_26 + 0x00D5 - dwArg0C;
		dwLoc08_22 = -*(fp - 0x08);
	}
}

// 00401250: Register word32 fn00401250(Stack (ptr32 ui32) dwArg04, Stack (ptr32 byte) dwArg08, Stack (ptr32 byte) dwArg0C)
word32 fn00401250(ui32 * dwArg04, byte * dwArg08, byte * dwArg0C)
{
	byte * edi_13 = dwArg0C;
	byte * esi_15 = dwArg08;
	ui32 * ecx_17 = dwArg04;
	do
	{
		byte al_24 = *esi_15;
		*edi_13 = al_24;
		eax = DPB(eax, al_24, 0);
		esi_15 = esi_15 + 0x01;
		edi_13 = edi_13 + 0x01;
		ecx_17 = ecx_17 - 0x01;
	} while (ecx_17 != null);
	return eax;
}

// 00401270: void fn00401270()
void fn00401270()
{
	struct Eq_380 * esp_7;
	uint32 eax_8;
	byte SZO_9;
	word32 edx_10;
	byte SCZO_11;
	bool C_12;
	word32 ecx_13;
	((<anonymous> **) 0x7FFE0300)();
	*esp_7->ptr0004 = (eax_8 & 0x0F) + ((eax_8 >> 0x18) + 0x10) - 0x01;
}

