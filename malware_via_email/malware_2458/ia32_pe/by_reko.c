// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401010: void fn00401010(Register (arr Eq_6630) ebx, Stack uint32 dwArg04)
void fn00401010(Eq_6630 ebx[], uint32 dwArg04)
{
	uint32 eax_21 = (uint32) (0x40 /u dwArg04);
	Eq_8 ebp_138 = 0x00;
	uint32 edi_136 = eax_21;
	if (!DPB(CZ, false, 0))
	{
		uint32 edx_95 = (uint32) ((uint64) (uint32) ebx % 0x0F);
		Eq_20 bLoc2D_106 = 0x00;
		uint32 edx_111 = (uint32) ((uint64) (uint32) ebx % 0x41);
		do
		{
			Eq_8 dwLoc2C_142 = ebp_138;
			Eq_8 dwLoc24_143 = ebp_138;
			if (edx_95 > 0x14)
			{
				Eq_37 eax_452 = GetDC(0x00);
				TextOutA(eax_452, 0x0A, 0x0A, 0x004030E8, 0x20);
				if (eax_452 != null && MoveToEx(eax_452, 0x0A, 0x0A, null) == 0x00)
					Polyline(eax_452, (POINT *) 0x00324345, 0x14);
				else
					LineTo(eax_452 + 0x0A, 0x96, 200);
				ReleaseDC(0x00, eax_452);
			}
			else
				dwLoc2C_142 = (word32) ebp_138.u0 + ((word32) (bLoc2D_106 != 0x00) * 0x08 + 0x0F);
			if (edx_111 > 0x56)
			{
				Eq_40 eax_330 = GetForegroundWindow();
				if (eax_330 != 0x00)
				{
					Eq_37 eax_339 = GetDC(eax_330);
					if (eax_339 != null)
					{
						Eq_113 eax_369 = CreatePen(0x02, 0x03, 0x00101010);
						if (eax_369 != 0x00)
							SelectObject(eax_339, eax_369);
						else
						{
							Eq_37 eax_401 = CreateCompatibleDC(eax_339);
							SelectObject(eax_401, 0x00);
							BitBlt(eax_339, 0x00, 0x00, 0x32, 0x32, eax_401, 0x00, 0x00, 0x00CC0020);
							DeleteDC(eax_401);
						}
						ReleaseDC(eax_330, eax_339);
					}
					edi_136 = eax_21;
				}
			}
			else if (dwLoc2C_142 > edi_136 - 0x01)
				dwLoc2C_142 = (uint32) ((uint64) (uint32) dwLoc2C_142 % edi_136);
			if ((ebx & 0x07) > 0x0A)
				SetEvent(CreateEventA(null, 0x01, 0x01, 0x004030F0));
			else
				bLoc2D_106 = bLoc2D_106 == 0x00;
			byte cl_223;
			if (edx_111 > 0x50)
			{
				Eq_40 eax_264 = FindWindowA(0x00, 0x004030FC);
				if (eax_264 != 0x00 && GetWindowRect(eax_264, fp - 0x10) != 0x00)
					SetWindowPos(eax_264, 0x00, dwLoc10, dwLoc0C, dwLoc08 + 0x32, dwLoc04, 0x04);
				goto l004011FF;
			}
			if (dwArg04 == 0x01)
			{
				cl_223 = (byte) (word32) Mem0[ebx + ebp_138:byte];
				goto l0040120A;
			}
			dwLoc24_143 = ebx[ebp_138];
l004011FF:
			if (dwArg04 == 0x01)
			{
				cl_223 = bLoc24;
l0040120A:
				word32 eax_230 = dwLoc2C_142 + ebx;
				Mem234[ebx + ebp_138:byte] = Mem0[eax_230 + 0x00:byte];
				*eax_230 = cl_223;
			}
			else
			{
				union Eq_8 * eax_255 = ebx + dwLoc2C_142;
				ebx[ebp_138] = *eax_255;
				*eax_255 = (union Eq_8 *) dwLoc24_143;
			}
			ui32 ebp_210 = (word32) ebp_138.u0 + 0x01;
			ebp_138 = ebp_210 + 0x01;
		} while (ebp_210 + 0x01 < edi_136);
	}
}

// 00401241: void fn00401241(Stack (ptr32 Eq_270) dwArg04, Stack Eq_40 dwArg08, Stack uint32 dwArg0C)
void fn00401241(Eq_270 * dwArg04, Eq_40 dwArg08, uint32 dwArg0C)
{
	Eq_40 esi_23 = 0x00;
	if (dwArg08 > 0x00)
	{
		do
		{
			fn00401010(esi_23 + dwArg04, dwArg0C);
			esi_23 = (word32) esi_23 + 0x0040;
		} while (esi_23 < dwArg08);
	}
}

// 00401268: void fn00401268(Register (ptr32 Eq_270) ebx, Stack Eq_40 dwArg04, Stack Eq_40 dwArg08)
void fn00401268(Eq_270 * ebx, Eq_40 dwArg04, Eq_40 dwArg08)
{
	fn00401241(ebx, dwArg04, 0x01);
	fn00401241(ebx, dwArg04, 0x04);
	word32 esi_34 = Mem0[ebx + 0x3C:word32] + ebx;
	fn00401A5A(dwArg08, ebx, esi_34->t0054);
	int32 dwArg04_43 = dwArg04 & 0x00;
	word32 eax_46 = esi_34 + ((word32) esi_34->w0014 + 0x18) / 88;
	if (0x00 < esi_34->w0006)
	{
		struct Eq_324 * edi_62 = eax_46 + 0x14;
		do
		{
			fn00401A5A((word32) dwArg08 + *(edi_62 - 0x08), ebx + edi_62->dw0000, *(edi_62 - 0x04));
			int32 v18_76 = dwArg04_43 + 0x01;
			edi_62 = edi_62 + 0x01;
			dwArg04_43 = v18_76;
		} while (v18_76 < (word32) esi_34->w0006);
	}
}

// 004012D3: Register word32 fn004012D3(Register (ptr32 Eq_355) edi)
word32 fn004012D3(Eq_355 * edi)
{
	struct Eq_356 * ecx_10 = edi + edi->dw003C / 0x0040;
	ptr32 edx_13 = edi - ecx_10->dw0034;
	struct Eq_355 * eax_109 = edi + ecx_10->dw00A0 / 0x0040;
	if (eax_109 == edi)
		return 0x00;
	ui32 dwLoc0C_106 = dwLoc0C & 0x00;
	word32 esi_110 = eax_109->dw0004;
	if (esi_110 != 0x00)
	{
		do
		{
			uint32 edx_92 = esi_110 - 0x08;
			if (edx_92 >> 0x01 > 0x00)
			{
				word16 * dwLoc08_117 = &eax_109->dw0004 + 0x01;
				uint32 dwLoc10_118 = edx_92 >> 0x01;
				do
				{
					ui32 edx_123 = (word32) *dwLoc08_117;
					if ((word16) (edx_123 & 0xF000) == 0x3000)
					{
						word32 * edx_145 = edi + (eax_109->dw0000 + (edx_123 & 0x0FFF)) / 0x0040;
						*edx_145 = *edx_145 + edx_13;
					}
					uint32 v20_138 = dwLoc10_118 - 0x01;
					dwLoc08_117 = dwLoc08_117 + 0x01;
					dwLoc10_118 = v20_138;
				} while (v20_138 != 0x00);
			}
			ui32 v18_105 = dwLoc0C_106 + esi_110;
			eax_109 = edi + (ecx_10->dw00A0 + v18_105) / 0x0040;
			dwLoc0C_106 = v18_105;
			esi_110 = eax_109->dw0004;
		} while (esi_110 != 0x00);
	}
	return 0x01;
}

// 00401367: Register (ptr32 Eq_440) fn00401367(Register (ptr32 Eq_440) eax)
Eq_440 * fn00401367(Eq_440 * eax)
{
	if (eax->b0000 == 0x01)
	{
		eax = &eax->b0001;
		byte * ecx_20 = &eax->b0001;
		if (eax->b0001 != 0x00)
		{
			do
			{
				byte dl_29;
				byte dl_23 = *ecx_20;
				if (dl_23 != 0x00)
					dl_29 = dl_23 + 0x1E;
				else
					dl_29 = 0x00;
				*ecx_20 = dl_29;
				ecx_20 = ecx_20 + 0x01;
			} while (*ecx_20 != 0x00);
		}
	}
	return eax;
}

// 0040138A: void fn0040138A()
void fn0040138A()
{
}

// 00401390: Register Eq_40 fn00401390(Register (ptr32 Eq_475) ebp, Stack Eq_40 dwArg04, Stack Eq_40 dwArg08, Stack Eq_40 dwArg0C)
Eq_40 fn00401390(Eq_475 * ebp, Eq_40 dwArg04, Eq_40 dwArg08, Eq_40 dwArg0C)
{
	Eq_40 eax_133;
	if (dwArg04 != 0x00)
	{
		word32 eax_98 = Mem0[dwArg04 + 0x3C:word32] + dwArg04;
		if (eax_98 != null)
		{
			Eq_40 eax_103 = (word32) dwArg04 + eax_98->dw0078;
			if (eax_103 != dwArg04)
			{
				uint32 ecx_113 = *((word32) eax_103 + 0x0014);
				uint32 edx_109 = *((word32) eax_103 + 0x0018);
				word16 ecx_111[] = Mem0[eax_103 + 0x24:word32] + dwArg04;
				word32 edi_114[] = Mem0[eax_103 + 0x1C:word32] + dwArg04;
				word32 ebx_115[] = Mem0[eax_103 + 0x20:word32] + dwArg04;
				uint32 dwLoc08_118 = ecx_113;
				if (ecx_113 <= edx_109)
					dwLoc08_118 = edx_109;
				if (dwArg08 < 0x00)
				{
					uint32 edx_128 = (dwArg08 & 0x7FFFFFFF) - *((word32) eax_103 + 0x0010);
					if (edx_128 < ecx_113)
					{
						eax_133 = (word32) dwArg04 + edi_114[edx_128];
						return eax_133;
					}
				}
				else
				{
					uint32 eax_135 = 0x00;
					uint32 dwArg04_136 = 0x00;
					if (dwLoc08_118 > 0x00)
					{
						while (true)
						{
							uint32 ecx_146 = (word32) ecx_111[eax_135];
							if (eax_135 >= edx_109 || ecx_146 >= ecx_113)
								break;
							if (fn0040159A(dwArg08, (word32) dwArg04 + ebx_115[dwArg04_136]) != 0x00)
							{
								up32 * ebx_171 = edi_114 + ecx_146;
								up32 ecx_173 = *ebx_171;
								up32 eax_174 = eax_98->dw0078;
								if (ecx_173 >= eax_174)
								{
									up32 edx_183 = eax_98->dw007C + eax_174;
									if (ecx_173 < edx_183)
									{
										byte * eax_186 = (word32) dwArg04 + ecx_173;
										do
										{
											byte dl_189 = *eax_186;
											eax_186 = eax_186 + 0x01;
										} while (dl_189 != 0x2E);
										ptr32 esp_207;
										word32 ebp_208;
										byte SCZO_209;
										ui32 * ebx_210;
										ui32 esi_211;
										<anonymous> ** edi_212;
										byte SZO_213;
										bool C_214;
										bool Z_215;
										Eq_40 eax_216;
										word32 ecx_217;
										word32 edx_218;
										byte CZ_219;
										bool S_220;
										byte dl_221;
										(*((word32) dwArg0C + 0x08))();
										if (eax_216 == 0x00)
											break;
										ui32 eax_226 = *ebx_210;
										*(esp_207 - 0x04) = eax_186 - eax_226 - esi_211 - 0x01;
										struct Eq_270 * ecx_235 = eax_226 + esi_211;
										fn00401A5A(eax_216, ecx_235, dwArg00);
										*(esp_207 - 0x04) = (<anonymous> ***) edi_212;
										*(esp_207 - 0x08) = (byte **) eax_186;
										*(esp_207 - 0x0C) = (union Eq_40 *) eax_216;
										struct Eq_646 * esp_251;
										struct Eq_475 * ebp_252;
										byte SCZO_253;
										word32 ebx_254;
										word32 esi_255;
										struct Eq_651 * edi_256;
										byte SZO_257;
										bool C_258;
										bool Z_259;
										word32 eax_260;
										word32 ecx_261;
										word32 edx_262;
										byte CZ_263;
										bool S_264;
										byte dl_265;
										(*edi_212)();
										*(esp_251 - 0x04) = eax_260;
										Eq_40 eax_268 = fn00401390(ebp_252, dwArg00, eax_216, eax_186 & 0x00);
										esp_251->dw0004 = ebx_254;
										esp_251->t0000 = eax_268;
										Eq_40 dwArg08_277 = esp_251->t0000;
										esp_251->dw0004 = 0x8000;
										esp_251->t0000.u0 = 0x00;
										*(esp_251 - 0x04) = (union Eq_40 *) eax_216;
										word32 esp_288;
										word32 ebp_289;
										byte SCZO_290;
										word32 ebx_291;
										word32 esi_292;
										word32 edi_293;
										byte SZO_294;
										bool C_295;
										bool Z_296;
										word32 eax_297;
										word32 ecx_298;
										word32 edx_299;
										byte CZ_300;
										bool S_301;
										byte dl_302;
										edi_256->ptr000C();
										eax_133 = dwArg08_277;
										return eax_133;
									}
								}
								eax_133 = (word32) dwArg04 + ecx_173;
								return eax_133;
							}
							uint32 v16_162 = dwArg04_136 + 0x01;
							dwArg04_136 = v16_162;
							if (v16_162 >= dwLoc08_118)
								break;
							eax_135 = v16_162;
						}
					}
				}
			}
		}
	}
	eax_133.u0 = 0x00;
	return eax_133;
}

// 004014E5: Register word32 fn004014E5(Register (ptr32 Eq_475) ebp, Stack Eq_40 dwArg04, Stack Eq_40 dwArg08)
word32 fn004014E5(Eq_475 * ebp, Eq_40 dwArg04, Eq_40 dwArg08)
{
	word32 eax_103;
	struct Eq_721 * eax_11 = (word32) dwArg04 + ((word32) (*((word32) dwArg04 + 0x003C)) + 0x0078);
	Eq_40 edx_108 = dwArg04;
	Eq_40 esi_115 = (word32) dwArg04 + eax_11->dw0000;
	if (esi_115 != dwArg04)
	{
		uint32 eax_53 = *((word32) esi_115 + 0x0014);
		uint32 ecx_54 = *((word32) esi_115 + 0x0018);
		ptr32 esp_117 = fp - 0x20;
		word32 edi_111 = Mem0[esi_115 + 0x1C:word32] + dwArg04;
		word16 ebx_112[] = Mem0[esi_115 + 0x24:word32] + dwArg04;
		uint32 dwLoc0C_217 = eax_53;
		if (eax_53 <= ecx_54)
			dwLoc0C_217 = ecx_54;
		uint32 eax_113 = 0x00;
		uint32 dwLoc08_110 = 0x00;
		if (dwLoc0C_217 > 0x00)
		{
			while (true)
			{
				if (eax_113 < *((word32) esi_115 + 0x0014))
					eax_113 = (word32) ebx_112[eax_113];
				union Eq_40 * ecx_121 = edi_111 + eax_113 * 0x04;
				word32 eax_123 = Mem0[ecx_121 + 0x00:word32] + edx_108;
				if (eax_123 != edx_108)
				{
					if (eax_123 > esi_115)
					{
						if (eax_123 <u Mem0[eax_11 + 0x04:word32] *s 0x28 + esi_115)
						{
							Eq_40 ecx_181 = eax_123;
							do
								ecx_181 = (word32) ecx_181 + 0x01;
							while (*ecx_181 != 0x2E);
							*ecx_181 = 0x00;
							union Eq_40 * esp_189 = esp_117 - 0x04;
							*esp_189 = (union Eq_40 *) dwArg08;
							*(esp_189 - 0x04) = (word32) ecx_181 + 0x01;
							*(esp_189 - 0x08) = (union Eq_40 *) eax_123;
							ptr32 esp_197;
							struct Eq_475 * ebp_198;
							byte SCZO_199;
							word32 edx_200;
							word32 eax_201;
							bool Z_203;
							byte SZO_204;
							bool C_205;
							word32 ecx_206;
							byte CZ_209;
							(*dwArg08)();
							*(esp_197 - 0x04) = eax_201;
							eax_123 = fn00401390(ebp_198, dwArg00, dwArg04, dwArg08);
							esp_117 = esp_197 + 0x08;
						}
						edx_108 = dwArg04;
					}
					if (eax_123 == 0x00)
					{
						eax_103 = 0x00;
						return eax_103;
					}
					*ecx_121 = (union Eq_40 *) eax_123;
				}
				uint32 v15_137 = dwLoc08_110 + 0x01;
				dwLoc08_110 = v15_137;
				if (v15_137 >= dwLoc0C_217)
					break;
				eax_113 = v15_137;
			}
		}
		eax_103 = 0x01;
		return eax_103;
	}
	else
	{
		eax_103 = 0x01;
		return eax_103;
	}
}

// 0040159A: Register Eq_40 fn0040159A(Register Eq_40 eax, Register ui32 ecx)
Eq_40 fn0040159A(Eq_40 eax, ui32 ecx)
{
	Eq_856 bl_9 = *eax == 0x01;
	if (bl_9 != 0x00)
		eax = (word32) eax + 0x01;
	Eq_40 eax_33;
	if (*eax != 0x02)
	{
		int32 esi_53 = ecx - eax;
		do
		{
			bool Z_68;
			byte cl_65;
			if (bl_9 != 0x00)
			{
				byte cl_81 = *eax;
				int32 edx_82 = (int32) cl_81;
				if (cl_81 != 0x00)
					edx_82 = edx_82 + 0x1E;
				cl_65 = (byte) *((word32) eax + esi_53);
				Z_68 = (bool) cond((int32) cl_65 - edx_82);
			}
			else
			{
				cl_65 = (byte) *((word32) eax + esi_53);
				Z_68 = (bool) cond(cl_65 - *eax);
			}
			if (Z_68)
			{
				eax_33.u0 = 0x00;
				return eax_33;
			}
			if (cl_65 == 0x00)
				break;
			eax = (word32) eax + 0x01;
		} while (*eax != 0x02);
	}
	eax_33.u0 = 0x01;
	return eax_33;
}

// 004015E7: Register word32 fn004015E7(Register (ptr32 Eq_475) ebp, Register (ptr32 Eq_915) esi, Stack Eq_40 dwArg04)
word32 fn004015E7(Eq_475 * ebp, Eq_915 * esi, Eq_40 dwArg04)
{
	word32 eax_22;
	word32 eax_6 = Mem0[Mem0[esi + 0x3C:word32] + 0x80 + esi:word32] + esi;
	if (eax_6 == esi)
		eax_22 = 0x01;
	else
	{
		if (eax_6->dw0000 != 0x00)
		{
			struct Eq_915 * ebx_71 = eax_6;
			do
			{
				if (fn0040166B(esi + ebx_71->dw0010 / 0x0040, &ebx_71->dw0010 + 0x01, ebp, dwArg04, esi + ebx_71->dw000C / 0x0040, esi + ebx_71->dw0000 / 0x0040, esi, out ebx_71) == 0x00)
				{
					eax_22 = 0x00;
					goto l00401630;
				}
			} while (ebx_71->dw0000 != 0x00);
		}
		eax_22 = 0x01;
l00401630:
	}
	return eax_22;
}

// 00401639: void fn00401639(Register (ptr32 Eq_970) eax)
void fn00401639(Eq_970 * eax)
{
	word32 esp_12;
	struct Eq_972 * eax_13;
	eax->ptr0008();
	eax_13->b0008 = 0x02;
	eax_13->b0001 = 111;
	eax_13->b0003 = 0x62;
	eax_13->b0006 = 101;
	eax_13->b0002 = 0x6D;
	eax_13->b0005 = 110;
	eax_13->b0000 = 0x43;
	eax_13->b0007 = 0x52;
	eax_13->b0004 = 0x69;
}

// 0040166B: Register Eq_40 fn0040166B(Register Eq_40 eax, Register ptr32 ebx, Register (ptr32 Eq_475) ebp, Register Eq_40 edi, Stack word32 dwArg04, Stack Eq_40 dwArg08, Stack (ptr32 Eq_915) dwArg0C, Register out (ptr32 word32) ebxOut)
Eq_40 fn0040166B(Eq_40 eax, ptr32 ebx, Eq_475 * ebp, Eq_40 edi, word32 dwArg04, Eq_40 dwArg08, Eq_915 * dwArg0C, word32 * & ebxOut)
{
	ptr32 esp_17;
	struct Eq_475 * ebp_18;
	word32 edi_21;
	byte SZO_22;
	bool C_23;
	bool Z_24;
	word32 ebx_25;
	byte SCZO_26;
	word32 ecx_27;
	bool S_28;
	word32 * esi_19;
	Eq_40 eax_115;
	(*((word32) edi + 0x0010))();
	if (eax_115 != 0x00)
	{
		*(esp_17 - 0x04) = ebx_25;
		word32 ebx_51 = dwArg08 - esi_19;
		while (true)
		{
			int32 * ecx_57 = esi_19 + ebx_51;
			int32 eax_102 = 0x00;
			if (ecx_57 != null)
				eax_102 = *ecx_57;
			if (esi_19 == null || *esi_19 == 0x00)
				break;
			if (ecx_57 != null)
			{
				*(esp_17 - 0x08) = edi_21;
				if (eax_102 >= 0x00)
					eax_102 = dwArg0C + (eax_102 + 0x02) / 0x0040;
				*(esp_17 - 0x0C) = eax_102;
				*(esp_17 - 0x10) = (union Eq_40 *) eax_115;
				Eq_40 eax_109 = fn00401390(ebp_18, dwArg00, eax_115, dwArg08);
				if (eax_109 == 0x00)
				{
					eax_115.u0 = 0x00;
					goto l004016C3;
				}
				*esi_19 = (word32) eax_109;
			}
			esi_19 = esi_19 + 0x01;
		}
		eax_115.u0 = 0x01;
l004016C3:
		word32 ebx_74;
		*ebxOut = *(esp_17 - 0x04);
	}
	return eax_115;
}

// 004016C9: void fn004016C9(Register (ptr32 Eq_1093) eax)
void fn004016C9(Eq_1093 * eax)
{
	word32 esp_12;
	struct Eq_1095 * eax_13;
	eax->ptr0008();
	eax_13->b0000 = 0x43;
	eax_13->b0007 = 0x02;
	eax_13->b0002 = 101;
	eax_13->b0005 = 101;
	eax_13->b0003 = 0x61;
	eax_13->b0001 = 114;
	eax_13->b0006 = 0x52;
	eax_13->b0004 = 116;
}

// 004016F7: Register (ptr32 Eq_915) fn004016F7(Register (ptr32 Eq_915) eax, Stack Eq_40 dwArg04)
Eq_915 * fn004016F7(Eq_915 * eax, Eq_40 dwArg04)
{
	word32 esi_13 = Mem0[Mem0[eax + 0x3C:word32] + 0x88 + eax:word32] + eax;
	if (esi_13 != eax)
	{
		ptr32 eax_39 = eax - dwArg04;
		if (eax_39 != 0x00)
		{
			up32 ebx_47 = 0x00;
			if (0x00 < esi_13->w000E)
			{
				struct Eq_1155 * edi_62 = &esi_13->dw0010 + 0x01;
				do
				{
					fn00401A35(esi_13 + ((edi_62->dw0000 & 0x7FFFFFFF) + 0x10) / 0x0040, esi_13, eax_39);
					edi_62 = edi_62 + 0x01;
					ebx_47 = ebx_47 + 0x01;
				} while (ebx_47 < (word32) esi_13->w000E);
			}
		}
	}
	return (struct Eq_915 *) 0x01;
}

// 0040174B: void fn0040174B(Register (ptr32 Eq_1181) eax)
void fn0040174B(Eq_1181 * eax)
{
	eax->b0000 = 0x47;
	eax->b0001 = 101;
	eax->b0005 = 0x67;
	eax->b0006 = 0x02;
	eax->b0002 = 116;
	eax->b0004 = 101;
	eax->b0003 = 0x52;
}

// 00401767: void fn00401767(Register (ptr32 Eq_1210) eax)
void fn00401767(Eq_1210 * eax)
{
	word32 esp_12;
	struct Eq_1212 * eax_13;
	eax->ptr0008();
	eax_13->b0007 = 0x6C;
	eax_13->b0006 = 100;
	eax_13->b0003 = 0x33;
	eax_13->b0008 = 0x6C;
	eax_13->b0000 = 0x67;
	eax_13->b0001 = 100;
	eax_13->b0004 = 0x32;
	eax_13->b0005 = 0x2E;
	eax_13->b0002 = 0x69;
}

// 00401799: Register word32 fn00401799(Register (ptr32 Eq_1253) edx, Register (ptr32 Eq_475) ebp, Register ptr32 esi)
word32 fn00401799(Eq_1253 * edx, Eq_475 * ebp, ptr32 esi)
{
	word32 eax_10 = Mem0[Mem0[edx + 0x3C:word32] + 0x80 + edx:word32] + edx;
	if (eax_10 == edx)
		return 0x00;
	ui32 edi_157 = 0x00;
	struct Eq_1253 * ecx_146 = eax_10;
	do
	{
		word32 eax_106;
		if (ecx_234->dw0000 == 0x00)
			goto l00401800;
		ecx_146 = &ecx_234->dw0010 + 0x01;
		struct Eq_1253 * ecx_234 = ecx_146;
	} while (edx[ecx_234->dw000C / 0x0040] != 0x4B);
	word32 eax_151[] = edx + ecx_234->dw0010 / 0x0040;
	int32 ecx_152[] = edx + ecx_234->dw0000 / 0x0040;
	if (eax_151[0x00] != 0x00)
	{
		do
		{
			int32 ebx_158 = ecx_152[edi_157];
			if (ebx_158 >= 0x00)
			{
				struct Eq_1315 * ebx_168 = edx + ebx_158 / 0x0040;
				if (ebx_168->b0002 == 0x47 && (ebx_168->b0003 == 101 && (ebx_168->b0005 == 77 && ebx_168->b000B == 0x48)))
				{
					<anonymous> * eax_178 = eax_151[edi_157];
					ptr32 esp_199;
					word32 ebp_200;
					struct Eq_1343 * eax_201;
					word32 edx_202;
					byte SCZO_203;
					bool Z_204;
					byte SZO_205;
					bool C_206;
					word32 edi_207;
					word32 ecx_208;
					word32 ebx_209;
					bool S_210;
					byte bl_211;
					struct Eq_1354 * esi_212;
					eax_178();
					*(esp_199 - 0x04) = (struct Eq_1354 **) esi_212;
					fn00401892(eax_201, dwArg00);
					if (esi_212->dw0000 == ebx_209 || (esi_212->dw0010 == ebx_209 || (esi_212->dw0008 == ebx_209 || (esi_212->dw000C == ebx_209 || (esi_212->dw0004 == ebx_209 || esi_212->dw0014 == ebx_209)))))
						break;
					eax_106 = 0x01;
					return eax_106;
				}
			}
			edi_157 = edi_157 + 0x01;
		} while (eax_151[edi_157] != 0x00);
	}
l00401800:
	eax_106 = 0x00;
	return eax_106;
}

// 0040186E: void fn0040186E(Register (ptr32 Eq_1391) eax)
void fn0040186E(Eq_1391 * eax)
{
	eax->b0003 = 0x61;
	eax->b0005 = 101;
	eax->b0000 = 0x43;
	eax->b0001 = 114;
	eax->b0004 = 116;
	eax->b0006 = 0x52;
	eax->b0007 = 111;
	eax->b0008 = 0x02;
	eax->b0002 = 101;
}

// 00401892: void fn00401892(Register (ptr32 Eq_1343) edi, Stack (ptr32 Eq_1363) dwArg04)
void fn00401892(Eq_1343 * edi, Eq_1363 * dwArg04)
{
	word32 ecx_11 = Mem0[Mem0[edi + 0x3C:word32] + 0x78 + edi:word32] + edi;
	uint32 eax_25 = ecx_11->dw0014;
	uint32 edx_13 = ecx_11->dw0018;
	word16 eax_19[] = edi + ecx_11->dw0024 / 0x0040;
	word32 esi_26[] = edi + ecx_11->dw001C / 0x0040;
	word32 ebx_27[] = edi + ecx_11->dw0020 / 0x0040;
	uint32 dwLoc10_203 = eax_25;
	if (eax_25 <= edx_13)
		dwLoc10_203 = edx_13;
	uint32 eax_100 = 0x00;
	up32 dwLoc08_108 = 0x00;
	uint32 dwLoc0C_37 = 0x00;
	if (dwLoc10_203 > 0x00)
	{
		while (dwLoc08_108 < 0x06)
		{
			uint32 edx_72 = (word32) eax_19[eax_100];
			if (eax_100 >= ecx_11->dw0018 || edx_72 >= ecx_11->dw0014)
				return;
			struct Eq_1485 * eax_80 = edi + ebx_27[eax_100] / 0x0040;
			byte bl_81 = eax_80->b0000;
			word32 esi_83 = edi + esi_26[edx_72] / 0x0040;
			if (bl_81 == 0x47)
			{
				byte dl_173 = eax_80->b0001;
				if (dl_173 != 101)
					goto l00401979;
				if (eax_80->b0002 == 116 && (eax_80->b0003 == 77 && eax_80->b000F == 0x41))
				{
					dwArg04->dw0000 = esi_83;
					goto l00401A1D;
				}
				if (dl_173 != 101 || (eax_80->b0002 != 116 || (eax_80->b0003 != 0x54 || (eax_80->b0004 != 0x69 || (eax_80->b0005 != 99 || (eax_80->b0007 != 0x43 || (eax_80->b000B != 116 || eax_80->b000C != 0x00)))))))
					goto l00401979;
				dwArg04->dw0014 = esi_83;
				goto l00401A1D;
			}
l00401979:
			if (bl_81 == 0x56)
			{
				byte dl_132 = eax_80->b0001;
				if (dl_132 != 0x69)
					goto l004019F4;
				if (eax_80->b0002 == 114 && (eax_80->b0007 == 0x41 && (eax_80->b0008 == eax_80->b0009 && eax_80->b000C == 0x00)))
				{
					dwArg04->dw0008 = esi_83;
					goto l00401A1D;
				}
				if (dl_132 != 0x69)
					goto l004019F4;
				if (eax_80->b0002 == 114 && (eax_80->b0007 == 0x50 && (eax_80->b0008 == 114 && eax_80->b000E == 0x00)))
				{
					dwArg04->dw0004 = esi_83;
					goto l00401A1D;
				}
				if (dl_132 != 0x69 || (eax_80->b0002 != 114 || (eax_80->b0007 != 0x46 || (eax_80->b0009 != eax_80->b000A || eax_80->b000B != 0x00))))
					goto l004019F4;
				dwArg04->dw000C = esi_83;
				goto l00401A1D;
			}
l004019F4:
			if (eax_80->b0000 == 0x4C && (eax_80->b0001 == 111 && (eax_80->b0002 == 0x61 && (eax_80->b0003 == 100 && (eax_80->b0004 == 0x4C && eax_80->b000B == 0x41)))))
			{
				dwArg04->dw0010 = esi_83;
l00401A1D:
				dwLoc08_108 = dwLoc08_108 + 0x01;
			}
			uint32 v18_92 = dwLoc0C_37 + 0x01;
			dwLoc0C_37 = v18_92;
			if (v18_92 >= dwLoc10_203)
				return;
			eax_100 = v18_92;
		}
	}
}

// 00401A35: void fn00401A35(Register (ptr32 Eq_1160) eax, Register (ptr32 Eq_915) esi, Stack ptr32 dwArg04)
void fn00401A35(Eq_1160 * eax, Eq_915 * esi, ptr32 dwArg04)
{
	while (true)
	{
		ui32 ecx_6 = eax->dw0004;
		if ((ecx_6 & 0x80000000) == 0x00)
			break;
		eax = (struct Eq_1160 *) (esi + ((ecx_6 & 0x7FFFFFFF) + 0x10) / 0x0040);
	}
	word32 * eax_14 = esi + ecx_6 / 0x0040;
	*eax_14 = *eax_14 + dwArg04;
}

// 00401A5A: void fn00401A5A(Register Eq_40 eax, Register (ptr32 Eq_270) ecx, Stack Eq_40 dwArg04)
void fn00401A5A(Eq_40 eax, Eq_270 * ecx, Eq_40 dwArg04)
{
	while (dwArg04 != 0x00)
	{
		*eax = ecx->b0000;
		dwArg04 = dwArg04 - 0x01;
		eax = (word32) eax + 0x01;
		ecx = ecx + 0x01;
	}
}

// 00401A70: Register Eq_40 Win32CrtStartup()
Eq_40 Win32CrtStartup()
{
	struct Eq_475 * ebp_10 = fn0040267C(ebx, esi, edi, dwLoc0C, 4207048, 0x010C);
	if ((uint32) ((uint64) (uint32) ebp_10->dw0010 % 0x23) > 0x46)
	{
		TlsGetValue(0x00);
		TlsSetValue(0x00, 0x6546);
		*(ebp_10 - 0x04) = 0x00;
		byte * ecx_2327 = globals->a403108;
		byte * edx_2328 = (byte *) 0x00100654;
		do
		{
			byte al_2332 = *ecx_2327;
			*edx_2328 = al_2332;
			ecx_2327 = ecx_2327 + 0x01;
			edx_2328 = edx_2328 + 0x01;
		} while (al_2332 != 0x00);
		globals->dw4050D8 = globals->dw4057FC + 100;
		globals->dw4060D8 = globals->dw4067FC + 100;
		*(ebp_10 - 0x04) = *(ebp_10 - 0x04) | ~0x00;
	}
	*(ebp_10 - 0xA8) = 0x00;
	*(ebp_10 - 0x28) = 0x00;
	word32 eax_38 = ebp_10->dw0008;
	if (eax_38 != 0x00 && (ebp_10->dw000C <= 0x03 && (ebp_10->dw0010 == 0x00 || ebp_10->dw0010 == 0x01)))
	{
		*(ebp_10 - 0xA8) = 0x01;
		*(ebp_10 - 0x28) = eax_38;
	}
	Eq_40 eax_102;
	*(ebp_10 - 0x44) = 0x00;
	if ((uint32) ((uint64) (uint32) eax_38 % 0x17) > 0x32)
	{
		Eq_40 eax_2229 = GetForegroundWindow();
		__wait();
		*(ebp_10 - 0x44) = (union Eq_40 *) eax_2229;
		Eq_40 eax_2233 = GetModuleHandleA(0x00);
		__wait();
		if (*(ebp_10 - 0x44) != 0x00 && eax_2233 != 0x00)
		{
			word32 ecx_2248 = 0x0A;
			word32 * edi_2256 = ebp_10 - 0x0108;
			while (ecx_2248 != 0x00)
			{
				*edi_2256 = 0x00;
				edi_2256 = edi_2256 + 0x01;
				ecx_2248 = ecx_2248 - 0x01;
			}
			*(ebp_10 - 0x010C) = 0x0F;
			Eq_40 eax_2263 = GetActiveWindow();
			__wait();
			Eq_2151 esi_2265 = 0x00;
			do
			{
				*(ebp_10 - 0xF8) = (union Eq_2151 *) esi_2265;
				*(ebp_10 - 0x0100) = ebp_10 - 0xE0;
				*(ebp_10 - 0x0104) = 0x14;
				*(ebp_10 - 0x0108) = (word32) (esi_2265 >= 0x02);
				Eq_2888 eax_2290 = SendMessageA(eax_2263, 0x1019, esi_2265, ebp_10 - 0x010C);
				__wait();
				if (eax_2290 == 0x00)
					goto l0040206C;
				esi_2265 = (word32) esi_2265 + 0x01;
			} while (esi_2265 < 11);
		}
	}
	else if (*(ebp_10 - 0x28) == 0x00)
		*(ebp_10 - 0x28) = 0x00400000;
	*(ebp_10 - 0x38) = 0x00;
	*(ebp_10 - 0x50) = 0x00;
	*(ebp_10 - 0xA4) = 0x00;
	*(ebp_10 - 0x40) = 0x00;
	*(ebp_10 - 0x9C) = 0x00;
	*(ebp_10 - 0x88) = 0x01;
	*(ebp_10 - 0x87) = 0x50;
	*(ebp_10 - 0x86) = 0x56;
	*(ebp_10 - 133) = 0x46;
	*(ebp_10 - 0x84) = 0x4E;
	*(ebp_10 - 131) = 0x4E;
	*(ebp_10 - 0x82) = 0x10;
	*(ebp_10 - 0x81) = 0x46;
	*(ebp_10 - 0x80) = 0x4E;
	*(ebp_10 - 0x7F) = 0x4E;
	*(ebp_10 - 0x7E) = 0x00;
	*(ebp_10 - 0x7C) = 0x01;
	*(ebp_10 - 0x7B) = 0x2E;
	*(ebp_10 - 122) = 0x46;
	*(ebp_10 - 121) = 0x54;
	*(ebp_10 - 0x78) = 0x28;
	*(ebp_10 - 0x77) = 0x4B;
	*(ebp_10 - 118) = 0x50;
	*(ebp_10 - 117) = 0x46;
	*(ebp_10 - 116) = 0x27;
	*(ebp_10 - 115) = 0x02;
	struct Eq_1253 * edx_142 = *(ebp_10 - 0x28);
	word32 edi_144 = edx_142 + edx_142->ptr003C / 0x0040;
	*(ebp_10 - 0x98) = edi_144;
	*(ebp_10 - 0x90) = 0x00;
	*(ebp_10 - 0x24) = 0x00;
	*(ebp_10 - 0xB4) = 0x00;
	*(ebp_10 - 0x8C) = 0x00;
	*(ebp_10 - 44) = 0x00;
	*(ebp_10 - 0xA0) = 0x00;
	*(ebp_10 - 0xB0) = 0x00;
	*(ebp_10 - 0x3C) = 106194171;
	word32 eax_156 = fn00401799(edx_142, ebp_10, ebp_10 - 0x68);
	__wait();
	if (eax_156 != 0x00)
	{
		ptr32 esp_195;
		ptr32 esp_172;
		word32 eax_173;
		word32 edx_175;
		byte SZO_176;
		bool C_177;
		word32 ecx_178;
		byte SCZO_179;
		Eq_40 ebx_180;
		byte CZ_181;
		byte al_182;
		byte bl_183;
		bool Z_184;
		word32 esi_186;
		byte SO_187;
		word16 ax_188;
		bool S_189;
		word16 si_190;
		struct Eq_2182 * ebp_174;
		struct Eq_2183 * edi_185;
		(*(ebp_10 - 0x60))();
		__wait();
		*(ebp_174 - 0xAC) = eax_173;
		if (*(ebp_174 - 0x44) != ebx_180)
		{
			*(esp_172 - 0x04) = 100;
			*(esp_172 - 0x08) = ebp_174->dw0008;
			Eq_2267 eax_2085 = LoadAcceleratorsA(*(esp_172 - 0x08), *(esp_172 - 0x04));
			__wait();
			*(ebp_174 - 0x34) = (HACCEL *) eax_2085;
			*(esp_172 - 0x04) = (union Eq_40 *) ebx_180;
			*(esp_172 - 0x08) = ebp_174->dw0008;
			*(esp_172 - 0x0C) = 0x1992;
			*(esp_172 - 0x10) = *(ebp_174 - 0x44);
			*(esp_172 - 0x14) = 0x12;
			*(esp_172 - 0x18) = 0x20;
			*(esp_172 - 0x1C) = 0x05;
			*(esp_172 - 0x20) = 0x0A;
			*(esp_172 - 0x24) = 0x50010000;
			*(esp_172 - 0x28) = 0x00403118;
			*(esp_172 - 44) = 0x0040311C;
			*(esp_172 - 0x30) = (union Eq_40 *) ebx_180;
			Eq_40 eax_2115 = CreateWindowExA(*(esp_172 - 0x30), *(esp_172 - 44), *(esp_172 - 0x28), *(esp_172 - 0x24), *(esp_172 - 0x20), *(esp_172 - 0x1C), *(esp_172 - 0x18), *(esp_172 - 0x14), *(esp_172 - 0x10), *(esp_172 - 0x0C), *(esp_172 - 0x08), *(esp_172 - 0x04));
			__wait();
			*(ebp_174 - 0x30) = (union Eq_40 *) eax_2115;
			*(esp_172 - 0x04) = (union Eq_40 *) ebx_180;
			*(esp_172 - 0x08) = ebp_174->dw0008;
			*(esp_172 - 0x0C) = 0x0363;
			*(esp_172 - 0x10) = *(ebp_174 - 0x44);
			*(esp_172 - 0x14) = 100;
			*(esp_172 - 0x18) = 100;
			*(esp_172 - 0x1C) = 0x05;
			*(esp_172 - 0x20) = 0x32;
			*(esp_172 - 0x24) = 0x50010000;
			*(esp_172 - 0x28) = 0x00403124;
			*(esp_172 - 44) = 0x00403134;
			*(esp_172 - 0x30) = (union Eq_40 *) ebx_180;
			Eq_40 eax_2144 = CreateWindowExA(*(esp_172 - 0x30), *(esp_172 - 44), *(esp_172 - 0x28), *(esp_172 - 0x24), *(esp_172 - 0x20), *(esp_172 - 0x1C), *(esp_172 - 0x18), *(esp_172 - 0x14), *(esp_172 - 0x10), *(esp_172 - 0x0C), *(esp_172 - 0x08), *(esp_172 - 0x04));
			__wait();
			esp_195 = esp_172;
			if (*(ebp_174 - 0x30) != ebx_180 && eax_2144 != ebx_180)
			{
				*(esp_172 - 0x04) = (union Eq_40 *) ebx_180;
				*(esp_172 - 0x08) = (union Eq_40 *) eax_2144;
				ShowWindow(*(esp_172 - 0x08), *(esp_172 - 0x04));
				__wait();
				*(esp_172 - 0x04) = 0x0040313C;
				*(esp_172 - 0x08) = *(ebp_174 - 0x30);
				SetWindowTextA(*(esp_172 - 0x08), *(esp_172 - 0x04));
				__wait();
				while (true)
				{
					*(esp_172 - 0x04) = (union Eq_40 *) ebx_180;
					*(esp_172 - 0x08) = (union Eq_40 *) ebx_180;
					*(esp_172 - 0x0C) = (union Eq_40 *) ebx_180;
					*(esp_172 - 0x10) = ebp_174 - 220;
					Eq_54 eax_2177 = GetMessageA(*(esp_172 - 0x10), *(esp_172 - 0x0C), *(esp_172 - 0x08), *(esp_172 - 0x04));
					__wait();
					esp_195 = esp_172;
					if (eax_2177 == 0x00)
						break;
					*(esp_172 - 0x04) = ebp_174 - 220;
					*(esp_172 - 0x08) = *(ebp_174 - 0x34);
					*(esp_172 - 0x0C) = *(ebp_174 - 220);
					int32 eax_2191 = TranslateAcceleratorA(*(esp_172 - 0x0C), *(esp_172 - 0x08), *(esp_172 - 0x04));
					__wait();
					if (eax_2191 == 0x00)
					{
						*(esp_172 - 0x04) = ebp_174 - 220;
						TranslateMessage(*(esp_172 - 0x04));
						__wait();
					}
				}
				fn0040138A();
				__wait();
			}
		}
		else
		{
			*(esp_172 - 0x04) = 0x04;
			*(esp_172 - 0x08) = 0x1000;
			*(esp_172 - 0x0C) = 0x0A;
			*(esp_172 - 0x10) = (union Eq_40 *) ebx_180;
			word32 eax_2210;
			word32 edx_2212;
			byte SZO_2213;
			bool C_2214;
			word32 ecx_2215;
			byte SCZO_2216;
			word32 ebx_2217;
			byte CZ_2218;
			byte al_2219;
			byte bl_2220;
			bool Z_2221;
			word32 esi_2223;
			byte SO_2224;
			word16 ax_2225;
			bool S_2226;
			word16 si_2227;
			(*(ebp_174 - 0x60))();
			__wait();
			*(ebp_174 - 44) = eax_2210;
		}
		*(ebp_174 - 0xB8) = edi_185->dw0050;
		word32 eax_201 = fn00401367(ebp_174 - 0x88);
		word32 * esp_202 = esp_195 - 0x04;
		*esp_202 = eax_201;
		ptr32 esp_204;
		word32 eax_205;
		ptr32 ebp_206;
		word32 edx_207;
		byte SZO_208;
		bool C_209;
		word32 ecx_210;
		byte SCZO_211;
		word32 ebx_212;
		byte CZ_213;
		byte al_214;
		byte bl_215;
		bool Z_216;
		word32 edi_217;
		word32 esi_218;
		byte SO_219;
		word16 ax_220;
		bool S_221;
		word16 si_222;
		(*(ebp_174 - 0x68))();
		__wait();
		*(ebp_206 - 0xC0) = eax_205;
		fn00401767(ebp_206 - 0x68);
		__wait();
		*(ebp_206 - 0x30) = ebp_206 - 0x68;
		*(esp_204 - 0x04) = ebp_206 - 0x68;
		ptr32 esp_228;
		word32 eax_229;
		ptr32 ebp_230;
		word32 edx_231;
		byte SZO_232;
		bool C_233;
		word32 ecx_234;
		byte SCZO_235;
		word32 ebx_236;
		byte CZ_237;
		byte al_238;
		byte bl_239;
		bool Z_240;
		word32 edi_241;
		word32 esi_242;
		byte SO_243;
		word16 ax_244;
		bool S_245;
		word16 si_246;
		(*(ebp_206 - 88))();
		__wait();
		*(ebp_230 - 0x20) = eax_229;
		*(esp_228 - 0x04) = 0x8000;
		*(esp_228 - 0x08) = ebx_236;
		*(esp_228 - 0x0C) = *(ebp_230 - 0x30);
		ptr32 esp_256;
		word32 eax_257;
		word32 edx_259;
		byte SZO_260;
		bool C_261;
		word32 ecx_262;
		byte SCZO_263;
		up32 ebx_264;
		byte CZ_265;
		byte al_266;
		byte bl_267;
		bool Z_268;
		ptr32 edi_269;
		word32 esi_270;
		byte SO_271;
		word16 ax_272;
		bool S_273;
		word16 si_274;
		(*(ebp_230 - 0x5C))();
		__wait();
		if (*(ebp_10 - 0x20) == ebx_264)
			goto l0040206C;
		up32 eax_277 = *(edi_269 - 0x08);
		*(ebp_10 - 0x6C) = eax_277;
		if (eax_277 <= ebx_264)
			goto l0040206C;
		struct Eq_1391 * eax_281 = *(ebp_10 - 44);
		fn0040186E(eax_281);
		*(esp_256 - 0x04) = ebp_10 - 0x68;
		*(esp_256 - 0x08) = (struct Eq_1391 **) eax_281;
		*(esp_256 - 0x0C) = *(ebp_10 - 0x20);
		Eq_40 eax_290 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
		__wait();
		*(ebp_10 - 0x34) = (union Eq_40 *) eax_290;
		*(esp_256 - 0x04) = esi_270;
		*(esp_256 - 0x08) = ebx_264;
		*(esp_256 - 0x0C) = *(ebp_10 - 44);
		ptr32 esp_300;
		word32 eax_301;
		word32 edx_303;
		byte SZO_304;
		bool C_305;
		word32 ecx_306;
		byte SCZO_307;
		word32 ebx_308;
		byte CZ_309;
		byte al_310;
		byte bl_311;
		bool Z_312;
		struct Eq_3063 * edi_313;
		word32 esi_314;
		byte SO_315;
		word16 ax_316;
		bool S_317;
		word16 si_318;
		(*(ebp_10 - 0x5C))();
		__wait();
		if (*(ebp_10 - 0x34) != ebx_308)
		{
			word32 edi_322 = edi_313->dw0088 + *(ebp_10 - 0x28);
			if (edi_322 == *(ebp_10 - 0x28))
			{
				eax_102.u0 = 0x01;
				goto l0040206E;
			}
			fn00401639(ebp_10 - 0x68);
			__wait();
			*(ebp_10 - 0x30) = ebp_10 - 0x68;
			*(esp_300 - 0x04) = ebp_10 - 0x68;
			*(esp_300 - 0x08) = ebp_10 - 0x68;
			*(esp_300 - 0x0C) = *(ebp_10 - 0x20);
			Eq_40 eax_342 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 44) = (union Eq_40 *) eax_342;
			*(esp_300 - 0x04) = esi_314;
			*(esp_300 - 0x08) = ebx_308;
			*(esp_300 - 0x0C) = *(ebp_10 - 0x30);
			ptr32 esp_352;
			word32 eax_353;
			word32 edx_355;
			byte SZO_356;
			bool C_357;
			word32 ecx_358;
			byte SCZO_359;
			byte CZ_361;
			byte al_362;
			byte bl_363;
			bool Z_364;
			word32 edi_365;
			word32 esi_366;
			byte SO_367;
			word16 ax_368;
			bool S_369;
			word16 si_370;
			Eq_40 ebx_1882;
			(*(ebp_10 - 0x5C))();
			__wait();
			if (*(ebp_10 - 44) == ebx_1882)
				goto l0040206C;
			uint64 edx_eax_375 = (uint64) (uint32) ebp_10->dw0008;
			*(esp_352 - 0x04) = 0x1B;
			uint32 edx_381 = (uint32) (edx_eax_375 % *(esp_352 - 0x04));
			*(ebp_10 - 0x94) = edx_381;
			if (edx_381 > 0x32)
			{
				*(esp_352 - 0x04) = ebp_10 - 220;
				*(esp_352 - 0x08) = (union Eq_40 *) ebx_1882;
				*(esp_352 - 0x0C) = 6637399;
				Eq_54 eax_2031 = GetScrollInfo(*(esp_352 - 0x0C), *(esp_352 - 0x08), *(esp_352 - 0x04));
				__wait();
				if (eax_2031 != 0x00)
				{
					*(ebp_10 - 200) = *(ebp_10 - 200) + 0x14;
					*(esp_352 - 0x04) = 0x01;
					*(esp_352 - 0x08) = ebp_10 - 220;
					*(esp_352 - 0x0C) = (union Eq_40 *) ebx_1882;
					*(esp_352 - 0x10) = 0x06547547;
					SetScrollInfo(*(esp_352 - 0x10), *(esp_352 - 0x0C), *(esp_352 - 0x08), *(esp_352 - 0x04));
				}
				else
				{
					*(esp_352 - 0x04) = 0x20;
					*(esp_352 - 0x08) = 0x2000;
					*(esp_352 - 0x0C) = 0x0A;
					*(esp_352 - 0x10) = (union Eq_40 *) ebx_1882;
					Eq_40 eax_2065 = VirtualAlloc(*(esp_352 - 0x10), *(esp_352 - 0x0C), *(esp_352 - 0x08), *(esp_352 - 0x04));
					__wait();
					if (eax_2065 == ebx_1882)
						goto l00401ECE;
					*(esp_352 - 0x04) = esi_366;
					*(esp_352 - 0x08) = (union Eq_40 *) ebx_1882;
					*(esp_352 - 0x0C) = (union Eq_40 *) eax_2065;
					VirtualFree(*(esp_352 - 0x0C), *(esp_352 - 0x08), *(esp_352 - 0x04));
				}
				__wait();
			}
l00401ECE:
			fn004016C9(ebp_10 - 0x68);
			__wait();
			*(ebp_10 - 188) = ebp_10 - 0x68;
			*(esp_352 - 0x04) = ebp_10 - 0x68;
			*(esp_352 - 0x08) = ebp_10 - 0x68;
			*(esp_352 - 0x0C) = *(ebp_10 - 0x20);
			Eq_40 eax_402 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 0x30) = (union Eq_40 *) eax_402;
			if (eax_402 == ebx_1882)
				goto l0040206C;
			ptr32 esp_1836;
			*(ebp_10 - 0x48) = edi_365 + 0x10;
			*(ebp_10 - 0x4C) = (union Eq_40 *) ebx_1882;
			uint64 edx_eax_412 = (uint64) (uint32) ebp_10->dw0008;
			*(esp_352 - 0x04) = 0x41;
			if ((uint32) (edx_eax_412 % *(esp_352 - 0x04)) > 0x4E)
			{
				*(esp_352 - 0x04) = *(ebp_10 - 0x44);
				Eq_40 eax_1832 = GetMenu(*(esp_352 - 0x04));
				__wait();
				esp_1836 = esp_352;
				if (eax_1832 != ebx_1882)
				{
					*(esp_352 - 0x04) = 0x0040314C;
					*(esp_352 - 0x08) = (union Eq_40 *) ebx_1882;
					*(esp_352 - 0x0C) = 0x0400;
					*(esp_352 - 0x10) = (union Eq_40 *) ebx_1882;
					*(esp_352 - 0x14) = (union Eq_40 *) eax_1832;
					ModifyMenuA(*(esp_352 - 0x14), *(esp_352 - 0x10), *(esp_352 - 0x0C), *(esp_352 - 0x08), *(esp_352 - 0x04));
					__wait();
					esp_1836 = esp_352;
				}
			}
			else
			{
				uint64 edx_eax_1853 = (uint64) (uint32) ebp_10->dw0008;
				*(esp_352 - 0x04) = 0x14;
				ui32 ecx_1856 = *(esp_352 - 0x04);
				esp_1836 = esp_352;
				uint32 edx_1859 = (uint32) (edx_eax_1853 % ecx_1856);
				if (edx_1859 <= 0x32)
				{
					*(esp_352 - 0x04) = 0x04;
					*(esp_352 - 0x08) = 0x2000;
					*(esp_352 - 0x0C) = 0x0A;
					*(esp_352 - 0x10) = (union Eq_40 *) ebx_1882;
					Eq_40 eax_1875;
					word32 edx_1877;
					byte SZO_1878;
					bool C_1879;
					word32 ecx_1880;
					byte SCZO_1881;
					byte CZ_1883;
					byte al_1884;
					byte bl_1885;
					bool Z_1886;
					word32 edi_1887;
					word32 esi_1888;
					byte SO_1889;
					word16 ax_1890;
					bool S_1891;
					word16 si_1892;
					(*(ebp_10 - 0x60))();
					__wait();
					*(ebp_10 - 0x24) = (union Eq_40 *) eax_1875;
					if (eax_1875 != ebx_1882)
					{
						*(esp_1836 - 0x04) = 0x96;
						*(esp_1836 - 0x08) = 0x23;
						*(esp_1836 - 0x0C) = 0x41;
						*(esp_1836 - 0x10) = 0x3C;
						*(esp_1836 - 0x14) = 0x19;
						*(esp_1836 - 0x18) = 0x0F;
						ptr32 esp_1977;
						word32 eax_1978;
						ptr32 ebp_1979;
						word32 edx_1980;
						byte SZO_1981;
						bool C_1982;
						word32 ecx_1983;
						byte SCZO_1984;
						word32 ebx_1985;
						byte CZ_1986;
						byte al_1987;
						byte bl_1988;
						bool Z_1989;
						word32 edi_1990;
						word32 esi_1991;
						byte SO_1992;
						word16 ax_1993;
						bool S_1994;
						word16 si_1995;
						(*(ebp_10 - 0x34))();
						__wait();
						*(ebp_1979 - 0x3C) = eax_1978;
						*(esp_1977 - 0x04) = esi_1991;
						*(esp_1977 - 0x08) = ebx_1985;
						*(esp_1977 - 0x0C) = *(ebp_1979 - 0x24);
						word32 eax_2005;
						word32 edx_2007;
						byte SZO_2008;
						bool C_2009;
						word32 ecx_2010;
						byte SCZO_2011;
						byte CZ_2013;
						byte al_2014;
						byte bl_2015;
						bool Z_2016;
						word32 edi_2017;
						word32 esi_2018;
						byte SO_2019;
						word16 ax_2020;
						bool S_2021;
						word16 si_2022;
						(*(ebp_1979 - 0x5C))();
						__wait();
						*(ebp_10 - 0x24) = (union Eq_40 *) ebx_1882;
					}
					if (*(ebp_10 - 0x24) == ebx_1882 && *(ebp_10 - 0x3C) != ebx_1882)
					{
						word32 * esp_1937 = esp_1836 - 0x04;
						*esp_1937 = 0x1D;
						*(esp_1937 - 0x04) = 0x1E;
						*(esp_1937 - 0x08) = 0x07;
						*(esp_1937 - 0x0C) = 0x05;
						word32 eax_1946;
						word32 edx_1948;
						byte SZO_1949;
						bool C_1950;
						word32 ecx_1951;
						byte SCZO_1952;
						byte CZ_1954;
						byte al_1955;
						byte bl_1956;
						bool Z_1957;
						word32 edi_1958;
						word32 esi_1959;
						byte SO_1960;
						word16 ax_1961;
						bool S_1962;
						word16 si_1963;
						(*(ebp_10 - 0x30))();
						__wait();
						*(ebp_10 - 0x8C) = eax_1946;
					}
					*(ebp_10 - 0x24) = 0x2D;
				}
			}
			struct Eq_1181 * eax_435 = *(ebp_10 - 0xAC);
			fn0040174B(eax_435);
			ptr32 ecx_436 = ebp_10 - 0x68;
			ptr32 * esp_437 = esp_1836 - 0x04;
			*esp_437 = ecx_436;
			*(esp_437 - 0x04) = (struct Eq_1181 **) eax_435;
			*(esp_437 - 0x08) = *(ebp_10 - 0x20);
			Eq_40 eax_444 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 0x20) = (union Eq_40 *) eax_444;
			if (eax_444 != ebx_1882)
			{
				*esp_437 = 0x04;
				*(esp_437 - 0x04) = 0x3000;
				*(esp_437 - 0x08) = 100;
				*(esp_437 - 0x0C) = (union Eq_40 *) ebx_1882;
				ptr32 esp_460;
				word32 eax_461;
				ptr32 ebp_462;
				word32 edx_463;
				byte SZO_464;
				bool C_465;
				word32 ecx_466;
				byte SCZO_467;
				word32 ebx_468;
				byte CZ_469;
				byte al_470;
				byte bl_471;
				bool Z_472;
				word32 edi_473;
				word32 esi_474;
				byte SO_475;
				word16 ax_476;
				bool S_477;
				word16 si_478;
				(*(ebp_10 - 0x60))();
				__wait();
				*(ebp_462 - 0x70) = eax_461;
				*(esp_460 - 0x04) = ebx_468;
				*(esp_460 - 0x08) = 0x0A;
				*(esp_460 - 0x0C) = *(ebp_462 - 0x3C);
				ptr32 esp_487;
				word32 eax_488;
				ptr32 ebp_489;
				word32 edx_490;
				byte SZO_491;
				bool C_492;
				word32 ecx_493;
				byte SCZO_494;
				word32 ebx_495;
				byte CZ_496;
				byte al_497;
				byte bl_498;
				bool Z_499;
				word32 edi_500;
				word32 esi_501;
				byte SO_502;
				word16 ax_503;
				bool S_504;
				word16 si_505;
				(*(ebp_462 - 0x20))();
				__wait();
				*(ebp_489 - 0x3C) = eax_488;
				*(esp_487 - 0x04) = esi_501;
				*(esp_487 - 0x08) = ebx_495;
				*(esp_487 - 0x0C) = *(ebp_489 - 0x70);
				ptr32 esp_514;
				word32 eax_515;
				word32 edx_517;
				byte SZO_518;
				bool C_519;
				word32 ecx_520;
				byte SCZO_521;
				word32 ebx_522;
				byte CZ_523;
				byte al_524;
				byte bl_525;
				bool Z_526;
				word32 edi_527;
				word32 esi_528;
				byte SO_529;
				word16 ax_530;
				bool S_531;
				word16 si_532;
				(*(ebp_489 - 0x5C))();
				__wait();
				if (*(ebp_10 - 0x3C) == 400)
				{
					*(esp_514 - 0x04) = 0x0F;
					*(esp_514 - 0x08) = 0x0F;
					*(esp_514 - 0x0C) = 0x3C;
					*(esp_514 - 0x10) = 0x32;
					*(esp_514 - 0x14) = 0x14;
					*(esp_514 - 0x18) = 0x14;
					Eq_40 eax_620;
					word32 edx_622;
					byte SZO_623;
					bool C_624;
					word32 ecx_625;
					byte SCZO_626;
					byte CZ_628;
					byte al_629;
					byte bl_630;
					bool Z_631;
					word32 esi_633;
					byte SO_634;
					word16 ax_635;
					bool S_636;
					word16 si_637;
					Eq_40 ebx_1390;
					ptr32 esp_1527;
					struct Eq_4032 * edi_1533;
					(*(ebp_10 - 0x34))();
					__wait();
					*(ebp_10 - 0x70) = (union Eq_40 *) eax_620;
					if (eax_620 == ebx_1390 || *(ebp_10 - 0x8C) == ebx_1390)
						goto l0040206C;
					if (0x00 < edi_1533->w000E)
					{
						do
						{
							if (**(ebp_10 - 0x48) == 0x17)
							{
								uint64 edx_eax_1564 = (uint64) (uint32) ebp_10->dw0008;
								union Eq_40 * esp_1565 = esp_1527 - 0x04;
								*esp_1565 = (union Eq_40 *) 0x4C;
								Eq_40 ecx_1567 = *esp_1565;
								uint32 edx_1570 = (uint32) (edx_eax_1564 % ecx_1567);
								if (edx_1570 > 100)
								{
									*esp_1565 = (union Eq_40 *) 0x00654674;
									Eq_40 eax_1728 = GetMenu(*esp_1565);
									__wait();
									if (eax_1728 != ebx_1390)
									{
										*esp_1565 = (union Eq_40 *) ebx_1390;
										*(esp_1565 - 0x04) = 0x05;
										*(esp_1565 - 0x08) = 0x0400;
										*(esp_1565 - 0x0C) = 0x05;
										*(esp_1565 - 0x10) = (union Eq_40 *) eax_1728;
										Eq_54 eax_1783 = ModifyMenuA(*(esp_1565 - 0x10), *(esp_1565 - 0x0C), *(esp_1565 - 0x08), *(esp_1565 - 0x04), *esp_1565);
										__wait();
										if (eax_1783 == 0x00)
											goto l004020FD;
										*esp_1565 = (union Eq_40 *) ebx_1390;
										*(esp_1565 - 0x04) = 0x01;
										*(esp_1565 - 0x08) = 0x0001000B;
										*(esp_1565 - 0x0C) = 0x00654674;
										SendMessageA(*(esp_1565 - 0x0C), *(esp_1565 - 0x08), *(esp_1565 - 0x04), *esp_1565);
										goto l0040212F;
									}
l004020FD:
									union Eq_54 * esp_1746 = esp_1527 - 0x04;
									*esp_1746 = (union Eq_54 *) (ebp_10 - 0xD0);
									*(esp_1746 - 0x04) = 0x00654674;
									Eq_54 eax_1750 = GetWindowRect(*(esp_1746 - 0x04), *esp_1746);
									__wait();
									esp_1527 = (char *) esp_1746 + 0x04;
									if (eax_1750 != 0x00)
									{
										*(ebp_10 - 200) = *(ebp_10 - 200) + 0x0A;
										*esp_1746 = 0x01;
										*(esp_1746 - 0x04) = ebp_10 - 0xD0;
										*(esp_1746 - 0x08) = 0x00654674;
										InvalidateRect(*(esp_1746 - 0x08), *(esp_1746 - 0x04), *esp_1746);
l0040212F:
										__wait();
									}
								}
								else
								{
									*esp_1565 = (union Eq_40 *) 0x15;
									*(esp_1565 - 0x04) = 0x14;
									*(esp_1565 - 0x08) = 0x10;
									*(esp_1565 - 0x0C) = 0x0F;
									word32 eax_1810;
									word32 edx_1812;
									byte SZO_1813;
									bool C_1814;
									word32 ecx_1815;
									byte SCZO_1816;
									byte CZ_1818;
									byte al_1819;
									byte bl_1820;
									bool Z_1821;
									word32 esi_1823;
									byte SO_1824;
									word16 ax_1825;
									bool S_1826;
									word16 si_1827;
									(*(ebp_10 - 0x30))();
									__wait();
									*(ebp_10 - 0x90) = eax_1810;
								}
								if (*(ebp_10 - 0x90) == ebx_1390)
									goto l0040206C;
								if (*(ebp_10 - 0xB0) == ebx_1390)
								{
									union Eq_40 * esp_1696 = esp_1527 - 0x04;
									*esp_1696 = (union Eq_40 *) ebx_1390;
									*(esp_1696 - 0x04) = (union Eq_40 *) ebx_1390;
									*(esp_1696 - 0x08) = *(ebp_10 - 0x70);
									word32 eax_1704;
									word32 edx_1706;
									byte SZO_1707;
									bool C_1708;
									word32 ecx_1709;
									byte SCZO_1710;
									byte CZ_1712;
									byte al_1713;
									byte bl_1714;
									bool Z_1715;
									word32 esi_1717;
									byte SO_1718;
									word16 ax_1719;
									bool S_1720;
									word16 si_1721;
									(*(ebp_10 - 0x20))();
									__wait();
									*(ebp_10 - 0xA0) = eax_1704;
									*(ebp_10 - 44) = *(ebp_10 - 44) - eax_1704;
								}
								struct Eq_4671 * eax_1614 = edi_1533 + (*((char *) (*(ebp_10 - 0x48)) + 0x04) & 0x7FFFFFFF) / 0x0010;
								*(ebp_10 - 0xB0) = 0x01;
								*(ebp_10 - 0x34) = (union Eq_40 *) ebx_1390;
								struct Eq_4694 * ecx_1615 = (char *) (&eax_1614->w000E + 0x01) + 0x04;
								Eq_40 eax_1620 = (word32) (eax_1614->w000C + eax_1614->w000E);
								if (eax_1620 > ebx_1390)
								{
									do
									{
										*(ebp_10 - 0x3C) = (union Eq_40 *) ebx_1390;
										Eq_4826 edx_1631 = ecx_1615->dw0000;
										if (edx_1631 >= 0x00)
										{
											if (edx_1631 > 1500)
												goto l004021AF;
											*(ebp_10 - 0x3C) = 0x01;
										}
										if (*(ebp_10 - 0x3C) != ebx_1390)
										{
											word32 eax_1649 = Mem1630[(Mem1630[ecx_1615 + 0x00:word32] & 0x7FFFFFFF) + 0x14 + edi_1533:word32] + edi_1533;
											*(ebp_10 - 0x24) = *(ebp_10 - 0x24) + *(ebp_10 - 0xA0);
											word32 ecx_1654 = eax_1649->dw0000;
											*(ebp_10 - 0xA4) = ecx_1654;
											*(ebp_10 - 0x40) = eax_1649->dw0004;
											word32 eax_1658 = (word32) edi_1533->w000E;
											*(ebp_10 - 0x4C) = eax_1658;
											word32 * esp_1660 = esp_1527 - 0x04;
											*esp_1660 = 0x04;
											*(esp_1660 - 0x04) = 0x03;
											*(esp_1660 - 0x08) = 0x02;
											*(esp_1660 - 0x0C) = 0x01;
											Eq_40 eax_1669;
											word32 edx_1671;
											byte SZO_1672;
											bool C_1673;
											word32 ecx_1674;
											byte SCZO_1675;
											byte CZ_1677;
											byte al_1678;
											byte bl_1679;
											bool Z_1680;
											word32 esi_1682;
											byte SO_1683;
											word16 ax_1684;
											bool S_1685;
											word16 si_1686;
											(*(ebp_10 - 0x30))();
											__wait();
											*(ebp_10 - 0xB4) = (union Eq_40 *) eax_1669;
											if (eax_1669 == ebx_1390)
												goto l0040206C;
											*(ebp_10 - 44) = *(ebp_10 - 44) + 0xB0;
											break;
										}
l004021AF:
										*(ebp_10 - 0x34) = *(ebp_10 - 0x34) + 0x01;
										ecx_1615 = ecx_1615 + 0x01;
									} while (*(ebp_10 - 0x34) < eax_1620);
								}
							}
							*(ebp_10 - 0x48) = *(ebp_10 - 0x48) + 0x08;
							*(ebp_10 - 0x4C) = *(ebp_10 - 0x4C) + 0x01;
						} while (*(ebp_10 - 0x4C) < (word32) edi_1533->w000E);
					}
					Eq_40 edi_662 = *(ebp_10 - 0xA4);
					Eq_40 esi_1515 = edi_662;
					if (*(ebp_10 - 0x94) > 0x36)
					{
						Eq_40 eax_1503 = GetActiveWindow();
						__wait();
						if (eax_1503 != ebx_1390)
						{
							int32 * esp_1509 = esp_1527 - 0x04;
							*esp_1509 = 0x03;
							*(esp_1509 - 0x04) = (union Eq_40 *) eax_1503;
							ShowWindow(*(esp_1509 - 0x04), *esp_1509);
							__wait();
						}
					}
					else
						esi_1515 = (word32) edi_662 + 0x01;
					if (esi_1515 == 0x01)
					{
						union Eq_40 * esp_1451 = esp_1527 - 0x04;
						*esp_1451 = (union Eq_40 *) ebx_1390;
						Eq_40 eax_1453 = GetModuleHandleA(*esp_1451);
						__wait();
						*esp_1451 = (union Eq_40 *) eax_1453;
						CloseHandle(*esp_1451);
						__wait();
						uint64 edx_eax_1461 = (uint64) (uint32) ebp_10->dw0008;
						*esp_1451 = (union Eq_40 *) 0x0A;
						if ((uint32) (edx_eax_1461 % *esp_1451) == 0x14)
						{
							*esp_1451 = (union Eq_40 *) esi_1515;
							*(esp_1451 - 0x04) = 0x54;
							TerminateThread(*(esp_1451 - 0x04), *esp_1451);
						}
						else
						{
							uint64 edx_eax_1486 = (uint64) (uint32) ebp_10->dw0008;
							*esp_1451 = (union Eq_40 *) 0x0F;
							if ((uint32) (edx_eax_1486 % *esp_1451) != 0x10)
								goto l0040206C;
							Eq_40 eax_1496 = GetCurrentProcess();
							__wait();
							*esp_1451 = (union Eq_40 *) ebx_1390;
							*(esp_1451 - 0x04) = (union Eq_40 *) eax_1496;
							TerminateProcess(*(esp_1451 - 0x04), *esp_1451);
						}
						__wait();
					}
					*(ebp_10 - 0x60) = *(ebp_10 - 0x60) + *(ebp_10 - 0xA0);
					word32 esi_1443 = *(ebp_10 - 0x28);
					Eq_40 ecx_684 = (word32) edi_662 + esi_1443;
					*(ebp_10 - 0x94) = (union Eq_40 *) ecx_684;
					if (ecx_684 == ebx_1390)
						goto l0040206C;
					uint64 edx_eax_690 = (uint64) (uint32) ebp_10->dw0008;
					LPDWORD * esp_691 = esp_1527 - 0x04;
					*esp_691 = (LPDWORD *) (DWORD *) 0x0A;
					Eq_5176 edi_693 = *esp_691;
					ptr32 esp_1382 = (char *) esp_691 + 0x04;
					uint32 edx_696 = (uint32) (edx_eax_690 % edi_693);
					if (edx_696 == 0x1B)
					{
						Eq_40 eax_1404 = GetCurrentThread();
						__wait();
						if (eax_1404 != ebx_1390)
						{
							Eq_40 eax_1408 = GetCurrentThreadId();
							__wait();
							if (eax_1408 != 0x00)
							{
								*esp_691 = (LPDWORD *) (ebp_10 - 0x70);
								*(esp_691 - 0x04) = (union Eq_40 *) eax_1404;
								GetExitCodeThread(*(esp_691 - 0x04), *esp_691);
								__wait();
								esp_1382 = (char *) esp_691 + 0x04;
							}
						}
					}
					else
					{
						Eq_5176 eax_1419 = ebp_10 - 0x50;
						*esp_691 = (LPDWORD *) eax_1419;
						*(esp_691 - 0x04) = 0x04;
						*(esp_691 - 0x08) = *(ebp_10 - 0x40);
						*(esp_691 - 0x0C) = (union Eq_40 *) ecx_684;
						word32 eax_1430;
						word32 edx_1432;
						byte SZO_1433;
						bool C_1434;
						word32 ecx_1435;
						byte SCZO_1436;
						byte CZ_1438;
						byte al_1439;
						byte bl_1440;
						bool Z_1441;
						word32 edi_1442;
						byte SO_1444;
						word16 ax_1445;
						bool S_1446;
						word16 si_1447;
						(*(ebp_10 - 100))();
						__wait();
						*(ebp_10 - 0x60) = *(ebp_10 - 0x60) - 0xB0;
					}
					*(ebp_10 - 0x20) = (union Eq_40 *) ebx_1390;
					word32 esi_1396 = esi_1443 + *(ebp_10 - 0xB8);
					while (*(ebp_10 - 0x20) <= 0x0800)
					{
						*(ebp_10 - 0x20) = *(ebp_10 - 0x20) + 0x01;
						word32 * esp_1373 = esp_1382 - 0x04;
						*esp_1373 = 0x04;
						*(esp_1373 - 0x04) = 0x3000;
						*(esp_1373 - 0x08) = *(ebp_10 - 0x6C);
						*(esp_1373 - 0x0C) = esi_2349;
						Eq_40 eax_1383;
						word32 edx_1385;
						byte SZO_1386;
						bool C_1387;
						word32 ecx_1388;
						byte SCZO_1389;
						byte CZ_1391;
						byte al_1392;
						byte bl_1393;
						bool Z_1394;
						word32 edi_1395;
						byte SO_1397;
						word16 ax_1398;
						bool S_1399;
						word16 si_1400;
						(*(ebp_10 - 0x60))();
						__wait();
						*(ebp_10 - 0x38) = (union Eq_40 *) eax_1383;
						word32 esi_2349 = esi_1396;
						if (eax_1383 != ebx_1390)
							break;
					}
					ptr32 esp_1306;
					word32 * esp_743 = esp_1382 - 0x04;
					*esp_743 = 0x8000;
					*(esp_743 - 0x04) = (union Eq_40 *) ebx_1390;
					*(esp_743 - 0x08) = *(ebp_10 - 0xAC);
					ptr32 esp_750;
					word32 eax_751;
					word32 edx_753;
					byte SZO_754;
					bool C_755;
					word32 ecx_756;
					byte SCZO_757;
					byte CZ_759;
					byte al_760;
					byte bl_761;
					bool Z_762;
					word32 edi_763;
					word32 esi_764;
					byte SO_765;
					word16 ax_766;
					bool S_767;
					word16 si_768;
					Eq_40 ebx_1355;
					struct Eq_5347 * ebp_1349;
					(*(ebp_10 - 0x5C))();
					__wait();
					uint64 edx_eax_771 = (uint64) (uint32) ebp_1349->dw0008;
					*(esp_750 - 0x04) = 0x11;
					ui32 ecx_774 = *(esp_750 - 0x04);
					uint32 edx_777 = (uint32) (edx_eax_771 % ecx_774);
					if (edx_777 == 0x15)
					{
						*(esp_750 - 0x04) = 0x00100000;
						*(esp_750 - 0x08) = 0x0400;
						*(esp_750 - 0x0C) = (union Eq_40 *) ebx_1355;
						Eq_40 eax_1302 = HeapCreate(*(esp_750 - 0x0C), *(esp_750 - 0x08), *(esp_750 - 0x04));
						__wait();
						esp_1306 = esp_750;
						if (eax_1302 != ebx_1355)
						{
							*(esp_750 - 0x04) = 0x0400;
							*(esp_750 - 0x08) = 0x08;
							*(esp_750 - 0x0C) = (union Eq_40 *) eax_1302;
							Eq_40 eax_1315 = HeapAlloc(*(esp_750 - 0x0C), *(esp_750 - 0x08), *(esp_750 - 0x04));
							__wait();
							esp_1306 = esp_750;
							word32 * esi_1321 = *(ebp_1349 - 0x28) + 0x0765;
							word32 ecx_1324 = 0x0100;
							Eq_40 edi_1325 = eax_1315;
							while (ecx_1324 != 0x00)
							{
								*edi_1325 = *esi_1321;
								esi_1321 = esi_1321 + 0x01;
								edi_1325 = edi_1325 + 0x04;
								ecx_1324 = ecx_1324 - 0x01;
							}
						}
					}
					else
					{
						*(esp_750 - 0x04) = 0x03;
						*(esp_750 - 0x08) = *(ebp_1349 - 0x90);
						*(esp_750 - 0x0C) = *(ebp_1349 - 0x8C);
						*(esp_750 - 0x10) = *(ebp_1349 - 0xB4);
						word32 eax_1348;
						word32 edx_1350;
						byte SZO_1351;
						bool C_1352;
						word32 ecx_1353;
						byte SCZO_1354;
						byte CZ_1356;
						byte al_1357;
						byte bl_1358;
						bool Z_1359;
						word32 edi_1360;
						word32 esi_1361;
						byte SO_1362;
						word16 ax_1363;
						bool S_1364;
						word16 si_1365;
						(*(ebp_1349 - 44))();
						__wait();
						*(ebp_1349 - 0x20) = eax_1348;
					}
					word32 * esp_788 = esp_1306 - 0x04;
					*esp_788 = 0x8000;
					*(esp_788 - 0x04) = (union Eq_40 *) ebx_1355;
					*(esp_788 - 0x08) = *(ebp_1349 - 188);
					word32 eax_796;
					word32 edx_798;
					byte SZO_799;
					bool C_800;
					word32 ecx_801;
					byte SCZO_802;
					word32 ebx_803;
					byte CZ_804;
					byte al_805;
					byte bl_806;
					bool Z_807;
					word32 edi_808;
					word32 esi_809;
					byte SO_810;
					word16 ax_811;
					bool S_812;
					word16 si_813;
					ptr32 esp_1274;
					(*(ebp_1349 - 0x5C))();
					__wait();
					if (*(ebp_10 - 0x38) == ebx_803)
					{
						*(esp_1274 - 0x04) = 0x04;
						*(esp_1274 - 0x08) = 0x3000;
						*(esp_1274 - 0x0C) = *(ebp_10 - 0x6C);
						*(esp_1274 - 0x10) = ebx_803;
						word32 eax_1275;
						word32 edx_1277;
						byte SZO_1278;
						bool C_1279;
						word32 ecx_1280;
						byte SCZO_1281;
						word32 ebx_1282;
						byte CZ_1283;
						byte al_1284;
						byte bl_1285;
						bool Z_1286;
						word32 edi_1287;
						word32 esi_1288;
						byte SO_1289;
						word16 ax_1290;
						bool S_1291;
						word16 si_1292;
						(*(ebp_10 - 0x60))();
						__wait();
						*(ebp_10 - 0x38) = eax_1275;
						if (eax_1275 == ebx_1282)
							goto l0040206C;
					}
					union Eq_3348 * esp_827 = esp_1274 - 0x04;
					*esp_827 = *(ebp_10 - 0x38);
					*(esp_827 - 0x04) = *(ebp_10 - 0x40);
					struct Eq_270 * ebx_837 = *(ebp_10 - 0x94) + *(ebp_10 - 0x24) - 0xE0 + *(ebp_10 - 0x20);
					fn00401268(ebx_837, dwArg00, dwArg04);
					__wait();
					*esp_827 = (union Eq_3348 *) (ebp_10 - 0x68);
					struct Eq_915 * esi_1255 = *(ebp_10 - 0x38);
					*(esp_827 - 0x04) = (struct Eq_915 **) esi_1255;
					word32 eax_846 = fn004014E5(ebp_10, dwArg00, dwArg04);
					__wait();
					if (eax_846 != 0x00)
					{
						uint64 edx_eax_853 = (uint64) (uint32) ebp_10->dw0008;
						*esp_827 = 11;
						Eq_3348 ecx_856 = *esp_827;
						ptr32 esp_1229 = (char *) esp_827 + 0x04;
						uint32 edx_859 = (uint32) (edx_eax_853 % ecx_856);
						if (edx_859 == 0x0F)
						{
							*esp_827 = 0x0400;
							*(esp_827 - 0x04) = 0x40;
							Eq_5851 eax_1228 = GlobalAlloc(*(esp_827 - 0x04), *esp_827);
							__wait();
							esp_1229 = (char *) esp_827 + 0x04;
							if (eax_1228 != null)
							{
								*esp_827 = 0x00100546;
								*(esp_827 - 0x04) = (HGLOBAL *) eax_1228;
								ptr32 esp_1241;
								byte * eax_1242;
								word32 edx_1244;
								byte SZO_1245;
								bool C_1246;
								word32 ecx_1247;
								byte SCZO_1248;
								word32 ebx_1249;
								byte CZ_1250;
								byte al_1251;
								byte bl_1252;
								bool Z_1253;
								word32 edi_1254;
								byte SO_1256;
								word16 ax_1257;
								bool S_1258;
								word16 si_1259;
								(*(ebp_10 - 0x28) + 0x0565)();
								__wait();
								*eax_1242 = 0x01;
								*(esp_1241 - 0x04) = edi_1254;
								GlobalFree(*(esp_1241 - 0x04));
								__wait();
								esp_1229 = esp_1241;
							}
						}
						ptr32 * esp_879 = esp_1229 - 0x04;
						*esp_879 = ebp_10 - 0x68;
						word32 eax_881 = fn004015E7(ebp_10, esi_1255, dwArg00);
						__wait();
						if (eax_881 != 0x00)
						{
							*esp_879 = *(ebp_10 - 0x28);
							word32 eax_890 = fn004016F7(esi_1255, dwArg00);
							__wait();
							if (eax_890 != 0x00)
							{
								ptr32 eax_899 = ebp_10 - 0x50;
								*esp_879 = eax_899;
								*(esp_879 - 0x04) = 0x40;
								*(esp_879 - 0x08) = 0xF8;
								word32 edi_906 = *(ebp_10 - 0x98);
								*(esp_879 - 0x0C) = edi_906;
								ptr32 esp_909;
								ui32 eax_910;
								ptr32 ebp_911;
								word32 edx_912;
								byte SZO_913;
								bool C_914;
								word32 ecx_915;
								byte SCZO_916;
								struct Eq_5977 * ebx_917;
								byte CZ_918;
								byte al_919;
								byte bl_920;
								bool Z_921;
								struct Eq_5982 * edi_922;
								word32 esi_923;
								byte SO_924;
								word16 ax_925;
								bool S_926;
								word16 si_927;
								(*(ebp_10 - 100))();
								__wait();
								edi_922->dw0050 = (eax_910 | ~0x00) - *(ebp_911 - 0x28);
								edi_922->dw008C = ebx_917->dw008C;
								edi_922->dw0088 = ebx_917->dw0088 - *(ebp_911 - 0x28) + esi_923;
								cup16 ax_939 = (word16) (word32) ebx_917->w0006;
								edi_922->w0006 = ax_939;
								up32 edx_941 = 0x00;
								if (0x00 < ax_939)
								{
									*(ebp_911 - 0x40) = &ebx_917->dw008C + 0x001B;
									struct Eq_6114 * eax_1180 = &edi_922->dw008C + 0x001E;
									edx_1185 = edx_941;
									do
									{
										up32 edx_1185;
										*(esp_909 - 0x04) = 0x0A;
										word32 * edi_1192 = eax_1180 - 0x0C;
										word32 ecx_1195 = *(esp_909 - 0x04);
										word32 * esi_1197 = *(ebp_911 - 0x40);
										while (ecx_1195 != 0x00)
										{
											*edi_1192 = *esi_1197;
											esi_1197 = esi_1197 + 0x01;
											edi_1192 = edi_1192 + 0x01;
											ecx_1195 = ecx_1195 - 0x01;
										}
										eax_1180->dw0000 = eax_1180->dw0000 + (*(ebp_911 - 0x38) - *(ebp_911 - 0x28));
										*(ebp_911 - 0x40) = *(ebp_911 - 0x40) + 0x28;
										edx_1185 = edx_1185 + 0x01;
										eax_1180 = eax_1180 + 0x01;
									} while (edx_1185 < (word32) (*((char *) (*(ebp_911 - 0x98)) + 0x06)));
								}
								*(esp_909 - 0x04) = ebp_911 - 0x50;
								*(esp_909 - 0x08) = *(ebp_911 - 0x50);
								*(esp_909 - 0x0C) = 0xF8;
								*(esp_909 - 0x10) = *(ebp_911 - 0x98);
								ptr32 esp_960;
								word32 eax_961;
								word32 edx_963;
								byte SZO_964;
								bool C_965;
								word32 ecx_966;
								byte SCZO_967;
								word32 ebx_968;
								byte CZ_969;
								byte al_970;
								byte bl_971;
								bool Z_972;
								word32 edi_973;
								word32 esi_974;
								byte SO_975;
								word16 ax_976;
								bool S_977;
								word16 si_978;
								(*(ebp_911 - 100))();
								__wait();
								struct Eq_355 * edi_979 = *(ebp_10 - 0x38);
								if (fn004012D3(edi_979) != 0x00)
								{
									*(esp_960 - 0x04) = ebp_10 - 0x50;
									*(esp_960 - 0x08) = 0x40;
									*(esp_960 - 0x0C) = *(ebp_10 - 0x6C);
									*(esp_960 - 0x10) = (struct Eq_355 **) edi_979;
									ptr32 esp_997;
									word32 eax_998;
									word32 edx_1000;
									byte SZO_1001;
									bool C_1002;
									word32 ecx_1003;
									byte SCZO_1004;
									struct Eq_6231 * ebx_1005;
									byte CZ_1006;
									byte al_1007;
									byte bl_1008;
									bool Z_1009;
									word32 edi_1010;
									word32 esi_1011;
									byte SO_1012;
									word16 ax_1013;
									bool S_1014;
									word16 si_1015;
									(*(ebp_10 - 100))();
									__wait();
									<anonymous> * ebx_1019 = ebx_1005->dw0028 + edi_1010;
									if (*(ebp_10 - 0xA8) != 0x00)
									{
										*(esp_997 - 0x04) = ebp_10 - 0x68;
										*(esp_997 - 0x08) = ebp_10 - 0x7C;
										*(esp_997 - 0x0C) = *(ebp_10 - 0xC0);
										Eq_40 eax_1051 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
										__wait();
										if (eax_1051 != 0x00)
										{
											*(ebp_10 - 0x24) = 0x00;
											*(esp_997 - 0x04) = ebp_10 - 0x24;
											*(esp_997 - 0x08) = ebp_10->dw0008;
											ptr32 esp_1062;
											word32 eax_1063;
											word32 edx_1065;
											byte SZO_1066;
											bool C_1067;
											word32 ecx_1068;
											byte SCZO_1069;
											<anonymous> * ebx_1070;
											byte CZ_1071;
											byte al_1072;
											byte bl_1073;
											bool Z_1074;
											word32 edi_1075;
											struct Eq_6428 * esi_1076;
											byte SO_1077;
											word16 ax_1078;
											bool S_1079;
											word16 si_1080;
											eax_1051();
											__wait();
											struct Eq_6428 * eax_1081 = *(ebp_10 - 0x24);
											if (eax_1081 != esi_1076)
											{
												eax_1081->dw0018 = edi_1075;
												*((char *) *(ebp_10 - 0x24) + 0x001C) = (struct Eq_6449 **) ebx_1070;
												struct Eq_6453 * eax_1090 = *(ebp_10 - 0x24);
												word32 ecx_1091 = *(ebp_10 - 0x6C);
												eax_1090->dw0020 = ecx_1091;
												*(esp_1062 - 0x04) = ebp_10->dw0010;
												*(esp_1062 - 0x08) = ebp_10->dw000C;
												*(esp_1062 - 0x0C) = edi_1075;
												*(esp_1062 - 0x10) = 0x01;
												word32 esp_1103;
												word32 eax_1104;
												word32 edx_1106;
												byte SZO_1107;
												bool C_1108;
												word32 ecx_1109;
												byte SCZO_1110;
												word32 ebx_1111;
												byte CZ_1112;
												byte al_1113;
												byte bl_1114;
												bool Z_1115;
												word32 edi_1116;
												word32 esi_1117;
												byte SO_1118;
												word16 ax_1119;
												bool S_1120;
												word16 si_1121;
												ebx_1070();
												__wait();
												*(ebp_10 - 0x9C) = eax_1104;
											}
										}
									}
									else
									{
										*(esp_997 - 0x04) = ebp_10->dw0010;
										*(esp_997 - 0x08) = ebp_10->dw000C;
										*(esp_997 - 0x0C) = ebp_10->dw0008;
										*(esp_997 - 0x10) = 0x00;
										ptr32 esp_1134;
										word32 eax_1135;
										ptr32 ebp_1136;
										word32 edx_1137;
										byte SZO_1138;
										bool C_1139;
										word32 ecx_1140;
										byte SCZO_1141;
										word32 ebx_1142;
										byte CZ_1143;
										byte al_1144;
										byte bl_1145;
										bool Z_1146;
										word32 edi_1147;
										word32 esi_1148;
										byte SO_1149;
										word16 ax_1150;
										bool S_1151;
										word16 si_1152;
										ebx_1019();
										__wait();
										*(ebp_1136 - 0x9C) = eax_1135;
										*(esp_1134 - 0x04) = 0x8000;
										*(esp_1134 - 0x08) = esi_1148;
										*(esp_1134 - 0x0C) = edi_1147;
										word32 esp_1160;
										word32 eax_1161;
										word32 edx_1163;
										byte SZO_1164;
										bool C_1165;
										word32 ecx_1166;
										byte SCZO_1167;
										word32 ebx_1168;
										byte CZ_1169;
										byte al_1170;
										byte bl_1171;
										bool Z_1172;
										word32 edi_1173;
										word32 esi_1174;
										byte SO_1175;
										word16 ax_1176;
										bool S_1177;
										word16 si_1178;
										(*(ebp_1136 - 0x5C))();
										__wait();
									}
									eax_102 = *(ebp_10 - 0x9C);
l0040206E:
									fn004026B7(ebp_10, 0x010C, dwArg00, dwArg04, dwArg08);
									return eax_102;
								}
							}
						}
					}
					goto l0040206C;
				}
				*(esp_514 - 0x04) = ebx_522;
				word32 esi_537 = *(ebp_10 - 0x44);
				*(esp_514 - 0x08) = esi_537;
				ShowWindow(*(esp_514 - 0x08), *(esp_514 - 0x04));
				__wait();
				*(esp_514 - 0x04) = 0x004030FC;
				*(esp_514 - 0x08) = esi_537;
				SetWindowTextA(*(esp_514 - 0x08), *(esp_514 - 0x04));
				__wait();
				*(esp_514 - 0x04) = ebp_10 - 0x011C;
				*(esp_514 - 0x08) = esi_537;
				Eq_54 eax_554 = GetWindowInfo(*(esp_514 - 0x08), *(esp_514 - 0x04));
				__wait();
				if (eax_554 != 0x00)
				{
					*(ebp_10 - 244) = *(ebp_10 - 244) | 0x00040000;
					*(esp_514 - 0x04) = *(ebp_10 - 244);
					*(esp_514 - 0x08) = ~0x13;
					*(esp_514 - 0x0C) = esi_537;
					SetWindowLongA(*(esp_514 - 0x0C), *(esp_514 - 0x08), *(esp_514 - 0x04));
					__wait();
				}
				Eq_40 eax_560 = GetForegroundWindow();
				__wait();
				*(esp_514 - 0x04) = 0x01;
				*(esp_514 - 0x08) = 0x32;
				*(esp_514 - 0x0C) = 0x32;
				*(esp_514 - 0x10) = 0x0A;
				*(esp_514 - 0x14) = 0x0A;
				*(esp_514 - 0x18) = (union Eq_40 *) eax_560;
				MoveWindow(*(esp_514 - 0x18), *(esp_514 - 0x14), *(esp_514 - 0x10), *(esp_514 - 0x0C), *(esp_514 - 0x08), *(esp_514 - 0x04));
				__wait();
				*(esp_514 - 0x04) = ebx_522;
				*(esp_514 - 0x08) = ebx_522;
				*(esp_514 - 0x0C) = 0x0F;
				*(esp_514 - 0x10) = (union Eq_40 *) eax_560;
				Eq_54 eax_585 = PostMessageA(*(esp_514 - 0x10), *(esp_514 - 0x0C), *(esp_514 - 0x08), *(esp_514 - 0x04));
				__wait();
				if (eax_585 == 0x00)
				{
					*(esp_514 - 0x04) = (union Eq_40 *) eax_560;
					UpdateWindow(*(esp_514 - 0x04));
					__wait();
				}
			}
			goto l0040206C;
		}
	}
l0040206C:
	eax_102.u0 = 0x00;
	goto l0040206E;
}

// 004025B8: Register Eq_40 GetKJfkdsjgksjgd()
Eq_40 GetKJfkdsjgksjgd()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403154);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 004025DE: Register Eq_40 GetLKVGskgdh()
Eq_40 GetLKVGskgdh()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403160);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402604: Register Eq_40 GetGHsdjkglkdh()
Eq_40 GetGHsdjkglkdh()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403170);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 0040262A: Register Eq_40 GetFJlksdjglkdfjhd()
Eq_40 GetFJlksdjglkdfjhd()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403184);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402650: Register Eq_40 GetKJGjhgfdhfdkh()
Eq_40 GetKJGjhgfdhfdkh()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 4207000);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 0040267C: Register ptr32 fn0040267C(Register word32 ebx, Register word32 esi, Register word32 edi, Stack word32 dwArg00, Stack word32 dwArg04, Stack ui32 dwArg08)
ptr32 fn0040267C(word32 ebx, word32 esi, word32 edi, word32 dwArg00, word32 dwArg04, ui32 dwArg08)
{
	ptr32 esp_14 = fp - 0x08 - dwArg08;
	*(esp_14 - 0x04) = ebx;
	*(esp_14 - 0x08) = esi;
	*(esp_14 - 0x0C) = edi;
	*(esp_14 - 0x10) = dwArg00;
	fs->ptr0000 = fp - 0x08;
	return fp + 0x08;
}

// 004026B7: void fn004026B7(Register (ptr32 Eq_475) ebp, Stack word32 dwArg00, Stack Eq_40 dwArg04, Stack Eq_40 dwArg08, Stack Eq_40 dwArg0C)
void fn004026B7(Eq_475 * ebp, word32 dwArg00, Eq_40 dwArg04, Eq_40 dwArg08, Eq_40 dwArg0C)
{
	fs->dw0000 = *(ebp - 0x10);
	ebp->dw0000 = dwArg00;
}

