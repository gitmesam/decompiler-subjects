// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401010: void fn00401010(Register (arr Eq_6595) ebx, Stack uint32 dwArg04)
void fn00401010(Eq_6595 ebx[], uint32 dwArg04)
{
	uint32 eax_21 = (uint32) (0x40 /u dwArg04);
	Eq_8 ebp_138 = 0x00;
	uint32 edi_136 = eax_21;
	if (!DPB(CZ, false, 0))
	{
		uint32 edx_95 = (uint32) ((uint64) (uint32) ebx % 0x0F);
		Eq_20 bLoc2D_106 = 0x00;
		uint32 edx_111 = (uint32) ((uint64) (uint32) ebx % 0x41);
		do
		{
			Eq_8 dwLoc2C_142 = ebp_138;
			Eq_8 dwLoc24_143 = ebp_138;
			if (edx_95 > 0x14)
			{
				Eq_37 eax_452 = GetDC(0x00);
				TextOutA(eax_452, 0x0A, 0x0A, 0x004030E0, 0x20);
				if (eax_452 != null && MoveToEx(eax_452, 0x0A, 0x0A, null) == 0x00)
					Polyline(eax_452, (POINT *) 0x00324345, 0x14);
				else
					LineTo(eax_452 + 0x0A, 0x96, 200);
				ReleaseDC(0x00, eax_452);
			}
			else
				dwLoc2C_142 = (word32) ebp_138.u0 + ((word32) (bLoc2D_106 != 0x00) * 0x08 + 0x0D);
			if (edx_111 > 0x56)
			{
				Eq_40 eax_330 = GetForegroundWindow();
				if (eax_330 != 0x00)
				{
					Eq_37 eax_339 = GetDC(eax_330);
					if (eax_339 != null)
					{
						Eq_113 eax_369 = CreatePen(0x02, 0x03, 0x00101010);
						if (eax_369 != 0x00)
							SelectObject(eax_339, eax_369);
						else
						{
							Eq_37 eax_401 = CreateCompatibleDC(eax_339);
							SelectObject(eax_401, 0x00);
							BitBlt(eax_339, 0x00, 0x00, 0x32, 0x32, eax_401, 0x00, 0x00, 0x00CC0020);
							DeleteDC(eax_401);
						}
						ReleaseDC(eax_330, eax_339);
					}
					edi_136 = eax_21;
				}
			}
			else if (dwLoc2C_142 > edi_136 - 0x01)
				dwLoc2C_142 = (uint32) ((uint64) (uint32) dwLoc2C_142 % edi_136);
			if ((ebx & 0x07) > 0x0A)
				SetEvent(CreateEventA(null, 0x01, 0x01, 0x004030E8));
			else
				bLoc2D_106 = bLoc2D_106 == 0x00;
			byte cl_223;
			if (edx_111 > 0x50)
			{
				Eq_40 eax_264 = FindWindowA(0x00, 0x004030F4);
				if (eax_264 != 0x00 && GetWindowRect(eax_264, fp - 0x10) != 0x00)
					SetWindowPos(eax_264, 0x00, dwLoc10, dwLoc0C, dwLoc08 + 0x32, dwLoc04, 0x04);
				goto l004011FF;
			}
			if (dwArg04 == 0x01)
			{
				cl_223 = (byte) (word32) Mem0[ebx + ebp_138:byte];
				goto l0040120A;
			}
			dwLoc24_143 = ebx[ebp_138];
l004011FF:
			if (dwArg04 == 0x01)
			{
				cl_223 = bLoc24;
l0040120A:
				word32 eax_230 = dwLoc2C_142 + ebx;
				Mem234[ebx + ebp_138:byte] = Mem0[eax_230 + 0x00:byte];
				*eax_230 = cl_223;
			}
			else
			{
				union Eq_8 * eax_255 = ebx + dwLoc2C_142;
				ebx[ebp_138] = *eax_255;
				*eax_255 = (union Eq_8 *) dwLoc24_143;
			}
			ui32 ebp_210 = (word32) ebp_138.u0 + 0x01;
			ebp_138 = ebp_210 + 0x01;
		} while (ebp_210 + 0x01 < edi_136);
	}
}

// 00401241: void fn00401241(Stack (ptr32 Eq_270) dwArg04, Stack Eq_40 dwArg08, Stack uint32 dwArg0C)
void fn00401241(Eq_270 * dwArg04, Eq_40 dwArg08, uint32 dwArg0C)
{
	Eq_40 esi_23 = 0x00;
	if (dwArg08 > 0x00)
	{
		do
		{
			fn00401010(esi_23 + dwArg04, dwArg0C);
			esi_23 = (word32) esi_23 + 0x0040;
		} while (esi_23 < dwArg08);
	}
}

// 00401268: void fn00401268(Register (ptr32 Eq_270) ebx, Stack Eq_40 dwArg04, Stack Eq_40 dwArg08)
void fn00401268(Eq_270 * ebx, Eq_40 dwArg04, Eq_40 dwArg08)
{
	fn00401241(ebx, dwArg04, 0x01);
	fn00401241(ebx, dwArg04, 0x04);
	word32 esi_34 = Mem0[ebx + 0x3C:word32] + ebx;
	fn00401A68(dwArg08, ebx, esi_34->t0054);
	int32 dwArg04_43 = dwArg04 & 0x00;
	word32 eax_46 = esi_34 + ((word32) esi_34->w0014 + 0x18) / 88;
	if (0x00 < esi_34->w0006)
	{
		struct Eq_324 * edi_62 = eax_46 + 0x14;
		do
		{
			fn00401A68((word32) dwArg08 + *(edi_62 - 0x08), ebx + edi_62->dw0000, *(edi_62 - 0x04));
			int32 v18_76 = dwArg04_43 + 0x01;
			edi_62 = edi_62 + 0x01;
			dwArg04_43 = v18_76;
		} while (v18_76 < (word32) esi_34->w0006);
	}
}

// 004012D3: Register word32 fn004012D3(Register (ptr32 Eq_355) edi)
word32 fn004012D3(Eq_355 * edi)
{
	struct Eq_356 * ecx_10 = edi + edi->dw003C / 0x0040;
	ptr32 edx_13 = edi - ecx_10->dw0034;
	struct Eq_355 * eax_109 = edi + ecx_10->dw00A0 / 0x0040;
	if (eax_109 == edi)
		return 0x00;
	ui32 dwLoc0C_106 = dwLoc0C & 0x00;
	word32 esi_110 = eax_109->dw0004;
	if (esi_110 != 0x00)
	{
		do
		{
			uint32 edx_92 = esi_110 - 0x08;
			if (edx_92 >> 0x01 > 0x00)
			{
				word16 * dwLoc08_117 = &eax_109->dw0004 + 0x01;
				uint32 dwLoc10_118 = edx_92 >> 0x01;
				do
				{
					ui32 edx_123 = (word32) *dwLoc08_117;
					if ((word16) (edx_123 & 0xF000) == 0x3000)
					{
						word32 * edx_145 = edi + (eax_109->dw0000 + (edx_123 & 0x0FFF)) / 0x0040;
						*edx_145 = *edx_145 + edx_13;
					}
					uint32 v20_138 = dwLoc10_118 - 0x01;
					dwLoc08_117 = dwLoc08_117 + 0x01;
					dwLoc10_118 = v20_138;
				} while (v20_138 != 0x00);
			}
			ui32 v18_105 = dwLoc0C_106 + esi_110;
			eax_109 = edi + (ecx_10->dw00A0 + v18_105) / 0x0040;
			dwLoc0C_106 = v18_105;
			esi_110 = eax_109->dw0004;
		} while (esi_110 != 0x00);
	}
	return 0x01;
}

// 00401367: Register (ptr32 Eq_440) fn00401367(Register (ptr32 Eq_440) eax)
Eq_440 * fn00401367(Eq_440 * eax)
{
	if (eax->b0000 == 0x01)
	{
		eax = &eax->b0001;
		byte * ecx_20 = &eax->b0001;
		if (eax->b0001 != 0x00)
		{
			do
			{
				byte dl_29;
				byte dl_23 = *ecx_20;
				if (dl_23 != 0x00)
					dl_29 = dl_23 + 0x1E;
				else
					dl_29 = 0x00;
				*ecx_20 = dl_29;
				ecx_20 = ecx_20 + 0x01;
			} while (*ecx_20 != 0x00);
		}
	}
	return eax;
}

// 0040138A: void fn0040138A()
void fn0040138A()
{
}

// 00401390: Register Eq_40 fn00401390(Register (ptr32 Eq_475) ebp, Stack Eq_40 dwArg04, Stack Eq_40 dwArg08, Stack Eq_40 dwArg0C)
Eq_40 fn00401390(Eq_475 * ebp, Eq_40 dwArg04, Eq_40 dwArg08, Eq_40 dwArg0C)
{
	Eq_40 eax_133;
	if (dwArg04 != 0x00)
	{
		word32 eax_98 = Mem0[dwArg04 + 0x3C:word32] + dwArg04;
		if (eax_98 != null)
		{
			Eq_40 eax_103 = (word32) dwArg04 + eax_98->dw0078;
			if (eax_103 != dwArg04)
			{
				uint32 ecx_113 = *((word32) eax_103 + 0x0014);
				uint32 edx_109 = *((word32) eax_103 + 0x0018);
				word16 ecx_111[] = Mem0[eax_103 + 0x24:word32] + dwArg04;
				word32 edi_114[] = Mem0[eax_103 + 0x1C:word32] + dwArg04;
				word32 ebx_115[] = Mem0[eax_103 + 0x20:word32] + dwArg04;
				uint32 dwLoc08_118 = ecx_113;
				if (ecx_113 <= edx_109)
					dwLoc08_118 = edx_109;
				if (dwArg08 < 0x00)
				{
					uint32 edx_128 = (dwArg08 & 0x7FFFFFFF) - *((word32) eax_103 + 0x0010);
					if (edx_128 < ecx_113)
					{
						eax_133 = (word32) dwArg04 + edi_114[edx_128];
						return eax_133;
					}
				}
				else
				{
					uint32 eax_135 = 0x00;
					uint32 dwArg04_136 = 0x00;
					if (dwLoc08_118 > 0x00)
					{
						while (true)
						{
							uint32 ecx_146 = (word32) ecx_111[eax_135];
							if (eax_135 >= edx_109 || ecx_146 >= ecx_113)
								break;
							if (fn0040159A(dwArg08, (word32) dwArg04 + ebx_115[dwArg04_136]) != 0x00)
							{
								up32 * ebx_171 = edi_114 + ecx_146;
								up32 ecx_173 = *ebx_171;
								up32 eax_174 = eax_98->dw0078;
								if (ecx_173 >= eax_174)
								{
									up32 edx_183 = eax_98->dw007C + eax_174;
									if (ecx_173 < edx_183)
									{
										byte * eax_186 = (word32) dwArg04 + ecx_173;
										do
										{
											byte dl_189 = *eax_186;
											eax_186 = eax_186 + 0x01;
										} while (dl_189 != 0x2E);
										ptr32 esp_207;
										word32 ebp_208;
										byte SCZO_209;
										ui32 * ebx_210;
										ui32 esi_211;
										<anonymous> ** edi_212;
										byte SZO_213;
										bool C_214;
										bool Z_215;
										Eq_40 eax_216;
										word32 ecx_217;
										word32 edx_218;
										byte CZ_219;
										bool S_220;
										byte dl_221;
										(*((word32) dwArg0C + 0x08))();
										if (eax_216 == 0x00)
											break;
										ui32 eax_226 = *ebx_210;
										*(esp_207 - 0x04) = eax_186 - eax_226 - esi_211 - 0x01;
										struct Eq_270 * ecx_235 = eax_226 + esi_211;
										fn00401A68(eax_216, ecx_235, dwArg00);
										*(esp_207 - 0x04) = (<anonymous> ***) edi_212;
										*(esp_207 - 0x08) = (byte **) eax_186;
										*(esp_207 - 0x0C) = (union Eq_40 *) eax_216;
										struct Eq_646 * esp_251;
										struct Eq_475 * ebp_252;
										byte SCZO_253;
										word32 ebx_254;
										word32 esi_255;
										struct Eq_651 * edi_256;
										byte SZO_257;
										bool C_258;
										bool Z_259;
										word32 eax_260;
										word32 ecx_261;
										word32 edx_262;
										byte CZ_263;
										bool S_264;
										byte dl_265;
										(*edi_212)();
										*(esp_251 - 0x04) = eax_260;
										Eq_40 eax_268 = fn00401390(ebp_252, dwArg00, eax_216, eax_186 & 0x00);
										esp_251->dw0004 = ebx_254;
										esp_251->t0000 = eax_268;
										Eq_40 dwArg08_277 = esp_251->t0000;
										esp_251->dw0004 = 0x8000;
										esp_251->t0000.u0 = 0x00;
										*(esp_251 - 0x04) = (union Eq_40 *) eax_216;
										word32 esp_288;
										word32 ebp_289;
										byte SCZO_290;
										word32 ebx_291;
										word32 esi_292;
										word32 edi_293;
										byte SZO_294;
										bool C_295;
										bool Z_296;
										word32 eax_297;
										word32 ecx_298;
										word32 edx_299;
										byte CZ_300;
										bool S_301;
										byte dl_302;
										edi_256->ptr000C();
										eax_133 = dwArg08_277;
										return eax_133;
									}
								}
								eax_133 = (word32) dwArg04 + ecx_173;
								return eax_133;
							}
							uint32 v16_162 = dwArg04_136 + 0x01;
							dwArg04_136 = v16_162;
							if (v16_162 >= dwLoc08_118)
								break;
							eax_135 = v16_162;
						}
					}
				}
			}
		}
	}
	eax_133.u0 = 0x00;
	return eax_133;
}

// 004014E5: Register word32 fn004014E5(Register (ptr32 Eq_475) ebp, Stack Eq_40 dwArg04, Stack Eq_40 dwArg08)
word32 fn004014E5(Eq_475 * ebp, Eq_40 dwArg04, Eq_40 dwArg08)
{
	word32 eax_103;
	struct Eq_721 * eax_11 = (word32) dwArg04 + ((word32) (*((word32) dwArg04 + 0x003C)) + 0x0078);
	Eq_40 edx_108 = dwArg04;
	Eq_40 esi_115 = (word32) dwArg04 + eax_11->dw0000;
	if (esi_115 != dwArg04)
	{
		uint32 eax_53 = *((word32) esi_115 + 0x0014);
		uint32 ecx_54 = *((word32) esi_115 + 0x0018);
		ptr32 esp_117 = fp - 0x20;
		word32 edi_111 = Mem0[esi_115 + 0x1C:word32] + dwArg04;
		word16 ebx_112[] = Mem0[esi_115 + 0x24:word32] + dwArg04;
		uint32 dwLoc0C_217 = eax_53;
		if (eax_53 <= ecx_54)
			dwLoc0C_217 = ecx_54;
		uint32 eax_113 = 0x00;
		uint32 dwLoc08_110 = 0x00;
		if (dwLoc0C_217 > 0x00)
		{
			while (true)
			{
				if (eax_113 < *((word32) esi_115 + 0x0014))
					eax_113 = (word32) ebx_112[eax_113];
				union Eq_40 * ecx_121 = edi_111 + eax_113 * 0x04;
				word32 eax_123 = Mem0[ecx_121 + 0x00:word32] + edx_108;
				if (eax_123 != edx_108)
				{
					if (eax_123 > esi_115)
					{
						if (eax_123 <u Mem0[eax_11 + 0x04:word32] *s 0x28 + esi_115)
						{
							Eq_40 ecx_181 = eax_123;
							do
								ecx_181 = (word32) ecx_181 + 0x01;
							while (*ecx_181 != 0x2E);
							*ecx_181 = 0x00;
							union Eq_40 * esp_189 = esp_117 - 0x04;
							*esp_189 = (union Eq_40 *) dwArg08;
							*(esp_189 - 0x04) = (word32) ecx_181 + 0x01;
							*(esp_189 - 0x08) = (union Eq_40 *) eax_123;
							ptr32 esp_197;
							struct Eq_475 * ebp_198;
							byte SCZO_199;
							word32 edx_200;
							word32 eax_201;
							bool Z_203;
							byte SZO_204;
							bool C_205;
							word32 ecx_206;
							byte CZ_209;
							(*dwArg08)();
							*(esp_197 - 0x04) = eax_201;
							eax_123 = fn00401390(ebp_198, dwArg00, dwArg04, dwArg08);
							esp_117 = esp_197 + 0x08;
						}
						edx_108 = dwArg04;
					}
					if (eax_123 == 0x00)
					{
						eax_103 = 0x00;
						return eax_103;
					}
					*ecx_121 = (union Eq_40 *) eax_123;
				}
				uint32 v15_137 = dwLoc08_110 + 0x01;
				dwLoc08_110 = v15_137;
				if (v15_137 >= dwLoc0C_217)
					break;
				eax_113 = v15_137;
			}
		}
		eax_103 = 0x01;
		return eax_103;
	}
	else
	{
		eax_103 = 0x01;
		return eax_103;
	}
}

// 0040159A: Register Eq_40 fn0040159A(Register Eq_40 eax, Register ui32 ecx)
Eq_40 fn0040159A(Eq_40 eax, ui32 ecx)
{
	Eq_856 bl_9 = *eax == 0x01;
	if (bl_9 != 0x00)
		eax = (word32) eax + 0x01;
	Eq_40 eax_33;
	if (*eax != 0x02)
	{
		int32 esi_53 = ecx - eax;
		do
		{
			bool Z_68;
			byte cl_65;
			if (bl_9 != 0x00)
			{
				byte cl_81 = *eax;
				int32 edx_82 = (int32) cl_81;
				if (cl_81 != 0x00)
					edx_82 = edx_82 + 0x1E;
				cl_65 = (byte) *((word32) eax + esi_53);
				Z_68 = (bool) cond((int32) cl_65 - edx_82);
			}
			else
			{
				cl_65 = (byte) *((word32) eax + esi_53);
				Z_68 = (bool) cond(cl_65 - *eax);
			}
			if (Z_68)
			{
				eax_33.u0 = 0x00;
				return eax_33;
			}
			if (cl_65 == 0x00)
				break;
			eax = (word32) eax + 0x01;
		} while (*eax != 0x02);
	}
	eax_33.u0 = 0x01;
	return eax_33;
}

// 004015E7: Register word32 fn004015E7(Register (ptr32 Eq_475) ebp, Register (ptr32 Eq_915) esi, Stack Eq_40 dwArg04)
word32 fn004015E7(Eq_475 * ebp, Eq_915 * esi, Eq_40 dwArg04)
{
	word32 eax_22;
	word32 eax_6 = Mem0[Mem0[esi + 0x3C:word32] + 0x80 + esi:word32] + esi;
	if (eax_6 == esi)
		eax_22 = 0x01;
	else
	{
		if (eax_6->dw0000 != 0x00)
		{
			struct Eq_915 * ebx_71 = eax_6;
			do
			{
				if (fn0040166B(esi + ebx_71->dw0010 / 0x0040, &ebx_71->dw0010 + 0x01, ebp, dwArg04, esi + ebx_71->dw000C / 0x0040, esi + ebx_71->dw0000 / 0x0040, esi, out ebx_71) == 0x00)
				{
					eax_22 = 0x00;
					goto l00401630;
				}
			} while (ebx_71->dw0000 != 0x00);
		}
		eax_22 = 0x01;
l00401630:
	}
	return eax_22;
}

// 00401639: void fn00401639(Register (ptr32 Eq_970) eax)
void fn00401639(Eq_970 * eax)
{
	word32 esp_12;
	struct Eq_972 * eax_13;
	eax->ptr0008();
	eax_13->b0008 = 0x02;
	eax_13->b0001 = 111;
	eax_13->b0003 = 0x62;
	eax_13->b0006 = 101;
	eax_13->b0002 = 0x6D;
	eax_13->b0005 = 110;
	eax_13->b0000 = 0x43;
	eax_13->b0007 = 0x52;
	eax_13->b0004 = 0x69;
}

// 0040166B: Register Eq_40 fn0040166B(Register Eq_40 eax, Register ptr32 ebx, Register (ptr32 Eq_475) ebp, Register Eq_40 edi, Stack word32 dwArg04, Stack Eq_40 dwArg08, Stack (ptr32 Eq_915) dwArg0C, Register out (ptr32 word32) ebxOut)
Eq_40 fn0040166B(Eq_40 eax, ptr32 ebx, Eq_475 * ebp, Eq_40 edi, word32 dwArg04, Eq_40 dwArg08, Eq_915 * dwArg0C, word32 * & ebxOut)
{
	ptr32 esp_17;
	struct Eq_475 * ebp_18;
	word32 edi_21;
	byte SZO_22;
	bool C_23;
	bool Z_24;
	word32 ebx_25;
	byte SCZO_26;
	word32 ecx_27;
	bool S_28;
	word32 * esi_19;
	Eq_40 eax_115;
	(*((word32) edi + 0x0010))();
	if (eax_115 != 0x00)
	{
		*(esp_17 - 0x04) = ebx_25;
		word32 ebx_51 = dwArg08 - esi_19;
		while (true)
		{
			int32 * ecx_57 = esi_19 + ebx_51;
			int32 eax_102 = 0x00;
			if (ecx_57 != null)
				eax_102 = *ecx_57;
			if (esi_19 == null || *esi_19 == 0x00)
				break;
			if (ecx_57 != null)
			{
				*(esp_17 - 0x08) = edi_21;
				if (eax_102 >= 0x00)
					eax_102 = dwArg0C + (eax_102 + 0x02) / 0x0040;
				*(esp_17 - 0x0C) = eax_102;
				*(esp_17 - 0x10) = (union Eq_40 *) eax_115;
				Eq_40 eax_109 = fn00401390(ebp_18, dwArg00, eax_115, dwArg08);
				if (eax_109 == 0x00)
				{
					eax_115.u0 = 0x00;
					goto l004016C3;
				}
				*esi_19 = (word32) eax_109;
			}
			esi_19 = esi_19 + 0x01;
		}
		eax_115.u0 = 0x01;
l004016C3:
		word32 ebx_74;
		*ebxOut = *(esp_17 - 0x04);
	}
	return eax_115;
}

// 004016C9: void fn004016C9(Register (ptr32 Eq_1093) eax)
void fn004016C9(Eq_1093 * eax)
{
	word32 esp_12;
	struct Eq_1095 * eax_13;
	eax->ptr0008();
	eax_13->b0000 = 0x43;
	eax_13->b0007 = 0x02;
	eax_13->b0002 = 101;
	eax_13->b0005 = 101;
	eax_13->b0003 = 0x61;
	eax_13->b0001 = 114;
	eax_13->b0006 = 0x52;
	eax_13->b0004 = 116;
}

// 004016F7: Register (ptr32 Eq_915) fn004016F7(Register (ptr32 Eq_915) eax, Stack Eq_40 dwArg04)
Eq_915 * fn004016F7(Eq_915 * eax, Eq_40 dwArg04)
{
	word32 esi_13 = Mem0[Mem0[eax + 0x3C:word32] + 0x88 + eax:word32] + eax;
	if (esi_13 != eax)
	{
		ptr32 eax_39 = eax - dwArg04;
		if (eax_39 != 0x00)
		{
			up32 ebx_47 = 0x00;
			if (0x00 < esi_13->w000E)
			{
				struct Eq_1155 * edi_62 = &esi_13->dw0010 + 0x01;
				do
				{
					fn00401A43(esi_13 + ((edi_62->dw0000 & 0x7FFFFFFF) + 0x10) / 0x0040, esi_13, eax_39);
					edi_62 = edi_62 + 0x01;
					ebx_47 = ebx_47 + 0x01;
				} while (ebx_47 < (word32) esi_13->w000E);
			}
		}
	}
	return (struct Eq_915 *) 0x01;
}

// 0040174B: void fn0040174B(Register (ptr32 Eq_1181) eax)
void fn0040174B(Eq_1181 * eax)
{
	eax->b0000 = 0x47;
	eax->b0001 = 101;
	eax->b0005 = 0x67;
	eax->b0006 = 0x02;
	eax->b0002 = 116;
	eax->b0004 = 101;
	eax->b0003 = 0x52;
}

// 00401767: void fn00401767(Register (ptr32 Eq_1210) eax)
void fn00401767(Eq_1210 * eax)
{
	word32 esp_12;
	struct Eq_1212 * eax_13;
	eax->ptr0008();
	eax_13->b0007 = 0x6C;
	eax_13->b0006 = 100;
	eax_13->b0003 = 0x33;
	eax_13->b0008 = 0x6C;
	eax_13->b0000 = 0x67;
	eax_13->b0001 = 100;
	eax_13->b0004 = 0x32;
	eax_13->b0005 = 0x2E;
	eax_13->b0002 = 0x69;
}

// 00401799: Register word32 fn00401799(Register (ptr32 Eq_1253) edx, Register (ptr32 Eq_475) ebp, Register ptr32 esi)
word32 fn00401799(Eq_1253 * edx, Eq_475 * ebp, ptr32 esi)
{
	word32 eax_10 = Mem0[Mem0[edx + 0x3C:word32] + 0x80 + edx:word32] + edx;
	if (eax_10 == edx)
		return 0x00;
	ui32 edi_157 = 0x00;
	struct Eq_1253 * ecx_146 = eax_10;
	do
	{
		word32 eax_106;
		if (ecx_234->dw0000 == 0x00)
			goto l00401800;
		ecx_146 = &ecx_234->dw0010 + 0x01;
		struct Eq_1253 * ecx_234 = ecx_146;
	} while (edx[ecx_234->dw000C / 0x0040] != 0x4B);
	word32 eax_151[] = edx + ecx_234->dw0010 / 0x0040;
	int32 ecx_152[] = edx + ecx_234->dw0000 / 0x0040;
	if (eax_151[0x00] != 0x00)
	{
		do
		{
			int32 ebx_158 = ecx_152[edi_157];
			if (ebx_158 >= 0x00)
			{
				struct Eq_1315 * ebx_168 = edx + ebx_158 / 0x0040;
				if (ebx_168->b0002 == 0x47 && (ebx_168->b0003 == 101 && (ebx_168->b0005 == 77 && ebx_168->b000B == 0x48)))
				{
					<anonymous> * eax_178 = eax_151[edi_157];
					ptr32 esp_199;
					word32 ebp_200;
					struct Eq_1343 * eax_201;
					word32 edx_202;
					byte SCZO_203;
					bool Z_204;
					byte SZO_205;
					bool C_206;
					word32 edi_207;
					word32 ecx_208;
					word32 ebx_209;
					bool S_210;
					byte bl_211;
					struct Eq_1354 * esi_212;
					eax_178();
					*(esp_199 - 0x04) = (struct Eq_1354 **) esi_212;
					fn004018A0(eax_201, dwArg00);
					if (esi_212->dw0000 == ebx_209 || (esi_212->dw0010 == ebx_209 || (esi_212->dw0008 == ebx_209 || (esi_212->dw000C == ebx_209 || (esi_212->dw0004 == ebx_209 || esi_212->dw0014 == ebx_209)))))
						break;
					eax_106 = 0x01;
					return eax_106;
				}
			}
			edi_157 = edi_157 + 0x01;
		} while (eax_151[edi_157] != 0x00);
	}
l00401800:
	eax_106 = 0x00;
	return eax_106;
}

// 0040186E: void fn0040186E(Register (ptr32 Eq_1391) eax)
void fn0040186E(Eq_1391 * eax)
{
	word32 esp_12;
	struct Eq_1393 * eax_13;
	eax->ptr0008();
	eax_13->b0007 = 111;
	eax_13->b0008 = 0x02;
	eax_13->b0004 = 116;
	eax_13->b0000 = 0x43;
	eax_13->b0001 = 114;
	eax_13->b0002 = 101;
	eax_13->b0003 = 0x61;
	eax_13->b0005 = 101;
	eax_13->b0006 = 0x52;
}

// 004018A0: void fn004018A0(Register (ptr32 Eq_1343) edi, Stack (ptr32 Eq_1363) dwArg04)
void fn004018A0(Eq_1343 * edi, Eq_1363 * dwArg04)
{
	word32 ecx_11 = Mem0[Mem0[edi + 0x3C:word32] + 0x78 + edi:word32] + edi;
	uint32 eax_25 = ecx_11->dw0014;
	uint32 edx_13 = ecx_11->dw0018;
	word16 eax_19[] = edi + ecx_11->dw0024 / 0x0040;
	word32 esi_26[] = edi + ecx_11->dw001C / 0x0040;
	word32 ebx_27[] = edi + ecx_11->dw0020 / 0x0040;
	uint32 dwLoc10_203 = eax_25;
	if (eax_25 <= edx_13)
		dwLoc10_203 = edx_13;
	uint32 eax_100 = 0x00;
	up32 dwLoc08_108 = 0x00;
	uint32 dwLoc0C_37 = 0x00;
	if (dwLoc10_203 > 0x00)
	{
		while (dwLoc08_108 < 0x06)
		{
			uint32 edx_72 = (word32) eax_19[eax_100];
			if (eax_100 >= ecx_11->dw0018 || edx_72 >= ecx_11->dw0014)
				return;
			struct Eq_1490 * eax_80 = edi + ebx_27[eax_100] / 0x0040;
			byte bl_81 = eax_80->b0000;
			word32 esi_83 = edi + esi_26[edx_72] / 0x0040;
			if (bl_81 == 0x47)
			{
				byte dl_173 = eax_80->b0001;
				if (dl_173 != 101)
					goto l00401987;
				if (eax_80->b0002 == 116 && (eax_80->b0003 == 77 && eax_80->b000F == 0x41))
				{
					dwArg04->dw0000 = esi_83;
					goto l00401A2B;
				}
				if (dl_173 != 101 || (eax_80->b0002 != 116 || (eax_80->b0003 != 0x54 || (eax_80->b0004 != 0x69 || (eax_80->b0005 != 99 || (eax_80->b0007 != 0x43 || (eax_80->b000B != 116 || eax_80->b000C != 0x00)))))))
					goto l00401987;
				dwArg04->dw0014 = esi_83;
				goto l00401A2B;
			}
l00401987:
			if (bl_81 == 0x56)
			{
				byte dl_132 = eax_80->b0001;
				if (dl_132 != 0x69)
					goto l00401A02;
				if (eax_80->b0002 == 114 && (eax_80->b0007 == 0x41 && (eax_80->b0008 == eax_80->b0009 && eax_80->b000C == 0x00)))
				{
					dwArg04->dw0008 = esi_83;
					goto l00401A2B;
				}
				if (dl_132 != 0x69)
					goto l00401A02;
				if (eax_80->b0002 == 114 && (eax_80->b0007 == 0x50 && (eax_80->b0008 == 114 && eax_80->b000E == 0x00)))
				{
					dwArg04->dw0004 = esi_83;
					goto l00401A2B;
				}
				if (dl_132 != 0x69 || (eax_80->b0002 != 114 || (eax_80->b0007 != 0x46 || (eax_80->b0009 != eax_80->b000A || eax_80->b000B != 0x00))))
					goto l00401A02;
				dwArg04->dw000C = esi_83;
				goto l00401A2B;
			}
l00401A02:
			if (eax_80->b0000 == 0x4C && (eax_80->b0001 == 111 && (eax_80->b0002 == 0x61 && (eax_80->b0003 == 100 && (eax_80->b0004 == 0x4C && eax_80->b000B == 0x41)))))
			{
				dwArg04->dw0010 = esi_83;
l00401A2B:
				dwLoc08_108 = dwLoc08_108 + 0x01;
			}
			uint32 v18_92 = dwLoc0C_37 + 0x01;
			dwLoc0C_37 = v18_92;
			if (v18_92 >= dwLoc10_203)
				return;
			eax_100 = v18_92;
		}
	}
}

// 00401A43: void fn00401A43(Register (ptr32 Eq_1160) eax, Register (ptr32 Eq_915) esi, Stack ptr32 dwArg04)
void fn00401A43(Eq_1160 * eax, Eq_915 * esi, ptr32 dwArg04)
{
	while (true)
	{
		ui32 ecx_6 = eax->dw0004;
		if ((ecx_6 & 0x80000000) == 0x00)
			break;
		eax = (struct Eq_1160 *) (esi + ((ecx_6 & 0x7FFFFFFF) + 0x10) / 0x0040);
	}
	word32 * eax_14 = esi + ecx_6 / 0x0040;
	*eax_14 = *eax_14 + dwArg04;
}

// 00401A68: void fn00401A68(Register Eq_40 eax, Register (ptr32 Eq_270) ecx, Stack Eq_40 dwArg04)
void fn00401A68(Eq_40 eax, Eq_270 * ecx, Eq_40 dwArg04)
{
	while (dwArg04 != 0x00)
	{
		*eax = ecx->b0000;
		dwArg04 = dwArg04 - 0x01;
		eax = (word32) eax + 0x01;
		ecx = ecx + 0x01;
	}
}

// 00401A7E: Register Eq_40 Win32CrtStartup()
Eq_40 Win32CrtStartup()
{
	struct Eq_475 * ebp_10 = fn004026B4(ebx, esi, edi, dwLoc0C, 4207064, 252);
	word32 ebx_151 = 0x00;
	if ((uint32) ((uint64) (uint32) ebp_10->dw000C % 0x0A) == 0x14)
	{
		TlsGetValue(0x00);
		TlsSetValue(0x00, 0x6546);
		*(ebp_10 - 0xE0) = 0x00;
		word32 ecx_2361 = 0x08;
		word32 * edi_2370 = ebp_10 - 220;
		while (ecx_2361 != 0x00)
		{
			*edi_2370 = 0x00;
			edi_2370 = edi_2370 + 0x01;
			ecx_2361 = ecx_2361 - 0x01;
		}
		GetSystemInfo(ebp_10 - 0xE0);
		*(ebp_10 - 0x1F) = 0x00;
		*(ebp_10 - 0x20) = (byte) ((char *) *((char *) *fs->ptr002C + 0x0047) + 0x01);
		*(ebp_10 - 0x04) = 0x00;
		Eq_1834 eax_2395 = GetCommandLineA();
		__wait();
		eax_2401 = eax_2395;
		do
		{
			Eq_1834 eax_2401;
			eax_2401 = (word32) eax_2528 + 0x01;
			Eq_1834 eax_2528 = eax_2401;
		} while (*eax_2528 != 0x00);
		Eq_6372 eax_2410 = eax_2401 - eax_2395;
		Eq_1834 esi_2414 = eax_2395;
		union Eq_6375 * edi_2418 = (union Eq_6375 *) 0x00100654;
		do
		{
			edi_2418 = (union Eq_6375 *) ((char *) edi_2529 + 0x01);
			union Eq_6375 * edi_2529 = edi_2418;
		} while (*edi_2529 != 0x00);
		uint32 ecx_2427 = eax_2410 >> 0x02;
		while (ecx_2427 != 0x00)
		{
			*edi_2418 = (union Eq_6375 *) *esi_2414;
			esi_2414 = esi_2414 + 0x04;
			edi_2418 = (union Eq_6375 *) ((char *) edi_2418 + 0x04);
			ecx_2427 = ecx_2427 - 0x01;
		}
		ui32 ecx_2441 = eax_2410 & 0x03;
		while (ecx_2441 != 0x00)
		{
			*edi_2418 = (union Eq_6375 *) *esi_2414;
			esi_2414 = esi_2414 + 0x01;
			edi_2418 = (union Eq_6375 *) ((char *) edi_2418 + 0x01);
			ecx_2441 = ecx_2441 - 0x01;
		}
		byte * eax_2455 = ebp_10 - (struct Eq_6406 *) 0x20;
		union Eq_6408 * esi_2459 = ebp_10 - (struct Eq_6406 *) 0x20;
		do
		{
			eax_2455 = eax_2530 + 0x01;
			byte * eax_2530 = eax_2455;
		} while (*eax_2530 != 0x00);
		Eq_6432 eax_2469 = eax_2455 - (ebp_10 - (struct Eq_6406 *) 0x20);
		union Eq_6435 * edi_2475 = (union Eq_6435 *) 0x00100654;
		do
		{
			edi_2475 = (union Eq_6435 *) ((char *) edi_2531 + 0x01);
			union Eq_6435 * edi_2531 = edi_2475;
		} while (*edi_2531 != 0x00);
		uint32 ecx_2484 = eax_2469 >> 0x02;
		while (ecx_2484 != 0x00)
		{
			*edi_2475 = (union Eq_6435 *) *esi_2459;
			esi_2459 = (union Eq_6408 *) ((char *) esi_2459 + 0x04);
			edi_2475 = (union Eq_6435 *) ((char *) edi_2475 + 0x04);
			ecx_2484 = ecx_2484 - 0x01;
		}
		ui32 ecx_2498 = eax_2469 & 0x03;
		while (ecx_2498 != 0x00)
		{
			*edi_2475 = (union Eq_6435 *) *esi_2459;
			esi_2459 = (union Eq_6408 *) ((char *) esi_2459 + 0x01);
			edi_2475 = (union Eq_6435 *) ((char *) edi_2475 + 0x01);
			ecx_2498 = ecx_2498 - 0x01;
		}
		(ebp_10 - (struct Eq_6472 *) 0x04)->dw0000 = (ebp_10 - (struct Eq_6465 *) 0x04)->dw0000 | ~0x00;
	}
	*(ebp_10 - 0xAC) = 0x00;
	*(ebp_10 - 0x20) = 0x00;
	Eq_1771 esi_48 = ebp_10->t0008;
	if (esi_48 != null && (ebp_10->dw000C <= 0x03 && (ebp_10->dw0010 == 0x00 || ebp_10->dw0010 == 0x01)))
	{
		*(ebp_10 - 0xAC) = 0x01;
		*(ebp_10 - 0x20) = (HINSTANCE *) esi_48;
	}
	Eq_40 eax_1065;
	*(ebp_10 - 0x28) = 0x00;
	ptr32 esp_153 = fp - 0x08;
	if ((uint32) ((uint64) (uint32) esi_48 % 0x17) > 0x32)
	{
		Eq_40 eax_2183 = GetModuleHandleA(0x00);
		__wait();
		Eq_40 eax_2212 = CreateWindowExA(0x00, 0x8002, 0x004030FD, 0x10C00000, 0x19, 0x23, 400, 400, 0x00, 0x00, esi_48, 0x00);
		__wait();
		*(ebp_10 - 0x28) = (union Eq_40 *) eax_2212;
		esp_153 = fp - 0x08;
		if (eax_2212 != 0x00 && eax_2183 != 0x00)
		{
			word32 ecx_2224 = 0x0A;
			word32 * edi_2233 = ebp_10 - 0x0108;
			while (ecx_2224 != 0x00)
			{
				*edi_2233 = 0x00;
				edi_2233 = edi_2233 + 0x01;
				ecx_2224 = ecx_2224 - 0x01;
			}
			*(ebp_10 - 0x010C) = 0x0F;
			Eq_40 eax_2270 = CreateWindowExA(esp_2267->t0000, esp_2267->t0004, esp_2267->t0008, esp_2267->t000C, esp_2267->dw0010, esp_2267->dw0014, esp_2267->dw0018, esp_2267->dw001C, esp_2267->t0020, esp_2267->t0024, esp_2267->t0028, esp_2267->t002C);
			__wait();
			int32 esi_2290 = 0x00;
			do
			{
				*(ebp_10 - 0xF8) = esi_2290;
				*(ebp_10 - 0x0100) = ebp_10 - 220;
				*(ebp_10 - 0x0104) = 0x14;
				*(ebp_10 - 0x0108) = (word32) (esi_2290 >= 0x02);
				*(esp_2269 - 0x04) = ebp_10 - 0x010C;
				*(esp_2269 - 0x08) = esi_2290;
				*(esp_2269 - 0x0C) = 0x101B;
				*(esp_2269 - 0x10) = (union Eq_40 *) eax_2270;
				Eq_2946 eax_2314 = SendMessageA(*(esp_2269 - 0x10), *(esp_2269 - 0x0C), *(esp_2269 - 0x08), *(esp_2269 - 0x04));
				__wait();
				esp_153 = esp_2269;
				if (eax_2314 == ~0x00)
					goto l00401C76;
				esi_2290 = esi_2290 + 0x01;
			} while (esi_2290 < 11);
		}
	}
	else if (*(ebp_10 - 0x20) == 0x00)
		*(ebp_10 - 0x20) = 0x00400000;
	*(ebp_10 - 0x24) = 0x00;
	*(ebp_10 - 0x48) = 0x00;
	*(ebp_10 - 0x9C) = 0x00;
	*(ebp_10 - 0x30) = 0x00;
	*(ebp_10 - 0x98) = 0x00;
	*(ebp_10 - 0x84) = 0x01;
	*(ebp_10 - 131) = 0x50;
	*(ebp_10 - 0x82) = 0x56;
	*(ebp_10 - 0x81) = 0x46;
	*(ebp_10 - 0x80) = 0x4E;
	*(ebp_10 - 0x7F) = 0x4E;
	*(ebp_10 - 0x7E) = 0x10;
	*(ebp_10 - 0x7D) = 0x46;
	*(ebp_10 - 0x7C) = 0x4E;
	*(ebp_10 - 0x7B) = 0x4E;
	*(ebp_10 - 122) = 0x00;
	*(ebp_10 - 0x78) = 0x01;
	*(ebp_10 - 0x77) = 0x2E;
	*(ebp_10 - 118) = 0x46;
	*(ebp_10 - 117) = 0x54;
	*(ebp_10 - 116) = 0x28;
	*(ebp_10 - 115) = 0x4B;
	*(ebp_10 - 114) = 0x50;
	*(ebp_10 - 113) = 0x46;
	*(ebp_10 - 0x70) = 0x27;
	*(ebp_10 - 111) = 0x02;
	struct Eq_1253 * edx_182 = *(ebp_10 - 0x20);
	word32 edi_184 = edx_182 + edx_182->ptr003C / 0x0040;
	*(ebp_10 - 0x88) = edi_184;
	*(ebp_10 - 0x94) = 0x00;
	*(ebp_10 - 0xB0) = 0x00;
	*(ebp_10 - 0x90) = 0x00;
	*(ebp_10 - 0xA4) = 0x00;
	*(ebp_10 - 0xB4) = 0x00;
	*(ebp_10 - 0x4C) = 106194171;
	ptr32 esi_193 = ebp_10 - 0x68;
	word32 eax_194 = fn00401799(edx_182, ebp_10, esi_193);
	__wait();
	if (eax_194 != 0x00)
	{
		word32 * esp_201 = esp_153 - 0x04;
		*esp_201 = 0x04;
		*(esp_201 - 0x04) = 0x3000;
		*(esp_201 - 0x08) = 0x07;
		*(esp_201 - 0x0C) = ebx_151;
		ptr32 esp_209;
		word32 eax_210;
		struct Eq_2262 * ebp_211;
		word32 edx_212;
		byte SZO_213;
		bool C_214;
		word32 ecx_215;
		byte SCZO_216;
		Eq_40 ebx_217;
		bool Z_218;
		struct Eq_2270 * edi_219;
		word32 esi_220;
		byte CZ_221;
		byte al_222;
		byte SO_223;
		word16 ax_224;
		bool S_225;
		word16 dx_226;
		struct Eq_2278 * fs_227;
		byte cl_228;
		(*(ebp_10 - 0x60))();
		__wait();
		*(ebp_211 - 0x50) = eax_210;
		if (*(ebp_211 - 0x28) != ebx_217)
		{
			*(esp_209 - 0x04) = 100;
			*(esp_209 - 0x08) = ebp_211->dw0008;
			Eq_2467 eax_2065 = LoadAcceleratorsA(*(esp_209 - 0x08), *(esp_209 - 0x04));
			__wait();
			*(ebp_211 - 44) = (HACCEL *) eax_2065;
			*(esp_209 - 0x04) = (union Eq_40 *) ebx_217;
			*(esp_209 - 0x08) = ebp_211->dw0008;
			*(esp_209 - 0x0C) = 0x1992;
			*(esp_209 - 0x10) = *(ebp_211 - 0x28);
			*(esp_209 - 0x14) = 0x12;
			*(esp_209 - 0x18) = 0x20;
			*(esp_209 - 0x1C) = 0x05;
			*(esp_209 - 0x20) = 0x0A;
			*(esp_209 - 0x24) = 0x50010000;
			*(esp_209 - 0x28) = 0x00403110;
			*(esp_209 - 44) = 0x00403114;
			*(esp_209 - 0x30) = (union Eq_40 *) ebx_217;
			Eq_40 eax_2095 = CreateWindowExA(*(esp_209 - 0x30), *(esp_209 - 44), *(esp_209 - 0x28), *(esp_209 - 0x24), *(esp_209 - 0x20), *(esp_209 - 0x1C), *(esp_209 - 0x18), *(esp_209 - 0x14), *(esp_209 - 0x10), *(esp_209 - 0x0C), *(esp_209 - 0x08), *(esp_209 - 0x04));
			__wait();
			*(ebp_211 - 0x3C) = (union Eq_40 *) eax_2095;
			*(esp_209 - 0x04) = (union Eq_40 *) ebx_217;
			*(esp_209 - 0x08) = ebp_211->dw0008;
			*(esp_209 - 0x0C) = 0x0363;
			*(esp_209 - 0x10) = *(ebp_211 - 0x28);
			*(esp_209 - 0x14) = 100;
			*(esp_209 - 0x18) = 100;
			*(esp_209 - 0x1C) = 0x05;
			*(esp_209 - 0x20) = 0x32;
			*(esp_209 - 0x24) = 0x50010000;
			*(esp_209 - 0x28) = 0x0040311C;
			*(esp_209 - 44) = 0x0040312C;
			*(esp_209 - 0x30) = (union Eq_40 *) ebx_217;
			Eq_40 eax_2124 = CreateWindowExA(*(esp_209 - 0x30), *(esp_209 - 44), *(esp_209 - 0x28), *(esp_209 - 0x24), *(esp_209 - 0x20), *(esp_209 - 0x1C), *(esp_209 - 0x18), *(esp_209 - 0x14), *(esp_209 - 0x10), *(esp_209 - 0x0C), *(esp_209 - 0x08), *(esp_209 - 0x04));
			__wait();
			if (*(ebp_211 - 0x3C) != ebx_217 && eax_2124 != ebx_217)
			{
				*(esp_209 - 0x04) = (union Eq_40 *) ebx_217;
				*(esp_209 - 0x08) = (union Eq_40 *) eax_2124;
				ShowWindow(*(esp_209 - 0x08), *(esp_209 - 0x04));
				__wait();
				*(esp_209 - 0x04) = 0x00403134;
				*(esp_209 - 0x08) = *(ebp_211 - 0x3C);
				SetWindowTextA(*(esp_209 - 0x08), *(esp_209 - 0x04));
				__wait();
				while (true)
				{
					*(esp_209 - 0x04) = (union Eq_40 *) ebx_217;
					*(esp_209 - 0x08) = (union Eq_40 *) ebx_217;
					*(esp_209 - 0x0C) = (union Eq_40 *) ebx_217;
					*(esp_209 - 0x10) = ebp_211 - 0xD8;
					Eq_54 eax_2157 = GetMessageA(*(esp_209 - 0x10), *(esp_209 - 0x0C), *(esp_209 - 0x08), *(esp_209 - 0x04));
					__wait();
					if (eax_2157 == 0x00)
						break;
					*(esp_209 - 0x04) = ebp_211 - 0xD8;
					*(esp_209 - 0x08) = *(ebp_211 - 44);
					*(esp_209 - 0x0C) = *(ebp_211 - 0xD8);
					int32 eax_2171 = TranslateAcceleratorA(*(esp_209 - 0x0C), *(esp_209 - 0x08), *(esp_209 - 0x04));
					__wait();
					if (eax_2171 == 0x00)
					{
						*(esp_209 - 0x04) = ebp_211 - 0xD8;
						TranslateMessage(*(esp_209 - 0x04));
						__wait();
					}
				}
				fn0040138A();
				__wait();
			}
		}
		*(ebp_211 - 0xB8) = edi_219->dw0050;
		word32 eax_237 = fn00401367(ebp_211 - 0x84);
		*(esp_209 - 0x04) = eax_237;
		ptr32 esp_240;
		word32 eax_241;
		ptr32 ebp_242;
		word32 edx_243;
		byte SZO_244;
		bool C_245;
		word32 ecx_246;
		byte SCZO_247;
		word32 ebx_248;
		bool Z_249;
		word32 edi_250;
		word32 esi_251;
		byte CZ_252;
		byte al_253;
		byte SO_254;
		word16 ax_255;
		bool S_256;
		word16 dx_257;
		struct Eq_2335 * fs_258;
		byte cl_259;
		(*(ebp_211 - 0x68))();
		__wait();
		*(ebp_242 - 188) = eax_241;
		fn00401767(ebp_242 - 0x68);
		__wait();
		*(ebp_242 - 44) = ebp_242 - 0x68;
		*(esp_240 - 0x04) = ebp_242 - 0x68;
		ptr32 esp_265;
		word32 eax_266;
		ptr32 ebp_267;
		word32 edx_268;
		byte SZO_269;
		bool C_270;
		word32 ecx_271;
		byte SCZO_272;
		word32 ebx_273;
		bool Z_274;
		word32 edi_275;
		word32 esi_276;
		byte CZ_277;
		byte al_278;
		byte SO_279;
		word16 ax_280;
		bool S_281;
		word16 dx_282;
		struct Eq_2386 * fs_283;
		byte cl_284;
		(*(ebp_242 - 88))();
		__wait();
		*(ebp_267 - 0x1C) = eax_266;
		*(esp_265 - 0x04) = 0x8000;
		*(esp_265 - 0x08) = ebx_273;
		*(esp_265 - 0x0C) = *(ebp_267 - 44);
		ptr32 esp_294;
		word32 eax_295;
		word32 edx_297;
		byte SZO_298;
		bool C_299;
		word32 ecx_300;
		byte SCZO_301;
		up32 ebx_302;
		bool Z_303;
		ptr32 edi_304;
		word32 esi_305;
		byte CZ_306;
		byte al_307;
		byte SO_308;
		word16 ax_309;
		bool S_310;
		word16 dx_311;
		struct Eq_2438 * fs_312;
		byte cl_313;
		(*(ebp_267 - 0x5C))();
		__wait();
		if (*(ebp_10 - 0x1C) == ebx_302)
			goto l00401C76;
		up32 eax_316 = *(edi_304 - 0x08);
		*(ebp_10 - 0x6C) = eax_316;
		if (eax_316 <= ebx_302)
			goto l00401C76;
		fn0040186E(ebp_10 - 0x68);
		__wait();
		*(ebp_10 - 44) = ebp_10 - 0x68;
		*(esp_294 - 0x04) = ebp_10 - 0x68;
		*(esp_294 - 0x08) = ebp_10 - 0x68;
		*(esp_294 - 0x0C) = *(ebp_10 - 0x1C);
		Eq_40 eax_330 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
		__wait();
		*(ebp_10 - 0x34) = (union Eq_40 *) eax_330;
		*(esp_294 - 0x04) = esi_305;
		*(esp_294 - 0x08) = ebx_302;
		*(esp_294 - 0x0C) = *(ebp_10 - 44);
		ptr32 esp_340;
		word32 eax_341;
		word32 edx_343;
		byte SZO_344;
		bool C_345;
		word32 ecx_346;
		byte SCZO_347;
		word32 ebx_348;
		bool Z_349;
		struct Eq_3139 * edi_350;
		word32 esi_351;
		byte CZ_352;
		byte al_353;
		byte SO_354;
		word16 ax_355;
		bool S_356;
		word16 dx_357;
		struct Eq_3147 * fs_358;
		byte cl_359;
		(*(ebp_10 - 0x5C))();
		__wait();
		if (*(ebp_10 - 0x34) != ebx_348)
		{
			word32 edi_363 = edi_350->dw0088 + *(ebp_10 - 0x20);
			if (edi_363 == *(ebp_10 - 0x20))
			{
				eax_1065.u0 = 0x01;
				goto l004025E7;
			}
			fn00401639(ebp_10 - 0x68);
			__wait();
			*(ebp_10 - 44) = ebp_10 - 0x68;
			*(esp_340 - 0x04) = ebp_10 - 0x68;
			*(esp_340 - 0x08) = ebp_10 - 0x68;
			*(esp_340 - 0x0C) = *(ebp_10 - 0x1C);
			Eq_40 eax_383 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 0x38) = (union Eq_40 *) eax_383;
			*(esp_340 - 0x04) = esi_351;
			*(esp_340 - 0x08) = ebx_348;
			*(esp_340 - 0x0C) = *(ebp_10 - 44);
			ptr32 esp_393;
			word32 eax_394;
			word32 edx_396;
			byte SZO_397;
			bool C_398;
			word32 ecx_399;
			byte SCZO_400;
			bool Z_402;
			word32 edi_403;
			word32 esi_404;
			byte CZ_405;
			byte al_406;
			byte SO_407;
			word16 ax_408;
			bool S_409;
			word16 dx_410;
			struct Eq_3260 * fs_411;
			byte cl_412;
			Eq_40 ebx_1960;
			(*(ebp_10 - 0x5C))();
			__wait();
			if (*(ebp_10 - 0x38) == ebx_1960)
				goto l00401C76;
			uint64 edx_eax_417 = (uint64) (uint32) ebp_10->t0008;
			*(esp_393 - 0x04) = 0x1B;
			uint32 edx_423 = (uint32) (edx_eax_417 % *(esp_393 - 0x04));
			*(ebp_10 - 0x8C) = edx_423;
			if (edx_423 > 0x32)
			{
				*(esp_393 - 0x04) = ebp_10 - 0xD8;
				*(esp_393 - 0x08) = (union Eq_40 *) ebx_1960;
				*(esp_393 - 0x0C) = 6637399;
				Eq_54 eax_2011 = GetScrollInfo(*(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
				__wait();
				if (eax_2011 != 0x00)
				{
					*(ebp_10 - 0xC4) = *(ebp_10 - 0xC4) + 0x14;
					*(esp_393 - 0x04) = 0x01;
					*(esp_393 - 0x08) = ebp_10 - 0xD8;
					*(esp_393 - 0x0C) = (union Eq_40 *) ebx_1960;
					*(esp_393 - 0x10) = 0x06547547;
					SetScrollInfo(*(esp_393 - 0x10), *(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
				}
				else
				{
					*(esp_393 - 0x04) = 0x20;
					*(esp_393 - 0x08) = 0x2000;
					*(esp_393 - 0x0C) = 0x0A;
					*(esp_393 - 0x10) = (union Eq_40 *) ebx_1960;
					Eq_40 eax_2045 = VirtualAlloc(*(esp_393 - 0x10), *(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
					__wait();
					if (eax_2045 == ebx_1960)
						goto l00401F6C;
					*(esp_393 - 0x04) = esi_404;
					*(esp_393 - 0x08) = (union Eq_40 *) ebx_1960;
					*(esp_393 - 0x0C) = (union Eq_40 *) eax_2045;
					VirtualFree(*(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
				}
				__wait();
			}
l00401F6C:
			fn004016C9(ebp_10 - 0x68);
			__wait();
			*(ebp_10 - 0xA8) = ebp_10 - 0x68;
			*(esp_393 - 0x04) = ebp_10 - 0x68;
			*(esp_393 - 0x08) = ebp_10 - 0x68;
			*(esp_393 - 0x0C) = *(ebp_10 - 0x1C);
			Eq_40 eax_444 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 0x3C) = (union Eq_40 *) eax_444;
			if (eax_444 == ebx_1960)
				goto l00401C76;
			ptr32 esp_1912;
			*(ebp_10 - 0x44) = edi_403 + 0x10;
			*(ebp_10 - 0x40) = (union Eq_40 *) ebx_1960;
			uint64 edx_eax_454 = (uint64) (uint32) ebp_10->t0008;
			*(esp_393 - 0x04) = 0x0A;
			ui32 ecx_457 = *(esp_393 - 0x04);
			uint32 edx_460 = (uint32) (edx_eax_454 % ecx_457);
			*(ebp_10 - 44) = edx_460;
			if (edx_460 == 0x14)
			{
				*(esp_393 - 0x04) = *(ebp_10 - 0x28);
				Eq_40 eax_1908 = GetMenu(*(esp_393 - 0x04));
				__wait();
				esp_1912 = esp_393;
				if (eax_1908 != ebx_1960)
				{
					*(esp_393 - 0x04) = 0x00403144;
					*(esp_393 - 0x08) = (union Eq_40 *) ebx_1960;
					*(esp_393 - 0x0C) = 0x0400;
					*(esp_393 - 0x10) = (union Eq_40 *) ebx_1960;
					*(esp_393 - 0x14) = (union Eq_40 *) eax_1908;
					Eq_54 eax_1925 = ModifyMenuA(*(esp_393 - 0x14), *(esp_393 - 0x10), *(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
					__wait();
					esp_1912 = esp_393;
					if (eax_1925 != 0x00)
					{
						*(esp_393 - 0x04) = (union Eq_40 *) ebx_1960;
						*(esp_393 - 0x08) = 0x0040314C;
						*(esp_393 - 0x0C) = 0x00403158;
						*(esp_393 - 0x10) = (union Eq_40 *) ebx_1960;
						MessageBoxA(*(esp_393 - 0x10), *(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
						__wait();
						esp_1912 = esp_393;
					}
				}
			}
			else
			{
				*(esp_393 - 0x04) = 0x78;
				*(esp_393 - 0x08) = 0x1E;
				*(esp_393 - 0x0C) = 0x32;
				*(esp_393 - 0x10) = 0x32;
				*(esp_393 - 0x14) = 0x14;
				*(esp_393 - 0x18) = 0x14;
				Eq_40 eax_1953;
				word32 edx_1955;
				byte SZO_1956;
				bool C_1957;
				word32 ecx_1958;
				byte SCZO_1959;
				bool Z_1961;
				word32 edi_1962;
				word32 esi_1963;
				byte CZ_1964;
				byte al_1965;
				byte SO_1966;
				word16 ax_1967;
				bool S_1968;
				word16 dx_1969;
				struct Eq_3608 * fs_1970;
				byte cl_1971;
				(*(ebp_10 - 0x34))();
				__wait();
				*(ebp_10 - 0x4C) = (union Eq_40 *) eax_1953;
				if (eax_1953 != ebx_1960)
				{
					*(esp_1912 - 0x04) = 0x1D;
					*(esp_1912 - 0x08) = 0x1E;
					*(esp_1912 - 0x0C) = 0x07;
					*(esp_1912 - 0x10) = 0x05;
					word32 eax_1984;
					word32 edx_1986;
					byte SZO_1987;
					bool C_1988;
					word32 ecx_1989;
					byte SCZO_1990;
					bool Z_1992;
					word32 edi_1993;
					word32 esi_1994;
					byte CZ_1995;
					byte al_1996;
					byte SO_1997;
					word16 ax_1998;
					bool S_1999;
					word16 dx_2000;
					struct Eq_4217 * fs_2001;
					byte cl_2002;
					(*(ebp_10 - 0x3C))();
					__wait();
					*(ebp_10 - 0x90) = eax_1984;
				}
			}
			if (*(ebp_10 - 0x90) != ebx_1960)
			{
				*(ebp_10 - 0x28) = 0x2D;
				struct Eq_1181 * eax_490 = *(ebp_10 - 0x50);
				fn0040174B(eax_490);
				ptr32 ecx_491 = ebp_10 - 0x68;
				ptr32 * esp_492 = esp_1912 - 0x04;
				*esp_492 = ecx_491;
				*(esp_492 - 0x04) = (struct Eq_1181 **) eax_490;
				*(esp_492 - 0x08) = *(ebp_10 - 0x1C);
				Eq_40 eax_499 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
				__wait();
				*(ebp_10 - 0x1C) = (union Eq_40 *) eax_499;
				if (eax_499 == ebx_1960)
					goto l00401C76;
				*esp_492 = 0x04;
				*(esp_492 - 0x04) = 0x3000;
				*(esp_492 - 0x08) = 100;
				*(esp_492 - 0x0C) = (union Eq_40 *) ebx_1960;
				ptr32 esp_515;
				word32 eax_516;
				ptr32 ebp_517;
				word32 edx_518;
				byte SZO_519;
				bool C_520;
				word32 ecx_521;
				byte SCZO_522;
				word32 ebx_523;
				bool Z_524;
				word32 edi_525;
				word32 esi_526;
				byte CZ_527;
				byte al_528;
				byte SO_529;
				word16 ax_530;
				bool S_531;
				word16 dx_532;
				struct Eq_3886 * fs_533;
				byte cl_534;
				(*(ebp_10 - 0x60))();
				__wait();
				*(ebp_517 - 0xA0) = eax_516;
				*(esp_515 - 0x04) = ebx_523;
				*(esp_515 - 0x08) = 0x0A;
				*(esp_515 - 0x0C) = *(ebp_517 - 0x4C);
				ptr32 esp_543;
				word32 eax_544;
				ptr32 ebp_545;
				word32 edx_546;
				byte SZO_547;
				bool C_548;
				word32 ecx_549;
				byte SCZO_550;
				word32 ebx_551;
				bool Z_552;
				word32 edi_553;
				word32 esi_554;
				byte CZ_555;
				byte al_556;
				byte SO_557;
				word16 ax_558;
				bool S_559;
				word16 dx_560;
				struct Eq_3939 * fs_561;
				byte cl_562;
				(*(ebp_517 - 0x1C))();
				__wait();
				*(ebp_545 - 0x4C) = eax_544;
				*(esp_543 - 0x04) = esi_554;
				*(esp_543 - 0x08) = ebx_551;
				*(esp_543 - 0x0C) = *(ebp_545 - 0xA0);
				ptr32 esp_571;
				word32 eax_572;
				word32 edx_574;
				byte SZO_575;
				bool C_576;
				word32 ecx_577;
				byte SCZO_578;
				word32 ebx_579;
				bool Z_580;
				word32 edi_581;
				word32 esi_582;
				byte CZ_583;
				byte al_584;
				byte SO_585;
				word16 ax_586;
				bool S_587;
				word16 dx_588;
				struct Eq_3990 * fs_589;
				byte cl_590;
				(*(ebp_545 - 0x5C))();
				__wait();
				uint64 edx_eax_593 = (uint64) (uint32) ebp_10->dw000C;
				*(esp_571 - 0x04) = 0x0A;
				ui32 ecx_596 = *(esp_571 - 0x04);
				uint32 edx_599 = (uint32) (edx_eax_593 % ecx_596);
				if (edx_599 != 0x28)
				{
					*(esp_571 - 0x04) = *(ebp_10 - 0x20);
					Eq_37 eax_1886 = GetDC(*(esp_571 - 0x04));
					__wait();
					*(esp_571 - 0x04) = 0x01;
					*(esp_571 - 0x08) = 88491439;
					*(esp_571 - 0x0C) = 0x20;
					*(esp_571 - 0x10) = 0x00403164;
					*(esp_571 - 0x14) = (HDC *) eax_1886;
					DrawTextA(*(esp_571 - 0x14), *(esp_571 - 0x10), *(esp_571 - 0x0C), *(esp_571 - 0x08), *(esp_571 - 0x04));
					__wait();
				}
				else if (*(ebp_10 - 0x4C) != 0x0130)
					goto l00401C76;
				*(esp_571 - 0x04) = 0x0F;
				*(esp_571 - 0x08) = 0x0F;
				*(esp_571 - 0x0C) = 0x3C;
				*(esp_571 - 0x10) = 0x32;
				*(esp_571 - 0x14) = 0x14;
				*(esp_571 - 0x18) = 0x14;
				ptr32 esp_620;
				word32 eax_621;
				word32 edx_623;
				byte SZO_624;
				bool C_625;
				word32 ecx_626;
				byte SCZO_627;
				word32 ebx_628;
				bool Z_629;
				word32 edi_630;
				word32 esi_631;
				byte CZ_632;
				byte al_633;
				byte SO_634;
				word16 ax_635;
				bool S_636;
				word16 dx_637;
				struct Eq_4163 * fs_638;
				byte cl_639;
				(*(ebp_10 - 0x34))();
				__wait();
				*(ebp_10 - 0xA0) = eax_621;
				if (eax_621 != ebx_628)
				{
					*(esp_620 - 0x04) = esi_631;
					*(esp_620 - 0x08) = ebx_628;
					*(esp_620 - 0x0C) = *(ebp_10 - 0x50);
					ptr32 esp_650;
					word32 eax_651;
					ptr32 ebp_652;
					word32 edx_653;
					byte SZO_654;
					bool C_655;
					word32 ecx_656;
					byte SCZO_657;
					word32 ebx_658;
					bool Z_659;
					word32 edi_660;
					word32 esi_661;
					byte CZ_662;
					byte al_663;
					byte SO_664;
					word16 ax_665;
					bool S_666;
					word16 dx_667;
					struct Eq_4269 * fs_668;
					byte cl_669;
					(*(ebp_10 - 0x5C))();
					__wait();
					*(esp_650 - 0x04) = esi_661;
					*(esp_650 - 0x08) = ebx_658;
					*(esp_650 - 0x0C) = *(ebp_652 - 0xA8);
					word32 eax_678;
					word32 edx_680;
					byte SZO_681;
					bool C_682;
					word32 ecx_683;
					byte SCZO_684;
					bool Z_686;
					word32 esi_688;
					byte CZ_689;
					byte al_690;
					byte SO_691;
					word16 ax_692;
					bool S_693;
					word16 dx_694;
					struct Eq_4312 * fs_695;
					byte cl_696;
					Eq_40 ebx_1491;
					ptr32 esp_1570;
					struct Eq_4316 * edi_1577;
					(*(ebp_652 - 0x5C))();
					__wait();
					if (0x00 < edi_1577->w000E)
					{
						do
						{
							if (**(ebp_10 - 0x44) == 0x17)
							{
								uint64 edx_eax_1610 = (uint64) (uint32) ebp_10->t0008;
								union Eq_40 * esp_1611 = esp_1570 - 0x04;
								*esp_1611 = (union Eq_40 *) 0x4C;
								Eq_40 ecx_1613 = *esp_1611;
								uint32 edx_1616 = (uint32) (edx_eax_1610 % ecx_1613);
								if (edx_1616 > 100)
								{
									*esp_1611 = (union Eq_40 *) 0x00654674;
									Eq_40 eax_1781 = GetMenu(*esp_1611);
									__wait();
									if (eax_1781 != ebx_1491)
									{
										*esp_1611 = (union Eq_40 *) ebx_1491;
										*(esp_1611 - 0x04) = 0x05;
										*(esp_1611 - 0x08) = 0x0400;
										*(esp_1611 - 0x0C) = 0x05;
										*(esp_1611 - 0x10) = (union Eq_40 *) eax_1781;
										Eq_54 eax_1836 = ModifyMenuA(*(esp_1611 - 0x10), *(esp_1611 - 0x0C), *(esp_1611 - 0x08), *(esp_1611 - 0x04), *esp_1611);
										__wait();
										if (eax_1836 == 0x00)
											goto l0040214D;
										*esp_1611 = (union Eq_40 *) ebx_1491;
										*(esp_1611 - 0x04) = 0x01;
										*(esp_1611 - 0x08) = 0x0001000B;
										*(esp_1611 - 0x0C) = 0x00654674;
										SendMessageA(*(esp_1611 - 0x0C), *(esp_1611 - 0x08), *(esp_1611 - 0x04), *esp_1611);
										goto l0040217F;
									}
l0040214D:
									union Eq_54 * esp_1799 = esp_1570 - 0x04;
									*esp_1799 = (union Eq_54 *) (ebp_10 - 0xCC);
									*(esp_1799 - 0x04) = 0x00654674;
									Eq_54 eax_1803 = GetWindowRect(*(esp_1799 - 0x04), *esp_1799);
									__wait();
									esp_1570 = (char *) esp_1799 + 0x04;
									if (eax_1803 != 0x00)
									{
										*(ebp_10 - 0xC4) = *(ebp_10 - 0xC4) + 0x0A;
										*esp_1799 = 0x01;
										*(esp_1799 - 0x04) = ebp_10 - 0xCC;
										*(esp_1799 - 0x08) = 0x00654674;
										InvalidateRect(*(esp_1799 - 0x08), *(esp_1799 - 0x04), *esp_1799);
l0040217F:
										__wait();
									}
								}
								else
								{
									*esp_1611 = (union Eq_40 *) 0x15;
									*(esp_1611 - 0x04) = 0x14;
									*(esp_1611 - 0x08) = 0x10;
									*(esp_1611 - 0x0C) = 0x0F;
									word32 eax_1863;
									word32 edx_1865;
									byte SZO_1866;
									bool C_1867;
									word32 ecx_1868;
									byte SCZO_1869;
									bool Z_1871;
									word32 esi_1873;
									byte CZ_1874;
									byte al_1875;
									byte SO_1876;
									word16 ax_1877;
									bool S_1878;
									word16 dx_1879;
									struct Eq_4435 * fs_1880;
									byte cl_1881;
									(*(ebp_10 - 0x3C))();
									__wait();
									*(ebp_10 - 0x94) = eax_1863;
								}
								if (*(ebp_10 - 0x94) == ebx_1491)
									goto l00401C76;
								if (*(ebp_10 - 0xB4) == ebx_1491)
								{
									union Eq_40 * esp_1748 = esp_1570 - 0x04;
									*esp_1748 = (union Eq_40 *) ebx_1491;
									*(esp_1748 - 0x04) = (union Eq_40 *) ebx_1491;
									*(esp_1748 - 0x08) = *(ebp_10 - 0xA0);
									word32 eax_1756;
									word32 edx_1758;
									byte SZO_1759;
									bool C_1760;
									word32 ecx_1761;
									byte SCZO_1762;
									bool Z_1764;
									word32 esi_1766;
									byte CZ_1767;
									byte al_1768;
									byte SO_1769;
									word16 ax_1770;
									bool S_1771;
									word16 dx_1772;
									struct Eq_4721 * fs_1773;
									byte cl_1774;
									(*(ebp_10 - 0x1C))();
									__wait();
									*(ebp_10 - 0xA4) = eax_1756;
									*(ebp_10 - 0x38) = *(ebp_10 - 0x38) - eax_1756;
								}
								struct Eq_4648 * eax_1661 = edi_1577 + (*((char *) (*(ebp_10 - 0x44)) + 0x04) & 0x7FFFFFFF) / 0x0010;
								*(ebp_10 - 0xB4) = 0x01;
								*(ebp_10 - 0x34) = (union Eq_40 *) ebx_1491;
								struct Eq_4671 * ecx_1662 = (char *) (&eax_1661->w000E + 0x01) + 0x04;
								Eq_40 eax_1668 = (word32) (eax_1661->w000C + eax_1661->w000E);
								if (eax_1668 > ebx_1491)
								{
									do
									{
										*(ebp_10 - 0x50) = (union Eq_40 *) ebx_1491;
										Eq_4795 edx_1680 = ecx_1662->dw0000;
										if (edx_1680 >= 0x00)
										{
											if (edx_1680 > 1500)
												goto l00402202;
											*(ebp_10 - 0x50) = 0x01;
										}
										if (*(ebp_10 - 0x50) != ebx_1491)
										{
											word32 eax_1700 = Mem1679[(Mem1679[ecx_1662 + 0x00:word32] & 0x7FFFFFFF) + 0x14 + edi_1577:word32] + edi_1577;
											*(ebp_10 - 0x28) = *(ebp_10 - 0x28) + *(ebp_10 - 0xA4);
											word32 ecx_1705 = eax_1700->dw0000;
											*(ebp_10 - 0x9C) = ecx_1705;
											*(ebp_10 - 0x30) = eax_1700->dw0004;
											word32 eax_1709 = (word32) edi_1577->w000E;
											*(ebp_10 - 0x40) = eax_1709;
											word32 * esp_1711 = esp_1570 - 0x04;
											*esp_1711 = 0x04;
											*(esp_1711 - 0x04) = 0x03;
											*(esp_1711 - 0x08) = 0x02;
											*(esp_1711 - 0x0C) = 0x01;
											Eq_40 eax_1720;
											word32 edx_1722;
											byte SZO_1723;
											bool C_1724;
											word32 ecx_1725;
											byte SCZO_1726;
											bool Z_1728;
											word32 esi_1730;
											byte CZ_1731;
											byte al_1732;
											byte SO_1733;
											word16 ax_1734;
											bool S_1735;
											word16 dx_1736;
											struct Eq_5186 * fs_1737;
											byte cl_1738;
											(*(ebp_10 - 0x3C))();
											__wait();
											*(ebp_10 - 0xB0) = (union Eq_40 *) eax_1720;
											if (eax_1720 == ebx_1491)
												goto l00401C76;
											*(ebp_10 - 0x38) = *(ebp_10 - 0x38) + 0xB0;
											break;
										}
l00402202:
										*(ebp_10 - 0x34) = *(ebp_10 - 0x34) + 0x01;
										ecx_1662 = ecx_1662 + 0x01;
									} while (*(ebp_10 - 0x34) < eax_1668);
								}
							}
							*(ebp_10 - 0x44) = *(ebp_10 - 0x44) + 0x08;
							*(ebp_10 - 0x40) = *(ebp_10 - 0x40) + 0x01;
						} while (*(ebp_10 - 0x40) < (word32) edi_1577->w000E);
					}
					Eq_40 edi_718 = *(ebp_10 - 0x9C);
					Eq_40 esi_1560 = edi_718;
					if (*(ebp_10 - 0x8C) > 0x36)
					{
						Eq_40 eax_1548 = GetActiveWindow();
						__wait();
						if (eax_1548 != ebx_1491)
						{
							int32 * esp_1554 = esp_1570 - 0x04;
							*esp_1554 = 0x03;
							*(esp_1554 - 0x04) = (union Eq_40 *) eax_1548;
							ShowWindow(*(esp_1554 - 0x04), *esp_1554);
							__wait();
						}
					}
					else
						esi_1560 = (word32) edi_718 + 0x01;
					if (esi_1560 == 0x01)
					{
						union Eq_40 * esp_1506 = esp_1570 - 0x04;
						*esp_1506 = (union Eq_40 *) ebx_1491;
						Eq_40 eax_1508 = GetModuleHandleA(*esp_1506);
						__wait();
						*esp_1506 = (union Eq_40 *) eax_1508;
						CloseHandle(*esp_1506);
						__wait();
						if (*(ebp_10 - 44) == 0x14)
						{
							*esp_1506 = (union Eq_40 *) esi_1560;
							*(esp_1506 - 0x04) = 0x54;
							TerminateThread(*(esp_1506 - 0x04), *esp_1506);
						}
						else
						{
							uint64 edx_eax_1531 = (uint64) (uint32) ebp_10->t0008;
							*esp_1506 = (union Eq_40 *) 0x0F;
							if ((uint32) (edx_eax_1531 % *esp_1506) != 0x10)
								goto l00401C76;
							Eq_40 eax_1541 = GetCurrentProcess();
							__wait();
							*esp_1506 = (union Eq_40 *) ebx_1491;
							*(esp_1506 - 0x04) = (union Eq_40 *) eax_1541;
							TerminateProcess(*(esp_1506 - 0x04), *esp_1506);
						}
						__wait();
					}
					*(ebp_10 - 0x60) = *(ebp_10 - 0x60) + *(ebp_10 - 0xA4);
					word32 esi_1494 = *(ebp_10 - 0x20);
					Eq_40 eax_737 = (word32) edi_718 + esi_1494;
					*(ebp_10 - 0x8C) = (union Eq_40 *) eax_737;
					ptr32 esp_1434 = esp_1570;
					if (eax_737 == ebx_1491)
						goto l00401C76;
					if (*(ebp_10 - 44) == 0x1B)
					{
						Eq_40 eax_1458 = GetCurrentThread();
						__wait();
						if (eax_1458 != ebx_1491)
						{
							Eq_40 eax_1462 = GetCurrentThreadId();
							__wait();
							if (eax_1462 != 0x00)
							{
								LPDWORD * esp_1467 = esp_1570 - 0x04;
								*esp_1467 = (LPDWORD *) (ebp_10 - 0xA8);
								*(esp_1467 - 0x04) = (union Eq_40 *) eax_1458;
								GetExitCodeThread(*(esp_1467 - 0x04), *esp_1467);
								__wait();
								esp_1434 = (char *) esp_1467 + 0x04;
							}
						}
					}
					else
					{
						ptr32 ecx_1473 = ebp_10 - 0x48;
						ptr32 * esp_1474 = esp_1570 - 0x04;
						*esp_1474 = ecx_1473;
						*(esp_1474 - 0x04) = 0x04;
						*(esp_1474 - 0x08) = *(ebp_10 - 0x30);
						*(esp_1474 - 0x0C) = (union Eq_40 *) eax_737;
						word32 eax_1484;
						word32 edx_1486;
						byte SZO_1487;
						bool C_1488;
						word32 ecx_1489;
						byte SCZO_1490;
						bool Z_1492;
						word32 edi_1493;
						byte CZ_1495;
						byte al_1496;
						byte SO_1497;
						word16 ax_1498;
						bool S_1499;
						word16 dx_1500;
						struct Eq_5016 * fs_1501;
						byte cl_1502;
						(*(ebp_10 - 100))();
						__wait();
						*(ebp_10 - 0x60) = *(ebp_10 - 0x60) - 0xB0;
					}
					*(ebp_10 - 0x1C) = (union Eq_40 *) ebx_1491;
					word32 esi_1445 = esi_1494 + *(ebp_10 - 0xB8);
					while (*(ebp_10 - 0x1C) <= 0x0800)
					{
						*(ebp_10 - 0x1C) = *(ebp_10 - 0x1C) + 0x01;
						word32 * esp_1425 = esp_1434 - 0x04;
						*esp_1425 = 0x04;
						*(esp_1425 - 0x04) = 0x3000;
						*(esp_1425 - 0x08) = *(ebp_10 - 0x6C);
						*(esp_1425 - 0x0C) = esi_1445;
						word32 eax_1435;
						word32 edx_1437;
						byte SZO_1438;
						bool C_1439;
						word32 ecx_1440;
						byte SCZO_1441;
						word32 ebx_1442;
						bool Z_1443;
						word32 edi_1444;
						byte CZ_1446;
						byte al_1447;
						byte SO_1448;
						word16 ax_1449;
						bool S_1450;
						word16 dx_1451;
						struct Eq_5291 * fs_1452;
						byte cl_1453;
						(*(ebp_10 - 0x60))();
						__wait();
						*(ebp_10 - 0x24) = eax_1435;
						if (eax_1435 != 0x00)
							break;
					}
					ptr32 esp_1324;
					uint64 edx_eax_804 = (uint64) (uint32) ebp_10->t0008;
					union Eq_3429 * esp_805 = esp_1434 - 0x04;
					*esp_805 = 0x11;
					Eq_3429 ecx_807 = *esp_805;
					uint32 edx_810 = (uint32) (edx_eax_804 % ecx_807);
					if (edx_810 == 0x15)
					{
						*esp_805 = 0x00100000;
						*(esp_805 - 0x04) = 0x0400;
						*(esp_805 - 0x08) = 0x00;
						Eq_40 eax_1353 = HeapCreate(*(esp_805 - 0x08), *(esp_805 - 0x04), *esp_805);
						__wait();
						esp_1324 = (char *) esp_805 + 0x04;
						if (eax_1353 != 0x00)
						{
							*esp_805 = 0x0400;
							*(esp_805 - 0x04) = 0x08;
							*(esp_805 - 0x08) = (union Eq_40 *) eax_1353;
							Eq_40 eax_1367 = HeapAlloc(*(esp_805 - 0x08), *(esp_805 - 0x04), *esp_805);
							__wait();
							esp_1324 = (char *) esp_805 + 0x04;
							word32 * esi_1373 = *(ebp_10 - 0x20) + 0x0765;
							word32 ecx_1375 = 0x0100;
							Eq_40 edi_1377 = eax_1367;
							while (ecx_1375 != 0x00)
							{
								*edi_1377 = *esi_1373;
								esi_1373 = esi_1373 + 0x01;
								edi_1377 = edi_1377 + 0x04;
								ecx_1375 = ecx_1375 - 0x01;
							}
						}
					}
					else
					{
						*esp_805 = 0x03;
						*(esp_805 - 0x04) = *(ebp_10 - 0x94);
						*(esp_805 - 0x08) = *(ebp_10 - 0x90);
						*(esp_805 - 0x0C) = *(ebp_10 - 0xB0);
						word32 eax_1400;
						word32 edx_1402;
						byte SZO_1403;
						bool C_1404;
						word32 ecx_1405;
						byte SCZO_1406;
						word32 ebx_1407;
						bool Z_1408;
						word32 edi_1409;
						word32 esi_1410;
						byte CZ_1411;
						byte al_1412;
						byte SO_1413;
						word16 ax_1414;
						bool S_1415;
						word16 dx_1416;
						struct Eq_5364 * fs_1417;
						byte cl_1418;
						(*(ebp_10 - 0x38))();
						__wait();
						*(ebp_10 - 0x1C) = eax_1400;
					}
					if (*(ebp_10 - 0x24) == 0x00)
					{
						word32 * esp_1315 = esp_1324 - 0x04;
						*esp_1315 = 0x04;
						*(esp_1315 - 0x04) = 0x3000;
						*(esp_1315 - 0x08) = *(ebp_10 - 0x6C);
						*(esp_1315 - 0x0C) = 0x00;
						word32 eax_1325;
						word32 edx_1327;
						byte SZO_1328;
						bool C_1329;
						word32 ecx_1330;
						byte SCZO_1331;
						word32 ebx_1332;
						bool Z_1333;
						word32 edi_1334;
						word32 esi_1335;
						byte CZ_1336;
						byte al_1337;
						byte SO_1338;
						word16 ax_1339;
						bool S_1340;
						word16 dx_1341;
						struct Eq_5541 * fs_1342;
						byte cl_1343;
						(*(ebp_10 - 0x60))();
						__wait();
						*(ebp_10 - 0x24) = eax_1325;
						if (eax_1325 == esi_1335)
							goto l00401C76;
					}
					if (*(ebp_10 - 0x4C) == 0x0130)
					{
						word32 * esp_1303 = esp_1324 - 0x04;
						*esp_1303 = *(ebp_10 - 0x24);
						*(esp_1303 - 0x04) = *(ebp_10 - 0x30);
						fn00401268(*(ebp_10 - 0x8C) + *(ebp_10 - 0x28) - 0xE0 + *(ebp_10 - 0x1C), dwArg00, dwArg04);
						__wait();
					}
					union Eq_3429 * esp_863 = esp_1324 - 0x04;
					*esp_863 = (union Eq_3429 *) (ebp_10 - 0x68);
					*(esp_863 - 0x04) = *(ebp_10 - 0x24);
					word32 eax_868 = fn004014E5(ebp_10, dwArg00, dwArg04);
					__wait();
					if (eax_868 != 0x00)
					{
						uint64 edx_eax_875 = (uint64) (uint32) ebp_10->t0008;
						*esp_863 = 11;
						Eq_3429 ecx_878 = *esp_863;
						ptr32 esp_1265 = (char *) esp_863 + 0x04;
						uint32 edx_881 = (uint32) (edx_eax_875 % ecx_878);
						if (edx_881 == 0x0F)
						{
							*esp_863 = 0x0400;
							*(esp_863 - 0x04) = 0x40;
							Eq_5681 eax_1264 = GlobalAlloc(*(esp_863 - 0x04), *esp_863);
							__wait();
							esp_1265 = (char *) esp_863 + 0x04;
							if (eax_1264 != null)
							{
								*esp_863 = 0x00100546;
								*(esp_863 - 0x04) = (HGLOBAL *) eax_1264;
								ptr32 esp_1277;
								byte * eax_1278;
								word32 edx_1280;
								byte SZO_1281;
								bool C_1282;
								word32 ecx_1283;
								byte SCZO_1284;
								word32 ebx_1285;
								bool Z_1286;
								word32 edi_1287;
								word32 esi_1288;
								byte CZ_1289;
								byte al_1290;
								byte SO_1291;
								word16 ax_1292;
								bool S_1293;
								word16 dx_1294;
								struct Eq_5726 * fs_1295;
								byte cl_1296;
								(*(ebp_10 - 0x20) + 0x0565)();
								__wait();
								*eax_1278 = 0x01;
								*(esp_1277 - 0x04) = esi_1288;
								GlobalFree(*(esp_1277 - 0x04));
								__wait();
								esp_1265 = esp_1277;
							}
						}
						ptr32 * esp_901 = esp_1265 - 0x04;
						*esp_901 = ebp_10 - 0x68;
						struct Eq_915 * esi_903 = *(ebp_10 - 0x24);
						word32 eax_904 = fn004015E7(ebp_10, esi_903, dwArg00);
						__wait();
						if (eax_904 != 0x00)
						{
							*esp_901 = *(ebp_10 - 0x20);
							word32 eax_913 = fn004016F7(esi_903, dwArg00);
							__wait();
							if (eax_913 != 0x00)
							{
								ptr32 eax_922 = ebp_10 - 0x48;
								*esp_901 = eax_922;
								*(esp_901 - 0x04) = 0x40;
								*(esp_901 - 0x08) = 0xF8;
								word32 esi_929 = *(ebp_10 - 0x88);
								*(esp_901 - 0x0C) = esi_929;
								ptr32 esp_932;
								ui32 eax_933;
								ptr32 ebp_934;
								word32 edx_935;
								byte SZO_936;
								bool C_937;
								word32 ecx_938;
								byte SCZO_939;
								struct Eq_5809 * ebx_940;
								bool Z_941;
								word32 edi_942;
								byte CZ_944;
								byte al_945;
								byte SO_946;
								word16 ax_947;
								bool S_948;
								word16 dx_949;
								struct Eq_5818 * fs_950;
								byte cl_951;
								struct Eq_5820 * esi_1259;
								(*(ebp_10 - 100))();
								__wait();
								esi_1259->dw0050 = (eax_933 | ~0x00) - *(ebp_934 - 0x20);
								esi_1259->dw008C = ebx_940->dw008C;
								esi_1259->dw0088 = ebx_940->dw0088 - *(ebp_934 - 0x20) + edi_942;
								cup16 ax_964 = (word16) (word32) ebx_940->w0006;
								esi_1259->w0006 = ax_964;
								*(ebp_934 - 0x30) = *(ebp_934 - 0x30) & 0x00;
								if (0x00 < ax_964)
								{
									word32 * edx_1210 = &ebx_940->dw008C + 0x001B;
									struct Eq_5943 * eax_1212 = &esi_1259->dw008C + 0x001E;
									do
									{
										*(esp_932 - 0x04) = 0x0A;
										word32 * edi_1225 = eax_1212 - 0x0C;
										word32 ecx_1228 = *(esp_932 - 0x04);
										word32 * esi_1231 = edx_1210;
										while (ecx_1228 != 0x00)
										{
											*edi_1225 = *esi_1231;
											esi_1231 = esi_1231 + 0x01;
											edi_1225 = edi_1225 + 0x01;
											ecx_1228 = ecx_1228 - 0x01;
										}
										eax_1212->dw0000 = eax_1212->dw0000 + (*(ebp_934 - 0x24) - *(ebp_934 - 0x20));
										*(ebp_934 - 0x30) = *(ebp_934 - 0x30) + 0x01;
										eax_1212 = eax_1212 + 0x01;
										edx_1210 = edx_1210 + 0x0A;
									} while (*(ebp_934 - 0x30) < (word32) (*((char *) (*(ebp_934 - 0x88)) + 0x06)));
									esi_1259 = (struct Eq_5820 *) *(ebp_934 - 0x88);
								}
								*(esp_932 - 0x04) = ebp_934 - 0x48;
								*(esp_932 - 0x08) = *(ebp_934 - 0x48);
								*(esp_932 - 0x0C) = 0xF8;
								*(esp_932 - 0x10) = (struct Eq_5820 **) esi_1259;
								ptr32 esp_986;
								word32 eax_987;
								word32 edx_989;
								byte SZO_990;
								bool C_991;
								word32 ecx_992;
								byte SCZO_993;
								word32 ebx_994;
								bool Z_995;
								struct Eq_355 * edi_996;
								word32 esi_997;
								byte CZ_998;
								byte al_999;
								byte SO_1000;
								word16 ax_1001;
								bool S_1002;
								word16 dx_1003;
								struct Eq_5926 * fs_1004;
								byte cl_1005;
								(*(ebp_934 - 100))();
								__wait();
								if (fn004012D3(edi_996) != 0x00)
								{
									*(esp_986 - 0x04) = ebp_10 - 0x48;
									*(esp_986 - 0x08) = 0x40;
									*(esp_986 - 0x0C) = *(ebp_10 - 0x6C);
									*(esp_986 - 0x10) = (struct Eq_355 **) edi_996;
									ptr32 esp_1023;
									word32 eax_1024;
									word32 edx_1026;
									byte SZO_1027;
									bool C_1028;
									word32 ecx_1029;
									byte SCZO_1030;
									struct Eq_6064 * ebx_1031;
									bool Z_1032;
									word32 edi_1033;
									word32 esi_1034;
									byte CZ_1035;
									byte al_1036;
									byte SO_1037;
									word16 ax_1038;
									bool S_1039;
									word16 dx_1040;
									struct Eq_6074 * fs_1041;
									byte cl_1042;
									(*(ebp_10 - 100))();
									__wait();
									<anonymous> * ebx_1045 = ebx_1031->dw0028 + edi_1033;
									if (*(ebp_10 - 0xAC) != 0x00)
									{
										*(esp_1023 - 0x04) = ebp_10 - 0x68;
										*(esp_1023 - 0x08) = ebp_10 - 0x78;
										*(esp_1023 - 0x0C) = *(ebp_10 - 188);
										Eq_40 eax_1078 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
										__wait();
										if (eax_1078 != 0x00)
										{
											*(ebp_10 - 0x1C) = 0x00;
											*(esp_1023 - 0x04) = ebp_10 - 0x1C;
											*(esp_1023 - 0x08) = (HINSTANCE *) ebp_10->t0008;
											ptr32 esp_1089;
											word32 eax_1090;
											word32 edx_1092;
											byte SZO_1093;
											bool C_1094;
											word32 ecx_1095;
											byte SCZO_1096;
											<anonymous> * ebx_1097;
											bool Z_1098;
											word32 edi_1099;
											struct Eq_6261 * esi_1100;
											byte CZ_1101;
											byte al_1102;
											byte SO_1103;
											word16 ax_1104;
											bool S_1105;
											word16 dx_1106;
											struct Eq_6268 * fs_1107;
											byte cl_1108;
											eax_1078();
											__wait();
											struct Eq_6261 * eax_1109 = *(ebp_10 - 0x1C);
											if (eax_1109 != esi_1100)
											{
												eax_1109->dw0018 = edi_1099;
												*((char *) *(ebp_10 - 0x1C) + 0x001C) = (struct Eq_6286 **) ebx_1097;
												struct Eq_6290 * eax_1118 = *(ebp_10 - 0x1C);
												word32 ecx_1119 = *(ebp_10 - 0x6C);
												eax_1118->dw0020 = ecx_1119;
												*(esp_1089 - 0x04) = ebp_10->dw0010;
												*(esp_1089 - 0x08) = ebp_10->dw000C;
												*(esp_1089 - 0x0C) = edi_1099;
												*(esp_1089 - 0x10) = 0x01;
												word32 esp_1131;
												word32 eax_1132;
												word32 edx_1134;
												byte SZO_1135;
												bool C_1136;
												word32 ecx_1137;
												byte SCZO_1138;
												word32 ebx_1139;
												bool Z_1140;
												word32 edi_1141;
												word32 esi_1142;
												byte CZ_1143;
												byte al_1144;
												byte SO_1145;
												word16 ax_1146;
												bool S_1147;
												word16 dx_1148;
												struct Eq_6349 * fs_1149;
												byte cl_1150;
												ebx_1097();
												__wait();
												*(ebp_10 - 0x98) = eax_1132;
											}
										}
									}
									else
									{
										*(esp_1023 - 0x04) = ebp_10->dw0010;
										*(esp_1023 - 0x08) = ebp_10->dw000C;
										*(esp_1023 - 0x0C) = (HINSTANCE *) ebp_10->t0008;
										*(esp_1023 - 0x10) = 0x00;
										ptr32 esp_1163;
										word32 eax_1164;
										ptr32 ebp_1165;
										word32 edx_1166;
										byte SZO_1167;
										bool C_1168;
										word32 ecx_1169;
										byte SCZO_1170;
										word32 ebx_1171;
										bool Z_1172;
										word32 edi_1173;
										word32 esi_1174;
										byte CZ_1175;
										byte al_1176;
										byte SO_1177;
										word16 ax_1178;
										bool S_1179;
										word16 dx_1180;
										struct Eq_6143 * fs_1181;
										byte cl_1182;
										ebx_1045();
										__wait();
										*(ebp_1165 - 0x98) = eax_1164;
										*(esp_1163 - 0x04) = 0x8000;
										*(esp_1163 - 0x08) = esi_1174;
										*(esp_1163 - 0x0C) = edi_1173;
										word32 esp_1190;
										word32 eax_1191;
										word32 edx_1193;
										byte SZO_1194;
										bool C_1195;
										word32 ecx_1196;
										byte SCZO_1197;
										word32 ebx_1198;
										bool Z_1199;
										word32 edi_1200;
										word32 esi_1201;
										byte CZ_1202;
										byte al_1203;
										byte SO_1204;
										word16 ax_1205;
										bool S_1206;
										word16 dx_1207;
										struct Eq_6185 * fs_1208;
										byte cl_1209;
										(*(ebp_1165 - 0x5C))();
										__wait();
									}
									eax_1065 = *(ebp_10 - 0x98);
l004025E7:
									fn004026EF(ebp_10, 252, dwArg00, dwArg04, dwArg08);
									return eax_1065;
								}
							}
						}
					}
				}
			}
			goto l00401C76;
		}
	}
l00401C76:
	eax_1065.u0 = 0x00;
	goto l004025E7;
}

// 004025EF: Register Eq_40 GetKJgkdghkdfhd()
Eq_40 GetKJgkdghkdfhd()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 0x0040316C);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402615: Register Eq_40 GetLKfsdgdkhd()
Eq_40 GetLKfsdgdkhd()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 0x0040317C);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 0040263B: Register Eq_40 GetKkgdstkdgkd()
Eq_40 GetKkgdstkdgkd()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 0x0040318C);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402661: Register Eq_40 GetKfldskgdhkd()
Eq_40 GetKfldskgdhkd()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 4207000);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402687: Register Eq_40 GetKlfgdkgldshd()
Eq_40 GetKlfgdkgldshd()
{
	Eq_40 eax_13 = CreateEventA(null, 0x01, 0x01, 0x004031A8);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 004026B4: Register ptr32 fn004026B4(Register word32 ebx, Register word32 esi, Register word32 edi, Stack word32 dwArg00, Stack word32 dwArg04, Stack ui32 dwArg08)
ptr32 fn004026B4(word32 ebx, word32 esi, word32 edi, word32 dwArg00, word32 dwArg04, ui32 dwArg08)
{
	ptr32 esp_14 = fp - 0x08 - dwArg08;
	*(esp_14 - 0x04) = ebx;
	*(esp_14 - 0x08) = esi;
	*(esp_14 - 0x0C) = edi;
	*(esp_14 - 0x10) = dwArg00;
	fs->ptr0000 = fp - 0x08;
	return fp + 0x08;
}

// 004026EF: void fn004026EF(Register (ptr32 Eq_475) ebp, Stack ui32 dwArg00, Stack Eq_40 dwArg04, Stack Eq_40 dwArg08, Stack Eq_40 dwArg0C)
void fn004026EF(Eq_475 * ebp, ui32 dwArg00, Eq_40 dwArg04, Eq_40 dwArg08, Eq_40 dwArg0C)
{
	fs->dw0000 = *(ebp - 0x10);
	ebp->dw0000 = dwArg00;
}

