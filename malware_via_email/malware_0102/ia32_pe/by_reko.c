// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	Eq_3 eax_28 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 esi_15 = 0x00;
	word32 ebx_259 = eax_28 + 22;
	ui32 ecx_33 = ecx * 0x03;
	Eq_2 dwLoc1C_137 = ~0x00;
	if (AreAnyAccessesGranted(~0x00, (struct Eq_428 *) ~0x00) == 0x00)
		ebx_259 = eax_28 - 0x0C;
	struct Eq_36 * eax_48 = null;
	do
	{
		ui32 edi_60 = ecx_33 + edi * 0x04;
		if (esi_15 == ebx_259)
			esi_15.u0 = 0x00;
		byte cl_66 = *((word32) esi_15 + 0x00404000);
		eax_48[0x00401190] = (struct Eq_36) (eax_48[0x00401190] ^ cl_66);
		edi = (word32) esi_15 + edi_60;
		ecx_33 = DPB(ecx_33, cl_66, 0);
		eax_48 = eax_48 + 0x01;
		esi_15 = (word32) esi_15 + 0x01;
	} while (eax_48 < (struct Eq_36 *) 0x1440);
	struct Eq_66 * ecx_108 = &globals->t402490;
	up32 dwLoc08_112 = 0x00;
	Eq_70 edi_101 = (word32) esi_15.u0 + edi * 0x04;
	do
	{
		Eq_74 eax_93 = ecx_108->t0004;
		Eq_114 eax_95 = eax_93 - 0x08 >> 0x01;
		edi_101 = (word32) eax_95 + edi_101 * 0x08;
		word16 * edx_100 = (char *) &ecx_108->t0004 + 0x04;
		if (eax_95 > 0x00)
		{
			uint32 esi_236 = eax_93 - 0x08 >> 0x01;
			do
			{
				ui32 eax_239 = (word32) *edx_100;
				edi_101 = eax_239 & 0xF000;
				if ((eax_239 & 0xF000) == 0x3000)
				{
					struct Eq_96 * eax_251 = (eax_239 & 0x0FFF) + ecx_108->dw0000;
					eax_251->dw400F10 = eax_251->dw400F10 + 4030730000;
				}
				edx_100 = edx_100 + 0x01;
				esi_236 = esi_236 - 0x01;
			} while (esi_236 != 0x00);
		}
		Eq_74 eax_104 = ecx_108->t0004;
		up32 edx_107 = eax_104 + dwLoc08_112 / 0x04;
		ecx_108 = ecx_108 + eax_104;
		dwLoc08_112 = edx_107;
	} while (edx_107 < 228);
	struct Eq_124 * esi_113 = &globals->t401C84;
	struct Eq_124 * dwLoc08_114 = &globals->t401C84;
	word32 * edi_115 = edi_101 * 0x02;
	if (globals->dw401C94 != 0x00)
	{
		do
		{
			word32 edx_153 = esi_113->dw000C;
			dwLoc1C_137 = edx_153 + 0x00400F10;
			eax_104 = LoadLibraryA(edx_153 + 0x00400F10);
			ecx_108 = ecx_108 * 0x03;
			if (eax_104 != null)
			{
				word32 ebx_185 = esi_113->dw0000;
				if (ebx_185 == 0x00)
					ebx_185 = esi_113->dw0010;
				word32 * ebx_191 = ebx_185 + 0x00400F10;
				edi_115 = esi_113->dw0010 + 0x00400F10;
				if (*ebx_191 != 0x00)
				{
					do
					{
						int32 eax_207 = *ebx_191;
						word16 ax_208 = (word16) eax_207;
						if (eax_207 < 0x00)
							dwLoc1C_137 = (word32) ax_208;
						else
						{
							ecx_108 = eax_207 + 0x00400F12;
							dwLoc1C_137 = eax_207 + 0x00400F12;
						}
						Eq_221 eax_217 = GetProcAddress(eax_104, dwLoc1C_137);
						*edi_115 = (word32) eax_217;
						ebx_191 = ebx_191 + 0x01;
						eax_104 = (Eq_74) (ebx_191 + eax_217 * 0x04);
						edi_115 = edi_115 + 0x01;
					} while (*ebx_191 != 0x00);
					esi_113 = dwLoc08_114;
				}
			}
			esi_113 = esi_113 + 0x01;
			dwLoc08_114 = esi_113;
		} while (esi_113->dw0010 != 0x00);
	}
	fn00401960(eax_104, ecx_108, &globals->t401960, esi_113, edi_115, es, dwLoc1C_137, dwLoc1A, rArg0);
	ExitProcess(0x00);
}

// 00401960: FpuStack real64 fn00401960(Register Eq_74 eax, Register (ptr32 Eq_66) ecx, Register (ptr32 Eq_139) edx, Register (ptr32 Eq_124) esi, Register (ptr32 word32) edi, Register (ptr16 Eq_142) es, Stack Eq_2 dwArg00, Stack word32 dwArg02, FpuStack real64 rArg0)
real64 fn00401960(HMODULE eax, Eq_66 * ecx, Eq_139 * edx, Eq_124 * esi, word32 * edi, Eq_142 * es, Eq_2 dwArg00, word32 dwArg02, real64 rArg0)
{
	Eq_2 ebx_113 = dwArg00;
	Eq_243 bl_105 = (byte) dwArg00;
	if (Z && ecx != (struct Eq_66 *) 0x01)
	{
		struct Eq_249 * ecx_111;
		ui8 cl_103;
		edx->dwD68383FC = ~0x6644E034;
		Eq_2 ecx_87 = (union Eq_2 *) 2732548724;
		*edi = (word32) (*edi | dh);
		Eq_266 eax_112 = eax - 0x664F8D01 - C;
		byte cl_88 = (byte) ecx_87;
		if (*edi > 0x00)
		{
			eax_112 = edx->t0000;
			byte v26_149 = Mem92[fs:eax_112 + 0x00:byte] + 0x02 + (Mem92[esi + 0x00:byte] <u Mem92[edi + 0x00:byte]);
			fs->*eax_112 = v26_149;
			Eq_350 SCZO_151 = cond(v26_149);
			(union Eq_350 *) 2732548723 = (union Eq_350 *) SCZO_151;
			struct Eq_249 * v28_165 = *((word32) ecx_87 + (ecx_87 - (struct Eq_355 *) 0x01));
			Mem166[ecx_87 - 0x01 + ecx_87:word32] = ecx_87 - 0x01;
			__wrmsr(v28_165, eax_112);
			esi = (struct Eq_124 *) ((char *) &esi->dw0000 + 0x01);
			bool C_152 = (bool) SCZO_151;
			ebx_113 = ecx_87;
			bl_105 = (byte) ecx_87;
			ecx_111 = v28_165;
			cl_103 = (byte) v28_165;
			*(v28_165 - 0x48) = __rcl(*(v28_165 - 0x48), 0x01, C_152);
		}
		else
		{
			cl_103 = cl_88 ^ dl;
			ecx_111 = (struct Eq_249 *) DPB(ecx_87, cl_103, 0);
		}
		Mem117[Mem92[eax_112 + 1630727305:segptr32] + ebx_113:word32] = 3449500343;
		Eq_243 v35_118 = esi->a005B[ecx_111].t0000;
		esi->a005B[ecx_111].t0000 = bl_105;
		struct Eq_409 * ebx_121 = DPB(ebx_113, v35_118, 0);
		ebx_121->b4CAACE06 = 0x9A;
		ebx_121->t0000 = eax_112;
		ecx_111->b541A34DD = cl_103;
	}
	else
	{
		ptr32 v8_15 = *((word32) dwArg00 + (ecx - 0x01));
		Mem16[ecx - 0x01 + dwArg00:word32] = ecx - 0x01;
		if (!O)
			__syscall(0x04);
		(v8_15 - 0x77)[esi].dw0000 = ~0x297C6869;
		word32 esp_41;
		word32 ebx_42;
		word32 ebp_43;
		word32 eax_44;
		word32 ecx_45;
		bool Z_46;
		struct Eq_300 * es_47;
		bool O_48;
		bool FPUF_49;
		real64 rArg0_50;
		word32 edx_51;
		bool C_52;
		byte SCZO_53;
		word32 esi_54;
		byte ah_55;
		word32 edi_56;
		byte SZO_57;
		byte dh_58;
		byte bl_59;
		struct Eq_313 * fs_60;
		byte SCZDOP_61;
		byte al_62;
		bool D_63;
		byte cl_64;
		byte dl_65;
		fnCEA64A9F();
		return rArg0_50;
	}
}

