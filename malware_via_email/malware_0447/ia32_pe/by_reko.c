// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_13;
	byte SCZO_14;
	word32 esi_15;
	byte SZO_16;
	bool C_17;
	word32 eax_18;
	bool Z_19;
	word32 ebx_20;
	word32 ebp_21;
	word32 edi_22;
	word32 edx_23;
	word32 ecx_24;
	byte cl_25;
	word16 ax_26;
	bool S_27;
	SHLWAPI.dll!StrChrA();
	if (eax_18 != 0x00)
		return 0x00;
	*(esp_13 - 0x04) = ebx_20;
	*(esp_13 - 0x08) = ebp_21;
	*(esp_13 - 0x0C) = edi_22;
	*(esp_13 - 0x10) = 0x0040406C;
	*(esp_13 - 0x14) = 0x00404074;
	*(esp_13 - 0x14) = (HMODULE *) LoadLibraryA(*(esp_13 - 0x14));
	Eq_62 eax_51 = GetProcAddress(*(esp_13 - 0x14), *(esp_13 - 0x10));
	*(esp_13 - 0x10) = 0x00;
	*(esp_13 - 0x14) = 0x00;
	*(esp_13 - 0x18) = 0x00;
	*(esp_13 - 0x1C) = 0x00;
	*(esp_13 - 0x20) = 0x00;
	int32 eax_68 = eax_51();
	*(esp_13 - 0x24) = ~0x00;
	*(esp_13 - 0x28) = ~0x00;
	Eq_56 ecx_112 = (struct HINSTANCE__ *) <invalid>;
	Eq_56 esi_116 = (struct HINSTANCE__ *) <invalid>;
	Eq_56 ebp_321 = eax_68 + 0x1C;
	if (AreAllAccessesGranted(*(esp_13 - 0x28), *(esp_13 - 0x24)) == 0x00)
		ebp_321 = eax_68 + 0x1C ^ 0x0E;
	*(esp_13 - 0x24) = esp_13 - 0x10;
	*(esp_13 - 0x28) = 0x40;
	*(esp_13 - 44) = 0x3000;
	*(esp_13 - 0x30) = 0x00401000;
	VirtualProtect(*(esp_13 - 0x30), *(esp_13 - 44), *(esp_13 - 0x28), *(esp_13 - 0x24));
	struct Eq_195 * eax_103 = null;
	do
	{
		if (esi_116 == ebp_321)
			esi_116 = null;
		ui8 cl_124 = (&esi_116->unused)[0x00101400] ^ eax_103[4204008];
		eax_103[4204008] = (struct Eq_195) (cl_124 ^ ~0x13);
		ecx_112 = DPB(ecx_112, cl_124 ^ ~0x13, 0);
		eax_103 = eax_103 + 0x01;
		esi_116 = (Eq_56) ((char *) &esi_116->unused + 0x01);
	} while (eax_103 < (struct Eq_195 *) 5152);
	*(esp_13 - 0x08) = 0x00402368;
	*(esp_13 - 0x0C) = 0x00;
	struct Eq_235 * ebx_134 = &globals->t4038C8;
	HMODULE * edi_136 = &globals->t402368;
	struct Eq_239 * ebp_137 = null;
	word32 * esi_141 = (word32 *) 0xF0402368;
	do
	{
		Eq_245 eax_149 = ebx_134->t0004;
		struct Eq_252 * ecx_153 = ecx_112 * 0x02 + 0x00402368;
		struct Eq_268 * edx_157 = (char *) &ebx_134->t0004 + 0x04;
		if (eax_149 - 0x08 >> 0x01 > 0x00)
		{
			uint32 ebp_292 = eax_149 - 0x08 >> 0x01;
			do
			{
				if ((edx_157->w0000 & 0xF000) == 0x3000)
				{
					ecx_153 = ((word32) edx_157->w0000 & 0x0FFF) + ebx_134->dw0000;
					ecx_153->dw402368 = ecx_153->dw402368 + 0xF0402368;
				}
				edx_157 = edx_157 + 0x01;
				ebp_292 = ebp_292 - 0x01;
			} while (ebp_292 != 0x00);
			ebp_137 = (struct Eq_239 *) *(esp_13 - 0x0C);
		}
		ebp_137 = ebp_137 + Mem142[ebx_134 + 0x04:word32];
		*(esp_13 - 0x0C) = (struct Eq_239 **) ebp_137;
		ecx_112 = (Eq_56) (ebx_134 + (ecx_153 * 0x04) / 0x08);
		ebx_134 = ebx_134 + Mem165[ebx_134 + 0x04:word32];
	} while (ebp_137 < (struct Eq_239 *) 228);
	*(esp_13 - 0x0C) = 0x004030C4;
	struct Eq_312 * ebx_173 = &globals->t4030C4;
	if (globals->dw4030D4 != 0x00)
	{
		do
		{
			edx_157 = (struct Eq_268 *) ((char *) edi_136 + ebx_173->dw000C);
			*(esp_13 - 0x24) = (struct Eq_268 **) edx_157;
			Eq_56 eax_206 = LoadLibraryA(*(esp_13 - 0x24));
			*(esp_13 - 0x04) = (HMODULE *) eax_206;
			ecx_112 = eax_206;
			if (eax_206 != null)
			{
				ptr32 ebp_231 = ebx_173->dw0000;
				if (ebp_231 == 0x00)
					ebp_231 = ebx_173->dw0010;
				Eq_361 eax_237 = *((char *) edi_136 + ebp_231);
				ebp_137 = (struct Eq_239 *) ((char *) edi_136 + ebp_231);
				esi_141 = (word32 *) ((char *) edi_136 + ebx_173->dw0010);
				if (eax_237 != 0x00)
				{
					while (true)
					{
						Eq_62 eax_260;
						if (eax_237 < 0x00)
						{
							*(esp_13 - 0x24) = (word32) ebp_137->w0000;
							*(esp_13 - 0x28) = (HMODULE *) ecx_112;
							eax_260 = GetProcAddress(*(esp_13 - 0x28), *(esp_13 - 0x24));
						}
						else
						{
							edx_157 = (struct Eq_268 *) ((char *) edi_136 + ((word32) eax_237 + 0x02));
							*(esp_13 - 0x24) = (struct Eq_268 **) edx_157;
							*(esp_13 - 0x28) = (HMODULE *) ecx_112;
							eax_260 = GetProcAddress(*(esp_13 - 0x28), *(esp_13 - 0x24));
						}
						*esi_141 = (word32) eax_260;
						ebp_137 = ebp_137 + 0x01;
						eax_237.u1 = ebp_137->w0000;
						edi_136 = (HMODULE *) *(esp_13 - 0x08);
						esi_141 = esi_141 + 0x01;
						if (eax_237 == 0x00)
							break;
						ecx_112 = (Eq_56) *(esp_13 - 0x04);
					}
					ebx_173 = (struct Eq_312 *) *(esp_13 - 0x0C);
				}
			}
			ebx_173 = ebx_173 + 0x01;
			*(esp_13 - 0x0C) = (struct Eq_312 **) ebx_173;
		} while (ebx_173->dw0010 != 0x00);
	}
	fn00402DB8(ecx_112, edx_157, ebx_173, ebp_137, esi_141, edi_136, dwLoc04);
	*(esp_13 - 0x24) = 0x00;
	ExitProcess(*(esp_13 - 0x24));
}

// 00402DB8: void fn00402DB8(Register Eq_56 ecx, Register (ptr32 Eq_268) edx, Register (ptr32 Eq_312) ebx, Register (ptr32 Eq_239) ebp, Register (ptr32 word32) esi, Register (ptr32 Eq_56) edi, Stack ui32 dwArg00)
void fn00402DB8(HMODULE ecx, Eq_268 * edx, Eq_312 * ebx, Eq_239 * ebp, word32 * esi, HMODULE * edi, ui32 dwArg00)
{
	int32 esi_12 = edx->a004E[edi] *s 0x5E;
	*edi = (HMODULE *) ecx;
	(byte *) 0x7F6D296C = (byte *) (byte) ecx;
	edx->dw21061381 = edx->dw21061381 | dwArg00;
	__wait();
	struct Eq_512 * eax_25 = DPB(ecx, 0x5A, 8);
	ptr32 esp_26 = eax_25->aC8D97BC8[eax_25].ptr0000;
	*(esp_26 - 0x04) = (struct Eq_512 **) eax_25;
	*(esp_26 - 0x08) = dwArg00;
	*(esp_26 - 0x0C) = (struct Eq_268 **) edx;
	*(esp_26 - 0x10) = (struct Eq_312 **) ebx;
	*(esp_26 - 0x14) = esp_26;
	*(esp_26 - 0x18) = (struct Eq_239 **) ebp;
	*(esp_26 - 0x1C) = esi_12;
	*(esp_26 - 0x20) = (char *) edi + 0x04;
}

