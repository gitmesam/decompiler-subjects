// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401019: Register word32 fn00401019(Register word32 eax, Register word32 edx, Register ui32 esi, Register out ptr32 ebpOut, Register out ptr32 esiOut)
word32 fn00401019(word32 eax, word32 edx, ui32 esi, ptr32 & ebpOut, ptr32 & esiOut)
{
	word32 ebp_20;
	*ebpOut = DPB(0x00120004, (word16) fp + 0x04, 0) + 0x00;
	word32 esi_21;
	*esiOut = (esi & 0x1D2CC28D | 565602565) >> 0x0D;
	return edx - 0x01;
}

// 00401111: Register Eq_28 Win32CrtStartup()
Eq_28 Win32CrtStartup()
{
	int32 esi_6;
	struct Eq_30 * ebp_104;
	fn00401019(eax, edx, esi, out ebp_104, out esi_6);
	struct Eq_39 * esp_1 = fp;
	byte al_15 = (byte) ebx;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	*ebx = *ebx + al_15;
	word16 si_52 = __ror((word16) (ebx + (esi_6 >> 0x1D)), 0x01);
	struct Eq_39 * edx_58 = fp;
	ptr32 edi_62 = dwArg00 + (ebx - 0x01);
	do
	{
		edx_58 = edx_58 + 0x01;
		byte * ecx_71 = edx_58->dw0000;
		si_52 = __rol(si_52, 0x06);
	} while (ecx_71 != ebx);
	word32 edi_87 = __rol(edi_62, 0x17);
	ui8 dl_90 = ebp_104->b0007 ^ 0x00;
	word32 edx_91 = (word32) dl_90;
	if (0x90 != edx_91)
	{
		word32 esp_259;
		word32 edx_260;
		word32 esi_261;
		byte SCZO_262;
		word32 edi_263;
		word32 ebx_264;
		word32 eax_265;
		byte al_266;
		word16 si_267;
		bool C_268;
		byte SZO_269;
		word32 ecx_270;
		bool Z_271;
		word32 ebp_272;
		byte dl_273;
		word16 dx_274;
		word16 cx_275;
		word16 ax_276;
		word16 di_277;
		comctl32.dll!ImageList_Replace();
		RegQueryValueA((struct HKEY__ *) 0x751CF59B, dwArg00, tArg04, tArg08);
		byte * eax_290 = __indw((word16) edx_260);
		__lock();
		byte al_291 = (byte) eax_290;
		*eax_290 = *eax_290 + al_291;
		*eax_290 = *eax_290 + al_291;
		(byte *) 0x77C5009C = (byte *) 0x77C5009C + 0x009C;
		(ui32 *) 321740271 = (ui32 *) 321740271 | 0x77C5009C;
		ebp_104 = (struct Eq_30 *) (fp + 0x08);
		*(fp - ~0x7F) = edi_263 - 4040370253;
		esp_1 = fp - ~0x7F;
	}
	__ror(0x90, 0x0A);
	struct Eq_281 * edi_119 = DPB(1210455, (word16) esp_1, 0) + 0x00;
	word32 eax_122 = 0x0040110B;
	word32 ecx_126 = globals->dw40110B;
	do
	{
		edi_119 = edi_119 + 0x01;
		eax_122 = ebp_104 + eax_122 / 0x08 + esp_1->dw0000 / 0x08;
		word32 edx_140 = edi_119->dw0000 - ecx_126;
	} while (edx_140 != 0x00);
	ui32 edx_155 = DPB(edx_140, *(edi_119 - 0x03), 0);
	struct Eq_39 ** esp_163 = esp_1 - 0x04;
	*esp_163 = (struct Eq_39 **) esp_1;
	struct Eq_39 * edi_165 = *esp_163;
	__rol(eax_122 + edx_140 - 2030342245, 0x03);
	word32 * ecx_172 = edi_165->dw0000;
	word32 edx_177 = globals->dw40104E;
	do
	{
		ecx_172 = (word32 *) ((char *) ecx_320 + 0x01);
		word32 * ecx_320 = ecx_172;
	} while ((*ecx_320 ^ edx_177) != 0x00);
	__ror((word16) (ebp_104 >> 0x03), 0x05);
	Eq_343 edx_219 = edx_155 << 0x10 >> 0x10;
	*esp_163 = (word32) edx_219 + 0x003F1338;
	__ror((word16) edx_219, 0x09);
	*(esp_163 - 0x04) = fs->ptr0000;
	fs->ptr0000 = esp_163 - 0x04;
	*(esp_163 - 0x08) = 0x00;
	int32 eax_236 = ~((word32) edx_219 + 0x003F1338 >> 0x1A);
	Eq_28 eax_249 = DPB(eax_236, __ror((word16) eax_236, 0x04), 0);
	*(esp_163 - 0x0C) = ecx_172;
	__ror(0x00, 0x0D);
	return eax_249;
}

