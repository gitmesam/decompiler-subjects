// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_13;
	byte SCZO_14;
	word32 esi_15;
	byte SZO_16;
	bool C_17;
	word32 eax_18;
	bool Z_19;
	word32 ebx_20;
	word32 ebp_21;
	word32 edi_22;
	word32 edx_23;
	byte cl_24;
	byte dl_25;
	word32 ecx_26;
	word16 ax_27;
	bool S_28;
	byte bl_29;
	SHLWAPI.dll!StrChrA();
	if (eax_18 != 0x00)
		return 0x00;
	*(esp_13 - 0x04) = ebx_20;
	*(esp_13 - 0x08) = ebp_21;
	*(esp_13 - 0x0C) = edi_22;
	*(esp_13 - 0x10) = 0x0040406C;
	*(esp_13 - 0x14) = 0x00404074;
	*(esp_13 - 0x14) = (HMODULE *) LoadLibraryA(*(esp_13 - 0x14));
	Eq_64 eax_53 = GetProcAddress(*(esp_13 - 0x14), *(esp_13 - 0x10));
	*(esp_13 - 0x10) = 0x00;
	*(esp_13 - 0x14) = 0x00;
	*(esp_13 - 0x18) = 0x00;
	*(esp_13 - 0x1C) = 0x00;
	*(esp_13 - 0x20) = 0x00;
	int32 eax_70 = eax_53();
	*(esp_13 - 0x24) = ~0x00;
	*(esp_13 - 0x28) = ~0x00;
	struct Eq_123 * esi_119 = (struct Eq_123 *) <invalid>;
	struct Eq_123 * edi_370 = eax_70 + 0x1C;
	if (AreAllAccessesGranted(*(esp_13 - 0x28), *(esp_13 - 0x24)) == 0x00)
		edi_370 = eax_70 + 0x1C ^ 0x0E;
	*(esp_13 - 0x24) = esp_13 - 0x10;
	*(esp_13 - 0x28) = 0x40;
	*(esp_13 - 44) = 0x3000;
	*(esp_13 - 0x30) = 0x00401000;
	VirtualProtect(*(esp_13 - 0x30), *(esp_13 - 44), *(esp_13 - 0x28), *(esp_13 - 0x24));
	struct Eq_196 * eax_108 = null;
	do
	{
		if (esi_119 == edi_370)
			esi_119 = null;
		eax_108[1051014] = (struct Eq_196) (esi_119[0x00405000] ^ eax_108[1051014] ^ ~0x01);
		struct Eq_123 * esi_127 = esi_119 + 0x01;
		if (esi_127 == edi_370)
			esi_127 = null;
		eax_108->b402619 = esi_127[0x00405000] ^ eax_108->b402619 ^ ~0x01;
		struct Eq_123 * esi_137 = esi_127 + 0x01;
		if (esi_137 == edi_370)
			esi_137 = null;
		eax_108->b40261A = esi_137[0x00405000] ^ eax_108->b40261A ^ ~0x01;
		struct Eq_123 * esi_147 = esi_137 + 0x01;
		if (esi_147 == edi_370)
			esi_147 = null;
		eax_108 = eax_108 + 0x01;
		eax_108->b402617 = esi_147[0x00405000] ^ eax_108->b40261B ^ ~0x01;
		esi_119 = esi_147 + 0x01;
	} while (eax_108 < (struct Eq_196 *) 5152);
	*(esp_13 - 0x0C) = 0x00;
	struct Eq_278 * edi_165 = &globals->t4038F8;
	up32 ebx_167 = 0x00;
	do
	{
		Eq_301 eax_180 = edi_165[0x01];
		Eq_291 ecx_186 = edi_165 + 0x02;
		if (eax_180 - 0x08 >> 0x01 > 0x00)
		{
			esi_119 = eax_180 - 0x08 >> 0x01;
			do
			{
				if ((ecx_186->unused & 0xF000) == 0x3000)
				{
					struct Eq_312 * eax_353 = ((word32) ecx_186->unused & 0x0FFF) + edi_165->dw0000;
					eax_353->dw402398 = eax_353->dw402398 + 0xF0402398;
				}
				ecx_186 = (Eq_291) (ecx_186 + 0x01);
				esi_119 = esi_119 - 0x01;
			} while (esi_119 != null);
			ebx_167 = *(esp_13 - 0x0C);
		}
		ebx_167 = (word32) edi_165[0x01].dw0000 + ebx_167;
		*(esp_13 - 0x0C) = ebx_167;
		esi_119 = (struct Eq_123 *) (ecx_186 + esi_119 * 0x04);
		edi_165 = edi_165 + Mem197[edi_165 + 0x04:word32];
	} while (ebx_167 < 228);
	*(esp_13 - 0x08) = 0x004030F4;
	struct Eq_345 * ebx_202 = &globals->t4030F4;
	byte bl_203 = 244;
	cup16 * edx_205 = (cup16 *) 0xB140B1F8;
	if (globals->dw403104 != 0x00)
	{
		do
		{
			word32 ecx_237 = ebx_202->dw000C;
			*(esp_13 - 0x24) = ecx_237 + 0x00402398;
			Eq_58 eax_242 = LoadLibraryA(*(esp_13 - 0x24));
			*(esp_13 - 0x0C) = (HMODULE *) eax_242;
			ecx_186 = ecx_237 + 0x00402398;
			if (eax_242 != null)
			{
				word32 edi_267 = ebx_202->dw0000;
				if (edi_267 == 0x00)
					edi_267 = ebx_202->dw0010;
				edi_165 = edi_267 + 0x00402398;
				ecx_186 = eax_242 + (ecx_237 + 0x00402398) * 0x08;
				esi_119 = ebx_202->dw0010 + 0x00402398;
				if (edi_165->dw0000 != 0x00)
				{
					do
					{
						int32 eax_291 = edi_165->dw0000;
						word16 ax_292 = (word16) eax_291;
						if (eax_291 < 0x00)
						{
							edx_205 = (word32) ax_292;
							word32 eax_314 = *(esp_13 - 0x0C);
							*(esp_13 - 0x24) = (cup16 **) edx_205;
							*(esp_13 - 0x28) = eax_314;
						}
						else
						{
							edx_205 = (cup16 *) *(esp_13 - 0x0C);
							*(esp_13 - 0x24) = eax_291 + 0x0040239A;
							*(esp_13 - 0x28) = (cup16 **) edx_205;
							ecx_186 = eax_291 + 0x0040239A;
						}
						esi_119->dw0000 = (word32) GetProcAddress(*(esp_13 - 0x28), *(esp_13 - 0x24));
						edi_165 = edi_165 + 0x01;
						esi_119 = esi_119 + 0x04;
					} while (edi_165->dw0000 != 0x00);
					ebx_202 = (struct Eq_345 *) *(esp_13 - 0x08);
				}
			}
			ebx_202 = ebx_202 + 0x01;
			*(esp_13 - 0x08) = (struct Eq_345 **) ebx_202;
			bl_203 = (byte) ebx_202;
		} while (ebx_202->dw0010 != 0x00);
	}
	fn00402DE8(&globals->t402DE8, ecx_186, edx_205, bl_203, &globals->t402398, esi_119, edi_165);
	*(esp_13 - 0x20) = 0x00;
	ExitProcess(*(esp_13 - 0x20));
}

// 00402DE2: void fn00402DE2(Register (ptr32 Eq_278) eax, Register Eq_291 ecx, Register (ptr32 cup16) edx, Register byte bl, Register (ptr32 Eq_361) ebp, Register (ptr32 Eq_123) esi, Register word16 di)
void fn00402DE2(Eq_278 * eax, HMODULE ecx, cup16 * edx, byte bl, Eq_361 * ebp, Eq_123 * esi, word16 di)
{
	struct Eq_278 * eax_12 = DPB(edi, __aad((word16) edi), 0);
	fn00402DE8(eax_12, ecx, edx, bl, ebp, esi, eax);
}

// 00402DE8: void fn00402DE8(Register (ptr32 Eq_278) eax, Register Eq_291 ecx, Register (ptr32 cup16) edx, Register byte bl, Register (ptr32 Eq_361) ebp, Register (ptr32 Eq_123) esi, Register (ptr32 Eq_278) edi)
void fn00402DE8(Eq_278 * eax, HMODULE ecx, cup16 * edx, byte bl, Eq_361 * ebp, Eq_123 * esi, Eq_278 * edi)
{
	ebp->dw6576ABC7 = ebp->dw6576ABC7 << 0x01;
	if (ecx == null)
		fn00402DE2(eax, ecx, edx, bl, ebp, esi, di);
	else
	{
		__bound(fp, *(edx - 22));
		__outw(dx, DPB(ax, al ^ 0x7F, 0));
		cup16 v16_34 = *edx - dx;
		*edx = v16_34;
		edi->dw0000 = esi->dw0000;
		__aad((word16) (DPB(eax, al ^ 0x7F, 0) - ~0x3C050C7F - (v16_34 < 0x00)));
	}
}

