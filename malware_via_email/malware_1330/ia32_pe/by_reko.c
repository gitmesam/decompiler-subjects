// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401021: Register int32 fn00401021(Register (ptr32 byte) eax, Register int32 ecx, Register word32 esi, Register (ptr32 byte) edi, Register out ptr32 edxOut, Register out ptr32 ebpOut)
int32 fn00401021(byte * eax, int32 ecx, word32 esi, byte * edi, ptr32 & edxOut, ptr32 & ebpOut)
{
	word16 cx_13 = (word16) fp;
	int32 * edx_18 = DPB(0x00120004, cx_13 + 0x04, 0);
	int32 ecx_22 = *edx_18;
	word32 ebp_26;
	*ebpOut = ecx_22;
	word32 edx_29;
	*edxOut = DPB(edx_18, __ror(cx_13 + 0x04, 0x07), 0);
	return ecx_22;
}

// 004011F8: Register Eq_32 Win32CrtStartup()
Eq_32 Win32CrtStartup()
{
	__rol(edx, 0x02);
	byte al_13 = (byte) ebx;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	*ebx = *ebx + al_13;
	word32 edx_51;
	word32 ebp_52;
	ui32 ecx_53 = fn00401021(ebx, ecx >> 0x07, 921056765 - esi, ebx, out edx_51, out ebp_52);
	Eq_155 esi_55 = fp;
	do
	{
		ui32 eax_63 = *esi_55;
		esi_55 = (word32) esi_55 + 0x01;
		ecx_53 = __ror(ecx_53, 0x0A);
	} while (eax_63 != 0x00);
	byte * ecx_82 = ~~0x07 + ebp_52;
	ui32 eax_85 = __ror(eax_63, 0x12);
	byte dl_88 = 0x90 - *ecx_82;
	word32 edx_89 = DPB(0x90, dl_88, 0);
	Eq_188 esi_91 = esi_55 - (union Eq_189 *) 0x6CC206AD | ~0x1B035D12;
	if (edx_89 == 0x00)
	{
		word16 ax_157 = (word16) fp;
		struct Eq_197 * edi_165 = DPB(1233235, ax_157, 0) + 0x00;
		__rol(ax_157, 0x04);
		ui32 ecx_169 = 0x004010E8;
		ui32 eax_172 = globals->dw40110D;
		do
		{
			edi_165 = edi_165 + 0x01;
			ecx_169 = edi_165 + ecx_169 ^ edi_165;
			word32 edx_185 = edi_165->dw0000 - eax_172;
		} while (edx_185 != 0x00);
		__ror(ecx_169, 0x02);
		ui32 eax_194 = ~(eax_172 | 0x93D50305);
		ui32 edx_200 = DPB(edx_185, edi_165->wFFFFFFFD, 0);
		__rol(&edi_165->wFFFFFFFD + DPB(eax_194, __rol((word16) eax_194, 0x0C), 0), 0x1E);
		ui32 edi_226 = globals->dw40104D;
		Eq_32 edx_220 = dwArg00;
		ui32 esi_228 = edi_226 & 0x0040104D;
		do
		{
			int32 eax_236 = *edx_220;
			esi_228 = esi_228 - eax_236;
			edx_220 = (word32) edx_220 + 0x01;
			word16 si_243 = (word16) esi_228;
			word16 ax_248 = (word16) (eax_236 >> 0x11);
		} while ((eax_236 ^ edi_226) != 0x00);
		int32 eax_258 = DPB(eax_236 >> 0x11, __ror(ax_248, 0x0C), 0);
		__ror(si_243, 0x0A);
		fs->ptr0000 = fp - 0x08;
		__ror((word16) (((edx_200 << 0x10 >> 0x10) + 4133933 ^ eax_258) << 11), 0x04);
		return edx_220;
	}
	else
	{
		word32 esp_127;
		word32 ecx_128;
		byte SCZO_129;
		word32 ebx_130;
		word32 edi_131;
		Eq_219 esi_132;
		word32 eax_133;
		word32 edx_134;
		bool C_135;
		byte al_136;
		word16 di_137;
		byte SZO_138;
		bool Z_139;
		word32 ebp_140;
		byte dl_141;
		word16 dx_142;
		word16 cx_143;
		word16 ax_144;
		word16 si_145;
		struct Eq_233 * fs_146;
		comctl32.dll!ImageList_GetDragImage();
		return RegLoadKeyW(esi_132, esi_91, (WCHAR *) 0x56EF2652);
	}
}

