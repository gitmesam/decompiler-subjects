// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401010: void fn00401010(Register (arr Eq_6464) edi, Stack uint32 dwArg04)
void fn00401010(Eq_6464 edi[], uint32 dwArg04)
{
	Eq_4 eax_18 = (uint32) (0x40 /u dwArg04);
	Eq_8 ebp_147 = 0x00;
	Eq_4 esi_146 = eax_18;
	if (!DPB(CZ, false, 0))
	{
		uint32 edx_89 = (uint32) ((uint64) (uint32) edi % 0x0A);
		Eq_20 bLoc19_133 = 0x00;
		uint32 edx_103 = (uint32) ((uint64) (uint32) edi % 0x0F);
		uint32 edx_114 = (uint32) ((uint64) (uint32) edi % 0x07);
		uint32 edx_125 = (uint32) ((uint64) (uint32) edi % 0x12);
		do
		{
			Eq_8 ebx_151 = ebp_147;
			Eq_8 dwLoc18_153 = ebp_147;
			if (edx_89 == 0x1E)
			{
				Eq_49 eax_336 = GetDC(0x00);
				MoveToEx(eax_336, 0x0A, 0x0A, null);
				TextOutA(eax_336, 0x0A, 0x0A, 0x004030D8, 0x20);
				LineTo(eax_336, 100, 100);
				Polyline(eax_336, (POINT *) 0x00065464, 0x0A);
				ReleaseDC(0x00, eax_336);
				esi_146 = eax_18;
			}
			else
				ebx_151 = (word32) ebp_147.u0 + ((word32) (bLoc19_133 != 0x00) * 0x08 + 0x09);
			if (edx_103 == 0x1E)
			{
				Eq_49 eax_290 = GetDC(0x00);
				SelectObject(eax_290, CreatePen(0x01, 0x01, 0x000A0A0A));
				DeleteDC(CreateCompatibleDC(eax_290));
				ReleaseDC(0x00, eax_290);
				esi_146 = eax_18;
			}
			else if (ebx_151 > esi_146 - 0x01)
				ebx_151 = (uint32) ((uint64) (uint32) ebx_151 % esi_146);
			if (edx_114 == 0x19)
				SetEvent(CreateEventA(null, 0x01, 0x01, 0x004030E8));
			else
				bLoc19_133 = bLoc19_133 == 0x00;
			byte cl_218;
			if (edx_125 == 0x59)
			{
				SetWindowPos(GetForegroundWindow(), 0x00, 0x0A, 0x0A, 0x14, 0x14, 0x04);
				goto l0040118F;
			}
			if (dwArg04 == 0x01)
			{
				cl_218 = (byte) (word32) Mem0[edi + ebp_147:byte];
				goto l0040119A;
			}
			dwLoc18_153 = edi[ebp_147];
l0040118F:
			if (dwArg04 == 0x01)
			{
				cl_218 = bLoc18;
l0040119A:
				word32 eax_222 = ebx_151 + edi;
				Mem225[edi + ebp_147:byte] = Mem0[eax_222 + 0x00:byte];
				*eax_222 = cl_218;
			}
			else
			{
				union Eq_8 * eax_242 = edi + ebx_151;
				edi[ebp_147] = *eax_242;
				*eax_242 = (union Eq_8 *) dwLoc18_153;
			}
			Eq_214 ebp_203 = (word32) ebp_147.u0 + 0x01;
			ebp_147 = (word32) ebp_203 + 0x01;
		} while ((word32) ebp_203 + 0x01 < esi_146);
	}
}

// 004011CA: Register word32 fn004011CA(Stack (ptr32 Eq_224) dwArg04, Stack Eq_225 dwArg08, Stack uint32 dwArg0C)
word32 fn004011CA(Eq_224 * dwArg04, HMENU dwArg08, uint32 dwArg0C)
{
	Eq_225 esi_25 = null;
	if (dwArg08 > null)
	{
		do
		{
			fn00401010(esi_25 + dwArg04, dwArg0C);
			esi_25 = (Eq_225) (esi_25 + 0x0040);
		} while (esi_25 < dwArg08);
	}
	return ebx;
}

// 004011F1: void fn004011F1(Register (ptr32 Eq_224) ebx, Stack Eq_225 dwArg04, Stack Eq_225 dwArg08)
void fn004011F1(Eq_224 * ebx, HMENU dwArg04, HMENU dwArg08)
{
	struct Eq_224 * ebx_27 = fn004011CA(fn004011CA(ebx, dwArg04, 0x01), dwArg04, 0x04);
	word32 esi_33 = Mem0[ebx_27 + 0x3C:word32] + ebx_27;
	fn004019F1(dwArg08, ebx_27, esi_33->t0054);
	int32 dwArg04_42 = dwArg04 & 0x00;
	word32 eax_45 = esi_33 + ((word32) esi_33->w0014 + 0x18) / 88;
	if (0x00 < esi_33->w0006)
	{
		struct Eq_279 * edi_64 = eax_45 + 0x14;
		do
		{
			fn004019F1(dwArg08 + *(edi_64 - 0x08), ebx_27 + edi_64->dw0000, *(edi_64 - 0x04));
			int32 v18_78 = dwArg04_42 + 0x01;
			edi_64 = edi_64 + 0x01;
			dwArg04_42 = v18_78;
		} while (v18_78 < (word32) esi_33->w0006);
	}
}

// 0040125C: Register word32 fn0040125C(Register (ptr32 Eq_310) edi)
word32 fn0040125C(Eq_310 * edi)
{
	struct Eq_311 * ecx_10 = edi + edi->dw003C / 0x0040;
	ptr32 edx_13 = edi - ecx_10->dw0034;
	struct Eq_310 * eax_109 = edi + ecx_10->dw00A0 / 0x0040;
	if (eax_109 == edi)
		return 0x00;
	ui32 dwLoc0C_106 = dwLoc0C & 0x00;
	word32 esi_110 = eax_109->dw0004;
	if (esi_110 != 0x00)
	{
		do
		{
			uint32 edx_92 = esi_110 - 0x08;
			if (edx_92 >> 0x01 > 0x00)
			{
				word16 * dwLoc08_117 = &eax_109->dw0004 + 0x01;
				uint32 dwLoc10_118 = edx_92 >> 0x01;
				do
				{
					ui32 edx_123 = (word32) *dwLoc08_117;
					if ((word16) (edx_123 & 0xF000) == 0x3000)
					{
						word32 * edx_145 = edi + (eax_109->dw0000 + (edx_123 & 0x0FFF)) / 0x0040;
						*edx_145 = *edx_145 + edx_13;
					}
					uint32 v20_138 = dwLoc10_118 - 0x01;
					dwLoc08_117 = dwLoc08_117 + 0x01;
					dwLoc10_118 = v20_138;
				} while (v20_138 != 0x00);
			}
			ui32 v18_105 = dwLoc0C_106 + esi_110;
			eax_109 = edi + (ecx_10->dw00A0 + v18_105) / 0x0040;
			dwLoc0C_106 = v18_105;
			esi_110 = eax_109->dw0004;
		} while (esi_110 != 0x00);
	}
	return 0x01;
}

// 004012F0: Register (ptr32 Eq_395) fn004012F0(Register (ptr32 Eq_395) eax)
Eq_395 * fn004012F0(Eq_395 * eax)
{
	if (eax->b0000 == 0x01)
	{
		eax = &eax->b0001;
		byte * ecx_20 = &eax->b0001;
		if (eax->b0001 != 0x00)
		{
			do
			{
				byte dl_29;
				byte dl_23 = *ecx_20;
				if (dl_23 != 0x00)
					dl_29 = dl_23 + 0x1E;
				else
					dl_29 = 0x00;
				*ecx_20 = dl_29;
				ecx_20 = ecx_20 + 0x01;
			} while (*ecx_20 != 0x00);
		}
	}
	return eax;
}

// 00401313: void fn00401313()
void fn00401313()
{
}

// 00401319: Register Eq_225 fn00401319(Register (ptr32 Eq_430) ebp, Stack Eq_225 dwArg04, Stack Eq_225 dwArg08, Stack Eq_225 dwArg0C)
HMENU fn00401319(Eq_430 * ebp, HMENU dwArg04, HMENU dwArg08, HMENU dwArg0C)
{
	Eq_225 eax_133;
	if (dwArg04 != null)
	{
		word32 eax_98 = Mem0[dwArg04 + 0x3C:word32] + dwArg04;
		if (eax_98 != null)
		{
			Eq_225 eax_103 = dwArg04 + eax_98->dw0078;
			if (eax_103 != dwArg04)
			{
				uint32 ecx_113 = eax_103[0x0014];
				uint32 edx_109 = eax_103[0x0018];
				word16 ecx_111[] = Mem0[eax_103 + 0x24:word32] + dwArg04;
				word32 edi_114[] = Mem0[eax_103 + 0x1C:word32] + dwArg04;
				word32 ebx_115[] = Mem0[eax_103 + 0x20:word32] + dwArg04;
				uint32 dwLoc08_118 = ecx_113;
				if (ecx_113 <= edx_109)
					dwLoc08_118 = edx_109;
				if (dwArg08 < null)
				{
					uint32 edx_128 = (dwArg08 & 0x7FFFFFFF) - eax_103[0x0010];
					if (edx_128 < ecx_113)
					{
						eax_133 = (Eq_225) (dwArg04 + edi_114[edx_128]);
						return eax_133;
					}
				}
				else
				{
					uint32 eax_135 = 0x00;
					uint32 dwArg04_136 = 0x00;
					if (dwLoc08_118 > 0x00)
					{
						while (true)
						{
							uint32 ecx_146 = (word32) ecx_111[eax_135];
							if (eax_135 >= edx_109 || ecx_146 >= ecx_113)
								break;
							if (fn00401523(dwArg08, dwArg04 + ebx_115[dwArg04_136]) != 0x00)
							{
								up32 * ebx_171 = edi_114 + ecx_146;
								up32 ecx_173 = *ebx_171;
								up32 eax_174 = eax_98->dw0078;
								if (ecx_173 >= eax_174)
								{
									up32 edx_183 = eax_98->dw007C + eax_174;
									if (ecx_173 < edx_183)
									{
										byte * eax_186 = dwArg04 + ecx_173;
										do
										{
											byte dl_189 = *eax_186;
											eax_186 = eax_186 + 0x01;
										} while (dl_189 != 0x2E);
										ptr32 esp_207;
										word32 ebp_208;
										byte SCZO_209;
										ui32 * ebx_210;
										ui32 esi_211;
										<anonymous> ** edi_212;
										byte SZO_213;
										bool C_214;
										bool Z_215;
										Eq_225 eax_216;
										word32 ecx_217;
										word32 edx_218;
										byte CZ_219;
										bool S_220;
										byte dl_221;
										dwArg0C[0x08]();
										if (eax_216 == null)
											break;
										ui32 eax_226 = *ebx_210;
										*(esp_207 - 0x04) = eax_186 - eax_226 - esi_211 - 0x01;
										struct Eq_224 * ecx_235 = eax_226 + esi_211;
										fn004019F1(eax_216, ecx_235, dwArg00);
										*(esp_207 - 0x04) = (<anonymous> ***) edi_212;
										*(esp_207 - 0x08) = (byte **) eax_186;
										*(esp_207 - 0x0C) = (HMENU *) eax_216;
										struct Eq_601 * esp_251;
										struct Eq_430 * ebp_252;
										byte SCZO_253;
										word32 ebx_254;
										word32 esi_255;
										struct Eq_606 * edi_256;
										byte SZO_257;
										bool C_258;
										bool Z_259;
										word32 eax_260;
										word32 ecx_261;
										word32 edx_262;
										byte CZ_263;
										bool S_264;
										byte dl_265;
										(*edi_212)();
										*(esp_251 - 0x04) = eax_260;
										Eq_225 eax_268 = fn00401319(ebp_252, dwArg00, eax_216, eax_186 & 0x00);
										esp_251->dw0004 = ebx_254;
										esp_251->t0000 = eax_268;
										Eq_225 dwArg08_277 = esp_251->t0000;
										esp_251->dw0004 = 0x8000;
										esp_251->t0000 = null;
										*(esp_251 - 0x04) = (HMENU *) eax_216;
										word32 esp_288;
										word32 ebp_289;
										byte SCZO_290;
										word32 ebx_291;
										word32 esi_292;
										word32 edi_293;
										byte SZO_294;
										bool C_295;
										bool Z_296;
										word32 eax_297;
										word32 ecx_298;
										word32 edx_299;
										byte CZ_300;
										bool S_301;
										byte dl_302;
										edi_256->ptr000C();
										eax_133 = dwArg08_277;
										return eax_133;
									}
								}
								eax_133 = (Eq_225) (dwArg04 + ecx_173);
								return eax_133;
							}
							uint32 v16_162 = dwArg04_136 + 0x01;
							dwArg04_136 = v16_162;
							if (v16_162 >= dwLoc08_118)
								break;
							eax_135 = v16_162;
						}
					}
				}
			}
		}
	}
	eax_133 = null;
	return eax_133;
}

// 0040146E: Register word32 fn0040146E(Register (ptr32 Eq_430) ebp, Stack Eq_225 dwArg04, Stack Eq_225 dwArg08)
word32 fn0040146E(Eq_430 * ebp, HMENU dwArg04, HMENU dwArg08)
{
	word32 eax_103;
	struct Eq_676 * eax_11 = dwArg04 + ((word32) (dwArg04)[0x003C].dw003C + 0x003C);
	Eq_225 edx_108 = dwArg04;
	Eq_225 esi_115 = dwArg04 + eax_11->dw0000;
	if (esi_115 != dwArg04)
	{
		uint32 eax_53 = esi_115[0x0014];
		uint32 ecx_54 = esi_115[0x0018];
		ptr32 esp_117 = fp - 0x20;
		word32 edi_111 = Mem0[esi_115 + 0x1C:word32] + dwArg04;
		word16 ebx_112[] = Mem0[esi_115 + 0x24:word32] + dwArg04;
		uint32 dwLoc0C_217 = eax_53;
		if (eax_53 <= ecx_54)
			dwLoc0C_217 = ecx_54;
		uint32 eax_113 = 0x00;
		uint32 dwLoc08_110 = 0x00;
		if (dwLoc0C_217 > 0x00)
		{
			while (true)
			{
				if (eax_113 < esi_115[0x0014])
					eax_113 = (word32) ebx_112[eax_113];
				HMENU * ecx_121 = edi_111 + eax_113 * 0x04;
				word32 eax_123 = Mem0[ecx_121 + 0x00:word32] + edx_108;
				if (eax_123 != edx_108)
				{
					if (eax_123 > esi_115)
					{
						if (eax_123 <u Mem0[eax_11 + 0x04:word32] *s 0x28 + esi_115)
						{
							Eq_225 ecx_181 = eax_123;
							do
								ecx_181 = (Eq_225) (ecx_181 + 0x01);
							while (ecx_181->unused != 0x2E);
							ecx_181->unused.u1 = 0x00;
							HMENU * esp_189 = esp_117 - 0x04;
							*esp_189 = (HMENU *) dwArg08;
							*(esp_189 - 0x04) = ecx_181 + 0x01;
							*(esp_189 - 0x08) = (HMENU *) eax_123;
							ptr32 esp_197;
							struct Eq_430 * ebp_198;
							byte SCZO_199;
							word32 edx_200;
							word32 eax_201;
							bool Z_203;
							byte SZO_204;
							bool C_205;
							word32 ecx_206;
							byte CZ_209;
							dwArg08->unused();
							*(esp_197 - 0x04) = eax_201;
							eax_123 = fn00401319(ebp_198, dwArg00, dwArg04, dwArg08);
							esp_117 = esp_197 + 0x08;
						}
						edx_108 = dwArg04;
					}
					if (eax_123 == null)
					{
						eax_103 = 0x00;
						return eax_103;
					}
					*ecx_121 = (HMENU *) eax_123;
				}
				uint32 v15_137 = dwLoc08_110 + 0x01;
				dwLoc08_110 = v15_137;
				if (v15_137 >= dwLoc0C_217)
					break;
				eax_113 = v15_137;
			}
		}
		eax_103 = 0x01;
		return eax_103;
	}
	else
	{
		eax_103 = 0x01;
		return eax_103;
	}
}

// 00401523: Register Eq_225 fn00401523(Register Eq_225 eax, Register ui32 ecx)
HMENU fn00401523(HMENU eax, ui32 ecx)
{
	Eq_811 bl_9 = eax->unused == 0x01;
	if (bl_9 != 0x00)
		eax = (Eq_225) (eax + 0x01);
	Eq_225 eax_33;
	if (eax->unused != 0x02)
	{
		int32 esi_53 = ecx - eax;
		do
		{
			bool Z_68;
			byte cl_65;
			if (bl_9 != 0x00)
			{
				byte cl_81 = eax->unused;
				int32 edx_82 = (int32) cl_81;
				if (cl_81 != 0x00)
					edx_82 = edx_82 + 0x1E;
				cl_65 = (byte) eax[esi_53];
				Z_68 = (bool) cond((int32) cl_65 - edx_82);
			}
			else
			{
				cl_65 = (byte) eax[esi_53];
				Z_68 = (bool) cond(cl_65 - eax->unused);
			}
			if (Z_68)
			{
				eax_33 = null;
				return eax_33;
			}
			if (cl_65 == 0x00)
				break;
			eax = (Eq_225) (eax + 0x01);
		} while (eax->unused != 0x02);
	}
	eax_33 = (struct HMENU__ *) 0x01;
	return eax_33;
}

// 00401570: Register word32 fn00401570(Register (ptr32 Eq_430) ebp, Register (ptr32 Eq_870) esi, Stack Eq_225 dwArg04)
word32 fn00401570(Eq_430 * ebp, Eq_870 * esi, HMENU dwArg04)
{
	word32 eax_22;
	word32 eax_6 = Mem0[Mem0[esi + 0x3C:word32] + 0x80 + esi:word32] + esi;
	if (eax_6 == esi)
		eax_22 = 0x01;
	else
	{
		if (eax_6->dw0000 != 0x00)
		{
			struct Eq_870 * ebx_71 = eax_6;
			do
			{
				if (fn004015F4(esi + ebx_71->dw0010 / 0x0040, &ebx_71->dw0010 + 0x01, ebp, dwArg04, esi + ebx_71->dw000C / 0x0040, esi + ebx_71->dw0000 / 0x0040, esi, out ebx_71) == 0x00)
				{
					eax_22 = 0x00;
					goto l004015B9;
				}
			} while (ebx_71->dw0000 != 0x00);
		}
		eax_22 = 0x01;
l004015B9:
	}
	return eax_22;
}

// 004015C2: void fn004015C2(Register (ptr32 Eq_925) eax)
void fn004015C2(Eq_925 * eax)
{
	word32 esp_12;
	struct Eq_927 * eax_13;
	eax->ptr0008();
	eax_13->b0008 = 0x02;
	eax_13->b0001 = 111;
	eax_13->b0003 = 0x62;
	eax_13->b0006 = 101;
	eax_13->b0002 = 0x6D;
	eax_13->b0005 = 110;
	eax_13->b0000 = 0x43;
	eax_13->b0007 = 0x52;
	eax_13->b0004 = 0x69;
}

// 004015F4: Register Eq_225 fn004015F4(Register Eq_225 eax, Register ptr32 ebx, Register (ptr32 Eq_430) ebp, Register Eq_225 edi, Stack word32 dwArg04, Stack Eq_225 dwArg08, Stack (ptr32 Eq_870) dwArg0C, Register out (ptr32 word32) ebxOut)
HMENU fn004015F4(HMENU eax, ptr32 ebx, Eq_430 * ebp, HMENU edi, word32 dwArg04, HMENU dwArg08, Eq_870 * dwArg0C, word32 * & ebxOut)
{
	ptr32 esp_17;
	struct Eq_430 * ebp_18;
	word32 edi_21;
	byte SZO_22;
	bool C_23;
	bool Z_24;
	word32 ebx_25;
	byte SCZO_26;
	word32 ecx_27;
	bool S_28;
	word32 * esi_19;
	Eq_225 eax_115;
	edi[0x0010]();
	if (eax_115 != null)
	{
		*(esp_17 - 0x04) = ebx_25;
		word32 ebx_51 = dwArg08 - esi_19;
		while (true)
		{
			int32 * ecx_57 = esi_19 + ebx_51;
			int32 eax_102 = 0x00;
			if (ecx_57 != null)
				eax_102 = *ecx_57;
			if (esi_19 == null || *esi_19 == 0x00)
				break;
			if (ecx_57 != null)
			{
				*(esp_17 - 0x08) = edi_21;
				if (eax_102 >= 0x00)
					eax_102 = dwArg0C + (eax_102 + 0x02) / 0x0040;
				*(esp_17 - 0x0C) = eax_102;
				*(esp_17 - 0x10) = (HMENU *) eax_115;
				Eq_225 eax_109 = fn00401319(ebp_18, dwArg00, eax_115, dwArg08);
				if (eax_109 == null)
				{
					eax_115 = null;
					goto l0040164C;
				}
				*esi_19 = (word32) eax_109;
			}
			esi_19 = esi_19 + 0x01;
		}
		eax_115 = (struct HMENU__ *) 0x01;
l0040164C:
		word32 ebx_74;
		*ebxOut = *(esp_17 - 0x04);
	}
	return eax_115;
}

// 00401652: void fn00401652(Register (ptr32 Eq_1048) eax)
void fn00401652(Eq_1048 * eax)
{
	word32 esp_12;
	struct Eq_1050 * eax_13;
	eax->ptr0008();
	eax_13->b0000 = 0x43;
	eax_13->b0007 = 0x02;
	eax_13->b0002 = 101;
	eax_13->b0005 = 101;
	eax_13->b0003 = 0x61;
	eax_13->b0001 = 114;
	eax_13->b0006 = 0x52;
	eax_13->b0004 = 116;
}

// 00401680: Register (ptr32 Eq_870) fn00401680(Register (ptr32 Eq_870) eax, Stack Eq_225 dwArg04)
Eq_870 * fn00401680(Eq_870 * eax, HMENU dwArg04)
{
	word32 esi_13 = Mem0[Mem0[eax + 0x3C:word32] + 0x88 + eax:word32] + eax;
	if (esi_13 != eax)
	{
		ptr32 eax_39 = eax - dwArg04;
		if (eax_39 != 0x00)
		{
			up32 ebx_47 = 0x00;
			if (0x00 < esi_13->w000E)
			{
				struct Eq_1110 * edi_62 = &esi_13->dw0010 + 0x01;
				do
				{
					fn004019CC(esi_13 + ((edi_62->dw0000 & 0x7FFFFFFF) + 0x10) / 0x0040, esi_13, eax_39);
					edi_62 = edi_62 + 0x01;
					ebx_47 = ebx_47 + 0x01;
				} while (ebx_47 < (word32) esi_13->w000E);
			}
		}
	}
	return (struct Eq_870 *) 0x01;
}

// 004016D4: void fn004016D4(Register (ptr32 Eq_1136) eax)
void fn004016D4(Eq_1136 * eax)
{
	eax->b0000 = 0x47;
	eax->b0001 = 101;
	eax->b0005 = 0x67;
	eax->b0006 = 0x02;
	eax->b0002 = 116;
	eax->b0004 = 101;
	eax->b0003 = 0x52;
}

// 004016F0: void fn004016F0(Register (ptr32 Eq_1165) eax)
void fn004016F0(Eq_1165 * eax)
{
	word32 esp_12;
	struct Eq_1167 * eax_13;
	eax->ptr0008();
	eax_13->b0007 = 0x6C;
	eax_13->b0006 = 100;
	eax_13->b0003 = 0x33;
	eax_13->b0008 = 0x6C;
	eax_13->b0000 = 0x67;
	eax_13->b0001 = 100;
	eax_13->b0004 = 0x32;
	eax_13->b0005 = 0x2E;
	eax_13->b0002 = 0x69;
}

// 00401722: Register word32 fn00401722(Register (ptr32 Eq_1208) edx, Register (ptr32 Eq_430) ebp, Register ptr32 esi)
word32 fn00401722(Eq_1208 * edx, Eq_430 * ebp, ptr32 esi)
{
	word32 eax_10 = Mem0[Mem0[edx + 0x3C:word32] + 0x80 + edx:word32] + edx;
	if (eax_10 == edx)
		return 0x00;
	ui32 edi_157 = 0x00;
	struct Eq_1208 * ecx_146 = eax_10;
	do
	{
		word32 eax_106;
		if (ecx_234->dw0000 == 0x00)
			goto l00401789;
		ecx_146 = &ecx_234->dw0010 + 0x01;
		struct Eq_1208 * ecx_234 = ecx_146;
	} while (edx[ecx_234->dw000C / 0x0040] != 0x4B);
	word32 eax_151[] = edx + ecx_234->dw0010 / 0x0040;
	int32 ecx_152[] = edx + ecx_234->dw0000 / 0x0040;
	if (eax_151[0x00] != 0x00)
	{
		do
		{
			int32 ebx_158 = ecx_152[edi_157];
			if (ebx_158 >= 0x00)
			{
				struct Eq_1270 * ebx_168 = edx + ebx_158 / 0x0040;
				if (ebx_168->b0002 == 0x47 && (ebx_168->b0003 == 101 && (ebx_168->b0005 == 77 && ebx_168->b000B == 0x48)))
				{
					<anonymous> * eax_178 = eax_151[edi_157];
					ptr32 esp_199;
					word32 ebp_200;
					struct Eq_1298 * eax_201;
					word32 edx_202;
					byte SCZO_203;
					bool Z_204;
					byte SZO_205;
					bool C_206;
					word32 edi_207;
					word32 ecx_208;
					word32 ebx_209;
					bool S_210;
					byte bl_211;
					struct Eq_1309 * esi_212;
					eax_178();
					*(esp_199 - 0x04) = (struct Eq_1309 **) esi_212;
					fn00401829(eax_201, dwArg00);
					if (esi_212->dw0000 == ebx_209 || (esi_212->dw0010 == ebx_209 || (esi_212->dw0008 == ebx_209 || (esi_212->dw000C == ebx_209 || (esi_212->dw0004 == ebx_209 || esi_212->dw0014 == ebx_209)))))
						break;
					eax_106 = 0x01;
					return eax_106;
				}
			}
			edi_157 = edi_157 + 0x01;
		} while (eax_151[edi_157] != 0x00);
	}
l00401789:
	eax_106 = 0x00;
	return eax_106;
}

// 004017F7: void fn004017F7(Register (ptr32 Eq_1346) eax)
void fn004017F7(Eq_1346 * eax)
{
	word32 esp_12;
	struct Eq_1348 * eax_13;
	eax->ptr0008();
	eax_13->b0007 = 111;
	eax_13->b0008 = 0x02;
	eax_13->b0004 = 116;
	eax_13->b0000 = 0x43;
	eax_13->b0001 = 114;
	eax_13->b0002 = 101;
	eax_13->b0003 = 0x61;
	eax_13->b0005 = 101;
	eax_13->b0006 = 0x52;
}

// 00401829: void fn00401829(Register (ptr32 Eq_1298) edi, Stack (ptr32 Eq_1318) dwArg04)
void fn00401829(Eq_1298 * edi, Eq_1318 * dwArg04)
{
	word32 ecx_11 = Mem0[Mem0[edi + 0x3C:word32] + 0x78 + edi:word32] + edi;
	uint32 eax_25 = ecx_11->dw0014;
	uint32 edx_13 = ecx_11->dw0018;
	word16 eax_19[] = edi + ecx_11->dw0024 / 0x0040;
	word32 esi_26[] = edi + ecx_11->dw001C / 0x0040;
	word32 ebx_27[] = edi + ecx_11->dw0020 / 0x0040;
	uint32 dwLoc10_203 = eax_25;
	if (eax_25 <= edx_13)
		dwLoc10_203 = edx_13;
	uint32 eax_100 = 0x00;
	up32 dwLoc08_108 = 0x00;
	uint32 dwLoc0C_37 = 0x00;
	if (dwLoc10_203 > 0x00)
	{
		while (dwLoc08_108 < 0x06)
		{
			uint32 edx_72 = (word32) eax_19[eax_100];
			if (eax_100 >= ecx_11->dw0018 || edx_72 >= ecx_11->dw0014)
				return;
			struct Eq_1445 * eax_80 = edi + ebx_27[eax_100] / 0x0040;
			byte bl_81 = eax_80->b0000;
			word32 esi_83 = edi + esi_26[edx_72] / 0x0040;
			if (bl_81 == 0x47)
			{
				byte dl_173 = eax_80->b0001;
				if (dl_173 != 101)
					goto l00401910;
				if (eax_80->b0002 == 116 && (eax_80->b0003 == 77 && eax_80->b000F == 0x41))
				{
					dwArg04->dw0000 = esi_83;
					goto l004019B4;
				}
				if (dl_173 != 101 || (eax_80->b0002 != 116 || (eax_80->b0003 != 0x54 || (eax_80->b0004 != 0x69 || (eax_80->b0005 != 99 || (eax_80->b0007 != 0x43 || (eax_80->b000B != 116 || eax_80->b000C != 0x00)))))))
					goto l00401910;
				dwArg04->dw0014 = esi_83;
				goto l004019B4;
			}
l00401910:
			if (bl_81 == 0x56)
			{
				byte dl_132 = eax_80->b0001;
				if (dl_132 != 0x69)
					goto l0040198B;
				if (eax_80->b0002 == 114 && (eax_80->b0007 == 0x41 && (eax_80->b0008 == eax_80->b0009 && eax_80->b000C == 0x00)))
				{
					dwArg04->dw0008 = esi_83;
					goto l004019B4;
				}
				if (dl_132 != 0x69)
					goto l0040198B;
				if (eax_80->b0002 == 114 && (eax_80->b0007 == 0x50 && (eax_80->b0008 == 114 && eax_80->b000E == 0x00)))
				{
					dwArg04->dw0004 = esi_83;
					goto l004019B4;
				}
				if (dl_132 != 0x69 || (eax_80->b0002 != 114 || (eax_80->b0007 != 0x46 || (eax_80->b0009 != eax_80->b000A || eax_80->b000B != 0x00))))
					goto l0040198B;
				dwArg04->dw000C = esi_83;
				goto l004019B4;
			}
l0040198B:
			if (eax_80->b0000 == 0x4C && (eax_80->b0001 == 111 && (eax_80->b0002 == 0x61 && (eax_80->b0003 == 100 && (eax_80->b0004 == 0x4C && eax_80->b000B == 0x41)))))
			{
				dwArg04->dw0010 = esi_83;
l004019B4:
				dwLoc08_108 = dwLoc08_108 + 0x01;
			}
			uint32 v18_92 = dwLoc0C_37 + 0x01;
			dwLoc0C_37 = v18_92;
			if (v18_92 >= dwLoc10_203)
				return;
			eax_100 = v18_92;
		}
	}
}

// 004019CC: void fn004019CC(Register (ptr32 Eq_1115) eax, Register (ptr32 Eq_870) esi, Stack ptr32 dwArg04)
void fn004019CC(Eq_1115 * eax, Eq_870 * esi, ptr32 dwArg04)
{
	while (true)
	{
		ui32 ecx_6 = eax->dw0004;
		if ((ecx_6 & 0x80000000) == 0x00)
			break;
		eax = (struct Eq_1115 *) (esi + ((ecx_6 & 0x7FFFFFFF) + 0x10) / 0x0040);
	}
	word32 * eax_14 = esi + ecx_6 / 0x0040;
	*eax_14 = *eax_14 + dwArg04;
}

// 004019F1: void fn004019F1(Register Eq_225 eax, Register (ptr32 Eq_224) ecx, Stack Eq_225 dwArg04)
void fn004019F1(HMENU eax, Eq_224 * ecx, HMENU dwArg04)
{
	while (dwArg04 != null)
	{
		eax->unused.u1 = ecx->b0000;
		dwArg04 = dwArg04 - 0x01;
		eax = (Eq_225) (eax + 0x01);
		ecx = ecx + 0x01;
	}
}

// 00401A07: Register Eq_52 Win32CrtStartup()
Eq_52 Win32CrtStartup()
{
	struct Eq_430 * ebp_10 = fn004025EC(ebx, esi, edi, dwLoc0C, 4207032, 252);
	word32 ebx_151 = 0x00;
	if ((uint32) ((uint64) (uint32) ebp_10->dw000C % 0x0A) == 0x14)
	{
		TlsGetValue(0x00);
		TlsSetValue(0x00, 0x6546);
		*(ebp_10 - 0xE0) = 0x00;
		word32 ecx_2307 = 0x08;
		word32 * edi_2316 = ebp_10 - 220;
		while (ecx_2307 != 0x00)
		{
			*edi_2316 = 0x00;
			edi_2316 = edi_2316 + 0x01;
			ecx_2307 = ecx_2307 - 0x01;
		}
		GetSystemInfo(ebp_10 - 0xE0);
		*(ebp_10 - 0x1F) = 0x00;
		*(ebp_10 - 0x20) = (byte) ((char *) *((char *) *fs->ptr002C + 0x0047) + 0x01);
		*(ebp_10 - 0x04) = 0x00;
		Eq_1789 eax_2341 = GetCommandLineA();
		__wait();
		eax_2347 = eax_2341;
		do
		{
			Eq_1789 eax_2347;
			eax_2347 = (word32) eax_2474 + 0x01;
			Eq_1789 eax_2474 = eax_2347;
		} while (*eax_2474 != 0x00);
		Eq_6241 eax_2356 = eax_2347 - eax_2341;
		Eq_1789 esi_2360 = eax_2341;
		union Eq_6244 * edi_2364 = (union Eq_6244 *) 0x00100654;
		do
		{
			edi_2364 = (union Eq_6244 *) ((char *) edi_2475 + 0x01);
			union Eq_6244 * edi_2475 = edi_2364;
		} while (*edi_2475 != 0x00);
		uint32 ecx_2373 = eax_2356 >> 0x02;
		while (ecx_2373 != 0x00)
		{
			*edi_2364 = (union Eq_6244 *) *esi_2360;
			esi_2360 = esi_2360 + 0x04;
			edi_2364 = (union Eq_6244 *) ((char *) edi_2364 + 0x04);
			ecx_2373 = ecx_2373 - 0x01;
		}
		ui32 ecx_2387 = eax_2356 & 0x03;
		while (ecx_2387 != 0x00)
		{
			*edi_2364 = (union Eq_6244 *) *esi_2360;
			esi_2360 = esi_2360 + 0x01;
			edi_2364 = (union Eq_6244 *) ((char *) edi_2364 + 0x01);
			ecx_2387 = ecx_2387 - 0x01;
		}
		byte * eax_2401 = ebp_10 - (struct Eq_6275 *) 0x20;
		union Eq_6277 * esi_2405 = ebp_10 - (struct Eq_6275 *) 0x20;
		do
		{
			eax_2401 = eax_2476 + 0x01;
			byte * eax_2476 = eax_2401;
		} while (*eax_2476 != 0x00);
		Eq_6301 eax_2415 = eax_2401 - (ebp_10 - (struct Eq_6275 *) 0x20);
		union Eq_6304 * edi_2421 = (union Eq_6304 *) 0x00100654;
		do
		{
			edi_2421 = (union Eq_6304 *) ((char *) edi_2477 + 0x01);
			union Eq_6304 * edi_2477 = edi_2421;
		} while (*edi_2477 != 0x00);
		uint32 ecx_2430 = eax_2415 >> 0x02;
		while (ecx_2430 != 0x00)
		{
			*edi_2421 = (union Eq_6304 *) *esi_2405;
			esi_2405 = (union Eq_6277 *) ((char *) esi_2405 + 0x04);
			edi_2421 = (union Eq_6304 *) ((char *) edi_2421 + 0x04);
			ecx_2430 = ecx_2430 - 0x01;
		}
		ui32 ecx_2444 = eax_2415 & 0x03;
		while (ecx_2444 != 0x00)
		{
			*edi_2421 = (union Eq_6304 *) *esi_2405;
			esi_2405 = (union Eq_6277 *) ((char *) esi_2405 + 0x01);
			edi_2421 = (union Eq_6304 *) ((char *) edi_2421 + 0x01);
			ecx_2444 = ecx_2444 - 0x01;
		}
		(ebp_10 - (struct Eq_6341 *) 0x04)->dw0000 = (ebp_10 - (struct Eq_6334 *) 0x04)->dw0000 | ~0x00;
	}
	*(ebp_10 - 0xB0) = 0x00;
	*(ebp_10 - 0x20) = 0x00;
	Eq_1726 esi_48 = ebp_10->t0008;
	if (esi_48 != null && (ebp_10->dw000C <= 0x03 && (ebp_10->dw0010 == 0x00 || ebp_10->dw0010 == 0x01)))
	{
		*(ebp_10 - 0xB0) = 0x01;
		*(ebp_10 - 0x20) = (HINSTANCE *) esi_48;
	}
	Eq_52 eax_1069;
	*(ebp_10 - 0x28) = 0x00;
	ptr32 esp_153 = fp - 0x08;
	if ((uint32) ((uint64) (uint32) esi_48 % 0x17) > 0x32)
	{
		Eq_52 eax_2129 = GetModuleHandleA(0x00);
		__wait();
		Eq_52 eax_2158 = CreateWindowExA(0x00, 0x8002, 0x004030F0, 0x10C00000, 0x19, 0x23, 400, 400, 0x00, null, esi_48, 0x00);
		__wait();
		*(ebp_10 - 0x28) = (union Eq_52 *) eax_2158;
		esp_153 = fp - 0x08;
		if (eax_2158 != 0x00 && eax_2129 != 0x00)
		{
			word32 ecx_2170 = 0x0A;
			word32 * edi_2179 = ebp_10 - 0x0108;
			while (ecx_2170 != 0x00)
			{
				*edi_2179 = 0x00;
				edi_2179 = edi_2179 + 0x01;
				ecx_2170 = ecx_2170 - 0x01;
			}
			*(ebp_10 - 0x010C) = 0x0F;
			Eq_52 eax_2216 = CreateWindowExA(esp_2213->t0000, esp_2213->t0004, esp_2213->t0008, esp_2213->t000C, esp_2213->dw0010, esp_2213->dw0014, esp_2213->dw0018, esp_2213->dw001C, esp_2213->t0020, esp_2213->t0024, esp_2213->t0028, esp_2213->t002C);
			__wait();
			int32 esi_2236 = 0x00;
			do
			{
				*(ebp_10 - 0xF8) = esi_2236;
				*(ebp_10 - 0x0100) = ebp_10 - 220;
				*(ebp_10 - 0x0104) = 0x14;
				*(ebp_10 - 0x0108) = (word32) (esi_2236 >= 0x02);
				*(esp_2215 - 0x04) = ebp_10 - 0x010C;
				*(esp_2215 - 0x08) = esi_2236;
				*(esp_2215 - 0x0C) = 0x101B;
				*(esp_2215 - 0x10) = (union Eq_52 *) eax_2216;
				Eq_2901 eax_2260 = SendMessageA(*(esp_2215 - 0x10), *(esp_2215 - 0x0C), *(esp_2215 - 0x08), *(esp_2215 - 0x04));
				__wait();
				esp_153 = esp_2215;
				if (eax_2260 == ~0x00)
					goto l00401BFF;
				esi_2236 = esi_2236 + 0x01;
			} while (esi_2236 < 11);
		}
	}
	else if (*(ebp_10 - 0x20) == 0x00)
		*(ebp_10 - 0x20) = 0x00400000;
	*(ebp_10 - 44) = 0x00;
	*(ebp_10 - 0x3C) = 0x00;
	*(ebp_10 - 0xA0) = 0x00;
	*(ebp_10 - 0x98) = 0x00;
	*(ebp_10 - 0x88) = 0x00;
	*(ebp_10 - 0x7C) = 0x01;
	*(ebp_10 - 0x7B) = 0x50;
	*(ebp_10 - 122) = 0x56;
	*(ebp_10 - 121) = 0x46;
	*(ebp_10 - 0x78) = 0x4E;
	*(ebp_10 - 0x77) = 0x4E;
	*(ebp_10 - 118) = 0x10;
	*(ebp_10 - 117) = 0x46;
	*(ebp_10 - 116) = 0x4E;
	*(ebp_10 - 115) = 0x4E;
	*(ebp_10 - 114) = 0x00;
	*(ebp_10 - 0x70) = 0x01;
	*(ebp_10 - 111) = 0x2E;
	*(ebp_10 - 110) = 0x46;
	*(ebp_10 - 0x6D) = 0x54;
	*(ebp_10 - 0x6C) = 0x28;
	*(ebp_10 - 0x6B) = 0x4B;
	*(ebp_10 - 0x6A) = 0x50;
	*(ebp_10 - 0x69) = 0x46;
	*(ebp_10 - 0x68) = 0x27;
	*(ebp_10 - 0x67) = 0x02;
	struct Eq_1208 * edx_182 = *(ebp_10 - 0x20);
	word32 edi_184 = edx_182 + edx_182->ptr003C / 0x0040;
	*(ebp_10 - 0x80) = edi_184;
	*(ebp_10 - 0x8C) = 0x00;
	*(ebp_10 - 0xAC) = 0x00;
	*(ebp_10 - 0x9C) = 0x00;
	*(ebp_10 - 0x94) = 0x00;
	*(ebp_10 - 0xA8) = 0x00;
	*(ebp_10 - 0x44) = 106194171;
	ptr32 esi_193 = ebp_10 - 0x60;
	word32 eax_194 = fn00401722(edx_182, ebp_10, esi_193);
	__wait();
	if (eax_194 != 0x00)
	{
		word32 * esp_201 = esp_153 - 0x04;
		*esp_201 = 0x04;
		*(esp_201 - 0x04) = 0x3000;
		*(esp_201 - 0x08) = 0x07;
		*(esp_201 - 0x0C) = ebx_151;
		ptr32 esp_209;
		word32 eax_210;
		struct Eq_2217 * ebp_211;
		word32 edx_212;
		byte SZO_213;
		bool C_214;
		word32 ecx_215;
		byte SCZO_216;
		Eq_52 ebx_217;
		bool Z_218;
		struct Eq_2225 * edi_219;
		word32 esi_220;
		byte CZ_221;
		byte al_222;
		byte SO_223;
		word16 ax_224;
		bool S_225;
		word16 dx_226;
		struct Eq_2233 * fs_227;
		byte cl_228;
		(*(ebp_10 - 88))();
		__wait();
		*(ebp_211 - 0x48) = eax_210;
		if (*(ebp_211 - 0x28) != ebx_217)
		{
			*(esp_209 - 0x04) = 100;
			*(esp_209 - 0x08) = ebp_211->dw0008;
			Eq_2422 eax_2011 = LoadAcceleratorsA(*(esp_209 - 0x08), *(esp_209 - 0x04));
			__wait();
			*(ebp_211 - 0x40) = (HACCEL *) eax_2011;
			*(esp_209 - 0x04) = (union Eq_52 *) ebx_217;
			*(esp_209 - 0x08) = ebp_211->dw0008;
			*(esp_209 - 0x0C) = 0x1992;
			*(esp_209 - 0x10) = *(ebp_211 - 0x28);
			*(esp_209 - 0x14) = 0x12;
			*(esp_209 - 0x18) = 0x20;
			*(esp_209 - 0x1C) = 0x05;
			*(esp_209 - 0x20) = 0x0A;
			*(esp_209 - 0x24) = 0x50010000;
			*(esp_209 - 0x28) = 0x00403104;
			*(esp_209 - 44) = 0x00403108;
			*(esp_209 - 0x30) = (union Eq_52 *) ebx_217;
			Eq_52 eax_2041 = CreateWindowExA(*(esp_209 - 0x30), *(esp_209 - 44), *(esp_209 - 0x28), *(esp_209 - 0x24), *(esp_209 - 0x20), *(esp_209 - 0x1C), *(esp_209 - 0x18), *(esp_209 - 0x14), *(esp_209 - 0x10), *(esp_209 - 0x0C), *(esp_209 - 0x08), *(esp_209 - 0x04));
			__wait();
			*(ebp_211 - 0x24) = (union Eq_52 *) eax_2041;
			*(esp_209 - 0x04) = (union Eq_52 *) ebx_217;
			*(esp_209 - 0x08) = ebp_211->dw0008;
			*(esp_209 - 0x0C) = 0x0363;
			*(esp_209 - 0x10) = *(ebp_211 - 0x28);
			*(esp_209 - 0x14) = 100;
			*(esp_209 - 0x18) = 100;
			*(esp_209 - 0x1C) = 0x05;
			*(esp_209 - 0x20) = 0x32;
			*(esp_209 - 0x24) = 0x50010000;
			*(esp_209 - 0x28) = 0x00403110;
			*(esp_209 - 44) = 0x00403118;
			*(esp_209 - 0x30) = (union Eq_52 *) ebx_217;
			Eq_52 eax_2070 = CreateWindowExA(*(esp_209 - 0x30), *(esp_209 - 44), *(esp_209 - 0x28), *(esp_209 - 0x24), *(esp_209 - 0x20), *(esp_209 - 0x1C), *(esp_209 - 0x18), *(esp_209 - 0x14), *(esp_209 - 0x10), *(esp_209 - 0x0C), *(esp_209 - 0x08), *(esp_209 - 0x04));
			__wait();
			if (*(ebp_211 - 0x24) != ebx_217 && eax_2070 != ebx_217)
			{
				*(esp_209 - 0x04) = (union Eq_52 *) ebx_217;
				*(esp_209 - 0x08) = (union Eq_52 *) eax_2070;
				ShowWindow(*(esp_209 - 0x08), *(esp_209 - 0x04));
				__wait();
				*(esp_209 - 0x04) = 0x00403120;
				*(esp_209 - 0x08) = *(ebp_211 - 0x24);
				SetWindowTextA(*(esp_209 - 0x08), *(esp_209 - 0x04));
				__wait();
				while (true)
				{
					*(esp_209 - 0x04) = (union Eq_52 *) ebx_217;
					*(esp_209 - 0x08) = (union Eq_52 *) ebx_217;
					*(esp_209 - 0x0C) = (union Eq_52 *) ebx_217;
					*(esp_209 - 0x10) = ebp_211 - 0xD8;
					Eq_52 eax_2103 = GetMessageA(*(esp_209 - 0x10), *(esp_209 - 0x0C), *(esp_209 - 0x08), *(esp_209 - 0x04));
					__wait();
					if (eax_2103 == 0x00)
						break;
					*(esp_209 - 0x04) = ebp_211 - 0xD8;
					*(esp_209 - 0x08) = *(ebp_211 - 0x40);
					*(esp_209 - 0x0C) = *(ebp_211 - 0xD8);
					int32 eax_2117 = TranslateAcceleratorA(*(esp_209 - 0x0C), *(esp_209 - 0x08), *(esp_209 - 0x04));
					__wait();
					if (eax_2117 == 0x00)
					{
						*(esp_209 - 0x04) = ebp_211 - 0xD8;
						TranslateMessage(*(esp_209 - 0x04));
						__wait();
					}
				}
				fn00401313();
				__wait();
			}
		}
		*(ebp_211 - 188) = edi_219->dw0050;
		word32 eax_237 = fn004012F0(ebp_211 - 0x7C);
		*(esp_209 - 0x04) = eax_237;
		ptr32 esp_240;
		word32 eax_241;
		ptr32 ebp_242;
		word32 edx_243;
		byte SZO_244;
		bool C_245;
		word32 ecx_246;
		byte SCZO_247;
		word32 ebx_248;
		bool Z_249;
		word32 edi_250;
		word32 esi_251;
		byte CZ_252;
		byte al_253;
		byte SO_254;
		word16 ax_255;
		bool S_256;
		word16 dx_257;
		struct Eq_2290 * fs_258;
		byte cl_259;
		(*(ebp_211 - 0x60))();
		__wait();
		*(ebp_242 - 0xB8) = eax_241;
		fn004016F0(ebp_242 - 0x60);
		__wait();
		*(ebp_242 - 0x24) = ebp_242 - 0x60;
		*(esp_240 - 0x04) = ebp_242 - 0x60;
		ptr32 esp_265;
		word32 eax_266;
		ptr32 ebp_267;
		word32 edx_268;
		byte SZO_269;
		bool C_270;
		word32 ecx_271;
		byte SCZO_272;
		word32 ebx_273;
		bool Z_274;
		word32 edi_275;
		word32 esi_276;
		byte CZ_277;
		byte al_278;
		byte SO_279;
		word16 ax_280;
		bool S_281;
		word16 dx_282;
		struct Eq_2341 * fs_283;
		byte cl_284;
		(*(ebp_242 - 0x50))();
		__wait();
		*(ebp_267 - 0x1C) = eax_266;
		*(esp_265 - 0x04) = 0x8000;
		*(esp_265 - 0x08) = ebx_273;
		*(esp_265 - 0x0C) = *(ebp_267 - 0x24);
		ptr32 esp_294;
		word32 eax_295;
		word32 edx_297;
		byte SZO_298;
		bool C_299;
		word32 ecx_300;
		byte SCZO_301;
		up32 ebx_302;
		bool Z_303;
		ptr32 edi_304;
		word32 esi_305;
		byte CZ_306;
		byte al_307;
		byte SO_308;
		word16 ax_309;
		bool S_310;
		word16 dx_311;
		struct Eq_2393 * fs_312;
		byte cl_313;
		(*(ebp_267 - 0x54))();
		__wait();
		if (*(ebp_10 - 0x1C) != ebx_302)
		{
			up32 eax_316 = *(edi_304 - 0x08);
			*(ebp_10 - 100) = eax_316;
			if (eax_316 <= ebx_302)
				goto l00401BFF;
			fn004017F7(ebp_10 - 0x60);
			__wait();
			*(ebp_10 - 0x24) = ebp_10 - 0x60;
			*(esp_294 - 0x04) = ebp_10 - 0x60;
			*(esp_294 - 0x08) = ebp_10 - 0x60;
			*(esp_294 - 0x0C) = *(ebp_10 - 0x1C);
			Eq_225 eax_330 = fn00401319(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 0x30) = (HMENU *) eax_330;
			*(esp_294 - 0x04) = esi_305;
			*(esp_294 - 0x08) = ebx_302;
			*(esp_294 - 0x0C) = *(ebp_10 - 0x24);
			ptr32 esp_340;
			word32 eax_341;
			word32 edx_343;
			byte SZO_344;
			bool C_345;
			word32 ecx_346;
			byte SCZO_347;
			word32 ebx_348;
			bool Z_349;
			struct Eq_3094 * edi_350;
			word32 esi_351;
			byte CZ_352;
			byte al_353;
			byte SO_354;
			word16 ax_355;
			bool S_356;
			word16 dx_357;
			struct Eq_3102 * fs_358;
			byte cl_359;
			(*(ebp_10 - 0x54))();
			__wait();
			if (*(ebp_10 - 0x30) != ebx_348)
			{
				word32 edi_363 = edi_350->dw0088 + *(ebp_10 - 0x20);
				if (edi_363 == *(ebp_10 - 0x20))
				{
					eax_1069.u0 = 0x01;
					goto l0040251E;
				}
				fn004015C2(ebp_10 - 0x60);
				__wait();
				*(ebp_10 - 0x24) = ebp_10 - 0x60;
				*(esp_340 - 0x04) = ebp_10 - 0x60;
				*(esp_340 - 0x08) = ebp_10 - 0x60;
				*(esp_340 - 0x0C) = *(ebp_10 - 0x1C);
				Eq_225 eax_383 = fn00401319(ebp_10, dwArg00, dwArg04, dwArg08);
				__wait();
				*(ebp_10 - 0x28) = (HMENU *) eax_383;
				*(esp_340 - 0x04) = esi_351;
				*(esp_340 - 0x08) = ebx_348;
				*(esp_340 - 0x0C) = *(ebp_10 - 0x24);
				ptr32 esp_393;
				word32 eax_394;
				word32 edx_396;
				byte SZO_397;
				bool C_398;
				word32 ecx_399;
				byte SCZO_400;
				bool Z_402;
				word32 edi_403;
				word32 esi_404;
				byte CZ_405;
				byte al_406;
				byte SO_407;
				word16 ax_408;
				bool S_409;
				word16 dx_410;
				struct Eq_3215 * fs_411;
				byte cl_412;
				Eq_225 ebx_1957;
				(*(ebp_10 - 0x54))();
				__wait();
				if (*(ebp_10 - 0x28) != ebx_1957)
				{
					uint64 edx_eax_417 = (uint64) (uint32) ebp_10->t0008;
					*(esp_393 - 0x04) = 0x57;
					uint32 edx_423 = (uint32) (edx_eax_417 % *(esp_393 - 0x04));
					*(ebp_10 - 0xA4) = edx_423;
					if (edx_423 > 0x028E)
					{
						*(esp_393 - 0x04) = 0x01;
						*(esp_393 - 0x08) = 6647723;
						*(esp_393 - 0x0C) = (HMENU *) ebx_1957;
						*(esp_393 - 0x10) = 5518842;
						Eq_225 eax_1978 = SetScrollInfo(*(esp_393 - 0x10), *(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
						__wait();
						if (eax_1978 != ebx_1957)
						{
							*(esp_393 - 0x04) = 0x01;
							*(esp_393 - 0x08) = (HMENU *) eax_1978;
							*(esp_393 - 0x0C) = (HMENU *) ebx_1957;
							*(esp_393 - 0x10) = 5518842;
							SetScrollPos(*(esp_393 - 0x10), *(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
							__wait();
						}
						*(esp_393 - 0x04) = 0x20;
						*(esp_393 - 0x08) = 0x2000;
						*(esp_393 - 0x0C) = 0x0A;
						*(esp_393 - 0x10) = (HMENU *) ebx_1957;
						VirtualAlloc(*(esp_393 - 0x10), *(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
						__wait();
					}
					fn00401652(ebp_10 - 0x60);
					__wait();
					*(ebp_10 - 0xB4) = ebp_10 - 0x60;
					*(esp_393 - 0x04) = ebp_10 - 0x60;
					*(esp_393 - 0x08) = ebp_10 - 0x60;
					*(esp_393 - 0x0C) = *(ebp_10 - 0x1C);
					Eq_225 eax_442 = fn00401319(ebp_10, dwArg00, dwArg04, dwArg08);
					__wait();
					*(ebp_10 - 0x40) = (HMENU *) eax_442;
					if (eax_442 != ebx_1957)
					{
						ptr32 esp_1892;
						*(ebp_10 - 0x38) = edi_403 + 0x10;
						*(ebp_10 - 0x34) = (HMENU *) ebx_1957;
						uint64 edx_eax_452 = (uint64) (uint32) ebp_10->t0008;
						*(esp_393 - 0x04) = 0x0A;
						ui32 ecx_455 = *(esp_393 - 0x04);
						uint32 edx_458 = (uint32) (edx_eax_452 % ecx_455);
						*(ebp_10 - 0x90) = edx_458;
						if (edx_458 == 0x14)
						{
							Eq_225 eax_1886 = CreateMenu();
							__wait();
							if (eax_1886 != ebx_1957)
							{
								*(esp_393 - 0x04) = (HMENU *) eax_1886;
								DestroyMenu(*(esp_393 - 0x04));
							}
							else
							{
								*(esp_393 - 0x04) = (HMENU *) ebx_1957;
								*(esp_393 - 0x08) = 0x00403130;
								*(esp_393 - 0x0C) = 0x00403138;
								*(esp_393 - 0x10) = (HMENU *) ebx_1957;
								MessageBoxA(*(esp_393 - 0x10), *(esp_393 - 0x0C), *(esp_393 - 0x08), *(esp_393 - 0x04));
							}
							__wait();
							esp_1892 = esp_393;
						}
						else
						{
							*(esp_393 - 0x04) = 0x1D;
							*(esp_393 - 0x08) = 0x1E;
							*(esp_393 - 0x0C) = 0x07;
							*(esp_393 - 0x10) = 0x05;
							ptr32 esp_1916;
							word32 eax_1917;
							ptr32 ebp_1918;
							word32 edx_1919;
							byte SZO_1920;
							bool C_1921;
							word32 ecx_1922;
							byte SCZO_1923;
							word32 ebx_1924;
							bool Z_1925;
							word32 edi_1926;
							word32 esi_1927;
							byte CZ_1928;
							byte al_1929;
							byte SO_1930;
							word16 ax_1931;
							bool S_1932;
							word16 dx_1933;
							struct Eq_3548 * fs_1934;
							byte cl_1935;
							(*(ebp_10 - 0x40))();
							__wait();
							*(ebp_1918 - 0x9C) = eax_1917;
							*(esp_1916 - 0x04) = 0x78;
							*(esp_1916 - 0x08) = 0x1E;
							*(esp_1916 - 0x0C) = 0x32;
							*(esp_1916 - 0x10) = 0x32;
							*(esp_1916 - 0x14) = 0x14;
							*(esp_1916 - 0x18) = 0x14;
							word32 eax_1950;
							word32 edx_1952;
							byte SZO_1953;
							bool C_1954;
							word32 ecx_1955;
							byte SCZO_1956;
							bool Z_1958;
							word32 edi_1959;
							word32 esi_1960;
							byte CZ_1961;
							byte al_1962;
							byte SO_1963;
							word16 ax_1964;
							bool S_1965;
							word16 dx_1966;
							struct Eq_3613 * fs_1967;
							byte cl_1968;
							(*(ebp_1918 - 0x30))();
							__wait();
							*(ebp_10 - 0x44) = eax_1950;
						}
						if (*(ebp_10 - 0x9C) != ebx_1957)
						{
							*(ebp_10 - 0x24) = 0x2D;
							struct Eq_1136 * eax_488 = *(ebp_10 - 0x48);
							fn004016D4(eax_488);
							ptr32 ecx_489 = ebp_10 - 0x60;
							ptr32 * esp_490 = esp_1892 - 0x04;
							*esp_490 = ecx_489;
							*(esp_490 - 0x04) = (struct Eq_1136 **) eax_488;
							*(esp_490 - 0x08) = *(ebp_10 - 0x1C);
							Eq_225 eax_497 = fn00401319(ebp_10, dwArg00, dwArg04, dwArg08);
							__wait();
							*(ebp_10 - 0x1C) = (HMENU *) eax_497;
							if (eax_497 == ebx_1957)
								goto l00401BFF;
							*esp_490 = 0x04;
							*(esp_490 - 0x04) = 0x3000;
							*(esp_490 - 0x08) = 100;
							*(esp_490 - 0x0C) = (HMENU *) ebx_1957;
							ptr32 esp_513;
							word32 eax_514;
							ptr32 ebp_515;
							word32 edx_516;
							byte SZO_517;
							bool C_518;
							word32 ecx_519;
							byte SCZO_520;
							word32 ebx_521;
							bool Z_522;
							word32 edi_523;
							word32 esi_524;
							byte CZ_525;
							byte al_526;
							byte SO_527;
							word16 ax_528;
							bool S_529;
							word16 dx_530;
							struct Eq_3790 * fs_531;
							byte cl_532;
							(*(ebp_10 - 88))();
							__wait();
							*(ebp_515 - 0x84) = eax_514;
							*(esp_513 - 0x04) = ebx_521;
							*(esp_513 - 0x08) = 0x0A;
							*(esp_513 - 0x0C) = *(ebp_515 - 0x44);
							ptr32 esp_541;
							word32 eax_542;
							ptr32 ebp_543;
							word32 edx_544;
							byte SZO_545;
							bool C_546;
							word32 ecx_547;
							byte SCZO_548;
							word32 ebx_549;
							bool Z_550;
							word32 edi_551;
							word32 esi_552;
							byte CZ_553;
							byte al_554;
							byte SO_555;
							word16 ax_556;
							bool S_557;
							word16 dx_558;
							struct Eq_3843 * fs_559;
							byte cl_560;
							(*(ebp_515 - 0x1C))();
							__wait();
							*(ebp_543 - 0x44) = eax_542;
							*(esp_541 - 0x04) = esi_552;
							*(esp_541 - 0x08) = ebx_549;
							*(esp_541 - 0x0C) = *(ebp_543 - 0x84);
							ptr32 esp_569;
							word32 eax_570;
							word32 edx_572;
							byte SZO_573;
							bool C_574;
							word32 ecx_575;
							byte SCZO_576;
							word32 ebx_577;
							bool Z_578;
							word32 edi_579;
							word32 esi_580;
							byte CZ_581;
							byte al_582;
							byte SO_583;
							word16 ax_584;
							bool S_585;
							word16 dx_586;
							struct Eq_3894 * fs_587;
							byte cl_588;
							(*(ebp_543 - 0x54))();
							__wait();
							uint64 edx_eax_591 = (uint64) (uint32) ebp_10->dw000C;
							*(esp_569 - 0x04) = 0x0A;
							ui32 ecx_594 = *(esp_569 - 0x04);
							uint32 edx_597 = (uint32) (edx_eax_591 % ecx_594);
							if (edx_597 != 0x28)
							{
								*(esp_569 - 0x04) = *(ebp_10 - 0x20);
								Eq_49 eax_1867 = GetDC(*(esp_569 - 0x04));
								__wait();
								*(esp_569 - 0x04) = 0x01;
								*(esp_569 - 0x08) = 88491439;
								*(esp_569 - 0x0C) = 0x20;
								*(esp_569 - 0x10) = 0x00403140;
								*(esp_569 - 0x14) = (HDC *) eax_1867;
								DrawTextA(*(esp_569 - 0x14), *(esp_569 - 0x10), *(esp_569 - 0x0C), *(esp_569 - 0x08), *(esp_569 - 0x04));
								__wait();
							}
							else if (*(ebp_10 - 0x44) != 0x0130)
								goto l00401BFF;
							*(esp_569 - 0x04) = 0x0F;
							*(esp_569 - 0x08) = 0x0F;
							*(esp_569 - 0x0C) = 0x3C;
							*(esp_569 - 0x10) = 0x32;
							*(esp_569 - 0x14) = 0x14;
							*(esp_569 - 0x18) = 0x14;
							ptr32 esp_618;
							word32 eax_619;
							word32 edx_621;
							byte SZO_622;
							bool C_623;
							word32 ecx_624;
							byte SCZO_625;
							word32 ebx_626;
							bool Z_627;
							word32 edi_628;
							word32 esi_629;
							byte CZ_630;
							byte al_631;
							byte SO_632;
							word16 ax_633;
							bool S_634;
							word16 dx_635;
							struct Eq_4067 * fs_636;
							byte cl_637;
							(*(ebp_10 - 0x30))();
							__wait();
							*(ebp_10 - 0x84) = eax_619;
							if (eax_619 != ebx_626)
							{
								*(esp_618 - 0x04) = esi_629;
								*(esp_618 - 0x08) = ebx_626;
								*(esp_618 - 0x0C) = *(ebp_10 - 0x48);
								ptr32 esp_648;
								word32 eax_649;
								ptr32 ebp_650;
								word32 edx_651;
								byte SZO_652;
								bool C_653;
								word32 ecx_654;
								byte SCZO_655;
								word32 ebx_656;
								bool Z_657;
								word32 edi_658;
								word32 esi_659;
								byte CZ_660;
								byte al_661;
								byte SO_662;
								word16 ax_663;
								bool S_664;
								word16 dx_665;
								struct Eq_4126 * fs_666;
								byte cl_667;
								(*(ebp_10 - 0x54))();
								__wait();
								*(esp_648 - 0x04) = esi_659;
								*(esp_648 - 0x08) = ebx_656;
								*(esp_648 - 0x0C) = *(ebp_650 - 0xB4);
								word32 eax_676;
								word32 edx_678;
								byte SZO_679;
								bool C_680;
								word32 ecx_681;
								byte SCZO_682;
								bool Z_684;
								word32 esi_686;
								byte CZ_687;
								byte al_688;
								byte SO_689;
								word16 ax_690;
								bool S_691;
								word16 dx_692;
								struct Eq_4169 * fs_693;
								byte cl_694;
								Eq_52 ebx_1505;
								word32 esp_1582;
								struct Eq_4173 * edi_1589;
								(*(ebp_650 - 0x54))();
								__wait();
								if (0x00 < edi_1589->w000E)
								{
									do
									{
										if (**(ebp_10 - 0x38) == 0x17)
										{
											uint64 edx_eax_1622 = (uint64) (uint32) ebp_10->t0008;
											union Eq_52 * esp_1623 = esp_1582 - 0x04;
											*esp_1623 = 33;
											Eq_52 ecx_1625 = *esp_1623;
											uint32 edx_1628 = (uint32) (edx_eax_1622 % ecx_1625);
											if (edx_1628 > 0x010B)
											{
												*esp_1623 = (union Eq_52 *) ebx_1505;
												*(esp_1623 - 0x04) = 0x0D;
												*(esp_1623 - 0x08) = 0x0400;
												*(esp_1623 - 0x0C) = 0x0D;
												*(esp_1623 - 0x10) = 5569212;
												Eq_52 eax_1801 = ModifyMenuA(*(esp_1623 - 0x10), *(esp_1623 - 0x0C), *(esp_1623 - 0x08), *(esp_1623 - 0x04), *esp_1623);
												__wait();
												if (eax_1801 != 0x00)
												{
													*esp_1623 = (union Eq_52 *) ebx_1505;
													*(esp_1623 - 0x04) = (union Eq_52 *) ebx_1505;
													*(esp_1623 - 0x08) = 65464;
													*(esp_1623 - 0x0C) = 0x004654AB;
													SendMessageA(*(esp_1623 - 0x0C), *(esp_1623 - 0x08), *(esp_1623 - 0x04), *esp_1623);
												}
												else
												{
													*esp_1623 = 0x01;
													*(esp_1623 - 0x04) = 0x056464AB;
													*(esp_1623 - 0x08) = 0x004654AB;
													InvalidateRect(*(esp_1623 - 0x08), *(esp_1623 - 0x04), *esp_1623);
												}
												__wait();
											}
											else
											{
												*esp_1623 = 0x15;
												*(esp_1623 - 0x04) = 0x14;
												*(esp_1623 - 0x08) = 0x10;
												*(esp_1623 - 0x0C) = 0x0F;
												word32 eax_1844;
												word32 edx_1846;
												byte SZO_1847;
												bool C_1848;
												word32 ecx_1849;
												byte SCZO_1850;
												bool Z_1852;
												word32 esi_1854;
												byte CZ_1855;
												byte al_1856;
												byte SO_1857;
												word16 ax_1858;
												bool S_1859;
												word16 dx_1860;
												struct Eq_4292 * fs_1861;
												byte cl_1862;
												(*(ebp_10 - 0x40))();
												__wait();
												*(ebp_10 - 0x8C) = eax_1844;
											}
											if (*(ebp_10 - 0x8C) == ebx_1505)
												goto l00401BFF;
											if (*(ebp_10 - 0xA8) == ebx_1505)
											{
												union Eq_52 * esp_1760 = esp_1582 - 0x04;
												*esp_1760 = (union Eq_52 *) ebx_1505;
												*(esp_1760 - 0x04) = (union Eq_52 *) ebx_1505;
												*(esp_1760 - 0x08) = *(ebp_10 - 0x84);
												word32 eax_1768;
												word32 edx_1770;
												byte SZO_1771;
												bool C_1772;
												word32 ecx_1773;
												byte SCZO_1774;
												bool Z_1776;
												word32 esi_1778;
												byte CZ_1779;
												byte al_1780;
												byte SO_1781;
												word16 ax_1782;
												bool S_1783;
												word16 dx_1784;
												struct Eq_4528 * fs_1785;
												byte cl_1786;
												(*(ebp_10 - 0x1C))();
												__wait();
												*(ebp_10 - 0x94) = eax_1768;
												*(ebp_10 - 0x28) = *(ebp_10 - 0x28) - eax_1768;
											}
											struct Eq_4455 * eax_1673 = edi_1589 + (*((char *) (*(ebp_10 - 0x38)) + 0x04) & 0x7FFFFFFF) / 0x0010;
											*(ebp_10 - 0xA8) = 0x01;
											*(ebp_10 - 0x30) = (union Eq_52 *) ebx_1505;
											struct Eq_4478 * ecx_1674 = (char *) (&eax_1673->w000E + 0x01) + 0x04;
											Eq_52 eax_1680 = (word32) (eax_1673->w000C + eax_1673->w000E);
											if (eax_1680 > ebx_1505)
											{
												do
												{
													*(ebp_10 - 0x48) = (union Eq_52 *) ebx_1505;
													Eq_4612 edx_1692 = ecx_1674->dw0000;
													if (edx_1692 >= 0x00)
													{
														if (edx_1692 > 1500)
															goto l00402126;
														*(ebp_10 - 0x48) = 0x01;
													}
													if (*(ebp_10 - 0x48) != ebx_1505)
													{
														word32 eax_1712 = Mem1691[(Mem1691[ecx_1674 + 0x00:word32] & 0x7FFFFFFF) + 0x14 + edi_1589:word32] + edi_1589;
														*(ebp_10 - 0x24) = *(ebp_10 - 0x24) + *(ebp_10 - 0x94);
														word32 ecx_1717 = eax_1712->dw0000;
														*(ebp_10 - 0xA0) = ecx_1717;
														*(ebp_10 - 0x98) = eax_1712->dw0004;
														word32 eax_1721 = (word32) edi_1589->w000E;
														*(ebp_10 - 0x34) = eax_1721;
														word32 * esp_1723 = esp_1582 - 0x04;
														*esp_1723 = 0x04;
														*(esp_1723 - 0x04) = 0x03;
														*(esp_1723 - 0x08) = 0x02;
														*(esp_1723 - 0x0C) = 0x01;
														Eq_52 eax_1732;
														word32 edx_1734;
														byte SZO_1735;
														bool C_1736;
														word32 ecx_1737;
														byte SCZO_1738;
														bool Z_1740;
														word32 esi_1742;
														byte CZ_1743;
														byte al_1744;
														byte SO_1745;
														word16 ax_1746;
														bool S_1747;
														word16 dx_1748;
														struct Eq_5061 * fs_1749;
														byte cl_1750;
														(*(ebp_10 - 0x40))();
														__wait();
														*(ebp_10 - 0xAC) = (union Eq_52 *) eax_1732;
														if (eax_1732 == ebx_1505)
															goto l00401BFF;
														*(ebp_10 - 0x28) = *(ebp_10 - 0x28) + 0xB0;
														break;
													}
l00402126:
													*(ebp_10 - 0x30) = *(ebp_10 - 0x30) + 0x01;
													ecx_1674 = ecx_1674 + 0x01;
												} while (*(ebp_10 - 0x30) < eax_1680);
											}
										}
										*(ebp_10 - 0x38) = *(ebp_10 - 0x38) + 0x08;
										*(ebp_10 - 0x34) = *(ebp_10 - 0x34) + 0x01;
									} while (*(ebp_10 - 0x34) < (word32) edi_1589->w000E);
								}
								Eq_52 edi_716 = *(ebp_10 - 0xA0);
								Eq_52 esi_1572 = edi_716;
								if (*(ebp_10 - 0xA4) > 110)
								{
									union Eq_52 * esp_1562 = esp_1582 - 0x04;
									*esp_1562 = 0x00403148;
									*(esp_1562 - 0x04) = 0x00403108;
									Eq_52 eax_1566 = FindWindowA(*(esp_1562 - 0x04), *esp_1562);
									__wait();
									*esp_1562 = (union Eq_52 *) eax_1566;
									DestroyWindow(*esp_1562);
									__wait();
								}
								else
									esi_1572 = (word32) edi_716 + 0x01;
								if (esi_1572 == 0x01)
								{
									union Eq_52 * esp_1520 = esp_1582 - 0x04;
									*esp_1520 = (union Eq_52 *) ebx_1505;
									Eq_52 eax_1522 = GetModuleHandleA(*esp_1520);
									__wait();
									*esp_1520 = (union Eq_52 *) eax_1522;
									CloseHandle(*esp_1520);
									__wait();
									if (*(ebp_10 - 0x90) == 0x14)
									{
										*esp_1520 = (union Eq_52 *) esi_1572;
										*(esp_1520 - 0x04) = 0x54;
										TerminateThread(*(esp_1520 - 0x04), *esp_1520);
									}
									else
									{
										uint64 edx_eax_1545 = (uint64) (uint32) ebp_10->t0008;
										*esp_1520 = 0x0F;
										if ((uint32) (edx_eax_1545 % *esp_1520) != 0x10)
											goto l00401BFF;
										Eq_52 eax_1555 = GetCurrentProcess();
										__wait();
										*esp_1520 = (union Eq_52 *) ebx_1505;
										*(esp_1520 - 0x04) = (union Eq_52 *) eax_1555;
										TerminateProcess(*(esp_1520 - 0x04), *esp_1520);
									}
									__wait();
								}
								*(ebp_10 - 88) = *(ebp_10 - 88) + *(ebp_10 - 0x94);
								word32 esi_1508 = *(ebp_10 - 0x20);
								Eq_52 ecx_732 = (word32) edi_716 + esi_1508;
								*(ebp_10 - 0x90) = (union Eq_52 *) ecx_732;
								if (ecx_732 == ebx_1505)
									goto l00401BFF;
								ptr32 esp_1438;
								uint64 edx_eax_739 = (uint64) (uint32) ebp_10->t0008;
								union Eq_52 * esp_740 = esp_1582 - 0x04;
								*esp_740 = 0x07;
								Eq_52 edi_742 = *esp_740;
								uint32 edx_745 = (uint32) (edx_eax_739 % edi_742);
								if (edx_745 == 0x08)
								{
									*esp_740 = (union Eq_52 *) (ebp_10 - 0xA4);
									*(esp_740 - 0x04) = 0x04;
									*(esp_740 - 0x08) = (union Eq_52 *) ebx_1505;
									*(esp_740 - 0x0C) = esi_1508 + 0x6565;
									*(esp_740 - 0x10) = 0x0400;
									*(esp_740 - 0x14) = (union Eq_52 *) ebx_1505;
									Eq_52 eax_1476 = CreateThread(*(esp_740 - 0x14), *(esp_740 - 0x10), *(esp_740 - 0x0C), *(esp_740 - 0x08), *(esp_740 - 0x04), *esp_740);
									__wait();
									esp_1438 = (char *) esp_740 + 0x04;
									if (eax_1476 != ebx_1505)
									{
										*esp_740 = (union Eq_52 *) eax_1476;
										ResumeThread(*esp_740);
										__wait();
										esp_1438 = (char *) esp_740 + 0x04;
									}
								}
								else
								{
									Eq_52 eax_1487 = ebp_10 - 0x3C;
									*esp_740 = (union Eq_52 *) eax_1487;
									*(esp_740 - 0x04) = 0x04;
									*(esp_740 - 0x08) = *(ebp_10 - 0x98);
									*(esp_740 - 0x0C) = (union Eq_52 *) ecx_732;
									word32 eax_1498;
									word32 edx_1500;
									byte SZO_1501;
									bool C_1502;
									word32 ecx_1503;
									byte SCZO_1504;
									bool Z_1506;
									word32 edi_1507;
									byte CZ_1509;
									byte al_1510;
									byte SO_1511;
									word16 ax_1512;
									bool S_1513;
									word16 dx_1514;
									struct Eq_4845 * fs_1515;
									byte cl_1516;
									(*(ebp_10 - 0x5C))();
									__wait();
									*(ebp_10 - 88) = *(ebp_10 - 88) - 0xB0;
								}
								*(ebp_10 - 0x1C) = (union Eq_52 *) ebx_1505;
								word32 esi_1449 = esi_1508 + *(ebp_10 - 188);
								while (*(ebp_10 - 0x1C) <= 0x0800)
								{
									*(ebp_10 - 0x1C) = *(ebp_10 - 0x1C) + 0x01;
									word32 * esp_1429 = esp_1438 - 0x04;
									*esp_1429 = 0x04;
									*(esp_1429 - 0x04) = 0x3000;
									*(esp_1429 - 0x08) = *(ebp_10 - 100);
									*(esp_1429 - 0x0C) = esi_1449;
									word32 eax_1439;
									word32 edx_1441;
									byte SZO_1442;
									bool C_1443;
									word32 ecx_1444;
									byte SCZO_1445;
									word32 ebx_1446;
									bool Z_1447;
									word32 edi_1448;
									byte CZ_1450;
									byte al_1451;
									byte SO_1452;
									word16 ax_1453;
									bool S_1454;
									word16 dx_1455;
									struct Eq_5166 * fs_1456;
									byte cl_1457;
									(*(ebp_10 - 88))();
									__wait();
									*(ebp_10 - 44) = eax_1439;
									if (eax_1439 != 0x00)
										break;
								}
								ptr32 esp_1328;
								uint64 edx_eax_808 = (uint64) (uint32) ebp_10->t0008;
								union Eq_3393 * esp_809 = esp_1438 - 0x04;
								*esp_809 = 0x11;
								Eq_3393 ecx_811 = *esp_809;
								uint32 edx_814 = (uint32) (edx_eax_808 % ecx_811);
								if (edx_814 == 0x15)
								{
									*esp_809 = 0x00100000;
									*(esp_809 - 0x04) = 0x0400;
									*(esp_809 - 0x08) = 0x00;
									Eq_52 eax_1357 = HeapCreate(*(esp_809 - 0x08), *(esp_809 - 0x04), *esp_809);
									__wait();
									esp_1328 = (char *) esp_809 + 0x04;
									if (eax_1357 != 0x00)
									{
										*esp_809 = 0x0400;
										*(esp_809 - 0x04) = 0x08;
										*(esp_809 - 0x08) = (union Eq_52 *) eax_1357;
										Eq_1736 eax_1371 = HeapAlloc(*(esp_809 - 0x08), *(esp_809 - 0x04), *esp_809);
										__wait();
										esp_1328 = (char *) esp_809 + 0x04;
										word32 * esi_1377 = *(ebp_10 - 0x20) + 0x0765;
										word32 ecx_1379 = 0x0100;
										Eq_1736 edi_1381 = eax_1371;
										while (ecx_1379 != 0x00)
										{
											*edi_1381 = *esi_1377;
											esi_1377 = esi_1377 + 0x01;
											edi_1381 = edi_1381 + 0x04;
											ecx_1379 = ecx_1379 - 0x01;
										}
									}
								}
								else
								{
									*esp_809 = 0x03;
									*(esp_809 - 0x04) = *(ebp_10 - 0x8C);
									*(esp_809 - 0x08) = *(ebp_10 - 0x9C);
									*(esp_809 - 0x0C) = *(ebp_10 - 0xAC);
									word32 eax_1404;
									word32 edx_1406;
									byte SZO_1407;
									bool C_1408;
									word32 ecx_1409;
									byte SCZO_1410;
									word32 ebx_1411;
									bool Z_1412;
									word32 edi_1413;
									word32 esi_1414;
									byte CZ_1415;
									byte al_1416;
									byte SO_1417;
									word16 ax_1418;
									bool S_1419;
									word16 dx_1420;
									struct Eq_5239 * fs_1421;
									byte cl_1422;
									(*(ebp_10 - 0x28))();
									__wait();
									*(ebp_10 - 0x1C) = eax_1404;
								}
								if (*(ebp_10 - 44) == 0x00)
								{
									word32 * esp_1319 = esp_1328 - 0x04;
									*esp_1319 = 0x04;
									*(esp_1319 - 0x04) = 0x3000;
									*(esp_1319 - 0x08) = *(ebp_10 - 100);
									*(esp_1319 - 0x0C) = 0x00;
									word32 eax_1329;
									word32 edx_1331;
									byte SZO_1332;
									bool C_1333;
									word32 ecx_1334;
									byte SCZO_1335;
									word32 ebx_1336;
									bool Z_1337;
									word32 edi_1338;
									word32 esi_1339;
									byte CZ_1340;
									byte al_1341;
									byte SO_1342;
									word16 ax_1343;
									bool S_1344;
									word16 dx_1345;
									struct Eq_5416 * fs_1346;
									byte cl_1347;
									(*(ebp_10 - 88))();
									__wait();
									*(ebp_10 - 44) = eax_1329;
									if (eax_1329 == esi_1339)
										goto l00401BFF;
								}
								if (*(ebp_10 - 0x44) == 0x0130)
								{
									word32 * esp_1307 = esp_1328 - 0x04;
									*esp_1307 = *(ebp_10 - 44);
									*(esp_1307 - 0x04) = *(ebp_10 - 0x98);
									fn004011F1(*(ebp_10 - 0x90) + *(ebp_10 - 0x24) - 0xE0 + *(ebp_10 - 0x1C), dwArg00, dwArg04);
									__wait();
								}
								union Eq_3393 * esp_867 = esp_1328 - 0x04;
								*esp_867 = (union Eq_3393 *) (ebp_10 - 0x60);
								*(esp_867 - 0x04) = *(ebp_10 - 44);
								word32 eax_872 = fn0040146E(ebp_10, dwArg00, dwArg04);
								__wait();
								if (eax_872 != 0x00)
								{
									uint64 edx_eax_879 = (uint64) (uint32) ebp_10->t0008;
									*esp_867 = 11;
									Eq_3393 ecx_882 = *esp_867;
									ptr32 esp_1269 = (char *) esp_867 + 0x04;
									uint32 edx_885 = (uint32) (edx_eax_879 % ecx_882);
									if (edx_885 == 0x0F)
									{
										*esp_867 = 0x0400;
										*(esp_867 - 0x04) = 0x40;
										Eq_5556 eax_1268 = GlobalAlloc(*(esp_867 - 0x04), *esp_867);
										__wait();
										esp_1269 = (char *) esp_867 + 0x04;
										if (eax_1268 != null)
										{
											*esp_867 = 0x00100546;
											*(esp_867 - 0x04) = (HGLOBAL *) eax_1268;
											ptr32 esp_1281;
											byte * eax_1282;
											word32 edx_1284;
											byte SZO_1285;
											bool C_1286;
											word32 ecx_1287;
											byte SCZO_1288;
											word32 ebx_1289;
											bool Z_1290;
											word32 edi_1291;
											word32 esi_1292;
											byte CZ_1293;
											byte al_1294;
											byte SO_1295;
											word16 ax_1296;
											bool S_1297;
											word16 dx_1298;
											struct Eq_5601 * fs_1299;
											byte cl_1300;
											(*(ebp_10 - 0x20) + 0x0565)();
											__wait();
											*eax_1282 = 0x01;
											*(esp_1281 - 0x04) = esi_1292;
											GlobalFree(*(esp_1281 - 0x04));
											__wait();
											esp_1269 = esp_1281;
										}
									}
									ptr32 * esp_905 = esp_1269 - 0x04;
									*esp_905 = ebp_10 - 0x60;
									struct Eq_870 * esi_907 = *(ebp_10 - 44);
									word32 eax_908 = fn00401570(ebp_10, esi_907, dwArg00);
									__wait();
									if (eax_908 != 0x00)
									{
										*esp_905 = *(ebp_10 - 0x20);
										word32 eax_917 = fn00401680(esi_907, dwArg00);
										__wait();
										if (eax_917 != 0x00)
										{
											ptr32 eax_926 = ebp_10 - 0x3C;
											*esp_905 = eax_926;
											*(esp_905 - 0x04) = 0x40;
											*(esp_905 - 0x08) = 0xF8;
											word32 esi_933 = *(ebp_10 - 0x80);
											*(esp_905 - 0x0C) = esi_933;
											ptr32 esp_936;
											ui32 eax_937;
											ptr32 ebp_938;
											word32 edx_939;
											byte SZO_940;
											bool C_941;
											word32 ecx_942;
											byte SCZO_943;
											struct Eq_5684 * ebx_944;
											bool Z_945;
											word32 edi_946;
											byte CZ_948;
											byte al_949;
											byte SO_950;
											word16 ax_951;
											bool S_952;
											word16 dx_953;
											struct Eq_5693 * fs_954;
											byte cl_955;
											struct Eq_5695 * esi_1263;
											(*(ebp_10 - 0x5C))();
											__wait();
											esi_1263->dw0050 = (eax_937 | ~0x00) - *(ebp_938 - 0x20);
											esi_1263->dw008C = ebx_944->dw008C;
											esi_1263->dw0088 = ebx_944->dw0088 - *(ebp_938 - 0x20) + edi_946;
											cup16 ax_968 = (word16) (word32) ebx_944->w0006;
											esi_1263->w0006 = ax_968;
											*(ebp_938 - 0x24) = *(ebp_938 - 0x24) & 0x00;
											if (0x00 < ax_968)
											{
												word32 * edx_1214 = &ebx_944->dw008C + 0x001B;
												struct Eq_5818 * eax_1216 = &esi_1263->dw008C + 0x001E;
												do
												{
													*(esp_936 - 0x04) = 0x0A;
													word32 * edi_1229 = eax_1216 - 0x0C;
													word32 ecx_1232 = *(esp_936 - 0x04);
													word32 * esi_1235 = edx_1214;
													while (ecx_1232 != 0x00)
													{
														*edi_1229 = *esi_1235;
														esi_1235 = esi_1235 + 0x01;
														edi_1229 = edi_1229 + 0x01;
														ecx_1232 = ecx_1232 - 0x01;
													}
													eax_1216->dw0000 = eax_1216->dw0000 + (*(ebp_938 - 44) - *(ebp_938 - 0x20));
													*(ebp_938 - 0x24) = *(ebp_938 - 0x24) + 0x01;
													eax_1216 = eax_1216 + 0x01;
													edx_1214 = edx_1214 + 0x0A;
												} while (*(ebp_938 - 0x24) < (word32) (*((char *) (*(ebp_938 - 0x80)) + 0x06)));
												esi_1263 = (struct Eq_5695 *) *(ebp_938 - 0x80);
											}
											*(esp_936 - 0x04) = ebp_938 - 0x3C;
											*(esp_936 - 0x08) = *(ebp_938 - 0x3C);
											*(esp_936 - 0x0C) = 0xF8;
											*(esp_936 - 0x10) = (struct Eq_5695 **) esi_1263;
											ptr32 esp_990;
											word32 eax_991;
											word32 edx_993;
											byte SZO_994;
											bool C_995;
											word32 ecx_996;
											byte SCZO_997;
											word32 ebx_998;
											bool Z_999;
											struct Eq_310 * edi_1000;
											word32 esi_1001;
											byte CZ_1002;
											byte al_1003;
											byte SO_1004;
											word16 ax_1005;
											bool S_1006;
											word16 dx_1007;
											struct Eq_5801 * fs_1008;
											byte cl_1009;
											(*(ebp_938 - 0x5C))();
											__wait();
											if (fn0040125C(edi_1000) != 0x00)
											{
												*(esp_990 - 0x04) = ebp_10 - 0x3C;
												*(esp_990 - 0x08) = 0x40;
												*(esp_990 - 0x0C) = *(ebp_10 - 100);
												*(esp_990 - 0x10) = (struct Eq_310 **) edi_1000;
												ptr32 esp_1027;
												word32 eax_1028;
												word32 edx_1030;
												byte SZO_1031;
												bool C_1032;
												word32 ecx_1033;
												byte SCZO_1034;
												struct Eq_5939 * ebx_1035;
												bool Z_1036;
												word32 edi_1037;
												word32 esi_1038;
												byte CZ_1039;
												byte al_1040;
												byte SO_1041;
												word16 ax_1042;
												bool S_1043;
												word16 dx_1044;
												struct Eq_5949 * fs_1045;
												byte cl_1046;
												(*(ebp_10 - 0x5C))();
												__wait();
												<anonymous> * ebx_1049 = ebx_1035->dw0028 + edi_1037;
												if (*(ebp_10 - 0xB0) != 0x00)
												{
													*(esp_1027 - 0x04) = ebp_10 - 0x60;
													*(esp_1027 - 0x08) = ebp_10 - 0x70;
													*(esp_1027 - 0x0C) = *(ebp_10 - 0xB8);
													Eq_225 eax_1082 = fn00401319(ebp_10, dwArg00, dwArg04, dwArg08);
													__wait();
													if (eax_1082 != null)
													{
														*(ebp_10 - 0x1C) = 0x00;
														*(esp_1027 - 0x04) = ebp_10 - 0x1C;
														*(esp_1027 - 0x08) = (HINSTANCE *) ebp_10->t0008;
														ptr32 esp_1093;
														word32 eax_1094;
														word32 edx_1096;
														byte SZO_1097;
														bool C_1098;
														word32 ecx_1099;
														byte SCZO_1100;
														<anonymous> * ebx_1101;
														bool Z_1102;
														word32 edi_1103;
														struct Eq_6136 * esi_1104;
														byte CZ_1105;
														byte al_1106;
														byte SO_1107;
														word16 ax_1108;
														bool S_1109;
														word16 dx_1110;
														struct Eq_6143 * fs_1111;
														byte cl_1112;
														eax_1082();
														__wait();
														struct Eq_6136 * eax_1113 = *(ebp_10 - 0x1C);
														if (eax_1113 != esi_1104)
														{
															eax_1113->dw0018 = edi_1103;
															*((char *) *(ebp_10 - 0x1C) + 0x001C) = (struct Eq_6161 **) ebx_1101;
															struct Eq_6165 * eax_1122 = *(ebp_10 - 0x1C);
															word32 ecx_1123 = *(ebp_10 - 100);
															eax_1122->dw0020 = ecx_1123;
															*(esp_1093 - 0x04) = ebp_10->dw0010;
															*(esp_1093 - 0x08) = ebp_10->dw000C;
															*(esp_1093 - 0x0C) = edi_1103;
															*(esp_1093 - 0x10) = 0x01;
															word32 esp_1135;
															word32 eax_1136;
															word32 edx_1138;
															byte SZO_1139;
															bool C_1140;
															word32 ecx_1141;
															byte SCZO_1142;
															word32 ebx_1143;
															bool Z_1144;
															word32 edi_1145;
															word32 esi_1146;
															byte CZ_1147;
															byte al_1148;
															byte SO_1149;
															word16 ax_1150;
															bool S_1151;
															word16 dx_1152;
															struct Eq_6224 * fs_1153;
															byte cl_1154;
															ebx_1101();
															__wait();
															*(ebp_10 - 0x88) = eax_1136;
														}
													}
												}
												else
												{
													*(esp_1027 - 0x04) = ebp_10->dw0010;
													*(esp_1027 - 0x08) = ebp_10->dw000C;
													*(esp_1027 - 0x0C) = (HINSTANCE *) ebp_10->t0008;
													*(esp_1027 - 0x10) = 0x00;
													ptr32 esp_1167;
													word32 eax_1168;
													ptr32 ebp_1169;
													word32 edx_1170;
													byte SZO_1171;
													bool C_1172;
													word32 ecx_1173;
													byte SCZO_1174;
													word32 ebx_1175;
													bool Z_1176;
													word32 edi_1177;
													word32 esi_1178;
													byte CZ_1179;
													byte al_1180;
													byte SO_1181;
													word16 ax_1182;
													bool S_1183;
													word16 dx_1184;
													struct Eq_6018 * fs_1185;
													byte cl_1186;
													ebx_1049();
													__wait();
													*(ebp_1169 - 0x88) = eax_1168;
													*(esp_1167 - 0x04) = 0x8000;
													*(esp_1167 - 0x08) = esi_1178;
													*(esp_1167 - 0x0C) = edi_1177;
													word32 esp_1194;
													word32 eax_1195;
													word32 edx_1197;
													byte SZO_1198;
													bool C_1199;
													word32 ecx_1200;
													byte SCZO_1201;
													word32 ebx_1202;
													bool Z_1203;
													word32 edi_1204;
													word32 esi_1205;
													byte CZ_1206;
													byte al_1207;
													byte SO_1208;
													word16 ax_1209;
													bool S_1210;
													word16 dx_1211;
													struct Eq_6060 * fs_1212;
													byte cl_1213;
													(*(ebp_1169 - 0x54))();
													__wait();
												}
												eax_1069 = *(ebp_10 - 0x88);
l0040251E:
												fn00402627(ebp_10, 252, dwArg00, dwArg04, dwArg08);
												return eax_1069;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
l00401BFF:
	eax_1069.u0 = 0x00;
	goto l0040251E;
}

// 00402526: Register Eq_52 GetKJgkdghkdfhd()
Eq_52 GetKJgkdghkdfhd()
{
	Eq_52 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403150);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 0040254C: Register Eq_52 GetLKfsdgdkhd()
Eq_52 GetLKfsdgdkhd()
{
	Eq_52 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403160);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402572: Register Eq_52 GetKkgdstkdgkd()
Eq_52 GetKkgdstkdgkd()
{
	Eq_52 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403170);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402598: Register Eq_52 GetKfldskgdhkd()
Eq_52 GetKfldskgdhkd()
{
	Eq_52 eax_13 = CreateEventA(null, 0x01, 0x01, 0x0040317C);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 004025BE: Register Eq_52 GetKlfgdkgldshd()
Eq_52 GetKlfgdkgldshd()
{
	Eq_52 eax_13 = CreateEventA(null, 0x01, 0x01, 0x0040318C);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 004025EC: Register ptr32 fn004025EC(Register word32 ebx, Register word32 esi, Register word32 edi, Stack word32 dwArg00, Stack word32 dwArg04, Stack ui32 dwArg08)
ptr32 fn004025EC(word32 ebx, word32 esi, word32 edi, word32 dwArg00, word32 dwArg04, ui32 dwArg08)
{
	ptr32 esp_14 = fp - 0x08 - dwArg08;
	*(esp_14 - 0x04) = ebx;
	*(esp_14 - 0x08) = esi;
	*(esp_14 - 0x0C) = edi;
	*(esp_14 - 0x10) = dwArg00;
	fs->ptr0000 = fp - 0x08;
	return fp + 0x08;
}

// 00402627: void fn00402627(Register (ptr32 Eq_430) ebp, Stack ui32 dwArg00, Stack Eq_225 dwArg04, Stack Eq_225 dwArg08, Stack Eq_225 dwArg0C)
void fn00402627(Eq_430 * ebp, ui32 dwArg00, HMENU dwArg04, HMENU dwArg08, HMENU dwArg0C)
{
	fs->dw0000 = *(ebp - 0x10);
	ebp->dw0000 = dwArg00;
}

