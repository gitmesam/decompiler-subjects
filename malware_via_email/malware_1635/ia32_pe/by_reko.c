// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004010C4: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_3 * esp_165 = fp - 0x04;
	struct Eq_7 * ebx_166 = (word32) eax + (ebx | eax);
	ui32 esi_223 = (word32) eax + SLICE(SEQ(esi, edx + ecx / 0x3FFFFFD2) + eax_edx, word32, 32);
l0040121B:
	ui32 eax_177;
	Eq_2 eax_156;
	word32 esi_1052 = esi_223 + ebx_166 + edx;
	ui64 ecx_edi_82 = SEQ(eax | esi_1052, esi_1052 - edx - eax) - edx_edx;
	struct Eq_7 * ecx_1019 = SLICE(ecx_edi_82, word32, 32);
	struct Eq_93 * edi_174 = (word32) ecx_edi_82 & edx | ecx_1019;
	if (esi_1052 == (struct Eq_87 *) 0x6E0BFD02)
	{
		byte al_324 = al & 0x84;
		ebx_166->t0000.u0 = al_324;
		eax_177 = DPB(eax, al_324, 0);
		esp_165 = esp_165 + 0x01;
		goto l0040123B;
	}
l004012A1:
	Eq_2 edx_1098;
	word32 ecx_358 = ecx_1019 + edx;
	ui32 eax_372 = edx + ((eax & esi_1052 - edx) & edx) / 0x3FFFFFD2;
	byte cl_359 = (byte) ecx_358;
	edi_174 = edi_174 - edx;
	byte al_375 = (byte) eax_372;
	if (edx != (struct Eq_15 *) 1575208321)
	{
		edx_1098 = (struct <anonymous> *) 3175377615;
		goto l0040132A;
	}
	struct Eq_66 * eax_430 = DPB(eax_372, al_375 & 0x02, 0);
	eax_430->dwD91B0180 = eax_430 + eax_430->dwD91B0180;
l004012C6:
	byte * ebx_453 = edi_174 & edx;
	if (ecx_358 == (struct Eq_87 *) 316566043)
		*ebx_453 = *ebx_453 | cl_359;
	ui32 ebx_481 = ebx_453 - edx;
	uint64 esi_esi_490 = 0x00 - SEQ(ebx_481, 0x00);
	ecx_1019 = ecx_358 & edx;
	edi_174 = 0x00 - ebx_481 - (esi_esi_490 < 0x00);
	esi_1052 = (word32) esi_esi_490 - ecx_1019 - (edi_174 < null);
	uint32 eax_511 = ecx_358 - ecx_1019 - (esi_1052 < null);
	byte ch_486 = SLICE(ecx_1019, byte, 8);
	ebx_166 = ecx_1019;
	eax_177 = eax_511 - ecx_1019 - (eax_511 < 0x00);
	edx = ecx_1019 * 0x02;
	if (ecx_1019 * 0x02 != 0x5658FAC0)
	{
l0040123B:
		__cli();
		int32 ebx_186 = ebx_166 - edx;
		ui32 esi_182 = esi_1052 & edx;
		uint32 edi_192 = edi_174 + ebx_186 / 0x3FFFFFD2;
		ui32 ecx_207 = ecx_1019 - esi_182 - (edi_192 < 0x00) & esi_182;
		uint32 eax_214 = eax_177 - ecx_207;
		uint32 edx_216 = edx + eax_214 / 0x3FFFFFD2;
		ui64 esi_edx_221 = SEQ(ecx_207, edx_216) + SEQ(ebx_186, eax_214);
		edx = (word32) esi_edx_221;
		uint32 edi_205 = (edi_192 & ebx_186) - edx;
		edx_edx = SEQ(edx_216, edx_216);
		esi_223 = SLICE(esi_edx_221, word32, 32);
		ebx_166 = ebx_186 & edx;
		al = (byte) edi_205;
		byte ah_238 = SLICE(edi_205, byte, 8);
		if (edi_205 != ~0x018BB214)
		{
			eax_156 = (edi_205 | (esi_223 - edi_205) - (edi_205 < ~0x018BB214)) & ecx_207;
			return eax_156;
		}
		eax.u1 = DPB(edi_205, (byte) edx->t0000 + ah_238, 8);
		ebx_166->t0000.u0 = (byte) ebx_166->t0000 + 202;
		goto l0040121B;
	}
	esp_165 = esp_165 + 0x01;
	esp_165[0x0022] = (struct Eq_3) ((word32) esp_165[0x0022].t0000 + eax_177);
	ecx_1019->t0000.u0 = ch_486;
	do
	{
		Eq_2 eax_1004;
		__sti();
		int32 esi_547 = esi_1052 | eax_177;
		uint32 edi_548 = edi_174 | ebx_166;
		word32 edx_554 = edx + ecx_1019 + ecx_1019;
		byte al_563 = (byte) esi_547;
		if (esi_547 == 0x36155017)
		{
			eax_1004 = (Eq_2) DPB(esi_547, (word32) esp_165[esi_547].t0000 + al_563 & ((ebx_166->a23C78BC7))[ecx_1019].b0000, 0);
			return eax_1004;
		}
		ui32 ecx_613 = (ecx_1019 | esi_547) & edi_548;
		ui32 eax_618 = esi_547 - ecx_613 & ecx_613 - edi_548;
		byte al_621 = (byte) eax_618;
		uint32 ecx_623 = ecx_613 & ebx_166;
		if (ecx_623 == 683515615)
		{
			word32 eax_635 = DPB(eax_618, al_621 + Mem532[(ebx_166 + 0x03D10BD3) + ebx_166:byte], 0);
			return eax_635;
		}
		uint32 edx_640 = edx_554 - edi_548;
		ui64 eax_edx_646 = SEQ(eax_618, edx_640) - SEQ(edx_640, edi_548);
		ui32 eax_647 = SLICE(eax_edx_646, word32, 32);
		uint32 edx_649 = (word32) eax_edx_646;
		ui64 eax_ecx_662 = SEQ(eax_647 & ecx_623 & edi_548, ecx_623 - edi_548) - SEQ(eax_647 | edx_649, edi_548);
		struct Eq_93 * eax_663 = SLICE(eax_ecx_662, word32, 32);
		ui32 ecx_668 = (word32) eax_ecx_662 | eax_663 | edx_649;
		struct Eq_93 * edi_679 = edi_548 - edx_649;
		ui32 ecx_676 = ecx_668 | edx_649;
		ecx_358 = (struct Eq_87 *) (edi_679 + edx_649 / 0x3FFFFFD2);
		ui32 ebx_682 = ecx_676;
		cl_359 = (byte) ecx_358;
		struct Eq_93 * esi_691 = eax_663;
		word32 eax_694 = 0x00;
		edi_174 = edi_679;
		edx_1098 = edx_649 - eax_663 - (edi_679 < null) - edi_679;
		if (true)
		{
			ui32 edx_1059 = edx_1098 & ecx_676;
			esi_1052 = eax_663 + edi_679;
			eax_1004 = edx_1098;
			edx = edx_1059 - (ecx_676 - ecx_358 | edx_1059);
			if (edx != (struct Eq_15 *) 0x55BFB4A1)
				goto l004012C6;
			esp_165[edx_1098 * 0x02] = (struct Eq_3) (esp_165[edx_1098 * 0x02] & 0x04);
			goto l004010FD;
		}
l00401311:
		uint32 ebx_834 = ebx_682 & edx_1098;
		uint32 edi_846 = edi_174 - edx_1098 - (esi_691 + eax_694 / 0x3FFFFFD2);
		ui64 ebx_ebx_835 = SEQ(ebx_834, ebx_834);
		esi_1052 = esi_691 - edi_846 & edx_1098;
		if (ecx_358 == (struct Eq_87 *) 1266007597)
		{
l0040132A:
			do
				edx_1098 = (Eq_2) (edx_1098 + 0x02E5AEC9);
			while (edx_1098 != (struct <anonymous> *) 1745437791);
			__fclex();
			__wait();
		}
		uint32 edx_866 = edx_1098 + ebx_834 / 0x001B;
		uint64 edx_edx_869 = SEQ(edx_866, edx_866) + ebx_ebx_835;
		ui32 edx_870 = (word32) edx_edx_869;
		ui32 ebx_873 = ebx_834 - edx_870 - (edx_edx_869 < 0x00);
		edx = edx_870 & esi_1052;
		edi_174 = edi_846 & ebx_873;
		eax_177 = edx_870;
		byte al_877 = (byte) edx_870;
		byte ah_878 = SLICE(edx_870, byte, 8);
		byte dl_884 = (byte) edx;
		ecx_1019 = ecx_358 - edi_174;
		ebx_166 = esi_1052 + ebx_873 / 0x3FFFFFD2 - edx;
	} while (ebx_166 != (struct Eq_7 *) 991192448);
	struct Eq_332 * eax_904 = DPB(edx_870, al_877 + 0x80, 0);
	struct Eq_336 * edx_907 = DPB(edx, dl_884 & eax_904->b8BD23324, 0);
	struct Eq_342 * ebx_912 = ebx_166 - edx_907 - edx_907;
	uint32 edi_915 = edi_174 + ebx_912;
	esp_165 = esp_165 + 0x01;
	ui32 edi_922 = (word32) (edi_915 + SEQ(edi_915, ebx_912)) + edi_915;
	if (ebx_912 + edi_915 / 0x3FFFFFD2 == 2923713477)
	{
		edx_907->t0000.u0 = edx_907->t0000 | ah_878;
		eax_156 = (Eq_2) DPB(edx_870, al_877 + 0x81, 0);
		eax_156->dw3F00B84 = edx_907 + eax_156->dw3F00B84 / 0x3FFFFFD2;
		return eax_156;
	}
	__syscall(0x2E);
	Eq_363 edi_961 = eax_904 - edi_922;
	Eq_365 ecx_956 = edi_922 & edx_907;
	edi_174 = (word32) (SEQ(edi_961, edi_961) - ecx_956);
	ui32 eax_1003;
	int32 ecx_983 = ecx_956 - eax_904;
	esi_1052 = (struct Eq_87 *) (eax_904 + ecx_983);
	int32 ecx_987 = ecx_983 - ecx_956;
	if (edx_907 != (struct Eq_336 *) ~0x00)
		eax_1003 = DPB(edx_870, (edx_907 - (struct Eq_440 *) 0x01)->b0000, 0);
	else
		eax_1003 = DPB(edx_870, 0x2E, 0);
	eax_1004 = eax_1003 - 0xC000002E;
	byte ah_1009 = SLICE(eax_1004, byte, 8);
	if (eax_1004 == null)
		return eax_1004;
	edx = edx_907 & edi_174;
	ecx_1019 = ecx_987 & eax_1004;
	if (eax_1004 == (struct <anonymous> *) 0x331E6836)
	{
		Mem1028[edx + eax_1004:byte] = Mem532[edx + eax_1004:byte] | ah_1009;
		eax = DPB(eax_1004, ah_1009 & esi_1052->t0000, 8);
		goto l004012A1;
	}
l004010FD:
	ecx_358 = esi_1052;
	ui32 eax_736 = eax_1004 | edx | edi_174;
	word32 ebx_742 = edi_174 + esi_1052 - edx;
	ui32 eax_755 = eax_736 & esi_1052;
	ebx_682 = ebx_742 | eax_736;
	edi_174 = edi_174 | esi_1052 + eax_755 / 0x3FFFFFD2;
	byte bl_753 = (byte) ebx_682;
	esi_691 = edi_174;
	eax_694 = eax_755 - edx + esi_1052;
	edx_1098 = edx | edi_174;
	if (edi_174 == (struct Eq_93 *) 2870005059)
	{
		(byte *) 0x355D8E1D = (byte *) 0x355D8E1D + bl_753;
		*(edi_174 - 0x5E) = (word32) esp_165->t0000;
		edi_174->b0001 = edi_174->b0001;
		edi_174->b0002 = edi_174->b0002;
		__maxps(xmm2, edx_1098->ow0000);
	}
	goto l00401311;
}

