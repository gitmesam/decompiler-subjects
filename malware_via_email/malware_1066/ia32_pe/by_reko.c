// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401040: void fn00401040(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn00401040(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	word32 dwLoc08_16 = 0x00;
	while (dwLoc08_16 < dwArg0C)
	{
		Mem30[dwArg04 + dwLoc08_16:byte] = Mem0[dwArg08 + dwLoc08_16:byte];
		dwLoc08_16 = dwLoc08_16 + 0x01;
	}
}

// 004010D0: Register DWORD Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 eax_18 = GetModuleHandleA(0x00);
	if (RegOpenKeyA(0x80000002, 0x00409058, fp - 0x84) != 0x00)
		return 0x01;
	if ((dwArg04 & 0xFFFF) != 0x00)
		Mem190[0x004090E8:word32] = 0x00;
	else
		Mem191[0x004090E8:word32] = 0x01;
	if (Mem0[0x004090E8:word32] != 0x00)
		Mem189[0x004090D8:word32] = dwArg04;
	word32 ecx_86 = Mem0[0x00405000:word32];
	word32 eax_89 = Mem0[0x00405004:word32];
	word32 dwLoc08_109 = 0x00;
	while (dwLoc08_109 <u ecx_86)
	{
		Mem105[dwLoc08_109 + 0x00405008:word32] = Mem0[dwLoc08_109 + 0x00405008:word32] ^ 1222211;
		dwLoc08_109 = dwLoc08_109 + 0x08;
	}
	word32 ebp_140;
	Mem115[0x004090E4:word32] = fn004026C0(eax_89);
	fn00402870(0x00405008, Mem115[0x004090E4:word32], ecx_86);
	Mem128[0x004090D4:word32] = edi;
	Mem129[0x004090D0:word32] = esi;
	Mem130[0x004090E0:word32] = ebx;
	word32 ecx_133 = Mem130[fs:0x18:word32];
	Mem134[0x004090EC:word32] = ecx_133;
	Mem135[0x004090DC:word32] = fp - 0x04;
	if (Mem135[0x004090E8:word32] != 0x00)
		ebp_140 = fn004026F0(0x0040122C - dwArg04, dwArg04);
	else
		ebp_140 = fn004026F0(0x0040122C - eax_18, eax_18);
	word32 edx_142 = Mem135[0x004090E4:word32];
	Mem144[fp - 0xAC + 0x00:word32] = edx_142;
	word32 eax_146 = fn00401290(ebp_140, dwArg00);
	word32 esp_153;
	word32 ebp_154;
	byte SCZO_155;
	word32 ebx_156;
	word32 esi_157;
	word32 edi_158;
	word32 eax_159;
	byte SZO_160;
	byte C_161;
	byte Z_162;
	word32 ecx_163;
	word32 edx_164;
	selector fs_165;
	Mem144[0x004090F0:word32]();
	return eax_159;
}

// 00401270: Register word32 fn00401270(Stack word32 dwArg04, Stack word32 dwArg08)
word32 fn00401270(word32 dwArg04, word32 dwArg08)
{
	return GetProcAddress(dwArg04, dwArg08);
}

// 00401290: Register word32 fn00401290(Register word32 ebp, Stack word32 dwArg04)
word32 fn00401290(word32 ebp, word32 dwArg04)
{
}

// 00402650: void fn00402650(Stack word32 dwArg04, Stack word32 dwArg08)
void fn00402650(word32 dwArg04, word32 dwArg08)
{
}

// 004026C0: Register word32 fn004026C0(Stack word32 dwArg04)
word32 fn004026C0(word32 dwArg04)
{
	return HeapAlloc(GetProcessHeap(), 0x00, dwArg04);
}

// 004026F0: Register word32 fn004026F0(Stack word32 dwArg04, Stack word32 dwArg08)
word32 fn004026F0(word32 dwArg04, word32 dwArg08)
{
	word32 dwLoc20_13;
	if (Mem0[0x004090E8:word32] != 0x00)
		dwLoc20_13 = Mem0[0x004090D8:word32];
	else
		dwLoc20_13 = dwArg08;
	word32 eax_16 = dwLoc20_13 + Mem0[dwLoc20_13 + 0x3C:word32];
	Mem29[0x004090CC:word32] = VirtualAlloc(0x00, Mem0[eax_16 + 0x50:word32], 0x3000, 0x40);
	if (Mem29[0x004090CC:word32] == 0x00)
		return ebp;
	word32 eax_72 = Mem29[0x004090CC:word32];
	fn00401040(eax_72, dwLoc20_13, Mem29[eax_16 + 0x50:word32]);
	word32 ecx_77 = Mem29[0x004090CC:word32] - dwLoc20_13;
	if (Mem29[eax_16 + 0xA4:word32] != 0x00)
	{
		word32 dwLoc0C_104 = dwLoc20_13 + Mem29[eax_16 + 0xA0:word32];
		while (Mem29[dwLoc0C_104 + 0x04:word32] != 0x00)
		{
			word32 ecx_119 = Mem29[dwLoc0C_104 + 0x04:word32] - 0x08 >>u 0x01;
			word32 edx_122 = dwLoc0C_104 + 0x08;
			word32 dwLoc08_125 = 0x00;
			while (dwLoc08_125 <u ecx_119)
			{
				if ((word32) edx_122[dwLoc08_125 * 0x02] >> 0x0C == 0x03)
					Mem166[Mem29[0x004090CC:word32] + Mem29[dwLoc0C_104 + 0x00:word32] + ((word32) edx_122[dwLoc08_125 * 0x02] & 0x0FFF):word32] = Mem29[Mem29[0x004090CC:word32] + Mem29[dwLoc0C_104 + 0x00:word32] + ((word32) edx_122[dwLoc08_125 * 0x02] & 0x0FFF):word32] + ecx_77;
				dwLoc08_125 = dwLoc08_125 + 0x01;
			}
			dwLoc0C_104 = dwLoc0C_104 + Mem29[dwLoc0C_104 + 0x04:word32];
		}
	}
	word32 edx_88 = dwArg04 + Mem29[0x004090CC:word32];
	word32 esp_90;
	word32 ebp_91;
	byte SCZO_92;
	word32 esi_93;
	byte Z_94;
	word32 eax_95;
	word32 ecx_96;
	word32 edx_97;
	byte C_98;
	byte SZO_99;
	edx_88();
	return ebp_91;
}

// 00402840: void fn00402840(Stack word32 dwArg04)
void fn00402840(word32 dwArg04)
{
	Mem13[Mem0[Mem0[0x004090EC:word32] + 0x30:word32] + 0x08:word32] = dwArg04;
}

// 00402870: void fn00402870(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn00402870(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	word32 dwLoc0C_112 = 0x01;
	byte cl_12 = Mem0[dwArg04 + 0x00:byte];
	word32 dwLoc18_118 = 0x00;
	do
	{
		word32 ecx_34 = dwLoc0C_112 + 0x01;
		byte al_31 = Mem0[dwArg04 + dwLoc0C_112:byte];
		dwLoc0C_112 = ecx_34;
		if ((word32) al_31 == (word32) cl_12)
		{
			if ((word32) Mem0[dwArg04 + ecx_34:byte] == 0x00)
			{
				Mem80[dwArg08 + dwLoc18_118:byte] = cl_12;
				dwLoc18_118 = dwLoc18_118 + 0x01;
				dwLoc0C_112 = ecx_34 + 0x01;
			}
			else
			{
				word32 eax_98 = fn00402970(fp - 0x10, dwArg04 + ecx_34) + ecx_34;
				dwLoc0C_112 = fn00402970(fp - 0x20, dwArg04 + eax_98) + eax_98;
				word32 dwLoc1C_113 = 0x00;
				while (dwLoc1C_113 <u dwLoc10)
				{
					Mem130[dwArg08 + dwLoc18_118:byte] = Mem0[dwArg08 + (dwLoc18_118 - dwLoc20):byte];
					dwLoc18_118 = dwLoc18_118 + 0x01;
					dwLoc1C_113 = dwLoc1C_113 + 0x01;
				}
			}
		}
		else
		{
			Mem142[dwArg08 + dwLoc18_118:byte] = al_31;
			dwLoc18_118 = dwLoc18_118 + 0x01;
		}
	} while (dwLoc0C_112 <u dwArg0C);
}

// 00402970: Register word32 fn00402970(Stack word32 dwArg04, Stack word32 dwArg08)
word32 fn00402970(word32 dwArg04, word32 dwArg08)
{
	word32 dwLoc08_12 = 0x00;
	word32 dwLoc10_13 = 0x00;
	do
	{
		word32 ecx_16 = (word32) Mem0[dwArg08 + 0x00:byte];
		word32 ecx_26 = ecx_16 & 0x7F | dwLoc08_12 << 0x07;
		word32 edx_29 = dwLoc10_13 + 0x01;
		dwArg08 = dwArg08 + 0x01;
		dwLoc08_12 = ecx_26;
		dwLoc10_13 = edx_29;
	} while ((ecx_16 & 0x80) != 0x00);
	Mem39[dwArg04 + 0x00:word32] = ecx_26;
	return edx_29;
}

