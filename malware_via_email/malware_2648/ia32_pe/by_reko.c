// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
void fn00401000()
{
}

// 00401105: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 esp_39;
	word32 ebp_40;
	word32 edx_41;
	byte SZO_42;
	bool C_43;
	byte SCZO_44;
	word32 esi_45;
	word32 edi_46;
	word32 ecx_47;
	word32 ebx_48;
	word32 eax_49;
	bool Z_50;
	byte cl_51;
	byte al_52;
	byte dl_53;
	NTDLL.dll!NtSetSystemInformation();
	if (eax_49 != 0xC0000003)
	{
		int3();
		word32 esp_515;
		word32 ebp_516;
		word32 edx_517;
		byte SZO_518;
		bool C_519;
		byte SCZO_520;
		word32 esi_521;
		word32 edi_522;
		word32 ecx_523;
		word32 ebx_524;
		word32 eax_525;
		bool Z_526;
		byte cl_527;
		byte al_528;
		byte dl_529;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_530;
		word32 ebp_531;
		word32 edx_532;
		byte SZO_533;
		bool C_534;
		byte SCZO_535;
		word32 esi_536;
		word32 edi_537;
		word32 ecx_538;
		word32 ebx_539;
		word32 eax_540;
		bool Z_541;
		byte cl_542;
		byte al_543;
		byte dl_544;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_545;
		word32 ebp_546;
		word32 edx_547;
		byte SZO_548;
		bool C_549;
		byte SCZO_550;
		word32 esi_551;
		word32 edi_552;
		word32 ecx_553;
		word32 ebx_554;
		word32 eax_555;
		bool Z_556;
		byte cl_557;
		byte al_558;
		byte dl_559;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_560;
		word32 ebp_561;
		word32 edx_562;
		byte SZO_563;
		bool C_564;
		byte SCZO_565;
		word32 esi_566;
		word32 edi_567;
		word32 ecx_568;
		word32 ebx_569;
		word32 eax_570;
		bool Z_571;
		byte cl_572;
		byte al_573;
		byte dl_574;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_575;
		word32 ebp_576;
		word32 edx_577;
		byte SZO_578;
		bool C_579;
		byte SCZO_580;
		word32 esi_581;
		word32 edi_582;
		word32 ecx_583;
		word32 ebx_584;
		word32 eax_585;
		bool Z_586;
		byte cl_587;
		byte al_588;
		byte dl_589;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_590;
		word32 ebp_591;
		word32 edx_592;
		byte SZO_593;
		bool C_594;
		byte SCZO_595;
		word32 esi_596;
		word32 edi_597;
		word32 ecx_598;
		word32 ebx_599;
		Eq_2 eax_600;
		bool Z_601;
		byte cl_602;
		byte al_603;
		byte dl_604;
		RTUTILS.dll!TraceDumpExA();
		fn00401000();
		return eax_600;
	}
	else
	{
		*(esp_39 - 0x04) = fp - 0x40;
		*(esp_39 - 0x08) = fp - 0x40;
		*(esp_39 - 0x0C) = fp - 0x40;
		*(esp_39 - 0x10) = fp - 0x40;
		*(esp_39 - 0x14) = fp - 0x40;
		word32 ebp_108;
		word32 edx_109;
		byte SZO_110;
		bool C_111;
		byte SCZO_112;
		word32 esi_113;
		word32 edi_114;
		word32 ecx_115;
		word32 ebx_116;
		word32 eax_117;
		bool Z_118;
		byte cl_119;
		byte al_120;
		byte dl_121;
		word32 esp_107;
		NTDLL.dll!NtQuerySemaphore();
		if ((eax_117 ^ 0xC0000003) != 0x00 && (eax_117 ^ 0xC0000003) != 0x01)
		{
			fn00401000();
			esp_107 = esp_107 + 0x04;
		}
		word32 * esp_132 = esp_107 - 0x04;
		*esp_132 = 0x00;
		*(esp_132 - 0x04) = 0x00;
		*(esp_132 - 0x08) = 0x00;
		*(esp_132 - 0x0C) = 0x00;
		*(esp_132 - 0x10) = 0x00;
		*(esp_132 - 0x14) = 0x00;
		*(esp_132 - 0x18) = 0x00;
		ptr32 esp_146;
		ptr32 ebp_147;
		word32 edx_148;
		byte SZO_149;
		bool C_150;
		byte SCZO_151;
		word32 esi_152;
		word32 edi_153;
		word32 ecx_154;
		word32 ebx_155;
		word32 eax_156;
		bool Z_157;
		byte cl_158;
		byte al_159;
		byte dl_160;
		RTUTILS.dll!TraceDumpExA();
		if (true)
		{
			fn00401000();
			return ~0x56;
		}
		else
		{
			word32 v16_172 = 0x00 - -0x7FF0062E;
			ui32 v17_178 = v16_172 + ((dwLoc4C & (fp - 0x3C & 0x00) + ~0x56) + 2272615812 ^ 0x077AA4FF);
			Mem183[fp - 0x04 + -0x18:word32] = v17_178;
			Eq_279 ebx_192 = v17_178 - ((v16_172 + ~0x7F889684 ^ ~0x00) + 0x01) + dwLoc1C;
			word32 v20_204 = (dwLoc14 & 0x00) + ((fp - 0x04) + -((ebx_192 *s 0x00 ^ 0x02A8) + ~0xFF));
			*(esp_146 - 0x04) = 0x00406000;
			ui32 edi_222 = ~((dwLoc08 & v17_178) + -((v20_204 - ~0x0F) *s 0x00 | 0x30));
			*(esp_146 - 0x08) = edi_222 - ~0x00;
			*(esp_146 - 0x0C) = (LPVOID *) ebx_192;
			*(esp_146 - 0x10) = (union Eq_334 *) (fp - 0x01AC);
			fn0040135A(ebp_147);
			*(esp_146 - 0x0C) = 0x40;
			*(esp_146 - 0x10) = 0x3000;
			*(esp_146 - 0x14) = (union Eq_357 *) (fp - 0x28);
			*(esp_146 - 0x18) = 0x00;
			Eq_2 eax_262 = VirtualAlloc(*(esp_146 - 0x18), *(esp_146 - 0x14), *(esp_146 - 0x10), *(esp_146 - 0x0C));
			ui32 edi_265 = fp - (ui32 *) 0x28 ^ fp - (ui32 *) 0x28;
			struct Eq_400 * dwLoc20_213 = v20_204 - ~0x0F;
			int32 dwLoc08_225 = edi_222 - ~0x00;
			Eq_404 dwLoc1C_252 = dwLoc1C & 0x00;
			ptr32 esp_263 = esp_146 - 0x08;
			Eq_2 dwLoc0C_264 = eax_262;
			Eq_404 ebx_267 = fp - 0x24;
			uint32 dwLoc01B0_272 = dwLoc01B0 & edi_265;
			if (edi_265 == 0x00)
			{
				while (dwLoc01B0_272 < v20_204->dw0008)
				{
					word32 * esp_439 = esp_263 - 0x04;
					*esp_439 = 0x00406000;
					*(esp_439 - 0x04) = dwLoc20_213->t0004;
					*(esp_439 - 0x08) = (edi_265 | 0x00400000) + dwLoc20_213->dw0000;
					Mem454[esp_439 - 0x0C + 0x00:word32] = eax_262 + dwLoc1C_252;
					fn0040134F(ebp_147);
					ebx_267 = (word32) dwLoc1C_252 + dwLoc20_213->t0004;
					esp_263 = esp_439 - 0x0C;
					dwLoc1C_252 = ebx_267;
					dwLoc01B0_272 = dwLoc01B0_272 + 0x01;
					dwLoc20_213 = dwLoc20_213 + 0x01;
				}
				ui32 * esp_469 = esp_263 - 0x04;
				*esp_469 = edi_265 | 0x00400000;
				*(esp_469 - 0x04) = v14;
				int32 ebx_488 = ebx_267 & 0x00;
				ui32 esi_496 = *((char *) (v20_204 + ebx_488 / 0x0C) + 0x04) + (ebx_488 - v15) / 0x0C;
				*(esp_469 - 0x08) = esi_496;
				ui32 esi_500 = esi_496 & 0x00 | v13;
				*(esp_469 - 0x0C) = esi_500;
				*(esp_469 - 0x10) = esi_500 + 0x0021C000;
				*(esp_469 - 0x14) = v13;
				return edi_265 | 0x00400000;
			}
			else
			{
				do
				{
					*(esp_146 - 0x0C) = edi_265;
					Eq_2 v43_306 = dwLoc0C_264 & *(esp_146 - 0x0C) *s 0x00 | dwLoc0C_264 - ebx_192;
					dwLoc0C_264 = v43_306;
					Eq_2 eax_311 = dwArg0C;
					if (v43_306 >= dwArg0C)
						return eax_311;
					ui32 eax_363 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg10[dwLoc08_225].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] & 0xFF ^ ~0x00;
					ui32 * eax_373 = (word32) v43_306 + (eax_363 + 0x01 & 0x00 ^ dwArg04);
					word32 eax_384 = DPB(Mem295[eax_373 + 0x00:word32], (byte) ((~(-ebx_192 - 0x01 | ~Mem295[dwArg08 + v43_306:word32]) & 0xFF) + (eax_363 + 0x01)), 0);
					*(esp_146 - 0x0C) = 0x00;
					*eax_373 = *(esp_146 - 0x0C);
					*(esp_146 - 0x0C) = eax_373;
					Mem399[eax_373 + 0x00:word32] = Mem395[eax_373 + 0x00:word32] + -eax_384 + fn004013B9();
					*eax_373 = (*eax_373 ^ ~0x00) + 0x01;
					ui32 edi_411 = (edi_265 & 0x00) + dwLoc08_225;
					eax_311 = esp_146 - 0x08;
					dwLoc08_225 = edi_411 + 0x01;
					edi_265 = edi_411;
					if (edi_411 == 0x00)
						dwLoc08_225 = edi_411 + 0x01 & 0x00;
				} while (dwLoc08_225 != 0x000EF000);
				return eax_311;
			}
		}
	}
}

// 0040134F: void fn0040134F(Register ptr32 ebp)
void fn0040134F(ptr32 ebp)
{
	if (true)
		fn00401000();
	else
		fn0040135A(ebp);
}

// 0040135A: void fn0040135A(Register ptr32 ebp)
void fn0040135A(ptr32 ebp)
{
	if (true)
		fn00401000();
	else
	{
		word32 edx_29 = *(ebp - 0x08) + -~0x152F;
		*(ebp - 0x14) = *(ebp - 0x14) & 0x00;
		*(ebp - 0x14) = *(ebp - 0x14) + edx_29;
		*(ebp - 0x08) = -*(ebp - 0x08);
	}
}

// 004013B9: FlagGroup bool fn004013B9()
bool fn004013B9()
{
	return false;
}

