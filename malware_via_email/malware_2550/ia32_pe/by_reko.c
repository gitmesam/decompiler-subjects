// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
void fn00401000()
{
}

// 004010CF: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	word32 ecx_24 = ecx + 0x01;
	do
		ecx_24 = ecx_24 - 0x01;
	while (ecx_24 != 0x00);
	Eq_11 eax_33 = strlen(fp - 0x14);
	if (eax_33 != 0x03)
	{
		fn00401000();
		return eax_33 - 0x03;
	}
	else
	{
		qsort(fp - 0x14, 0x02, 0x04, GetProcAddress);
		if (true)
		{
			fn00401000();
			return 3557897;
		}
		else
		{
			Eq_2 eax_75 = GetLastError();
			if (eax_75 != 0x7E)
			{
				fn00401000();
				return eax_75;
			}
			else
			{
				fn00401268(fp - 0x04, dwLoc0220);
				return fn004011B1(fp - 0x04);
			}
		}
	}
}

// 004011B1: Register word32 fn004011B1(Register ptr32 ebp)
word32 fn004011B1(ptr32 ebp)
{
	word32 * ebx_8 = *(ebp - 0x10);
	*(ebp - 0x24) = (char *) *((char *) *(ebp - 0x10) + 0x04) + *ebx_8;
	*(ebp - 0x18) = *(ebp - 0x18) & 0x00;
	*(ebp - 0x20) = 0x00;
	word32 ecx_35;
	byte SZO_36;
	byte C_37;
	ptr32 ebp_38;
	byte SCZO_39;
	word32 ebx_40;
	word32 eax_41;
	byte Z_42;
	word32 edi_43;
	word32 esi_44;
	word32 edx_45;
	ptr32 esp_34;
	NTDLL.dll!NtAllocateVirtualMemory();
	word32 eax_46 = *(ebp_38 - 0x20);
	*(ebp_38 - 0x08) = eax_46;
	if (eax_46 == 0x00)
	{
		*(esp_34 - 0x04) = 0xCF;
		return eax_46;
	}
	else
	{
		*(ebp_38 - 0x20) = 0x00400000;
		*(ebp_38 - 0x01AC) = *(ebp_38 - 0x01AC) & 0x00;
		while (*(ebp_38 - 0x01AC) < *((char *) (*(ebp_38 - 0x10)) + 0x08))
		{
			word32 * esp_76 = esp_34 - 0x04;
			*esp_76 = *(ebp_38 - 0x28);
			*(esp_76 - 0x04) = *((char *) *(ebp_38 - 0x1C) + 0x04);
			*(esp_76 - 0x08) = (char *) **(ebp_38 - 0x1C) + *(ebp_38 - 0x20);
			*(esp_76 - 0x0C) = *(ebp_38 - 0x08) + *(ebp_38 - 0x18);
			eax_46 = fn00401260(ebp_38);
			*(ebp_38 - 0x18) = (char *) *((char *) *(ebp_38 - 0x1C) + 0x04) + *(ebp_38 - 0x18);
			esp_34 = esp_76 - 0x0C;
			*(ebp_38 - 0x01AC) = *(ebp_38 - 0x01AC) + 0x01;
			*(ebp_38 - 0x1C) = *(ebp_38 - 0x1C) + 0x08;
		}
		word32 * esp_106 = esp_34 - 0x04;
		*esp_106 = *(ebp_38 - 0x20);
		*(ebp_38 - 0x14) = *(ebp_38 - 0x08) + 5424;
		*(esp_106 - 0x04) = *(ebp_38 - 0x019C);
		*(esp_106 - 0x08) = (char *) *((char *) *(ebp_38 - 0x10) + 0x04) + *(ebp_38 - 0x08);
		*(esp_106 - 0x0C) = *(ebp_38 - 0x14);
		*(esp_106 - 0x10) = 0x3C000000;
		*(esp_106 - 0x14) = *(ebp_38 - 0x14);
		return eax_46;
	}
}

// 00401260: Register word32 fn00401260(Register ptr32 ebp)
word32 fn00401260(ptr32 ebp)
{
	if (0x00 != 0x00)
		return fn00401268(ebp, dwArg00);
	fn00401000();
	return eax;
}

// 00401268: Register Eq_2 fn00401268(Register ptr32 ebp, Stack word32 dwArg00)
Eq_2 fn00401268(ptr32 ebp, word32 dwArg00)
{
	fn00401260(ebp);
	return fn004011B1(ebp);
}

