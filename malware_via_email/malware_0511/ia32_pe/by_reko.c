// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack Eq_3 dwArg04)
word32 fn003E1000(Eq_3 dwArg04)
{
	return dwArg04 + Mem0[dwArg04 + 0x3C:word32];
}

// 003E101C: void fn003E101C(Stack (ptr32 byte) dwArg04, Stack Eq_3 dwArg08, Stack Eq_10 dwArg0C)
void fn003E101C(byte * dwArg04, Eq_3 dwArg08, SIZE_T dwArg0C)
{
	fn003E1944(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 0x08);
}

// 003E10B3: Register Eq_28 fn003E10B3(Stack Eq_29 dwArg04, Stack Eq_30 dwArg08, Stack Eq_30 dwArg0C)
FARPROC fn003E10B3(HMODULE dwArg04, LPCSTR dwArg08, LPCSTR dwArg0C)
{
	Eq_28 eax_40;
	Eq_28 eax_17 = GetProcAddress(dwArg04, dwArg0C);
	if (fn003E1A34(dwArg08, &globals->b3E2030) == 0x00)
	{
		if (fn003E19B0(0x003E2030, dwArg0C, &globals->b3E2040) == 0x00)
		{
			globals->t3E8810 = eax_17;
			eax_40 = (Eq_28) &globals->t3E1050;
			return eax_40;
		}
		if (fn003E19B0(0x003E2040, dwArg0C, &globals->b3E2054) == 0x00)
		{
			globals->t3E8814 = eax_17;
			eax_40 = (Eq_28) &globals->t3E1081;
			return eax_40;
		}
	}
	eax_40 = eax_17;
	return eax_40;
}

// 003E1125: Register byte fn003E1125(Stack ui32 dwArg04)
byte fn003E1125(ui32 dwArg04)
{
	return (byte) (-(dwArg04 & 0x80000000) == 0x00);
}

// 003E1138: void fn003E1138(Stack (ptr32 Eq_77) dwArg04, Stack Eq_3 dwArg08)
void fn003E1138(Eq_77 * dwArg04, Eq_3 dwArg08)
{
	globals->t3E8818 = GetModuleHandleA(null);
	globals->t3E881C = dwArg08;
	struct Eq_88 * dwLoc08_209 = (word32) dwArg08 + dwArg04->dw0080;
	while (dwLoc08_209->dw000C != 0x00)
	{
		ui32 * dwLoc10_111;
		Eq_30 ecx_79 = (word32) dwArg08 + dwLoc08_209->dw000C;
		Eq_29 eax_84 = LoadLibraryA(ecx_79);
		if (dwLoc08_209->dw0004 == 0x00)
			dwLoc10_111 = (word32) dwArg08 + dwLoc08_209->dw0010;
		else
			dwLoc10_111 = (word32) dwArg08 + dwLoc08_209->dw0000;
		word32 * dwLoc18_110 = (word32) dwArg08 + dwLoc08_209->dw0010;
		while (*dwLoc10_111 != 0x00)
		{
			Eq_28 dwLoc14_146;
			if ((word32) fn003E1125(*dwLoc10_111) != 0x00)
				dwLoc14_146 = GetProcAddress(eax_84, (word32) (word16) (*dwLoc10_111 & 0xFFFF));
			else
				dwLoc14_146 = fn003E10B3(eax_84, ecx_79, (word32) dwArg08 + *dwLoc10_111 + 0x02);
			*dwLoc18_110 = (word32) dwLoc14_146;
			dwLoc18_110 = dwLoc18_110 + 0x01;
			dwLoc10_111 = dwLoc10_111 + 0x01;
		}
		dwLoc08_209 = dwLoc08_209 + 0x01;
	}
}

// 003E1260: void fn003E1260(Register ui32 ecx, Stack Eq_170 dwArg04, Stack Eq_3 dwArg08, Stack ui32 dwArg0C)
void fn003E1260(ui32 ecx, HANDLE dwArg04, Eq_3 dwArg08, ui32 dwArg0C)
{
	do
		;
	while (ReadFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E1297: void fn003E1297(Register ui32 ecx, Stack Eq_170 dwArg04, Stack Eq_194 dwArg08, Stack ui32 dwArg0C)
void fn003E1297(ui32 ecx, HANDLE dwArg04, LPCVOID dwArg08, ui32 dwArg0C)
{
	do
		;
	while (WriteFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E12CE: void fn003E12CE(Register ui32 ecx, Stack (ptr32 Eq_216) dwArg04, Stack ui32 dwArg08, Stack uint32 dwArg0C)
void fn003E12CE(ui32 ecx, Eq_216 * dwArg04, ui32 dwArg08, uint32 dwArg0C)
{
	uint32 dwLoc08_14 = ecx & 0x00;
	while (dwLoc08_14 < dwArg0C)
	{
		fn003E1297(dwArg08, dwArg04->t0004, dwArg08 + dwLoc08_14 * 0x04, 0x08);
		fn003E1260(dwArg08, dwArg04->t0000, dwArg08 + dwLoc08_14 * 0x04, 0x08);
		dwLoc08_14 = dwLoc08_14 + 0x02;
	}
}

// 003E1415: void fn003E1415(Stack (ptr32 Eq_245) dwArg04)
void fn003E1415(Eq_245 * dwArg04)
{
	CloseHandle(dwArg04->t0000);
	CloseHandle(dwArg04->t0004);
}

// 003E1432: Register word32 fn003E1432(Register ui32 ecx)
word32 fn003E1432(ui32 ecx)
{
	struct Eq_260 * eax_16 = fn003E15D0()->ptr0030;
	if ((word32) eax_16->b0002 == 0x00)
	{
		globals->dw40FF0E = 5900;
		globals->dw40FF0E = globals->dw40FF0E + 22702;
		globals->dw40FF12 = 0x24C5;
		globals->dw40FF16 = 0x17F4;
		globals->dw40FF16 = globals->dw40FF16 + 22574;
		globals->dw40FF1A = 0x4BC0;
		if (CreatePipe(fp - 0x24, fp - 0x14, null, 0x10) != 0x00 && CreatePipe(fp - 0x18, fp - 0x20, null, 0x10) != 0x00)
		{
			Eq_170 eax_119 = CreateThread(null, 0x00, &globals->t3E1322, fp - 0x24, 0x00, fp - 0x0C);
			fn003E12CE(ecx, fp - 0x18, 0x003E3000, globals->dw3E8803 >> 0x02);
			fn003E1415(fp - 0x18);
			fn003E1415(fp - 0x24);
			CloseHandle(eax_119);
			struct Eq_77 * eax_151 = fn003E1000(0x003E3000);
			if (eax_151 != null)
			{
				Eq_3 eax_172 = eax_151->t0034;
				fn003E101C(&globals->b3E3000, eax_172, eax_151->t0054);
				fn003E15E0(eax_151, 0x003E3000, eax_172);
				struct Eq_77 * eax_198 = fn003E1000(eax_172);
				if (eax_198 != null)
				{
					fn003E1138(eax_198, eax_172);
					fn003E1778(eax_198, eax_172);
					eax_16->t0008 = eax_172;
					<anonymous> * ecx_237 = (word32) eax_172 + eax_151->dw0028;
					word32 esp_240;
					word32 ebp_241;
					byte SCZO_242;
					word32 eax_243;
					byte SZO_244;
					bool C_245;
					bool Z_246;
					word32 ecx_247;
					ecx_237();
				}
			}
		}
	}
	return 0x00;
}

// 003E15B6: Register Eq_21 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ExitProcess(fn003E1432(ecx));
}

// 003E15D0: Register word32 fn003E15D0()
word32 fn003E15D0()
{
	return fs->dw0018;
}

// 003E15E0: void fn003E15E0(Stack (ptr32 Eq_77) dwArg04, Stack word32 dwArg08, Stack Eq_3 dwArg0C)
void fn003E15E0(Eq_77 * dwArg04, word32 dwArg08, Eq_3 dwArg0C)
{
	word16 ax_21 = dwArg04->w0006;
	cui16 wLoc14_138 = wLoc14 & 0x00;
	while ((word32) wLoc14_138 < (word32) ax_21)
	{
		Eq_10 dwLoc2C_140;
		Eq_10 v15_64 = (&dwArg04->dw0080 + 0x001E)[((word32) wLoc14_138 *s 0x28 + 0x08) / 0x0084];
		Eq_10 eax_77 = (&dwArg04->dw0080 + 0x001E)[((word32) wLoc14_138 *s 0x28 + 0x10) / 0x0084];
		if (v15_64 < eax_77)
			dwLoc2C_140 = v15_64;
		else
			dwLoc2C_140 = eax_77;
		fn003E1944(dwArg0C + Mem0[((word32) wLoc14_138 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem0[((word32) wLoc14_138 *s 0x28 + 0x14) + (dwArg04 + 0xF8):word32], dwLoc2C_140);
		wLoc14_138 = wLoc14_138 + 0x01;
	}
}

// 003E16AE: Register ui32 fn003E16AE(Register Eq_483 ecx, Stack ui32 dwArg04)
ui32 fn003E16AE(Eq_483 ecx, ui32 dwArg04)
{
	ui32 dwLoc08_14 = ecx & 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_14 = ecx & 0x00 | 0x0200;
	ui32 dwLoc08_108;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_108 = dwLoc08_14 | 0x40;
			else
				dwLoc08_108 = dwLoc08_14 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_108 = dwLoc08_14 | 0x80;
		else
			dwLoc08_108 = dwLoc08_14 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_108 = dwLoc08_14 | 0x04;
		else
			dwLoc08_108 = dwLoc08_14 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_108 = dwLoc08_14 | 0x08;
	else
		dwLoc08_108 = dwLoc08_14 | 0x01;
	return dwLoc08_108;
}

// 003E1778: void fn003E1778(Stack (ptr32 Eq_77) dwArg04, Stack Eq_3 dwArg08)
void fn003E1778(Eq_77 * dwArg04, Eq_3 dwArg08)
{
	word16 ax_21 = dwArg04->w0006;
	cui16 wLoc14_27 = wLoc14 & 0x00;
	while ((word32) wLoc14_27 < (word32) ax_21)
	{
		VirtualProtect(dwArg08 + Mem0[((word32) wLoc14_27 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], Mem0[(word32) wLoc14_27 *s 0x28 + 0x08 + (dwArg04 + 0xF8):word32], fn003E16AE(dwArg04 + 0xF8, Mem0[(word32) wLoc14_27 *s 0x28 + 0x24 + (dwArg04 + 0xF8):word32]), fp - 0x18);
		wLoc14_27 = wLoc14_27 + 0x01;
	}
}

// 003E1810: Register int32 fn003E1810(Stack int32 dwArg04)
int32 fn003E1810(int32 dwArg04)
{
	int32 eax_12;
	if (dwArg04 >= 0x41 && dwArg04 <= 0x5A)
		eax_12 = dwArg04 + 0x20;
	else
		eax_12 = dwArg04;
	return eax_12;
}

// 003E1944: void fn003E1944(Stack Eq_3 dwArg04, Stack (ptr32 byte) dwArg08, Stack Eq_10 dwArg0C)
void fn003E1944(Eq_3 dwArg04, byte * dwArg08, SIZE_T dwArg0C)
{
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = *dwArg08;
		dwArg04 = (word32) dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
}

// 003E19B0: Register int32 fn003E19B0(Register word32 ecx, Stack Eq_30 dwArg04, Stack (ptr32 byte) dwArg08)
int32 fn003E19B0(word32 ecx, LPCSTR dwArg04, byte * dwArg08)
{
	while (true)
	{
		int32 eax_28 = (word32) (*dwArg04 - *dwArg08);
		int32 dwLoc08_31 = eax_28;
		if (eax_28 != 0x00 || (int32) (*dwArg08) == 0x00)
			break;
		dwArg04 = (Eq_30) (dwArg04 + 0x01);
		dwArg08 = dwArg08 + 0x01;
	}
	if (eax_28 < 0x00)
		dwLoc08_31 = eax_28 | ~0x00;
	else if (eax_28 > 0x00)
		dwLoc08_31 = 0x01;
	return dwLoc08_31;
}

// 003E1A34: Register word32 fn003E1A34(Stack Eq_30 dwArg04, Stack (ptr32 byte) dwArg08)
word32 fn003E1A34(LPCSTR dwArg04, byte * dwArg08)
{
	do
	{
		word32 eax_23 = fn003E1810((word32) *dwArg04);
		dwArg04 = (Eq_30) (dwArg04 + 0x01);
		word32 eax_37 = fn003E1810((word32) *dwArg08);
		dwArg08 = dwArg08 + 0x01;
	} while (eax_23 != 0x00 && eax_23 == eax_37);
	return eax_23 - eax_37;
}

