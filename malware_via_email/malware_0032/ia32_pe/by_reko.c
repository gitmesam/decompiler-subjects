// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register DWORD Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 ecx_15;
	byte dh_16;
	word32 ebp_17;
	word32 eax_18 = fn00401078(out ecx_15, out dh_16, out ebp_17);
	Mem25[fp - 0x18 + 0x00:word32] = Mem0[0x00404400:word32];
	Mem27[fp - 0x1C + 0x00:word32] = 0x00402000;
	fn00401128(eax_18, ecx_15, dh_16, ebp_17);
	Mem34[fp - 0x18 + 0x00:word32] = 0x062E;
	Mem36[fp - 0x1C + 0x00:word32] = 0x00401128;
	word32 ecx_37;
	byte dh_38;
	word32 ebp_39;
	fn00401078(out ecx_37, out dh_38, out ebp_39);
	if (false)
	{
		Mem52[fp - 0x18 + 0x00:word32] = 0x00405000;
		Mem54[fp - 0x1C + 0x00:word32] = 0x00401000;
		lstrcpyA(Mem54[fp - 0x1C + 0x00:LPSTR], Mem54[fp - 0x18 + 0x00:LPCSTR]);
	}
	return 0x00;
}

// 00401078: Register word32 fn00401078(Register out ptr32 ecxOut, Register out ptr32 dhOut, Register out ptr32 ebpOut)
word32 fn00401078(ptr32 & ecxOut, ptr32 & dhOut, ptr32 & ebpOut)
{
	word32 ecx_9;
	byte dh_10;
	word32 ebp_11;
	return fn00401085(fp - 0x04, out ecx_9, out dh_10, out ebp_11);
}

// 00401085: Register word32 fn00401085(Register word32 ebp, Register out ptr32 ecxOut, Register out ptr32 dhOut, Register out ptr32 ebpOut)
word32 fn00401085(word32 ebp, ptr32 & ecxOut, ptr32 & dhOut, ptr32 & ebpOut)
{
	esp = v3;
	eax = Mem0[ebp - 0x04 + 0x00:word32];
	edx_eax = SEQ(edx, eax);
	al = (byte) eax;
	SCZO = cond(eax - Mem0[ebp + 0x0C:word32]);
	SO = SCZO;
	if (Test(GE,SO))
	{
		esp = ebp;
		ebp = Mem0[esp + 0x00:word32];
		esp = esp + 0x04;
		return eax;
	}
	else
	{
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x00);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			eax = eax & 0x01;
			SZO = cond(eax & eax);
			Z = (bool) SZO;
			C = false;
			if (Test(EQ,Z))
			{
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				ecx = Mem0[ebp + 0x08:word32];
				ecx = ecx + eax;
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				edx = Mem0[ebp + 0x08:word32];
				edx = edx + eax;
				al = ~0x0C;
				al = ~0x0C ^ Mem0[edx + 0x00:byte];
				SZO = cond(al);
				C = false;
				Mem0[ecx + 0x00:byte] = al;
			}
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x02);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			edx = Mem0[ebp - 0x04 + 0x00:word32];
			edx = edx - 0x02;
			eax = 0x03;
			ecx = 0x03;
			eax = edx;
			edx = edx >> 0x1F;
			edx_eax = SEQ(edx, eax);
			v15 = edx_eax;
			edx = (int32) (v15 % 0x03);
			eax = (int32) (v15 / 0x03);
			SZO = cond(edx & edx);
			Z = (bool) SZO;
			C = false;
			if (Test(EQ,Z))
			{
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				edx = Mem0[ebp + 0x08:word32];
				edx = edx + eax;
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				eax = eax + Mem0[ebp + 0x08:word32];
				al = Mem0[eax + 0x00:byte];
				eax = DPB(eax, al, 0);
				eax = eax + 88;
				al = (byte) eax;
				SCZO = cond(eax);
				Mem0[edx + 0x00:byte] = al;
			}
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x03);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			edx = Mem0[ebp + 0x08:word32];
			edx = edx + eax;
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			eax = eax + Mem0[ebp + 0x08:word32];
			al = Mem0[eax + 0x00:byte];
			eax = DPB(eax, al, 0);
			eax = eax - 0x22;
			al = (byte) eax;
			SCZO = cond(eax);
			Mem0[edx + 0x00:byte] = al;
		}
		eax = Mem0[ebp - 0x04 + 0x00:word32];
		ecx = Mem0[ebp + 0x08:word32];
		ecx = ecx + eax;
		eax = Mem0[ebp - 0x04 + 0x00:word32];
		eax = eax + Mem0[ebp + 0x08:word32];
		edx_eax = SEQ(edx, eax);
		al = (byte) eax;
		SCZO = cond(eax);
		eax = fn00401113(eax, ecx, ebp, out ecx, out dh, out ebp);
		edx_eax = SEQ(edx, eax);
		al = (byte) eax;
		return eax;
	}
}

// 00401113: Register word32 fn00401113(Register word32 eax, Register word32 ecx, Register word32 ebp, Register out ptr32 ecxOut, Register out ptr32 dhOut, Register out ptr32 ebpOut)
word32 fn00401113(word32 eax, word32 ecx, word32 ebp, ptr32 & ecxOut, ptr32 & dhOut, ptr32 & ebpOut)
{
	ptr32 fp;
	word32 ebp;
	<type-error> Mem0;
	word32 eax;
	word32 ecx;
	ptr32 ecxOut;
	ptr32 dhOut;
	ptr32 ebpOut;
	esp_1 = fp;
	edx_4 = Mem0[ebp - 0x04 + 0x00:word32];
	dl_5 = (byte) edx_4;
	eax_11 = fn00401115(eax, ecx, dl_5, ebp, out ecx_8, out dh_9, out ebp_10);
	al_12 = (byte) eax_11;
	return eax_11;
}

// 00401115: Register word32 fn00401115(Register word32 eax, Register word32 ecx, Register byte dl, Register word32 ebp, Register out ptr32 ecxOut, Register out ptr32 dhOut, Register out ptr32 ebpOut)
word32 fn00401115(word32 eax, word32 ecx, byte dl, word32 ebp, ptr32 & ecxOut, ptr32 & dhOut, ptr32 & ebpOut)
{
	ptr32 fp;
	word32 eax;
	<type-error> Mem0;
	byte dl;
	word32 ecx;
	word32 ebp;
	ptr32 ecxOut;
	ptr32 dhOut;
	ptr32 ebpOut;
	esp_1 = fp;
	D_2 = false;
	al_5 = Mem0[eax + 0x00:byte];
	al_7 = al_5 - dl;
	SCZO_8 = cond(al_7);
	Mem9[ecx + 0x00:byte] = al_7;
	eax_12 = ebp - 0x04;
	v10_13 = Mem9[eax_12 + 0x00:word32] + 0x01;
	Mem14[eax_12 + 0x00:word32] = v10_13;
	SZO_15 = cond(v10_13);
	eax_19 = fn00401085(ebp, out ecx_16, out dh_17, out ebp_18);
	al_20 = (byte) eax_19;
	return eax_19;
}

// 00401128: void fn00401128(Register word32 eax, Register word32 ecx, Register byte dh, Register word32 ebp)
void fn00401128(word32 eax, word32 ecx, byte dh, word32 ebp)
{
	byte dl_7 = (fp - 0x04)[eax * 0x04];
	if (Z && ecx != 0x01)
	{
		if (SO)
		{
			word32 ecx_25;
			byte dh_26;
			word32 ebp_27;
			fn00401113(eax, ecx - 0x01, ebp, out ecx_25, out dh_26, out ebp_27);
		}
		else
		{
			Mem19[ecx + 0x05:byte] = Mem0[ecx + 0x05:byte] - dh;
			word32 ecx_21;
			byte dh_22;
			word32 ebp_23;
			fn00401115(eax, ecx - 0x01, dl_7, ebp, out ecx_21, out dh_22, out ebp_23);
		}
	}
}

