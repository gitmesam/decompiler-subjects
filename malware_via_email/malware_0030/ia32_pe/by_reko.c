// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	byte cl_15;
	struct Eq_4 * edx_16;
	struct Eq_5 * eax_17 = fn00401078(globals->a401128, 0x062E, out cl_15, out edx_16);
	fn00401128(eax_17, cl_15, edx_16, bl, bh, fp - 0x04, esi, edi, rArg0, rArg1);
	byte cl_43;
	word32 edx_44;
	fn00401078(globals->a401128, 0x062E, out cl_43, out edx_44);
	if (false)
		lstrcpyA(&globals->t401000, &globals->t405000);
	return 0x00;
}

// 00401078: Register int32 fn00401078(Stack (arr Eq_81) dwArg04, Stack int32 dwArg08, Register out Eq_10 clOut, Register out ptr32 edxOut)
int32 fn00401078(Eq_81 dwArg04[], int32 dwArg08, Eq_10 & clOut, ptr32 & edxOut)
{
	*clOut = cl;
	*edxOut = edx;
	int32 dwLoc08_22 = 0x00;
	while (dwLoc08_22 < dwArg08)
	{
		if (dwLoc08_22 > 0x01 && (dwLoc08_22 - 0x01 & 0x01) == 0x00)
		{
			byte * eax_110 = (dwArg04 + dwLoc08_22)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg04[dwLoc08_22].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (byte) (DPB(eax_110, *eax_110, 0) ^ 0x43);
		}
		if (dwLoc08_22 > 0x01)
		{
			byte * eax_93 = (dwArg04 + dwLoc08_22)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg04[dwLoc08_22].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (byte) (DPB(eax_93, *eax_93, 0) + 121);
		}
		if (dwLoc08_22 > 0x03)
		{
			Eq_113 edx_66 = dwLoc08_22 - 0x03;
			if ((int32) (SEQ(edx_66 >> 0x1F, edx_66) % 0x03) == 0x00)
			{
				byte * eax_82 = (dwArg04 + dwLoc08_22)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg04[dwLoc08_22].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (byte) (DPB(eax_82, *eax_82, 0) - 0x04);
			}
		}
		byte * ecx_49 = (dwArg04 + dwLoc08_22)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000;
		*ecx_49 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg04[dwLoc08_22].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] - (byte) dwLoc08_22;
		byte cl_50;
		*clOut = (byte) ecx_49;
		word32 edx_53;
		*edxOut = dwLoc08_22;
		dwLoc08_22 = dwLoc08_22 + 0x01;
	}
	return dwLoc08_22;
}

// 00401128: FpuStack real64 fn00401128(Register (ptr32 Eq_5) eax, Register byte cl, Register (ptr32 Eq_4) edx, Register byte bl, Register byte bh, Register (ptr32 Eq_24) ebp, Register (ptr32 word32) esi, Register (ptr32 Eq_26) edi, FpuStack real64 rArg0, FpuStack real64 rArg1)
real64 fn00401128(Eq_5 * eax, byte cl, Eq_4 * edx, byte bl, byte bh, Eq_24 * ebp, word32 * esi, Eq_26 * edi, real64 rArg0, real64 rArg1)
{
	if (CZ)
	{
		edi->dw0000 = *esi;
		__inb(166);
	}
	else
	{
		__syscall(~0x70);
		edi->r9AC09A50 = rArg0;
		ebp->w856661D9 = (int16) rArg1;
		__fbld(edx->n282FF4DC);
		byte al_15 = (byte) edi;
		word16 ax_16 = (word16) edi;
		if (!O)
			__syscall(0x04);
		__outb(166, al_15);
		__outw(dx, ax_16);
		eax->b0004 = __in(dx);
		word32 esp_38;
		word32 ebp_39;
		byte ch_40;
		word32 esi_41;
		byte CZ_42;
		word32 eax_43;
		word32 edi_44;
		struct Eq_198 * cs_45;
		real64 rArg0_46;
		real64 rArg1_47;
		word32 edx_48;
		bool O_49;
		byte al_50;
		byte SCZO_51;
		word16 dx_52;
		word16 ax_53;
		bool C_54;
		byte bl_55;
		byte bh_56;
		byte SZO_57;
		byte cl_58;
		fn356303FE();
		return rArg0_46;
	}
}

