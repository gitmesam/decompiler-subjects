// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004038B8: Register (ptr32 uint32) HKrXZROZ_Mf_noYJLG(Stack uint32 dwArg04, Stack real32 rArg08)
uint32 * HKrXZROZ_Mf_noYJLG(uint32 dwArg04, real32 rArg08)
{
	word32 ecx_19 = Mem0[0x0040AB76:word32] + Mem0[4238294:word32] + (Mem0[0x0040AB16:word32] <u eax);
	globals->dw40AB76 = ecx_19;
	ui32 * edi_22 = globals->ptr40AD02;
	*edi_22 = *edi_22 | globals->t40ABA2;
	globals->dw40AB56 = globals->dw40AB56 - *globals->ptr40AC6E - (ebx < ecx_19);
	return eax;
}

// 00403900: void _riGFEGY_WGXY_qbsOD_(Stack char bArg04)
void _riGFEGY_WGXY_qbsOD_(char bArg04)
{
	globals->dw40AB9E = (word32) ((bool) (globals->t40AAF6 < edi) + ((word32) globals->t40AB6E + globals->dw40AB9E));
	ui32 * ebx_19 = globals->ptr40AD52;
	*ebx_19 = *ebx_19 & globals->dw40AB32;
	word32 * edi_23 = globals->ptr40ACC2;
	*edi_23 = *edi_23 - globals->dw40AB6A;
}

// 00403940: Register (ptr32 void) JVPFYysga_h(Stack int32 dwArg04, Stack (ptr32 real32) ptrArg08)
void(int32 dwArg04, real32 * ptrArg08)
{
	globals->t40AAF2 = globals->t40AAF2 ^ *globals->ptr40AD32;
	globals->dw40ABBA = globals->dw40ABBA & (word32) globals->t40ABDA;
	ui32 * ecx_22 = globals->ptr40AC7A;
	*ecx_22 = *ecx_22 | globals->dw40ABDE;
	return eax;
}

// 00403981: Register uint16 Q_B_GTvmg_bvsmX(Stack uint32 dwArg04)
uint16 Q_B_GTvmg_bvsmX(uint32 dwArg04)
{
	globals->dw40AB66 = globals->dw40AB66 + globals->dw40AB72;
	globals->t40AB12 = globals->t40AB12 ^ *globals->ptr40AD02;
	globals->t40AB46 = (word32) globals->t40AB46 & *globals->ptr40ACF2;
	return ax;
}

// 004039FA: Register ui32 fn004039FA(Register Eq_50 edx, Stack (ptr32 Eq_147) dwArg04, Stack byte bArg07, Stack (ptr32 word32) dwArg08)
ui32 fn004039FA(Eq_50 edx, Eq_147 * dwArg04, byte bArg07, word32 * dwArg08)
{
	ptr32 esp_149 = fp - 0x5C;
	ui32 dwLoc14_117 = 0x1B;
	while (dwLoc14_117 != 0x00)
	{
		if (dwLoc14_117 == 0x1D)
		{
			CreatePropertySheetPageA((PROPSHEETPAGEA_V4 *) 23155);
			esp_149 = fp - 0x5C;
		}
		dwLoc14_117 = dwLoc14_117 - 0x01;
	}
	ptr32 esp_114;
	word32 eax_125;
	if (true)
	{
		union Eq_232 * esi_208 = globals->ptr40ACDA;
		word32 ecx_197 = globals->dw40A0F0;
		*esi_208 = (union Eq_232 *) ((char *) *esi_208 + 44);
		esp_114 = fp - 100;
		if (0x01 == ecx_197 || 0x00 == *dwArg04->ptr0038)
		{
			eax_125 = ~0x101E;
			goto l00403C0D;
		}
		struct Eq_147 * ecx_242 = globals->ptr40A2D8;
		edx = *ecx_242->ptr0008;
		dwLoc14_117 = dwLoc14_117 & dwLoc18;
		word32 eax_251 = Mem210[Mem210[edx + 0x3C:word32] + 0x28 + edx:word32] + edx;
		if (ecx_242->dw0040 != 0x00)
		{
			struct Eq_289 * edx_291 = globals->ptr40A310;
			edx_291->t0000 = (<anonymous>) 233;
			struct Eq_289 * ecx_298 = globals->ptr40A310;
			ecx_298->dw0001 = eax_251 - ~0x2529 - ecx_298 - 0x252F;
			word32 ebp_320;
			byte SCZO_321;
			word32 eax_322;
			word32 ecx_323;
			bool Z_324;
			byte CZ_325;
			word32 esi_326;
			word32 edi_327;
			byte SZO_328;
			bool C_329;
			byte cl_331;
			word32 ebx_332;
			globals->ptr40A310();
			*dwArg08 = eax_322;
		}
		globals->dw40AB56 = globals->dw40AB56 ^ dwLoc3C;
		globals->t40A100 = null;
		globals->dw40AB0E = globals->dw40AB0E & 0x00;
l00403B8B:
		globals->dw40AB0E = globals->dw40AB0E + 0x01;
		if (globals->dw40AB0E != 0x2A)
		{
l00403BC8:
			if (globals->dw40AB0E >= 0x1C)
			{
				globals->dw40A104 = 0x00;
				eax_125 = ~0x101D;
l00403C0D:
				globals->dw40AB72 = globals->dw40AB72 - 4238242 - (edx < globals->t40AAF6);
				globals->dw40AB72 = globals->dw40AB72 ^ 0x0040AB12;
				return (eax_125 ^ 0x3530) + 0x252F;
			}
			goto l00403B8B;
		}
		word32 * esp_188 = esp_114 - 0x04;
		*esp_188 = 0x2920;
		*(esp_188 - 0x04) = 0x3A69;
		*(esp_188 - 0x08) = 0x72870000;
		*(esp_188 - 0x0C) = 0x75A5;
		esp_149 = esp_188 - 0x0C;
	}
	struct Eq_170 * esp_152 = esp_149 - 0x04;
	esp_152->t0000.u0 = 0x2454;
	*(esp_152 - 0x04) = 33958;
	*(esp_152 - 0x08) = dwLoc14_117;
	SetDIBits(*(esp_152 - 0x08), *(esp_152 - 0x04), esp_152->t0000, esp_152->t0004, esp_152->ptr0008, esp_152->ptr000C, esp_152->t0010);
	esp_114 = (char *) &esp_152->t0010 + 0x04;
	goto l00403BC8;
}

// 00403C31: Register (ptr32 ui32) fn00403C31(Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08, Stack word32 dwArg0C)
ui32 * fn00403C31(word32 * dwArg04, word32 * dwArg08, word32 dwArg0C)
{
	globals->dw40AB42 = 22;
	Eq_396 eax_123 = ~0x101E;
	while (globals->dw40AB42 != 0x00)
	{
		if (globals->dw40AB42 == 0x26)
			eax_123 = SystemParametersInfoW(23276, 6300, dwLoc2C, 30379);
		globals->dw40AB42 = globals->dw40AB42 - 0x01;
	}
	if (false)
	{
		union Eq_425 * ecx_172 = globals->ptr40AC9A;
		*ecx_172 = (union Eq_425 *) ((char *) *ecx_172 + 66);
	}
	do
	{
		word32 edx_79 = 0x0040A0D4[(eax_123 + 0x01 & 0x03) * 0x04];
		int32 edi_81 = *edx_79 *s eax_123;
		globals->dw40ABBA = globals->dw40ABBA + 0x0040AB0E;
		globals->dw40ABBA = globals->dw40ABBA ^ 4238118;
		globals->dw40ABBA = globals->dw40ABBA + 0x0040AAFA;
		*edx_79 = edi_81 *s ~0x201B;
		globals->t40ABA2 = globals->t40ABA2 & 0x0040AB5E;
		globals->t40ABA2 = (word32) globals->t40ABA2 + 4238230;
		globals->t40ABA2 = (word32) globals->t40ABA2 + 4238114;
		ui32 * edx_103 = *((char *) globals->a40A0D4 + (eax_123 - 0x01 & 0x03) * 0x04);
		*edx_103 = *edx_103 ^ (eax_123 *s ~0x201C | eax_123);
		globals->ptr40A304 = dwArg04;
		if (eax_123 == ~0x11DE)
			globals->ptr40A308 = dwArg08;
		else if (eax_123 == ~0x119E)
			globals->dw40A30C = dwArg0C;
		globals->dw40AB56 = globals->dw40AB56 + 0x2272;
		eax_123 = (eax_123 ^ 0x3530) + 0x01 ^ 0x3530;
		word32 * edx_136 = *((char *) globals->a40A0D4 + (eax_123 & 0x03) * 0x04);
		*edx_136 = *edx_136 + (eax_123 *s ~0x201D ^ eax_123);
		ui32 * edx_144 = *((char *) globals->a40A0D4 + (eax_123 - 0x02 & 0x03) * 0x04);
		*edx_144 = *edx_144 | eax_123 *s ~0x201A;
	} while (eax_123 != ~0x112E);
	return edx_144;
}

// 00403E03: void fn00403E03(Register (ptr32 Eq_562) eax)
void fn00403E03(Eq_562 * eax)
{
	globals->ptr40A554 = (word32 *) ((char *) &eax->t0000 + 0x04);
	globals->t40A548 = eax->t0008;
	globals->t40A54C = eax->t000C;
	globals->t40A550 = eax->t0010;
}

// 00403E27: Register Eq_569 fn00403E27(Register ptr32 ebp, Register (ptr32 Eq_584) esi, Register Eq_569 edi)
Eq_569 fn00403E27(ptr32 ebp, Eq_584 * esi, Eq_569 edi)
{
	esi->t0000.u0 = 0x01;
	InterlockedExchange(&globals->t40A2EC, 0x00760677);
	if (esi->t0000 != edi)
	{
		ptr32 esp_125 = fp - 0x04;
		do
		{
			ecx = esi->t0000;
			if (ecx < edi)
			{
				if (ecx == 0x00)
					goto l00403EDA;
				globals->dw40AB22 = globals->dw40AB22 & 0x00;
				do
				{
					globals->dw40AB22 = globals->dw40AB22 + 0x01;
					if (globals->dw40AB22 == 0x24)
					{
						word32 * esp_117 = esp_125 - 0x04;
						*esp_117 = *(ebp - 0x0C);
						*(esp_117 - 0x04) = 6888;
						*(esp_117 - 0x08) = 0x0040AF0F;
						*(esp_117 - 0x0C) = 0x4558;
						word32 eax_127;
						byte SCZO_129;
						bool Z_130;
						word32 ebx_131;
						bool C_133;
						byte SZO_134;
						word32 edx_136;
						COMCTL32.dll!CreateStatusWindowW();
					}
				} while (globals->dw40AB22 < 0x1E);
				esi->t0000 = (word32) ecx + ((uint32) ((uint64) ((uint32) edi) /u 0x0101) + 0x01);
			}
			else if (ecx == 0x00)
			{
l00403EDA:
				esi->t0000 = edi;
			}
			else
			{
				esi->t0000 = ecx - 0x01;
				ecx = ecx - 0x01;
			}
		} while (esi->t0000 != edi);
	}
	return ecx;
}

// 00403EEE: Register ui32 fn00403EEE(Register word32 edi)
ui32 fn00403EEE(word32 edi)
{
	Eq_396 eax_11 = globals->t40A080;
	globals->dw40AB0A = globals->dw40AB0A & 0x00;
	while (globals->dw40AB0A < 0x14)
	{
		if (globals->dw40AB0A == 0x18)
			eax_11 = DestroyCaret();
		globals->dw40AB0A = globals->dw40AB0A + 0x01;
	}
	byte eax_32[] = *eax_11;
	if (~0x2C01 != 0x00)
	{
		dwLoc0C = eax_32;
		eax_32 = (byte (*)[]) *globals->ptr40A084;
	}
	Mem44[0x0040AAF6:word32] = Mem13[0x0040AAF6:word32] + Mem13[Mem13[0x0040ACA6:word32] + 0x00:word32];
	globals->ptr40A2F0 = dwLoc0C;
	globals->t40A2F4 = eax_32 + (0x04 - globals->ptr40A2F0);
	word32 eax_77 = ~0x101D;
	if (globals->ptr40A2F0 == null)
	{
		globals->t40ABDA = -globals->t40ABDA;
		eax_77 = ~0x101E;
	}
	return (eax_77 ^ 0x3530) + 0x252F;
}

// 00404004: void fn00404004()
void fn00404004()
{
	if (true)
		globals->dw40AB2A = globals->dw40AB2A | (word32) bLoc2C;
	globals->dw40ABD2 = globals->dw40ABD2 & 0x00;
	while (globals->dw40ABD2 < 0x19)
	{
		if (globals->dw40ABD2 == 0x23)
			FormatMessageA(0x48BC, dwLoc24, 0x2D2B, dwLoc2C, &globals->dw40ABA6, dwLoc1C, dwLoc1C);
		globals->dw40ABD2 = globals->dw40ABD2 + 0x01;
	}
	globals->dw40ABBE = globals->dw40ABBE - 4238242;
	globals->dw40ABBE = globals->dw40ABBE ^ 4238238;
	globals->dw40ABBE = globals->dw40ABBE - 0x0040AAF2;
	if (false)
		globals->dw40AB8E = globals->dw40AB8E & 0x3962;
	globals->t40AB12.u1 = 0x0040AB8A;
	globals->t40AB12 = globals->t40AB12 & 4238262;
	globals->t40AB12 = globals->t40AB12 - 4238286;
	word32 esp_154;
	word32 ebp_155;
	byte SCZO_156;
	word32 edx_157;
	byte CZ_158;
	word32 eax_159;
	word32 ecx_160;
	byte SZO_161;
	bool C_162;
	bool Z_163;
	globals->ptr40A580();
}

// 0040419E: Register (ptr32 word16) fn0040419E()
word16 * fn0040419E()
{
	globals->dw40AB86 = 0x1C;
	while (globals->dw40AB86 != 0x00)
	{
		if (globals->dw40AB86 == 0x1E)
			GetClipBox((struct HDC__ *) 0x30CE, &globals->dw40AB56);
		globals->dw40AB86 = globals->dw40AB86 - 0x01;
	}
	byte * edx_63 = globals->ptr40ACE6;
	*edx_63 = *edx_63 + 99;
	globals->dw40AB8E = globals->dw40AB8E & dwLoc44;
	ui32 eax_88 = 0x01 << bLoc0C << bLoc0C << bLoc0C << bLoc0C;
	ui32 *** eax_90 = globals->ptr40A040;
	!OVERFLOW(DPB(dwLoc44, bLoc0C, 0) - 3938);
	word16 * eax_109 = ~(eax_88 - 0x01) & *(*(*eax_90));
	if (false)
	{
		int8 * ecx_169 = globals->ptr40AD3A;
		*ecx_169 = *ecx_169 >> 0x09;
	}
	globals->t40AAF6.u0 = 0x0040AB1A;
	globals->t40AAF6 = globals->t40AAF6 & 0x0040ABD2;
	word16 * dwLoc10_116 = eax_109;
	word16 ax_126 = *eax_109 - 0x022F;
	while ((ax_126 ^ 0x0330) != 23342)
	{
		globals->t40AB46 = (word32) globals->t40AB46 - 0x15D5;
		word16 * v28_150 = dwLoc10_116 - eax_88;
		dwLoc10_116 = v28_150;
		ax_126 = *v28_150 - 0x022F;
	}
	return dwLoc10_116;
}

// 00404365: void fn00404365(Register ptr32 ebp, Stack (ptr32 Eq_979) dwArg04, Stack (ptr32 Eq_979) dwArg08)
void fn00404365(ptr32 ebp, Eq_979 * dwArg04, Eq_979 * dwArg08)
{
	Eq_981 eax_10 = dwArg04[1059111];
	uint32 dwLoc58_14 = dwLoc58 & 0x00;
	while (dwLoc58_14 < 0x12)
	{
		if (dwLoc58_14 == 0x1E)
			eax_10 = PropertySheetA(dwLoc28);
		dwLoc58_14 = dwLoc58_14 + 0x01;
	}
	if (false)
	{
		union Eq_1091 * ecx_459 = globals->ptr40ACBA;
		*ecx_459 = (union Eq_1091 *) (*ecx_459 - 0x317E);
	}
	union Eq_1004 * edx_91 = globals->ptr40AD56;
	*edx_91 = (union Eq_1004 *) (*edx_91 ^ 0x1116);
	globals->a40A340[((eax_10 ^ 0x3530) + 0x252F) * 0x02] = 0x00;
	word32 * eax_102 = globals->ptr40AD16;
	*eax_102 = *eax_102 + dwLocD8;
	byte * ebx_113 = globals->ptr40AD1A;
	*ebx_113 = *ebx_113 + 118;
	globals->dw40AB4E = globals->dw40AB4E & dwLoc90;
	globals->t40AB52 = (bool) (0x3530 < globals->dw40AB2E) + ((word32) globals->t40AB52 + 0x0040AB0A);
	globals->t40AB52 = globals->t40AB52 & 4238202;
	globals->dw40AAEE = globals->dw40AAEE | (word32) bLocB4;
	globals->dw40AB3A = globals->dw40AB3A ^ dwLoc74;
	globals->dw40AB6A = globals->dw40AB6A & 0x00;
	word32 esi_228 = 0x3530;
	ptr32 esp_235 = fp - 0x01FC;
	word32 edi_227 = 0x252F;
	while (globals->dw40AB6A < 0x11)
	{
		if (globals->dw40AB6A == 0x18)
		{
			word32 * esp_264 = esp_235 - 0x04;
			*esp_264 = dwLoc1C;
			*(esp_264 - 0x04) = dwLoc18;
			*(esp_264 - 0x08) = dwLoc14;
			word32 ebp_275;
			byte SCZO_276;
			word32 eax_277;
			byte SZO_278;
			bool C_279;
			bool Z_280;
			word32 ebx_281;
			word32 ecx_282;
			word32 edx_283;
			word16 ax_286;
			word16 bx_287;
			word16 dx_288;
			word16 cx_289;
			COMCTL32.dll!ImageList_AddMasked();
		}
		globals->dw40AB6A = globals->dw40AB6A + 0x01;
	}
	if (0x00 != 0x00)
	{
		union Eq_1241 * edx_433 = globals->ptr40ACFE;
		*edx_433 = (union Eq_1241 *) ((char *) *edx_433 + 0x0036);
		union Eq_425 * edx_436 = globals->ptr40AC9A;
		*edx_436 = (union Eq_425 *) (*edx_436 - globals->t40AAF6);
		word32 * edx_442 = globals->ptr40AD66;
		*edx_442 = *edx_442 + dwLocB0;
	}
	ui32 * eax_303 = globals->ptr40AD62;
	*eax_303 = *eax_303 | 31545;
	word32 * esp_313 = esp_235 - 0x04;
	*esp_313 = (word32) dwArg08[1059110];
	*(esp_313 - 0x04) = 0x0040A340;
	*(esp_313 - 0x08) = 0x03;
	*(esp_313 - 0x0C) = fp - 0x30;
	*(esp_313 - 0x10) = *globals->ptr40A2D8->ptr000C;
	*(esp_313 - 0x14) = globals->dw40A584;
	word32 ecx_341;
	fn0040672B(dwArg00, dwArg04, dwArg08, dwArg0C, out ecx_341);
	*(esp_313 - 0x18) = 0x0040A340;
	*(esp_313 - 0x1C) = 0x01;
	*(esp_313 - 0x20) = fp - 0x54;
	if (fp <= 0x686E)
		globals->dw40ABB6 = globals->dw40ABB6 - (word32) globals->t40ABA2 - (fp < 0x686E);
	byte * eax_355 = globals->ptr40AC6A;
	*eax_355 = *eax_355 | 0x19;
	*(esp_313 - 0x24) = *globals->ptr40A2D8->ptr000C;
	*(esp_313 - 0x28) = globals->dw40A584;
	word32 ecx_368;
	ui32 eax_369 = fn0040672B(dwArg00, dwArg04, dwArg08, dwArg0C, out ecx_368);
	globals->t40ABDA.u2 = 4238238;
	globals->t40ABDA = (bool) (globals->ptr40AB4A < dwArg08) + ((word32) globals->t40ABDA + 4238182);
	if (eax_369 != ((dwArg08[1059111] ^ esi_228) + 0x4A5E) + (dwArg04[1059111] ^ esi_228))
	{
		globals->t40A4D8->t0000 = (esi_228 ^ ~0x101E) + edi_227;
		*globals->ptr40A2D8->ptr000C = (uint32) ((esi_228 ^ ~0x101E) + edi_227);
	}
}

// 004047C6: void fn004047C6()
void fn004047C6()
{
	globals->t40ABDA = globals->t40ABDA & 0x00;
	do
	{
		globals->t40ABDA = (word32) globals->t40ABDA + 0x01;
		if (globals->t40ABDA == 0x23)
			CreateHatchBrush(dwLoc2C, dwLoc14);
	} while (globals->t40ABDA < 0x1D);
	bool C_366 = (bool) cond(~0x051E);
	if (true)
	{
		globals->t40AB96 = globals->t40AB96 & 0xDF90;
		C_366 = false;
	}
	__rcr(dwLoc94, 0x01, C_366);
	byte * edi_59 = globals->ptr40ACCE;
	*edi_59 = *edi_59 | 0x53;
	if (fn00403EEE(0x252F) != 0x00)
	{
		fn00404004();
		Eq_396 ecx_132 = globals->t40A2F4;
		globals->dw40AB42 = globals->dw40AB42 - dwLoc84;
		byte eax_140[] = globals->ptr40A2F0;
		ui32 dwLoc14_156 = 4294957777;
		int32 edx_157 = 0x00;
		if (0x00 != ecx_132)
		{
			do
			{
				byte bl_268;
				int32 ecx_203;
				byte cl_187 = eax_140[edx_157 * 0x01];
				byte bLoc05_188 = cl_187;
				int32 ebx_190 = 0x01;
				if (false)
				{
					globals->dw40AB6A = globals->dw40AB6A | 4238222;
					word32 ecx_288 = (word32) cl_187;
					bl_268 = (byte) (word32) ((byte) (DPB(ecx_288, ((byte) ecx_288 ^ 0x60) + 0x32, 0) + (word32) cl_187) - eax_140[edx_157 * 0x01]);
					goto l004049D9;
				}
				dwLoc44 = dwLoc44 & 0x00;
				do
				{
					uint32 ecx_321 = dwLoc44 + 0x01;
					dwLoc44 = ecx_321;
					if (ecx_321 == 22)
						eax_140 = SetWindowRgn((struct HWND__ *) 0x3B44, (struct HRGN__ *) 0x7CDD, ecx_132);
				} while (ecx_321 < 0x10);
				ecx_203 = ~0x11CF;
				if (true)
				{
					bl_268 = __ror((byte) ((word32) cl_187 - 0x2F), 0x01);
l004049D9:
					globals->dw40AB1A = globals->dw40AB1A | 0x0040AB16;
					bLoc05_188 = bl_268;
					ecx_203 = edx_157 *s 0x01;
					ebx_190 = edx_157 *s 0x01;
				}
				byte bl_207 = eax_140[ebx_190];
				eax_140[ecx_203] = eax_140[ecx_203] ^ bl_207;
				globals->t40AB52 = (bool) (globals->t40ABD6 < DPB(ebx_190, bl_207, 0)) + ((word32) globals->t40AB52 + *globals->ptr40ACAA);
				int32 ecx_221 = edx_157 *s 0x01;
				eax_140[ecx_221] = eax_140[ecx_221] + 0x01;
				globals->t40AB6E = globals->t40AB6E | 0x0040AB0E;
				globals->t40AB6E = (word32) globals->t40AB6E + 4238182;
				globals->t40AB6E = (word32) globals->t40AB6E + 4238178;
				int32 ecx_239 = edx_157 *s 0x01;
				eax_140[ecx_239] = eax_140[ecx_239] + bLoc05_188;
				int32 ecx_245 = edx_157 *s 0x01;
				eax_140[ecx_245] = eax_140[ecx_245] - 0x01;
				ui32 edx_257 = dwLoc14_156 + 0x01 ^ 0x3530 ^ 0x3530;
				dwLoc14_156 = edx_257;
				edx_157 = edx_257 + 0x252F;
			} while (edx_257 + 0x252F != ecx_132);
		}
	}
}

// 00404AB9: Register Eq_1594 fn00404AB9(Register Eq_1594 ecx, Register Eq_1190 edi, Register out ptr32 ediOut)
Eq_1594 fn00404AB9(Eq_1594 ecx, WPARAM edi, ptr32 & ediOut)
{
	struct Eq_1597 * edx_11 = (struct Eq_1597 *) 0x05;
	word32 * esp_12 = fp - 0x08;
	while (globals->dw40A090 == 0x00)
	{
		globals->dw40ABCE = globals->dw40ABCE & 0x00;
		while (globals->dw40ABCE < 0x12)
		{
			if (globals->dw40ABCE == 0x14)
			{
				CreateHalftonePalette(dwLoc20);
				esp_12 = fp - 0x08;
			}
			globals->dw40ABCE = globals->dw40ABCE + 0x01;
		}
		edx_11[0x0040A4D7] = (struct Eq_1597) ((edx_11[0x0040A4D7] ^ 0x60) + 0x32);
		edx_11 = edx_11 + 0x01;
		if (edx_11 >= (struct Eq_1597 *) 0x14)
			break;
	}
	bool Z_191 = (bool) cond(775);
	if (true)
	{
		esp_12 = fp - 0x10;
		edi = 0x00;
		if (*globals->ptr40A2D8->ptr000C == 0x00)
			edi = fn0040419E();
		ecx.u0 = ~0x101E;
		edx_11 = (struct Eq_1597 *) 0x3530;
l00404B6F:
		ui32 ecx_155 = ecx ^ edx_11;
		struct Eq_1662 * eax_156 = ecx_155 + 0x4A5E + ecx_155;
		ui16 ax_160 = eax_156->w40A4BC ^ 0x0330;
		globals->dw40AB6A = globals->dw40AB6A + *globals->ptr40AC82;
		if (!OVERFLOW(dwLoc4C - 0x1EA6))
			Mem197[4238238:word32] = Mem165[4238238:word32] + Mem165[0x0040AB4A:word32] + (dwLoc4C <u 0x1EA6);
		else
		{
			union Eq_1091 * esi_198 = globals->ptr40ACBA;
			*esi_198 = (union Eq_1091 *) (*esi_198 | 0x7B);
		}
		globals->dw40ABA6 = globals->dw40ABA6 & dwLoc38;
		eax_156->w40A4C4 = (word16) (word32) (ax_160 + 0x022F);
		ecx = ecx_155 + 0x01 ^ edx_11;
		Z_191 = (bool) cond(ecx - ~0x101B);
	}
	if (!Z_191)
	{
		if (edi != 0x00)
		{
			union Eq_1594 * esp_92 = esp_12 - 0x04;
			*esp_92 = 0x09;
			ecx = *esp_92;
			Eq_1763 (* edx_104)[] = 0x0040A520 - ecx;
			Eq_1784 (* esi_105)[] = 0x0040A640 - ecx;
			do
			{
				byte al_109 = Mem93[edx_104 + ecx:byte];
				globals->dw40AAFA = globals->dw40AAFA | 4238226;
				globals->dw40AAFA = globals->dw40AAFA + 0x0040AB1E;
				globals->dw40AAFA = globals->dw40AAFA ^ 0x0040ABB2;
				Mem121[esi_105 + ecx:byte] = (al_109 ^ 0x60) + 0x32;
				ecx = ecx - 0x01;
			} while (ecx != 0x00);
			*globals->ptr40A2D8->ptr000C = (uint32) edi;
		}
		word32 edi_85;
		*ediOut = *esp_12;
		return ecx;
	}
	goto l00404B6F;
}

// 00404C90: Register Eq_1799 fn00404C90(Register ptr32 ebp, Register (ptr32 Eq_569) esi, Register Eq_569 edi)
LONG fn00404C90(ptr32 ebp, Eq_569 * esi, Eq_569 edi)
{
	do
	{
		*esi = 0x01;
		if (edi != 0x01)
		{
			do
			{
				Eq_569 ecx_66 = *esi;
				if (ecx_66 > edi)
					*esi = (union Eq_569 *) (ecx_66 - 0x01);
				else if (ecx_66 == 0x00)
					*esi = (union Eq_569 *) edi;
				else
				{
					globals->dw40ABBA = 0x11;
					while (globals->dw40ABBA != 0x00)
					{
						if (globals->dw40ABBA == 0x19)
							DefWindowProcA(*(ebp - 0x14), *(ebp - 0x18), *(ebp - 0x0C), 0x6CA2);
						globals->dw40ABBA = globals->dw40ABBA - 0x01;
					}
					union Eq_728 * ebx_126 = globals->ptr40ACA6;
					*ebx_126 = (union Eq_728 *) (*ebx_126 >> 0x01);
					*esi = (word32) ecx_66 + ((uint32) ((uint64) ((uint32) edi) /u 0x0101) + 0x01);
				}
			} while (*esi != edi);
		}
		Eq_593 eax_45 = InterlockedExchangeAdd(&globals->t40A2EC, 0x00760677);
	} while (eax_45 + 0x00760677 != Mem29[0x0040A2EC:word32]);
	return eax_45 + 0x00760677;
}

// 00404D4D: Register word32 fn00404D4D(Register Eq_281 ecx, Register (ptr32 word32) ebx, Stack Eq_173 dwArg00, Register out ptr32 ecxOut, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out Eq_1911 ediOut)
word32 fn00404D4D(LRESULT ecx, word32 * ebx, Eq_173 dwArg00, ptr32 & ecxOut, ptr32 & ebxOut, ptr32 & esiOut, Eq_1911 & ediOut)
{
	uint32 dwLoc1C_25 = dwLoc1C & 0x00;
	while (dwLoc1C_25 < 0x1E)
	{
		if (dwLoc1C_25 == 0x26)
			CreateWaitableTimerW(dwLoc28, 0x00, &globals->t40AEBC);
		dwLoc1C_25 = dwLoc1C_25 + 0x01;
	}
	word32 dwLoc08_110;
	globals->dw40A0EC = globals->dw40A318;
	globals->dw40A0F0 = globals->dw40A31C;
	globals->dw40A0F4 = globals->dw40A320;
	word32 ebx_99;
	word32 esi_100;
	word32 edi_101;
	if (fn00404EEB(fn00403C31(fp - 0x08, *globals->ptr40A314, globals->dw40A2FC), ebx, fp - 0x04, out ebx_99, out esi_100, out edi_101) != 0x00)
	{
		globals->dw40A098 = globals->dw40A098 + 0x00677577;
		dwLoc08_110 = 0x00;
	}
	else
	{
		if (false)
		{
			word32 * ecx_169 = globals->ptr40ACE2;
			*ecx_169 = *ecx_169 - 22241;
			word32 * eax_173 = globals->ptr40AC82;
			*eax_173 = *eax_173 - 790448901;
		}
		struct Eq_147 * eax_156 = globals->ptr40A2D8;
		globals->t40AAF2 = (word32) globals->t40AAF2 - 0x01;
		word32 eax_162 = *eax_156->ptr003C;
		globals->dw40ABDE = ~globals->dw40ABDE;
		dwLoc08_110 = eax_162;
	}
	globals->ptr40A2F8 = fp;
	word32 * ecx_123 = globals->ptr40A2F8;
	*ecxOut = ecx_123;
	Mem124[ecx_123 + 0x00:word32] = dwArg00 + Mem113[0x0040A100:word32];
	return dwLoc08_110;
}

// 00404EEB: Register ui32 fn00404EEB(Register Eq_50 edx, Register (ptr32 word32) ebx, Register Eq_1496 ebp, Register out ptr32 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
ui32 fn00404EEB(Eq_50 edx, word32 * ebx, HWND ebp, ptr32 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 * eax_8 = globals->ptr40A304;
	globals->dw40AB42 = globals->dw40AB42 & 0x00;
	do
	{
		globals->dw40AB42 = globals->dw40AB42 + 0x01;
		if (globals->dw40AB42 == 0x20)
			CreateDCW(&globals->t40AEAC, &globals->t40AE94, &globals->t40AE85, (DEVMODEW *) 0x1DDC);
	} while (globals->dw40AB42 < 0x17);
	word32 eax_173 = globals->dw40A30C;
	word32 * esp_174 = fp - 0x54;
	if (true)
	{
		struct Eq_147 * v15_168 = globals->ptr40A2D8;
		ebx = globals->ptr40A308;
		dwLoc18 = eax_173;
		eax_173 = fn004039FA(edx, v15_168, SLICE(v15_168, byte, 24), eax_8);
		esp_174 = fp - 0x5C;
	}
	word32 eax_142;
	globals->t40AB6E = globals->t40AB6E ^ 0x0040AB5E;
	globals->t40AB6E = globals->t40AB6E - 0x0040AB22;
	word32 esi_116 = 0x252F;
	if (0x00 != eax_173)
		eax_142 = ~0x101D;
	else
	{
		word32 * esp_102 = esp_174 - 0x04;
		*esp_102 = 0x00031A16;
		*(esp_102 - 0x04) = dwLoc18;
		*(esp_102 - 0x08) = ebx;
		*(esp_102 - 0x0C) = (struct Eq_147 **) globals->ptr40A2D8;
		esi_116 = fn00405435(ebp, dwArg00, dwArg04, dwArg08, dwArg0C);
		globals->dw40ABD2 = globals->dw40ABD2 - globals->ptr40AB16;
		globals->ptr40A300 = fp;
		word32 * eax_124 = globals->ptr40A300;
		*eax_124 = globals->t40A100 + *eax_124 / 0x04;
		if (dwLoc3C >= 3155)
		{
			word32 * eax_152 = globals->ptr40ACCA;
			*eax_152 = *eax_152 - dwLoc30 - (dwLoc3C < 3155);
		}
		eax_142 = ~0x101E;
	}
	struct Eq_2170 * esp_87 = esp_174 + 0x01;
	word32 edi_86;
	*ediOut = *esp_174;
	word32 esi_90;
	*esiOut = esp_87->dw0000;
	word32 ebx_92;
	*ebxOut = esp_87->dw0004;
	return (eax_142 ^ 0x3530) + esi_116;
}

// 00405060: Register word32 fn00405060(Register Eq_1594 ecx, Register ui32 ebx, Register ptr32 ebp, Register Eq_1190 edi, Register out ptr32 ecxOut)
word32 fn00405060(Eq_1594 ecx, ui32 ebx, ptr32 ebp, WPARAM edi, ptr32 & ecxOut)
{
	__align(fp - 0x04);
	ptr32 ebp_104 = fp - 0x04;
	struct Eq_2220 * esp_107 = fp - 0x44;
	word32 ecx_23;
	word32 edi_145;
	*ecxOut = fn00404AB9(ecx, edi, out edi_145);
	uint32 dwLoc08_142 = dwLoc08 & 0x00;
	do
	{
		uint32 esi_101 = dwLoc08_142 + 0x01;
		dwLoc08_142 = esi_101;
		if (esi_101 == 0x26)
		{
			DestroyCursor((struct HICON__ *) 20602);
			esp_107 = fp - 0x44;
		}
	} while (esi_101 < 0x1F);
	word32 ecx_155;
	Eq_2249 dwLoc14_138 = (DWORD *) 0x0180;
	if (false)
	{
l0040534E:
		*ecxOut = ebx + 0x01 ^ esi_101;
		goto l00405353;
	}
	globals->t40ABE2 = (word32) globals->t40ABE2 | *globals->ptr40AD06;
	esi_101 = 0x3530;
	edi_145 = 0x252F;
l00405102:
	if (globals->dw40A090 != 0x00)
		goto l0040540C;
	struct Eq_147 * eax_477 = globals->ptr40A2D8;
	WPARAM * ecx_479 = eax_477->ptr000C;
	*ecxOut = ecx_479;
	if (*ecx_479 != 0x00)
	{
		word32 * esp_491 = esp_107 - 0x04;
		*esp_491 = 0x0040A524;
		*(esp_491 - 0x04) = 0x01;
		*(esp_491 - 0x08) = &eax_477->dw0040 + 0x04;
		*(esp_491 - 0x0C) = *ecx_479;
		*(esp_491 - 0x10) = globals->dw40A584;
		word32 ecx_505;
		globals->dw40A4EC = fn0040672B(dwArg00, dwArg04, dwArg08, dwArg0C, out ecx_505);
	}
	if (globals->dw40A4EC == 0x00)
	{
l004053B2:
		globals->t40ABD6.u0 = 0x1F;
		while (globals->t40ABD6 != 0x00)
		{
			if (globals->t40ABD6 == 0x2B)
			{
				LPDWORD * esp_124 = esp_107 - 0x04;
				*esp_124 = (LPDWORD *) dwLoc14_138;
				*(esp_124 - 0x04) = 0x0040ABAA;
				GetComputerNameW(*(esp_124 - 0x04), *esp_124);
			}
			globals->t40ABD6 = globals->t40ABD6 - 0x01;
		}
		ui32 eax_133 = (esp_107[0x03] ^ esi_101) + 0x01 ^ esi_101;
		esp_107[0x03] = (struct Eq_2220) eax_133;
		if (eax_133 == ~0x11EE)
		{
l0040540C:
			ui32 * esi_72 = globals->ptr40ACA2;
			*esi_72 = *esi_72 - 20124;
			return 0x01;
		}
		goto l00405102;
	}
	esp_107[0x05] = (struct Eq_2220) 0x00;
	*ecxOut = ~0x101E;
l00405353:
	Eq_2352 C_180;
	if (!P)
	{
		C_180.u0 = false;
		dwLoc0C = (word32) bLoc0C & (word32) globals->w40ABC6;
	}
	else
	{
		uint32 eax_450 = dwLoc08_142 - globals->dw40AB9A - (dwLoc0C < 0x4FCF);
		C_180 = (bool) cond(eax_450);
		dwLoc08_142 = eax_450;
	}
	int32 eax_185 = (bool) C_180.u0 + (dwLoc10 + (word32) globals->t40AB6E);
	word32 eax_188 = *esp_107[0x08];
	struct Eq_2375 * esp_189 = esp_107 - 0x04;
	esp_189->ptr0000 = (char *) 0x61;
	dwLoc10 = eax_185;
	esp_107 = (struct Eq_2220 *) ((char *) &esp_189->ptr0000 + 0x04);
	if ((uint32) ((uint64) (uint32) eax_188 % esp_189->ptr0000) > 0x8A || ecx_155 == ~0x102E)
		goto l004053B2;
	int32 ecx_207 = (esp_189->dw0020 ^ esi_101) + edi_145;
	globals->dw40ABA6 = globals->dw40ABA6 & 0x0040ABD2;
	globals->dw40ABA6 = globals->dw40ABA6 - 0x0040AB6E;
	esp_189->ptr0000 = &globals->b40A52C;
	*(esp_189 - 0x04) = 4236604;
	ebx = ecx_155 ^ esi_101;
	esp_189->ptr0014 = (uint32) ((uint64) (uint32) (ebx + 0x252F) % ecx_207) << 0x03;
	struct Eq_2220 * esp_222 = esp_189 - 0x04;
	int32 eax_226 = _stricmp(*(esp_189 - 0x04), esp_189->ptr0000);
	dwLoc14_138 = (DWORD *) 0x0765;
	if (false)
	{
		if (eax_226 != 0x00)
		{
			esp_189->ptr0000 = esp_189->ptr0014->ptr40A498;
			*(esp_189 - 0x04) = 0x0040A4C4;
			*(esp_189 - 0x08) = 0x0040A340;
			*(esp_189 - 0x0C) = 0x03;
			*(esp_189 - 0x10) = 0x0040A4F0;
			*(esp_189 - 0x14) = globals->dw40A4EC;
			*(esp_189 - 0x18) = globals->dw40A584;
			word32 ecx_433;
			fn0040672B(dwArg00, dwArg04, dwArg08, dwArg0C, out ecx_433);
		}
		esp_107[0x06] = (struct Eq_2220) ~0x24DE;
		esp_222 = esp_107;
		eax_226 = ~0x11EE;
l0040521B:
		if (eax_226 == ~0x11C9)
		{
			globals->dw40AB82 = globals->dw40AB82 & 0x00;
			while (globals->dw40AB82 < 0x1B)
			{
				if (globals->dw40AB82 == 0x1D)
				{
					int32 * esp_344 = esp_222 - 0x04;
					*esp_344 = eax_185;
					*(esp_344 - 0x04) = 0x3015;
					RestoreDC(*(esp_344 - 0x04), *esp_344);
				}
				globals->dw40AB82 = globals->dw40AB82 + 0x01;
			}
			WPARAM * eax_351 = globals->ptr40A2D8->ptr000C;
			struct Eq_2647 * esp_352 = esp_222 - 0x04;
			esp_352->dw0000 = 0x0040A638;
			*(esp_352 - 0x04) = *eax_351;
			globals->dw40AB2A = globals->dw40AB2A - *globals->ptr40AC9E;
			<anonymous> * eax_362 = esp_352->ptr0018;
			byte SCZO_365;
			word32 eax_368;
			byte SZO_370;
			bool C_371;
			bool Z_372;
			byte CZ_373;
			word32 ecx_374;
			word32 edx_376;
			eax_362();
			globals->dw40A514 = eax_368;
		}
		else if (eax_226 == ~0x11DE)
		{
			word32 eax_381 = *globals->ptr40A11C;
			struct Eq_2729 * esp_382 = esp_222 - 0x04;
			esp_382->dw0000 = 0x0040A4DC;
			*(esp_382 - 0x04) = eax_381;
			*(esp_382 - 0x08) = 0x02;
			*(esp_382 - 0x0C) = 0x0040A1A4;
			*(esp_382 - 0x10) = eax_381;
			*(esp_382 - 0x14) = globals->dw40A584;
			word32 ecx_397;
			esp_382->dw0018 = fn0040672B(dwArg00, dwArg04, dwArg08, dwArg0C, out ecx_397);
			esp_222 = (struct Eq_2220 *) (&esp_382->dw0000 + 0x01);
		}
		eax_226 = esp_222[0x06] - 0x01 ^ esi_101;
		dwLoc0C = (word32) ((word32) globals->t40AB96 + bLoc0C);
		ecx_207 = eax_226;
	}
	ui32 ecx_245 = ecx_207 ^ esi_101;
	esp_222[0x06] = (struct Eq_2220) ecx_245;
	if (ecx_245 + edi_145 == 0x00)
	{
		word32 ecx_250 = esp_222[0x07];
		dwLoc10 = 0x6EF9;
		if (false)
		{
			dwLoc08_142 = dwLoc08_142 >> 0x01;
			dwLoc10 = 26516;
		}
		esp_222[0x06] = (struct Eq_2220) ((uint32) ((uint64) (uint32) ((esp_222[0x03] ^ esi_101) + edi_145) % ((ecx_250 ^ esi_101) + edi_145)) << 0x03);
		struct Eq_2616 * esp_270 = esp_222 - 0x04;
		esp_270->dw0000 = (word32) esp_222[0x06];
		*(esp_270 - 0x04) = esp_270->dw0014;
		fn00404365(ebp_104, dwArg00, dwArg04);
		esp_107 = (struct Eq_2220 *) (&esp_270->dw0000 + 0x01);
		goto l0040534E;
	}
	goto l0040521B;
}

// 00405435: Register word32 fn00405435(Stack Eq_1496 dwArg00, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr32 code) dwArg0C, Stack word32 dwArg10)
word32 fn00405435(HWND dwArg00, word32 dwArg04, word32 dwArg08, code * dwArg0C, word32 dwArg10)
{
	word32 * esp_108;
	if (dwArg10 != 549991)
	{
		word32 dwLoc10_112;
		if (dwArg10 == 0x00031A16)
			dwLoc10_112 = 394293;
		else
		{
			uint32 dwLoc40_122 = dwLoc40 & 0x00;
			while (dwLoc40_122 < 0x10)
			{
				if (dwLoc40_122 == 0x13)
				{
					SetScrollRange(dwLoc28, 15244, dwLoc24, dwLoc18, 0x00);
					dwLoc18 = dwLoc24;
					dwLoc20 = dwLoc28;
				}
				dwLoc40_122 = dwLoc40_122 + 0x01;
			}
			if (0x00 != *(globals->ptr40A2D8)->ptr000C && 0x00 == globals->dw40A090)
				fn004047C6();
			dwLoc10_112 = 549991;
		}
		fn00405435(dwLoc20, dwArg04, dwArg08, dwArg0C, dwLoc10_112);
		esp_108 = fp - 0x0C;
	}
	else
	{
		word32 ebp_226;
		word32 ecx_227;
		word32 esi_228;
		byte SCZO_229;
		bool Z_230;
		byte SZO_231;
		bool C_232;
		word32 eax_233;
		byte CZ_234;
		dwArg0C();
	}
	globals->t40ABD6 = globals->t40ABD6 - 0x39AA;
	union Eq_232 * ecx_46 = globals->ptr40ACDA;
	*ecx_46 = (union Eq_232 *) (*ecx_46 - 13668 - (globals->t40A100 < dwLoc8C));
	return *esp_108;
}

// 0040564B: Register Eq_396 fn0040564B(Register Eq_396 eax, Register up32 ebx, Register uint32 edi, Register out ptr32 ecxOut)
Eq_396 fn0040564B(Eq_396 eax, up32 ebx, uint32 edi, ptr32 & ecxOut)
{
	DWORD * dwLoc28_119 = fp - 0x10;
	uint32 dwLoc30_11 = dwLoc30 & 0x00;
	while (dwLoc30_11 < 0x1F)
	{
		if (dwLoc30_11 == 0x27)
			eax = LockFile(dwLoc20, dwLoc10, 22414, dwLoc20, 0x8757);
		dwLoc30_11 = dwLoc30_11 + 0x01;
	}
	if (true)
	{
		Eq_569 edx_215 = *eax;
		dwLoc10 = edx_215;
		word32 ecx_217;
		*ecxOut = edx_215;
		if (edx_215 == 0x00)
			return 0x00;
		Mem240[Mem0[eax + 0x04:word32] + 0x00:word32] = edx_215 + Mem0[edx_215 + 0x3C:word32];
		byte * edx_252 = globals->ptr40AC7E;
		struct Eq_2944 * ecx_244 = **((word32) eax + 0x04);
		*edx_252 = (bool) (ebx < dwLoc7C) + (*edx_252 + 0x47);
		word32 ecx_258 = ecx_244->dw0078;
		Eq_2966 edx_255 = *((word32) eax + 0x0018);
		word32 ecx_260;
		*ecxOut = ecx_258;
		if (ecx_258 == 0x00)
			return 0x00;
		up32 ecx_329;
		**((word32) eax + 0x0C) = (word32) edx_215 + ecx_258;
		Eq_3014 ecx_268 = *((word32) eax + 0x0C);
		globals->dw40AB1A = (char *) *globals->ptr40ACFE + globals->dw40AB1A;
		struct Eq_2899 * ecx_274 = *ecx_268.dw0000;
		up32 ecx_290 = ecx_274->dw0018;
		globals->t40AB8A = (word32) globals->t40AB8A + dwLocC4;
		globals->dw40AB9E = globals->dw40AB9E - 11752 - (edi < dwLoc30_11);
		dwLoc1C = ecx_274;
		up32 ecx_310 = ecx_274->dw0014;
		dwLoc28_119 = fp - 0x18;
		if (ecx_310 > ecx_290)
			ecx_329 = ecx_310;
		else
			ecx_329 = ecx_290;
		globals->t40AB52 = globals->t40AB52 & 0x0040AB0E;
		Eq_1047 v31_335 = (word32) globals->t40AB52 + 4238178;
		globals->t40AB52 = v31_335;
		globals->t40AB52 = (bool) (v31_335 < 0x00) + ((word32) globals->t40AB52 + 4238098);
		*edx_255.dw0000 = (Eq_2966) ecx_329;
		uint32 dwLoc44_343 = dwLoc44 & 0x00;
		do
		{
			uint32 edx_352 = dwLoc44_343 + 0x01;
			dwLoc44_343 = edx_352;
			if (edx_352 == 0x2B)
				eax = SetLocalTime((SYSTEMTIME *) 23636);
		} while (edx_352 < 0x1D);
		if (false)
			globals->t40ABE6 = globals->t40ABE6 - dwLoc88;
		word32 * ecx_383 = globals->ptr40AD1E;
		word32 ecx_379 = ecx_274->dw0024;
		*ecx_383 = *ecx_383 - 0x1909;
		**((word32) eax + 0x0014) = (word32) edx_215 + ecx_379;
		uint8 * edx_390 = globals->ptr40AC92;
		*edx_390 = *edx_390 >> 0x01;
	}
	Mem159[Mem0[eax + 0x08:word32] + 0x00:word32] = dwLoc10 + Mem0[dwLoc1C + 0x1C:word32];
	**((word32) eax + 0x0010) = (word32) dwLoc10 + *dwLoc28_119;
	globals->dw40AAFA = globals->dw40AAFA & 0x6DF3;
	**((word32) eax + 0x001C) = ~0x101A;
	**((word32) eax + 0x0020) = ~0x101A;
	**((word32) eax + 0x0024) = ~0x101C;
	word32 ecx_184;
	*ecxOut = ~0x101A;
	return 0x01;
}

// 004059B2: Register Eq_569 Win32CrtStartup()
Eq_569 Win32CrtStartup()
{
	Eq_569 eax_258;
	ptr32 esp_12;
	ptr32 ebp_13;
	byte SCZO_14;
	int32 eax_15;
	byte SZO_16;
	bool C_17;
	word32 esi_18;
	word32 edi_19;
	bool Z_20;
	word16 ax_21;
	word32 ecx_22;
	word32 edx_23;
	byte CZ_24;
	word16 cx_25;
	word16 dx_26;
	word16 di_27;
	word16 si_28;
	word32 ebx_29;
	byte SO_30;
	SHLWAPI.dll!StrSpnA();
	if (eax_15 <= 0x0A)
	{
		*(esp_12 - 0x04) = esi_18;
		*(esp_12 - 0x08) = edi_19;
		word32 dwLoc0220_153 = 0x11;
		while (dwLoc0220_153 != 0x00)
		{
			if (dwLoc0220_153 == 0x18)
			{
				*(esp_12 - 0x0C) = 0x3899;
				*(esp_12 - 0x10) = 0x8BFF;
				*(esp_12 - 0x14) = dwLoc14;
				*(esp_12 - 0x18) = 7721;
				*(esp_12 - 0x1C) = dwLoc24;
				DialogBoxIndirectParamA(*(esp_12 - 0x1C), *(esp_12 - 0x18), *(esp_12 - 0x14), *(esp_12 - 0x10), *(esp_12 - 0x0C));
			}
			dwLoc0220_153 = dwLoc0220_153 - 0x01;
		}
		word32 * eax_187 = fn00404C90(ebp_13, fp - 0x14, ~0x101E);
		if (true)
		{
			*(esp_12 - 0x0C) = 0x46;
			*(esp_12 - 0x0C) = 0x3A;
			*(esp_12 - 0x0C) = 0x5C;
			*(esp_12 - 0x0C) = 0x4A;
			ui32 * ecx_283 = globals->ptr40ACAA;
			*ecx_283 = *ecx_283 | dwLoc025C;
			globals->t40ABAE = (word32) globals->t40ABAE - dwLoc03D4;
			*(esp_12 - 0x0C) = 0x48;
			*(esp_12 - 0x0C) = 0x44;
			ui32 * edx_321 = globals->ptr40AC6E;
			*edx_321 = *edx_321 & (word32) globals->b40ABCA;
			*(esp_12 - 0x0C) = 0x4B;
			globals->dw40AAEE = globals->dw40AAEE & 0x0040AAFA;
			globals->dw40ABBE = globals->dw40ABBE & dwLoc0294;
			*(esp_12 - 0x0C) = 0x44;
			byte * edi_374 = globals->ptr40ACAE;
			*edi_374 = *edi_374 + 0x2D;
			*(esp_12 - 0x0C) = 0x2E;
			*(esp_12 - 0x0C) = 0x44;
			*(esp_12 - 0x0C) = 0x4C;
			globals->dw40AB4E = globals->dw40AB4E & 0x00;
			while (globals->dw40AB4E < 22)
			{
				if (globals->dw40AB4E == 0x1D)
				{
					*(esp_12 - 0x10) = dwLoc20;
					*(esp_12 - 0x14) = 0x0040AB66;
					*(esp_12 - 0x18) = dwLoc18;
					*(esp_12 - 0x1C) = 0x0040AB82;
					*(esp_12 - 0x20) = dwLoc24;
					*(esp_12 - 0x24) = dwLoc28;
					*(esp_12 - 0x28) = dwLoc10;
					TransactNamedPipe(*(esp_12 - 0x28), *(esp_12 - 0x24), *(esp_12 - 0x20), *(esp_12 - 0x1C), *(esp_12 - 0x18), *(esp_12 - 0x14), *(esp_12 - 0x10));
				}
				globals->dw40AB4E = globals->dw40AB4E + 0x01;
			}
			*(esp_12 - 0x0C) = 464;
			*(esp_12 - 0x10) = 0x00;
			if (true)
				globals->ptr40AB02 = globals->ptr40AB02 - *globals->ptr40AC9E - (dwLoc0358 + dwLoc0364 < 0x00);
			*(esp_12 - 0x14) = fp - 484;
			memset(*(esp_12 - 0x14), *(esp_12 - 0x10), *(esp_12 - 0x0C));
			*(esp_12 - 0x0C) = fp - 0x021C;
			struct Eq_3522 * esp_483;
			ptr32 ebp_484;
			byte SCZO_485;
			word32 eax_486;
			byte SZO_487;
			bool C_488;
			word32 esi_489;
			word32 edi_490;
			bool Z_491;
			word16 ax_492;
			word32 ecx_493;
			word32 edx_494;
			byte CZ_495;
			word16 cx_496;
			word16 dx_497;
			word16 di_498;
			word16 si_499;
			ui32 ebx_500;
			byte SO_501;
			SHLWAPI.dll!PathMakePrettyW();
			if ((fp - 0x021C & fp - 0x021C) != 0x00)
			{
				fn00403E27(ebp_484, fp - (struct Eq_3593 *) 0x0C, fp - (struct Eq_3595 *) 0x10);
				Eq_569 edi_632 = fp - (struct Eq_3595 *) 0x10 ^ fp - (struct Eq_3595 *) 0x10;
				fn00403E27(ebp_484, &globals->t40A548, edi_632);
				fn00404C90(ebp_484, &globals->t40A54C, edi_632);
				fn00403E27(ebp_484, &globals->t40A550, edi_632);
				fn00403E27(ebp_484, &globals->ptr40A554, edi_632);
			}
			fn00403E27(ebp_484, fp - 0x08, 0x06586468);
			fn00403E03(fp - (union Eq_569 *) 0x04);
			byte * esi_518 = globals->ptr40AD5A;
			Eq_569 edi_515 = globals->t40A548;
			*esi_518 = *esi_518 - 122;
			fn00403E27(ebp_484, &globals->dw40A4CC, edi_515);
			if (false)
				globals->dw40AB5E = globals->dw40AB5E + globals->dw40AB5A;
			fn00404C90(ebp_484, &globals->dw40A4D0, globals->t40A54C);
			fn00403E27(ebp_484, &globals->dw40A4D4, globals->t40A550);
			Eq_1594 ecx_538 = fn00403E27(ebp_484, &globals->t40A4D8, dwLoc0C);
			Eq_569 eax_540 = GetCurrentProcessId();
			Eq_1190 edi_541 = esp_483->t0000;
			globals->dw40ABBE = globals->dw40ABBE - 4238294 - (ecx_538 < dwLoc0348);
			if (eax_540 != 0x00)
				fn00405F2F(ecx_538, ebx_500, edi_541);
			else if (GetCurrentThreadId() != 0x00)
			{
				esp_483->t0004.u0 = 0x00;
				ExitProcess(esp_483->t0004);
			}
			*dwLoc0C = globals->t40A4D8->t0000;
			Eq_281 eax_561 = globals->dw40A104 ^ globals->t40A100;
			uint32 dwLoc0264_564 = dwLoc0264 & 0x00;
			do
			{
				uint32 ecx_573 = dwLoc0264_564 + 0x01;
				dwLoc0264_564 = ecx_573;
				if (ecx_573 == 0x1E)
				{
					esp_483->t0004.u0 = 34445;
					esp_483->t0000 = dwLoc2C;
					*(esp_483 - 0x04) = 33818;
					*(esp_483 - 0x08) = 0x31CE;
					*(esp_483 - 0x0C) = dwLoc20;
					eax_561 = SendDlgItemMessageA(*(esp_483 - 0x0C), *(esp_483 - 0x08), *(esp_483 - 0x04), esp_483->t0000, esp_483->t0004);
				}
			} while (ecx_573 < 0x13);
			globals->t40A100 = eax_561;
			eax_187 = globals->ptr40A554;
		}
		*eax_187 = globals->t40A100 + *eax_187 / 0x04;
		eax_258 = *dwLoc0C;
		return eax_258;
	}
	else
	{
		eax_258.u0 = 0x00;
		return eax_258;
	}
}

// 00405F2F: void fn00405F2F(Register Eq_1594 ecx, Register ui32 ebx, Register Eq_1190 edi)
void fn00405F2F(Eq_1594 ecx, ui32 ebx, WPARAM edi)
{
	globals->t40ABA2 = globals->t40ABA2 & globals->dw40ABEA;
	globals->ptr40A4B8 = null;
	Eq_281 ecx_101;
	if (fn00405060(ecx, ebx, fp - 0x04, edi, out ecx_101) != 0x00)
	{
		ui32 edi_103 = ~0x1119;
		word32 * ebx_105 = fp;
		word32 esi_104 = 0x3530;
		do
		{
			word32 * eax_111;
			globals->dw40A318 = globals->dw40A4CC;
			globals->dw40A31C = globals->dw40A4D0;
			word32 eax_94 = globals->dw40A4D4;
			globals->ptr40AB02 = 4238222;
			globals->dw40A320 = eax_94;
			if (edi_103 == ~0x101C)
			{
				dwLoc18 = dwLoc18 & 0x00;
				while (dwLoc18 < 0x17)
				{
					if (dwLoc18 == 0x25)
					{
						SendMessageA(dwLoc24, 33790, 12190, ~0x101D);
						dwLoc50.u0 = ~0x101D;
					}
					dwLoc18 = dwLoc18 + 0x01;
				}
				eax_111 = globals->ptr40A4B8;
				if (false)
					goto l0040608B;
				ecx_101 = globals->t40A100;
				*eax_111 = ecx_101 + *eax_111 / 0x04;
			}
			else if (edi_103 == ~0x11DE)
			{
				globals->ptr40A314 = fp - 0x0C;
				up32 ecx_199;
				Eq_569 eax_203 = fn00404D4D(ecx_101, ebx_105, dwLoc50, out ecx_199, out ebx_105, out esi_104, out edi_103);
				ecx_101 = globals->t40A4D8;
				ecx_101->t0000 = eax_203;
				dwLoc18 = (word32) bLoc18 - dwLoc1C - (dwLoc1C < ecx_199);
			}
			globals->ptr40A4B8 = ebx_105;
			eax_111 = (word32 *) ~0x101D;
			edi_103 = edi_103 ^ esi_104;
l0040608B:
			edi_103 = edi_103 - (eax_111 ^ esi_104) - 0x252F ^ esi_104;
		} while (edi_103 != ~0x101D);
	}
}

// 0040672B: Register word32 fn0040672B(Stack (ptr32 Eq_979) dwArg04, Stack (ptr32 Eq_979) dwArg08, Stack (ptr32 Eq_979) dwArg0C, Stack int32 dwArg10, Register out ptr32 ecxOut)
word32 fn0040672B(Eq_979 * dwArg04, Eq_979 * dwArg08, Eq_979 * dwArg0C, int32 dwArg10, ptr32 & ecxOut)
{
	*ecxOut = ecx;
	globals->ptr40ABB2 = 0x0040AB76;
	up32 ebx_14 = ~0x101E;
	ptr32 esp_15 = fp - 0x022C;
	word32 dwLoc60_18 = ~0x101D;
	word32 dwLoc4C_20 = ~0x101E;
	ui32 dwLoc10_21 = ~0x101E;
	uint32 edi_23 = 0x252F;
l0040675D:
	word32 eax_150;
	if (dwLoc4C_20 == ~0x101E)
	{
		dwLoc8C = dwLoc8C & 0x00;
		while (dwLoc8C < 0x14)
		{
			if (dwLoc8C == 0x1F)
			{
				HMENU * esp_771 = esp_15 - 0x04;
				*esp_771 = (HMENU *) dwLoc24;
				IsMenu(*esp_771);
			}
			dwLoc8C = dwLoc8C + 0x01;
		}
		word32 ecx_796;
		if (fn0040564B(fp - 0x88, ebx_14, edi_23, out ecx_796) == 0x00)
			goto l00406C97;
	}
	if (dwLoc1C != ~0x101E && (dwLoc14->dw0018 == 0x00 || dwLoc14->dw0014 == 0x00))
	{
		dwLoc60_18 = ~0x101E;
		goto l00406ACF;
	}
	if (dwLoc18 != ~0x101E && (dwLoc10_21 != (dwLoc30 + 4294957777 ^ 0x3530) && dwLoc60_18 == ~0x101D))
	{
		Eq_4012 ecx_313 = dwLoc10_21 ^ 0x3530;
		word32 ecx_314;
		*ecxOut = (word32) ecx_313 + 0x0000252F;
		if (ecx_313 > 0x2529)
			dwLoc4C_20 = ~0x101D;
		if ((word32) ecx_313 + 0x0000252F < dwLoc14->dw0018)
		{
			word32 dwLocA8_326 = 0x19;
			while (dwLocA8_326 != 0x00)
			{
				if (dwLocA8_326 == 0x20)
				{
					*(esp_15 - 0x04) = (HMENU *) dwLoc24;
					*(esp_15 - 0x08) = 36602;
					*(esp_15 - 0x0C) = 0x0040AB3A;
					*(esp_15 - 0x10) = dwLoc10_21;
					*(esp_15 - 0x14) = dwLoc1C;
					*(esp_15 - 0x18) = 33267;
					*(esp_15 - 0x1C) = 34436;
					FormatMessageA(*(esp_15 - 0x1C), *(esp_15 - 0x18), *(esp_15 - 0x14), *(esp_15 - 0x10), *(esp_15 - 0x0C), *(esp_15 - 0x08), *(esp_15 - 0x04));
				}
				dwLocA8_326 = dwLocA8_326 - 0x01;
			}
			Eq_4035 eax_362 = ((word32) ecx_313 + 0x0000252F) * 0x02;
			<anonymous> * eax_393 = ((word32) *((word32) eax_362 + dwLoc28) - 0x252F ^ 0x3530 ^ 0x3530) + 0x252F;
			if (eax_393 <= dwLoc14->dw0014 - 0x01)
			{
				if (true)
				{
					ui32 eax_605 = (word32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(((dwLoc48 ^ 0x3530) + 0x252F) *s ((word32) ecx_313 + 0x0000252F))[dwLoc28].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
					globals->dw40ABEA = globals->dw40ABEA + dwLocD0;
					globals->dw40ABD2 = 0x18;
					ui32 v29_598 = dwLoc20 & 0x00;
					dwLoc20 = v29_598;
					Eq_4168 eax_617 = ((dwLoc1C ^ 0x3530) + 0x252F) *s ((word32) ecx_313 + 0x0000252F);
					word32 * eax_625 = fp - 0x3C;
					while (globals->dw40ABD2 != 0x00)
					{
						if (globals->dw40ABD2 == 0x1A)
						{
							*(esp_15 - 0x04) = 0x490B;
							*(esp_15 - 0x08) = dwLoc28;
							*(esp_15 - 0x0C) = dwLoc2C;
							*(esp_15 - 0x10) = dwLoc10_21;
							*(esp_15 - 0x14) = dwLoc28;
							*(esp_15 - 0x18) = dwLoc18;
							*(esp_15 - 0x1C) = 0x5043;
							eax_625 = SetDIBits(*(esp_15 - 0x1C), *(esp_15 - 0x18), *(esp_15 - 0x14), *(esp_15 - 0x10), *(esp_15 - 0x0C), *(esp_15 - 0x08), *(esp_15 - 0x04));
						}
						globals->dw40ABD2 = globals->dw40ABD2 - 0x01;
					}
					globals->dw40AB86 = globals->dw40AB86 ^ 0x0040AB5A;
					*eax_625 = (word32) *((word32) eax_617 + dwLoc34);
					*(esp_15 - 0x04) = fp - 0x20;
					*(esp_15 - 0x08) = dwArg08 + dwLoc3C / 0x04;
					*(esp_15 - 0x0C) = (struct Eq_979 **) dwArg0C;
					word32 ebp_695;
					byte SCZO_696;
					word32 esi_698;
					word32 eax_700;
					bool Z_701;
					byte SZO_702;
					bool C_703;
					word32 ecx_704;
					byte CZ_705;
					word32 edx_706;
					byte SO_707;
					word16 ax_708;
					dwArg04();
					if (v29_598 != 0x01)
					{
l00406ACF:
						dwLoc10_21 = (dwLoc10_21 ^ 0x3530) + 0x01 ^ 0x3530;
						goto l0040675D;
					}
					eax_393 = (<anonymous> *) (dwArg08 + dwLoc2C[eax_605] / 0x04);
				}
				if (dwArg10 != 0x00)
				{
					word32 * eax_462 = globals->ptr40AD12;
					*eax_462 = (word32) ((bool) (dwLocC4 < 0x00) + (*eax_462 + 0x350F));
					globals->dw40AAFA = (ui32) ((bool) (dwLocC4 < 0x00) + (globals->dw40AAFA + (word32) wLoc0170));
					int32 eax_471 = (dwLoc18 ^ 0x3530) + 0x252F;
					if (!P)
					{
						union Eq_1004 * edx_562 = globals->ptr40AD56;
						*edx_562 = (union Eq_1004 *) (*edx_562 | 0x81);
					}
					else
						globals->t40AB6E = globals->t40AB6E | dwLoc0130;
					globals->dw40AB6A = globals->dw40AB6A + globals->dw40AB9A;
					ptr32 eax_497 = esp_15;
					int32 ecx_509 = eax_471 *s dwArg10;
					do
					{
						eax_497 = eax_497 - 0x01;
						ecx_509 = ecx_509 - 0x01;
					} while (ecx_509 != 0x00);
					int32 dwLoc10_530 = 0x00;
					struct Eq_979 * eax_531 = fp + 0x10;
					do
					{
						union Eq_4389 * ebx_540 = globals->ptr40AD42;
						Mem542[ebx_540 + 0x00:byte] = Mem493[ebx_540 + 0x00:byte] + 111 + (eax_531 <u Mem493[0x0040AB4A:word32]);
						eax_531 = eax_531 + 0x01;
						((dwLoc18 ^ 0x3530) + 0x252F) *s dwLoc10_530 + eax_497 = (word32 *) eax_531->t0000;
						int32 v47_555 = dwLoc10_530 + 0x01;
						dwLoc10_530 = v47_555;
					} while (v47_555 != dwArg10);
				}
				word32 esp_437;
				word32 ebp_438;
				byte SCZO_439;
				word32 ebx_440;
				word32 esi_441;
				word32 edi_442;
				word32 eax_443;
				bool Z_444;
				byte SZO_445;
				bool C_446;
				word32 ecx_447;
				byte CZ_448;
				word32 edx_449;
				byte SO_450;
				word16 ax_451;
				bool P_452;
				eax_393();
				eax_150 = eax_443;
				return eax_150;
			}
		}
	}
l00406C97:
	globals->dw40AB86 = globals->dw40AB86 & 0x00;
	while (globals->dw40AB86 < 0x19)
	{
		if (globals->dw40AB86 == 0x1F)
		{
			LPCWSTR * esp_212 = esp_15 - 0x04;
			*esp_212 = (LPCWSTR *) &globals->t40AEE4;
			*(esp_212 - 0x04) = dwLoc10_21;
			*(esp_212 - 0x08) = 0x8CE8;
			CreateWaitableTimerW(*(esp_212 - 0x08), *(esp_212 - 0x04), *esp_212);
		}
		globals->dw40AB86 = globals->dw40AB86 + 0x01;
	}
	eax_150 = 0x00;
	return eax_150;
}

// 00406D5A: Register (ptr32 void) __he_qt(Stack uint32 dwArg04)
void(uint32 dwArg04)
{
	globals->dw40AB36 = (word32) ((bool) (ecx < globals->dw40AB0E) + (globals->dw40AB36 + globals->dw40AB1E));
	globals->t40ABD6 = globals->t40ABD6 - *globals->ptr40AD22;
	globals->t40ABC2 = (word32) globals->t40ABC2 - *globals->ptr40AD4E;
	return eax;
}

// 00406DAD: void RF_Egdnkvdiiuncf(Stack uint32 dwArg04, Stack (ptr32 int16) ptrArg08)
void RF_Egdnkvdiiuncf(uint32 dwArg04, int16 * ptrArg08)
{
	globals->t40ABC2 = globals->t40ABC2 - globals->dw40AAFA;
	globals->dw40AB86 = globals->dw40AB86 + (word32) globals->t40AAF6;
	Mem30[4238226:word32] = Mem21[4238226:word32] + Mem21[Mem21[0x0040AD42:word32] + 0x00:word32] + (dwLoc08 <u edi);
}

// 00406DF7: Register (ptr32 cu8) kJAZuY_hvjqel_v_wuvzz(Stack uint32 dwArg04, Stack uint16 wArg08)
cu8 * kJAZuY_hvjqel_v_wuvzz(uint32 dwArg04, uint16 wArg08)
{
	ui32 * ebx_14 = globals->ptr40ACEA;
	*ebx_14 = *ebx_14 | globals->t40AB46;
	Eq_3130 edx_21 = (word32) globals->t40ABC2 | globals->ptr40AB16;
	globals->t40ABC2 = edx_21;
	globals->dw40AB5E = globals->dw40AB5E - *globals->ptr40AC9A - (globals->t40ABE6 < edx_21);
	return eax;
}

// 00406E3E: Register uint32 xcfq_xwotK(Stack (ptr32 uint32) ptrArg04)
uint32 xcfq_xwotK(uint32 * ptrArg04)
{
	Eq_3036 ecx_13 = (word32) globals->t40AB8A - *globals->ptr40ACF2;
	globals->t40AB8A = ecx_13;
	globals->t40ABE2 = (bool) (dwLoc08 < ecx_13) + ((word32) globals->t40AB6E + (word32) globals->t40ABE2);
	globals->t40AB12 = globals->t40AB12 & *globals->ptr40ACA2;
	return eax;
}

