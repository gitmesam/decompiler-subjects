// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	word32 edi_385 = AddAce(null, 0x00, 0x00, null, 0x00) + 0x25 + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00) + AddAce(0x00, 0x00, 0x00, 0x00, 0x00);
	Eq_2 esi_12 = AddAce;
	Eq_3 ebp_16 = null;
	Eq_2 dwLoc1C_382 = ~0x00;
	if (AreAnyAccessesGranted(~0x00, (struct Eq_546 *) ~0x00) == 0x00)
		edi_385 = edi_385 - 0x22;
	struct Eq_249 * eax_394 = null;
	do
	{
		if (ebp_16 == edi_385)
			ebp_16 = null;
		eax_394[0x00401290] = (struct Eq_249) (eax_394[0x00401290] ^ ebp_16[0x00404000]);
		esi_12 = esi_12 + edi_385;
		eax_394 = eax_394 + 0x01;
		ebp_16 = (Eq_3) (ebp_16 + 0x01);
	} while (eax_394 < (struct Eq_249 *) 5152);
	struct Eq_272 * edx_425 = &globals->t402570;
	union Eq_274 * edi_429 = (union Eq_274 *) 0xF0401010;
	up32 dwLoc08_430 = 0x00;
	do
	{
		Eq_278 eax_437 = edx_425->t0004;
		cui16 * ecx_443 = (char *) &edx_425->t0004 + 0x04;
		if (eax_437 - 0x08 >> 0x01 > 0x00)
		{
			esi_12 = eax_437 - 0x08 >> 0x01;
			do
			{
				if ((*ecx_443 & 0xF000) == 0x3000)
				{
					struct Eq_407 * eax_613 = ((word32) *ecx_443 & 0x0FFF) + edx_425->dw0000;
					eax_613->dw401010 = eax_613->dw401010 + 0xF0401010;
				}
				ecx_443 = ecx_443 + 0x01;
				esi_12 = esi_12 - (struct HINSTANCE__ *) 0x01;
			} while (esi_12 != 0x00);
		}
		Eq_278 eax_450 = edx_425->t0004;
		up32 ecx_452 = (word32) eax_450.u0 + dwLoc08_430;
		edx_425 = edx_425 + eax_450;
		dwLoc08_430 = ecx_452;
	} while (ecx_452 < 228);
	struct Eq_309 * ebx_457 = &globals->t401D6C;
	struct Eq_309 * dwLoc04_458 = &globals->t401D6C;
	Eq_2 edx_459 = (char *) &edx_425->t0004 + 4201832;
	if (globals->dw401D7C != 0x00)
	{
		do
		{
			Eq_2 eax_499 = LoadLibraryA(ebx_457->dw000C + 0x00401010);
			CloseHandle(0x62);
			esi_12 = eax_499;
			&dwLoc1C_382.u0->dw0000 = (struct Eq_546 *) 0x62;
			if (eax_499 != 0x00)
			{
				struct Eq_376 * edi_528 = ebx_457->dw0000;
				if (edi_528 == null)
					edi_528 = ebx_457->dw0010;
				Eq_382 eax_534 = edi_528->t401010;
				edi_429 = (union Eq_274 *) &edi_528->t401010;
				esi_12 = ebx_457->dw0010 + 0x00401010;
				bool S_540 = (bool) cond(eax_534);
				if (eax_534 != 0x00)
				{
					do
					{
						if (!S_540)
						{
							edx_459 = (word32) *edi_429;
							dwLoc1C_382 = edx_459;
						}
						else
						{
							edx_459 = eax_499;
							dwLoc1C_382 = (word32) eax_534 + 0x00401012;
						}
						*esi_12 = GetProcAddress(eax_499, dwLoc1C_382);
						edi_429 = (union Eq_274 *) ((char *) edi_429 + 0x04);
						eax_534 = *edi_429;
						esi_12 = esi_12 + 0x04;
						S_540 = (bool) cond(eax_534);
					} while (eax_534 != 0x00);
					ebx_457 = dwLoc04_458;
				}
			}
			ebx_457 = ebx_457 + 0x01;
			dwLoc04_458 = ebx_457;
		} while (ebx_457->dw0010 != 0x00);
	}
	fn00401A60(0x00401A60, edx_459, ebx_457, 0x00401010, esi_12, edi_429, dwLoc1C_382, edi, rArg0);
	*(fp - 22) = 0x00;
	ExitProcess(*(fp - 22));
}

// 004019F5: void fn004019F5(Register byte al, Register byte bl, Register int32 ebp, Register (ptr32 Eq_453) edi)
void fn004019F5(byte al, byte bl, int32 ebp, Eq_453 * edi)
{
	__sti();
	edi->b0004 = edi->b0004 - (byte) (DPB(ebx, al, 8) + 0x01);
	__wait();
}

// 00401A60: FpuStack real64 fn00401A60(Register word32 eax, Register Eq_2 edx, Register (ptr32 Eq_309) ebx, Register int32 ebp, Register Eq_2 esi, Register (ptr32 Eq_274) edi, Stack Eq_2 dwArg00, Stack word32 dwArg04, FpuStack real64 rArg0)
real64 fn00401A60(word32 eax, Eq_2 edx, Eq_309 * ebx, int32 ebp, Eq_2 esi, Eq_274 * edi, Eq_2 dwArg00, word32 dwArg04, real64 rArg0)
{
	if (OVERFLOW(*esi - *edi))
	{
		byte al_70 = (byte) dwArg00;
		Eq_484 C_102 = (bool) cond(SEQ(al_70 + 191, al_70 + 191) + 38847);
		do
		{
			*((word32) edx + 1125234540) = *((word32) edx + 1125234540) - 0x7E26E72E - C_102;
			__wait();
			C_102.u0 = false;
		} while ((*((word32) esi - 0x0D117619) & ebp) > 0x00);
		(byte *) 0xD74340BE = (byte *) (byte) (ebx - 0x01);
		*(ebx - 0x01) = (byte) *((word32) esi + 0x04);
		return rArg0;
	}
	else
	{
		int64 edx_eax_36 = (int64) eax;
		byte al_39 = (byte) edx_eax_36;
		real64 rArg0_63 = rArg0 + (real64) ((word32) edx_eax_36)->w6F98EFA9;
		if (ebp > 0x01)
		{
			fn004019F5(al_39, bl, ebp - 0x01, (char *) edi + 0x04);
			return rArg0_63;
		}
	}
}

