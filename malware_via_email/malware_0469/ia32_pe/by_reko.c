// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_3 * ebp_15 = null;
	Eq_2 eax_22 = AddUsersToEncryptedFile(null, null);
	if (eax_22 == 0x00)
		return eax_22;
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x1C);
	struct Eq_37 * eax_47 = null;
	do
	{
		if (ebp_15 == null)
			ebp_15 = null;
		eax_47[4199880] = (struct Eq_37) (ebp_15[0x00404000] ^ eax_47[4199880] ^ 202);
		eax_47 = eax_47 + 0x01;
		ebp_15 = ebp_15 + 0x01;
	} while (eax_47 < (struct Eq_37 *) 0x1440);
	up32 ecx_230 = 0x00;
	struct Eq_62 * edi_234 = &globals->t4028C8;
	up32 dwLoc24_228 = 0x00;
	if (true)
	{
		do
		{
			Eq_80 eax_236 = edi_234->t0004;
			cui16 * esi_243 = (char *) &edi_234->t0004 + 0x04;
			if (eax_236 - 0x08 >> 0x01 > 0x00)
			{
				uint32 dwLoc28_258 = eax_236 - 0x08 >> 0x01;
				do
				{
					if ((*esi_243 & 0xF000) == 0x3000)
					{
						struct Eq_196 * eax_285 = ((word32) *esi_243 & 0x0FFF) + edi_234->dw0000;
						eax_285->dw401348 = eax_285->dw401348 + 0xF0401348;
					}
					uint32 v20_275 = dwLoc28_258 - 0x01;
					esi_243 = esi_243 + 0x01;
					dwLoc28_258 = v20_275;
				} while (v20_275 != 0x00);
				ecx_230 = dwLoc24_228;
			}
			ecx_230 = (word32) edi_234->t0004 + ecx_230;
			dwLoc24_228 = ecx_230;
			edi_234 = edi_234 + Mem71[edi_234 + 0x04:word32];
		} while (ecx_230 < ~0x00);
	}
	struct Eq_67 * esp_98 = fp - 0x40;
	struct Eq_70 * esi_101 = &globals->t4020B4;
	esi_127 = esi_101;
	esp_129 = esp_98;
	if (globals->dw4020C4 != 0x00)
	{
		do
		{
			struct Eq_70 * esi_127;
			struct Eq_67 * esp_129;
			esp_129 = esp_129 - 0x04;
			esp_129->dw0000 = esi_127->dw000C + 0x00401348;
			Eq_143 eax_135 = LoadLibraryA(esp_129->dw0000);
			if (eax_135 != null)
			{
				struct Eq_163 * edi_155 = esi_127->dw0000;
				if (edi_155 == null)
					edi_155 = esi_127->dw0010;
				Eq_169 eax_161 = edi_155->t401348;
				union Eq_173 * edi_162 = &edi_155->t401348;
				word32 * esi_163 = esi_127->dw0010 + 0x00401348;
				bool S_166 = cond(eax_161);
				if (eax_161 != 0x00)
				{
					do
					{
						Eq_226 eax_199;
						if (!S_166)
						{
							LPCSTR * esp_212 = esp_129 - 0x04;
							*esp_212 = (LPCSTR *) (word32) *edi_162;
							*(esp_212 - 0x04) = (HMODULE *) eax_135;
							eax_199 = GetProcAddress(*(esp_212 - 0x04), *esp_212);
						}
						else
						{
							LPCSTR * esp_221 = esp_129 - 0x04;
							*esp_221 = (word32) eax_161 + 4199242;
							*(esp_221 - 0x04) = (HMODULE *) eax_135;
							eax_199 = GetProcAddress(*(esp_221 - 0x04), *esp_221);
						}
						*esi_163 = (word32) eax_199;
						edi_162 = (union Eq_173 *) ((char *) edi_162 + 0x04);
						eax_161 = *edi_162;
						esp_129 = esp_129 - 0x08;
						esi_163 = esi_163 + 0x01;
						S_166 = cond(eax_161);
					} while (eax_161 != 0x00);
				}
				esi_127 = (struct Eq_70 *) esp_129[0x03];
			}
			esi_127 = esi_127 + 0x01;
			esp_129[0x03] = (struct Eq_67) esi_127;
		} while (esi_127->dw0010 != 0x00);
	}
	ptr32 esp_105;
	byte SCZO_106;
	word32 ebx_107;
	word32 ebp_108;
	word32 esi_109;
	word32 edi_110;
	byte SZO_111;
	byte C_112;
	word32 eax_113;
	byte Z_114;
	word32 edx_115;
	byte cl_116;
	word32 ecx_117;
	byte CZ_118;
	word16 dx_119;
	byte S_120;
	globals->t401DA8();
	*(esp_105 - 0x04) = 0x00;
	ExitProcess(*(esp_105 - 0x04));
}

