// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack Eq_3 dwArg04)
word32 fn003E1000(Eq_3 dwArg04)
{
	return dwArg04 + Mem0[dwArg04 + 0x3C:word32];
}

// 003E101D: void fn003E101D(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_10 dwArg0C)
void fn003E101D(Eq_3 dwArg04, Eq_3 dwArg08, SIZE_T dwArg0C)
{
	fn003E1A03(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 0x08);
}

// 003E10AF: Register Eq_28 fn003E10AF(Register word32 ecx, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
Eq_28 fn003E10AF(word32 ecx, Eq_3 dwArg04, Eq_3 dwArg08)
{
	Eq_28 eax_38;
	Eq_28 eax_17 = GetProcAddress(dwArg04, dwArg08);
	if (fn003E1A71(ecx, dwArg08, &globals->b3E2050) == 0x00)
	{
		globals->t3EAA10 = eax_17;
		&eax_38.u0->t0000 = 0x003E1050;
	}
	else if (fn003E1A71(0x003E2050, dwArg08, &globals->b3E2064) == 0x00)
	{
		globals->t3EAA14 = eax_17;
		&eax_38.u0->t0000 = 0x003E1080;
	}
	else
		eax_38 = eax_17;
	return eax_38;
}

// 003E110E: Register byte fn003E110E(Stack Eq_3 dwArg04)
byte fn003E110E(Eq_3 dwArg04)
{
	return (byte) (-(dwArg04 & 0x80000000) == 0x00);
}

// 003E1121: void fn003E1121(Register ptr32 ebp, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
void fn003E1121(ptr32 ebp, Eq_3 dwArg04, Eq_3 dwArg08)
{
	globals->t3EAA18 = GetModuleHandleA(0x00);
	globals->t3EAA1C = dwArg08;
	ptr32 esp_203 = fp - 44;
	word32 dwLoc08_206 = dwArg08 + Mem21[dwArg04 + 0x80:word32];
	while (*((word32) dwLoc08_206 + 0x0C) != 0x00)
	{
		Eq_3 dwLoc10_110;
		union Eq_3 * esp_71 = esp_203 - 0x04;
		*esp_71 = (union Eq_3 *) dwArg08;
		Mem79[esp_71 + 0x00:word32] = Mem72[esp_71 + 0x00:word32] + Mem72[dwLoc08_206 + 0x0C:word32];
		Eq_3 eax_80 = LoadLibraryA(*esp_71);
		if (*((word32) dwLoc08_206 + 0x04) == 0x00)
			dwLoc10_110 = dwArg08 + Mem79[dwLoc08_206 + 0x10:word32];
		else
		{
			*(esp_71 - 0x04) = (union Eq_3 *) dwLoc08_206;
			dwLoc10_110 = dwArg08 + Mem214[Mem214[(esp_71 - 0x04) + 0x00:word32] + 0x00:word32];
		}
		*(esp_71 - 0x04) = (union Eq_3 *) dwLoc08_206;
		struct Eq_141 * eax_90 = *(esp_71 - 0x04);
		*(esp_71 - 0x04) = (union Eq_3 *) dwArg08;
		union Eq_3 * esp_108 = esp_71;
		Eq_28 dwLoc18_109 = *(esp_71 - 0x04) + eax_90->dw0010;
		while (true)
		{
			union Eq_3 * esp_112 = esp_108 - 0x04;
			*esp_112 = (union Eq_3 *) dwLoc10_110;
			if (**esp_112 == 0x00)
				break;
			ptr32 esp_141;
			Eq_28 dwLoc14_140;
			*esp_112 = (union Eq_3 *) eax_80;
			*(esp_112 - 0x04) = (word32) *dwLoc10_110;
			if ((word32) fn003E110E(dwArg00) != 0x00)
			{
				*esp_112 = (union Eq_3 *) (word32) (word16) (*dwLoc10_110 & 0xFFFF);
				*(esp_112 - 0x04) = (union Eq_3 *) eax_80;
				esp_141 = esp_112 - 0x04;
				dwLoc14_140 = GetProcAddress(*(esp_112 - 0x04), *esp_112);
			}
			else
			{
				word32 ecx_181 = dwArg08 + Mem124[dwLoc10_110 + 0x00:word32];
				*esp_112 = (union Eq_3 *) (ecx_181 + 0x02);
				*(esp_112 - 0x04) = (union Eq_3 *) eax_80;
				esp_141 = (char *) esp_112 + 0x04;
				dwLoc14_140 = fn003E10AF(ecx_181, dwArg00, dwArg04);
			}
			union Eq_28 * esp_143 = esp_141 - 0x04;
			*esp_143 = (union Eq_28 *) dwLoc18_109;
			Eq_28 eax_145 = *esp_143;
			*esp_143 = (union Eq_28 *) dwLoc14_140;
			*eax_145 = *esp_143;
			*esp_143 = (union Eq_28 *) dwLoc18_109;
			esp_108 = (union Eq_3 *) ((char *) esp_143 + 0x04);
			dwLoc18_109 = (char *) *esp_143 + 0x04;
			dwLoc10_110 = (word32) dwLoc10_110 + 0x04;
		}
		*esp_112 = (union Eq_3 *) dwLoc08_206;
		esp_203 = (char *) esp_112 + 0x04;
		dwLoc08_206 = (char *) *esp_112 + 0x0014;
	}
}

// 003E1250: void fn003E1250(Register Eq_286 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack ui32 dwArg0C)
void fn003E1250(Eq_286 ecx, word32 dwArg04, word32 dwArg08, ui32 dwArg0C)
{
	ptr32 esp_15 = fp - 0x08;
	do
	{
		LPOVERLAPPED * esp_16 = esp_15 - 0x04;
		*esp_16 = (LPOVERLAPPED *) null;
		*(esp_16 - 0x04) = fp - 0x08;
		*(esp_16 - 0x08) = dwArg0C;
		*(esp_16 - 0x08) = *(esp_16 - 0x08) - (ecx & 0x00);
		*(esp_16 - 0x0C) = dwArg08;
		*(esp_16 - 0x10) = dwArg04;
		esp_15 = esp_16 - 0x10;
	} while (ReadFile(*(esp_16 - 0x10), *(esp_16 - 0x0C), *(esp_16 - 0x08), *(esp_16 - 0x04), *esp_16) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E1286: void fn003E1286(Register Eq_286 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack ui32 dwArg0C)
void fn003E1286(Eq_286 ecx, word32 dwArg04, word32 dwArg08, ui32 dwArg0C)
{
	ptr32 esp_10 = fp - 0x08;
	do
	{
		LPOVERLAPPED * esp_20 = esp_10 - 0x04;
		*esp_20 = (LPOVERLAPPED *) null;
		*(esp_20 - 0x04) = fp - 0x08;
		*(esp_20 - 0x08) = dwArg0C - (ecx & 0x00);
		*(esp_20 - 0x0C) = dwArg08;
		*(esp_20 - 0x10) = dwArg04;
		esp_10 = esp_20 - 0x10;
	} while (WriteFile(*(esp_20 - 0x10), *(esp_20 - 0x0C), *(esp_20 - 0x08), *(esp_20 - 0x04), *esp_20) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E12BD: Register Eq_286 fn003E12BD(Register Eq_286 ecx, Stack (ptr Eq_446) dwArg04, Stack Eq_286 dwArg08, Stack uint32 dwArg0C)
Eq_286 fn003E12BD(Eq_286 ecx, Eq_446 * dwArg04, Eq_286 dwArg08, uint32 dwArg0C)
{
	uint32 dwLoc08_14 = ecx & 0x00;
	while (dwLoc08_14 < dwArg0C)
	{
		fn003E1286(dwArg08, dwArg04->dw0004, (word32) dwArg08 + dwLoc08_14 * 0x04, 0x08);
		fn003E1250(dwArg08, dwArg04->dw0000, (word32) dwArg08 + dwLoc08_14 * 0x04, 0x08);
		ecx = dwArg08;
		dwLoc08_14 = dwLoc08_14 + 0x02;
	}
	return ecx;
}

// 003E1400: Register Eq_340 fn003E1400(Stack Eq_3 dwArg04)
HANDLE fn003E1400(Eq_3 dwArg04)
{
	CloseHandle(*dwArg04);
	Eq_340 v8_22 = *((word32) dwArg04 + 0x04);
	CloseHandle(v8_22);
	return v8_22;
}

// 003E141D: Register word32 fn003E141D(Register Eq_286 ecx, Register ptr32 ebp)
word32 fn003E141D(Eq_286 ecx, ptr32 ebp)
{
	if ((word32) fn003E1620()->ptr0030->b0002 == 0x00)
	{
		globals->dw413E1D = 0x53;
		globals->dw413E1D = globals->dw413E1D + 4696;
		globals->dw413E21 = 0x1454;
		globals->dw413E25 = 0x7407;
		globals->dw413E29 = 0x0ABE;
		globals->dw413E29 = globals->dw413E29 + 10838;
		if (CreatePipe(fp - 0x44, fp - 0x34, null, 0x10) != 0x00 && CreatePipe(fp - 0x38, fp - 0x40, null, 0x10) != 0x00)
		{
			CreateThread(null, 0x00, &globals->t3E1313, fp - 0x44, 0x00, fp - 44);
			fn003E12BD(fn003E12BD(ecx, fp - 0x38, fp - 0x24, 0x08), fp - 0x38, 0x003E3000, globals->dw3EAA0B >> 0x02);
			*(fp - 0x90) = fn003E1400(fp - 0x38) - 0x40;
			ptr32 ebp_210 = fn003E1400(dwArg00);
			*(fp - 0x90) = *(ebp_210 - 0x44);
			CloseHandle(*(fp - 0x90));
			*(fp - 0x94) = 0x003E3000;
			*(ebp_210 - 44) = fn003E1000(dwArg00);
			if (*(ebp_210 - 44) != 0x00)
			{
				*(fp - 0x94) = *(ebp_210 - 44);
				*(fp - 0x94) = *((char *) *(fp - 0x94) + 0x0034);
				*(ebp_210 - 0x4C) = *(fp - 0x94);
				*(fp - 0x94) = *((char *) *(ebp_210 - 44) + 0x0054);
				*(fp - 0x98) = *(ebp_210 - 0x4C);
				*(fp - 0x9C) = 0x003E3000;
				fn003E101D(dwArg00, dwArg04, dwArg08);
				*(fp - 0x94) = *(ebp_210 - 0x4C);
				*(fp - 0x98) = 0x003E3000;
				*(fp - 0x9C) = *(ebp_210 - 44);
				fn003E1630(dwArg00, dwArg04, dwArg08);
				*(fp - 0x94) = *(ebp_210 - 0x4C);
				*(ebp_210 - 0x48) = fn003E1000(dwArg00);
				if (*(ebp_210 - 0x48) != 0x00)
				{
					*(fp - 0x94) = *(ebp_210 - 0x4C);
					*(fp - 0x98) = *(ebp_210 - 0x48);
					fn003E1121(ebp_210, dwArg00, dwArg04);
					*(fp - 0x94) = *(ebp_210 - 0x4C);
					*(fp - 0x98) = *(ebp_210 - 0x48);
					fn003E17C2(ebp_210, dwArg00, dwArg04);
					*((char *) *(ebp_210 - 0x38) + 0x08) = *(ebp_210 - 0x4C);
					*(fp - 0x94) = *(ebp_210 - 44);
					struct Eq_834 * eax_302 = *(fp - 0x94);
					*(fp - 0x94) = *(ebp_210 - 0x4C);
					word32 ecx_309 = *(fp - 0x94) + eax_302->dw0028;
					*(ebp_210 - 0x50) = ecx_309;
					word32 esp_312;
					word32 ebp_313;
					byte SCZO_314;
					word32 eax_315;
					byte SZO_316;
					byte C_317;
					byte Z_318;
					word32 ecx_319;
					(*(ebp_210 - 0x50))();
				}
			}
		}
	}
	return 0x00;
}

// 003E1604: Register Eq_21 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	*(fp - 0x08) = fn003E141D(ecx, fp - 0x04);
	*(fp - 0x0C) = *(fp - 0x08);
	ExitProcess(*(fp - 0x0C));
}

// 003E1620: Register word32 fn003E1620()
word32 fn003E1620()
{
	return fs->dw0018;
}

// 003E1630: void fn003E1630(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_10 dwArg0C)
void fn003E1630(Eq_3 dwArg04, Eq_3 dwArg08, SIZE_T dwArg0C)
{
	word16 ax_21 = *((word32) dwArg04 + 0x06);
	cui16 wLoc14_130 = wLoc14 & 0x00;
	while ((word32) wLoc14_130 < (word32) ax_21)
	{
		Eq_10 dwLoc2C_136;
		Eq_10 v16_68 = (word32) wLoc14_130 *s 0x28 + 0x08 + ((word32) dwArg04 + 0x00F8);
		Eq_10 v17_77 = (word32) wLoc14_130 *s 0x28 + 0x10 + ((word32) dwArg04 + 0x00F8);
		if (v16_68 < v17_77)
			dwLoc2C_136 = v16_68;
		else
			dwLoc2C_136 = v17_77;
		fn003E1A03(dwArg0C + Mem0[((word32) wLoc14_130 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem0[((word32) wLoc14_130 *s 0x28 + 0x14) + (dwArg04 + 0xF8):word32], dwLoc2C_136);
		wLoc14_130 = wLoc14_130 + 0x01;
	}
}

// 003E16FD: Register ui32 fn003E16FD(Register int32 ecx, Stack ui32 dwArg04)
ui32 fn003E16FD(int32 ecx, ui32 dwArg04)
{
	ui32 dwLoc08_10 = ecx & 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_10 = ecx & 0x00 | 0x0200;
	ui32 dwLoc08_105;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_105 = dwLoc08_10 | 0x40;
			else
				dwLoc08_105 = dwLoc08_10 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_105 = dwLoc08_10 | 0x80;
		else
			dwLoc08_105 = dwLoc08_10 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_105 = dwLoc08_10 | 0x04;
		else
			dwLoc08_105 = dwLoc08_10 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_105 = dwLoc08_10 | 0x08;
	else
		dwLoc08_105 = dwLoc08_10 | 0x01;
	return dwLoc08_105;
}

// 003E17C2: void fn003E17C2(Register ptr32 ebp, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
void fn003E17C2(ptr32 ebp, Eq_3 dwArg04, Eq_3 dwArg08)
{
	ptr32 esp_16 = fp - 0x20;
	word16 ax_21 = *((word32) dwArg04 + 0x06);
	cui16 wLoc14_27 = wLoc14 & 0x00;
	while ((word32) wLoc14_27 < (word32) ax_21)
	{
		word32 edx_48 = dwArg08 + Mem0[((word32) wLoc14_27 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32];
		PDWORD * esp_53 = esp_16 - 0x04;
		*esp_53 = (word32) dwArg04 + 0x00F8;
		*esp_53 = *((char *) *esp_53 + ((word32) ((word32) wLoc14_27 *s 0x28) + 0x08));
		Eq_22 eax_60 = *esp_53;
		*esp_53 = (PDWORD *) (fp - 0x18);
		*(esp_53 - 0x04) = (word32) dwArg04 + 0x00F8;
		int32 ecx_72 = *(esp_53 - 0x04);
		*(esp_53 - 0x04) = (word32) ((word32) wLoc14_27 *s 0x28) + 0x0024 + ecx_72;
		*(esp_53 - 0x04) = fn003E16FD(ecx_72, dwArg00);
		*(esp_53 - 0x08) = (PDWORD *) eax_60;
		*(esp_53 - 0x0C) = edx_48;
		VirtualProtect(*(esp_53 - 0x0C), *(esp_53 - 0x08), *(esp_53 - 0x04), *esp_53);
		esp_16 = esp_53 - 0x0C;
		wLoc14_27 = wLoc14_27 + 0x01;
	}
}

// 003E1A03: void fn003E1A03(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_10 dwArg0C)
void fn003E1A03(Eq_3 dwArg04, Eq_3 dwArg08, SIZE_T dwArg0C)
{
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = *dwArg08;
		dwArg04 = (word32) dwArg04 + 0x01;
		dwArg08 = (word32) dwArg08 + 0x01;
	}
}

// 003E1A71: Register int32 fn003E1A71(Register word32 ecx, Stack Eq_3 dwArg04, Stack (ptr byte) dwArg08)
int32 fn003E1A71(word32 ecx, Eq_3 dwArg04, byte * dwArg08)
{
	while (true)
	{
		int32 eax_32 = (word32) *dwArg04 - (word32) (*dwArg08);
		int32 dwLoc08_35 = eax_32;
		if (eax_32 != 0x00 || (int32) (*dwArg08) == 0x00)
			break;
		dwArg04 = (word32) dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
	if (eax_32 < 0x00)
		dwLoc08_35 = eax_32 | ~0x00;
	else if (eax_32 > 0x00)
		dwLoc08_35 = 0x01;
	return dwLoc08_35;
}

