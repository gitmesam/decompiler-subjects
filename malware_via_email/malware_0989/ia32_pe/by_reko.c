// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack Eq_3 dwArg04)
word32 fn003E1000(Eq_3 dwArg04)
{
	return dwArg04 + Mem0[dwArg04 + 0x3C:word32];
}

// 003E101D: void fn003E101D(Stack (ptr32 byte) dwArg04, Stack Eq_3 dwArg08, Stack Eq_10 dwArg0C)
void fn003E101D(byte * dwArg04, Eq_3 dwArg08, SIZE_T dwArg0C)
{
	fn003E1A03(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 0x08);
}

// 003E10AF: Register Eq_28 fn003E10AF(Register word32 ecx, Stack Eq_30 dwArg04, Stack Eq_31 dwArg08)
FARPROC fn003E10AF(word32 ecx, HMODULE dwArg04, LPCSTR dwArg08)
{
	Eq_28 eax_39;
	Eq_28 eax_17 = GetProcAddress(dwArg04, dwArg08);
	if (fn003E1A71(ecx, dwArg08, &globals->b3E2050) == 0x00)
	{
		globals->t3EAA10 = eax_17;
		eax_39 = (Eq_28) &globals->t3E1050;
	}
	else if (fn003E1A71(0x003E2050, dwArg08, &globals->b3E2064) == 0x00)
	{
		globals->t3EAA14 = eax_17;
		eax_39 = (Eq_28) &globals->t3E1080;
	}
	else
		eax_39 = eax_17;
	return eax_39;
}

// 003E110E: Register byte fn003E110E(Stack ui32 dwArg04)
byte fn003E110E(ui32 dwArg04)
{
	return (byte) (-(dwArg04 & 0x80000000) == 0x00);
}

// 003E1121: void fn003E1121(Stack (ptr32 Eq_68) dwArg04, Stack Eq_3 dwArg08)
void fn003E1121(Eq_68 * dwArg04, Eq_3 dwArg08)
{
	globals->t3EAA18 = GetModuleHandleA(null);
	globals->t3EAA1C = dwArg08;
	struct Eq_79 * dwLoc08_210 = (word32) dwArg08 + dwArg04->dw0080;
	while (dwLoc08_210->dw000C != 0x00)
	{
		ui32 * dwLoc10_114;
		Eq_30 eax_84 = LoadLibraryA((word32) dwArg08 + dwLoc08_210->dw000C);
		if (dwLoc08_210->dw0004 == 0x00)
			dwLoc10_114 = (word32) dwArg08 + dwLoc08_210->dw0010;
		else
			dwLoc10_114 = (word32) dwArg08 + dwLoc08_210->dw0000;
		word32 * dwLoc18_103 = (word32) dwArg08 + dwLoc08_210->dw0010;
		while (*dwLoc10_114 != 0x00)
		{
			Eq_28 dwLoc14_144;
			if ((word32) fn003E110E(*dwLoc10_114) != 0x00)
				dwLoc14_144 = GetProcAddress(eax_84, (word32) (word16) (*dwLoc10_114 & 0xFFFF));
			else
			{
				word32 ecx_185 = (word32) dwArg08 + *dwLoc10_114;
				dwLoc14_144 = fn003E10AF(ecx_185, eax_84, ecx_185 + 0x02);
			}
			*dwLoc18_103 = (word32) dwLoc14_144;
			dwLoc18_103 = dwLoc18_103 + 0x01;
			dwLoc10_114 = dwLoc10_114 + 0x01;
		}
		dwLoc08_210 = dwLoc08_210 + 0x01;
	}
}

// 003E1250: void fn003E1250(Register Eq_160 ecx, Stack Eq_161 dwArg04, Stack Eq_3 dwArg08, Stack ui32 dwArg0C)
void fn003E1250(Eq_160 ecx, HANDLE dwArg04, Eq_3 dwArg08, ui32 dwArg0C)
{
	do
		;
	while (ReadFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E1286: void fn003E1286(Register Eq_160 ecx, Stack Eq_161 dwArg04, Stack Eq_185 dwArg08, Stack ui32 dwArg0C)
void fn003E1286(Eq_160 ecx, HANDLE dwArg04, LPCVOID dwArg08, ui32 dwArg0C)
{
	do
		;
	while (WriteFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E12BD: Register Eq_160 fn003E12BD(Register Eq_160 ecx, Stack (ptr32 Eq_207) dwArg04, Stack Eq_160 dwArg08, Stack uint32 dwArg0C)
Eq_160 fn003E12BD(Eq_160 ecx, Eq_207 * dwArg04, Eq_160 dwArg08, uint32 dwArg0C)
{
	uint32 dwLoc08_14 = ecx & 0x00;
	while (dwLoc08_14 < dwArg0C)
	{
		fn003E1286(dwArg08, dwArg04->t0004, (word32) dwArg08 + dwLoc08_14 * 0x04, 0x08);
		fn003E1250(dwArg08, dwArg04->t0000, (word32) dwArg08 + dwLoc08_14 * 0x04, 0x08);
		ecx = dwArg08;
		dwLoc08_14 = dwLoc08_14 + 0x02;
	}
	return ecx;
}

// 003E1400: void fn003E1400(Stack (ptr32 Eq_236) dwArg04)
void fn003E1400(Eq_236 * dwArg04)
{
	CloseHandle(dwArg04->t0000);
	CloseHandle(dwArg04->t0004);
}

// 003E141D: Register word32 fn003E141D(Register Eq_160 ecx)
word32 fn003E141D(Eq_160 ecx)
{
	struct Eq_251 * v7_16 = fn003E1620()->ptr0030;
	if ((word32) v7_16->b0002 == 0x00)
	{
		globals->dw413E1D = 0x53;
		globals->dw413E1D = globals->dw413E1D + 4696;
		globals->dw413E21 = 0x1454;
		globals->dw413E25 = 0x7407;
		globals->dw413E29 = 0x0ABE;
		globals->dw413E29 = globals->dw413E29 + 10838;
		if (CreatePipe(fp - 0x44, fp - 0x34, null, 0x10) != 0x00 && CreatePipe(fp - 0x38, fp - 0x40, null, 0x10) != 0x00)
		{
			Eq_161 eax_139 = CreateThread(null, 0x00, &globals->t3E1313, fp - 0x44, 0x00, fp - 44);
			fn003E12BD(fn003E12BD(ecx, fp - 0x38, fp - 0x24, 0x08), fp - 0x38, 0x003E3000, globals->dw3EAA0B >> 0x02);
			fn003E1400(fp - 0x38);
			fn003E1400(fp - 0x44);
			CloseHandle(eax_139);
			struct Eq_68 * eax_205 = fn003E1000(0x003E3000);
			if (eax_205 != null)
			{
				Eq_3 v23_230 = eax_205->t0034;
				fn003E101D(&globals->b3E3000, v23_230, eax_205->t0054);
				fn003E1630(eax_205, 0x003E3000, v23_230);
				struct Eq_68 * eax_260 = fn003E1000(v23_230);
				if (eax_260 != null)
				{
					fn003E1121(eax_260, v23_230);
					fn003E17C2(eax_260, v23_230);
					v7_16->t0008 = v23_230;
					<anonymous> * ecx_299 = (word32) v23_230 + eax_205->dw0028;
					word32 esp_302;
					word32 ebp_303;
					byte SCZO_304;
					word32 eax_305;
					byte SZO_306;
					bool C_307;
					bool Z_308;
					word32 ecx_309;
					ecx_299();
				}
			}
		}
	}
	return 0x00;
}

// 003E1604: Register Eq_21 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ExitProcess(fn003E141D(ecx));
}

// 003E1620: Register word32 fn003E1620()
word32 fn003E1620()
{
	return fs->dw0018;
}

// 003E1630: void fn003E1630(Stack (ptr32 Eq_68) dwArg04, Stack word32 dwArg08, Stack Eq_3 dwArg0C)
void fn003E1630(Eq_68 * dwArg04, word32 dwArg08, Eq_3 dwArg0C)
{
	word16 ax_21 = dwArg04->w0006;
	cui16 wLoc14_130 = wLoc14 & 0x00;
	while ((word32) wLoc14_130 < (word32) ax_21)
	{
		Eq_10 dwLoc2C_136;
		Eq_10 v16_68 = (&dwArg04->dw0080 + 0x001E)[((word32) wLoc14_130 *s 0x28 + 0x08) / 0x0084];
		Eq_10 v17_77 = (&dwArg04->dw0080 + 0x001E)[((word32) wLoc14_130 *s 0x28 + 0x10) / 0x0084];
		if (v16_68 < v17_77)
			dwLoc2C_136 = v16_68;
		else
			dwLoc2C_136 = v17_77;
		fn003E1A03(dwArg0C + Mem0[((word32) wLoc14_130 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem0[((word32) wLoc14_130 *s 0x28 + 0x14) + (dwArg04 + 0xF8):word32], dwLoc2C_136);
		wLoc14_130 = wLoc14_130 + 0x01;
	}
}

// 003E16FD: Register ui32 fn003E16FD(Register Eq_481 ecx, Stack ui32 dwArg04)
ui32 fn003E16FD(Eq_481 ecx, ui32 dwArg04)
{
	ui32 dwLoc08_10 = ecx & 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_10 = ecx & 0x00 | 0x0200;
	ui32 dwLoc08_105;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_105 = dwLoc08_10 | 0x40;
			else
				dwLoc08_105 = dwLoc08_10 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_105 = dwLoc08_10 | 0x80;
		else
			dwLoc08_105 = dwLoc08_10 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_105 = dwLoc08_10 | 0x04;
		else
			dwLoc08_105 = dwLoc08_10 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_105 = dwLoc08_10 | 0x08;
	else
		dwLoc08_105 = dwLoc08_10 | 0x01;
	return dwLoc08_105;
}

// 003E17C2: void fn003E17C2(Stack (ptr32 Eq_68) dwArg04, Stack Eq_3 dwArg08)
void fn003E17C2(Eq_68 * dwArg04, Eq_3 dwArg08)
{
	word16 ax_21 = dwArg04->w0006;
	cui16 wLoc14_100 = wLoc14 & 0x00;
	while ((word32) wLoc14_100 < (word32) ax_21)
	{
		VirtualProtect(dwArg08 + Mem0[((word32) wLoc14_100 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], Mem0[(word32) wLoc14_100 *s 0x28 + 0x08 + (dwArg04 + 0xF8):word32], fn003E16FD(dwArg04 + 0xF8, Mem0[(word32) wLoc14_100 *s 0x28 + 0x24 + (dwArg04 + 0xF8):word32]), fp - 0x18);
		wLoc14_100 = wLoc14_100 + 0x01;
	}
}

// 003E1A03: void fn003E1A03(Stack Eq_3 dwArg04, Stack (ptr32 byte) dwArg08, Stack Eq_10 dwArg0C)
void fn003E1A03(Eq_3 dwArg04, byte * dwArg08, SIZE_T dwArg0C)
{
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = *dwArg08;
		dwArg04 = (word32) dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
}

// 003E1A71: Register int32 fn003E1A71(Register word32 ecx, Stack Eq_31 dwArg04, Stack (ptr32 byte) dwArg08)
int32 fn003E1A71(word32 ecx, LPCSTR dwArg04, byte * dwArg08)
{
	while (true)
	{
		int32 eax_32 = (word32) (*dwArg04 - *dwArg08);
		int32 dwLoc08_35 = eax_32;
		if (eax_32 != 0x00 || (int32) (*dwArg08) == 0x00)
			break;
		dwArg04 = (Eq_31) (dwArg04 + 0x01);
		dwArg08 = dwArg08 + 0x01;
	}
	if (eax_32 < 0x00)
		dwLoc08_35 = eax_32 | ~0x00;
	else if (eax_32 > 0x00)
		dwLoc08_35 = 0x01;
	return dwLoc08_35;
}

