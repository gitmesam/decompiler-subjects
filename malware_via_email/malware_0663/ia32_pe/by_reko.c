// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 esi_12 = null;
	Eq_3 edi_17 = (struct <anonymous> *) 0x1F;
	Eq_2 eax_24 = AddUsersToEncryptedFile(&globals->t403020, null);
	if (eax_24 == 0x00)
		return eax_24;
	Eq_17 eax_33 = AreAllAccessesGranted(~0x00, ~0x00);
	if (eax_33 == 0x00)
		edi_17 = eax_33 + 0x11;
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x20);
	struct Eq_40 * esp_46 = fp - 0x44;
	struct Eq_43 * ecx_52 = null;
	do
	{
		if (esi_12 == edi_17)
			esi_12 = null;
		ecx_52[4199880] = (struct Eq_43) (esi_12[0x00404000] ^ ecx_52[4199880] ^ 0x90);
		ecx_52 = ecx_52 + 0x01;
		esi_12 = (Eq_3) (esi_12 + 0x01);
	} while (ecx_52 < (struct Eq_43 *) 0x1440);
	word32 ebp_86 = 0x00401348;
	struct Eq_69 * edx_247 = &globals->t4028C8;
	up32 edi_250 = 0x00;
	up32 dwLoc28_246 = 0x00;
	if (true)
	{
		do
		{
			Eq_85 eax_255 = edx_247->t0004 - 0x08 >> 0x01;
			cui16 * ecx_259 = (char *) &edx_247->t0004 + 0x04;
			if (eax_255 > 0x00)
			{
				Eq_85 ebx_275 = eax_255;
				do
				{
					if ((*ecx_259 & 0xF000) == 0x3000)
					{
						struct Eq_115 * eax_297 = ((word32) *ecx_259 & 0x0FFF) + edx_247->dw0000;
						eax_297->dw401348 = eax_297->dw401348 + 0xF0401348;
					}
					ecx_259 = ecx_259 + 0x01;
					ebx_275 = ebx_275 - 0x01;
				} while (ebx_275 != 0x00);
				edi_250 = dwLoc28_246;
			}
			edi_250 = (word32) edx_247->t0004 + edi_250;
			dwLoc28_246 = edi_250;
			edx_247 = edx_247 + Mem76[edx_247 + 0x04:word32];
		} while (edi_250 < ~0x00);
	}
	struct Eq_76 * edi_105 = &globals->t4020B4;
	edi_135 = edi_105;
	ebp_137 = ebp_86;
	esp_140 = esp_46;
	if (globals->dw4020C4 != 0x00)
	{
		do
		{
			struct Eq_76 * edi_135;
			word32 ebp_137;
			struct Eq_40 * esp_140;
			esp_140 = esp_140 - 0x04 + 0x18;
			esp_140->dw0000 = edi_135->dw000C + ebp_137;
			Eq_176 eax_145 = LoadLibraryA(esp_140->dw0000);
			esp_140[0x04] = (struct Eq_40) eax_145;
			if (eax_145 != null)
			{
				word32 ecx_169 = edi_135->dw0000;
				if (ecx_169 == 0x00)
					ecx_169 = edi_135->dw0010;
				word32 * ebp_176 = ebp_137 + ecx_169;
				word32 * edi_179 = (word32) esp_140[0x03].dw0000 + edi_135->dw0010;
				if (*ebp_176 != 0x00)
				{
					while (true)
					{
						Eq_236 eax_216;
						int32 ecx_207 = *ebp_176;
						word16 cx_208 = (word16) ecx_207;
						if (ecx_207 < 0x00)
						{
							LPCSTR * esp_227 = esp_140 - 0x04;
							*esp_227 = (LPCSTR *) (word32) cx_208;
							*(esp_227 - 0x04) = (HMODULE *) eax_145;
							eax_216 = GetProcAddress(*(esp_227 - 0x04), *esp_227);
						}
						else
						{
							LPCSTR * esp_238 = esp_140 - 0x04;
							*esp_238 = (LPCSTR *) (ecx_207 + 0x02 + esp_140->dw0000);
							*(esp_238 - 0x04) = (HMODULE *) eax_145;
							eax_216 = GetProcAddress(*(esp_238 - 0x04), *esp_238);
						}
						*edi_179 = (word32) eax_216;
						esp_140 = esp_140 - 0x08;
						ebp_176 = ebp_176 + 0x01;
						edi_179 = edi_179 + 0x01;
						if (*ebp_176 == 0x00)
							break;
						eax_145 = (Eq_176) esp_140[0x04];
					}
				}
				ebp_137 = (word32) esp_140[0x03];
				edi_135 = esp_140->dw001C;
			}
			edi_135 = edi_135 + 0x01;
			esp_140->dw001C = edi_135;
		} while (edi_135->dw0010 != 0x00);
	}
	ptr32 esp_112;
	byte SCZO_113;
	word32 ebx_114;
	word32 ebp_115;
	word32 esi_116;
	byte SZO_117;
	byte C_118;
	word32 edi_119;
	word32 eax_120;
	byte Z_121;
	word32 ecx_122;
	byte dl_123;
	word32 edx_124;
	byte CZ_125;
	word16 ax_126;
	byte S_127;
	word16 cx_128;
	globals->t401DA8();
	*(esp_112 - 0x04) = 0x00;
	ExitProcess(*(esp_112 - 0x04));
}

