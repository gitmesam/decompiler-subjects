// Generated by Rec Studio 4 - build Sep 23 2015

signed int* L00401000(
    _unknown_ __eax,                       // r0
    signed int __ebx,                      // r1
    signed int __edx,                      // r3
    signed int __edi,                      // r4
    signed int _a4,                        // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int* _t40;                      // _t40
    signed int _t62;                       // _t62
    signed int* _t68;                      // _t68
    signed int _t71;                       // _t71
    signed int _t80;                       // _t80
    signed int _t81;                       // _t81
    signed int _t91;                       // _t91
    signed int _t94;                       // _t94

    __ebx = __ebx;
    _push(__ebx);
    _push(__edi);
    _t91 = (__edi | -1) + 1;
    _v8 = _v8 & _t91;
    _v12 = _v12 & _t91;
    _push(_t91);
    _v16 = _v16 & _t91;
    _push(_t91);
    _push(_t91);
    _t71 = __edx * 0 - 1;
    _v16 = _v16 + _t71;
    _push(_t71 + 1);
    _push(0);
    _push(0);
    _push(0);
    __imp__RtlAdjustPrivilege();
    _t40 = __eax - -1073741727;
    if(_t40 != 0) {
        goto __imp__VirtualAlloc;
    }
L3:
    while(_v12 < _a12) {
        asm("sbb edx, [ecx]");
        _v24 =  !( ~0x00000000);
        _v24 = 0;
        _t80 = 0xffffffffffffffff;
        _v24 = _t80;
        asm("adc eax, ecx");
        _t81 = _t80 + 1;
        _t62 = (((0 |  *(_a16 + _v8)) & _v24 ^ _v24) + 1 & _t81 ^ _a4) + _v12;
        _v20 = _v20 & _t81;
        _v20 = _v20 | _t62;
        _push(0);
        _pop( *__eax);
        _push(0 + _t62);
        _t40 = L004013B2(0 + _t62);
        asm("adc [eax], ecx");
        _t68 = __esp;
        __esp = _t40;
         *_t40 = ( *_t40 ^ (0 | _v24)) + 1;
        __esp = _t68;
        _t94 = 0 + _v8 + 1;
        _v8 = _t94;
        if(_t94 == 1) {
            _v8 = 0;
        }
        if(_v8 != 1984) {
            _push(_t68);
            _pop(__edx);
            asm("clc");
            asm("sbb edx, [ebp-0xc]");
            __ebx = __ebx * 0;
            _v12 = _v12 & __ebx;
            _v12 = _v12 | 0 | _v12;
            continue;
        }
        break;
    }
    return _t40;
    goto L3;
}

VirtualAlloc()
{// addr = 0x00401033
    goto __imp__VirtualAlloc;
}

signed int L00401348(
    signed int _a4,                        // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v412;                        // _cfa_fffffe64
    _unknown_ _t53;                        // _t53
    signed int* _t54;                      // _t54
    signed int _t76;                       // _t76
    signed int* _t82;                      // _t82
    signed int _t83;                       // _t83
    signed int _t85;                       // _t85
    signed int _t94;                       // _t94
    signed int _t95;                       // _t95
    signed int _t103;                      // _t103
    signed int _t105;                      // _t105
    signed int _t109;                      // _t109
    _unknown_ _t111;                       // _t111
    signed int* _t112;                     // _t112

    if(0 < 64) {
L1:
        _push(_t111);
        _t112 = __esp;
        _push(__ebx);
        _push(_t103);
        _t105 = (_t103 | -1) + 1;
        _v8 = _v8 & _t105;
        _v12 = _v12 & _t105;
        _push(_t105);
        _v16 = _v16 & _t105;
        _push(_t105);
        _push(_t105);
        _t85 = _t83 * 0 - 1;
        _v16 = _v16 + _t85;
        _push(_t85 + 1);
        _push(0);
        _push(0);
        _push(0);
        __imp__RtlAdjustPrivilege();
        _t54 = _t53 - -1073741727;
        if(_t54 != 0) {
            goto __imp__VirtualAlloc;
        }
L4:
        while(_v12 < _a12) {
            asm("sbb edx, [ecx]");
            _v24 =  !( ~0x00000000);
            _v24 = 0;
            _t94 = 0xffffffffffffffff;
            _v24 = _t94;
            asm("adc eax, ecx");
            _t95 = _t94 + 1;
            _t76 = (((0 |  *(_a16 + _v8)) & _v24 ^ _v24) + 1 & _t95 ^ _a4) + _v12;
            _v20 = _v20 & _t95;
            _v20 = _v20 | _t76;
            _push(0);
            _pop( *__eax);
            _push(0 + _t76);
            _t54 = L004013B2(0 + _t76);
            asm("adc [eax], ecx");
            _t82 = __esp;
            __esp = _t54;
             *_t54 = ( *_t54 ^ (0 | _v24)) + 1;
            __esp = _t82;
            _t109 = 0 + _v8 + 1;
            _v8 = _t109;
            if(_t109 == 1) {
                _v8 = 0;
            }
            if(_v8 != 1984) {
                _push(_t82);
                _pop(__edx);
                asm("clc");
                asm("sbb edx, [ebp-0xc]");
                __ebx = __ebx * 0;
                _v12 = _v12 & __ebx;
                _v12 = _v12 | 0 | _v12;
                continue;
            }
            break;
        }
        __esp = _t112;
        _pop(__ebp);
        return _t54;
    } else {
        __ebx = 0;
        if(0 < 44864) {
            goto L1;
        } else {
            0 = 0 | _v32;
            _push(0 | _v32);
            _v8 = _v8 +  ~0xFFFFEAD0;
            _v20 = 0;
            _v20 = _v20 + _v8 +  ~0xFFFFEAD0;
            _push(_v412);
            __eax = 0;
            __edi = 0;
            __eax = 0 + _v16;
            _v8 =  ~_v8;
            __edx = _v8;
            0 - _v8 = 0 - _v8 +  *((intOrPtr*)(0 + _v16 + 4));
            _push(0 - _v8 +  *((intOrPtr*)(0 + _v16 + 4)));
            __edi = 0;
            __edi = 0 | _v20;
            _push(__edi);
            _push(__edi);
            __eax = _v20;
            _push(__eax);
            return __eax;
        }
    }
}

signed int L00401353(
    signed int _a4,                        // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v412;                        // _cfa_fffffe64
    _unknown_ _t53;                        // _t53
    signed int* _t54;                      // _t54
    signed int _t76;                       // _t76
    signed int* _t82;                      // _t82
    signed int _t83;                       // _t83
    signed int _t85;                       // _t85
    signed int _t94;                       // _t94
    signed int _t95;                       // _t95
    signed int _t103;                      // _t103
    signed int _t105;                      // _t105
    signed int _t108;                      // _t108
    _unknown_ _t110;                       // _t110
    signed int* _t111;                     // _t111

    __ebx = 0;
    if(0 < 44864) {
        _push(_t110);
        _t111 = __esp;
        _push(0);
        _push(_t103);
        _t105 = (_t103 | -1) + 1;
        _v8 = _v8 & _t105;
        _v12 = _v12 & _t105;
        _push(_t105);
        _v16 = _v16 & _t105;
        _push(_t105);
        _push(_t105);
        _t85 = _t83 * 0 - 1;
        _v16 = _v16 + _t85;
        _push(_t85 + 1);
        _push(0);
        _push(0);
        _push(0);
        __imp__RtlAdjustPrivilege();
        _t54 = _t53 - -1073741727;
        if(_t54 != 0) {
            goto __imp__VirtualAlloc;
        }
L4:
        while(_v12 < _a12) {
            asm("sbb edx, [ecx]");
            _v24 =  !( ~0x00000000);
            _v24 = 0;
            _t94 = 0xffffffffffffffff;
            _v24 = _t94;
            asm("adc eax, ecx");
            _t95 = _t94 + 1;
            _t76 = (((0 |  *(_a16 + _v8)) & _v24 ^ _v24) + 1 & _t95 ^ _a4) + _v12;
            _v20 = _v20 & _t95;
            _v20 = _v20 | _t76;
            _push(0);
            _pop( *__eax);
            _push(0 + _t76);
            _t54 = L004013B2(0 + _t76);
            asm("adc [eax], ecx");
            _t82 = __esp;
            __esp = _t54;
             *_t54 = ( *_t54 ^ (0 | _v24)) + 1;
            __esp = _t82;
            _t108 = 0 + _v8 + 1;
            _v8 = _t108;
            if(_t108 == 1) {
                _v8 = 0;
            }
            if(_v8 != 1984) {
                _push(_t82);
                _pop(__edx);
                asm("clc");
                asm("sbb edx, [ebp-0xc]");
                __ebx = __ebx * 0;
                _v12 = _v12 & __ebx;
                _v12 = _v12 | 0 | _v12;
                continue;
            }
            break;
        }
        __esp = _t111;
        _pop(__ebp);
        return _t54;
    } else {
        0 = 0 | _v32;
        _push(0 | _v32);
        _v8 = _v8 +  ~0xFFFFEAD0;
        _v20 = 0;
        _v20 = _v20 + _v8 +  ~0xFFFFEAD0;
        _push(_v412);
        __eax = 0;
        __edi = 0;
        __eax = 0 + _v16;
        _v8 =  ~_v8;
        __edx = _v8;
        0 - _v8 = 0 - _v8 +  *((intOrPtr*)(0 + _v16 + 4));
        _push(0 - _v8 +  *((intOrPtr*)(0 + _v16 + 4)));
        __edi = 0;
        __edi = 0 | _v20;
        _push(__edi);
        _push(__edi);
        __eax = _v20;
        _push(__eax);
        return __eax;
    }
}

L004013B2(
    _unknown_ __eax                        // r0
)
{
    __eax = __eax;
    asm("clc");
    return __eax;
}

L004013B2(
    _unknown_ __eax                        // r0
)
{
    __eax = __eax;
    asm("clc");
    return __eax;
}

// Statistics:
//      65 Register nodes
//     113 Temporaries nodes
//       4 Casts
//      30 Statements
//       8 Labels
//       2 Gotos
//       5 Blocks
//     842 Nodes
//      16 Assembly nodes
//       9 Unknown Types


Total time: 0 seconds.
