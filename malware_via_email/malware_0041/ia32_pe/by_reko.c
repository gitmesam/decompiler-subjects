// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register DWORD Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 ecx_15;
	word32 edx_16;
	word32 ebp_17;
	byte al_18 = fn00401078(out ecx_15, out edx_16, out ebp_17);
	Mem25[fp - 0x18 + 0x00:word32] = Mem0[0x00404400:word32];
	Mem27[fp - 0x1C + 0x00:word32] = 0x00402000;
	fn0040112A(al_18, ecx_15, edx_16, ebx, ebp_17);
	Mem36[fp - 0x12 + 0x00:word32] = 0x062E;
	Mem38[fp - 22 + 0x00:word32] = 0x0040112A;
	word32 ecx_39;
	word32 edx_40;
	word32 ebp_41;
	fn00401078(out ecx_39, out edx_40, out ebp_41);
	if (false)
	{
		Mem54[fp - 0x12 + 0x00:word32] = 0x00405000;
		Mem56[fp - 22 + 0x00:word32] = 0x00401000;
		lstrcpyA(Mem56[fp - 22 + 0x00:LPSTR], Mem56[fp - 0x12 + 0x00:LPCSTR]);
	}
	return 0x00;
}

// 00401078: Register byte fn00401078(Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebpOut)
byte fn00401078(ptr32 & ecxOut, ptr32 & edxOut, ptr32 & ebpOut)
{
	word32 ecx_9;
	word32 edx_10;
	word32 ebp_11;
	return fn004010FD(fp - 0x04, out ecx_9, out edx_10, out ebp_11);
}

// 004010F0: Register byte fn004010F0(Register word32 edx, Register word32 ebp, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebpOut)
byte fn004010F0(word32 edx, word32 ebp, ptr32 & ecxOut, ptr32 & edxOut, ptr32 & ebpOut)
{
	ptr32 fp;
	word32 ebp;
	<type-error> Mem0;
	word32 edx;
	ptr32 ecxOut;
	ptr32 edxOut;
	ptr32 ebpOut;
	esp_1 = fp;
	eax_4 = Mem0[ebp - 0x04 + 0x00:word32];
	eax_5 = eax_4 + Mem0[ebp + 0x08:word32];
	al_6 = Mem0[eax_5 + 0x00:byte];
	eax_7 = DPB(eax_5, al_6, 0);
	eax_8 = eax_7 - 77;
	al_9 = (byte) eax_8;
	SCZO_10 = cond(eax_8);
	Mem11[edx + 0x00:byte] = al_9;
	al_16 = fn004010FD(ebp, out ecx_13, out edx_14, out ebp_15);
	eax_17 = DPB(eax_8, al_16, 0);
	return al_16;
}

// 004010FD: Register byte fn004010FD(Register word32 ebp, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebpOut)
byte fn004010FD(word32 ebp, ptr32 & ecxOut, ptr32 & edxOut, ptr32 & ebpOut)
{
	do
	{
		esp = v3;
		eax = Mem0[ebp - 0x04 + 0x00:word32];
		eax = eax & 0x01;
		SZO = cond(eax & eax);
		Z = (bool) SZO;
		C = false;
		if (Test(EQ,Z))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			ecx = Mem0[ebp + 0x08:word32];
			ecx = ecx + eax;
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			eax = eax + Mem0[ebp + 0x08:word32];
			edx = Mem0[ebp - 0x04 + 0x00:word32];
			dl = (byte) edx;
			al = Mem0[eax + 0x00:byte];
			al = al - dl;
			SCZO = cond(al);
			Mem0[ecx + 0x00:byte] = al;
		}
		eax = ebp - 0x04;
		v14 = Mem0[eax + 0x00:word32] + 0x01;
		Mem0[eax + 0x00:word32] = v14;
		SZO = cond(v14);
		eax = Mem0[ebp - 0x04 + 0x00:word32];
		al = (byte) eax;
		SCZO = cond(eax - Mem0[ebp + 0x0C:word32]);
		SO = SCZO;
		if (Test(GE,SO))
		{
			esp = ebp;
			ebp = Mem0[esp + 0x00:word32];
			esp = esp + 0x04;
			return al;
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x01);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			edx = Mem0[ebp + 0x08:word32];
			edx = edx + eax;
			dl = (byte) edx;
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			eax = eax + Mem0[ebp + 0x08:word32];
			al = Mem0[eax + 0x00:byte];
			eax = DPB(eax, al, 0);
			eax = eax ^ 0x35;
			al = (byte) eax;
			SZO = cond(eax);
			C = false;
			Mem0[edx + 0x00:byte] = al;
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x02);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			eax = eax - 0x02;
			eax = eax & 0x01;
			SZO = cond(eax & eax);
			Z = (bool) SZO;
			C = false;
			if (Test(EQ,Z))
			{
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				ecx = Mem0[ebp + 0x08:word32];
				ecx = ecx + eax;
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				edx = Mem0[ebp + 0x08:word32];
				edx = edx + eax;
				dl = (byte) edx;
				al = 226;
				al = 226 + Mem0[edx + 0x00:byte];
				SCZO = cond(al);
				Mem0[ecx + 0x00:byte] = al;
			}
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x02);
		SZO = SCZO;
		if (Test(LE,SZO))
			continue;
		eax = Mem0[ebp - 0x04 + 0x00:word32];
		eax = eax - 0x02;
		eax = eax & 0x01;
		SZO = cond(eax & eax);
		Z = (bool) SZO;
		C = false;
	} while (Test(NE,Z));
	eax = Mem0[ebp - 0x04 + 0x00:word32];
	edx = Mem0[ebp + 0x08:word32];
	edx = edx + eax;
	dl = (byte) edx;
	SCZO = cond(edx);
	al = fn004010F0(edx, ebp, out ecx, out edx, out ebp);
	eax = DPB(eax, al, 0);
	return al;
}

// 0040112A: void fn0040112A(Register byte al, Register word32 ecx, Register word32 edx, Register word32 ebx, Register word32 ebp)
void fn0040112A(byte al, word32 ecx, word32 edx, word32 ebx, word32 ebp)
{
	Mem11[ecx + 0x00:word32] = 0xDC4B4A4D;
	word32 eax_9 = DPB(eax, 110, 8);
	Mem16[eax_9 + 0x35:word32] = Mem11[eax_9 + 0x35:word32] ^ ecx;
	if (!OVERFLOW(Mem16[eax_9 + 0x35:word32]))
		return;
	word32 ecx_28;
	word32 edx_29;
	word32 ebp_30;
	fn004010F0(edx, 3058054466, out ecx_28, out edx_29, out ebp_30);
}

