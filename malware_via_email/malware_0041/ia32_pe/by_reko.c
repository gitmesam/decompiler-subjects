// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register DWORD Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 ecx_15;
	word32 edx_16;
	word32 ebp_17;
	byte al_18 = fn00401078(out ecx_15, out edx_16, out ebp_17);
	Mem25[fp - 0x18 + 0x00:word32] = Mem0[0x00404400:word32];
	Mem27[fp - 0x1C + 0x00:word32] = 0x00402000;
	fn0040112A(al_18, ecx_15, edx_16, ebx, ebp_17);
	Mem36[fp - 0x12 + 0x00:word32] = 0x062E;
	Mem38[fp - 22 + 0x00:word32] = 0x0040112A;
	word32 ecx_39;
	word32 edx_40;
	word32 ebp_41;
	fn00401078(out ecx_39, out edx_40, out ebp_41);
	if (false)
	{
		Mem54[fp - 0x12 + 0x00:word32] = 0x00405000;
		Mem56[fp - 22 + 0x00:word32] = 0x00401000;
		lstrcpyA(Mem56[fp - 22 + 0x00:LPSTR], Mem56[fp - 0x12 + 0x00:LPCSTR]);
	}
	return 0x00;
}

// 00401078: Register byte fn00401078(Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebpOut)
byte fn00401078(ptr32 & ecxOut, ptr32 & edxOut, ptr32 & ebpOut)
{
	word32 ecx_9;
	word32 edx_10;
	word32 ebp_11;
	return fn004010FD(fp - 0x04, out ecx_9, out edx_10, out ebp_11);
}

// 004010F0: Register byte fn004010F0(Register word32 edx, Register word32 ebp, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebpOut)
byte fn004010F0(word32 edx, word32 ebp, ptr32 & ecxOut, ptr32 & edxOut, ptr32 & ebpOut)
{
	ptr32 fp;
	word32 ebp;
	<type-error> Mem0;
	word32 edx;
	ptr32 ecxOut;
	ptr32 edxOut;
	ptr32 ebpOut;
	esp_1 = fp;
	eax_4 = Mem0[ebp - 0x04 + 0x00:word32];
	eax_5 = eax_4 + Mem0[ebp + 0x08:word32];
	al_6 = Mem0[eax_5 + 0x00:byte];
	eax_7 = DPB(eax_5, al_6, 0);
	eax_8 = eax_7 - 77;
	al_9 = (byte) eax_8;
	SCZO_10 = cond(eax_8);
	Mem11[edx + 0x00:byte] = al_9;
	al_16 = fn004010FD(ebp, out ecx_13, out edx_14, out ebp_15);
	eax_17 = DPB(eax_8, al_16, 0);
	return al_16;
}

// 004010FD: Register byte fn004010FD(Register word32 ebp, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebpOut)
byte fn004010FD(word32 ebp, ptr32 & ecxOut, ptr32 & edxOut, ptr32 & ebpOut)
{
}

// 0040112A: void fn0040112A(Register byte al, Register word32 ecx, Register word32 edx, Register word32 ebx, Register word32 ebp)
void fn0040112A(byte al, word32 ecx, word32 edx, word32 ebx, word32 ebp)
{
	Mem11[ecx + 0x00:word32] = 0xDC4B4A4D;
	word32 eax_9 = DPB(eax, 110, 8);
	Mem16[eax_9 + 0x35:word32] = Mem11[eax_9 + 0x35:word32] ^ ecx;
	if (!OVERFLOW(Mem16[eax_9 + 0x35:word32]))
		return;
	word32 ecx_28;
	word32 edx_29;
	word32 ebp_30;
	fn004010F0(edx, 3058054466, out ecx_28, out edx_29, out ebp_30);
}

