// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401030: Register (ptr32 byte) fn00401030(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
byte * fn00401030(HMODULE dwArg04, HMODULE dwArg08, HMODULE dwArg0C)
{
	globals->t4072E8 = null;
	while (globals->t4072E8 < dwArg0C)
	{
		edx = dwArg04 + Mem6[4223720:word32];
		Mem25[edx + 0x00:byte] = Mem6[dwArg08 + Mem6[4223720:word32]:byte];
		globals->t4072E8 = (Eq_3) ((char *) &globals->t4072E8->unused + 0x01);
	}
	return edx;
}

// 004010C0: Register Eq_28 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 dwLoc18_20 = GetModuleHandleA(null);
	LoadIconA(null, (CHAR *) 0x7F00);
	globals->t4072E8 = (struct HINSTANCE__ *) 1169;
	globals->t4072F0 = dwArg04;
	if ((globals->t4072F0 & 0xFFFF) != 0x00)
		globals->dw407300 = 0x00;
	else
		globals->dw407300 = 0x01;
	if (globals->t4072F0 == null)
		globals->dw407300 = 0x00;
	if (globals->dw407300 != 0x00)
		dwLoc18_20 = globals->t4072F0;
	GetWindowsDirectoryA(fp - 332, 0xE6);
	lstrcatA(fp - 332, &globals->t407290);
	if (CreateFileA(fp - 332, 0x80, 0x03, null, 0x03, 0x80, null) == (void *) ~0x00)
		return 0x00;
	lstrcatA(fp - 332, &globals->t4072A4);
	if (CreateFileA(fp - 332, 0x80, 0x03, null, 0x03, 0x80, null) != (void *) ~0x00)
		return 0x00;
	globals->t4072E8 = (struct HINSTANCE__ *) 0x0222;
	globals->t4072E8 = (struct HINSTANCE__ *) 6846;
	struct Eq_134 * dwLoc08_159 = null;
	while (dwLoc08_159 < (struct Eq_134 *) 0x5200)
	{
		GetModuleHandleA(null);
		dwLoc08_159->dw402001 = dwLoc08_159 + dwLoc08_159->dw402001 / 0x08;
		dwLoc08_159->dw402001 = (char *) &dwLoc08_159->dw402001 + 41364171 ^ dwLoc08_159->dw402001;
		dwLoc08_159 = dwLoc08_159 + 0x01;
	}
	globals->t4072FC = fn004019B0(0x5200);
	fn00401030(globals->t4072FC, globals->a402001, (struct HINSTANCE__ *) 0x5200);
	globals->dw4072EC = edi;
	globals->dw4072E4 = esi;
	globals->dw4072F8 = ebx;
	globals->ptr407308 = fs->ptr0018;
	globals->ptr4072F4 = fp - 0x04;
	globals->t407304 = GetModuleHandleA(&globals->t4072C0);
	Eq_175 dwLoc08_223 = 0x00;
	while (dwLoc08_223 < 0x07)
	{
		globals->a407320[dwLoc08_223 * 0x04] = fn00401350(globals->t407304, dwLoc08_223 *s 0x13 + 0x00407208);
		dwLoc08_223 = (word32) dwLoc08_223 + 0x01;
	}
	word32 ebp_261 = fn004019E0(fp - 0x04, 4199163 - dwLoc18_20, dwLoc18_20);
	Eq_3 ecx_264 = globals->t4072FC;
	word32 eax_267 = fn004013A0(ebp_261, ecx_264);
	struct Eq_167 * esp_271 = globals->ptr4072F4;
	if (globals->dw407300 != 0x00)
		esp_271->t0008 = globals->t4072FC;
	word32 esp_275;
	word32 ebp_276;
	byte SCZO_277;
	word32 ebx_278;
	word32 esi_279;
	word32 edi_280;
	Eq_28 eax_281;
	byte SZO_282;
	bool C_283;
	bool Z_284;
	word32 ecx_285;
	word32 edx_286;
	struct Eq_255 * fs_287;
	globals->ptr40733C();
	return eax_281;
}

// 00401350: Register Eq_263 fn00401350(Stack Eq_3 dwArg04, Stack Eq_32 dwArg08)
FARPROC fn00401350(HMODULE dwArg04, LPCSTR dwArg08)
{
	return GetProcAddress(dwArg04, dwArg08);
}

// 00401370: Register word32 fn00401370(Stack Eq_3 dwArg04)
word32 fn00401370(HMODULE dwArg04)
{
	globals->t4072E8 = (struct HINSTANCE__ *) 0x01;
	word32 * edx_13 = &dwArg04->unused + 0x001E + globals->t4072E8 * 0x02;
	GetCommandLineA();
	return *edx_13;
}

// 004013A0: Register word32 fn004013A0(Register word32 ebp, Stack Eq_3 dwArg04)
word32 fn004013A0(word32 ebp, HMODULE dwArg04)
{
	globals->dw407300 == 0x00;
	struct Eq_293 * ecx_20 = dwArg04 + (&dwArg04->unused)[0x0F] / 0x04;
	struct Eq_298 * edx_26 = &ecx_20->w0014 + 0x02 + (word32) ecx_20->w0014 / 0x0040;
	struct Eq_298 * dwLoc28_27 = edx_26;
	ptr32 esp_38;
	word32 ebp_39;
	byte SCZO_40;
	word32 esi_41;
	bool Z_42;
	Eq_3 eax_43;
	word32 ecx_44;
	word32 edx_45;
	bool C_46;
	byte SZO_47;
	word16 cx_48;
	globals->ptr40732C();
	*(esp_38 - 0x04) = (&dwArg04->unused)[0x0F] + 0x0138 + (word32) ecx_20->w0006 *s 0x28;
	*(esp_38 - 0x08) = (HMODULE *) dwArg04;
	*(esp_38 - 0x0C) = (HMODULE *) eax_43;
	fn00401030(dwArg00, dwArg04, dwArg08);
	up32 dwLoc14_70 = 0x00;
	while (dwLoc14_70 < (word32) ecx_20->w0006)
	{
		if (dwLoc28_27->dw0014 != 0x00 && dwLoc28_27->dw0010 != 0x00)
		{
			*(esp_38 - 0x04) = (uint32) ((uint64) (uint32) ((word32) ecx_20->t003C + (dwLoc28_27->dw0010 - 0x01)) /u ecx_20->t003C) *s ecx_20->t003C;
			*(esp_38 - 0x08) = dwArg04 + dwLoc28_27->dw0014 / 0x04;
			*(esp_38 - 0x0C) = eax_43 + dwLoc28_27->dw000C / 0x04;
			fn00401030(dwArg00, dwArg04, dwArg08);
		}
		dwLoc28_27 = dwLoc28_27 + 0x01;
		dwLoc14_70 = dwLoc14_70 + 0x01;
	}
	struct Eq_358 * ecx_134 = eax_43 + (&eax_43->unused)[0x0F] / 0x04;
	*(esp_38 - 0x04) = (struct Eq_358 **) ecx_134;
	struct Eq_368 * eax_142 = eax_43 + fn00401370(dwArg00) / 0x04;
	if (globals->dw407300 != 0x00)
	{
		if (eax_142->dw0010 == 0x00)
		{
			if (globals->dw407300 != 0x00)
			{
				globals->t4072E0 = null;
				if (globals->t4072E0 != null)
				{
					if (globals->dw407300 == 0x00)
					{
						*(esp_38 - 0x04) = ecx_134->dw0050;
						*(esp_38 - 0x08) = (HMODULE *) eax_43;
						Eq_3 ecx_234 = globals->t4072E0;
						*(esp_38 - 0x0C) = (HMODULE *) ecx_234;
						fn00401030(dwArg00, dwArg04, dwArg08);
						*(esp_38 - 0x04) = 0x00;
						ptr32 esp_250;
						word32 ebp_251;
						byte SCZO_252;
						word32 esi_253;
						bool Z_254;
						word32 eax_255;
						word32 ecx_256;
						word32 edx_257;
						bool C_258;
						byte SZO_259;
						word16 cx_260;
						globals->ptr407328();
						*(esp_250 - 0x04) = (HMODULE *) globals->t4072E0;
						fn00401B30(dwArg00);
						Mem269[0x0040733C:word32] = Mem263[0x004072E0:word32] + Mem263[ecx_134 + 0x28:word32];
						ecx_134->ptr0028 = globals->ptr40733C;
					}
					else
					{
						globals->t4072E0 = eax_43;
						ptr32 ecx_277 = eax_43 - ecx_134->t0034;
						if (ecx_134->dw00A4 != 0x00)
						{
							struct Eq_750 * dwLoc20_342 = eax_43 + ecx_134->dw00A0 / 0x04;
							while (dwLoc20_342->t0004 != 0x00)
							{
								uint32 ecx_357 = dwLoc20_342->t0004 - 0x08 >> 0x01;
								word16 edx_360[] = (char *) &dwLoc20_342->t0004 + 0x04;
								uint32 dwLoc14_363 = 0x00;
								while (dwLoc14_363 < ecx_357)
								{
									if ((word32) edx_360[dwLoc14_363] >> 0x0C == 0x03)
										(eax_43 + dwLoc20_342->dw0000 / 0x04)[((word32) edx_360[dwLoc14_363] & 0x0FFF) / 0x04] = (struct HINSTANCE__) ((word32) (eax_43 + dwLoc20_342->dw0000 / 0x04)[((word32) edx_360[dwLoc14_363] & 0x0FFF) / 0x04].unused + ecx_277);
									dwLoc14_363 = dwLoc14_363 + 0x01;
								}
								dwLoc20_342 = dwLoc20_342 + Mem274[dwLoc20_342 + 0x04:word32];
							}
						}
						Mem292[0x0040733C:word32] = Mem274[0x004072E0:word32] + Mem274[ecx_134 + 0x28:word32];
						struct Eq_637 * ecx_295 = (char *) ecx_134->ptr0028 + dwLoc0C;
						ecx_134->w0016 = (word16) ((word32) ecx_134->w0016 | 0x2000);
						*(esp_38 - 0x04) = fp - 0xC0;
						*(esp_38 - 0x08) = 0x40;
						*(esp_38 - 0x0C) = 0x06;
						*(esp_38 - 0x10) = (struct Eq_637 **) ecx_295;
						VirtualProtect(*(esp_38 - 0x10), *(esp_38 - 0x0C), *(esp_38 - 0x08), *(esp_38 - 0x04));
						ecx_295->b0000 = 0x68;
						ecx_295->ptr0001 = globals->ptr40733C;
						ecx_295->b0005 = 0xC3;
						globals->t4072FC = globals->t4072E0;
						*(esp_38 - 0x04) = (HMODULE *) globals->t4072E0;
						Mem332[esp_38 - 0x08 + 0x00:word32] = Mem326[0x004072E0:word32] + Mem326[ecx_134 + 0x28:word32];
						*(esp_38 - 0x0C) = (HMODULE *) globals->t4072F0;
						fn00401930(dwArg00, dwArg04, dwArg08);
					}
					return 0x01;
				}
				else
				{
					Eq_3 dwLoc0C_193;
					if (globals->dw407300 != 0x00)
						dwLoc0C_193 = globals->t4072F0;
					else
						dwLoc0C_193 = ecx_134->t0034;
					*(esp_38 - 0x04) = (HMODULE *) dwLoc0C_193;
				}
			}
			else
			{
				*(esp_38 - 0x04) = (HMODULE *) ecx_134->t0034;
				*(esp_38 - 0x08) = 0x00;
				*(esp_38 - 0x0C) = 0x00;
				*(esp_38 - 0x10) = 0x00;
				*(esp_38 - 0x14) = 0x22;
				*(esp_38 - 0x18) = 0x00;
			}
		}
		else
			*(esp_38 - 0x04) = eax_43 + eax_142->dw000C / 0x04;
	}
	else
	{
		*(esp_38 - 0x04) = 0x00;
		*(esp_38 - 0x08) = ecx_134->dw0050;
		*(esp_38 - 0x0C) = 0x00;
		*(esp_38 - 0x10) = 0x04;
		*(esp_38 - 0x14) = 0x00;
		*(esp_38 - 0x18) = ~0x00;
	}
}

// 00401930: void fn00401930(Stack Eq_3 dwArg04, Stack Eq_3 dwArg08, Stack Eq_3 dwArg0C)
void fn00401930(HMODULE dwArg04, HMODULE dwArg08, HMODULE dwArg0C)
{
	struct Eq_813 * ecx_14 = globals->ptr407308->ptr0030->ptr000C->ptr000C;
	struct Eq_813 * dwLoc0C_15 = ecx_14;
	while (0x01 != 0x00 && dwLoc0C_15 != null)
	{
		if (dwLoc0C_15->t0018 == dwArg04)
		{
			dwLoc0C_15->t001C = dwArg08;
			dwLoc0C_15->t0018 = dwArg0C;
			return;
		}
		struct Eq_813 * edx_57 = dwLoc0C_15->ptr0000;
		dwLoc0C_15 = edx_57;
		if (edx_57 == ecx_14)
			return;
	}
}

// 004019B0: Register Eq_679 fn004019B0(Stack Eq_140 dwArg04)
LPVOID fn004019B0(SIZE_T dwArg04)
{
	GetCommandLineA();
	return HeapAlloc(GetProcessHeap(), 0x00, dwArg04);
}

// 004019E0: Register ptr32 fn004019E0(Register ptr32 ebp, Stack Eq_3 dwArg04, Stack Eq_3 dwArg08)
ptr32 fn004019E0(ptr32 ebp, HMODULE dwArg04, HMODULE dwArg08)
{
	struct Eq_859 * edx_16 = dwArg08 + (&dwArg08->unused)[0x0F] / 0x04;
	ptr32 esp_29;
	ptr32 ebp_30;
	byte SCZO_31;
	word32 esi_32;
	Eq_3 eax_33;
	word32 ecx_34;
	word32 edx_35;
	bool Z_36;
	bool C_37;
	byte SZO_38;
	globals->ptr40732C();
	globals->t4072E0 = eax_33;
	if (globals->t4072E0 == null)
		return ebp;
	*(esp_29 - 0x04) = edx_16->dw0050;
	*(esp_29 - 0x08) = (HMODULE *) dwArg08;
	*(esp_29 - 0x0C) = (HMODULE *) globals->t4072E0;
	fn00401030(dwArg00, dwArg04, dwArg08);
	ui32 eax_82 = globals->t4072E0 - dwArg08;
	if (edx_16->dw00A4 != 0x00)
	{
		struct Eq_922 * dwLoc0C_109 = dwArg08 + edx_16->dw00A0 / 0x04;
		while (dwLoc0C_109->t0004 != 0x00)
		{
			uint32 eax_124 = dwLoc0C_109->t0004 - 0x08 >> 0x01;
			word16 ecx_127[] = (char *) &dwLoc0C_109->t0004 + 0x04;
			uint32 dwLoc08_130 = 0x00;
			while (dwLoc08_130 < eax_124)
			{
				if ((word32) ecx_127[dwLoc08_130] >> 0x0C == 0x03)
					(globals->t4072E0 + dwLoc0C_109->dw0000 / 0x04)[((word32) ecx_127[dwLoc08_130] & 0x0FFF) / 0x04] = (struct HINSTANCE__) ((word32) (globals->t4072E0 + dwLoc0C_109->dw0000 / 0x04)[((word32) ecx_127[dwLoc08_130] & 0x0FFF) / 0x04].unused + eax_82);
				dwLoc08_130 = dwLoc08_130 + 0x01;
			}
			dwLoc0C_109 = dwLoc0C_109 + Mem76[dwLoc0C_109 + 0x04:word32];
		}
	}
	Mem101[esp_29 - 0x04 + 0x00:word32] = dwArg04 + Mem76[0x004072E0:word32];
	return ebp_30;
}

// 00401B30: void fn00401B30(Stack Eq_3 dwArg04)
void fn00401B30(HMODULE dwArg04)
{
	globals->ptr407308->ptr0030->t0008 = dwArg04;
}

