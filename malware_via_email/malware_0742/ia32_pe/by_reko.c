// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401040: void fn00401040(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08, Stack (ptr Eq_4) dwArg0C)
void fn00401040(HMODULE dwArg04, Eq_3 dwArg08, Eq_4 * dwArg0C)
{
	globals->ptr4063FC = null;
	while (globals->ptr4063FC < dwArg0C)
	{
		Mem25[dwArg04 + Mem6[4219900:word32]:byte] = Mem6[dwArg08 + Mem6[4219900:word32]:byte];
		globals->ptr4063FC = (struct Eq_4 *) (globals->ptr4063FC->a0000 + 0x01)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000;
	}
}

// 004010D0: Register Eq_25 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	GetProcAddress(LoadLibraryA(4219544), &globals->t406298)();
	lstrcatA(fp - 116, 0x004062A8);
	Eq_46 eax_67 = CreateFileA(fp - 116, 0x01, 0x03, null, 0x03, 0x80, null);
	if (eax_67 == (void *) ~0x00 || eax_67 == null)
		return 0x00;
	if (GetProcAddress(LoadLibraryA(0x004062C4), 0x004062C4)() != 0x00 || (GetProcAddress)(LoadLibraryA(4219624), 4219624)() == 0x00)
		return 0x00;
	Eq_2 eax_192 = GetModuleHandleA(0x00);
	word32 * esp_190 = fp - 0x010C;
	Eq_2 eax_196 = globals->t402001;
	Eq_2 edx_199 = globals->t402005;
	Eq_2 dwLoc08_201 = null;
	while (dwLoc08_201 < eax_196)
	{
		esp_190 = esp_190 - 0x04;
		*esp_190 = 0x00;
		GetModuleHandleA(*esp_190);
		*((char *) &dwLoc08_201->unused + 0x00402009) = (Eq_2) (*((char *) &dwLoc08_201->unused + 0x00402009) ^ 11152423);
		dwLoc08_201 = (Eq_2) (&dwLoc08_201->unused + 0x02);
	}
	HMODULE * esp_225 = esp_190 - 0x04;
	*esp_225 = (HMODULE *) edx_199;
	globals->t40640C = fn004016C0(dwArg00);
	*esp_225 = (HMODULE *) eax_196;
	*(esp_225 - 0x04) = (HMODULE *) globals->t40640C;
	*(esp_225 - 0x08) = 0x00402009;
	fn00401880(dwArg00, dwArg04, dwArg08);
	globals->dw406400 = edi_176;
	globals->dw4063F8 = esi_175;
	globals->dw406408 = ebx_174;
	globals->ptr406410 = fs_183->ptr0018;
	globals->ptr406404 = fp - 0x04;
	*esp_225 = (HMODULE *) eax_192;
	word32 ecx_258 = 4199081 - eax_192;
	*(esp_225 - 0x04) = ecx_258;
	word32 ebp_262 = fn004016F0(ebp_172, dwArg00, dwArg04);
	Eq_2 edx_265 = globals->t40640C;
	*esp_225 = (HMODULE *) edx_265;
	word32 eax_268 = fn00401300(ebp_262, dwArg00);
	word32 esp_275;
	word32 ebp_276;
	byte SCZO_277;
	word32 ebx_278;
	word32 esi_279;
	word32 edi_280;
	Eq_25 eax_281;
	word32 ecx_282;
	word32 edx_283;
	byte Z_284;
	byte SZO_285;
	byte C_286;
	struct Eq_204 * fs_287;
	globals->ptr406414();
	return eax_281;
}

// 004012E0: Register Eq_35 fn004012E0(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08)
FARPROC fn004012E0(HMODULE dwArg04, Eq_3 dwArg08)
{
	return GetProcAddress(dwArg04, dwArg08);
}

// 00401300: Register word32 fn00401300(Register word32 ebp, Stack Eq_3 dwArg04)
word32 fn00401300(word32 ebp, Eq_3 dwArg04)
{
	lstrcpyA(fp - 188, 0x0040630C);
	Eq_2 eax_15 = GetModuleHandleA(0x00406314);
	Eq_35 eax_22 = GetProcAddress(eax_15, 0x00406324);
	Eq_35 eax_29 = GetProcAddress(eax_15, 0x00406334);
	Eq_35 eax_36 = GetProcAddress(eax_15, 0x00406348);
	Eq_35 eax_43 = GetProcAddress(eax_15, 0x00406358);
	Eq_35 eax_50 = GetProcAddress(eax_15, 0x00406364);
	word32 edx_58 = dwArg04 + Mem0[dwArg04 + 0x3C:word32];
	struct Eq_272 * dwLoc2C_110 = &edx_58->w0014 + 0x02 + (word32) edx_58->w0014 / 22;
	struct Eq_280 * eax_79 = eax_36();
	fn00401040(dwArg00, dwArg04, dwArg08);
	up32 dwLoc10_105 = 0x00;
	while (dwLoc10_105 < (word32) edx_58->w0006)
	{
		if (dwLoc2C_110->dw0014 != 0x00 && dwLoc2C_110->dw0010 != 0x00)
			fn00401040(dwArg00, dwArg04, dwArg08);
		dwLoc2C_110 = dwLoc2C_110 + 0x01;
		dwLoc10_105 = dwLoc10_105 + 0x01;
	}
	struct Eq_294 * ecx_168 = eax_79 + eax_79->dw003C / 0x0040;
	Eq_46 eax_188 = eax_29();
	union Eq_3 * esp_185 = fp - 0x0128;
	struct Eq_304 * dwLocCC_199 = eax_79 + ecx_168->dw0080 / 0x0040;
	while (dwLocCC_199->dw0010 != 0x00)
	{
		word32 * dwLoc38_228;
		ui32 * dwLoc28_227;
		union Eq_3 * esp_220 = esp_185 - 0x04;
		*esp_220 = (union Eq_3 *) (eax_79 + dwLocCC_199->dw000C / 0x0040);
		Eq_2 eax_222 = LoadLibraryA(*esp_220);
		if (dwLocCC_199->dw0000 != 0x00)
		{
			dwLoc28_227 = (ui32 *) (eax_79 + dwLocCC_199->dw0000 / 0x0040);
			dwLoc38_228 = (word32 *) (eax_79 + dwLocCC_199->dw0010 / 0x0040);
		}
		else
		{
			dwLoc28_227 = (ui32 *) (eax_79 + dwLocCC_199->dw0010 / 0x0040);
			dwLoc38_228 = (word32 *) (eax_79 + dwLocCC_199->dw0000 / 0x0040);
		}
		word32 dwLoc1C_231 = 0x00;
		if (dwLocCC_199->dw0010 != 0x00 && dwLocCC_199->dw0000 != 0x00)
			dwLoc1C_231 = 0x01;
		while (true)
		{
			esp_185 = esp_220;
			if (*dwLoc28_227 == 0x00)
				break;
			if ((*dwLoc28_227 & 0x80000000) != 0x00)
			{
				*(esp_220 - 0x04) = *dwLoc28_227 & 0x7FFFFFFF;
				*(esp_220 - 0x08) = (HMODULE *) eax_222;
				*dwLoc28_227 = fn004012E0(dwArg00, dwArg04);
			}
			else
			{
				*(esp_220 - 0x04) = eax_79 + (*dwLoc28_227 + 0x02) / 0x0040;
				*(esp_220 - 0x08) = (HMODULE *) eax_222;
				*dwLoc28_227 = fn004012E0(dwArg00, dwArg04);
			}
			if (dwLoc1C_231 != 0x00)
				*dwLoc38_228 = *dwLoc28_227;
			dwLoc28_227 = dwLoc28_227 + 0x01;
			dwLoc38_228 = dwLoc38_228 + 0x01;
		}
		dwLocCC_199 = dwLocCC_199 + 0x01;
	}
	word32 eax_359;
	word32 * esp_329 = esp_185 - 0x04;
	*esp_329 = ecx_168->dw0034;
	*(esp_329 - 0x04) = 0x00;
	*(esp_329 - 0x08) = 0x00;
	*(esp_329 - 0x0C) = 0x00;
	*(esp_329 - 0x10) = 0x22;
	*(esp_329 - 0x14) = (HANDLE *) eax_188;
	globals->ptr4063F4 = eax_50();
	ptr32 esp_342 = esp_329 - 0x14;
	if (globals->ptr4063F4 == null)
	{
		*(esp_329 - 0x18) = ecx_168->dw0034;
		ptr32 esp_404 = esp_329 - 0x18;
		if (eax_22() == 0x00)
		{
			*(esp_329 - 0x1C) = 0x8000;
			*(esp_329 - 0x20) = 0x00;
			*(esp_329 - 0x24) = ecx_168->dw0034;
			esp_404 = esp_329 - 0x24;
			if (eax_43() == 0x00)
			{
				eax_359 = 0x00;
				return eax_359;
			}
		}
		word32 * esp_419 = esp_404 - 0x04;
		*esp_419 = ecx_168->dw0034;
		*(esp_419 - 0x04) = 0x00;
		*(esp_419 - 0x08) = 0x00;
		*(esp_419 - 0x0C) = 0x00;
		*(esp_419 - 0x10) = 0x22;
		*(esp_419 - 0x14) = (HANDLE *) eax_188;
		globals->ptr4063F4 = eax_50();
		esp_342 = esp_419 - 0x14;
		if (globals->ptr4063F4 == null)
		{
			*(esp_419 - 0x18) = 0x40;
			*(esp_419 - 0x1C) = 0x3000;
			*(esp_419 - 0x20) = ecx_168->dw0050;
			*(esp_419 - 0x24) = ecx_168->dw0034;
			globals->ptr4063F4 = eax_36();
			esp_342 = esp_419 - 0x24;
		}
	}
	HANDLE * esp_371 = esp_342 - 0x04;
	*esp_371 = (HANDLE *) eax_188;
	CloseHandle(*esp_371);
	*(esp_371 - 0x04) = ecx_168->dw0050;
	*(esp_371 - 0x08) = (struct Eq_280 **) eax_79;
	*(esp_371 - 0x0C) = (Eq_773 (**)[]) globals->ptr4063F4;
	fn00401040(dwArg00, dwArg04, dwArg08);
	*(esp_371 - 0x04) = (Eq_773 (**)[]) globals->ptr4063F4;
	fn00401850(dwArg00);
	Mem394[0x00406414:word32] = Mem388[0x004063F4:word32] + Mem388[ecx_168 + 0x28:word32];
	ecx_168->ptr0028 = globals->ptr406414;
	eax_359 = 0x01;
	return eax_359;
}

// 004016C0: Register Eq_674 fn004016C0(Stack Eq_3 dwArg04)
LPVOID fn004016C0(Eq_3 dwArg04)
{
	return VirtualAlloc(null, dwArg04, 0x3000, 0x04);
}

// 004016F0: Register word32 fn004016F0(Register word32 ebp, Stack Eq_3 dwArg04, Stack (ptr Eq_4) dwArg08)
word32 fn004016F0(word32 ebp, Eq_3 dwArg04, Eq_4 * dwArg08)
{
	struct Eq_685 * edx_16 = dwArg08 + dwArg08->dw003C / 0x0040;
	globals->ptr4063F4 = GetProcAddress(GetModuleHandleA(0x00406384), &globals->t406384)();
	if (globals->ptr4063F4 == null)
		return ebp;
	fn00401040(dwArg00, dwArg04, dwArg08);
	ui32 eax_90 = globals->ptr4063F4 - dwArg08;
	if (edx_16->dw00A4 != 0x00)
	{
		struct Eq_728 * dwLoc0C_116 = dwArg08 + edx_16->dw00A0 / 0x0040;
		while (dwLoc0C_116->t0004 != 0x00)
		{
			uint32 eax_131 = dwLoc0C_116->t0004 - 0x08 >> 0x01;
			word16 ecx_134[] = (char *) &dwLoc0C_116->t0004 + 0x04;
			uint32 dwLoc08_137 = 0x00;
			while (dwLoc08_137 < eax_131)
			{
				if ((word32) ecx_134[dwLoc08_137] >> 0x0C == 0x03)
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(globals->ptr4063F4 + dwLoc0C_116->dw0000)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000[(word32) ecx_134[dwLoc08_137] & 0x0FFF].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (Eq_773) ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(globals->ptr4063F4 + dwLoc0C_116->dw0000)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000[(word32) ecx_134[dwLoc08_137] & 0x0FFF].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000 + eax_90).a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000;
				dwLoc08_137 = dwLoc08_137 + 0x01;
			}
			dwLoc0C_116 = dwLoc0C_116 + Mem85[dwLoc0C_116 + 0x04:word32];
		}
	}
	word32 ecx_100 = dwArg04 + Mem85[0x004063F4:word32];
	word32 esp_102;
	word32 ebp_103;
	byte SCZO_104;
	word32 esi_105;
	word32 eax_106;
	word32 ecx_107;
	word32 edx_108;
	byte Z_109;
	byte C_110;
	byte SZO_111;
	ecx_100();
	return ebp_103;
}

// 00401850: void fn00401850(Stack Eq_2 dwArg04)
void fn00401850(HMODULE dwArg04)
{
	globals->ptr406410->ptr0030->t0008 = dwArg04;
}

// 00401880: void fn00401880(Stack Eq_3 dwArg04, Stack (ptr Eq_4) dwArg08, Stack Eq_139 dwArg0C)
void fn00401880(Eq_3 dwArg04, Eq_4 * dwArg08, Eq_139 dwArg0C)
{
	Eq_803 cl_12 = *dwArg04;
	lstrcpyA(fp - 0x94, 4219844);
	Eq_139 dwLoc0C_100 = 0x01;
	int32 dwLoc18_129 = 0x00;
	do
	{
		Eq_139 edx_41 = (word32) dwLoc0C_100 + 0x01;
		byte cl_38 = Mem0[dwArg04 + dwLoc0C_100:byte];
		dwLoc0C_100 = edx_41;
		if ((word32) cl_38 == (word32) cl_12)
		{
			if ((word32) Mem0[dwArg04 + edx_41:byte] == 0x00)
			{
				dwArg08[dwLoc18_129 / 0x0040] = (struct Eq_4) cl_12;
				dwLoc18_129 = dwLoc18_129 + 0x01;
				dwLoc0C_100 = (word32) edx_41.u0 + 0x01;
			}
			else
			{
				word32 eax_111 = fn004019B0(fp - 0x10, dwArg04 + edx_41) + edx_41;
				dwLoc0C_100 = fn004019B0(fp - 0x20, (word32) dwArg04 + eax_111) + eax_111;
				up32 dwLoc1C_126 = 0x00;
				while (dwLoc1C_126 < dwLoc10)
				{
					dwArg08[dwLoc18_129 / 0x0040] = dwArg08[(dwLoc18_129 - dwLoc20) / 0x0040];
					dwLoc18_129 = dwLoc18_129 + 0x01;
					dwLoc1C_126 = dwLoc1C_126 + 0x01;
				}
			}
		}
		else
		{
			dwArg08[dwLoc18_129 / 0x0040] = (struct Eq_4) cl_38;
			dwLoc18_129 = dwLoc18_129 + 0x01;
		}
	} while (dwLoc0C_100 < dwArg0C);
	lstrcpyA(fp - 0x94, 0x004063DC);
}

// 004019B0: Register word32 fn004019B0(Stack (ptr ui32) dwArg04, Stack (ptr byte) dwArg08)
word32 fn004019B0(ui32 * dwArg04, byte * dwArg08)
{
	lstrcpyA(fp - 0x84, 0x00406394);
	ui32 dwLoc08_18 = 0x00;
	word32 dwLoc10_19 = 0x00;
	do
	{
		ui32 edx_22 = (word32) *dwArg08;
		ui32 edx_32 = edx_22 & 0x7F | dwLoc08_18 << 0x07;
		word32 eax_35 = dwLoc10_19 + 0x01;
		dwArg08 = dwArg08 + 0x01;
		dwLoc08_18 = edx_32;
		dwLoc10_19 = eax_35;
	} while ((edx_22 & 0x80) != 0x00);
	lstrcpyA(fp - 0x84, 0x004063AC);
	*dwArg04 = edx_32;
	return eax_35;
}

