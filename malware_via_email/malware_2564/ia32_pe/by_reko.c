// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040100A: Register word32 fn0040100A(Register (ptr32 Eq_3) edi)
word32 fn0040100A(Eq_3 * edi)
{
	word32 ebp_4;
	real64 rArg0_5;
	fn0040100C(edi, rArg0, out ebp_4, out rArg0_5);
	return ebp_4;
}

// 0040100C: Register word32 fn0040100C(Register (ptr32 Eq_3) edi, FpuStack real64 rArg0, Register out ptr32 ebpOut, FpuStack out Eq_11 rArg0Out)
word32 fn0040100C(Eq_3 * edi, real64 rArg0, ptr32 & ebpOut, Eq_11 & rArg0Out)
{
	word32 eax_25;
	word32 ecx_26;
	word32 ebp_27;
	fn00401032(fp - 0x04, out eax_25, out ecx_26, out ebp_27);
	return eax_25;
}

// 00401028: FlagGroup bool fn00401028(Register (ptr32 Eq_22) ebp, Stack word32 dwArg00, Register out Eq_36 alOut, Register out ptr32 ecxOut, Register out ptr32 ebpOut)
bool fn00401028(Eq_22 * ebp, word32 dwArg00, Eq_36 & alOut, ptr32 & ecxOut, ptr32 & ebpOut)
{
	*alOut = al;
	*(ebp - 0x08) = *(ebp - 0x08) - *(ebp - 0x0C);
	word32 eax_11;
	word32 ecx_12;
	word32 ebp_13;
	return fn00401032(ebp, out eax_11, out ecx_12, out ebp_13);
}

// 00401032: FlagGroup bool fn00401032(Register (ptr32 Eq_22) ebp, Register out ptr32 eaxOut, Register out ptr32 ecxOut, Register out ptr32 ebpOut)
bool fn00401032(Eq_22 * ebp, ptr32 & eaxOut, ptr32 & ecxOut, ptr32 & ebpOut)
{
	*eaxOut = eax;
	up32 ecx_4 = *(ebp - 0x08);
	*ecxOut = ecx_4;
	bool C_102 = (bool) cond(ecx_4 - ebp->dw0010);
	if (ecx_4 < ebp->dw0010)
	{
		ui32 edx_55 = ~*(ebp - 0x0C);
		*(ebp - 0x14) = ~(ebp->ptr000C + *(ebp - 0x08));
		ui32 edx_59 = ~(edx_55 | *(ebp - 0x14));
		ui32 ecx_63 = ebp->ptr0014 + *(ebp - 0x04);
		*(ebp - 0x14) = 0xFF;
		ui32 ebx_66 = ecx_63 & *(ebp - 0x14);
		*(ebp - 0x14) = ~0x00;
		ui32 ebx_68 = ebx_66 ^ *(ebp - 0x14);
		word32 * ebx_75 = (ebx_68 + 0x01 & 0x00 ^ ebp->dw0008) + *(ebp - 0x08);
		*(ebp - 0x10) = ebx_75;
		word32 ebx_79 = DPB(*ebx_75, (byte) ((edx_59 & 0xFF) + (ebx_68 + 0x01)), 0);
		ui32 * edx_80 = *(ebp - 0x10);
		*(v3 - 0x04) = 0x00;
		*edx_80 = *(v3 - 0x04);
		*edx_80 = *edx_80 + -ebx_79;
		ui32 ecx_91 = *edx_80 ^ *(ebp - 0x14);
		*edx_80 = ecx_91 + 0x01;
		*(ebp - 0x04) = *(ebp - 0x04) + 0x01;
		word32 ecx_92;
		*ecxOut = ecx_91 + 0x01;
		if (*(ebp - 0x04) == 0x01)
			*(ebp - 0x04) = *(ebp - 0x04) & 0x00;
		C_102 = (bool) cond(*(ebp - 0x04) - 0x7500);
		if (*(ebp - 0x04) != 0x7500)
		{
			byte al_104;
			word32 ecx_105;
			word32 ebp_106;
			fn00401028(ebp, dwLoc04, out al_104, out ecx_105, out ebp_106);
			*ecx = (int32) rArg0;
			if (C)
			{
				word32 eax_112;
				return fn00401240(al_104, ebp_106, out eax_112);
			}
		}
	}
	word32 ebp_42;
	*ebpOut = ebp->dw0000;
	return C_102;
}

// 004010D0: Register Eq_15 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_51;
	word32 ebp_52;
	byte SCZO_53;
	word32 edi_54;
	word32 esi_55;
	byte SZO_56;
	bool C_57;
	word32 ebx_58;
	word32 edx_59;
	Eq_15 eax_60;
	bool Z_61;
	byte SCZDOP_62;
	word32 ecx_63;
	real64 rArg0_64;
	COMCTL32.dll!CreateToolbarEx();
	word32 esi_67 = 0x00 - fn00401217(eax_60);
	if ((esi_67 ^ ~0x057D) != 0x00)
	{
		word32 ebp_233;
		real64 rArg0_234;
		return fn0040100C((struct Eq_3 *) ~0x057D, rArg0_64, out ebp_233, out rArg0_234);
	}
	else
	{
		*(esp_51 - 0x04) = 0x00;
		struct Eq_3 * edi_112 = -~0x00428FFF;
		*(esp_51 - 0x04) = edi_112 ^ 0x00;
		*(esp_51 - 0x08) = ~~0x2F - ~0x00;
		*(esp_51 - 0x0C) = 0x00 - -0x0040AE8A + (esi_67 ^ ~0x057D);
		*(esp_51 - 0x10) = fp - 0x01AC;
		real64 rArg0_140;
		ptr32 ebp_139;
		fn0040100C(edi_112, rArg0_64, out ebp_139, out rArg0_140);
		Mem147[ebp_139 - 0x24 + 0x00:word32] = Mem138[Mem138[ebp_139 - 0x10 + 0x00:word32] + 0x04:word32] + Mem138[Mem138[(ebp_139 - 0x10) + 0x00:word32] + 0x00:word32];
		*(esp_51 - 0x10) = 0x40;
		*(ebp_139 - 0x18) = *(ebp_139 - 0x18) & 0x00;
		*(esp_51 - 0x14) = 0x3000;
		*(esp_51 - 0x18) = *(ebp_139 - 0x24);
		*(esp_51 - 0x1C) = 0x00;
		*(ebp_139 - 0x08) = (LPVOID *) VirtualAlloc(*(esp_51 - 0x1C), *(esp_51 - 0x18), *(esp_51 - 0x14), *(esp_51 - 0x10));
		*(ebp_139 - 0x20) = 0x00400000;
		*(ebp_139 - 0x01AC) = *(ebp_139 - 0x01AC) & 0x00;
		ptr32 esp_162 = esp_51 - 0x0C;
		while (true)
		{
			Eq_15 eax_176 = *((char *) *(ebp_139 - 0x10) + 0x08);
			if (*(ebp_139 - 0x01AC) >= eax_176)
				break;
			word32 * esp_180 = esp_162 - 0x04;
			*esp_180 = *(ebp_139 - 0x28);
			struct Eq_3 * edi_182 = *(ebp_139 - 0x1C);
			*(esp_180 - 0x04) = edi_182->dw0004;
			*(esp_180 - 0x08) = (char *) **(ebp_139 - 0x1C) + *(ebp_139 - 0x20);
			*(esp_180 - 0x0C) = *(ebp_139 - 0x08) + *(ebp_139 - 0x18);
			ebp_139 = fn0040100A(edi_182);
			*(ebp_139 - 0x18) = (char *) *((char *) *(ebp_139 - 0x1C) + 0x04) + *(ebp_139 - 0x18);
			esp_162 = esp_180 - 0x10;
			*(ebp_139 - 0x01AC) = *(ebp_139 - 0x01AC) + 0x01;
			*(ebp_139 - 0x1C) = *(ebp_139 - 0x1C) + 0x08;
		}
		word32 * esp_211 = esp_162 - 0x04;
		*esp_211 = *(ebp_139 - 0x20);
		*(ebp_139 - 0x14) = *(ebp_139 - 0x08) + 0x1370;
		*(esp_211 - 0x04) = *(ebp_139 - 0x019C);
		*(esp_211 - 0x08) = *(ebp_139 - 0x14);
		*(esp_211 - 0x0C) = 0x0AC0;
		*(esp_211 - 0x10) = *(ebp_139 - 0x14);
		return eax_176;
	}
}

// 00401217: Register Eq_15 fn00401217(Register Eq_15 eax)
DWORD fn00401217(DWORD eax)
{
	if (eax == 0x00)
		eax = GetLastError();
	return eax;
}

// 00401240: FlagGroup bool fn00401240(Register byte al, Register word32 ebp, Register out ptr32 eaxOut)
bool fn00401240(byte al, word32 ebp, ptr32 & eaxOut)
{
	word32 eax_8;
	*eaxOut = DPB(eax, al + 0x52, 0);
	bool C_10 = (bool) cond(al + 0x52);
	return C_10;
}

