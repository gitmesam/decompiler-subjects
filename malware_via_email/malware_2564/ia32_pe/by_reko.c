// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040100A: Register word32 fn0040100A(Register (ptr Eq_3) edi)
word32 fn0040100A(Eq_3 * edi)
{
	word32 ebp_4;
	real64 rArg0_5;
	fn0040100C(edi, rArg0, out ebp_4, out rArg0_5);
	return ebp_4;
}

// 0040100C: Register word32 fn0040100C(Register (ptr Eq_3) edi, FpuStack real64 rArg0, Register out ptr32 ebpOut, FpuStack out Eq_11 rArg0Out)
word32 fn0040100C(Eq_3 * edi, real64 rArg0, ptr32 & ebpOut, Eq_11 & rArg0Out)
{
	word32 eax_25;
	word32 ecx_26;
	word32 ebp_27;
	fn00401032(fp - 0x04, out eax_25, out ecx_26, out ebp_27);
	return eax_25;
}

// 00401028: FlagGroup bool fn00401028(Register (ptr Eq_22) ebp, Stack word32 dwArg00, Register out Eq_36 alOut, Register out ptr32 ecxOut, Register out ptr32 ebpOut)
bool fn00401028(Eq_22 * ebp, word32 dwArg00, Eq_36 & alOut, ptr32 & ecxOut, ptr32 & ebpOut)
{
	*alOut = al;
	*(ebp - 0x08) = *(ebp - 0x08) - *(ebp - 0x0C);
	word32 eax_11;
	word32 ecx_12;
	word32 ebp_13;
	return fn00401032(ebp, out eax_11, out ecx_12, out ebp_13);
}

// 00401032: FlagGroup bool fn00401032(Register (ptr Eq_22) ebp, Register out ptr32 eaxOut, Register out ptr32 ecxOut, Register out ptr32 ebpOut)
bool fn00401032(Eq_22 * ebp, ptr32 & eaxOut, ptr32 & ecxOut, ptr32 & ebpOut)
{
	*eaxOut = eax;
	up32 ecx_4 = *(ebp - 0x08);
	*ecxOut = ecx_4;
	bool C_102 = cond(ecx_4 - ebp->dw0010);
	if (ecx_4 < ebp->dw0010)
	{
		ui32 edx_55 = ~*(ebp - 0x0C);
		*(ebp - 0x14) = ~(ebp->ptr000C + *(ebp - 0x08));
		ui32 edx_59 = ~(edx_55 | *(ebp - 0x14));
		ui32 ecx_63 = ebp->ptr0014 + *(ebp - 0x04);
		*(ebp - 0x14) = 0xFF;
		ui32 ebx_66 = ecx_63 & *(ebp - 0x14);
		*(ebp - 0x14) = ~0x00;
		ui32 ebx_68 = ebx_66 ^ *(ebp - 0x14);
		word32 * ebx_75 = (ebx_68 + 0x01 & 0x00 ^ ebp->dw0008) + *(ebp - 0x08);
		*(ebp - 0x10) = ebx_75;
		word32 ebx_79 = DPB(*ebx_75, (byte) ((edx_59 & 0xFF) + (ebx_68 + 0x01)), 0);
		ui32 * edx_80 = *(ebp - 0x10);
		*(v3 - 0x04) = 0x00;
		*edx_80 = *(v3 - 0x04);
		*edx_80 = *edx_80 + -ebx_79;
		ui32 ecx_91 = *edx_80 ^ *(ebp - 0x14);
		*edx_80 = ecx_91 + 0x01;
		*(ebp - 0x04) = *(ebp - 0x04) + 0x01;
		word32 ecx_92;
		*ecxOut = ecx_91 + 0x01;
		if (*(ebp - 0x04) == 0x01)
			*(ebp - 0x04) = *(ebp - 0x04) & 0x00;
		C_102 = cond(*(ebp - 0x04) - 0x7500);
		if (*(ebp - 0x04) != 0x7500)
		{
			byte al_104;
			word32 ecx_105;
			word32 ebp_106;
			fn00401028(ebp, dwLoc04, out al_104, out ecx_105, out ebp_106);
			*ecx = (int32) rArg0;
			if (C)
			{
				word32 eax_112;
				return fn00401240(al_104, ebp_106, out eax_112);
			}
		}
	}
	word32 ebp_42;
	*ebpOut = ebp->dw0000;
	return C_102;
}

// 004010D0: Register Eq_15 Win32CrtStartup()
Eq_15 Win32CrtStartup()
{
	if ((0x00 - fn00401217(CreateToolbarEx(0x00, 0x00, 0x00, 0x00, null, 0x00, fp - 0x10, fp - 0x10, 0x00, 0x00, 0x00, 0x00, 0x00)) ^ ~0x057D) != 0x00)
	{
		word32 ebp_226;
		real64 rArg0_227;
		return fn0040100C((struct Eq_3 *) ~0x057D, rArg0, out ebp_226, out rArg0_227);
	}
	else
	{
		struct Eq_3 * edi_103 = -~0x00428FFF;
		real64 rArg0_132;
		ptr32 ebp_131;
		fn0040100C(edi_103, rArg0, out ebp_131, out rArg0_132);
		Mem140[ebp_131 - 0x24 + 0x00:word32] = Mem0[Mem0[ebp_131 - 0x10 + 0x00:word32] + 0x04:word32] + Mem0[Mem0[(ebp_131 - 0x10) + 0x00:word32] + 0x00:word32];
		*(fp - 0x0234) = 0x40;
		*(ebp_131 - 0x18) = *(ebp_131 - 0x18) & 0x00;
		*(fp - 0x0238) = 0x3000;
		*(fp - 0x023C) = *(ebp_131 - 0x24);
		*(fp - 0x0240) = 0x00;
		*(ebp_131 - 0x08) = (LPVOID *) VirtualAlloc(*(fp - 0x0240), *(fp - 0x023C), *(fp - 0x0238), *(fp - 0x0234));
		*(ebp_131 - 0x20) = 0x00400000;
		*(ebp_131 - 0x01AC) = *(ebp_131 - 0x01AC) & 0x00;
		ptr32 esp_152 = fp - 0x0240;
		while (true)
		{
			Eq_15 eax_169 = *((char *) *(ebp_131 - 0x10) + 0x08);
			if (*(ebp_131 - 0x01AC) >= eax_169)
				break;
			word32 * esp_173 = esp_152 - 0x04;
			*esp_173 = *(ebp_131 - 0x28);
			struct Eq_3 * edi_175 = *(ebp_131 - 0x1C);
			*(esp_173 - 0x04) = edi_175->dw0004;
			*(esp_173 - 0x08) = (char *) **(ebp_131 - 0x1C) + *(ebp_131 - 0x20);
			*(esp_173 - 0x0C) = *(ebp_131 - 0x08) + *(ebp_131 - 0x18);
			ebp_131 = fn0040100A(edi_175);
			*(ebp_131 - 0x18) = (char *) *((char *) *(ebp_131 - 0x1C) + 0x04) + *(ebp_131 - 0x18);
			esp_152 = esp_173 - 0x10;
			*(ebp_131 - 0x01AC) = *(ebp_131 - 0x01AC) + 0x01;
			*(ebp_131 - 0x1C) = *(ebp_131 - 0x1C) + 0x08;
		}
		word32 * esp_204 = esp_152 - 0x04;
		*esp_204 = *(ebp_131 - 0x20);
		*(ebp_131 - 0x14) = *(ebp_131 - 0x08) + 0x1370;
		*(esp_204 - 0x04) = *(ebp_131 - 0x019C);
		*(esp_204 - 0x08) = *(ebp_131 - 0x14);
		*(esp_204 - 0x0C) = 0x0AC0;
		*(esp_204 - 0x10) = *(ebp_131 - 0x14);
		return eax_169;
	}
}

// 00401217: Register Eq_15 fn00401217(Register Eq_15 eax)
Eq_15 fn00401217(Eq_15 eax)
{
	if (eax == 0x00)
		eax = GetLastError();
	return eax;
}

// 00401240: FlagGroup bool fn00401240(Register byte al, Register word32 ebp, Register out ptr32 eaxOut)
bool fn00401240(byte al, word32 ebp, ptr32 & eaxOut)
{
	word32 eax_8;
	*eaxOut = DPB(eax, al + 0x52, 0);
	bool SCZO_9 = cond(al + 0x52);
	return SCZO_9;
}

