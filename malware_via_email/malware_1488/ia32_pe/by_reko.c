// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: FlagGroup Eq_2 fn13101000(Register Eq_3 eax, Stack Eq_3 dwArg04, Stack Eq_5 dwArg08, Stack word32 dwArg0C, Stack (ptr word32) dwArg10, Stack Eq_8 dwArg14, Stack (arr Eq_219) dwArg18)
Eq_2 fn13101000(LPVOID eax, LPVOID dwArg04, LPVOID dwArg08, word32 dwArg0C, word32 * dwArg10, LPVOID dwArg14, Eq_219 dwArg18[])
{
	ui32 ebp_16 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_16 == 0x00);
	ui32 ebp_40 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_40 == 0x00);
	ui32 ebp_66 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_66 == 0x00);
	ui32 ebp_91 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_91 == 0x00);
	ui32 ebp_118 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_118 == 0x00);
	*dwArg10 = dwArg0C;
	ui32 ebp_142 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_142 == 0x00);
	ui32 ebp_167 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_167 == 0x00);
	ui32 ebp_196 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_196 == 0x00);
	ui32 ebp_221 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_221 == 0x00);
	uint64 edx_eax_229 = (uint64) (uint32) dwArg14;
	uint32 eax_239 = (uint32) (edx_eax_229 /u 0x05);
	word16 dx_238 = (word16) (uint32) (edx_eax_229 % 0x05);
	ui32 ebp_252 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_252 == 0x00);
	word16 wLoc0C_1048 = dx_238;
	ui32 ebp_276 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_276 == 0x00);
	ui32 ebp_303 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_303 == 0x00);
	word32 edx_317 = dwArg04 + dwArg14;
	ui32 ebp_331 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_331 == 0x00);
	byte * dwArg04_1187 = edx_317;
	ui32 ebp_355 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_355 == 0x00);
	while (true)
	{
		word32 ebp_401 = dwArg0C + 0x00038884;
		do
			;
		while ((ebp_401 ^ 0xF90A) == 0x00);
		ui32 ebp_428 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_428 == 0x00);
		word32 ecx_442 = dwArg0C - 0x01;
		ui32 ebp_456 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_456 == 0x00);
		dwArg0C = ecx_442;
		ui32 ebp_480 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_480 == 0x00);
		Eq_2 dwLoc14_500 = false;
		ui32 ebp_506 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_506 == 0x00);
		if (!dwLoc14_500)
			break;
		ui32 ebp_615 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_615 == 0x00);
		byte al_629 = *dwArg04_1187;
		word32 eax_630 = DPB(dwArg0C, al_629, 0);
		ui32 ebp_640 = eax_630 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_640 == 0x00);
		ui32 ebp_665 = eax_630 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_665 == 0x00);
		int32 ecx_679 = (int32) wLoc0C_1048;
		ui32 ebp_691 = eax_630 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_691 == 0x00);
		ui32 ebp_718 = eax_630 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_718 == 0x00);
		word32 eax_732 = (word32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg18[ecx_679].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
		ui32 ebp_742 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_742 == 0x00);
		int32 ecx_756 = (int32) al_629;
		ui32 ebp_768 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_768 == 0x00);
		byte cl_783 = (byte) (ecx_756 ^ eax_732);
		ui32 ebp_797 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_797 == 0x00);
		ui32 ebp_821 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_821 == 0x00);
		ui32 ebp_847 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_847 == 0x00);
		word32 eax_862 = DPB(eax_732, cl_783, 0);
		ui32 ebp_873 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_873 == 0x00);
		*dwArg08 = (Eq_5) cl_783;
		ui32 ebp_898 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_898 == 0x00);
		ui32 ebp_924 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_924 == 0x00);
		word16 cx_938 = wLoc0C_1048 + 0x01;
		ui32 ebp_952 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_952 == 0x00);
		wLoc0C_1048 = cx_938;
		ui32 ebp_976 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_976 == 0x00);
		int32 edx_990 = (int32) cx_938;
		ui32 ebp_1002 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_1002 == 0x00);
		ui32 ebp_1027 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_1027 == 0x00);
		word32 eax_1034 = eax_862;
		if (edx_990 == 0x05)
		{
			do
				;
			while (225678 == 0x00);
			wLoc0C_1048 = 0x00;
			do
				;
			while (225678 == 0x00);
			eax_1034 = 0x00;
		}
		word32 ebp_1066 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1066 ^ 0xF90A) == 0x00);
		Eq_5 ecx_1081 = (char *) dwArg08 + 0x01;
		word32 ebp_1094 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1094 ^ 0xF90A) == 0x00);
		dwArg08 = ecx_1081;
		word32 ebp_1118 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1118 ^ 0xF90A) == 0x00);
		word32 ebp_1144 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1144 ^ 0xF90A) == 0x00);
		byte * edx_1159 = dwArg04_1187 + 0x01;
		word32 ebp_1172 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1172 ^ 0xF90A) == 0x00);
		dwArg04_1187 = edx_1159;
		word32 ebp_1196 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1196 ^ 0xF90A) == 0x00);
	}
	do
		;
	while (225679 == 0x00);
	do
		;
	while (225679 == 0x00);
	do
		;
	while (225679 == 0x00);
	return dwLoc14_500;
}

// 1310156E: Register Eq_381 Win32CrtStartup()
DWORD Win32CrtStartup()
{
}

