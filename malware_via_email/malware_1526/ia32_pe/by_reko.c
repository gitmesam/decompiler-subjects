// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040108A: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
}

// 00401478: Register (ptr Eq_76) fn00401478(Stack (ptr Eq_76) dwArg04, Stack word32 dwArg08, Register out ptr32 ediOut)
Eq_76 * fn00401478(Eq_76 * dwArg04, word32 dwArg08, ptr32 & ediOut)
{
	int32 edx_11 = dwArg04[0x003C];
	__wait();
	__wait();
	word32 * edx_20 = dwArg04 + ((dwArg04 + 0x0078)[edx_11] - ~0x1B);
	int32 * edx_31 = dwArg04 + *(edx_20 - ~0x03);
	word32 edi_23[] = dwArg04 + *edx_20;
	word16 eax_35[] = dwArg04 + *(edx_20 - ~0x07);
	byte * eax_51 = dwArg04 + *edx_31;
	__wait();
	int32 * edi_43 = edx_31;
	ui32 dwLoc0C_48 = 0x00;
	ui32 edx_53 = 0x00;
	byte dl_54 = 0x00;
	while (true)
	{
		do
		{
			word32 edx_69 = __ror(DPB(edx_53, dl_54 + *eax_51, 0), 0x1D);
			__wait();
			eax_51 = eax_51 + 0x01;
			edx_53 = edx_69 ^ ~0x601073C0;
			dl_54 = (byte) (edx_69 ^ ~0x601073C0);
		} while (*eax_51 != 0x00);
		if ((edx_69 ^ ~0x601073C0 ^ dwArg08) == 0x00)
			break;
		__wait();
		edi_43 = edi_43 + 0x01;
		eax_51 = (byte *) (dwArg04 + *edi_43);
		__wait();
		dwLoc0C_48 = dwLoc0C_48 + 0x01;
		edx_53 = 0x00;
		dl_54 = 0x00;
	}
	word32 edi_114;
	*ediOut = dwArg04 + edi_23[(word32) eax_35[dwLoc0C_48]];
	return dwArg04;
}

