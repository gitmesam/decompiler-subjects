// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0040108A: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 edi_6 = __ror(~0x06F0, 0x04);
	ui32 edx_12 = __rol(0x055FF8B9, 0x04);
	struct Eq_36 ** ecx_28 = __ror(0x012FF000, 0x04) + (fp & __rol(0xE000001F, 0x03));
	word32 edx_30 = DPB(edx_12, (word16) edx_12 - 0x33, 0);
	struct Eq_36 * eax_33 = *ecx_28;
	ui32 ecx_289 = ecx_28 & ebx;
	do
	{
		eax_33 = eax_33 - 0x01;
		if (eax_33->dw0000 == edi_6)
		{
			byte dl_312 = (byte) __ror(1020, 0x02);
			while (eax_33[0x04] != dl_312)
				ecx_289 = ecx_289 - 0x01;
			goto l004010FB;
		}
		ecx_289 = ecx_289 + ebx;
	} while (eax_33->dw0000 != edx_30);
	ecx_289 = __rol(0x20000001, 0x07);
	byte cl_299 = (byte) ecx_289;
	do
		;
	while (*(eax_33 - 0x01) != cl_299);
l004010FB:
	word32 ecx_70 = __ror(ecx_289, 0x07);
	struct Eq_76 * edi_75 = dwArg00;
	do
		edi_75 = edi_75 + 0x01;
	while (edi_75->t0000 != __ror(0x30C0, 0x06));
	ptr32 esp_93;
	word32 edx_94;
	byte SZO_95;
	word32 edi_96;
	bool C_97;
	word32 esi_98;
	byte SCZO_99;
	word32 ecx_100;
	word32 ebx_101;
	word32 eax_102;
	word16 dx_103;
	bool Z_104;
	byte cl_105;
	word16 si_106;
	byte dl_107;
	word16 ax_108;
	word32 ebp_109;
	struct Eq_111 * fs_110;
	word16 di_111;
	struct Eq_113 * ds_112;
	edi_75();
	struct Eq_114 * edx_124 = fs_110->ptr0030->ptr000C;
	__ror(~0x09, 0x07);
	struct Eq_138 ** esi_132 = edx_124->ptr001C;
	__ror(0x1C, 11);
	word32 ecx_138 = *((char *) *esi_132 + 0x08);
	*(esp_93 - 0x04) = 0x4443BBD7;
	*(esp_93 - 0x08) = ecx_138;
	<anonymous> * edi_149;
	fn00401478(dwArg00, dwArg04, out edi_149);
	ui32 esi_154 = __rol(0x60000003, 0x05);
	ui32 eax_159 = __rol(0x36321736, 0x01);
	*(esp_93 - 0x04) = esi_154;
	*(esp_93 - 0x08) = eax_159;
	word32 eax_167 = __ror(eax_159, 0x0F);
	word32 edx_170 = __ror(0x6323A373, 0x03);
	*(esp_93 - 0x0C) = edx_170;
	*(esp_93 - 0x10) = esp_93 - 0x0C;
	struct Eq_202 * esp_179;
	word32 edx_180;
	byte SZO_181;
	word32 edi_182;
	bool C_183;
	word32 esi_184;
	byte SCZO_185;
	word32 ecx_186;
	word32 ebx_187;
	word32 eax_188;
	word16 dx_189;
	bool Z_190;
	byte cl_191;
	word16 si_192;
	byte dl_193;
	word16 ax_194;
	word32 ebp_195;
	struct Eq_219 * fs_196;
	word16 di_197;
	struct Eq_221 * ds_198;
	edi_149();
	*(esp_179 - ~0x07) = 3633639433;
	*(esp_179 - ~0x03) = eax_188;
	<anonymous> * edi_207;
	fn00401478(dwArg00, dwArg04, out edi_207);
	esp_179->ptr0008 = edi_207;
	<anonymous> * eax_212 = esp_179->ptr0008;
	esp_179->ptr0008 = null;
	esp_179->dw0004 = 0x00;
	esp_179->dw0000 = 0x00;
	*(esp_179 - 0x04) = 12646967;
	*(esp_179 - 0x08) = 1118437288;
	ptr32 esp_228 = esp_179 - 0x08;
	while (true)
	{
		word32 * esp_231 = esp_228 - 0x04;
		*esp_231 = 0x0C55;
		word32 esp_233;
		word32 edx_234;
		byte SZO_235;
		word32 edi_236;
		bool C_237;
		ui32 esi_238;
		byte SCZO_239;
		word32 ecx_240;
		word32 ebx_241;
		word32 eax_242;
		word16 dx_243;
		bool Z_244;
		byte cl_245;
		word16 si_246;
		byte dl_247;
		word16 ax_248;
		word32 ebp_249;
		struct Eq_293 * fs_250;
		word16 di_251;
		struct Eq_295 * ds_252;
		eax_212();
		<anonymous> * edi_263 = (<anonymous> **) 0x0008CD89;
		ui32 esi_266 = __rol(esi_238 << 0x0F, 0x12);
		word32 edx_270;
		byte SZO_271;
		word32 edi_272;
		bool C_273;
		word32 esi_274;
		byte SCZO_275;
		word32 ecx_276;
		word32 ebx_277;
		word32 eax_278;
		word16 dx_279;
		bool Z_280;
		byte cl_281;
		word16 si_282;
		byte dl_283;
		word16 ax_284;
		word32 ebp_285;
		struct Eq_321 * fs_286;
		word16 di_287;
		struct Eq_323 * ds_288;
		edi_263();
	}
}

// 00401478: Register (ptr32 Eq_76) fn00401478(Stack (ptr32 Eq_76) dwArg04, Stack word32 dwArg08, Register out ptr32 ediOut)
Eq_76 * fn00401478(Eq_76 * dwArg04, word32 dwArg08, ptr32 & ediOut)
{
	int32 edx_11 = dwArg04[0x003C];
	__wait();
	__wait();
	word32 * edx_20 = dwArg04 + ((dwArg04 + 0x0078)[edx_11] - ~0x1B);
	int32 * edx_31 = dwArg04 + *(edx_20 - ~0x03);
	word32 edi_23[] = dwArg04 + *edx_20;
	word16 eax_35[] = dwArg04 + *(edx_20 - ~0x07);
	byte * eax_51 = dwArg04 + *edx_31;
	__wait();
	int32 * edi_43 = edx_31;
	ui32 dwLoc0C_48 = 0x00;
	ui32 edx_53 = 0x00;
	byte dl_54 = 0x00;
	while (true)
	{
		do
		{
			word32 edx_69 = __ror(DPB(edx_53, dl_54 + *eax_51, 0), 0x1D);
			__wait();
			eax_51 = eax_51 + 0x01;
			edx_53 = edx_69 ^ ~0x601073C0;
			dl_54 = (byte) (edx_69 ^ ~0x601073C0);
		} while (*eax_51 != 0x00);
		if ((edx_69 ^ ~0x601073C0 ^ dwArg08) == 0x00)
			break;
		__wait();
		edi_43 = edi_43 + 0x01;
		eax_51 = (byte *) (dwArg04 + *edi_43);
		__wait();
		dwLoc0C_48 = dwLoc0C_48 + 0x01;
		edx_53 = 0x00;
		dl_54 = 0x00;
	}
	word32 edi_114;
	*ediOut = dwArg04 + edi_23[(word32) eax_35[dwLoc0C_48]];
	return dwArg04;
}

