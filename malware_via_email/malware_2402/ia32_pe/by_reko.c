// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00410328: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 esp_6;
	word32 edx_7;
	ptr32 ebp_8;
	word32 ecx_9;
	byte SCZO_10;
	byte SZO_11;
	bool C_12;
	bool Z_13;
	word32 eax_14;
	real64 rArg0_15;
	_p__iob();
	word32 ecx_20 = (word32) *(ebp_8 - 113) + dwLoc38;
	struct Eq_26 * esp_25;
	word32 edx_26;
	struct Eq_28 * ebp_27;
	word32 ecx_28;
	byte SCZO_29;
	byte SZO_30;
	bool C_31;
	bool Z_32;
	word32 eax_33;
	real64 rArg0_34;
	tell();
	ui32 ecx_46 = (word32) *(ebp_27 - 0x46);
	if (ecx_46 != esp_25->dw000C)
		(ecx_46 & 10908 ^ (word32) (*(esp_25 - 0x2F)) ^ ebp_27->dw0004) == esp_25->dw0008;
	*(esp_25 - 0x04) = 0x00;
	Eq_55 eax_56 = GetStdHandle(*(esp_25 - 0x04));
	word32 ecx_65 = (word32) *(ebp_27 - 118) + *(esp_25 - 0x7C);
	if (ecx_65 == 0x00)
		(word32) ebp_27->b0040 + *(ebp_27 - 0x80) == 0x00;
	ptr32 esp_70;
	word32 edx_71;
	struct Eq_98 * ebp_72;
	word32 ecx_73;
	byte SCZO_74;
	byte SZO_75;
	bool C_76;
	bool Z_77;
	word32 eax_78;
	real64 rArg0_79;
	_p__osver();
	*(esp_70 - 0x04) = (word32) ebp_72->b003A & 0x07;
	*(esp_70 - 0x08) = 0x0F;
	_rotr(*(esp_70 - 0x08), *(esp_70 - 0x04));
	if (false && (9943 != 0x00 && (*(ebp_72 - 0x10) & 0x353E) == 0x00))
		(~0x6016 & 0x0800) != *(ebp_72 - 772);
	if (((word32) *(ebp_72 - 22) ^ *(ebp_72 - 0x30)) == (word32) ebp_72->b0004 && (word32) (*(esp_70 - 0x56)) == 0x82)
		(word32) *(esp_70 - 0x5A) == 0x00;
	*(esp_70 - 0x04) = 0x1F;
	int32 eax_126 = _ftol(rArg0_79);
	ptr32 esp_134;
	word32 edx_135;
	ptr32 ebp_136;
	word32 ecx_137;
	byte SCZO_138;
	byte SZO_139;
	bool C_140;
	bool Z_141;
	word32 eax_142;
	real64 rArg0_143;
	_p__osver();
	(word32) *(esp_134 - 0x13) == 0x02D4;
	word32 edx_159 = (word32) *(esp_134 - 0x5B);
	if (edx_159 != 0x00 && (((word32) (*(esp_134 - 0x70)) ^ *(esp_134 - 0x28)) == 0x00 && (word32) (*(esp_134 - 0x30)) - *(ebp_136 - 0x44) != 0x00))
		((word32) *(ebp_136 - 88) ^ 0x02BD) != 0x0256;
	word32 esp_163;
	struct Eq_249 * ebp_165;
	word32 ecx_166;
	byte SCZO_167;
	byte SZO_168;
	bool C_169;
	bool Z_170;
	word32 eax_171;
	real64 rArg0_172;
	ui32 edx_164;
	tell();
	if (edx_164 != 0x024F)
		edx_164 = (word32) ebp_165->w0060 - ebp_165->dw0008 ^ *(ebp_165 - 0x6C);
	word32 edx_182 = edx_164 + 0x131E;
	struct Eq_319 * esp_187;
	word32 edx_188;
	struct Eq_321 * ebp_189;
	word32 ecx_190;
	byte SCZO_191;
	byte SZO_192;
	bool C_193;
	bool Z_194;
	word32 eax_195;
	real64 rArg0_196;
	_p__osver();
	*(esp_187 - 0x04) = 0x00;
	*(esp_187 - 0x08) = 0x15;
	_rotr(*(esp_187 - 0x08), *(esp_187 - 0x04));
	*(esp_187 - 0x04) = 0x00;
	GetDC(*(esp_187 - 0x04));
	GetCurrentProcess();
	(word32) ebp_189->t0004 == 0x026D;
	ui32 edx_235 = (word32) *(ebp_189 - 22);
	if ((ebp_189->dw0010 ^ 0x3ADC) == *(ebp_189 - 0x48))
		edx_235 = (word32) ebp_189->b004C & *(esp_187 - 0x38);
	Eq_2 eax_242 = GetLastError();
	(word32) *(esp_187 - 0x54) - edx_235 != 0x00;
	<anonymous> * eax_252 = (eax_242 & 0x00) + 4243328;
	word32 ecx_265 = (word32) ebp_189->w0008;
	(word32) *(ebp_189 - 0x59) == ecx_265;
	((word32) *(ebp_189 - 0x0E) & 10004) != esp_187->dw0008;
	Eq_373 edx_285 = ebp_189->t0004;
	if (edx_285 != (word32) (*(ebp_189 - 110)) + ebp_189->dw0010)
		edx_285 = edx_285 ^ *(ebp_189 - 0x68) ^ ebp_189->t0004;
	(word32) *(esp_187 - 0x7F) - *(ebp_189 - 0x40) - *(ebp_189 - 0x40) == 0x00;
	word32 edx_311 = (word32) ebp_189->w000F;
	ui32 ecx_315 = (word32) *(ebp_189 - 0x28) ^ edx_311 + 4349;
	bool Z_318 = (bool) cond(ecx_315 - (edx_311 + 4349));
	if (ecx_315 != edx_311 + 4349)
	{
		ui32 ecx_433 = ((word32) *(esp_187 - 0x04) ^ ebp_189->t0004) + *(ebp_189 - 88);
		Z_318 = (bool) cond(ecx_433);
	}
	word32 edx_325 = (word32) ebp_189->b007A;
	word32 ecx_326 = (word32) *(esp_187 - 0x32);
	if (!Z_318)
	{
		ecx_326 = (word32) ebp_189->w0034;
		edx_325 = (word32) ebp_189->w005D + ecx_326;
		if (*(ebp_189 - 0x0230) == edx_325)
		{
			ecx_326 = (word32) *(ebp_189 - 0x11);
			edx_325 = 0x2094;
			if (ecx_326 != 0x011C)
			{
				ecx_326 = *(ebp_189 - 0x44) + 0x0F87;
				edx_325 = *(ebp_189 - 0x14) + 0x2094;
			}
		}
	}
	ui32 ecx_331 = (ecx_326 ^ edx_325) - *(ebp_189 - 0x48);
	if (ecx_331 == (((word32) ebp_189->w0077 & 11134) & 1848))
		ecx_331 = (word32) *(ebp_189 - 111) + *(ebp_189 - 0x5C) & *(esp_187 - 0x54);
	*(ebp_189 - 0x60) != ecx_331 - ebp_189->t0004;
	if ((word32) *(esp_187 - 0x24) == 0x0111 && (word32) ebp_189->w0030 != (word32) ebp_189->b000D)
		(word32) *(ebp_189 - 115) != 919;
	word32 esp_355;
	word32 edx_356;
	word32 ebp_357;
	word32 ecx_358;
	byte SCZO_359;
	byte SZO_360;
	bool C_361;
	bool Z_362;
	Eq_2 eax_363;
	real64 rArg0_364;
	eax_252();
	return eax_363;
}

