// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00410328: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 esp_6;
	word32 edx_7;
	ptr32 ebp_8;
	word32 ecx_9;
	byte SCZO_10;
	byte SZO_11;
	byte C_12;
	byte Z_13;
	word32 eax_14;
	_p__iob();
	word32 ecx_19 = (word32) *(ebp_8 - 113) + dwLoc38;
	struct Eq_25 * esp_24;
	word32 edx_25;
	struct Eq_27 * ebp_26;
	word32 ecx_27;
	byte SCZO_28;
	byte SZO_29;
	byte C_30;
	byte Z_31;
	word32 eax_32;
	tell();
	ui32 ecx_44 = (word32) *(ebp_26 - 0x46);
	*(esp_24 - 0x04) = 0x00;
	Eq_53 eax_54 = GetStdHandle(*(esp_24 - 0x04));
	word32 ecx_62 = (word32) *(ebp_26 - 118) + *(esp_24 - 0x80);
	ptr32 esp_67;
	word32 edx_68;
	struct Eq_96 * ebp_69;
	word32 ecx_70;
	byte SCZO_71;
	byte SZO_72;
	byte C_73;
	byte Z_74;
	word32 eax_75;
	_p__osver();
	*(esp_67 - 0x04) = (word32) ebp_69->b003A & 0x07;
	*(esp_67 - 0x08) = 0x0F;
	uint32 eax_85 = _rotr(*(esp_67 - 0x08), *(esp_67 - 0x04));
	ui32 edx_113 = (word32) *(ebp_69 - 22) ^ *(ebp_69 - 0x30);
	ui32 ecx_114 = (word32) ebp_69->b0004;
	*(esp_67 - 0x04) = 0x1F;
	word32 esp_119;
	word32 edx_120;
	word32 ebp_121;
	word32 ecx_122;
	byte SCZO_123;
	byte SZO_124;
	byte C_125;
	byte Z_126;
	word32 eax_127;
	ftol();
	ptr32 esp_135;
	word32 edx_136;
	ptr32 ebp_137;
	word32 ecx_138;
	byte SCZO_139;
	byte SZO_140;
	byte C_141;
	byte Z_142;
	word32 eax_143;
	_p__osver();
	word32 edx_159 = (word32) *(esp_135 - 0x5B);
	word32 esp_163;
	struct Eq_254 * ebp_165;
	word32 ecx_166;
	byte SCZO_167;
	byte SZO_168;
	byte C_169;
	byte Z_170;
	word32 eax_171;
	ui32 edx_164;
	tell();
	if (edx_164 != 0x024F)
		edx_164 = (word32) ebp_165->w0060 - ebp_165->dw0008 ^ *(ebp_165 - 0x6C);
	word32 edx_181 = edx_164 + 0x131E;
	struct Eq_323 * esp_186;
	word32 edx_187;
	struct Eq_325 * ebp_188;
	word32 ecx_189;
	byte SCZO_190;
	byte SZO_191;
	byte C_192;
	byte Z_193;
	word32 eax_194;
	_p__osver();
	*(esp_186 - 0x04) = 0x00;
	*(esp_186 - 0x08) = 0x15;
	_rotr(*(esp_186 - 0x08), *(esp_186 - 0x04));
	*(esp_186 - 0x04) = 0x00;
	GetDC(*(esp_186 - 0x04));
	GetCurrentProcess();
	ui32 edx_232 = (word32) *(ebp_188 - 22);
	if ((ebp_188->dw0010 ^ 0x3ADC) == *(ebp_188 - 0x48))
		edx_232 = (word32) ebp_188->b004C & *(esp_186 - 0x3C);
	Eq_2 eax_239 = GetLastError();
	<anonymous> * eax_249 = (eax_239 & 0x00) + 4243328;
	word32 ecx_262 = (word32) ebp_188->w0008;
	Eq_376 edx_282 = ebp_188->t0004;
	if (edx_282 != (word32) (*(ebp_188 - 110)) + ebp_188->dw0010)
		edx_282 = edx_282 ^ *(ebp_188 - 0x68) ^ ebp_188->t0004;
	word32 edx_308 = (word32) ebp_188->w000F;
	ui32 ecx_312 = (word32) *(ebp_188 - 0x28) ^ edx_308 + 4349;
	bool Z_315 = cond(ecx_312 - (edx_308 + 4349));
	if (ecx_312 != edx_308 + 4349)
	{
		ui32 ecx_429 = ((word32) *(esp_186 - 0x08) ^ ebp_188->t0004) + *(ebp_188 - 88);
		Z_315 = cond(ecx_429);
	}
	word32 edx_322 = (word32) ebp_188->b007A;
	word32 ecx_323 = (word32) *(esp_186 - 0x36);
	if (!Z_315)
	{
		ecx_323 = (word32) ebp_188->w0034;
		edx_322 = (word32) ebp_188->w005D + ecx_323;
		if (*(ebp_188 - 0x0230) == edx_322)
		{
			ecx_323 = (word32) *(ebp_188 - 0x11);
			edx_322 = 0x2094;
			if (ecx_323 != 0x011C)
			{
				ecx_323 = *(ebp_188 - 0x44) + 0x0F87;
				edx_322 = *(ebp_188 - 0x14) + 0x2094;
			}
		}
	}
	ui32 ecx_328 = (ecx_323 ^ edx_322) - *(ebp_188 - 0x48);
	if (ecx_328 == (((word32) ebp_188->w0077 & 11134) & 1848))
		ecx_328 = (word32) *(ebp_188 - 111) + *(ebp_188 - 0x5C) & *(esp_186 - 88);
	word32 esp_352;
	word32 edx_353;
	word32 ebp_354;
	word32 ecx_355;
	byte SCZO_356;
	byte SZO_357;
	byte C_358;
	byte Z_359;
	word32 eax_360;
	eax_249();
	return eax_360;
}

