// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_3 * esp_23;
	byte SCZO_24;
	word32 esi_26;
	byte SZO_28;
	bool C_29;
	word32 edx_30;
	Eq_2 eax_31;
	bool Z_32;
	word32 ecx_33;
	byte dl_34;
	word32 ebp_35;
	byte CZ_36;
	bool S_37;
	byte cl_38;
	byte ch_39;
	Eq_18 ebx_25;
	Eq_18 edi_101;
	SHLWAPI.dll!StrStrIA();
	if (eax_31 != 0x00)
		return eax_31;
	*(esp_23 - 0x04) = (uint32) eax_31;
	*(esp_23 - 0x08) = (uint32) eax_31;
	Eq_2 eax_56 = AddUsersToEncryptedFile(*(esp_23 - 0x08), *(esp_23 - 0x04));
	if (eax_56 == 0x00)
		return eax_56;
	*(esp_23 - 0x04) = ~0x00;
	*(esp_23 - 0x08) = ~0x00;
	Eq_63 eax_65 = AreAllAccessesGranted(*(esp_23 - 0x08), *(esp_23 - 0x04));
	if (eax_65 == 0x00)
		ebx_25 = eax_65 + 0x2E;
	*(esp_23 - 0x04) = (char *) &esp_23->t000C + 0x04;
	*(esp_23 - 0x08) = 0x40;
	*(esp_23 - 0x0C) = 0x3000;
	*(esp_23 - 0x10) = 0x00401000;
	VirtualProtect(*(esp_23 - 0x10), *(esp_23 - 0x0C), *(esp_23 - 0x08), *(esp_23 - 0x04));
	esp_23->t000C = esp_23->t000C - 0x01;
	struct Eq_139 * ecx_109 = null;
	do
	{
		if (edi_101 == ebx_25)
			edi_101 = null;
		ecx_109[4199896] = (struct Eq_139) (edi_101[0x00404000] ^ ecx_109[4199896] ^ 0xA0);
		ecx_109 = ecx_109 + 0x01;
		edi_101 = (Eq_18) (edi_101 + 0x01);
	} while (ecx_109 < (struct Eq_139 *) 0x1440);
	*(esp_23 - 0x04) = ebp_35;
	esp_23->t000C = (word32) esp_23->t000C + 0x01;
	esp_23->ptr001C = &globals->dw401358;
	&esp_23->t0014.u0->w0000 = 0x00;
	struct Eq_184 * edx_119 = &globals->t4028D8;
	word32 * edi_125 = &globals->dw401358;
	Eq_133 ebp_126 = 0x00;
	word32 * esi_130 = (word32 *) 0xF0401358;
	if (esp_23->t000C > 0x00)
	{
		do
		{
			Eq_205 eax_270 = edx_119->t0004 - 0x08 >> 0x01;
			word16 * ecx_273 = (char *) &edx_119->t0004 + 0x04;
			if (eax_270 > 0x00)
			{
				Eq_205 ebx_290 = eax_270;
				do
				{
					ui32 eax_295 = (word32) *ecx_273;
					if ((eax_295 & 0xF000) == 0x3000)
					{
						struct Eq_240 * eax_309 = (eax_295 & 0x0FFF) + edx_119->dw0000;
						eax_309->dw401358 = eax_309->dw401358 + 0xF0401358;
					}
					ecx_273 = ecx_273 + 0x01;
					ebx_290 = ebx_290 - 0x01;
				} while (ebx_290 != 0x00);
				ebp_126 = esp_23->t0014;
			}
			ebp_126 = ebp_126 + Mem131[edx_119 + 0x04:word32];
			esp_23->t0014 = ebp_126;
			edx_119 = edx_119 + Mem284[edx_119 + 0x04:word32];
		} while (ebp_126 < esp_23->t000C);
	}
	&esp_23->t0014.u0->w0000 = 0x004020C4;
	if (globals->dw4020D4 != 0x00)
	{
		Eq_133 ebx_164 = 0x004020C4;
		do
		{
			Mem176[esp_23 - 0x08 + 0x00:word32] = Mem142[ebx_164 + 0x0C:word32] + edi_125;
			Eq_335 eax_177 = LoadLibraryA(*(esp_23 - 0x08));
			esp_23->t0018 = eax_177;
			Eq_335 ecx_179 = eax_177;
			esi_130 = (word32) ebx_164 + esi_130 * 0x08;
			if (eax_177 != null)
			{
				ptr32 ebp_204 = *ebx_164;
				if (ebp_204 == 0x00)
					ebp_204 = (ptr32) *((word32) ebx_164 + 0x0010);
				Eq_299 eax_210 = edi_125[ebp_204];
				ebp_126 = edi_125 + ebp_204;
				esi_130 = Mem182[ebx_164 + 0x10:word32] + edi_125;
				if (eax_210 != 0x00)
				{
					while (true)
					{
						Eq_323 eax_232;
						if (eax_210 < 0x00)
						{
							*(esp_23 - 0x08) = (word32) *ebp_126;
							*(esp_23 - 0x0C) = (HMODULE *) ecx_179;
							eax_232 = GetProcAddress(*(esp_23 - 0x0C), *(esp_23 - 0x08));
							edi_125 = esp_23->ptr001C;
						}
						else
						{
							*(esp_23 - 0x08) = edi_125 + ((word32) eax_210 + 0x02);
							*(esp_23 - 0x0C) = (HMODULE *) ecx_179;
							eax_232 = GetProcAddress(*(esp_23 - 0x0C), *(esp_23 - 0x08));
						}
						*esi_130 = (word32) eax_232;
						ebp_126 = (word32) ebp_126 + 0x04;
						eax_210 = *ebp_126;
						esi_130 = esi_130 + 0x04;
						if (eax_210 == 0x00)
							break;
						ecx_179 = esp_23->t0018;
					}
					ebx_164 = esp_23->t0014;
				}
			}
			ebx_164 = (word32) ebx_164 + 0x0014;
			esp_23->t0014 = ebx_164;
		} while (*((word32) ebx_164 + 0x0010) != 0x00);
	}
	fn00401DB8(0xB8, 0x1D, ebp_126, esi_130, edi_125, psegArg5B9F);
	*(esp_23 - 0x08) = 0x00;
	ExitProcess(*(esp_23 - 0x08));
}

// 00401DB8: void fn00401DB8(Register byte cl, Register byte ch, Register Eq_133 ebp, Register (ptr32 word32) esi, Register (ptr32 word32) edi, Stack (ptr16 Eq_262) psegArg5BA3)
void fn00401DB8(byte cl, byte ch, Eq_133 ebp, word32 * esi, word32 * edi, Eq_262 * psegArg5BA3)
{
	word32 eax_31 = *esi;
	cu8 al_32 = (byte) eax_31;
	struct Eq_432 * esi_40 = (word32) *((word32) ebp - 348888786) + (esi - 0x04);
	Mem49[esi_40 - 0x38 + 0x00:byte] = Mem0[esi_40 - 0x38 + 0x00:byte] + cl + (al_32 <u 212);
	cu8 ah_33 = SLICE(eax_31, byte, 8);
	struct Eq_455 * ecx_39 = DPB(ecx, -ch, 8);
	cu8 al_56 = (bool) (bool) ah_33 + ((al_32 - 212) + ah_33);
	if (!OVERFLOW(al_56))
	{
		__syscall(232);
		*edi = esi_40->dw0000;
		cu8 v26_83 = ecx_39->b0000 - 0x19 - (al_56 < 0x00);
		ecx_39->b0000 = v26_83;
		ptr32 ebp_103 = fp - 0x2A;
		ptr32 esp_123 = fp - ~0x5BA2;
		if (v26_83 != 0x00)
		{
			word32 eax_115 = DPB(eax_31, esi_40->b0004, 0) - 2762353262 - (v26_83 < 0x00);
			ebp_103 = fp - 0x2A - (eax_115 + 0x00) - (eax_115 < 0x00);
			esp_123 = fp - ~0x5BA4;
		}
		(ui32 *) ~0x2646789B = (ui32 *) ~0x2646789B << 0x01;
		__wait();
		*(esp_123 - 0x04) = ebp_103;
	}
	else
		ecx_39->dw6BDDB24B = ecx_39->dw6BDDB24B - (ebp - 0x01) - (al_56 < 0x00);
}

