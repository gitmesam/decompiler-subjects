// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register DWORD Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 edx_16;
	word32 ebp_17;
	word32 eax_18 = fn00401078(out edx_16, out ebp_17);
	Mem25[fp - 0x18 + 0x00:word32] = Mem0[0x00404400:word32];
	Mem27[fp - 0x1C + 0x00:word32] = 0x00402000;
	fn00401133(eax_18, edx_16, ebx, ebp_17, edi, SLICE(ebp, selector, 16));
	Mem37[fp - 0x12 + 0x00:word32] = 0x062E;
	Mem39[fp - 22 + 0x00:word32] = 0x00401133;
	word32 edx_40;
	word32 ebp_41;
	fn00401078(out edx_40, out ebp_41);
	if (false)
	{
		Mem54[fp - 0x12 + 0x00:word32] = 0x00405000;
		Mem56[fp - 22 + 0x00:word32] = 0x00401000;
		lstrcpyA(Mem56[fp - 22 + 0x00:LPSTR], Mem56[fp - 0x12 + 0x00:LPCSTR]);
	}
	return 0x00;
}

// 00401078: Register word32 fn00401078(Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn00401078(ptr32 & edxOut, ptr32 & ebpOut)
{
	word32 edx_9;
	word32 ebp_10;
	return fn00401127(fp - 0x04, out edx_9, out ebp_10);
}

// 004010F1: Register word32 fn004010F1(Register word32 ebp, Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn004010F1(word32 ebp, ptr32 & edxOut, ptr32 & ebpOut)
{
}

// 0040110D: Register word32 fn0040110D(Register word32 eax, Register word32 ebp, Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn0040110D(word32 eax, word32 ebp, ptr32 & edxOut, ptr32 & ebpOut)
{
	ptr32 fp;
	word32 ebp;
	<type-error> Mem0;
	word32 eax;
	ptr32 edxOut;
	ptr32 ebpOut;
	esp_1 = fp;
	v4_4 = Mem0[ebp + 0x17:byte] << 0x8B;
	Mem5[ebp + 0x17:byte] = v4_4;
	SCZO_6 = cond(v4_4);
	eax_10 = fn00401111(eax, ebp, out edx_8, out ebp_9);
	return eax_10;
}

// 00401111: Register word32 fn00401111(Register word32 eax, Register word32 ebp, Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn00401111(word32 eax, word32 ebp, ptr32 & edxOut, ptr32 & ebpOut)
{
	ptr32 fp;
	word32 ebp;
	<type-error> Mem0;
	word32 eax;
	ptr32 edxOut;
	ptr32 ebpOut;
	esp_1 = fp;
	ebp_3 = ebp + 0x01;
	D_4 = false;
	ecx_6 = Mem0[ebp_3 + 0x08:word32];
	ecx_8 = ecx_6 + eax;
	eax_9 = Mem0[ebp_3 - 0x04 + 0x00:word32];
	eax_10 = eax_9 + Mem0[ebp_3 + 0x08:word32];
	edx_11 = Mem0[ebp_3 - 0x04 + 0x00:word32];
	dl_12 = (byte) edx_11;
	al_13 = Mem0[eax_10 + 0x00:byte];
	al_14 = al_13 - dl_12;
	SCZO_15 = cond(al_14);
	Mem16[ecx_8 + 0x00:byte] = al_14;
	eax_19 = fn00401127(ebp_3, out edx_17, out ebp_18);
	al_20 = (byte) eax_19;
	return eax_19;
}

// 00401127: Register word32 fn00401127(Register word32 ebp, Register out ptr32 edxOut, Register out ptr32 ebpOut)
word32 fn00401127(word32 ebp, ptr32 & edxOut, ptr32 & ebpOut)
{
	esp = v3;
	eax = ebp - 0x04;
	edx_eax = SEQ(edx, eax);
	v6 = Mem0[eax + 0x00:word32] + 0x01;
	Mem0[eax + 0x00:word32] = v6;
	SZO = cond(v6);
	eax = Mem0[ebp - 0x04 + 0x00:word32];
	edx_eax = SEQ(edx, eax);
	al = (byte) eax;
	SCZO = cond(eax - Mem0[ebp + 0x0C:word32]);
	SO = SCZO;
	if (Test(GE,SO))
	{
		esp = ebp;
		ebp = Mem0[esp + 0x00:word32];
		esp = esp + 0x04;
		return eax;
	}
	else
	{
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x01);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			ecx = Mem0[ebp + 0x08:word32];
			ecx = ecx + eax;
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			edx = Mem0[ebp + 0x08:word32];
			edx = edx + eax;
			al = ~0x00;
			al = ~0x00 ^ Mem0[edx + 0x00:byte];
			SZO = cond(al);
			C = false;
			Mem0[ecx + 0x00:byte] = al;
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x01);
		SZO = SCZO;
		if (Test(GT,SZO))
		{
			eax = Mem0[ebp - 0x04 + 0x00:word32];
			eax = eax - 0x01;
			eax = eax & 0x03;
			SZO = cond(eax & eax);
			Z = (bool) SZO;
			C = false;
			if (Test(EQ,Z))
			{
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				edx = Mem0[ebp + 0x08:word32];
				edx = edx + eax;
				eax = Mem0[ebp - 0x04 + 0x00:word32];
				eax = eax + Mem0[ebp + 0x08:word32];
				al = Mem0[eax + 0x00:byte];
				eax = DPB(eax, al, 0);
				eax = eax + 0x07;
				al = (byte) eax;
				SCZO = cond(eax);
				Mem0[edx + 0x00:byte] = al;
			}
		}
		SCZO = cond(Mem0[ebp - 0x04 + 0x00:word32] - 0x03);
		SZO = SCZO;
		if (Test(LE,SZO))
		{
			eax = fn004010F1(ebp, out edx, out ebp);
			edx_eax = SEQ(edx, eax);
			al = (byte) eax;
			return eax;
		}
		else
		{
			edx = Mem0[ebp - 0x04 + 0x00:word32];
			edx = edx - 0x03;
			eax = 0x03;
			ecx = 0x03;
			eax = edx;
			edx = edx >> 0x1F;
			edx_eax = SEQ(edx, eax);
			v16 = edx_eax;
			edx = (int32) (v16 % 0x03);
			eax = (int32) (v16 / 0x03);
			SZO = cond(edx & edx);
			Z = (bool) SZO;
			C = false;
			if (Test(NE,Z))
			{
				eax = fn004010F1(ebp, out edx, out ebp);
				edx_eax = SEQ(edx, eax);
				al = (byte) eax;
				return eax;
			}
			else
			{
				eax = fn004010F1(ebp, out edx, out ebp);
				edx_eax = SEQ(edx, eax);
				al = (byte) eax;
				return eax;
			}
		}
	}
}

// 00401133: void fn00401133(Register word32 eax, Register word32 edx, Register word32 ebx, Register word32 ebp, Register word32 edi, Stack selector psegArg02)
void fn00401133(word32 eax, word32 edx, word32 ebx, word32 ebp, word32 edi, selector psegArg02)
{
	Mem6[eax + 0x00:word32] = ebx;
	if (SZO)
	{
		if (!P)
			return;
		word32 edx_81;
		word32 ebp_82;
		fn0040110D(edx - 0x51E000A7, ebp, out edx_81, out ebp_82);
	}
	else if (SZO)
	{
		word32 edx_47;
		word32 ebp_48;
		fn004010F1(ebp, out edx_47, out ebp_48);
	}
	else
	{
		if (edi < 0x01)
			return;
		__inb(DPB(dx, 0x87, 8));
	}
}

