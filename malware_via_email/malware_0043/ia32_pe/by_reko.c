// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_3 * edx_15;
	word32 eax_16 = fn00401078(globals->a401134, (Eq_105 (*)[]) 0x062E, out edx_15);
	fn00401134(eax_16, edx_15);
	word32 edx_35;
	fn00401078(globals->a401134, (Eq_105 (*)[]) 0x062E, out edx_35);
	if (false)
	{
		*(fp - 0x18) = 0x00405000;
		*(fp - 0x1C) = 0x00401000;
		lstrcpyA(*(fp - 0x1C), *(fp - 0x18));
	}
	return 0x00;
}

// 00401078: Register (ptr32 (arr Eq_105)) fn00401078(Stack (ptr32 (arr Eq_105)) dwArg04, Stack (ptr32 (arr Eq_105)) dwArg08, Register out ptr32 edxOut)
Eq_105 * fn00401078[](Eq_105 * dwArg04[], Eq_105 * dwArg08[], ptr32 & edxOut)
{
	*edxOut = edx;
	Eq_105 (* dwLoc08_20)[] = null;
	while (dwLoc08_20 < dwArg08)
	{
		if (dwLoc08_20 > (Eq_105 (*)[]) 0x01)
		{
			word32 eax_120 = dwLoc08_20 + dwArg04;
			Mem127[dwArg04 + dwLoc08_20:byte] = (byte) (DPB(eax_120, *eax_120, 0) ^ 0x67);
		}
		if (dwLoc08_20 > (Eq_105 (*)[]) 0x01 && (dwLoc08_20 - 0x01 & 0x03) == 0x00)
			Mem115[dwArg04 + dwLoc08_20:byte] = Mem0[dwArg04 + dwLoc08_20:byte] + ~0x02;
		if (dwLoc08_20 > (Eq_105 (*)[]) 0x02 && (dwLoc08_20 - (Eq_105 (*)[]) 0x02 & 0x01) == 0x00)
			Mem99[dwArg04 + dwLoc08_20:byte] = Mem0[dwLoc08_20 + dwArg04:byte] - ~0x22;
		int32 edx_53 = (int32) (SEQ(dwLoc08_20 >> 0x1F, dwLoc08_20) % 0x03);
		*edxOut = edx_53;
		if (edx_53 == 0x00)
		{
			Mem83[dwArg04 + dwLoc08_20:byte] = Mem0[dwLoc08_20 + dwArg04:byte] - (byte) dwLoc08_20;
			word32 edx_76;
			*edxOut = dwLoc08_20;
		}
		dwLoc08_20 = dwLoc08_20 + 0x01;
	}
	return dwLoc08_20;
}

// 00401134: void fn00401134(Register word32 eax, Register (ptr32 Eq_3) edx)
void fn00401134(word32 eax, Eq_3 * edx)
{
	edx->dw8EECAEE3 = eax;
	*(DPB(__indw(133), FPUF, 8) - 0x78) = fp - 0x04;
}

