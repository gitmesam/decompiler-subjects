// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: FlagGroup byte fn00401000(Register ptr32 ecx, Stack word32 dwArg04, Stack (ptr32 byte) dwArg08, Stack word32 dwArg0C, Stack (ptr32 word32) dwArg10, Stack word32 dwArg14, Stack (arr Eq_123) dwArg18)
byte fn00401000(ptr32 ecx, word32 dwArg04, byte * dwArg08, word32 dwArg0C, word32 * dwArg10, word32 dwArg14, Eq_123 dwArg18[])
{
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	*dwArg10 = dwArg0C;
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	uint64 edx_eax_223 = (uint64) (uint32) dwArg14;
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	word16 dx_287 = (word16) (uint32) (edx_eax_223 % 0x05);
	do
		;
	while (~0x00C0050F == 0x00);
	word16 wLoc0C_1146 = dx_287;
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	byte * edx_381 = dwArg04 + dwArg14;
	do
		;
	while (~0x00C0050F == 0x00);
	byte * dwArg04_1404 = edx_381;
	do
		;
	while (~0x00C0050F == 0x00);
	while (true)
	{
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		word32 ecx_526 = dwArg0C - 0x01;
		byte SCZO_527 = cond(ecx_526);
		do
			;
		while (~0x00C0050F == 0x00);
		dwArg0C = ecx_526;
		do
			;
		while (~0x00C0050F == 0x00);
		byte SCZDOP_588 = DPB(SCZO_527, false, 0);
		do
			;
		while (~0x00C0050F == 0x00);
		if (true)
			break;
		do
			;
		while (~0x00C0050F == 0x00);
		byte al_745 = *dwArg04_1404;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		int32 ecx_806 = (int32) wLoc0C_1146;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		word32 eax_867 = (word32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg18[ecx_806].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
		do
			;
		while (~0x00C0050F == 0x00);
		int32 ecx_899 = (int32) al_745;
		do
			;
		while (~0x00C0050F == 0x00);
		ui32 ecx_928 = ecx_899 ^ eax_867;
		do
			;
		while (~0x00C0050F == 0x00);
		byte cl_954 = (byte) ecx_928;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		*dwArg08 = cl_954;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		word16 cx_1113 = wLoc0C_1146 + 0x01;
		do
			;
		while (~0x00C0050F == 0x00);
		wLoc0C_1146 = cx_1113;
		do
			;
		while (~0x00C0050F == 0x00);
		int32 edx_1175 = (int32) cx_1113;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		if (edx_1175 == 0x05)
		{
			do
				;
			while (~0x00C0050F == 0x00);
			wLoc0C_1146 = 0x00;
			do
				;
			while (~0x00C0050F == 0x00);
		}
		do
			;
		while (~0x00C0050F == 0x00);
		byte * ecx_1280 = dwArg08 + 0x01;
		do
			;
		while (~0x00C0050F == 0x00);
		dwArg08 = ecx_1280;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		byte * edx_1371 = dwArg04_1404 + 0x01;
		do
			;
		while (~0x00C0050F == 0x00);
		dwArg04_1404 = edx_1371;
		do
			;
		while (~0x00C0050F == 0x00);
	}
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	return SCZDOP_588;
}

// 00401659: Register Eq_208 Win32CrtStartup()
Eq_208 Win32CrtStartup()
{
	Eq_209 eax_19 = CreateStdDispatch(null, null, null, null);
	ptr32 esp_20 = fp - 0x0270;
	if (eax_19 != (struct <anonymous> *) 0x80070057)
	{
		word32 ebp_492;
		byte SCZO_493;
		word32 eax_494;
		bool Z_495;
		word32 ecx_496;
		word32 edx_497;
		byte SCZDOP_498;
		byte SZO_500;
		bool C_501;
		byte dl_502;
		byte DP_503;
		eax_19->ptr0000();
	}
	word32 ecx_46 = globals->dw402254;
	union Eq_208 * esp_49 = esp_20 - 0x04;
	*esp_49 = (union Eq_208 *) (fp - 0x0234);
	*(esp_49 - 0x04) = 0x00;
	*(esp_49 - 0x08) = fp - 0x04;
	*(esp_49 - 0x0C) = (union Eq_251 *) cond(fp);
	*(esp_49 - 0x10) = ecx_46;
	do
		;
	while (~0x00C0050F == 0x00);
	*(esp_49 - 0x14) = edi;
	word32 edi_72 = *(esp_49 - 0x14);
	word32 ecx_74 = *(esp_49 - 0x10);
	Eq_296 SCZDOP_76 = *(esp_49 - 0x0C);
	word32 ebp_79 = *(esp_49 - 0x08);
	*(esp_49 - 0x08) = ebp_79;
	*(esp_49 - 0x0C) = (union Eq_296 *) SCZDOP_76;
	*(esp_49 - 0x10) = ecx_74;
	do
		;
	while (~0x00C0050F == 0x00);
	*(esp_49 - 0x14) = edi_72;
	word32 edi_101 = *(esp_49 - 0x14);
	word32 ecx_103 = *(esp_49 - 0x10);
	Eq_342 SCZDOP_105 = *(esp_49 - 0x0C);
	word32 ebp_108 = *(esp_49 - 0x08);
	*(esp_49 - 0x08) = ebp_79 - 0x0C;
	*(esp_49 - 0x0C) = ebp_108;
	*(esp_49 - 0x10) = (union Eq_342 *) SCZDOP_105;
	*(esp_49 - 0x14) = ecx_103;
	do
		;
	while (~0x00C0050F == 0x00);
	*(esp_49 - 0x18) = edi_101;
	word32 edi_131 = *(esp_49 - 0x18);
	word32 ecx_133 = *(esp_49 - 0x14);
	Eq_395 SCZDOP_135 = *(esp_49 - 0x10);
	word32 ebp_138 = *(esp_49 - 0x0C);
	*(esp_49 - 0x0C) = 0x04;
	*(esp_49 - 0x10) = ebp_138;
	*(esp_49 - 0x14) = (union Eq_395 *) SCZDOP_135;
	*(esp_49 - 0x18) = ecx_133;
	do
		;
	while (~0x00C0050F == 0x00);
	*(esp_49 - 0x1C) = edi_131;
	ptr32 ebp_167 = *(esp_49 - 0x10);
	*(esp_49 - 0x10) = ebp_167 - 0x24;
	*(esp_49 - 0x14) = ebp_167 - 0x24;
	fn00401000(ebp_167 - 0x24, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_167 - 0x0254) = *((char *) *(ebp_167 - 0x023C) + 0x04);
	*esp_49 = (union Eq_208 *) (ebp_167 - 0x0230);
	*(esp_49 - 0x04) = 0x04;
	*(esp_49 - 0x08) = ebp_167 - 0x0C;
	*(esp_49 - 0x0C) = 0x04;
	*(esp_49 - 0x10) = ebp_167 - 0x0254;
	*(esp_49 - 0x14) = ebp_167 - 600;
	fn00401000(ebp_167 - 0x0254, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_167 - 0x10) = *((char *) *(ebp_167 - 0x023C) + 0x08);
	*esp_49 = (union Eq_208 *) (ebp_167 - 0x0230);
	*(esp_49 - 0x04) = 0x08;
	*(esp_49 - 0x08) = ebp_167 - 0x0C;
	*(esp_49 - 0x0C) = 0x04;
	*(esp_49 - 0x10) = ebp_167 - 0x10;
	*(esp_49 - 0x14) = ebp_167 - 0x18;
	fn00401000(ebp_167 - 0x10, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_167 - 0x20) = *(ebp_167 - 0x023C) + 0x0C;
	*esp_49 = 0x00;
	*(ebp_167 - 0x1C) = (HMODULE *) GetModuleHandleA(*esp_49);
	*(ebp_167 - 0x0250) = *(ebp_167 - 0x1C) + 0x1000;
	*(ebp_167 - 588) = 0x0C;
	*(ebp_167 - 0x18) = **(ebp_167 - 0x20);
	*esp_49 = (union Eq_208 *) (ebp_167 - 0x0230);
	*(esp_49 - 0x04) = *(ebp_167 - 588);
	*(esp_49 - 0x08) = ebp_167 - 0x0C;
	*(esp_49 - 0x0C) = 0x04;
	*(esp_49 - 0x10) = ebp_167 - 0x18;
	*(esp_49 - 0x14) = ebp_167 - 0x18 - *(ebp_167 - 588);
	fn00401000(ebp_167 - 0x18, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_167 - 0x18) = *(ebp_167 - 0x18) + *(ebp_167 - 0x1C);
	*(ebp_167 - 588) = *(ebp_167 - 588) + 0x04;
	*(ebp_167 - 0x20) = *(ebp_167 - 0x20) + 0x04;
	*(ebp_167 - 0x0244) = **(ebp_167 - 0x20);
	*esp_49 = (union Eq_208 *) (ebp_167 - 0x0230);
	*(esp_49 - 0x04) = *(ebp_167 - 588);
	*(esp_49 - 0x08) = ebp_167 - 0x0C;
	*(esp_49 - 0x0C) = 0x04;
	*(esp_49 - 0x10) = ebp_167 - 0x0244;
	*(esp_49 - 0x14) = ebp_167 - 0x0244 - *(ebp_167 - 588);
	byte DP_296 = fn00401000(ebp_167 - 0x0C, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_167 - 588) = *(ebp_167 - 588) + 0x04;
	*(ebp_167 - 0x20) = *(ebp_167 - 0x20) + 0x04;
	*(ebp_167 - 0x28) = *(ebp_167 - 0x10) * 0x08 + 0x0C;
	*esp_49 = 0x40;
	*(esp_49 - 0x04) = 0x3000;
	*(esp_49 - 0x08) = *(ebp_167 - 0x28) + *(ebp_167 - 0x0254) + *(ebp_167 - 0x24);
	*(esp_49 - 0x0C) = 0x00;
	*(ebp_167 - 0x0238) = (LPVOID *) VirtualAlloc(*(esp_49 - 0x0C), *(esp_49 - 0x08), *(esp_49 - 0x04), *esp_49);
	*(ebp_167 - 0x08) = *(ebp_167 - 0x18) + *(ebp_167 - 0x28);
	word32 ecx_324 = *(ebp_167 - 0x28);
	*(ebp_167 - 0x0240) = ecx_324;
	word32 edx_326 = *(ebp_167 - 0x0240);
	*(ebp_167 - 0x0260) = edx_326;
	*(ebp_167 - 0x04) = 0x00;
	*(ebp_167 - 0x14) = 0x00;
	ptr32 esp_336;
	ptr32 ebp_337;
	byte SCZO_338;
	Eq_208 eax_339;
	bool Z_340;
	word32 ecx_341;
	word32 edx_342;
	byte SCZDOP_343;
	word32 edi_344;
	byte SZO_345;
	bool C_346;
	byte dl_347;
	byte DP_348;
	fn00401A24();
	return eax_339;
}

