// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 eax_26 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 esi_15 = null;
	word32 ebx_104 = eax_26 + 0x25;
	if (AreAllAccessesGranted(~0x00, ~0x00) == 0x00)
		ebx_104 = eax_26 + 0x03;
	CloseHandle((void *) 0x59);
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x0C);
	struct Eq_49 * eax_59 = null;
	do
	{
		if (esi_15 == ebx_104)
			esi_15 = null;
		eax_59[4199032] = (struct Eq_49) (eax_59[4199032] ^ esi_15[0x00101000]);
		eax_59 = eax_59 + 0x01;
		esi_15 = (Eq_17) ((char *) &esi_15->dw0000 + 0x01);
	} while (eax_59 < (struct Eq_49 *) 5152);
	struct Eq_71 * ecx_110 = &globals->t402558;
	Eq_73 edi_125 = (struct HINSTANCE__ *) 0xF0400FF8;
	up32 dwLoc08_114 = 0x00;
	do
	{
		Eq_73 eax_98 = ecx_110->t0004;
		word16 * edx_103 = (char *) &ecx_110->t0004 + 0x04;
		if (eax_98 - 0x08 >> 0x01 > 0x00)
		{
			uint32 esi_245 = eax_98 - 0x08 >> 0x01;
			do
			{
				ui32 eax_248 = (word32) *edx_103;
				ebx_104 = eax_248 & 0xF000;
				if ((eax_248 & 0xF000) == 0x3000)
				{
					struct Eq_99 * eax_259 = (eax_248 & 0x0FFF) + ecx_110->dw0000;
					eax_259->dw400FF8 = eax_259->dw400FF8 + 0xF0400FF8;
				}
				edx_103 = edx_103 + 0x01;
				esi_245 = esi_245 - 0x01;
			} while (esi_245 != 0x00);
		}
		Eq_73 eax_107 = ecx_110->t0004;
		up32 edx_109 = eax_107 + dwLoc08_114 / 0x04;
		ecx_110 = ecx_110 + eax_107;
		dwLoc08_114 = edx_109;
	} while (edx_109 < 228);
	struct Eq_123 * esi_117 = &globals->t401D54;
	struct Eq_123 * dwLoc08_118 = &globals->t401D54;
	if (globals->dw401D64 != 0x00)
	{
		do
		{
			eax_107 = LoadLibraryA(esi_117->dw000C + 0x00400FF8);
			edi_125 = eax_107;
			if (eax_107 != null)
			{
				word32 ebx_173 = esi_117->dw0000;
				if (ebx_173 == 0x00)
					ebx_173 = esi_117->dw0010;
				ebx_104 = ebx_173 + 0x00400FF8;
				eax_107 = (Eq_73) ebx_104->dw0000;
				word32 * esi_182 = esi_117->dw0010 + 0x00400FF8;
				bool S_185 = (bool) cond(eax_107);
				if (eax_107 != null)
				{
					do
					{
						Eq_207 eax_218;
						if (!S_185)
						{
							eax_218 = GetProcAddress(edi_125, (word32) ebx_104->dw0000);
							edi_125 = eax_107;
						}
						else
							eax_218 = GetProcAddress(edi_125, eax_107 + 0x00400FFA);
						*esi_182 = (word32) eax_218;
						ebx_104 = ebx_104 + 0x04;
						eax_107 = (Eq_73) ebx_104->dw0000;
						esi_182 = esi_182 + 0x01;
						S_185 = (bool) cond(eax_107);
					} while (eax_107 != null);
				}
				esi_117 = dwLoc08_118;
			}
			esi_117 = esi_117 + 0x01;
			dwLoc08_118 = esi_117;
		} while (esi_117->dw0010 != 0x00);
	}
	fn00401A48(eax_107, &globals->t401A48, ebx_104, 0x00400FF8, edi_125);
	*(fp - 0x20) = 0x00;
	ExitProcess(*(fp - 0x20));
}

// 00401A48: void fn00401A48(Register Eq_73 eax, Register (ptr32 Eq_134) edx, Register Eq_17 ebx, Register word32 ebp, Register Eq_73 edi)
void fn00401A48(HMODULE eax, Eq_134 * edx, BOOL ebx, word32 ebp, HMODULE edi)
{
	(int32 *) 2625356659 = (int32 *) 2625356659 | fp;
	if ((int32 *) 2625356659 < 0x00)
	{
		edx->b0000 = edx->b0000 | 228;
		edx->dw2929C543 = edx->dw2929C543 ^ ~0x71;
		__bound(ebp, *((char *) &ebx->dw0000 + 1614660203));
	}
	else
	{
		edi->bBD285212 = edi->bBD285212 + bh;
		(HMODULE *) 0x623DC26D = (HMODULE *) eax;
	}
}

