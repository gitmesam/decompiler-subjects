// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00401018();
	<anonymous> * eax_59 = fn004010B5((struct <anonymous> *) 3472027048);
	ptr32 esp_61;
	word32 ebp_62;
	word32 edi_63;
	word32 esi_64;
	word32 ebx_65;
	word32 ecx_66;
	byte SZO_67;
	Eq_2 eax_68;
	byte cl_69;
	byte SCZO_70;
	struct Eq_22 * edx_71;
	word16 bx_72;
	bool C_73;
	word16 dx_74;
	bool Z_75;
	eax_59();
	if (eax_68 != null)
	{
		fn00401018();
		return eax_68;
	}
	else
	{
		*(esp_61 - 0x04) = 0x10066F2F;
		<anonymous> * eax_98 = fn004010B5(dwArg00);
		*(esp_61 - 0x04) = esp_61;
		*(esp_61 - 0x08) = esp_61 - 0x04;
		*(esp_61 - 0x0C) = 0x40;
		*(esp_61 - 0x10) = edx_71->dw0030;
		*(esp_61 - 0x14) = edx_71->dw0034;
		*(esp_61 - 0x14) = *(esp_61 - 0x14) + ebx_65;
		struct Eq_83 * esp_117;
		word32 ebp_118;
		word32 edi_119;
		word32 esi_120;
		word32 ebx_121;
		word32 ecx_122;
		byte SZO_123;
		word32 eax_124;
		byte cl_125;
		byte SCZO_126;
		word32 edx_127;
		word16 bx_128;
		bool C_129;
		word16 dx_130;
		bool Z_131;
		eax_98();
		word32 ecx_134 = esp_117->dw0004;
		<anonymous> * eax_136 = esp_117->ptr0008;
		esp_117->dw0018 = ecx_134;
		word32 esp_148;
		word32 ebp_149;
		word32 edi_150;
		word32 esi_151;
		word32 ebx_152;
		word32 ecx_153;
		byte SZO_154;
		word32 eax_155;
		byte cl_156;
		byte SCZO_157;
		word32 edx_158;
		word16 bx_159;
		bool C_160;
		word16 dx_161;
		bool Z_162;
		eax_136();
		return fn00401076(dwArg00, dwArg04);
	}
}

// 00401018: void fn00401018()
void fn00401018()
{
}

// 00401076: Register uint32 fn00401076(Stack Eq_2 dwArg04, Stack word32 dwArg08)
uint32 fn00401076(DWORD dwArg04, word32 dwArg08)
{
	Eq_2 edx_32 = dwArg04;
	word32 ecx_106 = dwArg08;
	if (dwArg08 == 0x00)
	{
		Eq_2 edi_100 = dwArg04;
		do
		{
			edi_100 = (Eq_2) (edi_108 + 0x01);
			Eq_2 edi_108 = edi_100;
		} while (0x00 != edi_108->b0000);
		ecx_106 = edi_100 - 0x01 - dwArg04;
	}
	uint32 eax_41 = ~0x00;
	byte al_42 = (byte) eax_41;
	do
	{
		eax_41 = DPB(eax_41, al_42 ^ edx_32->b0000, 0);
		edx_32 = (Eq_2) (edx_32 + 0x01);
		byte bl_56 = 0x08;
		do
		{
			eax_41 = eax_41 >> 0x01;
			al_42 = (byte) eax_41;
			if (eax_41 < 0x00)
			{
				eax_41 = eax_41 ^ 3988292384;
				al_42 = (byte) (eax_41 ^ 3988292384);
			}
			bl_56 = bl_56 - 0x01;
		} while (bl_56 != 0x00);
		ecx_106 = ecx_106 - 0x01;
	} while (ecx_106 != 0x00);
	return ~eax_41;
}

// 004010B5: Register word32 fn004010B5(Stack Eq_2 dwArg04)
word32 fn004010B5(DWORD dwArg04)
{
	struct Eq_180 * edx_35 = fs->ptr0030->ptr000C->ptr000C;
	do
	{
		edx_35 = edx_35->ptr0000;
		byte * edi_57 = fp - 0x1D;
		word16 * esi_58 = edx_35->ptr0030;
		word32 ecx_180 = 0x0D;
		do
		{
			word16 ax_63 = *esi_58;
			*edi_57 = (byte) ax_63;
			esi_58 = esi_58 + 0x01;
			edi_57 = edi_57 + 0x01;
			if (ax_63 == 0x00)
				break;
			ecx_180 = ecx_180 - 0x01;
		} while (ecx_180 != 0x00);
		word32 ecx_72 = 0x0D;
		byte * esi_73 = fp - 0x1D;
		byte * edi_74 = fp - 0x1D;
		do
		{
			cu8 al_176 = *esi_73;
			esi_73 = esi_73 + 0x01;
			if (al_176 <= 0x5A && al_176 >= 0x41)
				al_176 = al_176 + 0x20;
			*edi_74 = al_176;
			edi_74 = edi_74 + 0x01;
			ecx_72 = ecx_72 - 0x01;
		} while (ecx_72 != 0x00);
	} while ((fn00401076(fp - 0x1D, 0x00) ^ 0x6AE69F02) != 0x00);
	struct Eq_259 * eax_106 = edx_35->ptr0018;
	word32 * esi_112 = (char *) (eax_106 + (&(eax_106 + eax_106->dw003C / 0x0040)->dw003C)[0x0F] / 0x0040) + 0x001C;
	word32 * edi_113 = fp - 0x10;
	word32 ecx_114 = 0x03;
	do
	{
		*edi_113 = eax_106 + *esi_112 / 0x0040;
		esi_112 = esi_112 + 0x01;
		edi_113 = edi_113 + 0x01;
		ecx_114 = ecx_114 - 0x01;
	} while (ecx_114 != 0x00);
	word32 * esi_126 = dwLoc0C;
	ui32 edx_127 = ~0x00;
	do
	{
		edx_127 = edx_127 + 0x01;
		esi_126 = esi_181 + 0x01;
		word32 * esi_181 = esi_126;
	} while (dwArg04 != fn00401076(eax_106 + *esi_181 / 0x0040, 0x00));
	return eax_106 + dwLoc10[(word32) dwLoc08[edx_127]] / 0x0040;
}

