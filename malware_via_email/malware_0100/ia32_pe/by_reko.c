// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 eax_30 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 esi_15 = 0x00;
	word32 ebx_286 = eax_30 + 0x23;
	if (AreAllAccessesGranted(~0x00, ~0x00) == 0x00)
		ebx_286 = eax_30 + 0x01;
	CloseHandle((void *) 0x59);
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x08);
	Eq_49 dwLoc1C_152 = fp - 0x08;
	struct Eq_51 * eax_63 = null;
	do
	{
		if (esi_15 == ebx_286)
			esi_15.u0 = 0x00;
		eax_63[4198848] = (struct Eq_51) (eax_63[4198848] ^ *((word32) esi_15 + 0x00404000));
		eax_63 = eax_63 + 0x01;
		esi_15 = (word32) esi_15 + 0x01;
	} while (eax_63 < (struct Eq_51 *) 5152);
	struct Eq_73 * edi_105 = &globals->t4024A0;
	up32 dwLoc04_100 = 0x00;
	do
	{
		Eq_77 eax_110 = edi_105->t0004;
		cui16 * esi_117 = (char *) &edi_105->t0004 + 0x04;
		if (eax_110 - 0x08 >> 0x01 > 0x00)
		{
			uint32 ebp_254 = eax_110 - 0x08 >> 0x01;
			do
			{
				if ((*esi_117 & 0xF000) == 0x3000)
				{
					struct Eq_156 * eax_276 = ((word32) *esi_117 & 0x0FFF) + edi_105->dw0000;
					eax_276->dw400F40 = eax_276->dw400F40 + 0xF0400F40;
				}
				esi_117 = esi_117 + 0x01;
				ebp_254 = ebp_254 - 0x01;
			} while (ebp_254 != 0x00);
		}
		Eq_77 eax_123 = edi_105->t0004;
		up32 ecx_126 = (word32) eax_123 + dwLoc04_100;
		edi_105 = edi_105 + eax_123;
		dwLoc04_100 = ecx_126;
	} while (ecx_126 < 228);
	struct Eq_109 * edi_132 = &globals->t401C9C;
	struct Eq_109 * dwLoc04_133 = globals->a401CAC;
	word32 * esi_134 = esi_117 + 0x002007A0;
	if (globals->a401CAC != 0x00)
	{
		do
		{
			word32 ecx_163 = edi_132->dw000C;
			ecx_126 = ecx_163 + 0x00400F40;
			dwLoc1C_152 = ecx_163 + 0x00400F40;
			eax_123 = LoadLibraryA(ecx_163 + 0x00400F40);
			if (eax_123 != 0x00)
			{
				Eq_77 edi_197;
				eax_123 = edi_132->dw0000;
				if (eax_123 != 0x00)
					edi_197 = eax_123;
				else
					edi_197 = edi_132->dw0010;
				word32 edi_200 = edi_197 + 0x00400F40;
				esi_134 = dwLoc04_133->dw0000 + 0x00400F40;
				if (edi_200->unused != 0x00)
				{
					do
					{
						int32 eax_227 = edi_200->unused;
						word16 ax_228 = (word16) eax_227;
						if (eax_227 < 0x00)
							dwLoc1C_152 = (word32) ax_228;
						else
						{
							ecx_126 = eax_227 + 0x00400F42;
							dwLoc1C_152 = eax_227 + 0x00400F42;
						}
						eax_123 = GetProcAddress(eax_123, dwLoc1C_152);
						*esi_134 = (word32) eax_123;
						edi_200 = edi_200 + 0x04;
						esi_134 = esi_134 + 0x01;
					} while (edi_200->unused != 0x00);
				}
				edi_132 = dwLoc04_133;
			}
			edi_132 = edi_132 + 0x01;
			dwLoc04_133 = edi_132;
		} while (edi_132->dw0010 != 0x00);
	}
	fn00401990(eax_123, ecx_126, &globals->t401990, esi_134, dwLoc1C_152, edi);
	ExitProcess(0x00);
}

// 00401990: void fn00401990(Register Eq_77 eax, Register up32 ecx, Register (ptr32 Eq_124) edx, Register (ptr32 word32) esi, Stack Eq_49 dwArg00, Stack ui32 dwArg04)
void fn00401990(Eq_77 eax, up32 ecx, Eq_124 * edx, word32 * esi, LPCSTR dwArg00, ui32 dwArg04)
{
	edx->aBCFFC3F1[(char *) esi + 0x01].dw0000 = __rol(edx->aBCFFC3F1[(char *) esi + 0x01].dw0000, 0x46);
	if (esi == (word32 *) 0x01 || ecx == 0x01)
	{
		ui32 * edi_25 = *((word32) eax + 0x001F);
		if ((edx->aBCFFC3F1[(char *) esi + 0x01].dw0000 & 0x04000000) == 0x00)
		{
			*edi_25 = dwArg04 | 0x2A3B82D6;
			__lock();
			word32 esp_43;
			word32 edi_44;
			word32 esi_45;
			byte SZO_46;
			word32 edx_47;
			bool C_48;
			word32 ecx_49;
			bool Z_50;
			word32 eax_51;
			byte ah_52;
			bool FPUF_53;
			word32 ebp_54;
			byte SCZO_55;
			ebp();
		}
	}
}

