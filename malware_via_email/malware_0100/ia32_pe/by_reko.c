// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_3 eax_30 = AddAce(null, 0x00, 0x00, null, 0x00);
	Eq_17 esi_15 = 0x00;
	word32 ebx_267 = eax_30 + 0x23;
	if (AreAllAccessesGranted(~0x00, ~0x00) == 0x00)
		ebx_267 = eax_30 + 0x01;
	CloseHandle((void *) 0x59);
	VirtualProtect(&globals->v401000, 0x3000, 0x40, fp - 0x28);
	struct Eq_49 * esp_54 = fp - 0x48;
	struct Eq_52 * eax_59 = null;
	do
	{
		if (esi_15 == ebx_267)
			esi_15.u0 = 0x00;
		eax_59[4198848] = (struct Eq_52) (eax_59[4198848] ^ *((word32) esi_15 + 0x00404000));
		eax_59 = eax_59 + 0x01;
		esi_15 = (word32) esi_15 + 0x01;
	} while (eax_59 < (struct Eq_52 *) 5152);
	struct Eq_74 * edi_103 = &globals->t4024A0;
	up32 dwLoc34_127 = 0x00;
	do
	{
		Eq_78 eax_106 = edi_103->t0004;
		cui16 * esi_113 = (char *) &edi_103->t0004 + 0x04;
		if (eax_106 - 0x08 >> 0x01 > 0x00)
		{
			uint32 ebp_235 = eax_106 - 0x08 >> 0x01;
			do
			{
				if ((*esi_113 & 0xF000) == 0x3000)
				{
					struct Eq_175 * eax_257 = ((word32) *esi_113 & 0x0FFF) + edi_103->dw0000;
					eax_257->dw400F40 = eax_257->dw400F40 + 0xF0400F40;
				}
				esi_113 = esi_113 + 0x01;
				ebp_235 = ebp_235 - 0x01;
			} while (ebp_235 != 0x00);
		}
		Eq_78 eax_120 = edi_103->t0004;
		up32 ecx_122 = (word32) eax_120.u0 + dwLoc34_127;
		edi_103 = edi_103 + eax_120;
		dwLoc34_127 = ecx_122;
	} while (ecx_122 < 228);
	struct Eq_110 * edi_128 = &globals->t401C9C;
	if (globals->dw401CAC != 0x00)
	{
		edi_156 = edi_128;
		esp_159 = esp_54;
		do
		{
			struct Eq_110 * edi_156;
			struct Eq_49 * esp_159;
			esp_159 = esp_159 - 0x04;
			esp_159->dw0000 = edi_156->dw000C + 0x00400F40;
			Eq_159 eax_164 = LoadLibraryA(esp_159->dw0000);
			if (eax_164 != null)
			{
				word32 edi_188;
				word32 eax_183 = edi_156->dw0000;
				if (eax_183 != 0x00)
					edi_188 = eax_183;
				else
					edi_188 = edi_156->dw0010;
				word32 * edi_191 = edi_188 + 0x00400F40;
				word32 * esi_192 = esp_159[0x05].t0004[0x0C] + 0x00400F40;
				if (*edi_191 != 0x00)
				{
					do
					{
						word32 * esp_218;
						int32 eax_212 = *edi_191;
						word16 ax_213 = (word16) eax_212;
						if (eax_212 < 0x00)
						{
							esp_218 = esp_159 - 0x04;
							*esp_218 = (word32) ax_213;
						}
						else
						{
							esp_218 = esp_159 - 0x04;
							*esp_218 = eax_212 + 0x00400F42;
						}
						esp_159 = esp_218 - 0x04;
						esp_159->dw0000 = (word32) eax_164;
						*esi_192 = (word32) GetProcAddress(esp_159->dw0000, esp_159[0x01]);
						edi_191 = edi_191 + 0x01;
						esi_192 = esi_192 + 0x01;
					} while (*edi_191 != 0x00);
				}
				edi_156 = (struct Eq_110 *) esp_159[0x05];
			}
			edi_156 = edi_156 + 0x01;
			esp_159[0x05] = (struct Eq_49) edi_156;
		} while (edi_156->dw0010 != 0x00);
	}
	ptr32 esp_134;
	byte SCZO_135;
	word32 ebx_136;
	word32 ebp_137;
	word32 esi_138;
	word32 edi_139;
	byte SZO_140;
	byte C_141;
	word32 ecx_142;
	word32 edx_143;
	word32 eax_144;
	byte Z_145;
	byte cl_146;
	word16 dx_147;
	byte S_148;
	word16 ax_149;
	globals->t401990();
	*(esp_134 - 0x04) = 0x00;
	ExitProcess(*(esp_134 - 0x04));
}

