// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text.h"

// 00401000: void fn00401000(Register word32 ecx, Register Eq_3 edx, Register word32 ebx)
// Called from:
//      Win32CrtStartup
void fn00401000(word32 ecx, Eq_3 edx, word32 ebx)
{
	if (g_dw403074 != 0x00)
		ecx = fn0040148C(ecx, edx, 0x00, 0x02, 0x00, out ebx);
	SetUnhandledExceptionFilter(&g_t401110);
	word32 edx_41;
	word32 ecx_42 = fn00401514(ecx, ebx, out edx_41);
	fn004015F4();
	__getmainargs(&g_dw405000, &g_dw405004, fp - 0x10, g_dw402000);
	ptr32 esp_111 = fp - 0x3C;
	word32 eax_60 = g_dw405034;
	if (eax_60 != 0x00)
	{
		g_dw402004 = eax_60;
		word32 eax_67 = iob->dw0010;
		struct Eq_69 * esp_70;
		word32 edx_72;
		word32 ecx_74;
		setmode();
		esp_70->dw0004 = g_dw405034;
		word32 eax_78 = iob->dw0030;
		esp_70->dw0000 = eax_78;
		struct Eq_86 * esp_80;
		word32 edx_82;
		word32 ecx_84;
		setmode();
		esp_80->dw0004 = g_dw405034;
		word32 eax_88 = iob->dw0050;
		esp_80->dw0000 = eax_88;
		setmode();
	}
	*__p__fmode() = g_dw402004;
	fn0040172C();
	__align(esp_111);
	word32 edx_115;
	struct Eq_121 * esp_121;
	word32 * eax_122;
	_p__environ();
	esp_121->dw0008 = *eax_122;
	esp_121->dw0004 = g_dw405004;
	esp_121->dw0000 = g_dw405000;
	UINT * esp_142;
	cexit();
	word32 ecx_135;
	word32 edx_136;
	*esp_142 = (uint32) fn0040138C(esp_121->dwFFFFFFFC, out ecx_135, out edx_136);
	ExitProcess(*esp_142);
}

// 0040126C: Register Eq_167 Win32CrtStartup()
Eq_167 Win32CrtStartup()
{
	__set_app_type(0x01);
	fn00401000(ecx, edx, ebx);
}

// 0040129C: void fn0040129C(Stack (ptr32 Eq_179) ptrArg04)
// Called from:
//      Win32CrtStartup
//      fn00401974
void fn0040129C(void (* ptrArg04)())
{
	atexit(ptrArg04);
}

// 0040138C: Register word32 fn0040138C(Stack word32 dwArg00, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      fn00401000
word32 fn0040138C(word32 dwArg00, ptr32 & ecxOut, ptr32 & edxOut)
{
	__align(fp);
	word32 edx_62;
	fn00401974(out edx_62);
	word32 * esp_27;
	word32 eax_29;
	ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc();
	*esp_27 = 0x00401430;
	ptr32 edx_39;
	ZNSolsEPFRSoS_E();
	ecxOut = fp + 0x04;
	edxOut = edx_39;
	return 0x00;
}

// 0040148C: Register word32 fn0040148C(Register word32 ecx, Register Eq_3 edx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Register out ptr32 ebxOut)
// Called from:
//      fn00401000
word32 fn0040148C(word32 ecx, Eq_3 edx, word32 dwArg04, word32 dwArg08, word32 dwArg0C, ptr32 & ebxOut)
{
	struct Eq_208 * esp_11 = fp - 0x1C;
	if (g_dw405044 != 0x02)
		g_dw405044 = 0x02;
	if (dwArg08 != 0x02)
	{
		if (dwArg08 == 0x01)
			ecx = fn00401B04(ecx, edx, 0x01);
	}
	else
	{
		word32 * ebx_19 = g_a407014;
		if (0x00 != 0x00)
		{
			do
			{
				<anonymous> * eax_27 = *ebx_19;
				if (eax_27 != null)
					eax_27();
				++ebx_19;
			} while (ebx_19 != g_a407014);
			ebxOut = esp_11->ptr0014;
			return ecx;
		}
	}
	ebxOut = ebx;
	return ecx;
}

// 00401514: Register word32 fn00401514(Register word32 ecx, Register word32 ebx, Register out Eq_20 edxOut)
// Called from:
//      fn00401000
word32 fn00401514(word32 ecx, word32 ebx, union Eq_20 & edxOut)
{
	byte cl_105 = (byte) ecx;
	byte ch_121 = SLICE(ecx, byte, 8);
	word16 ecx_16_16_141 = SLICE(ecx, word16, 16);
	Eq_20 edx_166 = SCZDOP;
	byte dh_40 = SLICE(SCZDOP, byte, 8);
	if (((SCZDOP ^ 0x00200000 ^ SCZDOP) & 0x00200000) != 0x00)
	{
		__cpuid(0x00, ecx, &0x00, &ebx, &ecx, &SCZDOP);
		if (0x00 != 0x00)
		{
			__cpuid(0x01, ecx, &0x01, &ebx, &ecx, &SCZDOP);
			if ((dh_40 & 0x01) != 0x00)
				g_dw405038 |= 0x01;
			if ((dh_40 & 0x80) != 0x00)
				g_dw405038 |= 0x02;
			if ((SCZDOP & 0x00800000) != 0x00)
				g_dw405038 |= 0x04;
			if ((SCZDOP & 0x01000000) != 0x00)
				g_dw405038 |= 0x08;
			if ((SCZDOP & 0x02000000) != 0x00)
				g_dw405038 |= 0x10;
			edx_166 = SCZDOP & 0x04000000;
			if ((SCZDOP & 0x04000000) != 0x00)
				g_dw405038 |= 0x20;
			if ((cl_105 & 0x01) != 0x00)
				g_dw405038 |= 0x40;
			ecx = SEQ(ecx_16_16_141, ch_121 & 0x20, cl_105);
			if ((ch_121 & 0x20) != 0x00)
				g_dw405038 |= 0x80;
			__cpuid(0x80000000, ecx, &0x80000000, &ebx, &ecx, &(SCZDOP & 0x04000000));
			if (false)
			{
				__cpuid(0x80000001, ecx, &0x80000001, &ebx, &ecx, &(SCZDOP & 0x04000000));
				if ((SCZDOP & 0x04000000) < 0x00)
					g_dw405038 |= 0x0100;
				edx_166 = SCZDOP & 0x04000000 & 0x40000000;
				if (edx_166 != 0x00)
					g_dw405038 |= 0x0200;
			}
		}
	}
	edxOut = edx_166;
	return ecx;
}

// 004015F4: void fn004015F4()
// Called from:
//      fn00401000
void fn004015F4()
{
	__fninit();
}

// 004015FC: Register Eq_115 fn004015FC(Stack Eq_418 dwArg04, Register out Eq_418 ecxOut, Register out Eq_418 edxOut)
// Called from:
//      fn00401648
//      fn0040172C
Eq_115 fn004015FC(Eq_418 dwArg04, union Eq_418 & ecxOut, union Eq_418 & edxOut)
{
	FILE * ebx_17 = iob + 0x40;
	fwrite(&g_v403078, 0x01, 0x17, ebx_17);
	msvcrt.dll!vfprintf();
	abort();
	Eq_115 eax_33 = fn00401648(eax, ecx, edx);
	ecxOut.u0 = <invalid>;
	edxOut.u0 = <invalid>;
	return eax_33;
}

// 00401648: Register Eq_115 fn00401648(Register Eq_115 eax, Register word32 ecx, Register (ptr32 byte) edx)
// Called from:
//      fn004015FC
//      fn0040172C
Eq_115 fn00401648(Eq_115 eax, word32 ecx, byte * edx)
{
	byte * esi_126 = edx;
	if (ecx == 0x00)
		return eax;
	word32 ecx_36 = ecx;
	if (VirtualQuery(eax, fp - 0x3C, 0x1C) == 0x00)
	{
		word32 edx_256;
		word32 ecx_255;
		fn004015FC(0x00403090, out ecx_255, out edx_256);
		return fn0040172C();
	}
	else if (dwLoc28 == 0x40 || dwLoc28 == 0x04)
	{
		Eq_115 edi_60 = eax;
		for (; ecx_36 != 0x00; --ecx_36)
		{
			*edi_60 = *esi_126;
			++esi_126;
			++edi_60;
		}
		return dwLoc28;
	}
	else
	{
		VirtualProtect(dwLoc3C, dwLoc30, 0x40, fp - 0x20);
		eax = dwLoc28;
		word32 ecx_132;
		Eq_115 edi_128 = eax;
		for (ecx_132 = ecx; ecx_132 != 0x00; --ecx_132)
		{
			*edi_128 = *esi_126;
			++esi_126;
			++edi_128;
		}
		if (dwLoc28 == 0x40 || dwLoc28 == 0x04)
			return eax;
		return VirtualProtect(dwLoc3C, dwLoc30, dwLoc20, fp - 0x20);
	}
}

// 0040172C: Register Eq_115 fn0040172C()
// Called from:
//      fn00401000
//      fn00401648
Eq_115 fn0040172C()
{
	struct Eq_534 * esp_148 = fp - 0x3C;
	Eq_115 eax_18 = g_t40503C;
	if (eax_18 != 0x00)
		return eax_18;
	g_t40503C.u0 = 0x01;
	eax_18.u0 = 0x18;
	if (false)
		return eax_18;
	struct Eq_548 * ebx_245 = &g_dw403128;
	if (true)
	{
		if (g_dw403128 != 0x00 || g_dw40312C != 0x00)
		{
l00401780:
			if (ebx_245 >= (struct Eq_548 *) 0x00403140)
				return eax_18;
			do
			{
				Eq_115 eax_267 = fn00401648(ebx_245->dw0004 + 0x00400000, 0x04, fp - 0x24);
				++ebx_245;
			} while (ebx_245 < (struct Eq_548 *) 0x00403140);
			return eax_267;
		}
		if (g_dw403130 != 0x00)
			goto l004017D9;
		ebx_245 = &g_t403134;
	}
	if (ebx_245->dw0000 == 0x00)
	{
		eax_18 = ebx_245->dw0004;
		if (eax_18 == 0x00)
		{
l004017D9:
			eax_18 = ebx_245[1];
			if (eax_18 != 0x01)
			{
				word32 ecx_72;
				word32 edx_73;
				fn004015FC(0x004030C4, out ecx_72, out edx_73);
				Eq_115 eax_104 = g_ptr402008->t0000;
				while (eax_104 != 0x00)
				{
					word32 ecx_96;
					eax_104();
					struct Eq_600 * eax_101 = g_ptr402008;
					g_ptr402008 = (struct Eq_600 *) &eax_101->t0004;
					eax_104 = eax_101->t0004;
				}
				return eax_104;
			}
			else
			{
				struct Eq_606 * ebx_113;
				for (ebx_113 = &ebx_245->dw0008 + 1; ebx_113 < (struct Eq_606 *) 0x00403140; ++ebx_113)
				{
					ui32 edx_122 = ebx_113->dw0008;
					word16 * eax_119 = ebx_113->dw0004 + 0x00400000;
					ui32 edx_123 = edx_122 & 0xFF;
					if ((edx_122 & 0xFF) != 0x10)
					{
						if ((edx_122 & 0xFF) == 0x20)
							goto l0040189F;
						if ((edx_122 & 0xFF) != 0x08)
						{
							esp_148[1] = (struct Eq_534) (edx_122 & 0xFF);
							esp_148->dw0000 = 0x004030F8;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_418 stackArg4 = <invalid>;
							word32 ecx_410;
							eax_119 = fn004015FC(stackArg4, out ecx_410, out edx_123);
							esp_148 = (struct Eq_534 *) ((char *) esp_148 - 4);
						}
						if (((word32) *eax_119 & 0x80) != 0x00)
							goto l00401881;
						goto l00401863;
					}
					if (((word32) *eax_119 & 0x8000) == 0x00)
					{
l00401863:
						if (edx_123 == 0x10)
							goto l004018D8;
						if (edx_123 != 0x20)
						{
							if (edx_123 == 0x08)
							{
l00401881:
								fn00401648(eax, 0x01, fp - 0x20);
							}
						}
						else
						{
l0040189F:
							fn00401648(eax, 0x04, fp - 0x20);
						}
					}
					else
					{
l004018D8:
						fn00401648(eax, 0x02, fp - 0x20);
					}
					eax_18.u0 = 0x00403140;
				}
				return eax_18;
			}
		}
	}
	goto l00401780;
}

// 00401974: Register word32 fn00401974(Register out ptr32 edxOut)
// Called from:
//      fn00401000
//      fn0040138C
word32 fn00401974(ptr32 & edxOut)
{
	word32 ecx_47 = g_dw405040;
	if (ecx_47 == 0x00)
	{
		g_dw405040 = 0x01;
		void (** esp_23)() = fp - 0x1C;
		ui32 ebx_24 = g_dw401C60;
		if (ebx_24 == ~0x00)
		{
			ebx_24 = 0x00;
			while (true)
			{
				ui32 eax_31 = ebx_24 + 0x01;
				edx = (ptr32) (&g_dw401C60)[eax_31 * 0x04];
				if (edx == 0x00)
					break;
				ebx_24 = eax_31;
			}
		}
		for (; ebx_24 != 0x00; --ebx_24)
		{
			word32 eax_48;
			fn909090C3();
		}
		*esp_23 = (void (**)()) &g_t4018F8;
		fn0040129C(*esp_23);
		edxOut = edx;
		return ecx_47;
	}
	else
	{
		edxOut = edx;
		return ecx_47;
	}
}

// 00401998: Register word32 fn00401998(Register word32 ecx, Register Eq_3 edx)
// Called from:
//      fn00401B04
word32 fn00401998(word32 ecx, Eq_3 edx)
{
	Eq_167 eax_15 = g_t405048;
	if (eax_15 == 0x00)
		return ecx;
	EnterCriticalSection(&g_t40504C);
	word32 * esp_21 = fp - 0x1C;
	struct Eq_773 * ebx_24;
	for (ebx_24 = g_ptr405064; ebx_24 != null; ebx_24 = ebx_24->ptr0008)
	{
		Eq_3 edx_54;
		*esp_21 = ebx_24->dw0000;
		struct Eq_804 * esp_34 = esp_21 + 1;
		Eq_3 eax_33 = TlsGetValue(*esp_21);
		esp_34->tFFFFFFFC = edx;
		esp_21 = esp_34 - 4;
		eax_15 = GetLastError();
		if (eax_15 == 0x00 && eax_33 != null)
		{
			<anonymous> * eax_46 = ebx_24->ptr0004;
			esp_34->tFFFFFFFC = eax_33;
			eax_46();
			edx = edx_54;
		}
	}
	*esp_21 = 0x0040504C;
	LeaveCriticalSection(*esp_21);
	*esp_21 = (word32) eax_15;
	return ecx;
}

// 00401B04: Register word32 fn00401B04(Register word32 ecx, Register Eq_3 edx, Stack up32 dwArg08)
// Called from:
//      fn0040148C
word32 fn00401B04(word32 ecx, Eq_3 edx, up32 dwArg08)
{
	if (dwArg08 == 0x01)
	{
		if (g_t405048 == 0x00)
			InitializeCriticalSection(&g_t40504C);
		g_t405048 = 0x01;
		return ecx;
	}
	else
	{
		if (dwArg08 >= 0x01)
		{
			if (dwArg08 == 0x03)
				ecx = fn00401998(ecx, edx);
		}
		else
		{
			ecx = fn00401998(ecx, edx);
			if (g_t405048 == 0x01)
			{
				g_t405048 = 0x00;
				DeleteCriticalSection(&g_t40504C);
			}
		}
		return ecx;
	}
}

