// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text.h"

// 00401000: void fn00401000(Register Eq_2 eax)
// Called from:
//      Win32CrtStartup
void fn00401000(Eq_2 eax)
{
	Eq_2 eax_20 = GetLastError();
	FormatMessageW(0x1300, null, eax_20, 0x0400, fp - 0x08, 0x00, null);
	int32 ecx_51 = lstrlenW(dwLoc08) + lstrlenW(eax);
	Eq_2 eax_57 = LocalAlloc(0x40, ecx_51 + 0x2000 + ecx_51);
	wsprintfW(eax_57, 0x00402080, 0x00);
	*((word32) eax_57 + 0x0800) = 0x00;
	MessageBoxW(null, eax_57, 0x00402234, 0x00);
	LocalFree(dwLoc08);
	LocalFree(eax_57);
	ExitProcess(eax_20);
}

// 004010A0: Register word32 fn004010A0(Register Eq_2 edi)
// Called from:
//      Win32CrtStartup
word32 fn004010A0(Eq_2 edi)
{
	int32 esi_19 = 0x00;
	if (DeleteFileW(edi) != 0x00)
		return 0x01;
	SetFileAttributesW(edi, 0x80);
	if (DeleteFileW(edi) != 0x00)
		return 0x01;
	do
	{
		if (DeleteFileW(edi) != 0x00)
			return 0x01;
		Eq_96 eax_55 = FindFirstFileW(edi, fp - 0x0254);
		if (eax_55 == (void *) ~0x00)
		{
			if (GetLastError() == 0x02)
				return 0x01;
		}
		else
			FindClose(eax_55);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Sleep(stackArg4);
		++esi_19;
	} while (esi_19 < 0x0A);
	return 0x00;
}

// 00401130: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	__align(fp - 4);
	struct Eq_138 * eax_24 = CommandLineToArgvW(GetCommandLineW(), fp - 0x60);
	if (eax_24 != null)
	{
		if (dwLoc60 != 0x05)
			return dwLoc60 + 1000;
		uint32 edx_239;
		union Eq_159 * edi_36 = eax_24->ptr0004;
		if (edi_36 != null)
		{
			word32 esi_41;
			union Eq_159 * eax_42 = edi_36;
			for (esi_41 = 0x14; esi_41 != 0x00; --esi_41)
			{
				if (*eax_42 == 0x00)
				{
					if (esi_41 == 0x00)
						break;
					edx_239 = 0x14 - esi_41;
					goto l00401195;
				}
				eax_42 = (union Eq_159 *) ((char *) eax_42 + 2);
			}
		}
		edx_239 = 0x00;
l00401195:
		Eq_2 ecx_67 = 0x00;
		uint32 eax_57 = 0x00;
		if (edx_239 != 0x00)
		{
			do
			{
				++eax_57;
				ecx_67 = (word32) *((char *) edi_36 + eax_57 * 0x02) - 0x30 + ecx_67 * 0x0A;
			} while (eax_57 < edx_239);
		}
		Eq_96 eax_84 = OpenProcess(0x01, 0x00, ecx_67);
		if (eax_84 != null)
		{
			if (TerminateProcess(eax_84, 0x00) != 0x00)
			{
				Eq_2 esi_118;
				CloseHandle(eax_84);
				if (fn004010A0(eax_24->t000C) == 0x00)
					esi_118 = eax_24->t0010;
				else
					esi_118 = eax_24->t000C;
				if (MoveFileW(eax_24->t0008, esi_118) != 0x00)
				{
					word32 ecx_138;
					byte * eax_139 = fp - 0x4C;
					for (ecx_138 = 0x44; ecx_138 != 0x00; --ecx_138)
					{
						*eax_139 = 0x00;
						++eax_139;
					}
					Eq_2 ecx_150;
					byte * eax_151 = fp - 0x5C;
					for (ecx_150 = 0x10; ecx_150 != 0x00; --ecx_150)
					{
						*eax_151 = 0x00;
						++eax_151;
					}
					if (CreateProcessW(ecx_150, esi_118, ecx_150, ecx_150, ecx_150, ecx_150, ecx_150, ecx_150, fp - 0x4C, fp - 0x5C) != 0x00)
					{
						if (esi_118 != eax_24->t000C)
						{
							word32 esi_196;
							for (esi_196 = 100; esi_196 != 0x00; --esi_196)
								fn004010A0(eax_24->t000C);
						}
						return 0x00;
					}
					else
						fn00401000(0x004022B8);
				}
				else
					fn00401000(0x004022A4);
			}
			else
				fn00401000(0x00402280);
		}
		else
			fn00401000(0x00402268);
	}
	else
		fn00401000(0x00402240);
}

