// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080487A0: void _cleanup()
void _cleanup()
{
}

// 080487B0: void atexit()
void atexit()
{
}

// 080487C0: void __fpstart()
void __fpstart()
{
}

// 080487D0: void exit()
void exit()
{
}

// 080487E0: void scanf()
void scanf()
{
}

// 080487F0: void printf()
void printf()
{
}

// 08048800: void malloc()
void malloc()
{
}

// 08048810: void free()
void free()
{
}

// 08048820: void abort()
void abort()
{
}

// 08048830: void memset()
void memset()
{
}

// 08048840: void _start(Register (ptr32 Eq_2) edx, Stack ui32 dwArg00)
void _start( * edx, ui32 dwArg00)
{
	if (0x080487A0 != 0x00)
		atexit(&globals->t80487A0);
	if (0x0804A5F4 != 0x00)
		atexit(edx);
	atexit(&globals->t8049510);
	globals->ptr804ACCC = fp + 0x08 + dwArg00 * 0x04;
	_init();
	word32 esp_36;
	word32 ebp_37;
	word32 edx_38;
	word32 eax_39;
	byte SZO_40;
	bool C_41;
	bool Z_42;
	byte SCZO_43;
	__fpstart();
	exit(main());
}

// 080488AF: void _mcount()
void _mcount()
{
}

// 080488B0: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	struct Eq_48 * ebx_10 = &globals->t804A5C0;
	while (true)
	{
		<anonymous> ** eax_18 = ebx_10->ptr00CC;
		if (*eax_18 == null)
			break;
		ebx_10->ptr00CC = (<anonymous> **) ((char *) eax_18 + 0x04);
		<anonymous> * eax_30 = *eax_18;
		word32 esp_32;
		word32 ebp_33;
		byte SCZO_35;
		word32 eax_36;
		bool Z_37;
		word32 edx_38;
		eax_30();
	}
	__deregister_frame_info((char *) &ebx_10->ptr00CC + 0x0014);
}

// 080488F0: void fini_dummy()
void fini_dummy()
{
}

// 08048908: void frame_dummy()
void frame_dummy()
{
	__register_frame_info(0x0804A6A0, &globals->t804ACB0);
}

// 08048930: void init_dummy()
void init_dummy()
{
}

// 08048948: Register word32 main()
word32 main()
{
	scanf("%d", tLoc20);
	scanf("%d", tLoc28);
	if (dwLoc08 == 0x05)
		printf("Equal\n");
	if (dwLoc08 != 0x05)
	{
		printf("Not Equal\n");
		if (dwLoc08 < 0x05)
		{
			printf("Greater\n");
			if (dwLoc08 < 0x05)
			{
l080489C3:
				printf("Greater or Equal\n");
				if (dwLoc08 <= 0x05)
					goto l080489E2;
l080489D5:
				printf("Less\n");
l080489E2:
				if (dwLoc0C < 0x05)
				{
					printf("Greater Unsigned\n");
					if (dwLoc0C < 0x05)
					{
l08048A0B:
						printf("Carry Clear\n");
						if (dwLoc0C <= 0x05)
							goto l08048A2A;
l08048A1D:
						printf("Carry Set\n");
l08048A2A:
						if (0x05 - dwLoc08 >= 0x00)
						{
							printf("Minus\n");
							if (0x05 - dwLoc08 >= 0x00)
								return 0x00;
						}
						printf("Plus\n");
						return 0x00;
					}
				}
				printf("Less or Equal Unsigned\n");
				if (dwLoc0C > 0x05)
					goto l08048A1D;
				goto l08048A0B;
			}
		}
	}
	printf("Less or Equal\n");
	if (dwLoc08 > 0x05)
		goto l080489D5;
	goto l080489C3;
}

// 08048A58: Register (ptr32 byte) decode_uleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
byte * decode_uleb128(byte * dwArg04, ui32 * dwArg08)
{
	ui32 edi_12 = 0x00;
	word32 esi_15 = 0x00;
	while (true)
	{
		byte * ecx_26 = dwArg04 + 0x01;
		ui32 edx_24 = (word32) *dwArg04;
		dwArg04 = ecx_26;
		edi_12 |= (edx_24 & 0x7F) << (byte) esi_15;
		if ((byte) edx_24 >= 0x00)
			break;
		esi_15 += 0x07;
	}
	*dwArg08 = edi_12;
	return ecx_26;
}

// 08048A94: Register (ptr32 byte) decode_sleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 uint32) dwArg08)
byte * decode_sleb128(byte * dwArg04, uint32 * dwArg08)
{
	byte * edi_15 = dwArg04;
	uint32 dwLoc08_16 = 0x00;
	uint32 ecx_17 = 0x00;
	byte cl_18 = 0x00;
	do
	{
		ui32 esi_24 = (word32) *edi_15;
		uint32 v12_29 = dwLoc08_16 | (esi_24 & 0x7F) << cl_18;
		ecx_17 += 0x07;
		++edi_15;
		dwLoc08_16 = v12_29;
		cl_18 = (byte) ecx_17;
	} while ((byte) esi_24 < 0x00);
	if (ecx_17 <= 0x1F && (esi_24 & 0x40) != 0x00)
		dwLoc08_16 = v12_29 | ~0x00 << cl_18;
	*dwArg08 = dwLoc08_16;
	return edi_15;
}

// 08048AF0: void fde_insert(Stack (ptr32 Eq_246) dwArg04, Stack ui32 dwArg08, Stack (ptr32 Eq_248) dwArg0C)
void fde_insert(Eq_246 * dwArg04, ui32 dwArg08, Eq_248 * dwArg0C)
{
	*((char *) dwArg04 + dwArg08 * 0x04) = (union Eq_246 *) dwArg0C;
	ui32 edx_14 = dwArg08;
	if (dwArg08 != 0x00)
	{
		word32 * ecx_45 = (char *) dwArg04 + dwArg08 * 0x04;
		do
		{
			struct Eq_259 * esi_53 = (dwArg04 - 0x04)[edx_14];
			struct Eq_263 * edi_50 = *ecx_45;
			if (edi_50->dw0008 - esi_53->dw0008 >= 0x00)
				return;
			*ecx_45 = esi_53;
			(dwArg04 - 0x04)[edx_14] = edi_50;
			ecx_45 += -0x01;
			--edx_14;
		} while (edx_14 != 0x00);
	}
}

// 08048B48: Register word32 count_fdes(Stack (ptr32 Eq_248) dwArg04)
word32 count_fdes(Eq_248 * dwArg04)
{
	struct Eq_248 * edx_25 = dwArg04;
	word32 ecx_13 = 0x00;
	if (dwArg04->dw0000 != 0x00)
	{
		do
		{
			if (edx_25[0x01] != 0x00 && edx_25[0x02] != 0x00)
				++ecx_13;
			struct Eq_302 * eax_32 = edx_25 + edx_25->dw0000 / 0x04;
			edx_25 = (struct Eq_248 *) &eax_32->dw0004;
		} while (eax_32->dw0004 != 0x00);
	}
	return ecx_13;
}

// 08048B78: void add_fdes(Stack (ptr32 Eq_248) dwArg04, Stack (ptr32 Eq_246) dwArg08, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 up32) dwArg10, Stack (ptr32 up32) dwArg14)
void add_fdes(Eq_248 * dwArg04, Eq_246 * dwArg08, ui32 * dwArg0C, up32 * dwArg10, up32 * dwArg14)
{
	struct Eq_248 * esi_19 = dwArg04;
	ui32 edi_105 = *dwArg0C;
	up32 dwLoc08_115 = *dwArg10;
	up32 dwLoc0C_119 = *dwArg14;
	if (dwArg04->dw0000 != 0x00)
	{
		do
		{
			if (esi_19[0x01] != 0x00 && esi_19[0x02] != 0x00)
			{
				fde_insert(dwArg08, edi_105, esi_19);
				++edi_105;
				up32 eax_111 = esi_19[0x02];
				if (dwLoc08_115 > eax_111)
					dwLoc08_115 = eax_111;
				up32 eax_116 = (word32) esi_19[0x03].dw0000 + eax_111;
				if (dwLoc0C_119 < eax_116)
					dwLoc0C_119 = eax_116;
			}
			struct Eq_358 * eax_95 = esi_19 + esi_19->dw0000 / 0x04;
			esi_19 = (struct Eq_248 *) &eax_95->dw0004;
		} while (eax_95->dw0004 != 0x00);
	}
	*dwArg0C = edi_105;
	*dwArg10 = dwLoc08_115;
	*dwArg14 = dwLoc0C_119;
}

// 08048C08: void frame_init(Stack (ptr32 Eq_396) dwArg04)
void frame_init(Eq_396 * dwArg04)
{
	uint32 dwLoc10_114;
	union Eq_246 * eax_21 = dwArg04->ptr000C;
	if (eax_21 != null)
	{
		union Eq_246 * esi_113 = eax_21;
		dwLoc10_114 = 0x00;
		if (*eax_21 != 0x00)
		{
			do
			{
				dwLoc10_114 += count_fdes(*esi_113);
				esi_113 = (union Eq_246 *) ((char *) esi_113 + 0x04);
			} while (*esi_113 != 0x00);
		}
	}
	else
		dwLoc10_114 = count_fdes(dwArg04->ptr0008);
	dwArg04->dw0010 = dwLoc10_114;
	union Eq_246 * eax_34 = malloc(dwLoc10_114 << 0x02);
	union Eq_246 * eax_42 = dwArg04->ptr000C;
	if (eax_42 != null)
	{
		union Eq_246 * esi_69 = eax_42;
		if (*eax_42 != 0x00)
		{
			do
			{
				add_fdes(*esi_69, eax_34, fp - 0x10, fp - 0x0C, fp - 0x08);
				esi_69 = (union Eq_246 *) ((char *) esi_69 + 0x04);
			} while (*esi_69 != 0x00);
		}
	}
	else
		add_fdes(dwArg04->ptr0008, eax_34, fp - 0x10, fp - 0x0C, fp - 0x08);
	dwArg04->ptr000C = eax_34;
	dwArg04->ptr0000 = (ui32 *) ~0x00;
	dwArg04->ptr0004 = null;
}

// 08048CF4: Register (ptr32 Eq_494) find_fde(Stack (ptr32 ui32) dwArg04)
Eq_494 * find_fde(ui32 * dwArg04)
{
	struct Eq_494 * eax_115;
	struct Eq_396 * esi_118 = globals->ptr804ACC8;
	if (esi_118 != null)
	{
		do
		{
			if (esi_118->ptr0000 == null)
				frame_init(esi_118);
			if (esi_118->ptr0000 <= dwArg04 && esi_118->ptr0004 > dwArg04)
				break;
			esi_118 = esi_118->ptr0014;
		} while (esi_118 != null);
		if (esi_118 != null)
		{
			uint32 ecx_86 = esi_118->dw0010;
			uint32 edi_106 = 0x00;
			uint32 dwLoc08_104 = ecx_86;
			if (0x00 < ecx_86)
			{
				union Eq_246 * esi_90 = esi_118->ptr000C;
				do
				{
					uint32 eax_95 = dwLoc08_104 + edi_106;
					struct Eq_494 * ecx_98 = *((char *) esi_90 + (eax_95 >> 0x01) * 0x04);
					ui32 * eax_100 = ecx_98->ptr0008;
					if (dwArg04 < eax_100)
						dwLoc08_104 = eax_95 >> 0x01;
					else
					{
						if (dwArg04 <= eax_100 + ecx_98->dw000C)
						{
							eax_115 = ecx_98;
							return eax_115;
						}
						edi_106 = (eax_95 >> 0x01) + 0x01;
					}
				} while (dwLoc08_104 > edi_106);
			}
		}
	}
	eax_115 = null;
	return eax_115;
}

// 08048D94: Register ptr32 extract_cie_info(Stack (ptr32 Eq_565) dwArg04, Stack (ptr32 Eq_566) dwArg08)
ptr32 extract_cie_info(Eq_565 * dwArg04, Eq_566 * dwArg08)
{
	struct Eq_567 * edx_23 = dwArg04 - (dwArg04->dw0004 + ~0x03);
	dwArg08->ptr0000 = (byte *) &edx_23->b0009;
	byte al_31 = (byte) 0x080495BC;
	byte * esi_237 = &edx_23->b0009;
	word32 ecx_239 = 0x01;
	byte * edi_238 = &globals->b80495BC;
	bool Z_235 = (bool) cond(al_31 & 0x00);
	while (ecx_239 != 0x00)
	{
		Z_235 = (bool) cond(*esi_240 - *edi_241);
		esi_237 = esi_240 + 0x01;
		edi_238 = edi_241 + 0x01;
		--ecx_239;
		byte * esi_240 = esi_237;
		byte * edi_241 = edi_238;
		if (*esi_240 == *edi_241)
			break;
	}
	ptr32 eax_163;
	if (!Z_235)
	{
		byte * esi_194 = &edx_23->b0009;
		byte * edi_195 = &globals->b80495BD;
		word32 ecx_196 = 0x03;
		bool Z_199 = (bool) cond(al_31 & 0x00);
		while (ecx_196 != 0x00)
		{
			Z_199 = (bool) cond(*esi_245 - *edi_246);
			esi_194 = esi_245 + 0x01;
			edi_195 = edi_246 + 0x01;
			--ecx_196;
			byte * esi_245 = esi_194;
			byte * edi_246 = edi_195;
			if (*esi_245 == *edi_246)
				break;
		}
		if (!Z_199 && edx_23->b0009 != 122)
		{
			eax_163 = 0x00;
			return eax_163;
		}
	}
	byte * eax_84 = dwArg08->ptr0000;
	byte * edi_192 = eax_84;
	word32 ecx_193 = ~0x00;
	while (ecx_193 != 0x00)
	{
		edi_192 = edi_242 + 0x01;
		--ecx_193;
		byte * edi_242 = edi_192;
		if (0x00 != *edi_242)
			break;
	}
	struct Eq_670 * eax_102 = eax_84 - 0x01 + ~ecx_193;
	byte * edx_106 = &eax_102->dw0001;
	byte * esi_107 = eax_84;
	byte * edi_109 = &globals->b80495BD;
	word32 ecx_111 = 0x03;
	bool Z_114 = (bool) cond((byte) eax_102 & 0x00);
	while (ecx_111 != 0x00)
	{
		Z_114 = (bool) cond(*esi_243 - *edi_244);
		esi_107 = esi_243 + 0x01;
		edi_109 = edi_244 + 0x01;
		--ecx_111;
		byte * esi_243 = esi_107;
		byte * edi_244 = edi_109;
		if (*esi_243 == *edi_244)
			break;
	}
	if (!Z_114)
	{
		dwArg08->dw0004 = eax_102->dw0001;
		edx_106 = (byte *) (&eax_102->dw0001 + 0x01);
	}
	else
		dwArg08->dw0004 = 0x00;
	byte * eax_148 = decode_sleb128(decode_uleb128(edx_106, &dwArg08->dw0004 + 0x01), &dwArg08->dw0004 + 0x02);
	dwArg08->dw0010 = (word32) *eax_148;
	ptr32 edx_153 = eax_148 + 0x01;
	if (*dwArg08->ptr0000 == 122)
		edx_153 = decode_uleb128(eax_148 + 0x01, fp - 0x08) + dwLoc08;
	eax_163 = edx_153;
	return eax_163;
}

// 08048EAC: Register (ptr32 byte) execute_cfa_insn(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08, Stack (ptr32 Eq_779) dwArg0C, Stack (ptr32 word32) dwArg10)
byte * execute_cfa_insn(byte * dwArg04, ui32 * dwArg08, Eq_779 * dwArg0C, word32 * dwArg10)
{
	uint32 eax_25 = (word32) *dwArg04;
	ci8 al_26 = (byte) eax_25;
	byte * dwArg04_106 = dwArg04 + 0x01;
	if ((eax_25 & 0x40) == 0x00)
	{
		if (al_26 >= 0x00)
		{
			if ((al_26 & 0xC0) == 0x00)
			{
				if (eax_25 > 0x2E)
					abort();
				else
				{
					<anonymous> * ecx_134 = 0x0804A5C0 - (globals->a8048F6C)[eax_25 * 0x04];
					word32 esp_136;
					word32 ebp_137;
					byte SCZO_138;
					word32 edi_139;
					word32 esi_140;
					word32 ebx_141;
					word32 edx_142;
					word32 ecx_143;
					byte * eax_144;
					byte SZO_145;
					bool C_146;
					bool Z_147;
					byte al_148;
					byte SO_149;
					byte cl_150;
					byte CZ_151;
					ecx_134();
					return eax_144;
				}
			}
			else
			{
				Mem129[(eax_25 & 0x3F) + 0x5C + dwArg08:byte] = bLoc14;
				return dwArg04_106;
			}
		}
		else
		{
			dwArg04_106 = decode_uleb128(dwArg04 + 0x01, fp - 0x08);
			int32 eax_108 = dwLoc08 *s dwArg0C->dw000C;
			dwArg08[(word32) (eax_25 & 0x3F) + 0x005C] = (ui32) 0x01;
			Mem118[(eax_25 & 0x3F) * 0x04 + 0x10 + dwArg08:word32] = eax_108;
			return dwArg04_106;
		}
	}
	else
	{
		*dwArg10 += (eax_25 & 0x3F) *s dwArg0C->dw0008;
		return dwArg04_106;
	}
}

// 0804923C: void __register_frame_info(Stack ptr32 dwArg04, Stack (ptr32 Eq_83) dwArg08)
void __register_frame_info(ptr32 dwArg04, Eq_83 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->dw000C = 0x00;
	dwArg08->dw0010 = 0x00;
	dwArg08->dw0014 = globals->ptr804ACC8;
	globals->ptr804ACC8 = dwArg08;
}

// 08049284: void __register_frame_info_table(Stack word32 dwArg04, Stack (ptr32 Eq_906) dwArg08)
void __register_frame_info_table(word32 dwArg04, Eq_906 * dwArg08)
{
	dwArg08->dw0008 = dwArg04;
	dwArg08->dw000C = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->dw0010 = 0x00;
	dwArg08->dw0014 = globals->ptr804ACC8;
	globals->ptr804ACC8 = dwArg08;
}

// 080492C8: void __deregister_frame_info(Stack ptr32 dwArg04)
void __deregister_frame_info(ptr32 dwArg04)
{
	struct Eq_936 * ecx_13 = &globals->ptr804ACC8;
	if (globals->ptr804ACC8 != 0x00)
	{
		do
		{
			struct Eq_946 * edx_23 = ecx_13->dw0000;
			if (edx_23->ptr0008 == dwArg04)
			{
				ecx_13->dw0000 = edx_23->dw0014;
				if (edx_23->dw0000 != 0x00)
					free(edx_23->ptr000C);
				return;
			}
			ecx_13 = (struct Eq_936 *) &edx_23->dw0014;
		} while (edx_23->dw0014 != 0x00);
	}
	abort();
}

// 08049320: void __frame_state_for(Register word32 ebp, Stack (ptr32 ui32) dwArg04)
void __frame_state_for(word32 ebp, ui32 * dwArg04)
{
	struct Eq_565 * eax_23 = find_fde(dwArg04);
	if (eax_23 != null)
	{
		up32 eax_76 = extract_cie_info(eax_23, fp - 0x18);
		up32 esi_189 = eax_76;
		if (eax_76 != 0x00)
		{
			memset(fp - 0x8C, 0x00, 116);
			word32 * ecx_102 = eax_23 - (eax_23->dw0004 + ~0x03);
			up32 eax_104 = ecx_102 + *ecx_102;
			if (eax_76 < eax_104 + 0x04)
			{
				do
				{
					*(fp - 188) = 0x00;
					*(fp - 0xC0) = *(fp - 0xA4);
					*(fp - 0xC4) = *(fp - 0xA8);
					*(fp - 200) = esi_189;
					up32 eax_200 = execute_cfa_insn(dwArg00, dwArg04, dwArg08, dwArg0C);
					esi_189 = eax_200;
				} while (eax_200 < eax_104 + 0x04);
			}
			word32 esi_113 = *(fp - 0x98);
			up32 esi_114 = esi_113 + 0x10;
			if (**(fp - 0x18) == 122)
			{
				*(fp - 188) = fp - 0x90;
				*(fp - 0xC0) = esi_113 + 0x10;
				esi_114 = decode_uleb128(dwArg00, dwArg04) + *(fp - 0x90);
			}
			word32 * eax_120 = *(fp - 0x98);
			up32 eax_121 = eax_120 + *eax_120;
			*(fp - 0x94) = *((char *) *(fp - 0x98) + 0x08);
			if (esi_114 < eax_121 + 0x04)
			{
				*(fp - 0xAC) = fp - 0x94;
				while (*(fp - 0x94) <= fp->dw0004)
				{
					*(fp - 188) = *(fp - 0xAC);
					*(fp - 0xC0) = fp - 0x18;
					*(fp - 0xC4) = fp - 0x8C;
					*(fp - 200) = esi_114;
					up32 eax_169 = execute_cfa_insn(dwArg00, dwArg04, dwArg08, dwArg0C);
					esi_114 = eax_169;
					if (eax_169 >= eax_121 + 0x04)
						break;
				}
			}
			word32 * edi_133 = fp->ptr0008;
			word32 * esi_134 = fp - 0x8C;
			word32 ecx_136;
			for (ecx_136 = 0x1C; ecx_136 != 0x00; --ecx_136)
			{
				*edi_133 = *esi_134;
				++esi_134;
				++edi_133;
			}
		}
	}
}

// 0804948C: void __do_global_ctors_aux()
void __do_global_ctors_aux()
{
	word32 * esi_15 = &globals->dw804A698;
	if (globals->dw804A698 != ~0x00)
	{
		do
		{
			<anonymous> * eax_30 = *esi_15;
			word32 esp_31;
			word32 ebp_32;
			struct Eq_1216 * esi_33;
			word32 ebx_34;
			byte SCZO_35;
			word32 eax_36;
			bool Z_37;
			eax_30();
			esi_15 = (word32 *) &esi_33->dwFFFFFFFC;
		} while (esi_33->dwFFFFFFFC != ~0x00);
	}
}

// 080494C0: void init_dummy()
void init_dummy()
{
}

// 080494E0: void _init()
void _init()
{
	frame_dummy();
	__do_global_ctors_aux();
}

// 08049510: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

