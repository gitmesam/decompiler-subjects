// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048840: void _start(Register (ptr Eq_2) edx, Stack ui32 dwArg00)
void _start( * edx, ui32 dwArg00)
{
	if (0x080487A0 != 0x00)
		atexit(&globals->t80487A0);
	if (0x0804A5F4 != 0x00)
		atexit(edx);
	atexit(&globals->t8049510);
	globals->ptr804ACCC = fp + 0x08 + dwArg00 * 0x04;
	_init();
	word32 esp_36;
	word32 ebp_37;
	word32 edx_38;
	word32 eax_39;
	byte SZO_40;
	byte C_41;
	byte Z_42;
	byte SCZO_43;
	!__fpstart();
	exit(main());
}

// 080488AF: void _mcount()
void _mcount()
{
}

// 080488B0: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	struct Eq_47 * ebx_10 = &globals->t804A5C0;
	while (true)
	{
		<anonymous> ** eax_18 = ebx_10->ptr00CC;
		if (*eax_18 == null)
			break;
		ebx_10->ptr00CC = (<anonymous> **) ((char *) eax_18 + 0x04);
		<anonymous> * eax_30 = *eax_18;
		word32 esp_32;
		word32 ebp_33;
		byte SCZO_35;
		word32 eax_36;
		byte Z_37;
		word32 edx_38;
		eax_30();
	}
	__deregister_frame_info((char *) &ebx_10->ptr00CC + 0x0014);
}

// 080488F0: void fini_dummy()
void fini_dummy()
{
}

// 08048908: void frame_dummy()
void frame_dummy()
{
	__register_frame_info(0x0804A6A0, &globals->t804ACB0);
}

// 08048930: void init_dummy()
void init_dummy()
{
}

// 08048948: Register word32 main()
word32 main()
{
	scanf("%d", tLoc20);
	scanf("%d", tLoc28);
	if (dwLoc08 == 0x05)
		printf("Equal\n");
	if (dwLoc08 != 0x05)
	{
		printf("Not Equal\n");
		if (dwLoc08 < 0x05)
		{
			printf("Greater\n");
			if (dwLoc08 < 0x05)
			{
l080489C3:
				printf("Greater or Equal\n");
				if (dwLoc08 <= 0x05)
					goto l080489E2;
l080489D5:
				printf("Less\n");
l080489E2:
				if (dwLoc0C < 0x05)
				{
					printf("Greater Unsigned\n");
					if (dwLoc0C < 0x05)
					{
l08048A0B:
						printf("Carry Clear\n");
						if (dwLoc0C <= 0x05)
							goto l08048A2A;
l08048A1D:
						printf("Carry Set\n");
l08048A2A:
						if (0x05 - dwLoc08 >= 0x00)
						{
							printf("Minus\n");
							if (0x05 - dwLoc08 >= 0x00)
								return 0x00;
						}
						printf("Plus\n");
						return 0x00;
					}
				}
				printf("Less or Equal Unsigned\n");
				if (dwLoc0C > 0x05)
					goto l08048A1D;
				goto l08048A0B;
			}
		}
	}
	printf("Less or Equal\n");
	if (dwLoc08 > 0x05)
		goto l080489D5;
	goto l080489C3;
}

// 08048A58: Register (ptr byte) decode_uleb128(Stack (ptr byte) dwArg04, Stack (ptr ui32) dwArg08)
byte * decode_uleb128(byte * dwArg04, ui32 * dwArg08)
{
	ui32 edi_12 = 0x00;
	word32 esi_15 = 0x00;
	while (true)
	{
		byte * ecx_26 = dwArg04 + 0x01;
		ui32 edx_24 = (word32) *dwArg04;
		dwArg04 = ecx_26;
		edi_12 = edi_12 | (edx_24 & 0x7F) << (byte) esi_15;
		if ((byte) edx_24 >= 0x00)
			break;
		esi_15 = esi_15 + 0x07;
	}
	*dwArg08 = edi_12;
	return ecx_26;
}

// 08048A94: Register (ptr byte) decode_sleb128(Stack (ptr byte) dwArg04, Stack (ptr uint32) dwArg08)
byte * decode_sleb128(byte * dwArg04, uint32 * dwArg08)
{
	byte * edi_15 = dwArg04;
	uint32 dwLoc08_16 = 0x00;
	uint32 ecx_17 = 0x00;
	byte cl_18 = 0x00;
	do
	{
		ui32 esi_24 = (word32) *edi_15;
		uint32 v12_29 = dwLoc08_16 | (esi_24 & 0x7F) << cl_18;
		ecx_17 = ecx_17 + 0x07;
		edi_15 = edi_15 + 0x01;
		dwLoc08_16 = v12_29;
		cl_18 = (byte) ecx_17;
	} while ((byte) esi_24 < 0x00);
	if (ecx_17 <= 0x1F && (esi_24 & 0x40) != 0x00)
		dwLoc08_16 = v12_29 | ~0x00 << cl_18;
	*dwArg08 = dwLoc08_16;
	return edi_15;
}

// 08048AF0: void fde_insert(Stack (ptr Eq_245) dwArg04, Stack ui32 dwArg08, Stack (ptr Eq_247) dwArg0C)
void fde_insert(Eq_245 * dwArg04, ui32 dwArg08, Eq_247 * dwArg0C)
{
}

// 08048B48: Register word32 count_fdes(Stack (ptr Eq_247) dwArg04)
word32 count_fdes(Eq_247 * dwArg04)
{
	struct Eq_247 * edx_25 = dwArg04;
	word32 ecx_13 = 0x00;
	if (dwArg04->dw0000 != 0x00)
	{
		do
		{
			if (edx_25[0x01] != 0x00 && edx_25[0x02] != 0x00)
				ecx_13 = ecx_13 + 0x01;
			struct Eq_301 * eax_32 = edx_25 + edx_25->dw0000 / 0x04;
			edx_25 = (struct Eq_247 *) &eax_32->dw0004;
		} while (eax_32->dw0004 != 0x00);
	}
	return ecx_13;
}

// 08048B78: void add_fdes(Stack (ptr Eq_247) dwArg04, Stack (ptr Eq_245) dwArg08, Stack (ptr ui32) dwArg0C, Stack (ptr up32) dwArg10, Stack (ptr up32) dwArg14)
void add_fdes(Eq_247 * dwArg04, Eq_245 * dwArg08, ui32 * dwArg0C, up32 * dwArg10, up32 * dwArg14)
{
	struct Eq_247 * esi_19 = dwArg04;
	ui32 edi_105 = *dwArg0C;
	up32 dwLoc08_115 = *dwArg10;
	up32 dwLoc0C_119 = *dwArg14;
	if (dwArg04->dw0000 != 0x00)
	{
		do
		{
			if (esi_19[0x01] != 0x00 && esi_19[0x02] != 0x00)
			{
				fde_insert(dwArg08, edi_105, esi_19);
				edi_105 = edi_105 + 0x01;
				up32 eax_111 = esi_19[0x02];
				if (dwLoc08_115 > eax_111)
					dwLoc08_115 = eax_111;
				up32 eax_116 = (word32) esi_19[0x03].dw0000 + eax_111;
				if (dwLoc0C_119 < eax_116)
					dwLoc0C_119 = eax_116;
			}
			struct Eq_357 * eax_95 = esi_19 + esi_19->dw0000 / 0x04;
			esi_19 = (struct Eq_247 *) &eax_95->dw0004;
		} while (eax_95->dw0004 != 0x00);
	}
	*dwArg0C = edi_105;
	*dwArg10 = dwLoc08_115;
	*dwArg14 = dwLoc0C_119;
}

// 08048C08: void frame_init(Stack (ptr Eq_395) dwArg04)
void frame_init(Eq_395 * dwArg04)
{
	uint32 dwLoc10_114;
	union Eq_245 * eax_21 = dwArg04->ptr000C;
	if (eax_21 != null)
	{
		union Eq_245 * esi_113 = eax_21;
		dwLoc10_114 = 0x00;
		if (*eax_21 != 0x00)
		{
			do
			{
				dwLoc10_114 = dwLoc10_114 + count_fdes(*esi_113);
				esi_113 = (union Eq_245 *) ((char *) esi_113 + 0x04);
			} while (*esi_113 != 0x00);
		}
	}
	else
		dwLoc10_114 = count_fdes(dwArg04->ptr0008);
	dwArg04->dw0010 = dwLoc10_114;
	union Eq_245 * eax_34 = malloc(dwLoc10_114 << 0x02);
	union Eq_245 * eax_42 = dwArg04->ptr000C;
	if (eax_42 != null)
	{
		union Eq_245 * esi_69 = eax_42;
		if (*eax_42 != 0x00)
		{
			do
			{
				add_fdes(*esi_69, eax_34, fp - 0x10, fp - 0x0C, fp - 0x08);
				esi_69 = (union Eq_245 *) ((char *) esi_69 + 0x04);
			} while (*esi_69 != 0x00);
		}
	}
	else
		add_fdes(dwArg04->ptr0008, eax_34, fp - 0x10, fp - 0x0C, fp - 0x08);
	dwArg04->ptr000C = eax_34;
	dwArg04->ptr0000 = (ui32 *) ~0x00;
	dwArg04->ptr0004 = null;
}

// 08048CF4: Register (ptr Eq_493) find_fde(Stack (ptr ui32) dwArg04)
Eq_493 * find_fde(ui32 * dwArg04)
{
}

// 08048D94: Register ptr32 extract_cie_info(Stack (ptr Eq_564) dwArg04, Stack (ptr Eq_565) dwArg08)
ptr32 extract_cie_info(Eq_564 * dwArg04, Eq_565 * dwArg08)
{
}

// 08048EAC: Register (ptr byte) execute_cfa_insn(Stack (ptr byte) dwArg04, Stack (ptr ui32) dwArg08, Stack (ptr Eq_772) dwArg0C, Stack (ptr word32) dwArg10)
byte * execute_cfa_insn(byte * dwArg04, ui32 * dwArg08, Eq_772 * dwArg0C, word32 * dwArg10)
{
	uint32 eax_25 = (word32) *dwArg04;
	ci8 al_26 = (byte) eax_25;
	byte * dwArg04_106 = dwArg04 + 0x01;
	if ((eax_25 & 0x40) == 0x00)
	{
		if (al_26 >= 0x00)
		{
			if ((al_26 & 0xC0) == 0x00)
			{
				if (eax_25 > 0x2E)
					abort();
				else
				{
					<anonymous> * ecx_134 = 0x0804A5C0 - (globals->a8048F6C)[eax_25 * 0x04];
					word32 esp_136;
					word32 ebp_137;
					byte SCZO_138;
					word32 edi_139;
					word32 esi_140;
					word32 ebx_141;
					word32 edx_142;
					word32 ecx_143;
					byte * eax_144;
					byte SZO_145;
					byte C_146;
					byte Z_147;
					byte al_148;
					byte SO_149;
					byte cl_150;
					byte CZ_151;
					ecx_134();
					return eax_144;
				}
			}
			else
			{
				Mem129[(eax_25 & 0x3F) + 0x5C + dwArg08:byte] = bLoc14;
				return dwArg04_106;
			}
		}
		else
		{
			dwArg04_106 = decode_uleb128(dwArg04 + 0x01, fp - 0x08);
			int32 eax_108 = dwLoc08 *s dwArg0C->dw000C;
			dwArg08[(word32) (eax_25 & 0x3F) + 0x005C] = (ui32) 0x01;
			Mem118[(eax_25 & 0x3F) * 0x04 + 0x10 + dwArg08:word32] = eax_108;
			return dwArg04_106;
		}
	}
	else
	{
		*dwArg10 = *dwArg10 + (eax_25 & 0x3F) *s dwArg0C->dw0008;
		return dwArg04_106;
	}
}

// 0804923C: void __register_frame_info(Stack ptr32 dwArg04, Stack (ptr Eq_82) dwArg08)
void __register_frame_info(ptr32 dwArg04, Eq_82 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->dw000C = 0x00;
	dwArg08->dw0010 = 0x00;
	dwArg08->dw0014 = globals->ptr804ACC8;
	globals->ptr804ACC8 = dwArg08;
}

// 08049284: void __register_frame_info_table(Stack word32 dwArg04, Stack (ptr Eq_899) dwArg08)
void __register_frame_info_table(word32 dwArg04, Eq_899 * dwArg08)
{
	dwArg08->dw0008 = dwArg04;
	dwArg08->dw000C = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->dw0010 = 0x00;
	dwArg08->dw0014 = globals->ptr804ACC8;
	globals->ptr804ACC8 = dwArg08;
}

// 080492C8: void __deregister_frame_info(Stack ptr32 dwArg04)
void __deregister_frame_info(ptr32 dwArg04)
{
}

// 08049320: void __frame_state_for(Register word32 ebp, Stack (ptr ui32) dwArg04)
void __frame_state_for(word32 ebp, ui32 * dwArg04)
{
}

// 0804948C: void __do_global_ctors_aux()
void __do_global_ctors_aux()
{
	word32 * esi_15 = &globals->dw804A698;
	if (globals->dw804A698 != ~0x00)
	{
		do
		{
			<anonymous> * eax_30 = *esi_15;
			word32 esp_31;
			word32 ebp_32;
			struct Eq_1209 * esi_33;
			word32 ebx_34;
			byte SCZO_35;
			word32 eax_36;
			byte Z_37;
			eax_30();
			esi_15 = (word32 *) &esi_33->dwFFFFFFFC;
		} while (esi_33->dwFFFFFFFC != ~0x00);
	}
}

// 080494C0: void init_dummy()
void init_dummy()
{
}

// 080494E0: void _init()
void _init()
{
	frame_dummy();
	__do_global_ctors_aux();
}

// 08049510: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

