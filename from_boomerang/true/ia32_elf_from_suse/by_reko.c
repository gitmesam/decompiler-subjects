// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_fini.h"

// 08049EF4: void _fini()
// Called from:
//      __libc_csu_fini
void _fini()
{
	__do_global_dtors_aux();
}

// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_init.h"

// 080487B0: void _init(Register word32 ecx, Register word32 edx)
// Called from:
//      __libc_csu_init
void _init(word32 ecx, word32 edx)
{
	call_gmon_start(edx);
	__do_global_ctors_aux(frame_dummy(ecx));
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_plt.h"

// 080487D8: void __fpending()
void __fpending()
{
}

// 080487E8: void __overflow()
void __overflow()
{
}

// 080487F8: void fputs_unlocked()
void fputs_unlocked()
{
}

// 08048808: void fprintf()
void fprintf()
{
}

// 08048818: void getenv()
void getenv()
{
}

// 08048828: void dcgettext()
void dcgettext()
{
}

// 08048838: void setlocale()
void setlocale()
{
}

// 08048848: void __cxa_atexit()
void __cxa_atexit()
{
}

// 08048858: void __errno_location()
void __errno_location()
{
}

// 08048868: void malloc()
void malloc()
{
}

// 08048878: void abort()
void abort()
{
}

// 08048888: void vfprintf()
void vfprintf()
{
}

// 08048898: void bindtextdomain()
void bindtextdomain()
{
}

// 080488A8: void strlen()
void strlen()
{
}

// 080488B8: void mbrtowc()
void mbrtowc()
{
}

// 080488C8: void __libc_start_main()
void __libc_start_main()
{
}

// 080488D8: void realloc()
void realloc()
{
}

// 080488E8: void textdomain()
void textdomain()
{
}

// 080488F8: void printf()
void printf()
{
}

// 08048908: void memcpy()
void memcpy()
{
}

// 08048918: void fclose()
void fclose()
{
}

// 08048928: void __ctype_get_mb_cur_max()
void __ctype_get_mb_cur_max()
{
}

// 08048938: void exit()
void exit()
{
}

// 08048948: void calloc()
void calloc()
{
}

// 08048958: void iswprint()
void iswprint()
{
}

// 08048968: void free()
void free()
{
}

// 08048978: void memset()
void memset()
{
}

// 08048988: void mbsinit()
void mbsinit()
{
}

// 08048998: void error()
void error()
{
}

// 080489A8: void __ctype_b_loc()
void __ctype_b_loc()
{
}

// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text.h"

// 080489C0: void _start(Register (ptr32 Eq_16) edx, Stack int32 dwArg00)
void _start(void (* edx)(), int32 dwArg00)
{
	__align((char *) fp + 4);
	__libc_start_main(&g_t8048B60, dwArg00, (char *) fp + 4, &g_t8049E30, &g_t8049DC0, edx, fp);
	__hlt();
}

// 080489E4: void call_gmon_start(Register word32 edx)
// Called from:
//      _init
void call_gmon_start(word32 edx)
{
	<anonymous> * eax_16 = g_ptr804B748;
	if (eax_16 != null)
		eax_16();
}

// 08048A10: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b804B804 == 0x00)
	{
		<anonymous> ** eax_15 = g_ptr804B7D0;
		<anonymous> * edx_16 = *eax_15;
		while (edx_16 != null)
		{
			<anonymous> ** eax_23 = (char *) eax_15 + 4;
			g_ptr804B7D0 = eax_23;
			edx_16();
			eax_15 = g_ptr804B7D0;
			edx_16 = (<anonymous> *) *eax_15;
		}
		g_b804B804 = 0x01;
	}
}

// 08048A50: Register word32 frame_dummy(Register word32 ecx)
// Called from:
//      _init
word32 frame_dummy(word32 ecx)
{
	word32 edx_13 = g_dw804B670;
	if (edx_13 != 0x00 && 0x00 != 0x00)
	{
		word32 eax_27;
		fn00000000();
	}
	return edx_13;
}

// 08048A80: void usage(Stack int32 dwArg04)
// Called from:
//      main
void usage(int32 dwArg04)
{
	printf(dcgettext(null, "Usage: %s [ignored command line arguments]\n  or:  %s OPTION\nExit with a status code indicating success.\n\nThese option names may not be abbreviated.\n\n", 0x05), 0x00);
	fputs_unlocked(dcgettext(null, "      --help     display this help and exit\n", 0x05), g_ptr804B800);
	fputs_unlocked(dcgettext(null, "      --version  output version information and exit\n", 0x05), g_ptr804B800);
	printf(dcgettext(null, "\nReport bugs to <%s>.\n", 0x05), 0x00);
	exit(dwArg04);
}

// 08048B60: void main(Stack word32 dwArg04, Stack (ptr32 Eq_136) dwArg08)
void main(word32 dwArg04, struct Eq_136 * dwArg08)
{
	__align(fp - 44);
	g_dw804B948 = dwArg08->dw0000;
	setlocale(0x06, "");
	bindtextdomain("coreutils", "/usr/share/locale");
	textdomain("coreutils");
	atexit(&g_t8048C80);
	if (dwArg04 == 0x02)
	{
		char * eax_40 = getenv("POSIXLY_CORRECT");
		bool Z_43 = SLICE(cond(eax_40), bool, 2);
		if (eax_40 == null)
		{
			byte * eax_45 = dwArg08->ptr0004;
			byte * edi_46 = &g_b804A075;
			byte * esi_48 = eax_45;
			word32 ecx_50 = 0x07;
			while (ecx_50 != 0x00)
			{
				Z_43 = SLICE(cond(*esi_133 - *edi_134), bool, 2);
				esi_48 = esi_133 + 1;
				edi_46 = edi_134 + 1;
				--ecx_50;
				esi_133 = esi_48;
				edi_134 = edi_46;
				if (*esi_133 == *edi_134)
					break;
			}
			if (Z_43)
				usage(0x00);
			byte * esi_69 = eax_45;
			byte * edi_71 = &g_b804A07C;
			word32 ecx_72 = 0x0A;
			while (ecx_72 != 0x00)
			{
				Z_43 = SLICE(cond(*esi_135 - *edi_136), bool, 2);
				esi_69 = esi_135 + 1;
				edi_71 = edi_136 + 1;
				--ecx_72;
				esi_135 = esi_69;
				edi_136 = edi_71;
				if (*esi_135 == *edi_136)
					break;
			}
			if (!Z_43)
				version_etc(g_ptr804B800, "true", "GNU coreutils", "5.2.1");
		}
	}
	exit(0x00);
}

// 08048C70: void close_stdout_set_file_name(Stack Eq_269 dwArg04)
void close_stdout_set_file_name(Eq_269 dwArg04)
{
	g_t804B808 = dwArg04;
}

// 08048C80: void close_stdout()
void close_stdout()
{
	FILE * edx_15 = g_ptr804B800;
	int32 ebx_21 = 0x00 - ((*edx_15 >> 0x05 & 0x01) < 0x01);
	if (ebx_21 != 0x00)
	{
		if (__fpending(edx_15) == 0x00)
			return;
		edx_15 = g_ptr804B800;
	}
	if (fclose(edx_15) != 0x00)
		ebx_21 = *__errno_location();
	if (ebx_21 < 0x00)
		return;
	dcgettext(null, "write error", 0x05);
	Eq_269 eax_53 = g_t804B808;
	if (eax_53 == 0x00)
		error(g_dw804B7D4, ebx_21, "%s", 0x00);
	else
	{
		quotearg_colon(eax_53);
		error(g_dw804B7D4, ebx_21, "%s: %s", 0x00);
	}
}

// 08048D50: void get_quoting_style(Stack word32 dwArg04)
void get_quoting_style(word32 dwArg04)
{
	if (dwArg04 == 0x00)
		;
}

// 08048D70: void set_quoting_style(Stack (ptr32 word32) dwArg04, Stack word32 dwArg08)
void set_quoting_style(word32 * dwArg04, word32 dwArg08)
{
	if (dwArg04 == null)
		g_dw804B920 = dwArg08;
	else
		*dwArg04 = dwArg08;
}

// 08048D90: void set_char_quoting(Stack ptr32 dwArg04, Stack byte bArg08, Stack ui32 dwArg0C)
// Called from:
//      quotearg_char
void set_char_quoting(ptr32 dwArg04, byte bArg08, ui32 dwArg0C)
{
	ui32 ecx_16 = (word32) bArg08;
	ui32 edx_20 = (word32) ((byte) ecx_16 >> 0x05);
	int32 * esi_24 = (edx_20 << 0x02) + 0x04 + dwArg04;
	if (dwArg04 == 0x00)
	{
		int32 * esi_26 = (edx_20 << 0x02) + 0x0804B924;
		int32 edx_27 = *esi_26;
		byte cl_31 = (byte) (ecx_16 & 0x1F);
		*esi_26 = edx_27 ^ (dwArg0C & 0x01 ^ edx_27 >> cl_31 & 0x01) << cl_31;
	}
	else
	{
		int32 edx_46 = *esi_24;
		byte cl_50 = (byte) (ecx_16 & 0x1F);
		*esi_24 = edx_46 ^ (dwArg0C & 0x01 ^ edx_46 >> cl_50 & 0x01) << cl_50;
	}
}

// 08048E00: void clone_quoting_options(Stack (ptr32 Eq_413) dwArg04)
void clone_quoting_options(struct Eq_413 * dwArg04)
{
	int32 * eax_16 = __errno_location();
	int32 esi_17 = *eax_16;
	struct Eq_421 * eax_20 = xmalloc(0x24);
	struct Eq_413 * edx_25 = dwArg04;
	if (dwArg04 == null)
		edx_25 = (struct Eq_413 *) &g_dw804B920;
	eax_20->dw0000 = edx_25->dw0000;
	eax_20->dw0004 = edx_25->dw0004;
	eax_20->dw0008 = edx_25->dw0008;
	eax_20->dw000C = edx_25->dw000C;
	eax_20->dw0010 = edx_25->dw0010;
	eax_20->dw0014 = edx_25->dw0014;
	eax_20->dw0018 = edx_25->dw0018;
	eax_20->dw001C = edx_25->dw001C;
	eax_20->dw0020 = edx_25->dw0020;
	*eax_16 = esi_17;
}

// 08048E70: void quoting_options_from_style(Register (ptr32 Eq_488) eax, Register word32 edx)
// Called from:
//      quotearg_n_style_mem
//      quotearg_n_style
void quoting_options_from_style(struct Eq_488 * eax, word32 edx)
{
	word32 ecx_12;
	word32 * edi_24 = fp - 0x38;
	for (ecx_12 = 0x08; ecx_12 != 0x00; --ecx_12)
	{
		*edi_24 = 0x00;
		++edi_24;
	}
	eax->dw0000 = edx;
	eax->dw0004 = dwLoc38;
	eax->dw0008 = dwLoc34;
	eax->dw000C = dwLoc30;
	eax->dw0010 = dwLoc2C;
	eax->dw0014 = dwLoc28;
	eax->dw0018 = dwLoc24;
	eax->dw001C = dwLoc20;
	eax->dw0020 = dwLoc1C;
}

// 08048ED0: Register (ptr32 char) gettext_quote(Register (ptr32 char) eax, Register up32 edx)
// Called from:
//      quotearg_buffer_restyled
char * gettext_quote(char * eax, up32 edx)
{
	ui24 edx_24_8_31 = SLICE(edx, word24, 8);
	char * eax_21 = dcgettext(null, eax, 0x05);
	char * ecx_23 = eax_21;
	if (((byte) (SEQ(SLICE(eax_21, word24, 8), edx == 0x06) & SEQ(edx_24_8_31, eax_21 == eax)) & 0x01) != 0x00)
		ecx_23 = (char *) "\"";
	return ecx_23;
}

// 08048F20: void quotearg_buffer_restyled(Register Eq_269 eax, Register Eq_269 ecx, Register Eq_269 edx, Stack Eq_269 dwArg04, Stack up32 dwArg08, Stack Eq_269 dwArg0C)
// Called from:
//      quotearg_buffer_restyled
//      quotearg_buffer
void quotearg_buffer_restyled(Eq_269 eax, Eq_269 ecx, Eq_269 edx, Eq_269 dwArg04, up32 dwArg08, Eq_269 dwArg0C)
{
}

// 08049560: void quotearg_buffer(Stack Eq_269 dwArg04, Stack Eq_269 dwArg08, Stack Eq_269 dwArg0C, Stack Eq_269 dwArg10, Stack Eq_269 dwArg14)
// Called from:
//      quotearg_n
void quotearg_buffer(Eq_269 dwArg04, Eq_269 dwArg08, Eq_269 dwArg0C, Eq_269 dwArg10, Eq_269 dwArg14)
{
	Eq_269 edi_11 = dwArg14;
	if (dwArg14 == 0x00)
		edi_11.u0 = 0x0804B920;
	int32 * eax_20 = __errno_location();
	int32 esi_22 = *eax_20;
	quotearg_buffer_restyled(dwArg04, dwArg0C, dwArg08, dwArg10, *edi_11.u0, edi_11);
	*eax_20 = esi_22;
}

// 080495C0: Register ptr32 quotearg_n_options(Register (arr Eq_1251) eax, Register Eq_269 edx)
// Called from:
//      quotearg_char
//      quotearg_n_style_mem
//      quotearg_n_style
//      quotearg_n
ptr32 quotearg_n_options(Eq_1251 eax[], Eq_269 edx)
{
	word32 eax_25 = *__errno_location();
	if (eax < null)
		abort();
	else
	{
		if (g_ptr804B7D8 <= eax)
		{
			if (eax > (Eq_1251 (*)[]) 0x1FFFFFFE)
			{
				xalloc_die();
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_269 stackArg4 = <invalid>;
				Eq_269 stackArg8 = <invalid>;
				quotearg_char(stackArg4, stackArg8);
				return fp - 4;
			}
			if (g_ptr804B7E4 == &g_t804B7DC)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_269 stackArg4 = <invalid>;
				xmalloc(stackArg4);
				g_ptr804B7E4 = eax;
				Eq_1251 eax_47 = g_t804B7DC.dw0000;
				*((word32) &eax[0].dw0000 + 4) = (Eq_1251 (*)[]) g_t804B7E0;
				eax[0].dw0000 = (word32) eax_47;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_269 stackArg4 = <invalid>;
			Eq_269 stackArg8 = <invalid>;
			xrealloc(stackArg4, stackArg8);
			Eq_1251 eax_54[] = (eax + 0x01) * 0x08;
			g_ptr804B7E4 = eax_54;
			Eq_1251 (* eax_59)[] = g_ptr804B7D8;
			word32 edx_61 = eax + 0x01 - eax_59;
			word32 * edi_147 = &(eax_54 + eax_59)->dw0000;
			uint32 eax_63 = edx_61 * 0x08;
			if (edx_61 * 0x08 > 0x07 && (edi_147 & 0x04) != 0x00)
			{
				*edi_147 = 0x00;
				eax_63 = edx_61 * 0x08 - 0x04;
				++edi_147;
			}
			uint32 ecx_150;
			for (ecx_150 = eax_63 >> 0x02; ecx_150 != 0x00; --ecx_150)
			{
				*edi_147 = 0x00;
				++edi_147;
			}
			Mem83[0x0804B7D8<p32>:word32] = eax + 0x01;
		}
		Eq_1251 eax_88[] = g_ptr804B7E4;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_269 esi_89 = eax_88[eax].dw0000;
		void * edi_90 = *((word32) &eax_88[eax].dw0000 + 4);
		Eq_269 stackArg4 = <invalid>;
		Eq_269 stackArg8 = <invalid>;
		Eq_269 stackArg12 = <invalid>;
		Eq_269 stackArg16 = <invalid>;
		Eq_269 stackArg20 = <invalid>;
		quotearg_buffer(stackArg4, stackArg8, stackArg12, stackArg16, stackArg20);
		if (esi_89 <= edx)
		{
			Eq_1251 ebx_103[] = g_ptr804B7E4;
			ebx_103[eax].dw0000 = (word32) edx + 1;
			if (edi_90 != &g_v804B820)
			{
				free(edi_90);
				ebx_103 = g_ptr804B7E4;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_269 stackArg4 = <invalid>;
			xmalloc(stackArg4);
			*((word32) &ebx_103[eax].dw0000 + 4) = (Eq_1251 (*)[]) edx;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_269 stackArg4 = <invalid>;
			Eq_269 stackArg8 = <invalid>;
			Eq_269 stackArg12 = <invalid>;
			Eq_269 stackArg16 = <invalid>;
			Eq_269 stackArg20 = <invalid>;
			quotearg_buffer(stackArg4, stackArg8, stackArg12, stackArg16, stackArg20);
		}
		*__errno_location() = eax_25;
		return ebp;
	}
}

// 08049750: void quotearg_char(Stack Eq_269 dwArg04, Stack Eq_269 bArg08)
// Called from:
//      quotearg_colon
//      quotearg_n
void quotearg_char(Eq_269 dwArg04, Eq_269 bArg08)
{
	set_char_quoting(fp - 0x3C, (byte) (int32) bArg08, 0x01);
	quotearg_n_options(null, dwArg04);
}

// 080497E0: void quotearg_colon(Stack Eq_269 dwArg04)
// Called from:
//      close_stdout
void quotearg_colon(Eq_269 dwArg04)
{
	quotearg_char(dwArg04, 0x3A);
}

// 08049800: void quotearg_n_style_mem(Stack (ptr32 (arr Eq_1251)) dwArg04, Stack word32 dwArg08, Stack Eq_269 dwArg0C)
void quotearg_n_style_mem(Eq_1251 (* dwArg04)[], word32 dwArg08, Eq_269 dwArg0C)
{
	quoting_options_from_style(fp - 0x3C, dwArg08);
	quotearg_n_options(dwArg04, dwArg0C);
}

// 08049830: void quotearg_n_style(Stack (ptr32 (arr Eq_1251)) dwArg04, Stack word32 dwArg08, Stack Eq_269 dwArg0C)
// Called from:
//      quotearg_style
void quotearg_n_style(Eq_1251 (* dwArg04)[], word32 dwArg08, Eq_269 dwArg0C)
{
	quoting_options_from_style(fp - 0x3C, dwArg08);
	quotearg_n_options(dwArg04, dwArg0C);
}

// 08049860: void quotearg_style(Stack word32 dwArg04, Stack Eq_269 dwArg08)
void quotearg_style(word32 dwArg04, Eq_269 dwArg08)
{
	quotearg_n_style(null, dwArg04, dwArg08);
}

// 08049890: Register word32 quotearg_n(Stack (ptr32 (arr Eq_1251)) dwArg04, Stack Eq_269 dwArg08)
// Called from:
//      quotearg
word32 quotearg_n(Eq_1251 (* dwArg04)[], Eq_269 dwArg08)
{
	return quotearg_n_options(dwArg04, dwArg08);
}

// 080498B0: void quotearg(Stack Eq_269 dwArg04)
void quotearg(Eq_269 dwArg04)
{
	quotearg_n(null, dwArg04);
}

// 080498D0: void version_etc_va(Stack (ptr32 Eq_105) dwArg04, Stack (ptr32 char) dwArg08, Stack (ptr32 char) dwArg0C, Stack (ptr32 char) dwArg10, Stack Eq_1335 dwArg14)
// Called from:
//      version_etc
void version_etc_va(FILE * dwArg04, char * dwArg08, char * dwArg0C, char * dwArg10, Eq_1335 dwArg14)
{
	up32 ebx_18 = 0x00;
	word32 * edx_25 = (word32) dwArg14 + 4;
	if (*dwArg14 != 0x00)
	{
		do
		{
			++ebx_18;
			edx_25 = edx_281 + 1;
			edx_281 = edx_25;
		} while (*edx_281 != 0x00);
	}
	if (dwArg08 != null)
		fprintf(dwArg04, "%s (%s) %s\n", dwArg08, dwArg0C, dwArg10);
	else
		fprintf(dwArg04, "%s %s\n", dwArg0C, dwArg10);
	char * dwLoc28_209;
	char * eax_100;
	if (ebx_18 <= 0x09)
	{
		switch (ebx_18)
		{
		case 0x00:
			abort();
		case 0x01:
			eax_100 = (char *) "Written by %s.\n";
			break;
		case 0x02:
			dwLoc28_209 = (char *) "Written by %s and %s.\n";
			goto l08049955;
		case 0x03:
			eax_100 = (char *) "Written by %s, %s, and %s.\n";
			break;
		case 0x04:
			eax_100 = (char *) "Written by %s, %s, %s,\nand %s.\n";
			break;
		case 0x05:
			eax_100 = (char *) "Written by %s, %s, %s,\n%s, and %s.\n";
			break;
		case 0x06:
			dwLoc28_209 = (char *) "Written by %s, %s, %s,\n%s, %s, and %s.\n";
			goto l08049955;
		case 0x07:
			dwLoc28_209 = (char *) "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n";
			goto l08049955;
		case 0x08:
			eax_100 = (char *) "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n";
			break;
		case 0x09:
			eax_100 = (char *) "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
			break;
		}
	}
	else
		eax_100 = (char *) "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
	dwLoc28_209 = eax_100;
l08049955:
	vfprintf(dwArg04, dcgettext(null, dwLoc28_209, 0x05), dwArg14);
	byte * eax_127 = dwArg04->ptr0014;
	if (eax_127 < dwArg04->ptr0018)
	{
		*eax_127 = 0x0A;
		++dwArg04->ptr0014;
	}
	else
		__overflow(dwArg04, 0x0A);
	fputs_unlocked(g_ptr804B7E8, dwArg04);
	byte * eax_144 = dwArg04->ptr0014;
	if (eax_144 < dwArg04->ptr0018)
	{
		*eax_144 = 0x0A;
		++dwArg04->ptr0014;
	}
	else
		__overflow(dwArg04, 0x0A);
	fputs_unlocked(dcgettext(null, "This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 0x05), dwArg04);
}

// 08049AF0: void version_etc(Stack (ptr32 Eq_105) dwArg04, Stack (ptr32 char) dwArg08, Stack (ptr32 char) dwArg0C, Stack (ptr32 char) dwArg10)
// Called from:
//      main
void version_etc(FILE * dwArg04, char * dwArg08, char * dwArg0C, char * dwArg10)
{
	version_etc_va(dwArg04, dwArg08, dwArg0C, dwArg10, fp + 0x14);
}

// 08049B20: void xalloc_die()
// Called from:
//      quotearg_n
//      xcalloc
//      x2realloc
//      x2nrealloc
//      xnrealloc
//      xmalloc
//      xnmalloc
void xalloc_die()
{
	<anonymous> * eax_9 = g_ptr804B944;
	if (eax_9 != null)
		eax_9();
	dcgettext(null, "memory exhausted", 0x05);
	error(g_dw804B7D4, 0x00, "%s", 0x00);
	abort();
}

// 08049B80: void xcalloc(Stack Eq_269 dwArg04, Stack Eq_269 dwArg08)
void xcalloc(Eq_269 dwArg04, Eq_269 dwArg08)
{
	if ((uint32) (0xFFFFFFFF /u dwArg08) >= dwArg04 && calloc(dwArg04, dwArg08) != null)
		return;
	xalloc_die();
}

// 08049BC0: void xrealloc(Stack Eq_269 dwArg04, Stack Eq_269 dwArg08)
// Called from:
//      quotearg_n
//      xcalloc
//      x2realloc
//      x2nrealloc
void xrealloc(Eq_269 dwArg04, Eq_269 dwArg08)
{
	if (realloc(dwArg04, dwArg08) != null)
		return;
	xalloc_die();
}

// 08049BF0: void x2realloc(Stack Eq_269 dwArg04, Stack (ptr32 Eq_269) dwArg08)
// Called from:
//      x2nrealloc
void x2realloc(Eq_269 dwArg04, union Eq_269 * dwArg08)
{
	Eq_269 eax_13 = *dwArg08;
	if (dwArg04 != 0x00)
	{
		if (eax_13 < 0x00)
			xalloc_die();
		eax_13 *= 0x02;
	}
	else if (eax_13 == 0x00)
		eax_13.u0 = 0x40;
	*dwArg08 = (union Eq_269 *) eax_13;
	xrealloc(dwArg04, eax_13);
}

// 08049C30: void x2nrealloc(Stack Eq_269 dwArg04, Stack (ptr32 Eq_1533) dwArg08, Stack Eq_1532 dwArg0C)
// Called from:
//      x2realloc
void x2nrealloc(Eq_269 dwArg04, union Eq_1533 * dwArg08, Eq_1532 dwArg0C)
{
	Eq_1533 ecx_19 = *dwArg08;
	if (dwArg04 != 0x00)
	{
		if ((uint32) (0x7FFFFFFF /u dwArg0C) < ecx_19)
			xalloc_die();
		ecx_19 *= 0x02;
	}
	else if (ecx_19 == 0x00)
	{
		uint32 eax_30 = (uint32) (0x40 /u dwArg0C);
		ecx_19 = eax_30 + (uint32) ((uint8) (eax_30 == 0x00));
	}
	*dwArg08 = (union Eq_1533 *) ecx_19;
	Eq_269 ecx_54 = ecx_19 *s dwArg0C;
	xrealloc(dwArg04, ecx_54);
}

// 08049CA0: void xnrealloc(Stack Eq_269 dwArg04, Stack Eq_1566 dwArg08, Stack Eq_1567 dwArg0C)
// Called from:
//      x2nrealloc
void xnrealloc(Eq_269 dwArg04, Eq_1566 dwArg08, Eq_1567 dwArg0C)
{
	if ((uint32) (0xFFFFFFFF /u dwArg0C) >= dwArg08 && realloc(dwArg04, dwArg08 *s dwArg0C) != null)
		return;
	xalloc_die();
}

// 08049CF0: Register (ptr32 void) xmalloc(Stack Eq_269 dwArg04)
// Called from:
//      clone_quoting_options
//      quotearg_n
//      xnrealloc
//      xclone
//      xzalloc
void * xmalloc(Eq_269 dwArg04)
{
	void * eax_11 = malloc(dwArg04);
	if (eax_11 != null)
		return eax_11;
	xalloc_die();
}

// 08049D20: void xclone(Stack (ptr32 void) dwArg04, Stack Eq_269 dwArg08)
// Called from:
//      xmalloc
void xclone(void * dwArg04, Eq_269 dwArg08)
{
	memcpy(xmalloc(dwArg08), dwArg04, dwArg08);
}

// 08049D50: void xzalloc(Stack Eq_269 dwArg04)
void xzalloc(Eq_269 dwArg04)
{
	memset(xmalloc(dwArg04), 0x00, dwArg04);
}

// 08049D80: void xnmalloc(Stack Eq_1609 dwArg04, Stack Eq_1610 dwArg08)
void xnmalloc(Eq_1609 dwArg04, Eq_1610 dwArg08)
{
	if ((uint32) (0xFFFFFFFF /u dwArg08) >= dwArg04 && malloc(dwArg04 *s dwArg08) != null)
		return;
	xalloc_die();
}

// 08049DC0: void __libc_csu_fini()
// Called from:
//      xnmalloc
void __libc_csu_fini()
{
	int32 eax_19 = 0x0804B828 - 0x0804B828;
	int32 esi_23 = (eax_19 >> 0x02) - 0x01;
	if (eax_19 >> 0x02 != 0x00)
	{
		do
		{
			(*((char *) g_a804B828 + esi_89 * 0x04))();
			esi_23 = esi_89 - 0x01;
			esi_89 = esi_23;
		} while (esi_89 != 0x00);
		_fini();
	}
	else
		_fini();
}

// 08049E30: void __libc_csu_init(Register word32 ecx, Register word32 edx)
void __libc_csu_init(word32 ecx, word32 edx)
{
	_init(ecx, edx);
	int32 edx_29 = 0x0804B828 - 0x0804B828;
	int32 edx_30 = edx_29 >> 0x02;
	if (edx_29 >> 0x02 > 0x00)
	{
		Eq_1663 esi_35 = 0x00;
		do
		{
			(*((char *) g_a804B828 + esi_35 * 0x04))();
			esi_35 = (word32) esi_35.u1 + 1;
		} while (esi_35 < edx_29 >> 0x02);
	}
}

// 08049E88: void __i686.get_pc_thunk.bx()
void __i686.get_pc_thunk.bx()
{
}

// 08049E90: void atexit(Stack (ptr32 Eq_168) dwArg04)
// Called from:
//      main
void atexit(void (* dwArg04)(void * ptrArg04))
{
	void * eax_19 = null;
	void ** edx_15 = g_ptr804B74C;
	if (edx_15 != null)
		eax_19 = (void *) *edx_15;
	__cxa_atexit(dwArg04, null, eax_19);
}

// 08049ED0: void __do_global_ctors_aux(Register word32 edx)
// Called from:
//      _init
void __do_global_ctors_aux(word32 edx)
{
	word32 * ebx_14 = &g_ptr804B660;
	<anonymous> * eax_15 = g_ptr804B660;
	while (eax_15 != (<anonymous> *) ~0x00)
	{
		eax_15();
		ebx_14 -= 0x04;
		eax_15 = *ebx_14;
	}
}

