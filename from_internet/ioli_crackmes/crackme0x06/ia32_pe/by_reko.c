// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text.h"

// 00401140: void fn00401140()
// Called from:
//      Win32CrtStartup
void fn00401140()
{
	SetUnhandledExceptionFilter(&g_t401000);
	fn00401510();
	__getmainargs(&g_dw405004, &g_dw405000, fp - 0x10, g_dw403000);
	struct Eq_24 * esp_15 = fp - 44;
	word32 eax_28 = g_dw405030;
	if (eax_28 != 0x00)
	{
		g_dw403010 = eax_28;
		ptr32 edx_33 = iob;
		if (iob != 0x00)
		{
			word32 eax_39 = iob->dw0010;
			setmode();
			edx_33 = iob;
		}
		if (edx_33 != ~0x1F)
		{
			esp_15->dw0004 = g_dw405030;
			word32 eax_55 = iob->dw0030;
			esp_15->dw0000 = eax_55;
			setmode();
			edx_33 = iob;
		}
		if (edx_33 != ~0x3F)
		{
			esp_15->dw0004 = g_dw405030;
			word32 eax_74 = iob->dw0050;
			esp_15->dw0000 = eax_74;
			setmode();
		}
	}
	*__p__fmode() = g_dw403010;
	fn004014E0();
	__align(esp_15);
	struct Eq_47 * esp_104;
	char * (** eax_105)[];
	word32 ecx_108;
	_p__environ();
	esp_104->ptr0008 = (char * (*)[]) *eax_105;
	esp_104->dw0004 = g_dw405000;
	esp_104->dw0000 = g_dw405004;
	UINT * esp_123;
	cexit();
	*esp_123 = (uint32) fn00401463(ecx_108, esp_104->ptr0008);
	ExitProcess(*esp_123);
}

// 00401260: Register Eq_144 Win32CrtStartup()
Eq_144 Win32CrtStartup()
{
	__set_app_type(0x01);
	fn00401140();
}

// 004012A0: void fn004012A0(Stack (ptr32 Eq_153) ptrArg04)
// Called from:
//      Win32CrtStartup
//      fn004015B0
void fn004012A0(void (* ptrArg04)())
{
	atexit(ptrArg04);
}

// 00401310: Register word32 fn00401310(Stack (arr (ptr32 char)) dwArg08)
// Called from:
//      fn00401376
word32 fn00401310(char * dwArg08[])
{
	ui32 dwLoc08_42 = 0x00;
	do
	{
		word32 dwLoc0C_45;
		if (dwArg08[dwLoc08_70] == null)
		{
			dwLoc0C_45 = 0x00;
			return dwLoc0C_45;
		}
		dwLoc08_42 = dwLoc08_70 + 0x01;
		dwLoc08_70 = dwLoc08_42;
	} while (strncmp(dwArg08[dwLoc08_70], "LOLO", 0x03) != 0x00);
	dwLoc0C_45 = 0x01;
	return dwLoc0C_45;
}

// 00401376: void fn00401376(Stack (ptr32 char) dwArg04, Stack (ptr32 (arr (ptr32 char))) dwArg08)
// Called from:
//      fn004013E4
void fn00401376(char * dwArg04, char * (* dwArg08)[])
{
	sscanf(dwArg04, "%d", fp - 0x08);
	if (fn00401310(dwArg08) != 0x00)
	{
		int32 dwLoc0C_62;
		for (dwLoc0C_62 = 0x00; dwLoc0C_62 <= 0x09; ++dwLoc0C_62)
		{
			if ((dwLoc08 & 0x01) == 0x00)
			{
				printf("Password OK!\n");
				exit(0x00);
			}
		}
	}
}

// 004013E4: void fn004013E4(Stack (ptr32 char) dwArg04, Stack (ptr32 (arr (ptr32 char))) dwArg08)
// Called from:
//      fn00401463
void fn004013E4(char * dwArg04, char * (* dwArg08)[])
{
	word32 dwLoc0C_61 = 0x00;
	size_t dwLoc10_62 = 0x00;
	while (dwLoc10_62 < strlen(dwArg04))
	{
		sscanf(fp - 0x11, "%d", fp - 0x08);
		word32 v9_38 = dwLoc0C_61 + dwLoc08;
		dwLoc0C_61 = v9_38;
		if (v9_38 == 0x10)
			fn00401376(dwArg04, dwArg08);
		dwLoc10_62 = (Eq_171) ((word32) dwLoc10_62 + 1);
	}
	printf("Password Incorrect!\n");
}

// 00401463: Register word32 fn00401463(Register word32 ecx, Stack (ptr32 (arr (ptr32 char))) dwArg0C)
// Called from:
//      fn00401140
word32 fn00401463(word32 ecx, char * (* dwArg0C)[])
{
	__align(fp - 0x9C);
	fn00402DB0(0x10, ecx, dwLocA0);
	fn004015B0();
	printf("IOLI Crackme Level 0x06\n");
	printf("Password: ");
	scanf("%s", fp - 0x7C);
	fn004013E4(fp - 0x7C, dwArg0C);
	return 0x00;
}

// 004014E0: void fn004014E0()
// Called from:
//      fn00401140
void fn004014E0()
{
	struct Eq_298 * ecx_15;
	for (ecx_15 = (struct Eq_298 *) 0x00404310; ecx_15 < (struct Eq_298 *) 0x00404310; ++ecx_15)
	{
		struct Eq_302 * edx_13 = ecx_15->dw0004;
		edx_13->dw400000 += ecx_15->dw0000;
	}
}

// 00401510: void fn00401510()
// Called from:
//      fn00401140
void fn00401510()
{
	__fninit();
}

// 004015B0: void fn004015B0()
// Called from:
//      fn00401463
void fn004015B0()
{
	if (g_dw405040 != 0x00)
		return;
	g_dw405040 = 0x01;
	ui32 eax_23 = g_dw402FC0;
	if (eax_23 == ~0x00)
	{
		eax_23 = 0x00;
		bool v14_82 = g_dw402FC4 != 0x00;
		while (v14_82)
		{
			++eax_23;
			v14_82 = (&g_dw402FC4)[eax_23 * 0x04] != 0x00;
		}
	}
	ui32 ebx_38 = eax_23;
	if (eax_23 != 0x00)
	{
		do
		{
			word32 ecx_56;
			fn90909090();
			--ebx_38;
		} while (ebx_38 != 0x00);
	}
	fn004012A0(&g_t401520);
}

// 00402DB0: void fn00402DB0(Register uint32 eax, Register word32 ecx, Stack (ptr32 code) dwArg00)
// Called from:
//      fn00401463
void fn00402DB0(uint32 eax, word32 ecx, <anonymous> * dwArg00)
{
	struct Eq_361 * ecx_13 = fp + 0x04;
	for (; eax >= 0x1000; eax -= 0x1000)
	{
		ecx_13 -= 0x1000;
		ecx_13->dw0000 = ecx_13->dw0000;
	}
	word32 * ecx_14 = ecx_13 - eax;
	*ecx_14 = *ecx_14;
	dwArg00();
}

