// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100(Register (ptr16 Eq_2) es, Register (ptr16 Eq_3) ds)
void fn0C00_0100(struct Eq_2 * es, struct Eq_3 * ds)
{
	bios_video_set_mode(0x13);
	__outb(0x03C8, 0x00);
	uint8 al_13 = 0x00;
	bcu8 cl_16;
	do
	{
		uint8 al_14 = al_13 >> 0x01;
		__outb(969, al_14);
		__outb(969, al_14);
		al_13 = cl_16 >> 0x02;
		__outb(969, al_13);
		++cl_16;
	} while (cl_16 != 0x00);
	word16 cx_23;
	word16 di_24 = 0x0200;
	uint16 ax_234 = (uint16) (uint8) __inb(0x40);
	for (cx_23 = 0x1520; cx_23 != 0x00; --cx_23)
		di_24 = fn0C00_01D5(di_24, ax_234, cx_23);
	do
	{
		byte Eq_62::* di_48;
		do
		{
			cu8 al_54 = 0xA000->*di_48;
			cu8 al_55 = al_54 - 0x19;
			if (al_54 < 0x19)
				al_55 = 0x00;
			0xA000->*di_48 = al_55;
			++di_48;
		} while (di_48 != Eq_62::a0000);
		while (true)
			--ds->w0141;
		word16 cx_102;
		struct Eq_82 Eq_3::* si_140 = Eq_3::a0200;
		for (cx_102 = 0x0101; cx_102 != 0x00; --cx_102)
		{
			(ds->*si_140).w0000 = (ds->*si_140).w0000;
			struct Eq_95 Eq_3::* si_82 = si_140 + 1;
			cu16 ax_83 = (ds->*si_140).w0000 + si_82[2];
			byte ah_117 = SLICE(ax_83, byte, 8);
			Eq_117 al_144 = (byte) ax_83;
			if (ax_83 >= 0x1400)
			{
l0C00_01CD:
				word16 cx_103 = cx_102 - 0x01;
				if (cx_103 == 0x00)
					break;
				uint16 ax_121 = SEQ(ah_117, __inb(0x40));
				fn0C00_01D5(&&(es->*(es->*si_140).w0000), ax_121, cx_103);
				return;
			}
			si_82[2] = ax_83;
			++(ds->*si_82).w0000;
			wchar_t ax_91 = (ds->*si_82).w0000 + si_82[3];
			ah_117 = SLICE(ax_91, byte, 8);
			al_144 = (byte) ax_91;
			if (ax_91 >= 0x0C80)
				goto l0C00_01CD;
			si_82[3] = ax_91;
			word16 ax_95 = si_82[1];
			Eq_117 v23_97 = (word16) si_82[4] + ax_95;
			si_82[4] = v23_97;
			ah_117 = SLICE(ax_95, byte, 8);
			al_144 = (byte) ax_95;
			if (v23_97 >= 0x00)
				goto l0C00_01CD;
			wchar_t ax_133 = si_82[3];
			Eq_144 di_138 = (si_82[2] >> 0x04) + (ax_133 >> 0x04) *s 0x0140;
			al_144 = si_82[4];
			si_140 = (struct Eq_82 Eq_3::*) (si_82 + 5);
			if (ax_133 >= 0x00)
				0xA000->*di_138 = al_144;
		}
		msdos_direct_console_output(~0x00);
		byte al_158 = al_144 - 0x77;
		if (al_158 == 0x00)
			--ds->b0167;
		if (al_158 == 252)
			++ds->b0167;
		if (al_158 == ~0x15)
			--ds->b015A;
		if (al_158 == ~0x12)
			++ds->b015A;
		if (al_158 == 0xB4)
			++ds->w0141;
		if (al_158 == ~0x49)
			--ds->w0141;
	} while (al_158 != 0xA4);
}

// 0C00:01D5: Register word16 fn0C00_01D5(Sequence (ptr32 Eq_52) es_di, Register uint16 ax, Register word16 cx)
// Called from:
//      fn0C00_0100
word16 fn0C00_01D5(struct Eq_52 * es_di, uint16 ax, word16 cx)
{
	word16 di = (word16) es_di;
	word16 ax_9 = (word16) (ax * 0x25) + cx;
	int16 ax_14 = (int16) (byte) ax_9;
	es_di->w0000 = SEQ(SLICE(ax_14, byte, 8), (byte) ax_14 & 0x1F ^ SLICE(ax_14, byte, 8));
	int16 ax_34 = (int16) ((SLICE(ax_9, byte, 8) | 0xF0) - 0x40);
	es_di->w0002 = ax_34;
	es_di->w0004 = SEQ(SLICE(ax_34, byte, 8), ~0x00);
	es_di->w0006 = 0x0A00;
	es_di->w0008 = 0x0C80;
	es_di->w000A = 0xFF;
	return di + 0x0C;
}

