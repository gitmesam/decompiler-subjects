// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100(Register (ptr16 Eq_2) es, Stack word16 wArg00)
void fn0C00_0100(struct Eq_2 * es, word16 wArg00)
{
	__fninit();
	byte al_629 = (byte) wArg00;
	byte Eq_2::* di_548 = Eq_2::a0300;
	word16 cx_10;
	for (cx_10 = 0x3D00; cx_10 != 0x00; --cx_10)
	{
		es->*di_548 = al_629;
		++di_548;
	}
	word16 ax_27 = ss->w3D0E;
	byte Eq_92::* di_117 = ss->ptr3D00;
	byte Eq_92::* si_112 = ss->ptr3D02;
	word16 bx_21 = ss->w3D08;
	word16 dx_23 = ss->w3D0A;
	word16 cx_25 = ss->w3D0C;
	ss->w3D0E = ax_27;
	ss->w3D0C = cx_25;
	ss->w3D0A = dx_23;
	ss->w3D08 = bx_21;
	ss->w3D06 = 0x3D10;
	ss->w3D04 = 0x02D6;
	ss->ptr3D02 = si_112;
	ss->ptr3D00 = di_117;
	0C00:02D6();
	0C00:02D6();
	ss->b02ED = 0x4A;
	struct Eq_55 Eq_14::* sp_78;
	0C00:02D6();
	fn0C00_0215(&Eq_14::t02D6);
	__syscall(0x10);
	__syscall(0x10);
	(ss->*sp_78).ptrFFFFFFFE = 0xA000;
	(ss->*sp_78).ptrFFFFFFFC = 0xA000;
	Eq_78 Top_235 = -4;
	word16 cx_103;
	for (cx_103 = 0xA000; cx_103 != 0x00; --cx_103)
	{
		byte al_114 = 0xA000->*si_112;
		0xA000->*di_117 = al_114;
		byte Eq_92::* di_119 = di_117 + 1;
		0xA000->*di_119 = al_114;
		++si_112;
		di_117 = di_119 + 1;
	}
	struct Eq_70 * ds_126 = (ss->*sp_78).ptrFFFFFFFC;
	struct Eq_70 * es_128 = (ss->*sp_78).ptrFFFFFFFE;
	while (true)
	{
		byte Eq_70::* di_133 = wLoc10;
		do
			;
		while ((__inb(0x03DA) & 0x08) == 0x00);
		uint8 al_182 = (byte) wLoc08;
		__outb(0x03C8, al_182);
		ci8 dh_323 = 0x03;
		do
		{
			cu8 al_188 = al_182 + 0x80;
			bcu8 al_191 = (bool) (al_188 < 0x00) + al_188;
			__outb(969, al_191 >> 0x01);
			__outb(969, al_191 >> 0x01);
			uint8 al_196 = (al_191 >> 0x01) * 0x02 + (al_191 >> 0x01 < 0x00);
			__outb(969, al_196);
			uint8 al_203 = (byte) (wLoc04 - 0x01);
			__outb(969, al_203);
			__outb(969, al_203);
			__outb(969, al_196);
			word16 cx_205 = wLoc04 - 0x01;
			al_182 = al_196;
		} while (al_196 != 0x40);
		do
		{
			cu8 al_213 = ds_126->*di_133;
			byte al_214 = al_213 - 0x02;
			if (al_213 < 0x02)
				al_214 = al_213 - 0x02 & 0x01;
			ds_126->*di_133 = al_214;
			es_128->*di_133 = al_214;
			++di_133;
			--cx_205;
		} while (cx_205 != 0x00);
		do
		{
			*Top_235 += *((word32) Top_235 + 2);
			Eq_78 Top_238 = (word32) Top_235 + 1;
			*Top_238 %= *((word32) Top_238 + 1);
			*((word32) Top_238 - 1) = *((word32) Top_238 - 1);
			real64 v30_242 = *((word32) Top_238 - 1);
			*((word32) Top_238 - 1) = cos(v30_242);
			*((word32) Top_238 - 2) = sin(v30_242);
			*((word32) Top_238 - 3) = (real64) (ss->*wLoc0C).t002A;
			*((word32) Top_238 - 3) *= *((word32) Top_238 + 3);
			*((word32) Top_238 - 3) = sin(*((word32) Top_238 - 3));
			*((word32) Top_238 - 3) *= *((word32) Top_238 - 1);
			*((word32) Top_238 - 2) *= *((word32) Top_238 - 3);
			*((word32) Top_238 - 3) = 1.0;
			*((word32) Top_238 - 3) += *((word32) Top_238 - 1);
			*((word32) Top_238 - 2) += *((word32) Top_238 - 3);
			real64 v31_261 = *((word32) Top_238 - 2);
			*((word32) Top_238 - 2) = *((word32) Top_238 - 1);
			*((word32) Top_238 - 1) = v31_261;
			*((word32) Top_238 - 2) *= (real64) (ss->*wLoc0C).wFFFFFFEA;
			*((word32) Top_238 - 2) = __rndint(*((word32) Top_238 - 2));
			*((word32) Top_238 - 3) = (real64) (ss->*wLoc0C).wFFFFFFEC;
			*((word32) Top_238 - 1) *= *((word32) Top_238 - 3);
			*((word32) Top_238 - 2) *= (real64) (ss->*wLoc0C).wFFFFFFE8;
			*((word32) Top_238 - 1) += *((word32) Top_238 - 2);
			(ss->*wLoc0C).tFFFFFFFA.u0 = (int32) *((word32) Top_238 - 1);
			Top_235 = Top_238;
			struct Eq_408 Eq_70::* di_276 = (word16) (ss->*wLoc0C).tFFFFFFFA.u1 + 1;
			ci8 cl_300;
			for (cl_300 = 0x01; cl_300 >= 0x00; --cl_300)
			{
				++di_276;
				(ds_126->*di_276).t0000 |= 0x90;
				(ds_126->*di_276).w0001 |= ~0x0101;
				(ds_126->*di_276).t0002 |= 0x90;
			}
			do
			{
				di_276 -= (ss->*wLoc0C).wFFFFFFE8;
				(ds_126->*di_276).t0000 |= ~0x0101;
				(ds_126->*di_276).t0002 |= ~0x0101;
				++cl_300;
			} while (cl_300 <= 0x00);
			--dh_323;
		} while (dh_323 >= 0x00);
		Eq_262 ax_328 = (ss->*wLoc0C).t002A;
		byte al_349 = (byte) ax_328;
		if (SLICE(ax_328, byte, 8) >= 0x14)
		{
			(ss->*wLoc0C).bFF70 = (ss->*wLoc0C).bFF70 ^ 0x03;
			ax_328 = SEQ(0x08, al_349);
		}
		Eq_262 ax_353 = (word16) ax_328.u1 + 1;
		(ss->*wLoc0C).t002A = ax_353;
		cui16 ax_358 = SEQ(SLICE(ax_353, byte, 8), __inb(0x60));
		bool S_374 = (bool) cond(ax_358 & 0x7E);
		if ((ax_358 & 0x7E) == 0x00)
		{
			(ss->*wLoc0C).bFEAD = ~0x14;
			byte v40_365 = (ss->*wLoc0C).bFF7B - 0x01;
			(ss->*wLoc0C).bFF7B = v40_365;
			(ss->*wLoc0C).wFEE8 = ax_358 & 0x7E;
			S_374 = (bool) cond(v40_365);
		}
		byte ah_379 = SLICE(ax_328, byte, 8);
		byte al_384 = (byte) ax_328;
		if (!S_374)
			break;
		ci8 ch_432 = SLICE(ax_328 >> 0x02, byte, 8);
		byte cl_451 = (byte) (ax_328 >> 0x02);
		if ((al_384 & 0x0F) == 0x00)
		{
			word16 ax_397 = SEQ(SLICE(ax_328 >> 0x02, byte, 8), (byte) (ax_328 >> 0x02) & 0x1C);
			cu16 ax_389 = SEQ(ah_379 & 0x03, al_384 << 0x02);
			ci8 al_401 = (byte) (ax_397 - 0x1C);
			if (ax_397 != 0x1C)
			{
				al_401 += 0x0C;
				if (al_401 != 0x0C)
				{
					if (al_401 >= 0x0C)
					{
						uint16 si_410 = (ax_389 >> 0x06) - 0x01;
						al_401 = (&(ss->*(ss->*wLoc0C).a001A))[si_410 ^ 0x03];
					}
					else
						al_401 = Mem406[ss:wLoc0C + 0x1A + (ax_389 >>u 0x06):byte];
				}
			}
			ui8 bh_487 = SLICE((uint16) (uint8) fn0C00_0294(SEQ(ch_432, al_401), 0x70, wLoc0C, ax_389 >> 0x06 & 0x03), byte, 8);
			if ((cl_451 & 0x01) == 0x00)
			{
				cui16 ax_456 = 0x26;
				if ((cl_451 & 0x08) == 0x00)
					ax_456 = 0x24;
				if (ch_432 >= 0x01)
				{
					(ss->*wLoc0C).bFEB0 = (ss->*wLoc0C).bFEB0 ^ 222;
					cup16 cx_483 = SEQ(ch_432 - 0x01, cl_451);
					if ((cl_451 & 0x06) == 0x00)
					{
						if (cx_483 <= 0x3F)
							bh_487 = (bh_487 & cl_451) * 0x02;
						fn0C00_0294(ax_456, bh_487 | 0x1F, wLoc0C, 0x08);
						byte v46_516 = (ss->*wLoc0C).bFE97;
						(ss->*wLoc0C).bFE97 = (ss->*wLoc0C).bFE94;
						byte v47_519 = (ss->*wLoc0C).bFE9B;
						(ss->*wLoc0C).bFE9B = v46_516;
						(ss->*wLoc0C).bFE94 = v47_519;
					}
				}
			}
		}
	}
	__syscall(0x10);
	fn0C00_0215(wLoc0C);
}

// 0C00:0215: void fn0C00_0215(Register (memptr (ptr16 Eq_14) Eq_59) bp)
// Called from:
//      fn0C00_0100
void fn0C00_0215(struct Eq_59 Eq_14::* bp)
{
	do
	{
		word16 ax_10;
		word16 cx_11;
		(0x0C00->*bp).t0000();
		word16 cx_19;
		(0x0C00->*bp).t0000();
	} while ((byte) (cx_19 + 0x01) < 0xC5);
}

// 0C00:0294: Register byte fn0C00_0294(Register cui16 ax, Register byte bh, Register (memptr (ptr16 Eq_14) Eq_59) bp, Register cui16 si)
// Called from:
//      fn0C00_0100
byte fn0C00_0294(cui16 ax, byte bh, struct Eq_59 Eq_14::* bp, cui16 si)
{
	int16 si_14 = (si + 0x01) * 0x02;
	cui16 v10_17 = (&(ss->*(ss->*bp).a002E))[si_14];
	(&(ss->*(ss->*bp).a002E))[si_14] = ax;
	word16 bx_21 = fn0C00_02A6(v10_17, SEQ(bh, 0x80) + (si + 0x01), bp);
	word16 bx_32 = SEQ(SLICE(bx_21, byte, 8), (byte) bx_21 + 0x10);
	return SLICE(fn0C00_02A6(ax, bx_32, bp), byte, 8);
}

// 0C00:02A6: Register word16 fn0C00_02A6(Register cui16 ax, Register word16 bx, Register (memptr (ptr16 Eq_14) Eq_59) bp)
// Called from:
//      fn0C00_0294
word16 fn0C00_02A6(cui16 ax, word16 bx, struct Eq_59 Eq_14::* bp)
{
	byte al = (byte) ax;
	byte ah = SLICE(ax, byte, 8);
	if (al != 0x00)
	{
		word16 ax_14 = SEQ(ah - 0x01, al);
		do
		{
			word16 ax_21;
			word16 bx_22;
			(0x0C00->*bp).t0000();
			word16 ax_29;
			word16 bx_30;
			(0x0C00->*bp).t0000();
			word16 ax_40;
			(0x0C00->*bp).t0000();
			ci16 ax_50 = SEQ(SLICE(ax_40, byte, 8), SLICE(bx, byte, 8));
			ax_14 = ax_50 + ~0xF3;
		} while (ax_50 > ~0xF3);
	}
	return bx;
}

