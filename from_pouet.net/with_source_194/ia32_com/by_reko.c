// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100()
void fn0C00_0100()
{
	bios_video_set_mode(0x03);
	while (true)
	{
		word16 cx_191;
		for (cx_191 = 500; cx_191 != 0x01; --cx_191)
		{
			byte Eq_12::* di_21 = Eq_12::a01D0;
			struct Eq_8 Eq_7::* si_22 = Eq_7::a0000;
			word16 cx_25;
			for (cx_25 = 2000; cx_25 != 0x00; --cx_25)
			{
				cs->*di_21 = (0xB800->*si_22).b0000;
				++di_21;
				++si_22;
			}
			word16 cx_39;
			struct Eq_28 Eq_12::* si_46 = Eq_12::a01D0;
			byte ah_203 = SLICE((char *) cs + 0x0096, byte, 8);
			byte Eq_71::* di_55 = Eq_71::a01D0;
			for (cx_39 = 2000; cx_39 != 0x00; --cx_39)
			{
				cup16 bx_66 = (bool) (cs < 0x96) + (SEQ(ah_203, (cs->*si_46).bFFFFFFAF) + SEQ(ah_203, (cs->*si_46).bFFFFFFB1));
				cu16 bx_71 = (bool) (bx_66 < 0x00) + (bx_66 + SEQ(ah_203, si_46[81]));
				((char *) cs + 0x0096)->*di_55 = (byte) ((bool) (bx_71 < 0x00) + (bx_71 + SEQ(ah_203, si_46[79])) + 0x01 >> 0x02);
				++si_46;
				++di_55;
			}
			byte Eq_93::* di_109 = Eq_93::a0000;
			byte Eq_89::* si_102 = Eq_89::a01D0;
			word16 cx_103;
			for (cx_103 = 2000; cx_103 != 0x00; --cx_103)
			{
				0xB800->*di_109 = ((char *) cs + 0x0096)->*si_102;
				++si_102;
				byte al_113 = ((char *) cs + 0x0096)->*si_102;
				byte Eq_93::* di_112 = di_109 + 1;
				0xB800->*di_112 = al_113 & 0x70 | (al_113 & 0x70) >> 0x04 & 0x05;
				di_109 = di_112 + 1;
			}
			word16 cx_125;
			struct Eq_126 Eq_93::* di_126 = Eq_93::a0000;
			byte al_206 = (byte) cx_191;
			for (cx_125 = 0x50; cx_125 != 0x00; --cx_125)
			{
				di_126[0x0780] = al_206;
				(0xB800->*di_126).b0000 = al_206;
				++di_126;
			}
			word16 cx_145;
			struct Eq_145 Eq_93::* di_146 = Eq_93::a0000;
			for (cx_145 = 0x19; cx_145 != 0x00; --cx_145)
			{
				(0xB800->*di_146).b009E = al_206;
				(0xB800->*di_146).b0000 = al_206;
				++di_146;
			}
			B800:07D0 = (byte *) (al_206 + 0x02);
			B800:07D2 = (byte *) (al_206 + 0x02);
			word16 cx_163 = 0x14;
			do
			{
				word16 cx_169;
				for (cx_169 = ~0x05; cx_169 != 0x00; --cx_169)
					;
				cx_163 = cx_260 - 0x01;
				cx_260 = cx_163;
			} while (cx_260 != 0x01);
			byte al_179;
			byte ah_180;
			if (bios_kbd_check_keystroke(out al_179, out ah_180))
			{
				byte al_187;
				bios_kbd_get_keystroke(out al_187);
				return;
			}
		}
	}
}

