// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100(Register byte ch, Register (ptr16 Eq_3) ds)
void fn0C00_0100(byte ch, struct Eq_3 * ds)
{
	__syscall(0x10);
	byte Eq_3::* si_21 = &Eq_3::b01FF;
	Eq_11 bx_13 = 0x01FF;
	word16 cx_17 = SEQ(ch, 0x10);
	do
	{
		--si_21;
		ds->*bx_13 = ds->*si_21;
		--cx_17;
		bx_13 = (word16) bx_13 + 1;
		byte ch_292 = SLICE(cx_17, byte, 8);
	} while (cx_17 != 0x00);
	word16 cx_293 = SEQ(ch_292, 0x20);
	do
	{
		ds->*bx_13 = -(ds->*si_21);
		--cx_293;
		++si_21;
		bx_13 = (word16) bx_13 + 1;
		byte ch_310 = SLICE(cx_293, byte, 8);
	} while (cx_293 != 0x00);
	do
	{
		byte ah_49 = 0040:006C;
		do
			;
		while (ah_49 == 0040:006C);
		Eq_56 bx_58 = (word16) bx_13 + 1;
		byte bl_317 = (byte) (bx_58 & 0x3F);
		byte Eq_78::* di_280 = &Eq_78::bFFFFAA00;
		word16 cx_287 = SEQ(ch_310, 0x80 - ds->*((word16) (bx_58 & 0x3F) + 495));
		while (true)
		{
			byte ch_314 = SLICE(cx_287, byte, 8);
			if (cx_287 == 0x00)
				break;
			0xA000->*di_280 = 0x1D;
			++di_280;
			--cx_287;
		}
		word16 cx_281 = SEQ(ch_314, 0x0F);
		while (true)
		{
			byte ch_318 = SLICE(cx_281, byte, 8);
			if (cx_281 == 0x00)
				break;
			0xA000->*di_280 = 22;
			++di_280;
			--cx_281;
		}
		byte al_75 = (bl_317 & 0x04) + 22;
		0xA000->*di_280 = al_75;
		byte Eq_78::* di_80 = di_280 + 1;
		0xA000->*di_80 = al_75;
		byte Eq_78::* di_269 = di_80 + 1;
		word16 cx_277;
		for (cx_277 = SEQ(ch_318, 0x0F); cx_277 != 0x00; --cx_277)
		{
			0xA000->*di_269 = 22;
			++di_269;
		}
		word16 cx_272 = 0xAB40 - di_269;
		while (true)
		{
			byte ch_333 = SLICE(cx_272, byte, 8);
			if (cx_272 == 0x00)
				break;
			0xA000->*di_269 = 0x1D;
			++di_269;
			--cx_272;
		}
		byte Eq_78::* di_102 = &Eq_78::bFFFFF8C0;
		word16 cx_106 = SEQ(ch_333, 0x3F);
		do
		{
			word16 cx_113 = 0x0140;
			struct Eq_151 Eq_78::* si_114 = di_102 - 0x0140;
			di_263 = di_102;
			while (true)
			{
				byte Eq_78::* di_263;
				if (cx_113 == 0x00)
					break;
				0xA000->*di_263 = (0xA000->*si_114).b0000;
				++si_114;
				++di_263;
				--cx_113;
			}
			(0xA000->*si_114).b0000 = (0xA000->*si_114).b0000;
			if ((0xA000->*si_114).b0000 != 0x00)
			{
				do
				{
					si_114 = si_409 + 1;
					si_409 = si_114;
				} while ((0xA000->*si_409).b0000 != 22);
				(0xA000->*si_114).bFFFFFFFD = 22;
				(0xA000->*si_114).bFFFFFFFE = 22;
				struct Eq_205 Eq_78::* si_136 = si_114 + 310;
				do
				{
					si_136 = si_410 - 0x01;
					si_410 = si_136;
				} while ((0xA000->*si_410).b0000 != 22);
				si_136[2] = 22;
				si_136[3] = 22;
			}
			di_102 -= 0x0140;
			cx_106 = cx_408 - 0x01;
			byte ch_349 = SLICE(cx_408 - 0x01, byte, 8);
			cx_408 = cx_106;
		} while (cx_408 != 0x01);
		byte Eq_78::* bx_175 = &Eq_78::b013F;
		do
		{
			byte ah_176 = 0x00;
			cu8 al_177 = __inb(0x40);
			if (al_177 >= ~0x07)
				ah_176 = al_177 & 0x0F | 0x10;
			0xA000->*bx_175 = ah_176;
			--bx_175;
		} while (bx_175 != Eq_78::a0000);
		bx_13 = bx_58 & 0x3F;
		byte Eq_78::* di_212 = &Eq_78::bFFFFA8C0;
		word16 cx_217 = SEQ(ch_349, 0x87);
		do
		{
			word16 cx_220;
			byte Eq_78::* si_227 = di_212 - 0x0141 + (uint16) (__inb(0x40) & 0x03);
			for (cx_220 = 0x0140; cx_220 != 0x00; --cx_220)
			{
				0xA000->*di_212 = 0xA000->*si_227;
				++si_227;
				++di_212;
			}
			di_212 -= 0x0280;
			cx_217 = cx_411 - 0x01;
			ch_310 = SLICE(cx_411 - 0x01, byte, 8);
			cx_411 = cx_217;
		} while (cx_411 != 0x01);
	} while (__inb(0x60) != 0x01);
	byte al_245;
	bios_kbd_get_keystroke(out al_245);
	byte bl_249;
	byte ch_250;
	byte cl_251;
	bios_video_get_EGA_info(out bl_249, out ch_250, out cl_251);
}

