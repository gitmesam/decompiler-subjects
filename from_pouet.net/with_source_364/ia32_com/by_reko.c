// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100(Register (ptr16 Eq_2) ds)
void fn0C00_0100(struct Eq_2 * ds)
{
	bios_video_set_mode(0x03);
	__syscall(0x10);
	__syscall(0x10);
	byte ah_8;
	byte bh_9;
	if (bios_video_get_current_video_mode(out ah_8, out bh_9) != 0x07)
		ds->w013A = 0xB800;
	Eq_27 bx_344 = msdos_get_interrupt_vector(0x08);
	ds->t0501 = (word16) bx_344;
	ds->ptr0503 = SLICE(bx_344, selector, 16);
	byte Eq_2::* si_105 = fn0C00_033E(&ds->w013A + 438);
	uint16 bp_30 = 0x00;
	word16 cx_31;
	struct Eq_50 Eq_62::* di_106 = Eq_62::a0000;
	ui8 dl_107 = 0x00;
	for (cx_31 = 6000; cx_31 != 0x00; --cx_31)
	{
		(0xB000->*di_106).w0000 = 0x00;
		++di_106;
	}
	while (true)
	{
		byte bl_62 = (byte) bx_344;
		if (bp_30 == 0x20)
		{
			si_105 = &Eq_2::b05AD;
			di_106 = (struct Eq_50 Eq_62::*) Eq_62::a0000;
			dl_107 |= 0x08;
		}
		if (bp_30 == 0x60)
			dl_107 |= 0x04;
		Eq_27 bx_73 = bx_344;
		if (bp_30 == 0x80)
		{
			bx_73.u0 = (uint16) (uint8) fn0C00_0362(bl_62 & ~0x01, 0xB000, ds);
			si_105 = &Eq_2::b05DC;
			di_106 = (struct Eq_50 Eq_62::*) Eq_62::a0FA0;
			dl_107 = dl_107 ^ 0x04 | 0x88;
		}
		byte bl_89 = (byte) bx_73;
		Eq_27 bx_888 = bx_73;
		if (bp_30 == 0x0100)
		{
			bx_888.u0 = (uint16) (uint8) fn0C00_0362(bl_89 | 0x01, 0xB000, ds);
			si_105 = &Eq_2::b0625;
			di_106 = (struct Eq_50 Eq_62::*) Eq_62::a0FA0;
			dl_107 |= 0x08;
		}
		if (bp_30 == 0x011E)
			si_105 = &Eq_2::b0644;
		if (bp_30 == 0x0140)
			dl_107 = dl_107 ^ 0x84;
		Eq_27 bx_143 = bx_888;
		if (bp_30 == 0x0160)
		{
			ui8 dl_127 = dl_107 ^ 0x04;
			word16 Eq_62::* di_128 = Eq_62::a0FA0;
			word16 cx_129;
			for (cx_129 = 2000; cx_129 != 0x00; --cx_129)
			{
				0xB000->*di_128 = 0x00;
				++di_128;
			}
			bx_143.u0 = (uint16) (uint8) fn0C00_0949(0x01AD, 0x0BB2, 0x1180, 0xB000, ds, out si_105, out di_106);
			dl_107 = dl_127 | 0x20;
		}
		byte bl_158 = (byte) bx_143;
		Eq_27 bx_176 = bx_143;
		if (bp_30 == 0x0180)
		{
			bx_176.u0 = (uint16) (uint8) fn0C00_0362(bl_158 & ~0x01, 0xB000, ds);
			si_105 = &Eq_2::b065C;
			di_106 = (struct Eq_50 Eq_62::*) Eq_62::a0FA0;
			dl_107 = dl_107 ^ 0x30 | 0x08;
		}
		byte bl_197 = (byte) bx_176;
		if (bp_30 == 464)
			si_105 = &Eq_2::b06DE;
		Eq_27 bx_207 = bx_176;
		if (bp_30 == 0x0200)
		{
			bx_207.u0 = (uint16) (uint8) fn0C00_0362(bl_197 | 0x01, 0xB000, ds);
			si_105 = &Eq_2::b0625;
			di_106 = (struct Eq_50 Eq_62::*) Eq_62::a0FA0;
			dl_107 |= 0x08;
		}
		if (bp_30 == 0x021E)
			si_105 = &Eq_2::b06AC;
		Eq_27 bx_256 = bx_207;
		if (bp_30 == 0x0280)
		{
			word16 Eq_62::* di_230 = Eq_62::a0000;
			word16 cx_233;
			for (cx_233 = 6000; cx_233 != 0x00; --cx_233)
			{
				0xB000->*di_230 = 0x20;
				++di_230;
			}
			word16 si_893;
			word16 di_894;
			fn0C00_0949(0xEB, 0x0AC7, 0x1CC0, 0xB000, ds, out si_893, out di_894);
			bx_256.u0 = (uint16) (uint8) fn0C00_0949(161, 3665, 4000, 0xB000, ds, out si_105, out di_106);
			dl_107 = 0x40;
		}
		byte bl_266 = (byte) bx_256;
		Eq_27 bx_281 = bx_256;
		if (bp_30 == 0x02C0)
		{
			bx_281.u0 = (uint16) (uint8) fn0C00_0362(bl_266 & ~0x01, 0xB000, ds);
			si_105 = &Eq_2::b070C;
			di_106 = (struct Eq_50 Eq_62::*) Eq_62::a0FA0;
			dl_107 |= 0x08;
		}
		byte bl_300 = (byte) bx_281;
		Eq_27 bx_308 = bx_281;
		if (bp_30 == 0x0300)
		{
			bx_308.u0 = (uint16) (uint8) fn0C00_0362(bl_300 | 0x01, 0xB000, ds);
			si_105 = &Eq_2::b0625;
			di_106 = (struct Eq_50 Eq_62::*) Eq_62::a0FA0;
			dl_107 |= 0x08;
		}
		if (bp_30 == 0x031E)
			si_105 = &Eq_2::b0739;
		bx_344 = bx_308;
		if (bp_30 == 0x0340)
		{
			word16 Eq_62::* di_329 = Eq_62::a0FA0;
			word16 cx_330;
			for (cx_330 = 2000; cx_330 != 0x00; --cx_330)
			{
				0xB000->*di_329 = 0x00;
				++di_329;
			}
			bx_344.u0 = (uint16) (uint8) fn0C00_0949(242, 3423, 0x1180, 0xB000, ds, out si_105, out di_106);
			dl_107 = 0x20;
		}
		if (bp_30 == 0x0360)
			dl_107 = 0x11;
		if (bp_30 == 0x0380)
		{
			di_106 = &Eq_62::t08C0;
			si_105 = &Eq_2::b0758;
			dl_107 |= 0x0A;
		}
		if (bp_30 == 0x0440)
		{
			di_106 = &Eq_62::t0DC0;
			si_105 = &Eq_2::b0905;
			dl_107 |= 0x08;
		}
		if (bp_30 == 0x0480)
			dl_107 |= ~0x00;
		if (dl_107 == ~0x00)
			break;
		if ((dl_107 & 0x08) != 0x00)
		{
			word16 cx_389 = 0x01;
			if ((dl_107 & 0x02) != 0x00)
			{
				cx_389 = 0x03;
				if ((bp_30 & 0x03) == 0x00)
					cx_389 = 0x02;
			}
			do
			{
				byte al_403 = ds->*si_105;
				++si_105;
				if (al_403 == 0x00)
					dl_107 = dl_107 ^ 0x08;
				(0xB000->*di_106).w0000 = SEQ(0x0E, al_403);
				++di_106;
				--cx_389;
			} while (cx_389 != 0x00);
			(0xB000->*di_106).bFFFFFFFD = 0x0F;
			(0xB000->*di_106).bFFFFFFFB = 0x07;
			(0xB000->*di_106).bFFFFFFF7 = 0x0E;
			(0xB000->*di_106).bFFFFFFF5 = 0x0C;
			(0xB000->*di_106).bFFFFFFF1 = 0x0E;
		}
		if ((dl_107 & 0x20) != 0x00)
		{
			int16 ax_577 = (int16) (byte) (bp_30 << 0x03);
			uint16 ax_582 = (uint16) (uint8) ((byte) ax_577 ^ SLICE(ax_577, byte, 8));
			ui16 ax_587 = ax_582 * 0x08 + ax_582 * 0x04;
			uint16 bx_590 = (ax_587 & ~0x3F) >> 0x01;
			cui16 ax_592 = (ax_587 & ~0x3F) + (bx_590 >> 0x01);
			word16 Eq_62::* di_568 = Eq_62::a0000;
			word16 Eq_62::* si_594 = 4000 - ax_592 - ax_592;
			word16 cx_596;
			for (cx_596 = 2000; cx_596 != 0x00; --cx_596)
			{
				0xB000->*di_568 = 0xB000->*si_594;
				++si_594;
				++di_568;
			}
			bx_344 = bx_590 >> 0x01;
		}
		while (bp_30 >= ds->w04AB)
		{
			if ((0000:0417 & 0x07) != 0x00)
				goto l0C00_033A;
			bx_344.u0 = <invalid>;
			byte bl_895;
			dl_107 = (byte) (uint16) (uint8) fn0C00_038D(dl_107, bp_30, 0xB000, out bl_895, out di_106);
		}
		++bp_30;
	}
l0C00_033A:
	Eq_33 ds_dx_672 = ds->t0501;
	fn0C00_033E(ds_dx_672);
}

// 0C00:033E: Register (memptr (ptr16 Eq_494) byte) fn0C00_033E(Sequence Eq_33 ds_dx)
// Called from:
//      fn0C00_0100
byte Eq_494::* fn0C00_033E(Eq_33 ds_dx)
{
	__cli();
	msdos_set_interrupt_vector(0x08, ds_dx);
	word16 ax_10 = 244;
	do
	{
		fn0C00_0505(ax_10);
		--ax_10;
		byte al_28 = (byte) ax_10;
	} while (ax_10 != 0x00);
	byte Eq_494::* si_17 = Eq_494::a08FD;
	do
	{
		++si_17;
		word16 ax_23 = SEQ(0x0C00->*si_17, al_28);
		do
		{
			fn0C00_0505(ax_23);
			++ax_23;
			al_28 = (byte) ax_23;
		} while ((al_28 & 0x1F) != 0x00);
	} while (al_28 != 0x00);
	__sti();
	return si_17;
}

// 0C00:0362: Register byte fn0C00_0362(Register byte bl, Register (ptr16 Eq_62) es, Register (ptr16 Eq_2) ds)
// Called from:
//      fn0C00_0100
byte fn0C00_0362(byte bl, struct Eq_62 * es, struct Eq_2 * ds)
{
	word16 Eq_62::* di_10 = Eq_62::a0FA0;
	word16 cx_42;
	for (cx_42 = 0xA0; cx_42 != 0x00; --cx_42)
	{
		es->*di_10 = 0x00;
		++di_10;
	}
	word16 cx_17;
	Eq_139 si_16;
	Eq_140 di_11 = di_10 + 730;
	if ((bl & 0x01) == 0x00)
	{
		&si_16.u0->b0000 = 0x099B;
		cx_17 = 0x5F;
	}
	else
	{
		&si_16.u0->b0000 = 2554;
		cx_17 = 0xCD;
		di_11 = (word16) di_11 + 70;
	}
	word16 di_51;
	word16 si_50;
	return (byte) (uint16) (uint8) fn0C00_0949(cx_17, si_16, di_11, es, ds, out si_50, out di_51);
}

// 0C00:038D: Register ui8 fn0C00_038D(Register ui8 dl, Register uint16 bp, Register (ptr16 Eq_62) es, Register out Eq_27 blOut, Register out Eq_449 diOut)
// Called from:
//      fn0C00_0100
ui8 fn0C00_038D(ui8 dl, uint16 bp, struct Eq_62 * es, union Eq_27 & blOut, union Eq_449 & diOut)
{
	if ((dl & 0x04) != 0x00)
	{
		di.u0 = 0x00;
		word16 cx_17 = 2000;
		word16 ax_10 = 177;
		if ((bp & 0x01) == 0x00)
			ax_10 = SEQ(~0x00, 177);
		for (; cx_17 != 0x00; --cx_17)
		{
			es->*di.u0 = ax_10;
			++di.u0;
		}
	}
	if ((dl & 0x40) != 0x00)
	{
		word16 Eq_62::* di_364 = Eq_62::a0000;
		Eq_570 si_357 = 4000;
		uint16 bx_63 = (uint16) (uint8) (bp % 0x50);
		for (dh = 0x19; dh != 0x00; --dh)
		{
			uint16 cx_68;
			for (cx_68 = 0x50; cx_68 != 0x00; --cx_68)
			{
				word16 ax_72 = es->*si_357;
				byte ah_77 = SLICE(ax_72, byte, 8);
				si_357 = (word16) si_357 + 2;
				if ((byte) ax_72 == 0x20 && (ah_77 & 0xF0) == 0x00)
				{
					if (cx_68 >= bx_63)
						ax_72 = es->*((word16) si_357 + ((word16) (bx_63 * 0x02) + 3998));
					else
						ax_72 = es->*((word16) si_357 + ((word16) (bx_63 * 0x02) + 0x0EFE));
				}
				es->*di_364 = ax_72;
				++di_364;
			}
		}
	}
	if ((dl & 0x80) != 0x00)
	{
		word16 Eq_62::* si_141 = Eq_62::a0FA0;
		Eq_615 di_142 = 0x00;
		byte bh_154 = 0x00;
		for (dh = 0x19; dh != 0x00; --dh)
		{
			int16 ax_161 = (int16) (byte) (SEQ(SLICE(bp * 0x04, byte, 8), (byte) (bp * 0x04) + dh + bh_154) * 0x04);
			uint8 al_164 = (byte) ax_161 ^ SLICE(ax_161, byte, 8);
			uint16 ax_169 = (uint16) (uint8) (al_164 - (al_164 >> 0x01));
			uint16 ax_170 = ax_169 + 0x08;
			if (ax_169 >= 0x48)
				ax_170 = 0x50;
			word16 dx_223 = SEQ(dh, dl);
			Eq_615 di_193;
			si_141 = fn0C00_0EF2(0x50 - ax_170, fn0C00_0EF2(ax_170, si_141, di_142, es, es, out di_193), di_193, es, es, out di_142);
			bh_154 = SLICE(SEQ(bh_154, ~(bh_154 + dh + (byte) bp) & 0x19) + dx_223 + dx_223, byte, 8);
		}
	}
	word16 dx_458 = SEQ(dh, dl);
	if ((dl & 0x10) != 0x00)
	{
		word16 Eq_62::* di_262 = Eq_62::a0000;
		word16 Eq_62::* si_263 = Eq_62::a0FA0;
		word16 cx_264 = 2000;
		byte ch_375 = 0x07;
		word16 dx_274 = SEQ(dh, dl);
		if ((dl & 0x01) == 0x00)
		{
			do
			{
				es->*di_262 = es->*si_263;
				++si_263;
				++di_262;
				--cx_264;
			} while (cx_264 != 0x00);
		}
		else
		{
			struct Eq_669 Eq_62::* di_276 = &Eq_62::t0001;
			word16 dx_277 = 0x4E;
			do
			{
				ui16 ax_280 = bp * 0x02;
				word16 bx_283 = dx_277;
				word16 cx_309 = SEQ(ch_375, 0x50);
				do
				{
					ui16 ax_289 = ax_280 + bx_283 + bp;
					(es->*di_276).b0000 = SLICE(ax_289, byte, 8) & 0x19 ^ 0x0F;
					--cx_309;
					byte dl_311 = (byte) dx_277;
					byte dh_369 = SLICE(dx_277, byte, 8);
					bx_283 += dx_277;
					ax_280 = ax_289;
					++di_276;
					ch_375 = SLICE(cx_309, byte, 8);
				} while (cx_309 != 0x00);
				dx_277 = SEQ(dh_369, dl_311 - 0x03);
			} while (dl_311 != 0x03);
		}
		dx_458 = dx_274;
	}
	blOut.u0 = <invalid>;
	diOut = di;
	return (byte) dx_458;
}

// 0C00:0505: void fn0C00_0505(Register word16 ax)
// Called from:
//      fn0C00_033E
void fn0C00_0505(word16 ax)
{
	byte al_15 = (byte) ax;
	byte ah_22 = SLICE(ax, byte, 8);
	__outb(0x0388, al_15);
	word16 cx_16 = 0x06;
	do
	{
		__inb(0x0388);
		--cx_16;
		byte ch_44 = SLICE(cx_16, byte, 8);
	} while (cx_16 != 0x00);
	__outb(0x0389, ah_22);
	word16 cx_30;
	do
	{
		__inb(0x0388);
		--cx_30;
	} while (cx_30 != 0x00);
}

// 0C00:0949: Register byte fn0C00_0949(Register word16 cx, Register Eq_139 si, Register Eq_140 di, Register (ptr16 Eq_62) es, Register (ptr16 Eq_2) ds, Register out Eq_139 siOut, Register out Eq_140 diOut)
// Called from:
//      fn0C00_0100
//      fn0C00_0362
byte fn0C00_0949(word16 cx, Eq_139 si, Eq_140 di, struct Eq_62 * es, struct Eq_2 * ds, union Eq_139 & siOut, union Eq_140 & diOut)
{
	Eq_140 dx_105 = di;
	byte ah_115 = 0x00;
	do
	{
		word16 ax_170;
		uint8 al_16 = ds->*si;
		si = (word16) si + 1;
		word16 ax_74 = SEQ(ah_115, al_16);
		if (al_16 >= 0x20)
		{
			es->*di = ax_74;
			di = (word16) di + 2;
			ax_170 = SEQ(ah_115, al_16);
		}
		else if (al_16 < 0x10)
			ax_170 = SEQ(ah_115 & 0xF0 | al_16, al_16);
		else if (al_16 != 0x18)
		{
			if (al_16 >= 0x18)
			{
				bx = cx;
				byte al_32 = ds->*si;
				si = (word16) si + 1;
				word16 ax_110 = SEQ(ah_115, 0x20);
				if (al_16 != 0x19)
				{
					si = (word16) si + 2;
					bx = cx - 0x01;
					ax_110 = SEQ(ah_115, ds->*((word16) si + 1));
				}
				ah_115 = SLICE(ax_110, byte, 8);
				uint16 cx_45;
				for (cx_45 = (uint16) (uint8) al_32 + 0x01; cx_45 != 0x00; --cx_45)
				{
					es->*di = ax_110;
					di = (word16) di + 2;
				}
				word16 cx_50 = bx - 0x01;
				cx = cx_50 - 0x01;
				if (cx_50 == 0x00 || cx_50 == 0x01)
					break;
				continue;
			}
			ui8 al_63 = (al_16 - 0x10) * 0x02;
			ax_170 = SEQ(ah_115 & ~0x70 | al_63 * 0x08, al_63 * 0x08);
		}
		else
		{
			dx_105 = (word16) dx_105 + 0x00A0;
			di = dx_105;
			ax_170 = SEQ(ah_115, al_16);
		}
		ah_115 = SLICE(ax_170, byte, 8);
		--cx;
	} while (cx != 0x00);
	siOut = si;
	diOut = di;
	return (byte) bx;
}

// 0C00:0EF2: Register (memptr (ptr16 Eq_62) word16) fn0C00_0EF2(Register uint16 cx, Register (memptr (ptr16 Eq_62) word16) si, Register Eq_615 di, Register (ptr16 Eq_62) es, Register (ptr16 Eq_62) ds, Register out Eq_615 diOut)
// Called from:
//      fn0C00_038D
word16 Eq_62::* fn0C00_0EF2(uint16 cx, word16 Eq_62::* si, Eq_615 di, struct Eq_62 * es, struct Eq_62 * ds, union Eq_615 & diOut)
{
	for (; cx != 0x00; --cx)
	{
		es->*di = ds->*si;
		++si;
		di = (word16) di + 2;
	}
	diOut = di;
	return si;
}

