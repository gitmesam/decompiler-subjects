// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100(Register word16 cx, Register (memptr (ptr16 Eq_4) Eq_66) bx, Register (ptr16 Eq_4) ds)
void fn0C00_0100(word16 cx, union Eq_66 Eq_4::* bx, struct Eq_4 * ds)
{
	__syscall(0x10);
	__outb(0x03C8, 0x00);
	word16 ax_13 = 0x00;
	do
	{
		byte al_17 = (byte) (ax_13 + 0x01);
		word16 ax_25 = __ror(ax_13, 0x02);
		if ((al_17 & 0x0F) != 0x00)
			ax_25 = __ror(ax_25, 0x01);
		byte al_33 = (byte) ax_25;
		__outb(969, al_33);
		__outb(969, al_33);
		if ((al_17 & 0x0F) != 0x00)
			al_33 = (byte) __rol(ax_25, 0x01);
		__outb(969, al_33);
		byte al_55 = (byte) ax_13;
		ax_13 = SEQ(SLICE(ax_13, byte, 8), al_55 + 0x01);
	} while (al_55 != 0x01);
	Eq_66 es_bp_67 = ds->*bx;
	ui16 bp_68 = (word16) es_bp_67;
	struct Eq_72 * es_365 = SLICE(es_bp_67, selector, 16);
	word16 cx_267 = cx;
	do
	{
		byte cl_301 = (byte) cx_267;
		Eq_75 si_121 = ds->t01FC;
		do
		{
			if (*((word16) si_121 + bp_68 * 0x02) == cl_301)
			{
				Eq_81 di_88 = (word16) ds->t01FC + (si_121 << 0x04);
				ui32 eax_91 = (word32) __rdtsc() ^ ds->dw020A;
				ds->*di_88 = (int16) (byte) eax_91;
				int16 ax_103 = (int16) SLICE((word16) eax_91, byte, 8);
				ds->*((word16) di_88 + 2) = ax_103;
				ds->*((word16) di_88 + 4) = 0x43800000;
				word32 eax_108 = __bswap(SEQ(SLICE(eax_91, word16, 16), ax_103));
				word16 ax_110 = (word16) eax_108;
				ds->*((word16) di_88 + 8) = ax_110 + 0x01;
				*((word16) si_121 + bp_68 * 0x02) = (word16) *((word16) si_121 + bp_68 * 0x02) + 1;
				ds->dw020A += SEQ(SLICE(eax_108, word16, 16), ax_110 + 0x01);
			}
			--si_121;
			word16 cx_137 = cx_267;
		} while (si_121 != 0x00);
		do
		{
			cu8 v27_127 = (bp_68 << 0x01)->*si_121 - 0x11;
			(bp_68 << 0x01)->*si_121 = v27_127;
			if (v27_127 < 0x00)
				(bp_68 << 0x01)->*si_121 = 0x01;
			si_121 = (word16) si_121 + 1;
			--cx_137;
		} while (cx_137 != 0x00);
		++ds->dw0200;
		Eq_75 si_154;
		do
		{
			Eq_213 di_161 = (word16) ds->t01FC + (si_154 << 0x04);
			real64 rLoc1_375 = (real64) (ds->*((word16) di_161 + 4)) - (real64) (ds->*((word16) di_161 + 8)) * ds->r01F8;
			ds->*((word16) di_161 + 4) = (real32) rLoc1_375;
			byte cl_237 = (byte) cx_137;
			struct Eq_198 Eq_125::* bp_176 = &Eq_125::t0000;
			bool C_178 = false;
			do
			{
				real64 rLoc2_380 = (real64) Mem184[ss:bp_176 + di_161:int16] * (real64) Mem184[ds:0x01FC:word16] / rLoc1_375;
				real64 rLoc3_382 = (real64) ds->dw0200 * ds->r01F8;
				if (!C_178)
					rLoc3_382 = cos(rLoc3_382);
				bp_176[516] = (int16) (rLoc2_380 + (sin(rLoc3_382) + 1.0) * (real64) ds->w01FE);
				Eq_202 bp_212 = bp_176 + 1;
				bp_176 = (word16) bp_212 + 1;
				C_178 = !C_178;
			} while (C_178);
			ds->t0208.u0 = (int16) rLoc1_375;
			uint16 di_223 = ds->w0206;
			if (bp_212 >= 0x01 && di_223 < 200)
			{
				wchar_t dx_228 = ds->w0204;
				if (dx_228 < 0x3C || dx_228 >= 0x0104)
					goto l0C00_01E3;
				SEQ(bp_68 << 0x01, dx_228 + 0x3C)[di_223].b0000 = 0x00 - ds->t0208 | 0x0F;
			}
			else
			{
l0C00_01E3:
				*((word16) si_154 + bp_68 * 0x02) = cl_237;
			}
			--si_154;
		} while (si_154 != 0x00);
		byte Eq_72::* di_269 = Eq_72::a0010;
		for (cx_267 = cx_137 - 0x01; cx_267 != 0x00; --cx_267)
		{
			es_365->*di_269 = ds->*si_154;
			si_154 = (word16) si_154 + 1;
			++di_269;
		}
	} while (__inb(0x60) != 0x01);
}

