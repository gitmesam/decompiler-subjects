// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100(Register (memptr (ptr16 Eq_10) Eq_2) di)
void fn0C00_0100(struct Eq_2 Eq_10::* di)
{
	struct Eq_3 Eq_11::* sp_183 = fp;
	__syscall(0x10);
	do
	{
		struct Eq_3 Eq_11::* sp_6 = sp_183 - 2;
		(ss->*sp_6).ptr0000 = 0x8000;
		struct Eq_10 * es_9 = (ss->*sp_6).ptr0000;
		(ss->*sp_6).ptr0000 = cs;
		struct Eq_10 * ds_14 = (ss->*sp_6).ptr0000;
		word16 cx_16 = ~0x00;
		while (true)
		{
			byte ch_243 = SLICE(cx_16, byte, 8);
			if (cx_16 == 0x00)
				break;
			(es_9->*di).t0000 = 0x14;
			++di;
			--cx_16;
		}
		(ss->*sp_6).ptr0000 = 0x00;
		struct Eq_16 Eq_10::* di_21 = Eq_10::a0000;
		word16 cx_244 = SEQ(ch_243, 200);
		do
		{
			(es_9->*di_21).b0000 = 0x0F;
			struct Eq_39 Eq_10::* di_32 = di_21 + 1;
			di_32[0x009E] = 0x0F;
			di_32[318] = 0x0F;
			di_21 = (struct Eq_16 Eq_10::*) (di_32 + 319);
			--cx_244;
		} while (cx_244 != 0x00);
		(ss->*sp_6).ptrFFFFFFFE = 0x0140;
		byte Eq_10::* di_220 = Eq_10::a0000;
		word16 cx_221;
		for (cx_221 = 0x0140; cx_221 != 0x00; --cx_221)
		{
			es_9->*di_220 = 0x0F;
			++di_220;
		}
		struct Eq_10 * cx_216 = (ss->*sp_6).ptrFFFFFFFE;
		byte Eq_10::* di_213 = di_220 + 63360;
		while (true)
		{
			byte ch_254 = SLICE(cx_216, byte, 8);
			if (cx_216 == 0x00)
				break;
			es_9->*di_213 = 0x0F;
			++di_213;
			--cx_216;
		}
		wchar_t bx_63 = ds_14->w01F7;
		Eq_85 dx_64 = ds_14->t01F9;
		if (dx_64 >= 0xC3 || dx_64 <= 0x01)
			ds_14->w01FD = -ds_14->w01FD;
		Eq_85 dx_81 = (word16) dx_64.u0 + ds_14->w01FD;
		if (bx_63 >= 0x0136 || bx_63 <= 0x06)
			ds_14->w01FB = -ds_14->w01FB;
		wchar_t bx_101 = bx_63 + ds_14->w01FB;
		Eq_126 di_107 = dx_81 *s 0x0140 + bx_101;
		word16 cx_115 = SEQ(ch_254, 0x04);
		do
		{
			es_9->*di_107 = 0x5C5C5C5C;
			di_107 = (word16) di_107 + 320;
			--cx_115;
		} while (cx_115 != 0x00);
		ds_14->w01F7 = bx_101;
		ds_14->t01F9 = dx_81;
		if (ds_14->b01FC != 0x00)
			fn0C00_01DD((char *) ss + 499, dx_81);
		else
			fn0C00_01DD((char *) ss + 501, dx_81);
		fn0C00_01C5(ds_14->w01F3, &Eq_10::t0002, es_9);
		fn0C00_01C5(ds_14->w01F5, &Eq_10::t013A, es_9);
		(ss->*sp_6).ptrFFFFFFFE = es_9;
		struct Eq_10 * ds_178 = (ss->*sp_6).ptrFFFFFFFE;
		(ss->*sp_6).ptrFFFFFFFE = 0xA000;
		struct Eq_10 * es_182 = (ss->*sp_6).ptrFFFFFFFE;
		sp_183 = sp_6;
		word16 cx_184;
		word16 Eq_10::* si_185 = Eq_10::a0000;
		di = (struct Eq_2 Eq_10::*) Eq_10::a0000;
		for (cx_184 = 0x7D00; cx_184 != 0x00; --cx_184)
		{
			(es_182->*di).t0000 = ds_178->*si_185;
			++si_185;
			di += 2;
		}
		__syscall(22);
	} while (0x00 == 0x00);
	bios_video_set_mode(0x03);
	fn0C00_01C5(0x03, di, es_182);
}

// 0C00:01C5: void fn0C00_01C5(Register int16 ax, Register (memptr (ptr16 Eq_10) Eq_2) di, Register (ptr16 Eq_10) es)
// Called from:
//      fn0C00_0100
void fn0C00_01C5(int16 ax, struct Eq_2 Eq_10::* di, struct Eq_10 * es)
{
	struct Eq_241 Eq_10::* di_11 = di + ax *s 0x0140;
	word16 cx_15;
	for (cx_15 = 0x10; cx_15 != 0x00; --cx_15)
	{
		(es->*di_11).dw0000 = 0x51515151;
		++di_11;
	}
}

// 0C00:01DD: void fn0C00_01DD(Sequence (ptr32 Eq_85) ss_bp, Register Eq_85 dx)
// Called from:
//      fn0C00_0100
void fn0C00_01DD(union Eq_85 * ss_bp, Eq_85 dx)
{
	if (dx < *ss_bp)
		*ss_bp = (union Eq_85 *) (*ss_bp - 0x01);
	else if (dx - 0x0C > *ss_bp)
		*ss_bp = (union Eq_85 *) ((char *) *ss_bp + 1);
}

