// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100(Register byte bh, Register wchar_t si)
void fn0C00_0100(byte bh, wchar_t si)
{
	__syscall(0x10);
	cup16 bx_120 = SEQ(bh, 0x05);
	do
	{
		byte Eq_13::* di_11 = Eq_13::a0000;
		word16 cx_14;
		for (cx_14 = 0xFA00; cx_14 != 0x00; --cx_14)
		{
			word16 dx_18;
			int16 ax_16 = fn0C00_0168(di_11, out dx_18);
			wchar_t dx_24 = dx_18 + ax_16 *s ax_16;
			byte al_25 = 0x00;
			if (dx_24 >= si)
			{
				al_25 = 0x09;
				if (dx_24 >= 2500)
				{
					cup16 dx_34;
					int16 ax_32 = fn0C00_0168(di_11, out dx_34);
					al_25 = 0x0F;
					if ((word16) ((ax_32 + 0x46) *s (ax_32 + 0x46)) + dx_34 >= 14641)
						al_25 = 0x0C;
				}
			}
			0xA000->*di_11 = al_25;
			++di_11;
		}
		si += bx_120;
		if (si <= 0x01 || si >= 0x0960)
			bx_120 = -bx_120;
	} while (__inb(0x60) != 0x01);
	word16 cx_104 = 100;
	do
	{
		byte Eq_13::* di_109 = Eq_13::a0000;
		byte Eq_13::* si_106 = Eq_13::a0280;
		word16 cx_113;
		for (cx_113 = 0xFA00; cx_113 != 0x00; --cx_113)
		{
			0xA000->*di_109 = 0xA000->*si_106;
			++si_106;
			++di_109;
		}
		cx_104 = cx_162 - 0x01;
		cx_162 = cx_104;
	} while (cx_162 != 0x01);
}

// 0C00:0168: Register Eq_97 fn0C00_0168(Register (memptr (ptr16 Eq_13) byte) di, Register out Eq_34 dxOut)
// Called from:
//      fn0C00_0100
Eq_97 fn0C00_0168(byte Eq_13::* di, union Eq_34 & dxOut)
{
	uint32 dx_ax_8 = (uint32) di;
	Eq_100 ax_11 = (uint16) (dx_ax_8 /u 0x0140);
	Eq_104 dx_10 = (uint16) (dx_ax_8 % 0x0140);
	Eq_97 ax_13 = ax_11 - 100;
	if (ax_11 < 100)
		ax_13 = 100 - ax_11;
	dxOut = (dx_10 - 0xA0) *s (dx_10 - 0xA0);
	return ax_13;
}

