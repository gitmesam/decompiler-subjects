// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100()
void fn0C00_0100()
{
	bios_video_set_mode(0x03);
	while (true)
	{
		word16 cx_203;
		for (cx_203 = 500; cx_203 != 0x01; --cx_203)
		{
			byte Eq_12::* di_21 = Eq_12::a01CE;
			struct Eq_8 Eq_7::* si_22 = Eq_7::a0000;
			word16 cx_25;
			for (cx_25 = 2000; cx_25 != 0x00; --cx_25)
			{
				cs->*di_21 = (0xB800->*si_22).b0000;
				++di_21;
				++si_22;
			}
			word16 cx_107;
			struct Eq_28 Eq_12::* si_104 = Eq_12::a01CE;
			uint8 ah_215 = SLICE((char *) cs + 0x0096, byte, 8);
			byte Eq_105::* di_102 = Eq_105::a01CE;
			for (cx_107 = 2000; cx_107 != 0x00; --cx_107)
			{
				ui32 bx_bx_223 = SEQ(bx_66, SEQ(ah_215, (cs->*si_104).bFFFFFFAF)) + SEQ(ax_69, SEQ(ah_215, (cs->*si_104).bFFFFFFB1));
				cup16 bx_71 = SLICE(bx_bx_223, word16, 16);
				cup16 bx_80 = (bool) (bx_71 < 0x00) + (bx_71 + SEQ(ah_215, si_104[79])) + SEQ(ah_215, (cs->*si_104).bFFFFFFB0) + true;
				cup16 bx_85 = (bool) (bx_80 < 0x00) + (bx_80 + SEQ(ah_215, (cs->*si_104).bFFFFFFFF));
				cu16 bx_90 = (bool) (bx_85 < 0x00) + (bx_85 + SEQ(ah_215, si_104[1]));
				uint16 ax_69 = SEQ(ah_215, si_104[81]);
				((char *) cs + 0x0096)->*di_102 = (byte) ((bool) (bx_90 < 0x00) + (bx_90 + SEQ(ah_215, si_104[80])) + 0x04 >> 0x03 & 0x3F);
				ui16 bx_66 = (word16) bx_bx_223;
				++si_104;
				++di_102;
			}
			struct Eq_118 Eq_128::* di_119 = Eq_128::a0000;
			byte Eq_124::* si_122 = Eq_124::a01CE;
			word16 cx_123;
			for (cx_123 = 2000; cx_123 != 0x00; --cx_123)
			{
				(0xB800->*di_119).b0000 = ((char *) cs + 0x0096)->*si_122;
				++si_122;
				++di_119;
			}
			word16 cx_137;
			struct Eq_142 Eq_128::* di_138 = Eq_128::a0000;
			byte al_216 = (byte) cx_203;
			for (cx_137 = 0x50; cx_137 != 0x00; --cx_137)
			{
				di_138[0x0780] = al_216;
				(0xB800->*di_138).b0000 = al_216;
				++di_138;
			}
			word16 cx_157;
			struct Eq_161 Eq_128::* di_158 = Eq_128::a0000;
			for (cx_157 = 0x19; cx_157 != 0x00; --cx_157)
			{
				(0xB800->*di_158).b009E = al_216;
				(0xB800->*di_158).b0000 = al_216;
				++di_158;
			}
			B800:07CE = (byte *) (al_216 + 0x02);
			B800:07D0 = (byte *) (al_216 + 0x02);
			word16 cx_175 = 200;
			do
			{
				word16 cx_181;
				for (cx_181 = ~0x05; cx_181 != 0x00; --cx_181)
					;
				cx_175 = cx_271 - 0x01;
				cx_271 = cx_175;
			} while (cx_271 != 0x01);
			byte al_191;
			byte ah_192;
			if (bios_kbd_check_keystroke(out al_191, out ah_192))
			{
				byte al_199;
				bios_kbd_get_keystroke(out al_199);
				return;
			}
		}
	}
}

