// subject_code.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_code.h"

// 0C00:0100: void fn0C00_0100(Register byte ah, Register byte ch, Register int16 dx, Register Eq_5 bx, Register (ptr16 Eq_6) ds)
void fn0C00_0100(byte ah, byte ch, int16 dx, Eq_5 bx, struct Eq_6 * ds)
{
	__syscall(0x10);
	int16 ax_108 = SEQ(ah, 0x13);
	struct Eq_6 * es_114 = ds->*((word16) bx + 2);
	do
	{
		struct Eq_19 Eq_6::* di_15 = Eq_6::a0000;
		word16 cx_120 = SEQ(ch, 0x03);
		do
		{
			++(ds->*di_15).w0179;
			real64 rLoc1_151 = (real64) (ds->*di_15).w0179 / (real64) ds->w017F;
			real64 rLoc1_152 = cos(rLoc1_151);
			(ds->*di_15).w0183 = (int16) (sin(rLoc1_151) * (real64) ds->w0181);
			(ds->*di_15).w018B = (int16) (rLoc1_152 * (real64) ds->w017F);
			(es_114->*di_15).w0000 = ax_108;
			--cx_120;
			++di_15;
			byte cl_121 = (byte) cx_120;
		} while (cx_120 != 0x00);
		byte Eq_6::* si_40 = Eq_6::a019A;
		byte Eq_6::* di_100 = Eq_6::a019A;
		word16 cx_101 = SEQ(~0x09, cl_121);
		while (true)
		{
			byte cl_123 = (byte) cx_101;
			if (cx_101 == 0x00)
				break;
			es_114->*di_100 = ds->*si_40;
			++si_40;
			++di_100;
			--cx_101;
		}
		Eq_81 di_45 = 0x019A;
		word16 cx_124;
		do
		{
			ds->*di_45 = 0x00;
			di_45 = (word16) di_45 + 1;
			--cx_124;
		} while (cx_124 != 0x00);
		do
		{
			Mem65[ds:dx *s 0x0140 + bx + 0xBC30:byte] = SLICE(ax_108, byte, 0);
			ax_108 = __rol((word16) di_45 + ax_108, 0x02);
			Eq_126 di_73 = (word16) di_45 + ax_108;
			--cx_124;
			byte ah_111 = SLICE(ax_108, byte, 8);
			di_45 = di_73 & 0x06;
			bx += Mem65[ds:(di_73 & 0x06) + 0x0183:word16] - bx >> 0x01;
			dx += ds->*((word16) (di_73 & 0x06) + 395) - dx >> 0x01;
			ch = SLICE(cx_124, byte, 8);
		} while (cx_124 != 0x00);
		byte al_88 = __inb(0x60);
		ax_108 = SEQ(ah_111, al_88 - 0x01);
	} while (al_88 != 0x01);
}

