// Generated by Rec Studio 4 - build Sep 23 2015

_init()
{// addr = 0x08049D84
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 146452 - 36)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    return _t3;
}

L08049D90()
{
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4

    _pop(__ebx);
    if( *((intOrPtr*)(_t4 + 146452 - 36)) != 0) {
        __gmon_start__();
    }
    frame_dummy();
    _t3 = __do_global_ctors_aux();
    _pop(__eax);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return _t3;
}

ldexp()
{// addr = 0x08049DC4
    goto __imp__ldexp;
}

fputs()
{// addr = 0x08049DD4
    goto __imp__fputs;
}

fmod()
{// addr = 0x08049DE4
    goto __imp__fmod;
}

__errno_location()
{// addr = 0x08049DF4
    goto __imp____errno_location;
}

sigemptyset()
{// addr = 0x08049E04
    goto __imp__sigemptyset;
}

inet_ntop()
{// addr = 0x08049E14
    goto __imp__inet_ntop;
}

sprintf()
{// addr = 0x08049E24
    goto __imp__sprintf;
}

tcflow()
{// addr = 0x08049E34
    goto __imp__tcflow;
}

connect()
{// addr = 0x08049E44
    goto __imp__connect;
}

setgroups()
{// addr = 0x08049E54
    goto __imp__setgroups;
}

getpid()
{// addr = 0x08049E64
    goto __imp__getpid;
}

mkdir()
{// addr = 0x08049E74
    goto __imp__mkdir;
}

strerror()
{// addr = 0x08049E84
    goto __imp__strerror;
}

getsockname()
{// addr = 0x08049E94
    goto __imp__getsockname;
}

memcmp()
{// addr = 0x08049EA4
    goto __imp__memcmp;
}

log1p()
{// addr = 0x08049EB4
    goto __imp__log1p;
}

freeaddrinfo()
{// addr = 0x08049EC4
    goto __imp__freeaddrinfo;
}

asin()
{// addr = 0x08049ED4
    goto __imp__asin;
}

shutdown()
{// addr = 0x08049EE4
    goto __imp__shutdown;
}

open64()
{// addr = 0x08049EF4
    goto __imp__open64;
}

sigismember()
{// addr = 0x08049F04
    goto __imp__sigismember;
}

__gmon_start__()
{// addr = 0x08049F14
    goto __imp____gmon_start__;
}

realloc()
{// addr = 0x08049F24
    goto __imp__realloc;
}

sinh()
{// addr = 0x08049F34
    goto __imp__sinh;
}

__isoc99_sscanf()
{// addr = 0x08049F44
    goto __imp____isoc99_sscanf;
}

__xstat64()
{// addr = 0x08049F54
    goto __imp____xstat64;
}

localtime()
{// addr = 0x08049F64
    goto __imp__localtime;
}

cfgetispeed()
{// addr = 0x08049F74
    goto __imp__cfgetispeed;
}

getgrnam()
{// addr = 0x08049F84
    goto __imp__getgrnam;
}

strtod()
{// addr = 0x08049F94
    goto __imp__strtod;
}

socketpair()
{// addr = 0x08049FA4
    goto __imp__socketpair;
}

recv()
{// addr = 0x08049FB4
    goto __imp__recv;
}

getenv()
{// addr = 0x08049FC4
    goto __imp__getenv;
}

calloc()
{// addr = 0x08049FD4
    goto __imp__calloc;
}

system()
{// addr = 0x08049FE4
    goto __imp__system;
}

fchown()
{// addr = 0x08049FF4
    goto __imp__fchown;
}

write()
{// addr = 0x0804A004
    goto __imp__write;
}

sendto()
{// addr = 0x0804A014
    goto __imp__sendto;
}

pow()
{// addr = 0x0804A024
    goto __imp__pow;
}

listen()
{// addr = 0x0804A034
    goto __imp__listen;
}

dlclose()
{// addr = 0x0804A044
    goto __imp__dlclose;
}

rename()
{// addr = 0x0804A054
    goto __imp__rename;
}

getlogin()
{// addr = 0x0804A064
    goto __imp__getlogin;
}

memset()
{// addr = 0x0804A074
    goto __imp__memset;
}

setitimer()
{// addr = 0x0804A084
    goto __imp__setitimer;
}

setsid()
{// addr = 0x0804A094
    goto __imp__setsid;
}

getprotobyname()
{// addr = 0x0804A0A4
    goto __imp__getprotobyname;
}

__libc_start_main()
{// addr = 0x0804A0B4
    goto __imp____libc_start_main;
}

wait()
{// addr = 0x0804A0C4
    goto __imp__wait;
}

floor()
{// addr = 0x0804A0D4
    goto __imp__floor;
}

modf()
{// addr = 0x0804A0E4
    goto __imp__modf;
}

tcgetattr()
{// addr = 0x0804A0F4
    goto __imp__tcgetattr;
}

chmod()
{// addr = 0x0804A104
    goto __imp__chmod;
}

read()
{// addr = 0x0804A114
    goto __imp__read;
}

tcdrain()
{// addr = 0x0804A124
    goto __imp__tcdrain;
}

sigaltstack()
{// addr = 0x0804A134
    goto __imp__sigaltstack;
}

exp()
{// addr = 0x0804A144
    goto __imp__exp;
}

getrusage()
{// addr = 0x0804A154
    goto __imp__getrusage;
}

gettimeofday()
{// addr = 0x0804A164
    goto __imp__gettimeofday;
}

expm1()
{// addr = 0x0804A174
    goto __imp__expm1;
}

strtol()
{// addr = 0x0804A184
    goto __imp__strtol;
}

getservbyport()
{// addr = 0x0804A194
    goto __imp__getservbyport;
}

free()
{// addr = 0x0804A1A4
    goto __imp__free;
}

inet_pton()
{// addr = 0x0804A1B4
    goto __imp__inet_pton;
}

__lxstat64()
{// addr = 0x0804A1C4
    goto __imp____lxstat64;
}

atan()
{// addr = 0x0804A1D4
    goto __imp__atan;
}

__fpclassify()
{// addr = 0x0804A1E4
    goto __imp____fpclassify;
}

getprotobynumber()
{// addr = 0x0804A1F4
    goto __imp__getprotobynumber;
}

access()
{// addr = 0x0804A204
    goto __imp__access;
}

dlsym()
{// addr = 0x0804A214
    goto __imp__dlsym;
}

truncate64()
{// addr = 0x0804A224
    goto __imp__truncate64;
}

sigaction()
{// addr = 0x0804A234
    goto __imp__sigaction;
}

fflush()
{// addr = 0x0804A244
    goto __imp__fflush;
}

sqrt()
{// addr = 0x0804A254
    goto __imp__sqrt;
}

opendir()
{// addr = 0x0804A264
    goto __imp__opendir;
}

gethostbyaddr_r()
{// addr = 0x0804A274
    goto __imp__gethostbyaddr_r;
}

accept()
{// addr = 0x0804A284
    goto __imp__accept;
}

tcflush()
{// addr = 0x0804A294
    goto __imp__tcflush;
}

symlink()
{// addr = 0x0804A2A4
    goto __imp__symlink;
}

socket()
{// addr = 0x0804A2B4
    goto __imp__socket;
}

dup2()
{// addr = 0x0804A2C4
    goto __imp__dup2;
}

__ctype_b_loc()
{// addr = 0x0804A2D4
    goto __imp____ctype_b_loc;
}

isatty()
{// addr = 0x0804A2E4
    goto __imp__isatty;
}

getaddrinfo()
{// addr = 0x0804A2F4
    goto __imp__getaddrinfo;
}

umask()
{// addr = 0x0804A304
    goto __imp__umask;
}

tanh()
{// addr = 0x0804A314
    goto __imp__tanh;
}

setuid()
{// addr = 0x0804A324
    goto __imp__setuid;
}

dup()
{// addr = 0x0804A334
    goto __imp__dup;
}

mktime()
{// addr = 0x0804A344
    goto __imp__mktime;
}

readdir64()
{// addr = 0x0804A354
    goto __imp__readdir64;
}

acos()
{// addr = 0x0804A364
    goto __imp__acos;
}

memcpy()
{// addr = 0x0804A374
    goto __imp__memcpy;
}

cfsetospeed()
{// addr = 0x0804A384
    goto __imp__cfsetospeed;
}

utime()
{// addr = 0x0804A394
    goto __imp__utime;
}

execv()
{// addr = 0x0804A3A4
    goto __imp__execv;
}

execvp()
{// addr = 0x0804A3B4
    goto __imp__execvp;
}

cos()
{// addr = 0x0804A3C4
    goto __imp__cos;
}

alarm()
{// addr = 0x0804A3D4
    goto __imp__alarm;
}

unlink()
{// addr = 0x0804A3E4
    goto __imp__unlink;
}

getpwuid()
{// addr = 0x0804A3F4
    goto __imp__getpwuid;
}

nice()
{// addr = 0x0804A404
    goto __imp__nice;
}

getppid()
{// addr = 0x0804A414
    goto __imp__getppid;
}

setlocale()
{// addr = 0x0804A424
    goto __imp__setlocale;
}

waitpid()
{// addr = 0x0804A434
    goto __imp__waitpid;
}

sigdelset()
{// addr = 0x0804A444
    goto __imp__sigdelset;
}

__h_errno_location()
{// addr = 0x0804A454
    goto __imp____h_errno_location;
}

strcpy()
{// addr = 0x0804A464
    goto __imp__strcpy;
}

chroot()
{// addr = 0x0804A474
    goto __imp__chroot;
}

getegid()
{// addr = 0x0804A484
    goto __imp__getegid;
}

dlopen()
{// addr = 0x0804A494
    goto __imp__dlopen;
}

mkfifo()
{// addr = 0x0804A4A4
    goto __imp__mkfifo;
}

chdir()
{// addr = 0x0804A4B4
    goto __imp__chdir;
}

bind()
{// addr = 0x0804A4C4
    goto __imp__bind;
}

getuid()
{// addr = 0x0804A4D4
    goto __imp__getuid;
}

putenv()
{// addr = 0x0804A4E4
    goto __imp__putenv;
}

sigpending()
{// addr = 0x0804A4F4
    goto __imp__sigpending;
}

select()
{// addr = 0x0804A504
    goto __imp__select;
}

closedir()
{// addr = 0x0804A514
    goto __imp__closedir;
}

close()
{// addr = 0x0804A524
    goto __imp__close;
}

fwrite()
{// addr = 0x0804A534
    goto __imp__fwrite;
}

rewinddir()
{// addr = 0x0804A544
    goto __imp__rewinddir;
}

frexp()
{// addr = 0x0804A554
    goto __imp__frexp;
}

initgroups()
{// addr = 0x0804A564
    goto __imp__initgroups;
}

fprintf()
{// addr = 0x0804A574
    goto __imp__fprintf;
}

time()
{// addr = 0x0804A584
    goto __imp__time;
}

log10()
{// addr = 0x0804A594
    goto __imp__log10;
}

execve()
{// addr = 0x0804A5A4
    goto __imp__execve;
}

ftruncate64()
{// addr = 0x0804A5B4
    goto __imp__ftruncate64;
}

malloc()
{// addr = 0x0804A5C4
    goto __imp__malloc;
}

sigprocmask()
{// addr = 0x0804A5D4
    goto __imp__sigprocmask;
}

chown()
{// addr = 0x0804A5E4
    goto __imp__chown;
}

gethostname()
{// addr = 0x0804A5F4
    goto __imp__gethostname;
}

atan2()
{// addr = 0x0804A604
    goto __imp__atan2;
}

fputc()
{// addr = 0x0804A614
    goto __imp__fputc;
}

rmdir()
{// addr = 0x0804A624
    goto __imp__rmdir;
}

dlerror()
{// addr = 0x0804A634
    goto __imp__dlerror;
}

getgrgid()
{// addr = 0x0804A644
    goto __imp__getgrgid;
}

sleep()
{// addr = 0x0804A654
    goto __imp__sleep;
}

sigaddset()
{// addr = 0x0804A664
    goto __imp__sigaddset;
}

readlink()
{// addr = 0x0804A674
    goto __imp__readlink;
}

memmove()
{// addr = 0x0804A684
    goto __imp__memmove;
}

cfgetospeed()
{// addr = 0x0804A694
    goto __imp__cfgetospeed;
}

getnameinfo()
{// addr = 0x0804A6A4
    goto __imp__getnameinfo;
}

strcat()
{// addr = 0x0804A6B4
    goto __imp__strcat;
}

send()
{// addr = 0x0804A6C4
    goto __imp__send;
}

getcwd()
{// addr = 0x0804A6D4
    goto __imp__getcwd;
}

log()
{// addr = 0x0804A6E4
    goto __imp__log;
}

gethostbyname_r()
{// addr = 0x0804A6F4
    goto __imp__gethostbyname_r;
}

fork()
{// addr = 0x0804A704
    goto __imp__fork;
}

__fxstat64()
{// addr = 0x0804A714
    goto __imp____fxstat64;
}

setsockopt()
{// addr = 0x0804A724
    goto __imp__setsockopt;
}

tcsetattr()
{// addr = 0x0804A734
    goto __imp__tcsetattr;
}

fcntl()
{// addr = 0x0804A744
    goto __imp__fcntl;
}

getrlimit64()
{// addr = 0x0804A754
    goto __imp__getrlimit64;
}

gmtime()
{// addr = 0x0804A764
    goto __imp__gmtime;
}

getgroups()
{// addr = 0x0804A774
    goto __imp__getgroups;
}

link()
{// addr = 0x0804A784
    goto __imp__link;
}

pipe()
{// addr = 0x0804A794
    goto __imp__pipe;
}

tan()
{// addr = 0x0804A7A4
    goto __imp__tan;
}

getsockopt()
{// addr = 0x0804A7B4
    goto __imp__getsockopt;
}

setgid()
{// addr = 0x0804A7C4
    goto __imp__setgid;
}

cosh()
{// addr = 0x0804A7D4
    goto __imp__cosh;
}

kill()
{// addr = 0x0804A7E4
    goto __imp__kill;
}

sin()
{// addr = 0x0804A7F4
    goto __imp__sin;
}

getpeername()
{// addr = 0x0804A804
    goto __imp__getpeername;
}

tcsendbreak()
{// addr = 0x0804A814
    goto __imp__tcsendbreak;
}

recvfrom()
{// addr = 0x0804A824
    goto __imp__recvfrom;
}

getpwnam()
{// addr = 0x0804A834
    goto __imp__getpwnam;
}

lseek64()
{// addr = 0x0804A844
    goto __imp__lseek64;
}

getitimer()
{// addr = 0x0804A854
    goto __imp__getitimer;
}

strcmp()
{// addr = 0x0804A864
    goto __imp__strcmp;
}

__sigsetjmp()
{// addr = 0x0804A874
    goto __imp____sigsetjmp;
}

getservbyname()
{// addr = 0x0804A884
    goto __imp__getservbyname;
}

exit()
{// addr = 0x0804A894
    goto __imp__exit;
}

cfsetispeed()
{// addr = 0x0804A8A4
    goto __imp__cfsetispeed;
}

fchmod()
{// addr = 0x0804A8B4
    goto __imp__fchmod;
}

sigsuspend()
{// addr = 0x0804A8C4
    goto __imp__sigsuspend;
}

getgid()
{// addr = 0x0804A8D4
    goto __imp__getgid;
}

ceil()
{// addr = 0x0804A8E4
    goto __imp__ceil;
}

geteuid()
{// addr = 0x0804A8F4
    goto __imp__geteuid;
}

_start(
    signed int __eax,                      // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0804A910
    _unknown_ __ebx;                       // r1
    signed int _t4;                        // _t4
    signed int _t5;                        // _t5

    __edx = __edx;
    _t3 = __eax;
    _pop(__esi);
    __ecx = __esp;
    __esp = __esp & -16;
    _push(__eax);
    _push(__esp);
    _push(__edx);
    _push(__libc_csu_fini);
    _push(__libc_csu_init);
    _push(__ecx);
    _push(__esi);
    _push(main);
    __libc_start_main();
    asm("hlt");
    0;
    0;
    _push(0);
    _push(_t5);
    __esp = __esp - 4;
    if(completed.5978 == 0) {
        _t3 = dtor_idx.5980;
        _t5 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t3 <  &__DTOR_END__) {
            do {
                _t4 = _t3 + 1;
                dtor_idx.5980 = _t4;
                 *((intOrPtr*)(_t4 * 4 +  &__DTOR_LIST__))();
                _t3 = dtor_idx.5980;
            } while(_t3 < _t5);
        }
        completed.5978 = 1;
    }
    __esp = __esp + 4;
    _pop(__ebx);
    _pop(__ebp);
}

__do_global_dtors_aux()
{// addr = 0x0804A940
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    signed int _t4;                        // _t4
    signed int _t5;                        // _t5
    signed int _t9;                        // _t9

    if(completed.5978 == 0) {
        _t4 = dtor_idx.5980;
        _t9 = ( &__DTOR_END__ -  &__DTOR_LIST__ >> 2) - 1;
        if(_t4 >=  &__DTOR_END__) {
L4:
            completed.5978 = 1;
            return;
        }
        do {
            _t5 = _t4 + 1;
            dtor_idx.5980 = _t5;
             *((intOrPtr*)(_t5 * 4 +  &__DTOR_LIST__))();
            _t4 = dtor_idx.5980;
        } while(_t4 < _t9);
        goto L4;
    }
}

frame_dummy()
{// addr = 0x0804A9A0
    if(__JCR_LIST__ == 0 || 0 == 0) {
        return;
    } else {
         *__esp =  &__JCR_LIST__;
         *0();
        return;
    }
}

caml_curry7(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AA50
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry7_1;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry7_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AA90
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry7_2;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry7_2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AAD0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry7_3;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry7_3(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AB10
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry7_4;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry7_4(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AB50
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry7_5;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry7_5(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AB90
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry7_6;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry7_6()
{// addr = 0x0804ABD0
    intOrPtr _t22;                         // _t22
    intOrPtr _t23;                         // _t23
    _unknown_ _t26;                        // _t26
    intOrPtr _t32;                         // _t32
    _unknown_ _t37;                        // _t37

    __esp[1] = _t22;
    _t37 = _t26;
    _t23 =  *((intOrPtr*)(_t37 + 12));
    _t32 =  *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t23 + 12)) + 12)) + 12)) + 12)) + 12));
    __esp[2] = _t32;
     *__esp =  *((intOrPtr*)(_t37 + 8));
    __esp[4] =  *((intOrPtr*)(_t23 + 8));
    __esp[3] =  *((intOrPtr*)(_t32 + 8));
    caml_extra_params = __esp[1];
     *134694272 = __esp[2];
    __esp = __esp + 20;
    goto __ebp;
}

caml_curry6(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AC40
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry6_1;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry6_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AC80
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry6_2;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry6_2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804ACC0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry6_3;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry6_3(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AD00
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry6_4;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry6_4(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AD40
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry6_5;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry6_5()
{// addr = 0x0804AD80
    intOrPtr _t18;                         // _t18
    _unknown_ _t21;                        // _t21
    intOrPtr _t26;                         // _t26

     *__esp = _t18;
    _t26 =  *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t21 + 12)) + 12)) + 12)) + 12)) + 12));
    __esp[1] = _t26;
    __esp[3] =  *((intOrPtr*)(_t21 + 8));
    __esp[2] =  *((intOrPtr*)(_t26 + 8));
    caml_extra_params = __esp[1];
    __esp = __esp + 16;
    goto __ebp;
}

caml_curry5(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804ADD0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry5_1;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry5_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AE10
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry5_2;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry5_2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AE50
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry5_3;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry5_3(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AE90
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry5_4;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry5_4()
{// addr = 0x0804AED0
    _unknown_ _t10;                        // _t10
    _unknown_ _t13;                        // _t13

    goto __ebp;
}

caml_curry4(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AEF0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry4_1;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry4_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AF30
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry4_2;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry4_2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AF70
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry4_3;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry4_3()
{// addr = 0x0804AFB0
    _unknown_ _t8;                         // _t8
    _unknown_ _t11;                        // _t11

    goto __edi;
}

caml_curry3(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804AFD0
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry3_1;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry3_1(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804B010
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry3_2;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry3_2()
{// addr = 0x0804B050
    _unknown_ _t6;                         // _t6
    _unknown_ _t9;                         // _t9

    goto ( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t9 + 12)) + 12)) + 8)));
}

caml_curry2(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804B070
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10

    __ebx = __ebx;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t10 = _t8 + 4;
     *((intOrPtr*)(_t10 - 4)) = 4343;
     *_t10 = caml_curry2_1;
    _t10[1] = 3;
    _t10[2] = __eax;
    _t10[3] = __ebx;
    return _t10;
}

intOrPtr caml_curry2_1()
{// addr = 0x0804B0B0
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    goto ( *((intOrPtr*)( *((intOrPtr*)(_t6 + 12)) + 8)));
}

caml_tuplify2()
{// addr = 0x0804B0C0
    _unknown_ _t3;                         // _t3
    _unknown_ _t5;                         // _t5

    goto ( *((intOrPtr*)(_t5 + 8)));
}

caml_tuplify3()
{// addr = 0x0804B0D0
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    goto ( *((intOrPtr*)(_t6 + 8)));
}

caml_apply3()
{// addr = 0x0804B0E0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t5;                         // _t5
    intOrPtr _t8;                          // _t8
    intOrPtr _t12;                         // _t12

    if(__edx[1] != 7) {
        _v4 = _t12;
         *__esp = _t8;
         *((intOrPtr*)( *__edx))();
         *((intOrPtr*)( *_t5))();
        __esp = __esp + 8;
        goto __ecx;
    }
    __esp = __esp + 8;
    goto __esi;
}

caml_apply2()
{// addr = 0x0804B130
    _unknown_ _t3;                         // _t3
    intOrPtr _t5;                          // _t5
    intOrPtr* _t8;                         // _t8

    if(_t8[1] != 5) {
         *__esp = _t5;
         *((intOrPtr*)( *_t8))();
        __esp = __esp + 4;
        goto __ecx;
    }
    __esp = __esp + 4;
    goto __edx;
}

camlStd_exit__entry()
{// addr = 0x0804B170
     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134679816))))))();
    return 1;
}

camlSource__lect_1031(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x0804B190
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _t21;                        // _t21
    _unknown_ _t23;                        // _t23
    intOrPtr _t26;                         // _t26
    intOrPtr _t29;                         // _t29
    intOrPtr* _t31;                        // _t31
    intOrPtr _t32;                         // _t32
    intOrPtr _t37;                         // _t37
    intOrPtr _t40;                         // _t40
    intOrPtr _t41;                         // _t41

    _t40 = __edx;
    _t37 = __ecx;
    _t32 = __ebx;
    _t21 = __eax;
    while(1) {
        _v12 = _t21;
        _v8 = _t32;
        _v4 = _t37;
         *__esp = _t40;
        _t23 = camlPervasives__input_1224( *134679576);
        if(_t23 == 1) {
            goto L2;
        }
        _t41 =  *__esp;
        if(_t23 != _t41) {
            _t40 = _t41 - _t23 + 1;
            _t37 = _v4 + _t23 - 1;
            _t21 = _v12;
            _t32 = _v8;
        } else {
            caml_c_call(20001);
            __esp = __esp + 4;
            _t32 = caml_create_string;
            while(1) {
                _t26 = caml_young_ptr - 12;
                caml_young_ptr = _t26;
                if(_t26 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t21 = _t26 + 4;
             *((intOrPtr*)(_t21 - 4)) = 2048;
             *_t21 = _v8;
            _t21[1] = _v12;
            _t40 = 20001;
            _t37 = 1;
        }
        continue;
L3:
        _t31 = _t29 + 4;
         *((intOrPtr*)(_t31 - 4)) = 3072;
         *_t31 = _v12;
        _t31[1] = _v8;
        _t31[2] = _v4;
        return _t31;
    }
    while(1) {
L2:
        _t29 = caml_young_ptr - 16;
        caml_young_ptr = _t29;
        if(_t29 >= caml_young_limit) {
            goto L3;
        }
        caml_call_gc();
    }
    goto L3;
}

camlSource__output_buf_1037(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x0804B280
    intOrPtr _t9;                          // _t9
    char* _t10;                            // _t10
    intOrPtr _t12;                         // _t12
    intOrPtr* _t14;                        // _t14
    intOrPtr _t19;                         // _t19

    _t9 =  *134679580;
    if(1 < 1 || __ebx < 1 || 1 > (( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) << 1) - __ebx + 2) {
        _t10 = "output";
    } else {
        _push(__ebx);
        _push(1);
        caml_c_call(__eax);
        __esp = __esp + 8;
        return caml_ml_output;
    }
    _t19 = _t10;
L2:
    _t12 = caml_young_ptr - 12;
    caml_young_ptr = _t12;
    if(_t12 >= caml_young_limit) {
        _t14 = _t12 + 4;
         *((intOrPtr*)(_t14 - 4)) = 2048;
         *_t14 =  &caml_exn_Invalid_argument;
        _t14[1] = _t19;
        caml_raise_exn(_t14);
    }
    caml_call_gc();
    goto L2;
}

camlSource__rev_write_1040(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr __ecx,                        // r2
    intOrPtr __edx,                        // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x0804B2A0
    intOrPtr* _t31;                        // _t31
    intOrPtr* _t34;                        // _t34
    intOrPtr _t43;                         // _t43
    intOrPtr* _t48;                        // _t48
    intOrPtr _t50;                         // _t50
    intOrPtr _t54;                         // _t54
    intOrPtr _t59;                         // _t59
    intOrPtr* _t60;                        // _t60
    intOrPtr _t69;                         // _t69
    intOrPtr _t70;                         // _t70

    _t70 = __esi;
    _t59 = __edx;
    _t54 = __ecx;
    _t48 = __ebx;
    _t31 = __eax;
    __esp = __esp - 20;
L1:
    while(_t70 == 1) {
        __esp[4] = _t31;
        if(_t48 != 1) {
            _t69 =  *_t48;
            _t70 = ( *(_t69 - 4) >> 10) * 4 - 1 - ( *(_t69 + ( *(_t69 - 4) >> 10) * 4 - 1) & 255) + ( *(_t69 - 4) >> 10) * 4 - 1 - ( *(_t69 + ( *(_t69 - 4) >> 10) * 4 - 1) & 255) + 1;
            while(1) {
                _t43 = caml_young_ptr - 24;
                caml_young_ptr = _t43;
                if(_t43 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            __ebp = _t43 + 4;
             *((intOrPtr*)(__ebp - 4)) = 2048;
             *__ebp = _t54;
             *((intOrPtr*)(__ebp + 4)) = _t59;
            _t31 = __ebp + 12;
             *((intOrPtr*)(_t31 - 4)) = 2048;
             *_t31 = __ebp;
             *((intOrPtr*)(_t31 + 4)) = __esp[4];
            _t48 =  *((intOrPtr*)(_t48 + 4));
            _t54 = _t69;
            _t59 = _t70;
            continue;
        }
        camlPervasives__output_1194( *134679580);
        _t34 =  *134669040;
        _t50 = __esp[4];
        __esp = __esp + 20;
        __esp = __esp - 8;
        while(1) {
            _t60 = _t34;
            if(_t50 == 1) {
                break;
            }
             *__esp = _t60;
            __esp[1] =  *((intOrPtr*)(_t50 + 4));
             *((intOrPtr*)( *_t60))();
            _t34 =  *__esp;
            _t50 = __esp[1];
        }
        __esp = __esp + 8;
        return 1;
    }
    if(( *(_t54 + (_t70 + -2 >> 1)) & 255) + ( *(_t54 + (_t70 + -2 >> 1)) & 255) + 1 != 21) {
        _t70 = _t70 + -2;
    } else {
        __esp[1] = _t70;
        __esp[3] = _t54;
        __esp[2] = _t48;
        __esp[4] = _t31;
         *__esp = _t59 - _t70 + 1;
        camlPervasives__output_1194( *134679580);
        L11();
        _t59 = __esp[1];
        _t70 = _t59 + -2;
        _t31 = 1;
        _t48 = __esp[2];
        _t54 = __esp[3];
    }
    goto L1;
}

camlSource__entry()
{// addr = 0x0804B3E0
    intOrPtr* _t8;                         // _t8

    camlSource = 20001;
     *134669036 =  &camlSource__3;
     *134669040 =  &camlSource__2;
     *134669044 =  &camlSource__1;
    caml_c_call(20001);
    __esp = __esp + 4;
    _t8 = camlSource__lect_1031(1, caml_create_string, 1, 20001);
     *134669048 =  *_t8;
     *134669052 = _t8[1];
     *134669056 = _t8[2];
    __esi =  *134669056;
    camlSource__rev_write_1040(1,  *134669048,  *134669052,  *134669056,  *134669056);
    return 1;
}

camlUnix__fun_2828(
    signed int __eax,                      // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __edi,                       // r4
    _unknown_ __esi                        // r5
)
{// addr = 0x0804B4E0
    intOrPtr _t14;                         // _t14
    intOrPtr* _t16;                        // _t16
    intOrPtr _t24;                         // _t24

    __esi = __esi;
    __edi = __edi;
    __ebx = __ebx;
    if((__eax & 1) == 0) {
        __eflags = ( *(__eax - 4) & 255) - 1;
        if(__eflags < 0) {
            goto L9;
        } else {
            if(__eflags > 0) {
                 *((intOrPtr*)( *((intOrPtr*)(__ebx + 12)))) =  *__eax;
                return 1;
            } else {
                _t24 =  *__eax;
                while(1) {
                    _t14 = caml_young_ptr - 8;
                    caml_young_ptr = _t14;
                    __eflags = _t14 - caml_young_limit;
                    if(_t14 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t16 = _t14 + 4;
                 *((intOrPtr*)(_t16 - 4)) = 1024;
                 *_t16 = _t24;
                caml_modify(__ebx, __edi, __esi,  *((intOrPtr*)(__ebx + 8)), _t16);
                return 1;
            }
        }
    } else {
        if(__eax >> 1 < 2) {
L9:
            return 1;
        } else {
             *((intOrPtr*)( *((intOrPtr*)(__ebx + 16)))) = 3;
            return 1;
        }
    }
}

camlUnix__get_port_1739(
    intOrPtr __eax,                        // r0
    intOrPtr __ecx                         // r2
)
{// addr = 0x0804B560
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t29;                        // _t29
    intOrPtr _t33;                         // _t33
    intOrPtr* _t36;                        // _t36
    intOrPtr _t43;                         // _t43
    intOrPtr* _t46;                        // _t46
    intOrPtr _t49;                         // _t49
    intOrPtr* _t51;                        // _t51
    intOrPtr _t52;                         // _t52
    intOrPtr* _t54;                        // _t54
    intOrPtr* _t56;                        // _t56
    intOrPtr* _t57;                        // _t57
    intOrPtr _t62;                         // _t62

    _t29 = caml_string_equal( *((intOrPtr*)(__ecx + 12)),  &camlUnix__215);
    if(_t29 == 1) {
        _v8 = __ecx;
         *__esp = _t52;
        _v4 = __eax;
        L11();
        if( *_t29 !=  &caml_exn_Failure) {
            caml_raise_exn(_t29);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            caml_c_call( *((intOrPtr*)(__ecx + 12)));
            while(1) {
                _t33 = caml_young_ptr - 24;
                caml_young_ptr = _t33;
                if(_t33 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t54 = _t33 + 4;
             *((intOrPtr*)(_t54 - 4)) = 2048;
             *_t54 = _v0;
             *((intOrPtr*)(_t54 + 4)) = caml_int_of_string;
            _t36 = _t54 + 12;
             *((intOrPtr*)(_t36 - 4)) = 2048;
             *_t36 = _t54;
            _t36[1] = 1;
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
            return _t36;
        } else {
            L7();
            if( *_t29 !=  &caml_exn_Not_found) {
                caml_raise_exn(_t29);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                caml_c_call(_v8);
                _t62 =  *((intOrPtr*)(0x80589a3));
                while(1) {
                    _t43 = caml_young_ptr - 24;
                    caml_young_ptr = _t43;
                    if(_t43 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t56 = _t43 + 4;
                 *((intOrPtr*)(_t56 - 4)) = 2048;
                 *_t56 = _v0;
                 *((intOrPtr*)(_t56 + 4)) = _t62;
                _t46 = _t56 + 12;
                 *((intOrPtr*)(_t46 - 4)) = 2048;
                 *_t46 = _t56;
                _t46[1] = 1;
                _pop(caml_exception_pointer);
                __esp = __esp + 4;
                return _t46;
            } else {
                return 1;
            }
        }
    } else {
        while(1) {
            _t49 = caml_young_ptr - 24;
            caml_young_ptr = _t49;
            if(_t49 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t57 = _t49 + 4;
         *((intOrPtr*)(_t57 - 4)) = 2048;
         *_t57 = __eax;
         *((intOrPtr*)(_t57 + 4)) = 1;
        _t51 = _t57 + 12;
         *((intOrPtr*)(_t51 - 4)) = 2048;
         *_t51 = _t57;
        _t51[1] = 1;
        return _t51;
    }
}

L0804B610(
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{
    intOrPtr _t16;                         // _t16
    intOrPtr* _t19;                        // _t19

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_a4);
    __ecx =  *((intOrPtr*)(0x80589a3));
    while(1) {
        _t16 = caml_young_ptr - 24;
        caml_young_ptr = _t16;
        if(_t16 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ebx = _t16 + 4;
     *((intOrPtr*)(__ebx - 4)) = 2048;
     *__ebx = _a12;
     *((intOrPtr*)(__ebx + 4)) = __ecx;
    _t19 = __ebx + 12;
     *((intOrPtr*)(_t19 - 4)) = 2048;
     *_t19 = __ebx;
    _t19[1] = 1;
    _pop(caml_exception_pointer);
    __esp = __esp + 12;
    return _t19;
}

L0804B6A0(
    _unknown_ __edi,                       // r4
    intOrPtr _a12                          // _cfa_c
)
{
    intOrPtr _t11;                         // _t11
    intOrPtr* _t14;                        // _t14

    __edi = __edi;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call( *((intOrPtr*)(__edi + 12)));
    while(1) {
        _t11 = caml_young_ptr - 24;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ebx = _t11 + 4;
     *((intOrPtr*)(__ebx - 4)) = 2048;
     *__ebx = _a12;
     *((intOrPtr*)(__ebx + 4)) = caml_int_of_string;
    _t14 = __ebx + 12;
     *((intOrPtr*)(_t14 - 4)) = 2048;
     *_t14 = __ebx;
    _t14[1] = 1;
    _pop(caml_exception_pointer);
    __esp = __esp + 12;
    return _t14;
}

camlUnix__fun_2833(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x0804B730
    intOrPtr _t7;                          // _t7
    intOrPtr* _t9;                         // _t9

    while(1) {
        _t7 = caml_young_ptr - 12;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t9 = _t7 + 4;
     *((intOrPtr*)(_t9 - 4)) = 2048;
     *_t9 = __eax;
    _t9[1] =  *((intOrPtr*)( *((intOrPtr*)(__ebx + 8))));
    return _t9;
}

camlUnix__fun_2836(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x0804B770
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t20;                         // _t20
    intOrPtr* _t22;                        // _t22
    intOrPtr _t28;                         // _t28
    intOrPtr* _t29;                        // _t29
    intOrPtr* _t31;                        // _t31
    intOrPtr _t37;                         // _t37
    intOrPtr* _t39;                        // _t39

    while(1) {
        _t20 = caml_young_ptr - 28;
        caml_young_ptr = _t20;
        if(_t20 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t22 = _t20 + 4;
     *((intOrPtr*)(_t22 - 4)) = 6391;
     *_t22 = caml_tuplify2;
    _t22[1] = -3;
    _t22[2] =  &camlUnix__code_begin;
    _t22[3] =  *((intOrPtr*)(__ecx + 12));
    _t22[4] = __eax;
    _t22[5] = __ebx;
    _t31 =  *((intOrPtr*)(__ecx + 16));
    __esp = __esp - 12;
    _t39 = _t22;
    if(_t31 == 1) {
        __esp = __esp + 12;
        return 1;
    } else {
         *__esp = _t39;
        _v8 = _t31[1];
         *((intOrPtr*)( *_t39))();
        _v4 =  *_t31;
        L4();
        _t37 =  *__esp;
        while(1) {
            _t28 = caml_young_ptr - 12;
            caml_young_ptr = _t28;
            if(_t28 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t29 = _t28 + 4;
         *((intOrPtr*)(_t29 - 4)) = 2048;
         *_t29 = _v4;
        _t29[1] = _t37;
        __esp = __esp + 12;
        return _t29;
    }
}

camlUnix__fun_2857(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B7C0
    caml_c_call(__eax);
    return unix_close;
}

camlUnix__fun_2863(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B7D0
    caml_c_call(__eax);
    return unix_close;
}

camlUnix__fun_2562(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B7E0
    caml_c_call(__eax);
    return unix_setsid;
}

camlUnix__fun_2564(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B7F0
    caml_c_call(__ebx);
    return unix_tcflow;
}

camlUnix__fun_2566(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B800
    caml_c_call(__ebx);
    return unix_tcflush;
}

camlUnix__fun_2568(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B810
    caml_c_call(__eax);
    return unix_tcdrain;
}

camlUnix__fun_2570(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B820
    caml_c_call(__ebx);
    return unix_tcsendbreak;
}

camlUnix__fun_2572(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B830
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_tcsetattr;
}

camlUnix__fun_2574(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B850
    caml_c_call(__eax);
    return unix_tcgetattr;
}

camlUnix__fun_2576(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B860
    caml_c_call(__ebx);
    return unix_getservbyport;
}

camlUnix__fun_2578(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B870
    caml_c_call(__ebx);
    return unix_getservbyname;
}

camlUnix__fun_2580(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B880
    caml_c_call(__eax);
    return unix_getprotobynumber;
}

camlUnix__fun_2582(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B890
    caml_c_call(__eax);
    return unix_getprotobyname;
}

camlUnix__fun_2584(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B8A0
    caml_c_call(__eax);
    return unix_gethostbyaddr;
}

camlUnix__fun_2586(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B8B0
    caml_c_call(__eax);
    return unix_gethostbyname;
}

camlUnix__fun_2588(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B8C0
    caml_c_call(__eax);
    return unix_gethostname;
}

camlUnix__fun_2590(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B8D0
    caml_c_call(__eax);
    return unix_getpeername;
}

camlUnix__fun_2592(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B8E0
    caml_c_call(__eax);
    return unix_getsockname;
}

camlUnix__fun_2594(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B8F0
    caml_c_call(__ebx);
    return unix_shutdown;
}

camlUnix__fun_2596(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B900
    caml_c_call(__ebx);
    return unix_listen;
}

camlUnix__fun_2598(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B910
    caml_c_call(__ebx);
    return unix_connect;
}

camlUnix__fun_2600(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B920
    caml_c_call(__ebx);
    return unix_bind;
}

camlUnix__fun_2602(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B930
    caml_c_call(__eax);
    return unix_accept;
}

camlUnix__fun_2604(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B940
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_socketpair;
}

camlUnix__fun_2606(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B960
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_socket;
}

camlUnix__fun_2608(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B980
    caml_c_call(__eax);
    return unix_string_of_inet_addr;
}

camlUnix__fun_2610(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B990
    caml_c_call(__eax);
    return unix_inet_addr_of_string;
}

camlUnix__fun_2612(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B9A0
    caml_c_call(__eax);
    return unix_getgrgid;
}

camlUnix__fun_2614(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B9B0
    caml_c_call(__eax);
    return unix_getpwuid;
}

camlUnix__fun_2616(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B9C0
    caml_c_call(__eax);
    return unix_getgrnam;
}

camlUnix__fun_2618(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B9D0
    caml_c_call(__eax);
    return unix_getpwnam;
}

camlUnix__fun_2620(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B9E0
    caml_c_call(__eax);
    return unix_getlogin;
}

camlUnix__fun_2622(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804B9F0
    caml_c_call(__ebx);
    return unix_initgroups;
}

camlUnix__fun_2624(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA00
    caml_c_call(__eax);
    return unix_setgroups;
}

camlUnix__fun_2626(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA10
    caml_c_call(__eax);
    return unix_getgroups;
}

camlUnix__fun_2628(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA20
    caml_c_call(__eax);
    return unix_setgid;
}

camlUnix__fun_2630(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA30
    caml_c_call(__eax);
    return unix_getegid;
}

camlUnix__fun_2632(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA40
    caml_c_call(__eax);
    return unix_getgid;
}

camlUnix__fun_2634(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA50
    caml_c_call(__eax);
    return unix_setuid;
}

camlUnix__fun_2636(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA60
    caml_c_call(__eax);
    return unix_geteuid;
}

camlUnix__fun_2638(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA70
    caml_c_call(__eax);
    return unix_getuid;
}

camlUnix__fun_2640(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA80
    caml_c_call(__ebx);
    return unix_setitimer;
}

camlUnix__fun_2642(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BA90
    caml_c_call(__eax);
    return unix_getitimer;
}

camlUnix__fun_2644(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BAA0
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_utimes;
}

camlUnix__fun_2646(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BAC0
    caml_c_call(__eax);
    return unix_times;
}

camlUnix__fun_2648(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BAD0
    caml_c_call(__eax);
    return unix_sleep;
}

camlUnix__fun_2650(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BAE0
    caml_c_call(__eax);
    return unix_alarm;
}

camlUnix__fun_2652(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BAF0
    caml_c_call(__eax);
    return unix_mktime;
}

camlUnix__fun_2654(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB00
    caml_c_call(__eax);
    return unix_localtime;
}

camlUnix__fun_2656(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB10
    caml_c_call(__eax);
    return unix_gmtime;
}

camlUnix__fun_2658(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB20
    caml_c_call(__eax);
    return unix_gettimeofday;
}

camlUnix__fun_2660(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB30
    caml_c_call(__eax);
    return unix_time;
}

camlUnix__fun_2662(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB40
    caml_c_call(__eax);
    return unix_sigsuspend;
}

camlUnix__fun_2664(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB50
    caml_c_call(__eax);
    return unix_sigpending;
}

camlUnix__fun_2666(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB60
    caml_c_call(__ebx);
    return unix_sigprocmask;
}

camlUnix__fun_2668(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB70
    caml_c_call(__ebx);
    return unix_kill;
}

camlUnix__fun_2670(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BB80
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_lockf;
}

camlUnix__fun_2672(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BBA0
    _push(__edx);
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 8;
    return unix_select;
}

camlUnix__fun_2674(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BBC0
    caml_c_call(__eax);
    return unix_readlink;
}

camlUnix__fun_2676(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BBD0
    caml_c_call(__ebx);
    return unix_symlink;
}

camlUnix__fun_2678(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BBE0
    caml_c_call(__ebx);
    return unix_mkfifo;
}

camlUnix__fun_2680(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BBF0
    caml_c_call(__eax);
    return unix_pipe;
}

camlUnix__fun_2682(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC00
    caml_c_call(__eax);
    return unix_closedir;
}

camlUnix__fun_2684(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC10
    caml_c_call(__eax);
    return unix_rewinddir;
}

camlUnix__fun_2686(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC20
    caml_c_call(__eax);
    return unix_readdir;
}

camlUnix__fun_2688(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC30
    caml_c_call(__eax);
    return unix_opendir;
}

camlUnix__fun_2690(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC40
    caml_c_call(__eax);
    return unix_chroot;
}

camlUnix__fun_2692(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC50
    caml_c_call(__eax);
    return unix_getcwd;
}

camlUnix__fun_2694(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC60
    caml_c_call(__eax);
    return unix_chdir;
}

camlUnix__fun_2696(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC70
    caml_c_call(__eax);
    return unix_rmdir;
}

camlUnix__fun_2698(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC80
    caml_c_call(__ebx);
    return unix_mkdir;
}

camlUnix__fun_2700(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BC90
    caml_c_call(__eax);
    return unix_clear_close_on_exec;
}

camlUnix__fun_2702(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BCA0
    caml_c_call(__eax);
    return unix_set_close_on_exec;
}

camlUnix__fun_2704(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BCB0
    caml_c_call(__eax);
    return unix_clear_nonblock;
}

camlUnix__fun_2706(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BCC0
    caml_c_call(__eax);
    return unix_set_nonblock;
}

camlUnix__fun_2708(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BCD0
    caml_c_call(__ebx);
    return unix_dup2;
}

camlUnix__fun_2710(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BCE0
    caml_c_call(__eax);
    return unix_dup;
}

camlUnix__fun_2712(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BCF0
    caml_c_call(__ebx);
    return unix_access;
}

camlUnix__fun_2714(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BD00
    caml_c_call(__eax);
    return unix_umask;
}

camlUnix__fun_2716(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BD10
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_fchown;
}

camlUnix__fun_2718(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BD30
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_chown;
}

camlUnix__fun_2720(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BD50
    caml_c_call(__ebx);
    return unix_fchmod;
}

camlUnix__fun_2722(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BD60
    caml_c_call(__ebx);
    return unix_chmod;
}

camlUnix__fun_2724(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BD70
    caml_c_call(__ebx);
    return unix_link;
}

camlUnix__fun_2726(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BD80
    caml_c_call(__ebx);
    return unix_rename;
}

camlUnix__fun_2728(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BD90
    caml_c_call(__eax);
    return unix_unlink;
}

camlUnix__fun_2730(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BDA0
    caml_c_call(__eax);
    return unix_isatty;
}

camlUnix__fun_2732(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BDB0
    caml_c_call(__eax);
    return unix_fstat;
}

camlUnix__fun_2734(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BDC0
    caml_c_call(__eax);
    return unix_lstat;
}

camlUnix__fun_2736(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BDD0
    caml_c_call(__eax);
    return unix_stat;
}

camlUnix__fun_2738(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BDE0
    caml_c_call(__ebx);
    return unix_ftruncate;
}

camlUnix__fun_2740(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BDF0
    caml_c_call(__ebx);
    return unix_truncate;
}

camlUnix__fun_2742(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BE00
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_lseek;
}

camlUnix__fun_2744(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BE20
    caml_c_call(__eax);
    return caml_channel_descriptor;
}

camlUnix__fun_2746(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BE30
    caml_c_call(__eax);
    return caml_channel_descriptor;
}

camlUnix__fun_2748(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BE40
    caml_c_call(__eax);
    return caml_ml_open_descriptor_out;
}

camlUnix__fun_2750(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BE50
    caml_c_call(__eax);
    return caml_ml_open_descriptor_in;
}

camlUnix__fun_2752(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BE60
    caml_c_call(__eax);
    return unix_close;
}

camlUnix__fun_2754(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BE70
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_open;
}

camlUnix__fun_2756(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BE90
    caml_c_call(__eax);
    return unix_nice;
}

camlUnix__fun_2758(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BEA0
    caml_c_call(__eax);
    return unix_getppid;
}

camlUnix__fun_2760(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BEB0
    caml_c_call(__eax);
    return unix_getpid;
}

camlUnix__fun_2762(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BEC0
    caml_c_call(__ebx);
    return unix_waitpid;
}

camlUnix__fun_2764(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BED0
    caml_c_call(__eax);
    return unix_wait;
}

camlUnix__fun_2766(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BEE0
    caml_c_call(__eax);
    return unix_fork;
}

camlUnix__fun_2768(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BEF0
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_execvpe;
}

camlUnix__fun_2770(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BF10
    caml_c_call(__ebx);
    return unix_execvp;
}

camlUnix__fun_2772(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BF20
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_execve;
}

camlUnix__fun_2774(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BF40
    caml_c_call(__ebx);
    return unix_execv;
}

camlUnix__fun_2776(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BF50
    caml_c_call(__ebx);
    return unix_putenv;
}

camlUnix__fun_2778(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BF60
    caml_c_call(__eax);
    return caml_sys_getenv;
}

camlUnix__fun_2780(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BF70
    caml_c_call(__eax);
    return unix_environment;
}

camlUnix__fun_2782(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804BF80
    caml_c_call(__eax);
    return unix_error_message;
}

camlUnix__handle_unix_error_1171()
{// addr = 0x0804BF90
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t24;                        // _t24
    intOrPtr* _t25;                        // _t25
    char* _t30;                            // _t30
    intOrPtr _t32;                         // _t32
    intOrPtr* _t33;                        // _t33
    intOrPtr _t43;                         // _t43
    intOrPtr* _t60;                        // _t60
    intOrPtr* _t65;                        // _t65
    intOrPtr _t66;                         // _t66
    intOrPtr _t81;                         // _t81

    __esp = __esp - 12;
    __edx = _t24;
    _t25 = _t60;
    L6();
    _t81 = camlUnix;
    if( *_t25 != _t81) {
        caml_raise_exn(_t25);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
         *((intOrPtr*)( *__edx))();
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        __esp = __esp + 12;
        return;
    } else {
        _v4 = _t25[3];
         *__esp = _t25[2];
        _v8 = _t25[1];
        _t65 = camlSys;
        _t29 =  *(_t65 - 4) >> 9;
        if( *(_t65 - 4) >> 9 <= 1) {
            caml_ml_array_bound_error();
            if(_t81 < 1 || __edx < 1 || _t81 > (( *(_t65 - 4) >> 10) * 4 - 1 - ( *(_t65 + ( *(_t65 - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
                _t30 = "Unix.read";
                _t66 = _t30;
                while(1) {
                    _t32 = caml_young_ptr - 12;
                    caml_young_ptr = _t32;
                    if(_t32 >= caml_young_limit) {
                        _t33 = _t32 + 4;
                         *((intOrPtr*)(_t33 - 4)) = 2048;
                         *_t33 =  &caml_exn_Invalid_argument;
                        _t33[1] = _t66;
                        caml_raise_exn(_t33);
                    }
                    caml_call_gc();
                }
            }
            _push(__edx);
            _push(_t81);
            caml_c_call(_t65);
            __esp = __esp + 8;
            return;
        } else {
            camlPervasives__output_string_1191( *134679584,  *_t65);
            camlPervasives__output_string_1191( *134679584,  &camlUnix__214);
            camlPervasives__output_string_1191( *134679584,  *__esp);
            camlPervasives__output_string_1191( *134679584, "" failed");
            _t43 = _v4;
            if(( *(_t43 - 4) >> 10) * 4 - 1 - ( *(_t43 + ( *(_t43 - 4) >> 10) * 4 - 1) & 255) + ( *(_t43 - 4) >> 10) * 4 - 1 - ( *(_t43 + ( *(_t43 - 4) >> 10) * 4 - 1) & 255) + 1 > 1) {
                _v4 = _t43;
                camlPervasives__output_string_1191( *134679584,  &camlUnix__212);
                camlPervasives__output_string_1191( *134679584, _v4);
                camlPervasives__output_string_1191( *134679584,  &camlUnix__211);
            }
            camlPervasives__output_string_1191( *134679584,  &camlUnix__210);
            caml_c_call(_v8);
            camlPervasives__prerr_endline_1285(unix_error_message);
            __esp = __esp + 12;
            __esp = __esp - 4;
             *__esp = 5;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134679816))))))();
            caml_c_call( *__esp);
            __esp = __esp + 4;
            return;
        }
    }
}

L0804C0A0(
    intOrPtr* __edx                        // r3
)
{
    __edx = __edx;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
     *((intOrPtr*)( *__edx))();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    __esp = __esp + 12;
}

camlUnix__read_1237(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx,                       // r2
    _unknown_ __edx                        // r3
)
{// addr = 0x0804C0D0
    char* _t9;                             // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    intOrPtr _t17;                         // _t17

    __edx = __edx;
    __ecx = __ecx;
    if(__ecx < 1 || __edx < 1 || __ecx > (( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
        _t9 = "Unix.read";
        _t17 = _t9;
L6:
        _t11 = caml_young_ptr - 12;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 2048;
             *_t13 =  &caml_exn_Invalid_argument;
            _t13[1] = _t17;
            caml_raise_exn(_t13);
        }
        caml_call_gc();
        goto L6;
    } else {
        _push(__edx);
        _push(__ecx);
        caml_c_call(__ebx);
        __esp = __esp + 8;
        return unix_read;
    }
}

camlUnix__write_1242(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C120
    char* _t9;                             // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    _unknown_ _t16;                        // _t16
    intOrPtr _t17;                         // _t17

    if(__ecx < 1 || __edx < 1 || __ecx > (( *(_t16 - 4) >> 10) * 4 - 1 - ( *(_t16 + ( *(_t16 - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
        _t9 = "Unix.write";
        _t17 = _t9;
L6:
        _t11 = caml_young_ptr - 12;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 2048;
             *_t13 =  &caml_exn_Invalid_argument;
            _t13[1] = _t17;
            caml_raise_exn(_t13);
        }
        caml_call_gc();
        goto L6;
    } else {
        _push(__edx);
        _push(__ecx);
        caml_c_call(_t16);
        __esp = __esp + 8;
        return unix_write;
    }
}

camlUnix__single_write_1247(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C170
    char* _t9;                             // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    _unknown_ _t16;                        // _t16
    intOrPtr _t17;                         // _t17

    if(__ecx < 1 || __edx < 1 || __ecx > (( *(_t16 - 4) >> 10) * 4 - 1 - ( *(_t16 + ( *(_t16 - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
        _t9 = "Unix.single_write";
        _t17 = _t9;
L6:
        _t11 = caml_young_ptr - 12;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 2048;
             *_t13 =  &caml_exn_Invalid_argument;
            _t13[1] = _t17;
            caml_raise_exn(_t13);
        }
        caml_call_gc();
        goto L6;
    } else {
        _push(__edx);
        _push(__ecx);
        caml_c_call(_t16);
        __esp = __esp + 8;
        return unix_single_write;
    }
}

camlUnix__fun_2804(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C1C0
    caml_c_call(__eax);
    return unix_fstat_64;
}

camlUnix__fun_2802(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C1D0
    caml_c_call(__eax);
    return unix_lstat_64;
}

camlUnix__fun_2800(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C1E0
    caml_c_call(__eax);
    return unix_stat_64;
}

camlUnix__fun_2798(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C1F0
    caml_c_call(__ebx);
    return unix_ftruncate_64;
}

camlUnix__fun_2796(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C200
    caml_c_call(__ebx);
    return unix_truncate_64;
}

camlUnix__fun_2794(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C210
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_lseek_64;
}

camlUnix__try_set_close_on_exec_1366(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804C230
    _unknown_ _t2;                         // _t2

    L3();
    if( *__eax !=  &caml_exn_Invalid_argument) {
        _t2 = caml_raise_exn(__eax);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        caml_c_call(_t2);
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        return 3;
    } else {
        return 1;
    }
}

L0804C260(
    _unknown_ __eax                        // r0
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(__eax);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return 3;
}

camlUnix__pause_1408()
{// addr = 0x0804C290
    caml_c_call(3);
    __esp = __esp + 4;
    caml_c_call(unix_sigprocmask);
    return unix_sigsuspend;
}

camlUnix__is_inet6_addr_1500(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C2B0
    return (( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + 1 == 33 & 255) + (( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + 1 == 33 & 255) + 1;
}

camlUnix__domain_of_sockaddr_1529(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804C2E0
    if(( *(__eax - 4) & 255) == 0) {
        return 1;
    } else {
        if(( *( *__eax - 4) >> 10) * 4 - 1 - ( *( *__eax + ( *( *__eax - 4) >> 10) * 4 - 1) & 255) + ( *( *__eax - 4) >> 10) * 4 - 1 - ( *( *__eax + ( *( *__eax - 4) >> 10) * 4 - 1) & 255) + 1 != 33) {
            return 3;
        } else {
            return 5;
        }
    }
}

camlUnix__recv_1558(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C330
    char* _t9;                             // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    _unknown_ _t16;                        // _t16
    intOrPtr _t17;                         // _t17

    if(__ecx < 1 || __edx < 1 || __ecx > (( *(_t16 - 4) >> 10) * 4 - 1 - ( *(_t16 + ( *(_t16 - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
        _t9 = "Unix.recv";
        _t17 = _t9;
L6:
        _t11 = caml_young_ptr - 12;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 2048;
             *_t13 =  &caml_exn_Invalid_argument;
            _t13[1] = _t17;
            caml_raise_exn(_t13);
        }
        caml_call_gc();
        goto L6;
    } else {
        _push(__esi);
        _push(__edx);
        _push(__ecx);
        caml_c_call(_t16);
        __esp = __esp + 12;
        return unix_recv;
    }
}

camlUnix__recvfrom_1564(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C380
    char* _t9;                             // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    _unknown_ _t16;                        // _t16
    intOrPtr _t17;                         // _t17

    if(__ecx < 1 || __edx < 1 || __ecx > (( *(_t16 - 4) >> 10) * 4 - 1 - ( *(_t16 + ( *(_t16 - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
        _t9 = "Unix.recvfrom";
        _t17 = _t9;
L6:
        _t11 = caml_young_ptr - 12;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 2048;
             *_t13 =  &caml_exn_Invalid_argument;
            _t13[1] = _t17;
            caml_raise_exn(_t13);
        }
        caml_call_gc();
        goto L6;
    } else {
        _push(__esi);
        _push(__edx);
        _push(__ecx);
        caml_c_call(_t16);
        __esp = __esp + 12;
        return unix_recvfrom;
    }
}

camlUnix__send_1570(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C3D0
    char* _t9;                             // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    _unknown_ _t16;                        // _t16
    intOrPtr _t17;                         // _t17

    if(__ecx < 1 || __edx < 1 || __ecx > (( *(_t16 - 4) >> 10) * 4 - 1 - ( *(_t16 + ( *(_t16 - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
        _t9 = "Unix.send";
        _t17 = _t9;
L6:
        _t11 = caml_young_ptr - 12;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 2048;
             *_t13 =  &caml_exn_Invalid_argument;
            _t13[1] = _t17;
            caml_raise_exn(_t13);
        }
        caml_call_gc();
        goto L6;
    } else {
        _push(__esi);
        _push(__edx);
        _push(__ecx);
        caml_c_call(_t16);
        __esp = __esp + 12;
        return unix_send;
    }
}

camlUnix__sendto_1576(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804C420
    char* _t10;                            // _t10
    intOrPtr _t12;                         // _t12
    intOrPtr* _t14;                        // _t14
    _unknown_ _t21;                        // _t21
    intOrPtr _t22;                         // _t22

    if(__ecx < 1 || __edx < 1) {
L4:
        _t10 = "Unix.sendto";
        __esp = __esp + 4;
        _t22 = _t10;
        while(1) {
            _t12 = caml_young_ptr - 12;
            caml_young_ptr = _t12;
            if(_t12 >= caml_young_limit) {
                _t14 = _t12 + 4;
                 *((intOrPtr*)(_t14 - 4)) = 2048;
                 *_t14 =  &caml_exn_Invalid_argument;
                _t14[1] = _t22;
                caml_raise_exn(_t14);
            }
            caml_call_gc();
        }
    } else {
         *__esp = __eax;
        if(__ecx > (( *(_t21 - 4) >> 10) * 4 - 1 - ( *(_t21 + ( *(_t21 - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
            goto L4;
        }
        _push(__edi);
        _push(__esi);
        _push(__edx);
        _push(__ecx);
        caml_c_call(_t21);
        __esp = __esp + 16;
        return unix_sendto_native;
    }
}

camlUnix__fun_2816(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C480
    _push(__edx);
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 8;
    return unix_setsockopt;
}

camlUnix__fun_2814(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C4A0
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    return unix_getsockopt;
}

camlUnix__getsockopt_1643(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C4C0
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 4;
    return unix_getsockopt;
}

camlUnix__setsockopt_1646(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C4E0
    _push(__ecx);
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 8;
    return unix_setsockopt;
}

camlUnix__getsockopt_int_1650(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C500
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 4;
    return unix_getsockopt;
}

camlUnix__setsockopt_int_1653(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C520
    _push(__ecx);
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 8;
    return unix_setsockopt;
}

camlUnix__getsockopt_optint_1657(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C540
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 4;
    return unix_getsockopt;
}

camlUnix__setsockopt_optint_1660(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C560
    _push(__ecx);
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 8;
    return unix_setsockopt;
}

camlUnix__getsockopt_float_1664(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C580
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 4;
    return unix_getsockopt;
}

camlUnix__setsockopt_float_1667(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C5A0
    _push(__ecx);
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 8;
    return unix_setsockopt;
}

camlUnix__getsockopt_error_1671(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804C5C0
    _push(__eax);
    caml_c_call(9);
    __esp = __esp + 8;
    return unix_getsockopt;
}

camlUnix__getaddrinfo_emulation_1730(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x0804C5E0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _t75;                         // _t75
    intOrPtr* _t77;                        // _t77
    intOrPtr _t80;                         // _t80
    intOrPtr* _t83;                        // _t83
    intOrPtr _t87;                         // _t87
    intOrPtr* _t88;                        // _t88
    intOrPtr _t92;                         // _t92
    intOrPtr _t96;                         // _t96
    intOrPtr* _t98;                        // _t98
    intOrPtr* _t99;                        // _t99
    intOrPtr* _t102;                       // _t102
    intOrPtr _t106;                        // _t106
    intOrPtr* _t108;                       // _t108
    intOrPtr _t115;                        // _t115
    intOrPtr* _t117;                       // _t117
    intOrPtr _t122;                        // _t122
    intOrPtr _t126;                        // _t126
    intOrPtr _t136;                        // _t136
    intOrPtr* _t138;                       // _t138
    intOrPtr _t144;                        // _t144
    intOrPtr _t145;                        // _t145
    intOrPtr* _t146;                       // _t146
    intOrPtr _t150;                        // _t150
    _unknown_ _t153;                       // _t153
    intOrPtr* _t155;                       // _t155
    intOrPtr* _t156;                       // _t156
    intOrPtr _t157;                        // _t157
    intOrPtr* _t161;                       // _t161
    intOrPtr* _t165;                       // _t165
    intOrPtr _t168;                        // _t168
    intOrPtr* _t171;                       // _t171
    intOrPtr* _t172;                       // _t172

    __esp = __esp - 20;
    _v8 = __eax;
     *__esp = __ebx;
    _v4 = __ecx;
    while(1) {
        _t75 = caml_young_ptr - 48;
        caml_young_ptr = _t75;
        if(_t75 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __edi = _t75 + 4;
    _v16 = __edi;
     *((intOrPtr*)(__edi - 4)) = 1024;
     *__edi = 1;
    __esi = __edi + 8;
    _v12 = __esi;
     *((intOrPtr*)(__esi - 4)) = 1024;
     *__esi = 1;
    _t172 = __edi + 16;
     *((intOrPtr*)(_t172 - 4)) = 1024;
     *_t172 = 1;
    _t77 = __edi + 24;
     *((intOrPtr*)(_t77 - 4)) = 5367;
     *_t77 = camlUnix__fun_2828;
    _t77[1] = 3;
    _t77[2] = __edi;
    _t77[3] = __esi;
    _t77[4] = _t172;
    camlList__iter_1074(_t77, __ecx);
    while(1) {
        _t80 = caml_young_ptr - 20;
        caml_young_ptr = _t80;
        if(_t80 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t161 = _t80 + 4;
     *((intOrPtr*)(_t161 - 4)) = 4343;
     *_t161 = caml_curry2;
     *((intOrPtr*)(_t161 + 4)) = 5;
     *((intOrPtr*)(_t161 + 8)) = camlUnix__get_port_1739;
    _t173 =  *__esp;
     *((intOrPtr*)(_t161 + 12)) =  *__esp;
    _t83 =  *_v16;
    if(_t83 == 1) {
         *__esp = _t161;
        _v16 = camlUnix__get_port_1739(3, _t161);
        _t87 = camlUnix__get_port_1739(1,  *__esp);
        L41();
         *__esp = _t87;
    } else {
        _t157 =  *_t83;
        if(_t157 == 3) {
             *__esp = camlUnix__get_port_1739(3, _t161);
        } else {
            if(_t157 == 1) {
                 *__esp = camlUnix__get_port_1739(1, _t161);
            } else {
                if(caml_string_equal(_t173,  &camlUnix__202) == 1) {
                     *__esp = 1;
                } else {
                    while(1) {
                        _t136 = caml_young_ptr - 24;
                        caml_young_ptr = _t136;
                        if(_t136 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t171 = _t136 + 4;
                     *((intOrPtr*)(_t171 - 4)) = 2048;
                     *_t171 = _t157;
                     *((intOrPtr*)(_t171 + 4)) = 1;
                    _t138 = _t171 + 12;
                     *__esp = _t138;
                     *((intOrPtr*)(_t138 - 4)) = 2048;
                     *_t138 = _t171;
                    _t138[1] = 1;
                }
            }
        }
    }
    _push( &camlUnix__197);
    _t144 = _v8;
    _push(_t144);
    _t88 = caml_string_equal();
    __esp = __esp + 8;
    if(_t88 == 1) {
        _v8 = _t144;
        L28();
        _t145 =  *_t88;
        if(_t145 !=  &caml_exn_Failure) {
            caml_raise_exn(_t88);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            caml_c_call(_t145);
            while(1) {
                _t92 = caml_young_ptr - 24;
                caml_young_ptr = _t92;
                if(_t92 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t146 = _t92 + 4;
             *((intOrPtr*)(_t146 - 4)) = 2048;
             *_t146 = unix_inet_addr_of_string;
             *((intOrPtr*)(_t146 + 4)) = _v4;
            _t165 = _t146 + 12;
             *((intOrPtr*)(_t165 - 4)) = 2048;
             *_t165 = _t146;
            _t165[1] = 1;
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
        } else {
            L24();
            if( *_t88 !=  &caml_exn_Not_found) {
                caml_raise_exn(_t88);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                caml_c_call(_v4);
                _v12 = unix_gethostbyname;
                _t153 = camlArray__to_list_1121( *((intOrPtr*)(0x805816f)));
                while(1) {
                    _t115 = caml_young_ptr - 16;
                    caml_young_ptr = _t115;
                    if(_t115 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t117 = _t115 + 4;
                 *((intOrPtr*)(_t117 - 4)) = 3319;
                 *_t117 = camlUnix__fun_2833;
                _t117[1] = 3;
                _t117[2] = _v12;
                _t165 = camlList__map_1062(_t117, _t153);
                _pop(caml_exception_pointer);
                __esp = __esp + 4;
            } else {
                _t165 = 1;
            }
        }
    } else {
        if(camlList__mem_1161(5, _v4) == 1) {
            while(1) {
                _t122 = caml_young_ptr - 24;
                caml_young_ptr = _t122;
                if(_t122 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t155 = _t122 + 4;
             *((intOrPtr*)(_t155 - 4)) = 2048;
             *_t155 =  *134669708;
             *((intOrPtr*)(_t155 + 4)) = "127.0.0.1";
            _t165 = _t155 + 12;
             *((intOrPtr*)(_t165 - 4)) = 2048;
             *_t165 = _t155;
            _t165[1] = 1;
        } else {
            while(1) {
                _t126 = caml_young_ptr - 24;
                caml_young_ptr = _t126;
                if(_t126 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t156 = _t126 + 4;
             *((intOrPtr*)(_t156 - 4)) = 2048;
             *_t156 =  *134669704;
             *((intOrPtr*)(_t156 + 4)) = "0.0.0.0";
            _t165 = _t156 + 12;
             *((intOrPtr*)(_t165 - 4)) = 2048;
             *_t165 = _t156;
             *((intOrPtr*)(_t165 + 4)) = 1;
            while(1) {
L31:
                _t96 = caml_young_ptr - 24;
                caml_young_ptr = _t96;
                if(_t96 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t98 = _t96 + 4;
             *((intOrPtr*)(_t98 - 4)) = 5367;
             *_t98 = caml_tuplify2;
            _t98[1] = -3;
            _t98[2] = camlUnix__fun_2836;
            _t98[3] = _v8;
            _t98[4] = _t165;
            _t99 = camlList__map_1062(_t98,  *__esp);
            __esp = __esp + 20;
            __esp = __esp - 4;
            if(_t99 == 1) {
                __esp = __esp + 4;
                return 1;
            } else {
                 *__esp =  *_t99;
                L47();
                _t150 = _t99[1];
                _t102 =  *__esp;
                __esp = __esp + 4;
                __esp = __esp - 4;
                if(_t102 == 1) {
                    __esp = __esp + 4;
                    return _t150;
                } else {
                     *__esp =  *_t102;
                    L41();
                    _t168 = _t102[1];
                    while(1) {
                        _t106 = caml_young_ptr - 12;
                        caml_young_ptr = _t106;
                        if(_t106 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t108 = _t106 + 4;
                     *((intOrPtr*)(_t108 - 4)) = 2048;
                     *_t108 =  *__esp;
                    _t108[1] = _t168;
                    __esp = __esp + 4;
                    return _t108;
                }
            }
        }
    }
    goto L31;
}

L0804C8C0(
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    intOrPtr _t26;                         // _t26
    intOrPtr* _t28;                        // _t28
    intOrPtr _t31;                         // _t31
    intOrPtr* _t33;                        // _t33
    intOrPtr* _t34;                        // _t34
    intOrPtr* _t37;                        // _t37
    intOrPtr _t41;                         // _t41
    intOrPtr* _t43;                        // _t43
    _unknown_ _t44;                        // _t44
    intOrPtr _t48;                         // _t48
    intOrPtr _t51;                         // _t51
    intOrPtr _t54;                         // _t54

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_a16);
    _a8 = unix_gethostbyname;
    _t44 = camlArray__to_list_1121( *((intOrPtr*)(0x805816f)));
    while(1) {
        _t26 = caml_young_ptr - 16;
        caml_young_ptr = _t26;
        if(_t26 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t28 = _t26 + 4;
     *((intOrPtr*)(_t28 - 4)) = 3319;
     *_t28 = camlUnix__fun_2833;
    _t28[1] = 3;
    _t28[2] = _a8;
    _t51 = camlList__map_1062(_t28, _t44);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    while(1) {
        _t31 = caml_young_ptr - 24;
        caml_young_ptr = _t31;
        if(_t31 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t33 = _t31 + 4;
     *((intOrPtr*)(_t33 - 4)) = 5367;
     *_t33 = caml_tuplify2;
    _t33[1] = -3;
    _t33[2] = camlUnix__fun_2836;
    _t33[3] = _a12;
    _t33[4] = _t51;
    _t34 = camlList__map_1062(_t33,  *__esp);
    __esp = __esp + 20;
    __esp = __esp - 4;
    if(_t34 == 1) {
        __esp = __esp + 4;
        return 1;
    } else {
         *__esp =  *_t34;
        L13();
        _t48 = _t34[1];
        _t37 =  *__esp;
        __esp = __esp + 4;
        __esp = __esp - 4;
        if(_t37 == 1) {
            __esp = __esp + 4;
            return _t48;
        } else {
             *__esp =  *_t37;
            L7();
            _t54 = _t37[1];
            while(1) {
                _t41 = caml_young_ptr - 12;
                caml_young_ptr = _t41;
                if(_t41 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t43 = _t41 + 4;
             *((intOrPtr*)(_t43 - 4)) = 2048;
             *_t43 =  *__esp;
            _t43[1] = _t54;
            __esp = __esp + 4;
            return _t43;
        }
    }
}

L0804C950(
    _unknown_ __ebx,                       // r1
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    intOrPtr _t22;                         // _t22
    intOrPtr _t26;                         // _t26
    intOrPtr* _t28;                        // _t28
    intOrPtr* _t29;                        // _t29
    intOrPtr* _t32;                        // _t32
    intOrPtr _t36;                         // _t36
    intOrPtr* _t38;                        // _t38
    intOrPtr* _t40;                        // _t40
    intOrPtr _t44;                         // _t44
    intOrPtr* _t47;                        // _t47
    intOrPtr _t50;                         // _t50

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(__ebx);
    while(1) {
        _t22 = caml_young_ptr - 24;
        caml_young_ptr = _t22;
        if(_t22 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t40 = _t22 + 4;
     *((intOrPtr*)(_t40 - 4)) = 2048;
     *_t40 = unix_inet_addr_of_string;
     *((intOrPtr*)(_t40 + 4)) = _a16;
    _t47 = _t40 + 12;
     *((intOrPtr*)(_t47 - 4)) = 2048;
     *_t47 = _t40;
     *((intOrPtr*)(_t47 + 4)) = 1;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    while(1) {
        _t26 = caml_young_ptr - 24;
        caml_young_ptr = _t26;
        if(_t26 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t28 = _t26 + 4;
     *((intOrPtr*)(_t28 - 4)) = 5367;
     *_t28 = caml_tuplify2;
    _t28[1] = -3;
    _t28[2] = camlUnix__fun_2836;
    _t28[3] = _a12;
    _t28[4] = _t47;
    _t29 = camlList__map_1062(_t28,  *__esp);
    __esp = __esp + 20;
    __esp = __esp - 4;
    if(_t29 == 1) {
        __esp = __esp + 4;
        return 1;
    } else {
         *__esp =  *_t29;
        L13();
        _t44 = _t29[1];
        _t32 =  *__esp;
        __esp = __esp + 4;
        __esp = __esp - 4;
        if(_t32 == 1) {
            __esp = __esp + 4;
            return _t44;
        } else {
             *__esp =  *_t32;
            L7();
            _t50 = _t32[1];
            while(1) {
                _t36 = caml_young_ptr - 12;
                caml_young_ptr = _t36;
                if(_t36 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t38 = _t36 + 4;
             *((intOrPtr*)(_t38 - 4)) = 2048;
             *_t38 =  *__esp;
            _t38[1] = _t50;
            __esp = __esp + 4;
            return _t38;
        }
    }
}

camlUnix__getaddrinfo_1751(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    char* __ecx                            // r2
)
{// addr = 0x0804CA50
    char* _v4;                             // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    _unknown_ _t78;                        // _t78
    _unknown_ _t80;                        // _t80
    intOrPtr _t82;                         // _t82
    intOrPtr* _t84;                        // _t84
    intOrPtr _t87;                         // _t87
    intOrPtr* _t90;                        // _t90
    intOrPtr _t94;                         // _t94
    intOrPtr* _t95;                        // _t95
    intOrPtr _t99;                         // _t99
    intOrPtr _t103;                        // _t103
    intOrPtr* _t105;                       // _t105
    intOrPtr* _t106;                       // _t106
    intOrPtr* _t109;                       // _t109
    intOrPtr _t113;                        // _t113
    intOrPtr* _t115;                       // _t115
    intOrPtr _t122;                        // _t122
    intOrPtr* _t124;                       // _t124
    intOrPtr _t129;                        // _t129
    intOrPtr _t133;                        // _t133
    intOrPtr _t143;                        // _t143
    intOrPtr* _t145;                       // _t145
    intOrPtr _t147;                        // _t147
    intOrPtr _t153;                        // _t153
    intOrPtr _t154;                        // _t154
    intOrPtr* _t155;                       // _t155
    intOrPtr _t159;                        // _t159
    _unknown_ _t162;                       // _t162
    intOrPtr* _t164;                       // _t164
    intOrPtr* _t165;                       // _t165
    intOrPtr _t166;                        // _t166
    intOrPtr* _t171;                       // _t171
    intOrPtr* _t175;                       // _t175
    intOrPtr _t178;                        // _t178
    intOrPtr* _t181;                       // _t181
    intOrPtr* _t182;                       // _t182

    __esp = __esp - 12;
     *__esp = __eax;
    _v8 = __ebx;
    _v4 = __ecx;
    L44();
    _t147 =  *__eax;
    if(_t147 !=  &caml_exn_Invalid_argument) {
        _t78 = caml_raise_exn(__eax);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _push( &caml_exn_Invalid_argument);
        caml_c_call(_t147);
        __esp = __esp + 4;
        _t80 = camlList__rev_append_1051(unix_getaddrinfo, 1);
        _pop(caml_exception_pointer);
        __esp = __esp + 12;
        return _t80;
    } else {
        __eax =  *__esp;
        __ebx = _v8;
        __ecx = _v4;
        __esp = __esp + 12;
        __esp = __esp - 20;
        _v8 = __eax;
         *__esp = _t147;
        _v4 =  &caml_exn_Invalid_argument;
        while(1) {
            _t82 = caml_young_ptr - 48;
            caml_young_ptr = _t82;
            if(_t82 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        __edi = _t82 + 4;
        _v16 = __edi;
         *((intOrPtr*)(__edi - 4)) = 1024;
         *__edi = 1;
        __esi = __edi + 8;
        _v12 = __esi;
         *((intOrPtr*)(__esi - 4)) = 1024;
         *__esi = 1;
        _t182 = __edi + 16;
         *((intOrPtr*)(_t182 - 4)) = 1024;
         *_t182 = 1;
        _t84 = __edi + 24;
         *((intOrPtr*)(_t84 - 4)) = 5367;
         *_t84 = camlUnix__fun_2828;
        _t84[1] = 3;
        _t84[2] = __edi;
        _t84[3] = __esi;
        _t84[4] = _t182;
        camlList__iter_1074(_t84,  &caml_exn_Invalid_argument);
        while(1) {
            _t87 = caml_young_ptr - 20;
            caml_young_ptr = _t87;
            if(_t87 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t171 = _t87 + 4;
         *((intOrPtr*)(_t171 - 4)) = 4343;
         *_t171 = caml_curry2;
         *((intOrPtr*)(_t171 + 4)) = 5;
         *((intOrPtr*)(_t171 + 8)) = camlUnix__get_port_1739;
        _t183 =  *__esp;
         *((intOrPtr*)(_t171 + 12)) =  *__esp;
        _t90 =  *_v16;
        if(_t90 == 1) {
             *__esp = _t171;
            _v16 = camlUnix__get_port_1739(3, _t171);
            _t94 = camlUnix__get_port_1739(1,  *__esp);
            L45();
             *__esp = _t94;
        } else {
            _t166 =  *_t90;
            if(_t166 == 3) {
                 *__esp = camlUnix__get_port_1739(3, _t171);
            } else {
                if(_t166 == 1) {
                     *__esp = camlUnix__get_port_1739(1, _t171);
                } else {
                    if(caml_string_equal(_t183,  &camlUnix__202) == 1) {
                         *__esp = 1;
                    } else {
                        while(1) {
                            _t143 = caml_young_ptr - 24;
                            caml_young_ptr = _t143;
                            if(_t143 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t181 = _t143 + 4;
                         *((intOrPtr*)(_t181 - 4)) = 2048;
                         *_t181 = _t166;
                         *((intOrPtr*)(_t181 + 4)) = 1;
                        _t145 = _t181 + 12;
                         *__esp = _t145;
                         *((intOrPtr*)(_t145 - 4)) = 2048;
                         *_t145 = _t181;
                        _t145[1] = 1;
                    }
                }
            }
        }
        _push( &camlUnix__197);
        _t153 = _v8;
        _push(_t153);
        _t95 = caml_string_equal();
        __esp = __esp + 8;
        if(_t95 == 1) {
            _v8 = _t153;
            L29();
            _t154 =  *_t95;
            if(_t154 !=  &caml_exn_Failure) {
                caml_raise_exn(_t95);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                caml_c_call(_t154);
                while(1) {
                    _t99 = caml_young_ptr - 24;
                    caml_young_ptr = _t99;
                    if(_t99 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t155 = _t99 + 4;
                 *((intOrPtr*)(_t155 - 4)) = 2048;
                 *_t155 = unix_inet_addr_of_string;
                 *((intOrPtr*)(_t155 + 4)) = _v4;
                _t175 = _t155 + 12;
                 *((intOrPtr*)(_t175 - 4)) = 2048;
                 *_t175 = _t155;
                _t175[1] = 1;
                _pop(caml_exception_pointer);
                __esp = __esp + 4;
            } else {
                L25();
                if( *_t95 !=  &caml_exn_Not_found) {
                    caml_raise_exn(_t95);
                    _push(caml_exception_pointer);
                    caml_exception_pointer = __esp;
                    caml_c_call(_v4);
                    _v12 = unix_gethostbyname;
                    _t162 = camlArray__to_list_1121( *((intOrPtr*)(0x805816f)));
                    while(1) {
                        _t122 = caml_young_ptr - 16;
                        caml_young_ptr = _t122;
                        if(_t122 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t124 = _t122 + 4;
                     *((intOrPtr*)(_t124 - 4)) = 3319;
                     *_t124 = camlUnix__fun_2833;
                    _t124[1] = 3;
                    _t124[2] = _v12;
                    _t175 = camlList__map_1062(_t124, _t162);
                    _pop(caml_exception_pointer);
                    __esp = __esp + 4;
                } else {
                    _t175 = 1;
                }
            }
        } else {
            if(camlList__mem_1161(5, _v4) == 1) {
                while(1) {
                    _t129 = caml_young_ptr - 24;
                    caml_young_ptr = _t129;
                    if(_t129 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t164 = _t129 + 4;
                 *((intOrPtr*)(_t164 - 4)) = 2048;
                 *_t164 =  *134669708;
                 *((intOrPtr*)(_t164 + 4)) = "127.0.0.1";
                _t175 = _t164 + 12;
                 *((intOrPtr*)(_t175 - 4)) = 2048;
                 *_t175 = _t164;
                _t175[1] = 1;
            } else {
                while(1) {
                    _t133 = caml_young_ptr - 24;
                    caml_young_ptr = _t133;
                    if(_t133 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t165 = _t133 + 4;
                 *((intOrPtr*)(_t165 - 4)) = 2048;
                 *_t165 =  *134669704;
                 *((intOrPtr*)(_t165 + 4)) = "0.0.0.0";
                _t175 = _t165 + 12;
                 *((intOrPtr*)(_t175 - 4)) = 2048;
                 *_t175 = _t165;
                 *((intOrPtr*)(_t175 + 4)) = 1;
                while(1) {
L32:
                    _t103 = caml_young_ptr - 24;
                    caml_young_ptr = _t103;
                    if(_t103 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t105 = _t103 + 4;
                 *((intOrPtr*)(_t105 - 4)) = 5367;
                 *_t105 = caml_tuplify2;
                _t105[1] = -3;
                _t105[2] = camlUnix__fun_2836;
                _t105[3] = _v8;
                _t105[4] = _t175;
                _t106 = camlList__map_1062(_t105,  *__esp);
                __esp = __esp + 20;
                __esp = __esp - 4;
                if(_t106 == 1) {
                    __esp = __esp + 4;
                    return 1;
                } else {
                     *__esp =  *_t106;
                    L51();
                    _t159 = _t106[1];
                    _t109 =  *__esp;
                    __esp = __esp + 4;
                    __esp = __esp - 4;
                    if(_t109 == 1) {
                        __esp = __esp + 4;
                        return _t159;
                    } else {
                         *__esp =  *_t109;
                        L45();
                        _t178 = _t109[1];
                        while(1) {
                            _t113 = caml_young_ptr - 12;
                            caml_young_ptr = _t113;
                            if(_t113 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t115 = _t113 + 4;
                         *((intOrPtr*)(_t115 - 4)) = 2048;
                         *_t115 =  *__esp;
                        _t115[1] = _t178;
                        __esp = __esp + 4;
                        return _t115;
                    }
                }
                goto L54;
            }
        }
        goto L32;
    }
L54:
}

L0804CAA0(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{
    _unknown_ _t3;                         // _t3

    __ecx = __ecx;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(__ecx);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    _t3 = camlList__rev_append_1051(unix_getaddrinfo, 1);
    _pop(caml_exception_pointer);
    __esp = __esp + 12;
    return _t3;
}

camlUnix__getnameinfo_emulation_1772(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804CAE0
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t22;                         // _t22
    intOrPtr* _t24;                        // _t24
    intOrPtr* _t27;                        // _t27
    char* _t33;                            // _t33
    intOrPtr _t37;                         // _t37
    intOrPtr* _t39;                        // _t39
    intOrPtr _t41;                         // _t41
    intOrPtr* _t43;                        // _t43
    intOrPtr _t51;                         // _t51
    intOrPtr* _t53;                        // _t53
    intOrPtr _t56;                         // _t56
    intOrPtr _t67;                         // _t67

    if(( *(__eax - 4) & 255) == 0) {
        _t56 =  *__eax;
        while(1) {
            _t22 = caml_young_ptr - 12;
            caml_young_ptr = _t22;
            if(_t22 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t24 = _t22 + 4;
         *((intOrPtr*)(_t24 - 4)) = 2048;
         *_t24 =  &camlUnix__192;
        _t24[1] = _t56;
        return _t24;
    } else {
        _v4 = __ebx;
        _v8 =  *((intOrPtr*)(__eax + 4));
         *__esp =  *__eax;
        if( *((intOrPtr*)(L0804CB90(__ebx))) !=  &caml_exn_Not_found) {
            _t27 = caml_raise_exn(_t26);
        } else {
            if(camlList__mem_1161(5, _v4) != 1) {
                while(1) {
                    _t51 = caml_young_ptr - 8;
                    caml_young_ptr = _t51;
                    if(_t51 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t53 = _t51 + 4;
                 *((intOrPtr*)(_t53 - 4)) = 1024;
                 *_t53 =  &caml_exn_Not_found;
                caml_raise_exn(_t53);
            }
            _push( *__esp);
            _t27 = unix_string_of_inet_addr;
            caml_c_call();
            __esp = __esp + 4;
        }
         *__esp = _t27;
        L11();
        if( *_t27 !=  &caml_exn_Not_found) {
            caml_raise_exn(_t27);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            if(camlList__mem_1161(7, _v0) != 1) {
                while(1) {
                    _t41 = caml_young_ptr - 8;
                    caml_young_ptr = _t41;
                    if(_t41 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t43 = _t41 + 4;
                 *((intOrPtr*)(_t43 - 4)) = 1024;
                 *_t43 =  &caml_exn_Not_found;
                caml_raise_exn(_t43);
            }
            if(camlList__mem_1161(9, _v0) == 1) {
                _t33 =  &camlUnix__193;
            } else {
                _t33 =  &camlUnix__194;
            }
            caml_c_call(_t33);
            _t67 =  *unix_getservbyport;
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
        } else {
            _t67 = camlPervasives__string_of_int_1130(_v8);
            while(1) {
L18:
                _t37 = caml_young_ptr - 12;
                caml_young_ptr = _t37;
                if(_t37 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t39 = _t37 + 4;
             *((intOrPtr*)(_t39 - 4)) = 2048;
             *_t39 =  *__esp;
            _t39[1] = _t67;
            return _t39;
            goto L27;
        }
        goto L18;
    }
L27:
}

L0804CB90(
    _unknown_ __ebx,                       // r1
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    intOrPtr _t18;                         // _t18
    char* _t24;                            // _t24
    intOrPtr _t28;                         // _t28
    intOrPtr* _t30;                        // _t30
    intOrPtr _t32;                         // _t32
    intOrPtr* _t34;                        // _t34
    intOrPtr _t39;                         // _t39
    intOrPtr* _t41;                        // _t41
    intOrPtr _t49;                         // _t49

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    if(camlList__mem_1161(3, __ebx) != 1) {
        while(1) {
            _t39 = caml_young_ptr - 8;
            caml_young_ptr = _t39;
            if(_t39 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t41 = _t39 + 4;
         *((intOrPtr*)(_t41 - 4)) = 1024;
         *_t41 =  &caml_exn_Not_found;
        caml_raise_exn(_t41);
    }
    caml_c_call(_a4);
    _t18 =  *unix_gethostbyaddr;
    _a4 = unix_gethostbyaddr;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    L7();
    if( *unix_gethostbyaddr !=  &caml_exn_Not_found) {
        caml_raise_exn(_t18);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        if(camlList__mem_1161(7, _a16) != 1) {
            while(1) {
                _t32 = caml_young_ptr - 8;
                caml_young_ptr = _t32;
                if(_t32 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t34 = _t32 + 4;
             *((intOrPtr*)(_t34 - 4)) = 1024;
             *_t34 =  &caml_exn_Not_found;
            caml_raise_exn(_t34);
        }
        if(camlList__mem_1161(9, _a16) == 1) {
            _t24 =  &camlUnix__193;
        } else {
            _t24 =  &camlUnix__194;
        }
        caml_c_call(_t24);
        _t49 =  *unix_getservbyport;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
    } else {
        _t49 = camlPervasives__string_of_int_1130(_a8);
        while(1) {
L14:
            _t28 = caml_young_ptr - 12;
            caml_young_ptr = _t28;
            if(_t28 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t30 = _t28 + 4;
         *((intOrPtr*)(_t30 - 4)) = 2048;
         *_t30 =  *__esp;
        _t30[1] = _t49;
        __esp = __esp + 12;
        return _t30;
    }
    goto L14;
}

L0804CC40(
    _unknown_ _a8,                         // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{
    char* _t13;                            // _t13
    intOrPtr _t17;                         // _t17
    intOrPtr* _t19;                        // _t19
    intOrPtr _t21;                         // _t21
    intOrPtr* _t23;                        // _t23

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    if(camlList__mem_1161(7, _a12) != 1) {
        while(1) {
            _t21 = caml_young_ptr - 8;
            caml_young_ptr = _t21;
            if(_t21 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t23 = _t21 + 4;
         *((intOrPtr*)(_t23 - 4)) = 1024;
         *_t23 =  &caml_exn_Not_found;
        caml_raise_exn(_t23);
    }
    if(camlList__mem_1161(9, _a12) == 1) {
        _t13 =  &camlUnix__193;
    } else {
        _t13 =  &camlUnix__194;
    }
    caml_c_call(_t13);
    __ecx =  *unix_getservbyport;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    while(1) {
        _t17 = caml_young_ptr - 12;
        caml_young_ptr = _t17;
        if(_t17 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t19 = _t17 + 4;
     *((intOrPtr*)(_t19 - 4)) = 2048;
     *_t19 =  *__esp;
    _t19[1] = __ecx;
    __esp = __esp + 12;
    return _t19;
}

camlUnix__getnameinfo_1781(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804CD60
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    _unknown_ _t23;                        // _t23
    intOrPtr _t26;                         // _t26
    intOrPtr* _t28;                        // _t28
    intOrPtr* _t31;                        // _t31
    char* _t37;                            // _t37
    intOrPtr _t41;                         // _t41
    intOrPtr* _t43;                        // _t43
    intOrPtr _t45;                         // _t45
    intOrPtr* _t47;                        // _t47
    intOrPtr _t55;                         // _t55
    intOrPtr* _t57;                        // _t57
    intOrPtr _t59;                         // _t59
    intOrPtr _t60;                         // _t60
    intOrPtr _t61;                         // _t61
    intOrPtr _t73;                         // _t73

    __esp = __esp - 8;
     *__esp = __eax;
    _v4 = _t59;
    L30();
    _t60 =  *__eax;
    if(_t60 !=  &caml_exn_Invalid_argument) {
        _t23 = caml_raise_exn(__eax);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        caml_c_call(_t60);
        _pop(caml_exception_pointer);
        __esp = __esp + 8;
        return unix_getnameinfo;
    } else {
        __eax =  *__esp;
        __ebx = _v4;
        __esp = __esp + 8;
        __esp = __esp - 12;
        if(( *(__eax - 4) & 255) == 0) {
            _t61 =  *__eax;
            while(1) {
                _t26 = caml_young_ptr - 12;
                caml_young_ptr = _t26;
                if(_t26 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t28 = _t26 + 4;
             *((intOrPtr*)(_t28 - 4)) = 2048;
             *_t28 =  &camlUnix__192;
            _t28[1] = _t61;
            __esp = __esp + 12;
            return _t28;
        } else {
            _v4 = _t60;
            _v8 =  *((intOrPtr*)(__eax + 4));
             *__esp =  *__eax;
            if( *((intOrPtr*)(L0804CB90(_t60))) !=  &caml_exn_Not_found) {
                _t31 = caml_raise_exn(_t30);
            } else {
                if(camlList__mem_1161(5, _v4) != 1) {
                    while(1) {
                        _t55 = caml_young_ptr - 8;
                        caml_young_ptr = _t55;
                        if(_t55 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t57 = _t55 + 4;
                     *((intOrPtr*)(_t57 - 4)) = 1024;
                     *_t57 =  &caml_exn_Not_found;
                    caml_raise_exn(_t57);
                }
                _push( *__esp);
                _t31 = unix_string_of_inet_addr;
                caml_c_call();
                __esp = __esp + 4;
            }
             *__esp = _t31;
            L12();
            if( *_t31 !=  &caml_exn_Not_found) {
                caml_raise_exn(_t31);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                if(camlList__mem_1161(7, _v0) != 1) {
                    while(1) {
                        _t45 = caml_young_ptr - 8;
                        caml_young_ptr = _t45;
                        if(_t45 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t47 = _t45 + 4;
                     *((intOrPtr*)(_t47 - 4)) = 1024;
                     *_t47 =  &caml_exn_Not_found;
                    caml_raise_exn(_t47);
                }
                if(camlList__mem_1161(9, _v0) == 1) {
                    _t37 =  &camlUnix__193;
                } else {
                    _t37 =  &camlUnix__194;
                }
                caml_c_call(_t37);
                _t73 =  *unix_getservbyport;
                _pop(caml_exception_pointer);
                __esp = __esp + 4;
            } else {
                _t73 = camlPervasives__string_of_int_1130(_v8);
                while(1) {
L19:
                    _t41 = caml_young_ptr - 12;
                    caml_young_ptr = _t41;
                    if(_t41 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t43 = _t41 + 4;
                 *((intOrPtr*)(_t43 - 4)) = 2048;
                 *_t43 =  *__esp;
                _t43[1] = _t73;
                __esp = __esp + 12;
                return _t43;
                goto L31;
            }
            goto L19;
        }
    }
L31:
}

L0804CDA0(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{
    __ebx = __ebx;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(__ebx);
    _pop(caml_exception_pointer);
    __esp = __esp + 8;
    return unix_getnameinfo;
}

camlUnix__system_1891()
{// addr = 0x0804CDD0
    intOrPtr _t1;                          // _t1

     *__esp = _t1;
    caml_c_call(1);
    __esp = __esp + 4;
    if(unix_fork == 1) {
        L0804CE30();
        __esp = __esp + 4;
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134679816))))))();
        caml_c_call( *__esp);
        return;
    } else {
        caml_c_call(unix_fork);
        return;
    }
}

L0804CE30(
    intOrPtr _a4                           // _cfa_4
)
{
    intOrPtr _t7;                          // _t7

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    while(1) {
        _t7 = caml_young_ptr - 16;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ebx = _t7 + 4;
     *((intOrPtr*)(__ebx - 4)) = 3072;
     *__ebx = "/bin/sh";
    __ebx[1] =  &camlUnix__191;
    __ebx[2] = _a4;
    caml_c_call(__ebx);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return unix_execv;
}

camlUnix__safe_dup_1894(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804CEA0
    intOrPtr _v4;                          // _cfa_fffffffc

     *__esp = __eax;
    caml_c_call(__eax);
    if(unix_dup < 7) {
        _v4 = unix_dup;
         *__esp = camlUnix__safe_dup_1894( *__esp);
        caml_c_call(_v4);
        return  *__esp;
    } else {
        return unix_dup;
    }
}

camlUnix__safe_close_1898(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804CEF0
    _unknown_ _t2;                         // _t2

    L3();
    if( *__eax != camlUnix) {
        _t2 = caml_raise_exn(__eax);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        caml_c_call(_t2);
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        return unix_close;
    } else {
        return 1;
    }
}

L0804CF20(
    _unknown_ __eax                        // r0
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(__eax);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return unix_close;
}

camlUnix__perform_redirections_1900(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804CF50
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec

     *__esp = __eax;
    _v20 = __ebx;
    _v16 = __ecx;
    _v12 = camlUnix__safe_dup_1894(__eax);
    _v8 = camlUnix__safe_dup_1894(_v20);
    _v4 = camlUnix__safe_dup_1894(_v16);
    camlUnix__safe_close_1898( *__esp);
    camlUnix__safe_close_1898(_v20);
    camlUnix__safe_close_1898(_v16);
    caml_c_call(_v12);
    __esp = __esp + 4;
    caml_c_call(_v12);
    _push(3);
    caml_c_call(_v8);
    __esp = __esp + 4;
    caml_c_call(_v8);
    _push(5);
    caml_c_call(_v4);
    __esp = __esp + 4;
    caml_c_call(_v4);
    return unix_close;
}

camlUnix__create_process_1907()
{// addr = 0x0804D020
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _t5;                          // _t5
    intOrPtr _t13;                         // _t13
    intOrPtr _t15;                         // _t15

    __esp = __esp - 20;
    _v4 = _t5;
    _v8 = _t13;
     *__esp = _t15;
    _v16 = __edx;
    _v12 = __esi;
    caml_c_call(1);
    __esp = __esp + 4;
    if(unix_fork == 1) {
        L0804D070();
        __esp = __esp + 20;
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134679816))))))();
        caml_c_call( *__esp);
        __esp = __esp + 4;
        return;
    } else {
        __esp = __esp + 20;
        return;
    }
}

L0804D070(
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    _unknown_ _a20                         // _cfa_14
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlUnix__perform_redirections_1900(_a4);
    caml_c_call(_a16);
    _pop(caml_exception_pointer);
    __esp = __esp + 20;
    return unix_execvp;
}

camlUnix__create_process_env_1914()
{// addr = 0x0804D0C0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t6;                          // _t6
    intOrPtr _t14;                         // _t14
    intOrPtr _t16;                         // _t16

    __esp = __esp - 24;
    _v4 = _t6;
    _v8 = _t14;
    _v12 = _t16;
     *__esp = __edx;
    _v20 = __esi;
    _v16 = __edi;
    caml_c_call(1);
    __esp = __esp + 4;
    if(unix_fork == 1) {
        L0804D120();
        __esp = __esp + 24;
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134679816))))))();
        caml_c_call( *__esp);
        __esp = __esp + 4;
        return;
    } else {
        __esp = __esp + 24;
        return;
    }
}

L0804D120(
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    intOrPtr _a20,                         // _cfa_14
    _unknown_ _a24                         // _cfa_18
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlUnix__perform_redirections_1900(_a4);
    _push(_a16);
    caml_c_call(_a20);
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 24;
    return unix_execvpe;
}

signed int camlUnix__open_proc_1949(
    signed int __eax                       // r0
)
{// addr = 0x0804D170
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _t105;                      // _t105
    signed int _t106;                      // _t106
    signed int _t122;                      // _t122
    signed int _t123;                      // _t123
    intOrPtr _t126;                        // _t126
    signed int _t127;                      // _t127
    intOrPtr _t129;                        // _t129
    signed int _t130;                      // _t130
    unsigned int _t132;                    // _t132
    unsigned int _t134;                    // _t134
    intOrPtr _t136;                        // _t136
    intOrPtr* _t137;                       // _t137
    intOrPtr _t141;                        // _t141
    unsigned int _t154;                    // _t154
    intOrPtr _t155;                        // _t155
    signed int _t158;                      // _t158
    signed int _t160;                      // _t160
    intOrPtr _t164;                        // _t164
    signed int _t172;                      // _t172
    intOrPtr _t175;                        // _t175
    intOrPtr _t179;                        // _t179
    unsigned int _t182;                    // _t182
    signed int _t183;                      // _t183
    signed int _t189;                      // _t189
    signed int _t191;                      // _t191
    signed int _t196;                      // _t196
    unsigned int _t197;                    // _t197
    signed int _t199;                      // _t199
    unsigned int _t200;                    // _t200
    signed int _t203;                      // _t203
    unsigned int _t206;                    // _t206
    signed int _t210;                      // _t210
    signed int _t213;                      // _t213
    signed int _t214;                      // _t214
    signed int _t215;                      // _t215
    signed int _t216;                      // _t216
    signed int _t218;                      // _t218
    signed int _t220;                      // _t220

    __esp = __esp - 24;
    _v20 = __eax;
    _v4 = _t175;
    _v8 = _t196;
    _v12 = _t210;
    _v16 = _t216;
     *__esp = camlList__for_all_1137( *134669888, _t216);
    caml_c_call(1);
    __esp =  &(__esp[1]);
    _t197 = unix_fork;
    if(unix_fork == 1) {
        _t105 = _v8;
        if(_t105 != 1) {
            _v8 = _t105;
            caml_c_call(_t105);
            __esp =  &(__esp[1]);
            caml_c_call(_v8);
        }
        _t106 = _v12;
        if(_t106 != 3) {
            _v12 = _t106;
            caml_c_call(_t106);
            __esp =  &(__esp[1]);
            caml_c_call(_v12);
        }
        if( *__esp == 1) {
            camlList__iter_1074( &camlUnix__188, _v16);
        }
        L0804D250();
        __esp =  &(__esp[6]);
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134679816))))))();
        caml_c_call( *__esp);
        __esp =  &(__esp[1]);
        return caml_sys_exit;
    } else {
        _t122 =  *134669920;
        _t179 = _v4;
        __esp =  &(__esp[6]);
        while(1) {
            __esp = __esp - 4;
            _t214 = _t122;
            _t123 =  *(_t214 + 4);
            _t218 =  *(_t123 - 4) >> 10;
            if(_t218 == 0) {
                caml_raise_exn( &caml_bucket_Division_by_zero);
            } else {
                 *__esp = _t197;
                caml_hash_univ_param(21, 201, _t179);
                asm("cdq");
                _t210 = (_t123 >> 1) % _t218;
            }
            _t210 = (_t210 << 1) + 1;
            while(1) {
                _t126 = caml_young_ptr - 16;
                caml_young_ptr = _t126;
                if(_t126 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t127 = _t126 + 4;
             *(_t127 - 4) = 3072;
             *_t127 = _t179;
             *(_t127 + 4) =  *__esp;
            _t199 =  *(_t214 + 4);
            _t182 =  *((unsigned int*)(_t199 - 4)) >> 9;
            if(_t182 <= _t210) {
L33:
                caml_ml_array_bound_error();
                __esp = __esp - 8;
                _t215 = _t127;
                _t200 = _t182;
                while(1) {
                    _t129 = caml_young_ptr - 20;
                    caml_young_ptr = _t129;
                    if(_t129 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t183 = _t129 + 4;
                 *(_t183 - 4) = 4343;
                 *_t183 = camlHashtbl__remove_bucket_1083;
                 *(_t183 + 4) = 3;
                 *(_t183 + 8) = _t215;
                 *(_t183 + 12) = _t200;
                _t130 =  *(_t215 + 4);
                _t220 =  *(_t130 - 4) >> 10;
                if(_t220 == 0) {
                    caml_raise_exn( &caml_bucket_Division_by_zero);
                } else {
                    caml_hash_univ_param(21, 201, _t200);
                    asm("cdq");
                    _t210 = (_t130 >> 1) % _t220;
                }
                _t213 = (_t210 << 1) + 1;
                _v8 = _t213;
                _t132 =  *(_t215 + 4);
                 *__esp = _t132;
                _t134 =  *((unsigned int*)(_t132 - 4)) >> 9;
                if(_t134 <= _t213) {
L44:
                    caml_ml_array_bound_error();
                    __esp = __esp - 12;
                    while(_t183 != 1) {
                         *__esp = _t134;
                        _v20 =  *(_t183 + 8);
                        _v16 =  *(_t183 + 4);
                        caml_c_call( *_t183);
                        if(caml_compare != 1) {
                            _t134 =  *__esp;
                            _t183 = _v20;
                            continue;
                        }
                        __esp =  &(__esp[3]);
                        return _v16;
                        goto L53;
                    }
                    while(1) {
                        _t136 = caml_young_ptr - 8;
                        caml_young_ptr = _t136;
                        if(_t136 >= caml_young_limit) {
                            _t137 = _t136 + 4;
                             *((intOrPtr*)(_t137 - 4)) = 1024;
                             *_t137 =  &caml_exn_Not_found;
                            caml_raise_exn(_t137);
                        }
                        caml_call_gc();
                    }
                } else {
                    _t203 =  *(_t215 + 4);
                    _t134 =  *((unsigned int*)(_t203 - 4)) >> 9;
                    if(_t134 <= _t213) {
                        caml_ml_array_bound_error();
                        goto L44;
                    } else {
                        _t141 =  *((intOrPtr*)(_t203 + _t213 * 2 - 2));
                        camlHashtbl__remove_bucket_1083(_t141, _t183);
                        caml_modify(_v12, _t215, _t220, _v12 + _v8 * 2 - 2, _t141);
                        __esp =  &(__esp[2]);
                        return 1;
                    }
                }
            } else {
                 *((intOrPtr*)(_t127 + 8)) =  *((intOrPtr*)(_t199 + _t210 * 2 - 2));
                _t205 =  *(_t214 + 4);
                _t182 =  *( *(_t214 + 4) - 4) >> 9;
                if(_t182 <= _t210) {
                    caml_ml_array_bound_error();
                    goto L33;
                } else {
                    caml_modify(_t182, _t214, _t218, _t205 + _t210 * 2 - 2, _t127);
                     *_t214 =  *_t214 + 2;
                    if( *_t214 <= ( *( *(_t214 + 4) - 4) >> 9 | 1) + ( *( *(_t214 + 4) - 4) >> 9 | 1) - 1) {
                        __esp =  &(__esp[1]);
                        return 1;
                    } else {
                        _t154 =  *134690256;
                        _t189 = _t214;
                        __esp =  &(__esp[1]);
                        __esp = __esp - 24;
                         *__esp = _t154;
                        _v8 = _t189;
                        _t155 =  *((intOrPtr*)(_t189 + 4));
                        _v4 = _t155;
                        _t158 =  *(_t155 - 4) >> 9 | 1;
                        _v16 = _t158;
                        _t160 = 3 + (_t158 >> 1) * 4;
                        camlPervasives__min_1022(_t160);
                        _t191 = _v16;
                        if(_t160 == _t191) {
                            __esp =  &(__esp[6]);
                            return 1;
                        } else {
                            _v20 = _t160;
                            _v16 = _t191;
                            caml_c_call(_t160);
                            __esp =  &(__esp[1]);
                            _v12 = caml_make_vect;
                            while(1) {
                                _t164 = caml_young_ptr - 24;
                                caml_young_ptr = _t164;
                                if(_t164 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            _t206 = _t164 + 4;
                             *(_t206 - 4) = 5367;
                             *_t206 = camlHashtbl__insert_bucket_1068;
                             *(_t206 + 4) = 3;
                             *(_t206 + 8) =  *__esp;
                             *(_t206 + 12) = _v20;
                             *((intOrPtr*)(_t206 + 16)) = caml_make_vect;
                            _t122 = 1;
                            _t194 = _v16 + -2;
                            if(1 > _t194) {
L17:
                                caml_modify(_t194, _t214, _t218, _v8 + 4, _v12);
                                __esp =  &(__esp[6]);
                                return 1;
                            } else {
                                _v16 = _t194;
                                _v20 = 1;
                                 *__esp = _t206;
                                while(1) {
                                    _t179 = _v4;
                                    _t197 =  *(_t179 - 4) >> 9;
                                    if(_t197 <= _t122) {
                                        break;
                                    }
                                    camlHashtbl__insert_bucket_1068( *((intOrPtr*)(_t179 + _t122 * 2 - 2)));
                                    _t172 = _v20;
                                    _t122 = _t172 + 2;
                                    _v20 = _t122;
                                    _t194 = _v16;
                                    if(_t172 != _v16) {
                                        continue;
                                    } else {
                                        goto L17;
                                    }
                                    goto L53;
                                }
                                caml_ml_array_bound_error();
                                continue;
                            }
                        }
                    }
                }
            }
            goto L53;
        }
    }
L53:
}

L0804D250(
    intOrPtr _a8                           // _cfa_8
)
{
    intOrPtr _t7;                          // _t7

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    while(1) {
        _t7 = caml_young_ptr - 16;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ebx = _t7 + 4;
     *((intOrPtr*)(__ebx - 4)) = 3072;
     *__ebx = "/bin/sh";
    __ebx[1] =  &camlUnix__187;
    __ebx[2] = _a8;
    caml_c_call(__ebx);
    _pop(caml_exception_pointer);
    __esp = __esp + 24;
    return unix_execv;
}

camlUnix__open_process_in_1957(
    signed int __eax                       // r0
)
{// addr = 0x0804D2C0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _t19;                         // _t19
    intOrPtr* _t28;                        // _t28

    _v12 = __eax;
    caml_c_call(1);
    __esp = __esp + 4;
    _v8 =  *((intOrPtr*)(0x805956c));
     *__esp = unix_pipe;
    caml_c_call( *unix_pipe);
    _v4 = caml_ml_open_descriptor_in;
    while(1) {
        _t19 = caml_young_ptr - 20;
        caml_young_ptr = _t19;
        if(_t19 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __esi = _t19 + 4;
     *((intOrPtr*)(__esi - 4)) = 2048;
     *__esi =  *__esp;
    __esi[1] = 1;
    _t28 = __esi + 12;
     *((intOrPtr*)(_t28 - 4)) = 1025;
     *_t28 = caml_ml_open_descriptor_in;
    camlUnix__open_proc_1949(_v12);
    caml_c_call(_v8);
    return _v4;
}

camlUnix__open_process_out_1962(
    signed int __eax                       // r0
)
{// addr = 0x0804D360
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _t19;                         // _t19
    intOrPtr _t27;                         // _t27
    intOrPtr* _t28;                        // _t28

    _v12 = __eax;
    caml_c_call(1);
    __esp = __esp + 4;
    _t27 =  *((intOrPtr*)(0x805956c));
     *__esp = _t27;
    _v8 =  *unix_pipe;
    caml_c_call(_t27);
    _v4 = caml_ml_open_descriptor_out;
    while(1) {
        _t19 = caml_young_ptr - 20;
        caml_young_ptr = _t19;
        if(_t19 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __esi = _t19 + 4;
     *((intOrPtr*)(__esi - 4)) = 2048;
     *__esi =  *__esp;
    __esi[1] = 1;
    _t28 = __esi + 12;
     *((intOrPtr*)(_t28 - 4)) = 1026;
     *_t28 = caml_ml_open_descriptor_out;
    camlUnix__open_proc_1949(_v12);
    caml_c_call(_v8);
    return _v4;
}

camlUnix__open_process_1967(
    signed int __eax                       // r0
)
{// addr = 0x0804D400
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t41;                         // _t41
    intOrPtr _t53;                         // _t53
    intOrPtr* _t55;                        // _t55
    intOrPtr* _t58;                        // _t58
    intOrPtr* _t59;                        // _t59
    intOrPtr* _t64;                        // _t64

    _v20 = __eax;
    caml_c_call(1);
    __esp = __esp + 4;
    _v12 =  *((intOrPtr*)(0x805956c));
    _v24 =  *unix_pipe;
    caml_c_call(1);
     *__esp =  *((intOrPtr*)(0x805956c));
    _v16 =  *unix_pipe;
    caml_c_call(_v24);
    _v8 = caml_ml_open_descriptor_in;
    caml_c_call( *__esp);
    _v4 = caml_ml_open_descriptor_out;
    while(1) {
        _t41 = caml_young_ptr - 36;
        caml_young_ptr = _t41;
        if(_t41 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t64 = _t41 + 4;
     *((intOrPtr*)(_t64 - 4)) = 2048;
     *_t64 =  *__esp;
     *((intOrPtr*)(_t64 + 4)) = 1;
    _t58 = _t64 + 12;
     *__esp = _t58;
     *((intOrPtr*)(_t58 - 4)) = 2048;
     *_t58 = _v24;
    _t58[1] = _t64;
    _t59 = _t64 + 24;
     *((intOrPtr*)(_t59 - 4)) = 2048;
     *_t59 = _v8;
    _t59[1] = caml_ml_open_descriptor_out;
    camlUnix__open_proc_1949(_v20);
    caml_c_call(_v16);
    caml_c_call(_v12);
    while(1) {
        _t53 = caml_young_ptr - 12;
        caml_young_ptr = _t53;
        if(_t53 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t55 = _t53 + 4;
     *((intOrPtr*)(_t55 - 4)) = 2048;
     *_t55 = _v8;
    _t55[1] = _v4;
    return _t55;
}

signed int camlUnix__open_proc_full_1975(
    signed int __eax                       // r0
)
{// addr = 0x0804D540
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _t128;                      // _t128
    signed int _t129;                      // _t129
    intOrPtr _t132;                        // _t132
    signed int _t133;                      // _t133
    intOrPtr _t135;                        // _t135
    signed int _t136;                      // _t136
    unsigned int _t138;                    // _t138
    unsigned int _t140;                    // _t140
    intOrPtr _t142;                        // _t142
    intOrPtr* _t143;                       // _t143
    intOrPtr _t147;                        // _t147
    unsigned int _t160;                    // _t160
    intOrPtr _t161;                        // _t161
    signed int _t164;                      // _t164
    signed int _t166;                      // _t166
    intOrPtr _t170;                        // _t170
    signed int _t178;                      // _t178
    signed int _t181;                      // _t181
    intOrPtr _t185;                        // _t185
    unsigned int _t188;                    // _t188
    signed int _t189;                      // _t189
    signed int _t195;                      // _t195
    signed int _t197;                      // _t197
    intOrPtr _t202;                        // _t202
    unsigned int _t203;                    // _t203
    signed int _t205;                      // _t205
    unsigned int _t206;                    // _t206
    signed int _t209;                      // _t209
    unsigned int _t212;                    // _t212
    signed int _t216;                      // _t216
    signed int _t219;                      // _t219
    intOrPtr _t220;                        // _t220
    signed int _t221;                      // _t221
    signed int _t222;                      // _t222
    intOrPtr _t223;                        // _t223
    signed int _t225;                      // _t225
    signed int _t227;                      // _t227

    __esp = __esp - 32;
    _v16 = __eax;
    _v12 = _t181;
    _v4 = _t202;
     *__esp = _t216;
    _v28 = _t223;
    _v24 = _t220;
    _v8 = caml_extra_params;
    _v20 = camlList__for_all_1137( *134669888, caml_extra_params);
    caml_c_call(1);
    __esp =  &(__esp[1]);
    _t203 = unix_fork;
    if(unix_fork == 1) {
        caml_c_call(_v32);
        __esp =  &(__esp[1]);
        caml_c_call( *__esp);
        _push(3);
        caml_c_call(_v28);
        __esp =  &(__esp[1]);
        caml_c_call(_v28);
        _push(5);
        caml_c_call(_v24);
        __esp =  &(__esp[1]);
        caml_c_call(_v24);
        if(_v20 == 1) {
            camlList__iter_1074( &camlUnix__184, _v8);
        }
        L0804D640();
        __esp =  &(__esp[8]);
        __esp = __esp - 4;
         *__esp = 255;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134679816))))))();
        caml_c_call( *__esp);
        __esp =  &(__esp[1]);
        return caml_sys_exit;
    } else {
        _t128 =  *134669920;
        _t185 = _v4;
        __esp =  &(__esp[8]);
        while(1) {
            __esp = __esp - 4;
            _t221 = _t128;
            _t129 =  *(_t221 + 4);
            _t225 =  *(_t129 - 4) >> 10;
            if(_t225 == 0) {
                caml_raise_exn( &caml_bucket_Division_by_zero);
            } else {
                 *__esp = _t203;
                caml_hash_univ_param(21, 201, _t185);
                asm("cdq");
                _t216 = (_t129 >> 1) % _t225;
            }
            _t216 = (_t216 << 1) + 1;
            while(1) {
                _t132 = caml_young_ptr - 16;
                caml_young_ptr = _t132;
                if(_t132 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t133 = _t132 + 4;
             *(_t133 - 4) = 3072;
             *_t133 = _t185;
             *(_t133 + 4) =  *__esp;
            _t205 =  *(_t221 + 4);
            _t188 =  *((unsigned int*)(_t205 - 4)) >> 9;
            if(_t188 <= _t216) {
L29:
                caml_ml_array_bound_error();
                __esp = __esp - 8;
                _t222 = _t133;
                _t206 = _t188;
                while(1) {
                    _t135 = caml_young_ptr - 20;
                    caml_young_ptr = _t135;
                    if(_t135 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t189 = _t135 + 4;
                 *(_t189 - 4) = 4343;
                 *_t189 = camlHashtbl__remove_bucket_1083;
                 *(_t189 + 4) = 3;
                 *(_t189 + 8) = _t222;
                 *(_t189 + 12) = _t206;
                _t136 =  *(_t222 + 4);
                _t227 =  *(_t136 - 4) >> 10;
                if(_t227 == 0) {
                    caml_raise_exn( &caml_bucket_Division_by_zero);
                } else {
                    caml_hash_univ_param(21, 201, _t206);
                    asm("cdq");
                    _t216 = (_t136 >> 1) % _t227;
                }
                _t219 = (_t216 << 1) + 1;
                _v8 = _t219;
                _t138 =  *(_t222 + 4);
                 *__esp = _t138;
                _t140 =  *((unsigned int*)(_t138 - 4)) >> 9;
                if(_t140 <= _t219) {
L40:
                    caml_ml_array_bound_error();
                    __esp = __esp - 12;
                    while(_t189 != 1) {
                         *__esp = _t140;
                        _v20 =  *(_t189 + 8);
                        _v16 =  *(_t189 + 4);
                        caml_c_call( *_t189);
                        if(caml_compare != 1) {
                            _t140 =  *__esp;
                            _t189 = _v20;
                            continue;
                        }
                        __esp =  &(__esp[3]);
                        return _v16;
                        goto L49;
                    }
                    while(1) {
                        _t142 = caml_young_ptr - 8;
                        caml_young_ptr = _t142;
                        if(_t142 >= caml_young_limit) {
                            _t143 = _t142 + 4;
                             *((intOrPtr*)(_t143 - 4)) = 1024;
                             *_t143 =  &caml_exn_Not_found;
                            caml_raise_exn(_t143);
                        }
                        caml_call_gc();
                    }
                } else {
                    _t209 =  *(_t222 + 4);
                    _t140 =  *((unsigned int*)(_t209 - 4)) >> 9;
                    if(_t140 <= _t219) {
                        caml_ml_array_bound_error();
                        goto L40;
                    } else {
                        _t147 =  *((intOrPtr*)(_t209 + _t219 * 2 - 2));
                        camlHashtbl__remove_bucket_1083(_t147, _t189);
                        caml_modify(_v12, _t222, _t227, _v12 + _v8 * 2 - 2, _t147);
                        __esp =  &(__esp[2]);
                        return 1;
                    }
                }
            } else {
                 *((intOrPtr*)(_t133 + 8)) =  *((intOrPtr*)(_t205 + _t216 * 2 - 2));
                _t211 =  *(_t221 + 4);
                _t188 =  *( *(_t221 + 4) - 4) >> 9;
                if(_t188 <= _t216) {
                    caml_ml_array_bound_error();
                    goto L29;
                } else {
                    caml_modify(_t188, _t221, _t225, _t211 + _t216 * 2 - 2, _t133);
                     *_t221 =  *_t221 + 2;
                    if( *_t221 <= ( *( *(_t221 + 4) - 4) >> 9 | 1) + ( *( *(_t221 + 4) - 4) >> 9 | 1) - 1) {
                        __esp =  &(__esp[1]);
                        return 1;
                    } else {
                        _t160 =  *134690256;
                        _t195 = _t221;
                        __esp =  &(__esp[1]);
                        __esp = __esp - 24;
                         *__esp = _t160;
                        _v8 = _t195;
                        _t161 =  *((intOrPtr*)(_t195 + 4));
                        _v4 = _t161;
                        _t164 =  *(_t161 - 4) >> 9 | 1;
                        _v16 = _t164;
                        _t166 = 3 + (_t164 >> 1) * 4;
                        camlPervasives__min_1022(_t166);
                        _t197 = _v16;
                        if(_t166 == _t197) {
                            __esp =  &(__esp[6]);
                            return 1;
                        } else {
                            _v20 = _t166;
                            _v16 = _t197;
                            caml_c_call(_t166);
                            __esp =  &(__esp[1]);
                            _v12 = caml_make_vect;
                            while(1) {
                                _t170 = caml_young_ptr - 24;
                                caml_young_ptr = _t170;
                                if(_t170 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            _t212 = _t170 + 4;
                             *(_t212 - 4) = 5367;
                             *_t212 = camlHashtbl__insert_bucket_1068;
                             *(_t212 + 4) = 3;
                             *(_t212 + 8) =  *__esp;
                             *(_t212 + 12) = _v20;
                             *((intOrPtr*)(_t212 + 16)) = caml_make_vect;
                            _t128 = 1;
                            _t200 = _v16 + -2;
                            if(1 > _t200) {
L13:
                                caml_modify(_t200, _t221, _t225, _v8 + 4, _v12);
                                __esp =  &(__esp[6]);
                                return 1;
                            } else {
                                _v16 = _t200;
                                _v20 = 1;
                                 *__esp = _t212;
                                while(1) {
                                    _t185 = _v4;
                                    _t203 =  *(_t185 - 4) >> 9;
                                    if(_t203 <= _t128) {
                                        break;
                                    }
                                    camlHashtbl__insert_bucket_1068( *((intOrPtr*)(_t185 + _t128 * 2 - 2)));
                                    _t178 = _v20;
                                    _t128 = _t178 + 2;
                                    _v20 = _t128;
                                    _t200 = _v16;
                                    if(_t178 != _v16) {
                                        continue;
                                    } else {
                                        goto L13;
                                    }
                                    goto L49;
                                }
                                caml_ml_array_bound_error();
                                continue;
                            }
                        }
                    }
                }
            }
            goto L49;
        }
    }
L49:
}

L0804D640(
    intOrPtr _a20,                         // _cfa_14
    intOrPtr _a24                          // _cfa_18
)
{
    intOrPtr _t8;                          // _t8

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    while(1) {
        _t8 = caml_young_ptr - 16;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ebx = _t8 + 4;
     *((intOrPtr*)(__ebx - 4)) = 3072;
     *__ebx = "/bin/sh";
    __ebx[1] =  &camlUnix__183;
    __ebx[2] = _a20;
    _push(_a24);
    caml_c_call(__ebx);
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 32;
    return unix_execve;
}

camlUnix__open_process_full_1985(
    signed int __eax,                      // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804D6B0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _t62;                         // _t62
    intOrPtr _t78;                         // _t78
    intOrPtr* _t80;                        // _t80
    intOrPtr* _t90;                        // _t90
    intOrPtr* _t91;                        // _t91
    intOrPtr* _t92;                        // _t92
    intOrPtr* _t94;                        // _t94

    _v32 = __eax;
    _v28 = __ebx;
    caml_c_call(1);
    __esp = __esp + 4;
    _v20 =  *((intOrPtr*)(0x805956c));
    _v36 =  *unix_pipe;
    caml_c_call(1);
    _v40 =  *((intOrPtr*)(0x805956c));
    _v24 =  *unix_pipe;
    caml_c_call(1);
    _v16 =  *((intOrPtr*)(0x805956c));
     *__esp =  *unix_pipe;
    caml_c_call(_v36);
    _v12 = caml_ml_open_descriptor_in;
    caml_c_call(_v40);
    _v8 = caml_ml_open_descriptor_out;
    caml_c_call( *__esp);
    _v4 = caml_ml_open_descriptor_in;
    while(1) {
        _t62 = caml_young_ptr - 52;
        caml_young_ptr = _t62;
        if(_t62 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t94 = _t62 + 4;
     *((intOrPtr*)(_t94 - 4)) = 2048;
     *_t94 =  *__esp;
     *((intOrPtr*)(_t94 + 4)) = 1;
    _t92 = _t94 + 12;
     *((intOrPtr*)(_t92 - 4)) = 2048;
     *_t92 = _v40;
     *((intOrPtr*)(_t92 + 4)) = _t94;
    _t90 = _t94 + 24;
     *__esp = _t90;
     *((intOrPtr*)(_t90 - 4)) = 2048;
     *_t90 = _v36;
    _t90[1] = _t92;
    _t91 = _t94 + 36;
     *((intOrPtr*)(_t91 - 4)) = 3075;
     *_t91 = _v12;
    _t91[1] = _v8;
    _t91[2] = caml_ml_open_descriptor_in;
    caml_extra_params =  *__esp;
    camlUnix__open_proc_full_1975(_v32);
    caml_c_call(_v24);
    caml_c_call(_v20);
    caml_c_call(_v16);
    while(1) {
        _t78 = caml_young_ptr - 16;
        caml_young_ptr = _t78;
        if(_t78 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t80 = _t78 + 4;
     *((intOrPtr*)(_t80 - 4)) = 3072;
     *_t80 = _v12;
    _t80[1] = _v8;
    _t80[2] = _v4;
    return _t80;
}

camlUnix__find_proc_id_1997(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804D870
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _t19;                         // _t19
    intOrPtr* _t21;                        // _t21

    _t11 = __eax;
    _v8 = __eax;
    _v4 = __ebx;
    L4();
    _t23 =  *__eax;
    if( *__eax ==  &caml_exn_Not_found) {
        while(1) {
            _t19 = caml_young_ptr - 20;
            caml_young_ptr = _t19;
            if(_t19 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t21 = _t19 + 4;
         *((intOrPtr*)(_t21 - 4)) = 4096;
         *_t21 = camlUnix;
        _t21[1] = 7;
        _t23 = _v8;
        _t21[2] = _v8;
        _t21[3] =  &camlUnix__180;
        _t11 = caml_raise_exn(_t21);
    }
    caml_raise_exn(_t11);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _v8 = camlHashtbl__find_1093( *134669920, _t23);
    camlHashtbl__remove_1080( *134669920, _v0);
    _pop(caml_exception_pointer);
    return  *__esp;
}

L0804D8E0(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a12                          // _cfa_c
)
{
    intOrPtr _t7;                          // _t7
    _unknown_ _t8;                         // _t8

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _a4 = camlHashtbl__find_1093( *134669920, _t8);
    camlHashtbl__remove_1080( *134669920, _a12);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _t7 =  *__esp;
    __esp = __esp + 12;
    return _t7;
}

camlUnix__waitpid_non_intr_2001(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804D930
    intOrPtr* _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    signed int _t7;                        // _t7

    _t3 = __eax;
    while(1) {
         *__esp = _t3;
        L6();
        if( *_t3 != camlUnix) {
            break;
        }
        _t7 =  *(_t3 + 4);
        if((_t7 & 1) != 0 && _t7 == 23) {
            _t3 =  *__esp;
            continue;
        }
        break;
    }
    _t4 = caml_raise_exn(_t3);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_t4);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return unix_waitpid;
}

L0804D970(
    _unknown_ __eax                        // r0
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(__eax);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return unix_waitpid;
}

camlUnix__close_process_in_2003(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804D9A0
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _t7;                          // _t7

     *__esp = __eax;
    while(1) {
        _t7 = caml_young_ptr - 8;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ebx = _t7 + 4;
     *((intOrPtr*)(__ebx - 4)) = 1025;
     *__ebx = __eax;
    _v4 = camlUnix__find_proc_id_1997("close_process_in", __ebx);
    caml_c_call( *__esp);
    return  *((intOrPtr*)(camlUnix__waitpid_non_intr_2001(_v4) + 4));
}

camlUnix__close_process_out_2006(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804DA10
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _t7;                          // _t7

     *__esp = __eax;
    while(1) {
        _t7 = caml_young_ptr - 8;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ebx = _t7 + 4;
     *((intOrPtr*)(__ebx - 4)) = 1026;
     *__ebx = __eax;
    _v4 = camlUnix__find_proc_id_1997("close_process_out", __ebx);
    camlPervasives__close_out_1209( *__esp);
    return  *((intOrPtr*)(camlUnix__waitpid_non_intr_2001(_v4) + 4));
}

camlUnix__close_process_2009(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804DA70
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _t10;                         // _t10
    intOrPtr* _t24;                        // _t24

    _v4 = __ebx;
     *__esp = __eax;
    while(1) {
        _t10 = caml_young_ptr - 12;
        caml_young_ptr = _t10;
        if(_t10 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t24 = _t10 + 4;
     *((intOrPtr*)(_t24 - 4)) = 2048;
     *_t24 = __eax;
     *((intOrPtr*)(_t24 + 4)) = __ebx;
    _v8 = camlUnix__find_proc_id_1997("close_process", _t24);
    caml_c_call( *__esp);
    L4();
    if( *caml_ml_close_channel !=  &caml_exn_Sys_error) {
        caml_raise_exn(caml_ml_close_channel);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        camlPervasives__close_out_1209(_v0);
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
    }
    return  *((intOrPtr*)(camlUnix__waitpid_non_intr_2001(_v8) + 4));
}

L0804DAE0(
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{
    _unknown_ _t6;                         // _t6

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlPervasives__close_out_1209(_a12);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _t6 = camlUnix__waitpid_non_intr_2001(_a8);
    __esp = __esp + 12;
    return  *((intOrPtr*)(_t6 + 4));
}

camlUnix__close_process_full_2013(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x0804DB20
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t13;                         // _t13
    intOrPtr* _t29;                        // _t29

    _v12 = __ecx;
    _v4 = __ebx;
     *__esp = __eax;
    while(1) {
        _t13 = caml_young_ptr - 16;
        caml_young_ptr = _t13;
        if(_t13 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t29 = _t13 + 4;
     *((intOrPtr*)(_t29 - 4)) = 3075;
     *_t29 = __eax;
     *((intOrPtr*)(_t29 + 4)) = __ebx;
     *((intOrPtr*)(_t29 + 8)) = __ecx;
    _v8 = camlUnix__find_proc_id_1997("close_process_full", _t29);
    caml_c_call( *__esp);
    L4();
    if( *caml_ml_close_channel !=  &caml_exn_Sys_error) {
        caml_raise_exn(caml_ml_close_channel);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        camlPervasives__close_out_1209(_v0);
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
    }
    caml_c_call(_v12);
    return  *((intOrPtr*)(camlUnix__waitpid_non_intr_2001(_v8) + 4));
}

L0804DBA0(
    intOrPtr _a8,                          // _cfa_8
    intOrPtr* _a12,                        // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{
    _unknown_ _t9;                         // _t9

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    camlPervasives__close_out_1209(_a16);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    caml_c_call(_a8);
    _t9 = camlUnix__waitpid_non_intr_2001(_a12);
    __esp = __esp + 16;
    return  *((intOrPtr*)(_t9 + 4));
}

camlUnix__open_connection_2018(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804DBF0
    intOrPtr* _v0;                         // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    _unknown_ _t13;                        // _t13
    _unknown_ _t18;                        // _t18
    intOrPtr _t27;                         // _t27
    intOrPtr* _t29;                        // _t29

     *__esp = __eax;
    _t13 = camlUnix__domain_of_sockaddr_1529(__eax);
    _push(1);
    caml_c_call(_t13);
    __esp = __esp + 8;
    _v4 = unix_socket;
    L1();
     *__esp = unix_socket;
    caml_c_call(_v4);
    _t18 = caml_raise_exn( *__esp);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_v4);
    camlUnix__try_set_close_on_exec_1366(_v0);
    caml_c_call(_v0);
    _v4 = caml_ml_open_descriptor_out;
    caml_c_call(_v0);
    while(1) {
        _t27 = caml_young_ptr - 12;
        caml_young_ptr = _t27;
        if(_t27 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t29 = _t27 + 4;
     *((intOrPtr*)(_t29 - 4)) = 2048;
     *_t29 = caml_ml_open_descriptor_in;
    _t29[1] = _v4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return _t29;
}

L0804DC40(
    _unknown_ __eax,                       // r0
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8                          // _cfa_8
)
{
    intOrPtr _t19;                         // _t19
    intOrPtr* _t21;                        // _t21

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_a4);
    camlUnix__try_set_close_on_exec_1366(_a8);
    caml_c_call(_a8);
    _a4 = caml_ml_open_descriptor_out;
    caml_c_call(_a8);
    while(1) {
        _t19 = caml_young_ptr - 12;
        caml_young_ptr = _t19;
        if(_t19 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t21 = _t19 + 4;
     *((intOrPtr*)(_t21 - 4)) = 2048;
     *_t21 = caml_ml_open_descriptor_in;
    _t21[1] = _a4;
    _pop(caml_exception_pointer);
    __esp = __esp + 8;
    return _t21;
}

camlUnix__shutdown_connection_2022(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804DCD0
    caml_c_call(__eax);
    caml_c_call(3);
    return unix_shutdown;
}

camlUnix__accept_non_intr_2024(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804DCF0
    intOrPtr* _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    signed int _t7;                        // _t7

    _t3 = __eax;
    while(1) {
         *__esp = _t3;
        L6();
        if( *_t3 != camlUnix) {
            break;
        }
        _t7 =  *(_t3 + 4);
        if((_t7 & 1) != 0 && _t7 == 23) {
            _t3 =  *__esp;
            continue;
        }
        break;
    }
    _t4 = caml_raise_exn(_t3);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_t4);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return unix_accept;
}

L0804DD30(
    _unknown_ __eax                        // r0
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(__eax);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return unix_accept;
}

camlUnix__establish_server_2026()
{// addr = 0x0804DD60
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _t13;                         // _t13
    _unknown_ _t15;                        // _t15
    intOrPtr* _t43;                        // _t43

    _v8 = _t13;
     *__esp = _t43;
    _t15 = camlUnix__domain_of_sockaddr_1529(_t43);
    _push(1);
    caml_c_call(_t15);
    __esp = __esp + 8;
    _v12 = unix_socket;
    camlUnix__setsockopt_1646(unix_socket);
    _push( *__esp);
    caml_c_call(_v12);
    __esp = __esp + 4;
    _push(11);
    caml_c_call(_v12);
    __esp = __esp + 4;
    while(1) {
L1:
        _v4 =  *((intOrPtr*)(camlUnix__accept_non_intr_2024(_v12)));
        caml_c_call(1);
        __esp = __esp + 4;
         *__esp = unix_fork;
        if(unix_fork == 1) {
            break;
        }
        caml_c_call(_v4);
        camlUnix__waitpid_non_intr_2001( *__esp);
    }
    caml_c_call(1);
    __esp = __esp + 4;
    if(unix_fork != 1) {
        camlPervasives__exit_1326();
    }
    caml_c_call(_v12);
    camlUnix__try_set_close_on_exec_1366(_v4);
    caml_c_call(_v4);
     *__esp = caml_ml_open_descriptor_in;
    caml_c_call(_v4);
    caml_apply2();
    camlPervasives__exit_1326();
    goto L1;
}

camlUnix__entry()
{// addr = 0x0804DEA0
    intOrPtr* _t25;                        // _t25
    intOrPtr* _t36;                        // _t36
    intOrPtr* _t43;                        // _t43
    intOrPtr _t45;                         // _t45
    intOrPtr* _t53;                        // _t53
    intOrPtr* _t92;                        // _t92

     *134669884 =  &camlUnix__175;
     *134669880 =  &camlUnix__174;
     *134669876 =  &camlUnix__173;
     *134669872 =  &camlUnix__172;
     *134669868 =  &camlUnix__171;
     *134669864 =  &camlUnix__170;
     *134669860 =  &camlUnix__169;
     *134669848 =  &camlUnix__168;
     *134669844 =  &camlUnix__167;
     *134669840 =  &camlUnix__166;
     *134669836 =  &camlUnix__165;
     *134669832 =  &camlUnix__164;
     *134669828 =  &camlUnix__163;
     *134669824 =  &camlUnix__162;
     *134669756 =  &camlUnix__161;
     *134669752 =  &camlUnix__160;
     *134669748 =  &camlUnix__159;
     *134669744 =  &camlUnix__158;
     *134669740 =  &camlUnix__157;
     *134669736 =  &camlUnix__156;
     *134669732 =  &camlUnix__155;
     *134669728 =  &camlUnix__154;
     *134669720 =  &camlUnix__153;
     *134669700 =  &camlUnix__152;
     *134669696 =  &camlUnix__151;
     *134669692 =  &camlUnix__150;
     *134669688 =  &camlUnix__149;
     *134669684 =  &camlUnix__148;
     *134669680 =  &camlUnix__147;
     *134669676 =  &camlUnix__146;
     *134669672 =  &camlUnix__145;
     *134669668 =  &camlUnix__144;
     *134669664 =  &camlUnix__143;
     *134669660 =  &camlUnix__142;
     *134669656 =  &camlUnix__141;
     *134669652 =  &camlUnix__140;
     *134669648 =  &camlUnix__139;
     *134669644 =  &camlUnix__138;
     *134669640 =  &camlUnix__137;
     *134669636 =  &camlUnix__136;
     *134669632 =  &camlUnix__135;
     *134669628 =  &camlUnix__134;
     *134669624 =  &camlUnix__133;
     *134669620 =  &camlUnix__132;
     *134669616 =  &camlUnix__131;
     *134669612 =  &camlUnix__130;
     *134669608 =  &camlUnix__129;
     *134669604 =  &camlUnix__128;
     *134669600 =  &camlUnix__127;
     *134669596 =  &camlUnix__126;
     *134669588 =  &camlUnix__125;
     *134669584 =  &camlUnix__124;
     *134669580 =  &camlUnix__123;
     *134669576 =  &camlUnix__122;
     *134669572 =  &camlUnix__121;
     *134669568 =  &camlUnix__120;
     *134669564 =  &camlUnix__119;
     *134669560 =  &camlUnix__118;
     *134669516 =  &camlUnix__117;
     *134669512 =  &camlUnix__116;
     *134669508 =  &camlUnix__115;
     *134669504 =  &camlUnix__114;
     *134669500 =  &camlUnix__113;
     *134669496 =  &camlUnix__112;
     *134669492 =  &camlUnix__111;
     *134669488 =  &camlUnix__110;
     *134669484 =  &camlUnix__109;
     *134669480 =  &camlUnix__108;
     *134669476 =  &camlUnix__107;
     *134669472 =  &camlUnix__106;
     *134669468 =  &camlUnix__105;
     *134669464 =  &camlUnix__104;
     *134669460 =  &camlUnix__103;
     *134669456 =  &camlUnix__102;
     *134669452 =  &camlUnix__101;
     *134669448 =  &camlUnix__100;
     *134669444 =  &camlUnix__99;
     *134669440 =  &camlUnix__98;
     *134669436 =  &camlUnix__97;
     *134669432 =  &camlUnix__96;
     *134669428 =  &camlUnix__95;
     *134669424 =  &camlUnix__94;
     *134669420 =  &camlUnix__93;
     *134669416 =  &camlUnix__92;
     *134669408 =  &camlUnix__91;
     *134669404 =  &camlUnix__90;
     *134669400 =  &camlUnix__89;
     *134669396 =  &camlUnix__88;
     *134669392 =  &camlUnix__87;
     *134669388 =  &camlUnix__86;
     *134669384 =  &camlUnix__85;
     *134669380 =  &camlUnix__84;
     *134669376 =  &camlUnix__83;
     *134669372 =  &camlUnix__82;
     *134669368 =  &camlUnix__81;
     *134669352 =  &camlUnix__80;
     *134669348 =  &camlUnix__79;
     *134669332 =  &camlUnix__78;
     *134669328 =  &camlUnix__77;
     *134669324 =  &camlUnix__76;
     *134669316 =  &camlUnix__75;
     *134669312 =  &camlUnix__74;
     *134669308 =  &camlUnix__73;
     *134669304 =  &camlUnix__72;
     *134669300 =  &camlUnix__71;
     *134669296 =  &camlUnix__70;
     *134669292 =  &camlUnix__69;
     *134669288 =  &camlUnix__68;
     *134669284 =  &camlUnix__67;
     *134669280 =  &camlUnix__66;
     *134669272 =  &camlUnix__65;
    _t25 = caml_allocN(28) + 4;
     *((intOrPtr*)(_t25 - 4)) = 1024;
     *_t25 = "Unix.Unix_error";
    camlUnix = _t25;
    _t92 = _t25 + 8;
     *((intOrPtr*)(_t92 - 4)) = 4096;
     *_t92 = camlUnix;
    _t92[1] = 1;
    _t92[2] =  &camlUnix__62;
    _t92[3] =  &camlUnix__63;
    camlCallback__register_exception_1034("Unix.Unix_error");
     *134669276 =  &camlUnix__60;
     *134669336 = 1;
     *134669340 = 3;
     *134669344 = 5;
     *134669356 =  &camlUnix__59;
     *134669360 =  &camlUnix__58;
     *134669364 =  &camlUnix__57;
    _t36 = caml_allocN(28) + 4;
     *((intOrPtr*)(_t36 - 4)) = 6144;
     *_t36 =  &camlUnix__50;
     *((intOrPtr*)(_t36 + 4)) =  &camlUnix__51;
     *((intOrPtr*)(_t36 + 8)) =  &camlUnix__52;
     *((intOrPtr*)(_t36 + 12)) =  &camlUnix__53;
     *((intOrPtr*)(_t36 + 16)) =  &camlUnix__54;
     *((intOrPtr*)(_t36 + 20)) =  &camlUnix__55;
     *134669412 = _t36;
     *134669888 =  &camlUnix__49;
     *134669592 =  &camlUnix__48;
     *134669892 =  &camlUnix__47;
    caml_c_call("0.0.0.0");
     *134669704 = unix_inet_addr_of_string;
    caml_c_call("127.0.0.1");
     *134669708 = unix_inet_addr_of_string;
    L3();
    if( *unix_inet_addr_of_string !=  &caml_exn_Failure) {
        caml_raise_exn(unix_inet_addr_of_string);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _push( &camlUnix__44);
        _t43 = unix_inet_addr_of_string;
        caml_c_call();
        __esp = __esp + 4;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
    } else {
        _t43 =  *134669704;
    }
     *134669712 = _t43;
    L7();
    if( *_t43 !=  &caml_exn_Failure) {
        caml_raise_exn(_t43);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _push( &camlUnix__43);
        _t45 = unix_inet_addr_of_string;
        caml_c_call();
        __esp = __esp + 4;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
    } else {
        _t45 =  *134669708;
    }
     *134669716 = _t45;
     *134669724 =  &camlUnix__42;
     *134669760 =  &camlUnix__41;
     *134669764 =  &camlUnix__40;
     *134669768 =  &camlUnix__39;
     *134669772 =  &camlUnix__38;
    _t53 = caml_allocN(32) + 4;
     *((intOrPtr*)(_t53 - 4)) = 7168;
     *_t53 = 1;
     *((intOrPtr*)(_t53 + 4)) = 3;
     *((intOrPtr*)(_t53 + 8)) = 5;
     *((intOrPtr*)(_t53 + 12)) = 7;
     *((intOrPtr*)(_t53 + 16)) = 9;
     *((intOrPtr*)(_t53 + 20)) =  &camlUnix__36;
     *((intOrPtr*)(_t53 + 24)) =  &camlUnix__37;
     *134669896 = _t53;
     *134669776 =  &camlUnix__35;
     *134669780 =  &camlUnix__34;
     *134669784 =  &camlUnix__33;
     *134669788 =  &camlUnix__32;
     *134669792 =  &camlUnix__31;
     *134669796 =  &camlUnix__30;
     *134669800 =  &camlUnix__29;
     *134669804 =  &camlUnix__28;
     *134669808 =  &camlUnix__27;
     *134669900 =  &camlUnix__26;
     *134669852 =  &camlUnix__25;
     *134669904 =  &camlUnix__24;
     *134669856 =  &camlUnix__23;
     *134669320 =  &camlUnix__22;
     *134669908 =  &camlUnix__21;
     *134669912 =  &camlUnix__20;
     *134669916 =  &camlUnix__19;
     *134669520 =  &camlUnix__18;
     *134669524 =  &camlUnix__17;
     *134669920 = camlHashtbl__create_1051(15);
     *134669924 =  &camlUnix__16;
     *134669528 =  &camlUnix__15;
     *134669532 =  &camlUnix__14;
     *134669536 =  &camlUnix__13;
     *134669928 =  &camlUnix__12;
     *134669540 =  &camlUnix__11;
     *134669932 =  &camlUnix__10;
     *134669936 =  &camlUnix__9;
     *134669544 =  &camlUnix__8;
     *134669548 =  &camlUnix__7;
     *134669552 =  &camlUnix__6;
     *134669556 =  &camlUnix__5;
     *134669812 =  &camlUnix__4;
     *134669816 =  &camlUnix__3;
     *134669940 =  &camlUnix__2;
     *134669820 =  &camlUnix__1;
    return 1;
}

L0804E43A()
{
    intOrPtr _t11;                         // _t11
    intOrPtr* _t19;                        // _t19

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call( &camlUnix__44);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
     *134669712 = unix_inet_addr_of_string;
    L4();
    if( *unix_inet_addr_of_string !=  &caml_exn_Failure) {
        caml_raise_exn(unix_inet_addr_of_string);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _push( &camlUnix__43);
        _t11 = unix_inet_addr_of_string;
        caml_c_call();
        __esp = __esp + 4;
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
    } else {
        _t11 =  *134669708;
    }
     *134669716 = _t11;
     *134669724 =  &camlUnix__42;
     *134669760 =  &camlUnix__41;
     *134669764 =  &camlUnix__40;
     *134669768 =  &camlUnix__39;
     *134669772 =  &camlUnix__38;
    _t19 = caml_allocN(32) + 4;
     *((intOrPtr*)(_t19 - 4)) = 7168;
     *_t19 = 1;
     *((intOrPtr*)(_t19 + 4)) = 3;
     *((intOrPtr*)(_t19 + 8)) = 5;
     *((intOrPtr*)(_t19 + 12)) = 7;
     *((intOrPtr*)(_t19 + 16)) = 9;
     *((intOrPtr*)(_t19 + 20)) =  &camlUnix__36;
     *((intOrPtr*)(_t19 + 24)) =  &camlUnix__37;
     *134669896 = _t19;
     *134669776 =  &camlUnix__35;
     *134669780 =  &camlUnix__34;
     *134669784 =  &camlUnix__33;
     *134669788 =  &camlUnix__32;
     *134669792 =  &camlUnix__31;
     *134669796 =  &camlUnix__30;
     *134669800 =  &camlUnix__29;
     *134669804 =  &camlUnix__28;
     *134669808 =  &camlUnix__27;
     *134669900 =  &camlUnix__26;
     *134669852 =  &camlUnix__25;
     *134669904 =  &camlUnix__24;
     *134669856 =  &camlUnix__23;
     *134669320 =  &camlUnix__22;
     *134669908 =  &camlUnix__21;
     *134669912 =  &camlUnix__20;
     *134669916 =  &camlUnix__19;
     *134669520 =  &camlUnix__18;
     *134669524 =  &camlUnix__17;
     *134669920 = camlHashtbl__create_1051(15);
     *134669924 =  &camlUnix__16;
     *134669528 =  &camlUnix__15;
     *134669532 =  &camlUnix__14;
     *134669536 =  &camlUnix__13;
     *134669928 =  &camlUnix__12;
     *134669540 =  &camlUnix__11;
     *134669932 =  &camlUnix__10;
     *134669936 =  &camlUnix__9;
     *134669544 =  &camlUnix__8;
     *134669548 =  &camlUnix__7;
     *134669552 =  &camlUnix__6;
     *134669556 =  &camlUnix__5;
     *134669812 =  &camlUnix__4;
     *134669816 =  &camlUnix__3;
     *134669940 =  &camlUnix__2;
     *134669820 =  &camlUnix__1;
    return 1;
}

L0804E482()
{
    intOrPtr* _t17;                        // _t17

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call( &camlUnix__43);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
     *134669716 = unix_inet_addr_of_string;
     *134669724 =  &camlUnix__42;
     *134669760 =  &camlUnix__41;
     *134669764 =  &camlUnix__40;
     *134669768 =  &camlUnix__39;
     *134669772 =  &camlUnix__38;
    _t17 = caml_allocN(32) + 4;
     *((intOrPtr*)(_t17 - 4)) = 7168;
     *_t17 = 1;
     *((intOrPtr*)(_t17 + 4)) = 3;
     *((intOrPtr*)(_t17 + 8)) = 5;
     *((intOrPtr*)(_t17 + 12)) = 7;
     *((intOrPtr*)(_t17 + 16)) = 9;
     *((intOrPtr*)(_t17 + 20)) =  &camlUnix__36;
     *((intOrPtr*)(_t17 + 24)) =  &camlUnix__37;
     *134669896 = _t17;
     *134669776 =  &camlUnix__35;
     *134669780 =  &camlUnix__34;
     *134669784 =  &camlUnix__33;
     *134669788 =  &camlUnix__32;
     *134669792 =  &camlUnix__31;
     *134669796 =  &camlUnix__30;
     *134669800 =  &camlUnix__29;
     *134669804 =  &camlUnix__28;
     *134669808 =  &camlUnix__27;
     *134669900 =  &camlUnix__26;
     *134669852 =  &camlUnix__25;
     *134669904 =  &camlUnix__24;
     *134669856 =  &camlUnix__23;
     *134669320 =  &camlUnix__22;
     *134669908 =  &camlUnix__21;
     *134669912 =  &camlUnix__20;
     *134669916 =  &camlUnix__19;
     *134669520 =  &camlUnix__18;
     *134669524 =  &camlUnix__17;
     *134669920 = camlHashtbl__create_1051(15);
     *134669924 =  &camlUnix__16;
     *134669528 =  &camlUnix__15;
     *134669532 =  &camlUnix__14;
     *134669536 =  &camlUnix__13;
     *134669928 =  &camlUnix__12;
     *134669540 =  &camlUnix__11;
     *134669932 =  &camlUnix__10;
     *134669936 =  &camlUnix__9;
     *134669544 =  &camlUnix__8;
     *134669548 =  &camlUnix__7;
     *134669552 =  &camlUnix__6;
     *134669556 =  &camlUnix__5;
     *134669812 =  &camlUnix__4;
     *134669816 =  &camlUnix__3;
     *134669940 =  &camlUnix__2;
     *134669820 =  &camlUnix__1;
    return 1;
}

camlPervasives__iter_1186(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804EE10
    intOrPtr* _t2;                         // _t2

    _t2 = __eax;
    while(_t2 != 1) {
         *__esp = _t2[1];
        L0804EE30( *_t2);
        _t2 =  *__esp;
    }
    return 1;
}

L0804EE30(
    _unknown_ __eax                        // r0
)
{
    intOrPtr* _t3;                         // _t3

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _push(__eax);
    _t3 = caml_ml_flush;
    caml_c_call();
    __esp = __esp + 4;
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    while(1) {
        _t3 =  *__esp;
        if(_t3 != 1) {
             *__esp = _t3[1];
            L0804EE30( *_t3);
            continue;
        }
        __esp = __esp + 4;
        return 1;
    }
}

camlPervasives__build_result_1243(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x0804EE70
    while(__ecx != 1) {
        caml_blit_string( *__ecx, 1, __eax, __ebx - ( *( *__ecx - 4) >> 10) * 4 - 1 - ( *(_t10 + ( *( *__ecx - 4) >> 10) * 4 - 1) & 255) + ( *( *__ecx - 4) >> 10) * 4 - 1 - ( *(_t10 + ( *( *__ecx - 4) >> 10) * 4 - 1) & 255) + 1 + 1, ( *( *__ecx - 4) >> 10) * 4 - 1 - ( *(_t10 + ( *( *__ecx - 4) >> 10) * 4 - 1) & 255) + ( *( *__ecx - 4) >> 10) * 4 - 1 - ( *(_t10 + ( *( *__ecx - 4) >> 10) * 4 - 1) & 255) + 1);
    }
    return __eax;
}

signed int camlPervasives__scan_1249(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x0804EEC0
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _t47;                        // _t47
    intOrPtr _t49;                         // _t49
    _unknown_ _t51;                        // _t51
    intOrPtr* _t53;                        // _t53
    signed int _t56;                       // _t56

    _t53 = __ecx;
    _t51 = __ebx;
    _t47 = __eax;
    __esp = __esp - 20;
    while(1) {
        _v4 = __eax;
        _v8 = __ebx;
        _v16 = __ecx;
        _push( *((intOrPtr*)(__ecx + 12)));
        __eax = caml_ml_input_scan_line;
        caml_c_call();
        __esp =  &(__esp[1]);
        if(caml_ml_input_scan_line != 1) {
            goto L9;
        }
        __eax = _v4;
        if(__eax == 1) {
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 8;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __eax = __eax + 4;
             *(__eax - 4) = 1024;
             *__eax =  &caml_exn_End_of_file;
            __eax = caml_raise_exn(__eax);
            goto L9;
        } else {
            _v4 = __eax;
            __eax = _v8;
            _push(_v8);
            __eax = caml_create_string;
            caml_c_call();
            __esp =  &(__esp[1]);
            __ebx = _v8;
            __ecx = _v4;
            __esp =  &(__esp[5]);
            while(1) {
L1:
                __edi = _t47;
                if(_t53 == 1) {
                    break;
                }
                _t49 =  *_t53;
                _t56 = ( *(_t49 - 4) >> 10) * 4 - 1;
                __edx =  *(_t49 + _t56) & 255;
                __esi = _t56 - ( *(_t49 + _t56) & 255) + _t56 - ( *(_t49 + _t56) & 255) + 1;
                caml_blit_string(_t49, 1, __edi, _t51 - __esi + 1, __esi);
                _t51 = _t51 - __esi + 1;
                _t47 = __edi;
                _t53 = _t53[1];
            }
            return __edi;
        }
L21:
L9:
        _v12 = __eax;
        if(__eax <= 1) {
            2 = 2 - __eax;
            _push(2 - __eax);
            __eax = caml_create_string;
            caml_c_call();
            __esp =  &(__esp[1]);
             *__esp = caml_create_string;
            __ecx = 2;
            __ebx = _v12;
            __ecx = 2 - _v12;
            _push(2 - _v12);
            _push(1);
            _push(caml_create_string);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input;
            caml_c_call();
            __esp =  &(__esp[4]);
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 12;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __eax = __eax + 4;
             *(__eax - 4) = 2048;
            __ebx =  *__esp;
             *__eax =  *__esp;
            __ebx = _v4;
             *(__eax + 4) = _v4;
            __ebx = _v8;
            __ecx = _v12;
            __ebx = _v8 - _v12;
            __ebx = _v8 - _v12 + 1;
            __ecx = _v16;
            continue;
        } else {
            _push(__eax);
            __eax = caml_create_string;
            caml_c_call();
            __esp =  &(__esp[1]);
             *__esp = caml_create_string;
            _v12 = _v12 + -2;
            _push(_v12 + -2);
            _push(1);
            _push(caml_create_string);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input;
            caml_c_call();
            __esp =  &(__esp[4]);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input_char;
            caml_c_call();
            __esp =  &(__esp[1]);
            __ecx = _v4;
            if(__ecx == 1) {
                __eax =  *__esp;
                __esp =  &(__esp[5]);
                return __eax;
            } else {
                __ebx = _v12;
                __eax = _v8;
                __edx = _v8 + _v12 - 3;
                _v16 = __edx;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 12;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    __eax = caml_call_gc();
                }
                __ebx = __eax + 4;
                _v12 = __ebx;
                 *(__ebx - 4) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *(__ebx + 4) = __ecx;
                _push(__edx);
                __eax = caml_create_string;
                caml_c_call();
                __esp =  &(__esp[1]);
                __ebx = _v16;
                __ecx = _v12;
                __esp =  &(__esp[5]);
                goto L1;
            }
        }
        goto L21;
    }
}

camlPervasives__fun_1500()
{// addr = 0x0804F0C0
    intOrPtr _t6;                          // _t6

     *__esp = _t6;
     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t6 + 8))))))();
    __esp = __esp + 4;
    goto __ecx;
}

camlPervasives__fun_1392(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F0F0
    caml_c_call(__ebx);
    return caml_ml_set_binary_mode;
}

camlPervasives__fun_1394(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F100
    caml_c_call(__eax);
    return caml_ml_close_channel;
}

camlPervasives__fun_1396(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F110
    caml_c_call(__eax);
    return caml_ml_channel_size;
}

camlPervasives__fun_1398(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F120
    caml_c_call(__eax);
    return caml_ml_pos_in;
}

camlPervasives__fun_1400(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F130
    caml_c_call(__ebx);
    return caml_ml_seek_in;
}

camlPervasives__fun_1402(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F140
    caml_c_call(__eax);
    return caml_input_value;
}

camlPervasives__fun_1404(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F150
    caml_c_call(__eax);
    return caml_ml_input_int;
}

camlPervasives__fun_1406(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F160
    caml_c_call(__eax);
    return caml_ml_input_char;
}

camlPervasives__fun_1408(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F170
    caml_c_call(__eax);
    return caml_ml_input_char;
}

camlPervasives__fun_1410(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F180
    caml_c_call(__ebx);
    return caml_ml_set_binary_mode;
}

camlPervasives__fun_1412(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F190
    caml_c_call(__eax);
    return caml_ml_channel_size;
}

camlPervasives__fun_1414(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F1A0
    caml_c_call(__eax);
    return caml_ml_pos_out;
}

camlPervasives__fun_1416(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F1B0
    caml_c_call(__ebx);
    return caml_ml_seek_out;
}

camlPervasives__fun_1418(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F1C0
    caml_c_call(__ebx);
    return caml_ml_output_int;
}

camlPervasives__fun_1420(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F1D0
    caml_c_call(__ebx);
    return caml_ml_output_char;
}

camlPervasives__fun_1422(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F1E0
    caml_c_call(__ebx);
    return caml_ml_output_char;
}

camlPervasives__fun_1424(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F1F0
    caml_c_call(__eax);
    return caml_ml_flush;
}

camlPervasives__failwith_1010()
{// addr = 0x0804F200
    intOrPtr _t4;                          // _t4
    intOrPtr _t6;                          // _t6
    intOrPtr* _t8;                         // _t8

    __ebx = _t4;
L1:
    _t6 = caml_young_ptr - 12;
    caml_young_ptr = _t6;
    if(_t6 >= caml_young_limit) {
        _t8 = _t6 + 4;
         *((intOrPtr*)(_t8 - 4)) = 2048;
         *_t8 =  &caml_exn_Failure;
        _t8[1] = __ebx;
        caml_raise_exn(_t8);
    }
    caml_call_gc();
    goto L1;
}

camlPervasives__invalid_arg_1012()
{// addr = 0x0804F240
    intOrPtr _t4;                          // _t4
    intOrPtr _t6;                          // _t6
    intOrPtr* _t8;                         // _t8

    __ebx = _t4;
L1:
    _t6 = caml_young_ptr - 12;
    caml_young_ptr = _t6;
    if(_t6 >= caml_young_limit) {
        _t8 = _t6 + 4;
         *((intOrPtr*)(_t8 - 4)) = 2048;
         *_t8 =  &caml_exn_Invalid_argument;
        _t8[1] = __ebx;
        caml_raise_exn(_t8);
    }
    caml_call_gc();
    goto L1;
}

camlPervasives__min_1022(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804F280
    intOrPtr _v4;                          // _cfa_fffffffc

    _v4 = __eax;
     *__esp = __ebx;
    caml_c_call(__ebx);
    if(caml_lessequal == 1) {
        return  *__esp;
    } else {
        return _v4;
    }
}

camlPervasives__max_1025(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804F2C0
    intOrPtr _v4;                          // _cfa_fffffffc

    _v4 = __eax;
     *__esp = __ebx;
    caml_c_call(__ebx);
    if(caml_greaterequal == 1) {
        return  *__esp;
    } else {
        return _v4;
    }
}

camlPervasives__abs_1044(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F300
    if(__eax < 1) {
        return 2 - __eax;
    } else {
        return __eax;
    }
}

signed int camlPervasives__lnot_1049(
    signed int __eax                       // r0
)
{// addr = 0x0804F320
    return __eax ^ -1 | 1;
}

camlPervasives__$5e_1112(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x0804F330
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4

    _v12 = __eax;
    _v4 = __ebx;
     *__esp = ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + 1;
    _v8 = ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + 1;
    caml_c_call(( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + 1 + ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + 1 - 1);
    __esi =  *__esp;
    caml_blit_string(_v12, 1, caml_create_string, 1,  *__esp);
    caml_blit_string(_v4, 1, caml_create_string, __esi, _v8);
    return caml_create_string;
}

camlPervasives__char_of_int_1120(
    char* __eax                            // r0
)
{// addr = 0x0804F3C0
    intOrPtr _t6;                          // _t6
    intOrPtr* _t8;                         // _t8

    _t4 = __eax;
    if(__eax < 1 || __eax > 511) {
        _t4 = "char_of_int";
    } else {
        return __eax;
    }
    __ebx = _t4;
L2:
    _t6 = caml_young_ptr - 12;
    caml_young_ptr = _t6;
    if(_t6 >= caml_young_limit) {
        _t8 = _t6 + 4;
         *((intOrPtr*)(_t8 - 4)) = 2048;
         *_t8 =  &caml_exn_Invalid_argument;
        _t8[1] = __ebx;
        caml_raise_exn(_t8);
    }
    caml_call_gc();
    goto L2;
}

camlPervasives__string_of_bool_1127(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F3E0
    if(__eax == 1) {
        return  &camlPervasives__100;
    } else {
        return  &camlPervasives__101;
    }
}

camlPervasives__bool_of_string_1129(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F400
    intOrPtr _t5;                          // _t5
    intOrPtr _t8;                          // _t8
    intOrPtr* _t10;                        // _t10
    intOrPtr _t13;                         // _t13

    _t5 = caml_string_notequal(__eax,  &camlPervasives__99);
    if(_t5 == 1) {
        return 1;
    } else {
        if(caml_string_notequal(__ebx,  &camlPervasives__98) != 1) {
            __eax = "bool_of_string";
            _t13 = _t5;
L2:
            _t8 = caml_young_ptr - 12;
            caml_young_ptr = _t8;
            if(_t8 >= caml_young_limit) {
                _t10 = _t8 + 4;
                 *((intOrPtr*)(_t10 - 4)) = 2048;
                 *_t10 =  &caml_exn_Invalid_argument;
                _t10[1] = _t13;
                caml_raise_exn(_t10);
            }
            caml_call_gc();
            goto L2;
        }
        __eax = 3;
        return 3;
    }
}

camlPervasives__string_of_int_1130(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F460
    caml_c_call(__eax);
    return caml_format_int;
}

camlPervasives__valid_float_lexem_1135(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F480
    char* _v4;                             // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _t47;                       // _t47
    signed int _t48;                       // _t48
    intOrPtr* _t49;                        // _t49
    intOrPtr _t54;                         // _t54
    signed int _t66;                       // _t66
    signed int _t75;                       // _t75
    _unknown_ _t77;                        // _t77
    intOrPtr _t87;                         // _t87
    intOrPtr _t88;                         // _t88

    _t47 = ( *(__eax - 4) >> 10) * 4 - 1;
    _t66 =  *(__eax + _t47) & 255;
    _t48 = _t47 - _t66;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __ebx = __eax + 4;
     *((intOrPtr*)(__ebx - 4)) = 4343;
     *__ebx =  &camlPervasives__code_begin;
    __ebx[1] = 3;
    __ebx[2] = __ecx;
    __ebx[3] = __edx;
    __eax = 1;
    while(_t48 <  *((intOrPtr*)(_t66 + 12))) {
        _t87 =  *((intOrPtr*)(_t66 + 8));
        _t75 = _t48 >> 1;
        if(( *(_t87 - 4) >> 10) * 4 - 1 - ( *(_t87 + ( *(_t87 - 4) >> 10) * 4 - 1) & 255) <= _t75) {
            _t49 = caml_ml_array_bound_error();
            __esp = __esp - 4;
            while(_t49 != 1) {
                 *__esp = _t49[1];
                L0804EE30( *_t49);
                _t49 =  *__esp;
            }
            __esp = __esp + 4;
            return 1;
        } else {
            _t77 = ( *(_t87 + _t75) & 255) + ( *(_t87 + _t75) & 255) + 1;
            if(_t77 < 97) {
                if(_t77 == 91) {
                    goto L9;
                } else {
                    goto L8;
                }
            } else {
                if(_t77 < 117) {
L9:
                    _t48 = _t48 + 2;
                    continue;
                } else {
L8:
                    return  *((intOrPtr*)(_t66 + 8));
                }
            }
        }
L20:
    }
    _t54 =  *((intOrPtr*)(_t66 + 8));
    __esp = __esp - 16;
    _t88 = _t54;
    _v12 = _t88;
    _v4 =  &camlPervasives__103;
     *__esp = ( *(_t88 - 4) >> 10) * 4 - 1 - ( *(_t88 + ( *(_t88 - 4) >> 10) * 4 - 1) & 255) + ( *(_t88 - 4) >> 10) * 4 - 1 - ( *(_t88 + ( *(_t88 - 4) >> 10) * 4 - 1) & 255) + 1;
    _v8 = ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__103 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1) & 255) + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__103 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1) & 255) + 1;
    caml_c_call(( *(_t88 - 4) >> 10) * 4 - 1 - ( *(_t88 + ( *(_t88 - 4) >> 10) * 4 - 1) & 255) + ( *(_t88 - 4) >> 10) * 4 - 1 - ( *(_t88 + ( *(_t88 - 4) >> 10) * 4 - 1) & 255) + 1 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__103 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1) & 255) + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__103 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1) & 255) + 1 - 1);
    _t93 =  *__esp;
    caml_blit_string(_v12, 1, caml_create_string, 1,  *__esp);
    caml_blit_string(_v4, 1, caml_create_string, _t93, _v8);
    __esp = __esp + 16;
    return caml_create_string;
    goto L20;
}

signed int camlPervasives__string_of_float_1140(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F4E0
    char* _v4;                             // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t51;                         // _t51
    signed int _t53;                       // _t53
    intOrPtr* _t54;                        // _t54
    intOrPtr _t59;                         // _t59
    intOrPtr* _t72;                        // _t72
    signed int _t81;                       // _t81
    _unknown_ _t83;                        // _t83
    intOrPtr _t92;                         // _t92
    intOrPtr _t93;                         // _t93
    intOrPtr _t94;                         // _t94

    caml_c_call(__eax);
    _t92 = ( *(caml_format_float - 4) >> 10) * 4 - 1 - ( *(caml_format_float + ( *(caml_format_float - 4) >> 10) * 4 - 1) & 255) + ( *(caml_format_float - 4) >> 10) * 4 - 1 - ( *(caml_format_float + ( *(caml_format_float - 4) >> 10) * 4 - 1) & 255) + 1;
    while(1) {
        _t51 = caml_young_ptr - 20;
        caml_young_ptr = _t51;
        if(_t51 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t72 = _t51 + 4;
     *((intOrPtr*)(_t72 - 4)) = 4343;
     *_t72 =  &camlPervasives__code_begin;
    _t72[1] = 3;
    _t72[2] = caml_format_float;
    _t72[3] = _t92;
    _t53 = 1;
    while(_t53 < _t72[3]) {
        _t93 = _t72[2];
        _t81 = _t53 >> 1;
        if(( *(_t93 - 4) >> 10) * 4 - 1 - ( *(_t93 + ( *(_t93 - 4) >> 10) * 4 - 1) & 255) <= _t81) {
            _t54 = caml_ml_array_bound_error();
            __esp = __esp - 4;
            while(_t54 != 1) {
                 *__esp = _t54[1];
                L0804EE30( *_t54);
                _t54 =  *__esp;
            }
            __esp = __esp + 4;
            return 1;
        } else {
            _t83 = ( *(_t93 + _t81) & 255) + ( *(_t93 + _t81) & 255) + 1;
            if(_t83 < 97) {
                if(_t83 == 91) {
                    goto L9;
                } else {
                    goto L8;
                }
            } else {
                if(_t83 < 117) {
L9:
                    _t53 = _t53 + 2;
                    continue;
                } else {
L8:
                    return _t72[2];
                }
            }
        }
L21:
    }
    _t59 = _t72[2];
    __esp = __esp - 16;
    _t94 = _t59;
    _v12 = _t94;
    _v4 =  &camlPervasives__103;
     *__esp = ( *(_t94 - 4) >> 10) * 4 - 1 - ( *(_t94 + ( *(_t94 - 4) >> 10) * 4 - 1) & 255) + ( *(_t94 - 4) >> 10) * 4 - 1 - ( *(_t94 + ( *(_t94 - 4) >> 10) * 4 - 1) & 255) + 1;
    _v8 = ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__103 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1) & 255) + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__103 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1) & 255) + 1;
    caml_c_call(( *(_t94 - 4) >> 10) * 4 - 1 - ( *(_t94 + ( *(_t94 - 4) >> 10) * 4 - 1) & 255) + ( *(_t94 - 4) >> 10) * 4 - 1 - ( *(_t94 + ( *(_t94 - 4) >> 10) * 4 - 1) & 255) + 1 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__103 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1) & 255) + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__103 + ( *( &camlPervasives__103 - 4) >> 10) * 4 - 1) & 255) + 1 - 1);
    _t99 =  *__esp;
    caml_blit_string(_v12, 1, caml_create_string, 1,  *__esp);
    caml_blit_string(_v4, 1, caml_create_string, _t99, _v8);
    __esp = __esp + 16;
    return caml_create_string;
    goto L21;
}

camlPervasives__$40_1143(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0804F500
    intOrPtr _t10;                         // _t10
    intOrPtr* _t12;                        // _t12
    _unknown_ _t13;                        // _t13
    intOrPtr _t16;                         // _t16

    if(__eax == 1) {
        return _t13;
    } else {
         *__esp =  *__eax;
        _t16 = camlPervasives__$40_1143( *((intOrPtr*)(__eax + 4)));
        while(1) {
            _t10 = caml_young_ptr - 12;
            caml_young_ptr = _t10;
            if(_t10 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t12 = _t10 + 4;
         *((intOrPtr*)(_t12 - 4)) = 2048;
         *_t12 =  *__esp;
        _t12[1] = _t16;
        return _t12;
    }
}

camlPervasives__open_out_gen_1175(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x0804F560
    __ecx = __ecx;
    __ebx = __ebx;
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 4;
    caml_c_call(caml_sys_open);
    return caml_ml_open_descriptor_out;
}

camlPervasives__open_out_1179(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F580
    _push( &camlPervasives__94);
    caml_c_call(__eax);
    __esp = __esp + 8;
    caml_c_call(caml_sys_open);
    return caml_ml_open_descriptor_out;
}

camlPervasives__open_out_bin_1181(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F5A0
    _push( &camlPervasives__93);
    caml_c_call(__eax);
    __esp = __esp + 8;
    caml_c_call(caml_sys_open);
    return caml_ml_open_descriptor_out;
}

camlPervasives__flush_all_1185()
{// addr = 0x0804F5C0
    intOrPtr* _t3;                         // _t3

    _t3 = caml_ml_out_channels_list;
    caml_c_call(1);
    __esp = __esp + 4;
    __esp = __esp - 4;
    while(_t3 != 1) {
         *__esp = _t3[1];
        L0804EE30( *_t3);
        _t3 =  *__esp;
    }
    __esp = __esp + 4;
    return 1;
}

camlPervasives__output_string_1191(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x0804F5E0
    __ebx = __ebx;
    _push(( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + 1);
    _push(1);
    caml_c_call(__ebx);
    __esp = __esp + 8;
    return caml_ml_output;
}

camlPervasives__output_1194(
    char* __eax                            // r0
)
{// addr = 0x0804F610
    char* _t8;                             // _t8
    intOrPtr _t10;                         // _t10
    intOrPtr* _t12;                        // _t12

    _t8 = __eax;
    if(__ecx < 1 || __edx < 1) {
L8:
        _t8 = "output";
    } else {
        __esi =  *(__ebx - 4);
        __esi =  *(__ebx - 4) >> 10;
        __esi = ( *(__ebx - 4) >> 10) * 4 - 1;
        __esi = ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + __esi) & 255);
        __esi = __esi << 1;
        __esi = __esi - __edx;
        if(__ecx > __esi) {
            goto L8;
        }
        _push(__edx);
        _push(__ecx);
        _push(__ebx);
        _push(caml_ml_output);
        __eax = caml_ml_output;
        caml_c_call();
        __esp = __esp + 16;
        return caml_ml_output;
    }
    __ebx = _t8;
L2:
    _t10 = caml_young_ptr - 12;
    caml_young_ptr = _t10;
    if(_t10 >= caml_young_limit) {
        _t12 = _t10 + 4;
         *((intOrPtr*)(_t12 - 4)) = 2048;
         *_t12 =  &caml_exn_Invalid_argument;
        _t12[1] = __ebx;
        caml_raise_exn(_t12);
    }
    caml_call_gc();
    goto L2;
}

camlPervasives__output_value_1202(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F660
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 8;
    return caml_output_value;
}

camlPervasives__close_out_1209(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804F680
     *__esp = __eax;
    caml_c_call(__eax);
    caml_c_call( *__esp);
    return caml_ml_close_channel;
}

camlPervasives__close_out_noerr_1211(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804F6B0
     *__esp = __eax;
    L0804F6C0(__eax);
    L0804F700();
    return 1;
}

L0804F6C0(
    _unknown_ __eax                        // r0
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(__eax);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    L0804F700();
    __esp = __esp + 4;
    return 1;
}

L0804F700(
    intOrPtr _a4                           // _cfa_4
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(_a4);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return caml_ml_close_channel;
}

camlPervasives__open_in_gen_1214(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x0804F730
    __ecx = __ecx;
    __ebx = __ebx;
    _push(__ebx);
    caml_c_call(__eax);
    __esp = __esp + 4;
    caml_c_call(caml_sys_open);
    return caml_ml_open_descriptor_in;
}

camlPervasives__open_in_1218(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F750
    _push( &camlPervasives__90);
    caml_c_call(__eax);
    __esp = __esp + 8;
    caml_c_call(caml_sys_open);
    return caml_ml_open_descriptor_in;
}

camlPervasives__open_in_bin_1220(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F770
    _push( &camlPervasives__89);
    caml_c_call(__eax);
    __esp = __esp + 8;
    caml_c_call(caml_sys_open);
    return caml_ml_open_descriptor_in;
}

camlPervasives__input_1224(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F790
    intOrPtr _t10;                         // _t10
    intOrPtr* _t12;                        // _t12

    if(__ecx < 1 || __edx < 1 || __ecx > (( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) << 1) - __edx + 2) {
        __ebx =  &camlPervasives__88;
L2:
        _t10 = caml_young_ptr - 12;
        caml_young_ptr = _t10;
        if(_t10 >= caml_young_limit) {
            _t12 = _t10 + 4;
             *((intOrPtr*)(_t12 - 4)) = 2048;
             *_t12 =  &caml_exn_Invalid_argument;
            _t12[1] = __ebx;
            caml_raise_exn(_t12);
        }
        caml_call_gc();
        goto L2;
    } else {
        _push(__edx);
        _push(__ecx);
        _push(__ebx);
        _push(caml_ml_input);
        __eax = caml_ml_input;
        caml_c_call();
        __esp = __esp + 16;
        return caml_ml_input;
    }
}

camlPervasives__unsafe_really_input_1229(
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x0804F7E0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t11;                         // _t11
    signed int _t12;                       // _t12
    intOrPtr _t15;                         // _t15
    intOrPtr* _t17;                        // _t17
    intOrPtr _t18;                         // _t18
    intOrPtr _t20;                         // _t20

    _t20 = __edx;
    __ecx = __ecx;
    _t18 = __ebx;
    while(_t20 > 1) {
         *__esp = _t20;
        _v12 = __ecx;
        _v4 = _t18;
        _v8 = _t11;
        _push(_t20);
        _push(__ecx);
        _push(_t18);
        _push(_t11);
        _t12 = caml_ml_input;
        caml_c_call();
        __esp = __esp + 16;
        if(caml_ml_input == 1) {
            while(1) {
                _t15 = caml_young_ptr - 8;
                caml_young_ptr = _t15;
                if(_t15 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t17 = _t15 + 4;
             *((intOrPtr*)(_t17 - 4)) = 1024;
             *_t17 =  &caml_exn_End_of_file;
            _t12 = caml_raise_exn(_t17);
        }
        _t20 =  *__esp - _t12 + 1;
        __ecx = _v12 + _t12 - 1;
        _t11 = _v8;
        _t18 = _v4;
    }
    return 1;
}

camlPervasives__really_input_1235(
    _unknown_ __ebx,                       // r1
    intOrPtr __ecx,                        // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x0804F880
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char* _t18;                            // _t18
    intOrPtr _t20;                         // _t20
    intOrPtr* _t22;                        // _t22
    intOrPtr _t25;                         // _t25

    __edx = __edx;
    __ecx = __ecx;
    if(__ecx < 1 || __edx < 1) {
L16:
        _t18 = "really_input";
    } else {
        __esi =  *(__ebx - 4);
        __esi =  *(__ebx - 4) >> 10;
        __esi = ( *(__ebx - 4) >> 10) * 4 - 1;
        __esi = ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + __esi) & 255);
        __esi = __esi << 1;
        __esi = __esi - __edx;
        if(__ecx > __esi) {
            goto L16;
        }
        __esp = __esp - 16;
        while(__edx > 1) {
             *__esp = __edx;
            _v12 = __ecx;
            _v4 = __ebx;
            _v8 = __eax;
            _push(__edx);
            _push(__ecx);
            _push(__ebx);
            _push(__eax);
            __eax = caml_ml_input;
            caml_c_call();
            __esp = __esp + 16;
            if(caml_ml_input != 1) {
L11:
                 *__esp =  *__esp - __eax;
                __edx =  *__esp - __eax + 1;
                __ebx = _v12;
                __ecx = _v12 + __eax - 1;
                __eax = _v8;
                __ebx = _v4;
                continue;
            } else {
                goto L9;
            }
            while(1) {
L9:
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 8;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 1024;
             *__eax =  &caml_exn_End_of_file;
            __eax = caml_raise_exn(__eax);
            goto L11;
        }
        __eax = 1;
        __esp = __esp + 16;
        return 1;
    }
    _t25 = _t18;
L2:
    _t20 = caml_young_ptr - 12;
    caml_young_ptr = _t20;
    if(_t20 >= caml_young_limit) {
        _t22 = _t20 + 4;
         *((intOrPtr*)(_t22 - 4)) = 2048;
         *_t22 =  &caml_exn_Invalid_argument;
        _t22[1] = _t25;
        caml_raise_exn(_t22);
    }
    caml_call_gc();
    goto L2;
}

camlPervasives__input_line_1241(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F8C0
    _unknown_ _v4;                         // _cfa_fffffffc
    _unknown_ _v8;                         // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    _unknown_ _t53;                        // _t53
    char* _t57;                            // _t57
    intOrPtr* _t59;                        // _t59

    _t53 = __eax;
    _t57 =  &camlPervasives__86;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 24;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __ecx = __eax + 4;
     *((intOrPtr*)(__ecx - 4)) = 5367;
     *__ecx = caml_curry2;
     *((intOrPtr*)(__ecx + 4)) = 5;
     *((intOrPtr*)(__ecx + 8)) = camlPervasives__scan_1249;
     *((intOrPtr*)(__ecx + 12)) = __edx;
     *((intOrPtr*)(__ecx + 16)) = __ebx;
    __ebx = 1;
    __eax = 1;
    __esp = __esp - 20;
    while(1) {
        _v4 = __eax;
        _v8 = __ebx;
        _v16 = __ecx;
        _push( *((intOrPtr*)(__ecx + 12)));
        __eax = caml_ml_input_scan_line;
        caml_c_call();
        __esp = __esp + 4;
        if(caml_ml_input_scan_line != 1) {
            goto L10;
        }
        __eax = _v4;
        if(__eax == 1) {
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 8;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 1024;
             *__eax =  &caml_exn_End_of_file;
            __eax = caml_raise_exn(__eax);
            goto L10;
        } else {
            _v4 = __eax;
            __eax = _v8;
            _push(_v8);
            __eax = caml_create_string;
            caml_c_call();
            __esp = __esp + 4;
            __ebx = _v8;
            __ecx = _v4;
            __esp = __esp + 20;
            while(1) {
L1:
                __edi = _t53;
                if(_t59 == 1) {
                    break;
                }
                __esi = ( *( *_t59 - 4) >> 10) * 4 - 1 - ( *( *_t59 + ( *( *_t59 - 4) >> 10) * 4 - 1) & 255) + ( *( *_t59 - 4) >> 10) * 4 - 1 - ( *( *_t59 + ( *( *_t59 - 4) >> 10) * 4 - 1) & 255) + 1;
                caml_blit_string(_t55, 1, __edi, _t57 - __esi + 1, __esi);
                _t57 = _t57 - __esi + 1;
                _t53 = __edi;
                _t59 = _t59[1];
            }
            return __edi;
        }
L25:
L10:
        _v12 = __eax;
        if(__eax <= 1) {
            2 = 2 - __eax;
            _push(2 - __eax);
            __eax = caml_create_string;
            caml_c_call();
            __esp = __esp + 4;
             *__esp = caml_create_string;
            __ecx = 2;
            __ebx = _v12;
            __ecx = 2 - _v12;
            _push(2 - _v12);
            _push(1);
            _push(caml_create_string);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input;
            caml_c_call();
            __esp = __esp + 16;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 12;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 2048;
            __ebx =  *__esp;
             *__eax =  *__esp;
            __ebx = _v4;
             *((intOrPtr*)(__eax + 4)) = _v4;
            __ebx = _v8;
            __ecx = _v12;
            __ebx = _v8 - _v12;
            __ebx = _v8 - _v12 + 1;
            __ecx = _v16;
            continue;
        } else {
            _push(__eax);
            __eax = caml_create_string;
            caml_c_call();
            __esp = __esp + 4;
             *__esp = caml_create_string;
            _v12 = _v12 + -2;
            _push(_v12 + -2);
            _push(1);
            _push(caml_create_string);
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input;
            caml_c_call();
            __esp = __esp + 16;
            __eax = _v16;
            _push( *((intOrPtr*)(_v16 + 12)));
            __eax = caml_ml_input_char;
            caml_c_call();
            __esp = __esp + 4;
            __ecx = _v4;
            if(__ecx == 1) {
                __eax =  *__esp;
                __esp = __esp + 20;
                return __eax;
            } else {
                __ebx = _v12;
                __eax = _v8;
                __edx = _v8 + _v12 - 3;
                _v16 = __edx;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 12;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    __eax = caml_call_gc();
                }
                __ebx = __eax + 4;
                _v12 = __ebx;
                 *((intOrPtr*)(__ebx - 4)) = 2048;
                __eax =  *__esp;
                 *__ebx =  *__esp;
                 *((intOrPtr*)(__ebx + 4)) = __ecx;
                _push(__edx);
                __eax = caml_create_string;
                caml_c_call();
                __esp = __esp + 4;
                __ebx = _v16;
                __ecx = _v12;
                __esp = __esp + 20;
                goto L1;
            }
        }
        goto L25;
    }
}

camlPervasives__close_in_noerr_1263()
{// addr = 0x0804F920
    _unknown_ _t1;                         // _t1

    L0804F930(_t1);
    return 1;
}

L0804F930(
    _unknown_ __eax                        // r0
)
{
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_c_call(__eax);
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return caml_ml_close_channel;
}

camlPervasives__print_char_1266(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F960
    caml_c_call(__eax);
    return caml_ml_output_char;
}

camlPervasives__print_string_1268(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F980
    intOrPtr _t8;                          // _t8

    _t8 =  *134679580;
    _push(( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + 1);
    _push(1);
    caml_c_call(__eax);
    __esp = __esp + 8;
    return caml_ml_output;
}

camlPervasives__print_int_1270()
{// addr = 0x0804F990
    _unknown_ _t7;                         // _t7
    intOrPtr _t9;                          // _t9

    __ebx = camlPervasives__string_of_int_1130(_t7);
    _t9 =  *134679580;
    _push(( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + 1);
    _push(1);
    caml_c_call(__ebx);
    __esp = __esp + 8;
    return caml_ml_output;
}

camlPervasives__print_float_1272()
{// addr = 0x0804F9B0
    _unknown_ _t7;                         // _t7
    intOrPtr _t9;                          // _t9

    __ebx = camlPervasives__string_of_float_1140(_t7);
    _t9 =  *134679580;
    _push(( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + 1);
    _push(1);
    caml_c_call(__ebx);
    __esp = __esp + 8;
    return caml_ml_output;
}

camlPervasives__print_endline_1274(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804F9D0
    __ebx = __eax;
    camlPervasives__output_string_1191( *134679580, __eax);
    caml_c_call( *134679580);
    __esp = __esp + 4;
    caml_c_call( *134679580);
    return caml_ml_flush;
}

camlPervasives__print_newline_1276()
{// addr = 0x0804FA10
    caml_c_call( *134679580);
    __esp = __esp + 4;
    caml_c_call( *134679580);
    return caml_ml_flush;
}

camlPervasives__prerr_char_1277(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FA40
    caml_c_call(__eax);
    return caml_ml_output_char;
}

camlPervasives__prerr_string_1279(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FA60
    intOrPtr _t8;                          // _t8

    _t8 =  *134679584;
    _push(( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + 1);
    _push(1);
    caml_c_call(__eax);
    __esp = __esp + 8;
    return caml_ml_output;
}

camlPervasives__prerr_int_1281()
{// addr = 0x0804FA70
    _unknown_ _t7;                         // _t7
    intOrPtr _t9;                          // _t9

    __ebx = camlPervasives__string_of_int_1130(_t7);
    _t9 =  *134679584;
    _push(( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + 1);
    _push(1);
    caml_c_call(__ebx);
    __esp = __esp + 8;
    return caml_ml_output;
}

camlPervasives__prerr_float_1283()
{// addr = 0x0804FA90
    _unknown_ _t7;                         // _t7
    intOrPtr _t9;                          // _t9

    __ebx = camlPervasives__string_of_float_1140(_t7);
    _t9 =  *134679584;
    _push(( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + ( *(__ebx - 4) >> 10) * 4 - 1 - ( *(__ebx + ( *(__ebx - 4) >> 10) * 4 - 1) & 255) + 1);
    _push(1);
    caml_c_call(__ebx);
    __esp = __esp + 8;
    return caml_ml_output;
}

camlPervasives__prerr_endline_1285(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FAB0
    __ebx = __eax;
    camlPervasives__output_string_1191( *134679584, __eax);
    caml_c_call( *134679584);
    __esp = __esp + 4;
    caml_c_call( *134679584);
    return caml_ml_flush;
}

camlPervasives__prerr_newline_1287()
{// addr = 0x0804FAF0
    caml_c_call( *134679584);
    __esp = __esp + 4;
    caml_c_call( *134679584);
    return caml_ml_flush;
}

camlPervasives__read_line_1288()
{// addr = 0x0804FB20
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _t54;                         // _t54
    intOrPtr _t56;                         // _t56
    intOrPtr* _t58;                        // _t58
    _unknown_ _t59;                        // _t59
    intOrPtr _t64;                         // _t64
    intOrPtr _t72;                         // _t72
    intOrPtr _t75;                         // _t75
    intOrPtr _t78;                         // _t78
    intOrPtr _t82;                         // _t82
    intOrPtr _t84;                         // _t84
    intOrPtr* _t86;                        // _t86
    intOrPtr* _t89;                        // _t89
    intOrPtr* _t100;                       // _t100
    intOrPtr _t101;                        // _t101
    intOrPtr* _t103;                       // _t103
    intOrPtr _t107;                        // _t107
    intOrPtr* _t108;                       // _t108
    intOrPtr _t116;                        // _t116
    intOrPtr _t117;                        // _t117

    caml_c_call( *134679580);
    _t54 =  *134679576;
    _t116 = _t54;
    while(1) {
        _t56 = caml_young_ptr - 24;
        caml_young_ptr = _t56;
        if(_t56 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t103 = _t56 + 4;
     *((intOrPtr*)(_t103 - 4)) = 5367;
     *_t103 = caml_curry2;
     *((intOrPtr*)(_t103 + 4)) = 5;
     *((intOrPtr*)(_t103 + 8)) = camlPervasives__scan_1249;
     *((intOrPtr*)(_t103 + 12)) = _t116;
     *((intOrPtr*)(_t103 + 16)) =  &camlPervasives__86;
    _t89 = 1;
    _t58 = 1;
    __esp = __esp - 20;
    while(1) {
        _v4 = _t58;
        _v8 = _t89;
        _v16 = _t103;
        _push( *((intOrPtr*)(_t103 + 12)));
        _t59 = caml_ml_input_scan_line;
        caml_c_call();
        __esp = __esp + 4;
        if(caml_ml_input_scan_line != 1) {
            goto L10;
        }
        _t82 = _v4;
        if(_t82 == 1) {
            while(1) {
                _t84 = caml_young_ptr - 8;
                caml_young_ptr = _t84;
                if(_t84 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t86 = _t84 + 4;
             *((intOrPtr*)(_t86 - 4)) = 1024;
             *_t86 =  &caml_exn_End_of_file;
            _t59 = caml_raise_exn(_t86);
            goto L10;
        } else {
            _v4 = _t82;
            _push(_v8);
            _t78 = caml_create_string;
            caml_c_call();
            __esp = __esp + 4;
            _t101 = _v8;
            _t108 = _v4;
            __esp = __esp + 20;
            while(1) {
L1:
                __edi = _t78;
                if(_t108 == 1) {
                    break;
                }
                __esi = ( *( *_t108 - 4) >> 10) * 4 - 1 - ( *( *_t108 + ( *( *_t108 - 4) >> 10) * 4 - 1) & 255) + ( *( *_t108 - 4) >> 10) * 4 - 1 - ( *( *_t108 + ( *( *_t108 - 4) >> 10) * 4 - 1) & 255) + 1;
                caml_blit_string(_t80, 1, __edi, _t101 - __esi + 1, __esi);
                _t101 = _t101 - __esi + 1;
                _t78 = __edi;
                _t108 =  *((intOrPtr*)(_t108 + 4));
            }
            return __edi;
        }
L26:
L10:
        _v12 = _t59;
        if(_t59 <= 1) {
            caml_c_call(2 - _t59);
             *__esp = caml_create_string;
            _push(2 - _v12);
            _push(1);
            caml_c_call(caml_create_string);
            __esp = __esp + 8;
            while(1) {
                _t64 = caml_young_ptr - 12;
                caml_young_ptr = _t64;
                if(_t64 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t58 = _t64 + 4;
             *((intOrPtr*)(_t58 - 4)) = 2048;
             *_t58 =  *__esp;
            _t58[1] = _v4;
            _t89 = _v8 - _v12 + 1;
            _t103 = _v16;
            continue;
        } else {
            caml_c_call(_t59 + -2);
             *__esp = caml_create_string;
            _push(_v12 + -2);
            _push(1);
            caml_c_call(caml_create_string);
            __esp = __esp + 8;
            caml_c_call( *((intOrPtr*)(_v16 + 12)));
            _t107 = _v4;
            if(_t107 == 1) {
                _t72 =  *__esp;
                __esp = __esp + 20;
                return _t72;
            } else {
                _t117 = _v8 + _v12 - 3;
                _v16 = _t117;
                while(1) {
                    _t75 = caml_young_ptr - 12;
                    caml_young_ptr = _t75;
                    if(_t75 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t100 = _t75 + 4;
                _v12 = _t100;
                 *((intOrPtr*)(_t100 - 4)) = 2048;
                 *_t100 =  *__esp;
                _t100[1] = _t107;
                _push(_t117);
                _t78 = caml_create_string;
                caml_c_call();
                __esp = __esp + 4;
                _t101 = _v16;
                _t108 = _v12;
                __esp = __esp + 20;
                goto L1;
            }
        }
        goto L26;
    }
}

camlPervasives__read_int_1289()
{// addr = 0x0804FB40
    caml_c_call(camlPervasives__read_line_1288());
    return caml_int_of_string;
}

camlPervasives__read_float_1290()
{// addr = 0x0804FB60
    caml_c_call(camlPervasives__read_line_1288());
    return caml_float_of_string;
}

camlPervasives__fun_1495(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FB80
    caml_c_call(__eax);
    return caml_ml_channel_size_64;
}

camlPervasives__fun_1493(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FB90
    caml_c_call(__eax);
    return caml_ml_pos_in_64;
}

camlPervasives__fun_1491(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FBA0
    caml_c_call(__ebx);
    return caml_ml_seek_in_64;
}

camlPervasives__fun_1489(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FBB0
    caml_c_call(__eax);
    return caml_ml_channel_size_64;
}

camlPervasives__fun_1487(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FBC0
    caml_c_call(__eax);
    return caml_ml_pos_out_64;
}

camlPervasives__fun_1485(
    _unknown_ __eax                        // r0
)
{// addr = 0x0804FBD0
    caml_c_call(__ebx);
    return caml_ml_seek_out_64;
}

camlPervasives__$5e$5e_1312(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804FBE0
    char* _v4;                             // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t23;                         // _t23

    __esp = __esp - 4;
     *__esp = __eax;
    L1();
    _t23 =  *__esp;
    __esp = __esp + 4;
    __esp = __esp - 16;
    __edx = _t23;
    _v12 = __edx;
    _v4 =  &camlPervasives__85;
     *__esp = ( *(__edx - 4) >> 10) * 4 - 1 - ( *(__edx + ( *(__edx - 4) >> 10) * 4 - 1) & 255) + ( *(__edx - 4) >> 10) * 4 - 1 - ( *(__edx + ( *(__edx - 4) >> 10) * 4 - 1) & 255) + 1;
    _v8 = ( *( &camlPervasives__85 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__85 + ( *( &camlPervasives__85 - 4) >> 10) * 4 - 1) & 255) + ( *( &camlPervasives__85 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__85 + ( *( &camlPervasives__85 - 4) >> 10) * 4 - 1) & 255) + 1;
    caml_c_call(( *(__edx - 4) >> 10) * 4 - 1 - ( *(__edx + ( *(__edx - 4) >> 10) * 4 - 1) & 255) + ( *(__edx - 4) >> 10) * 4 - 1 - ( *(__edx + ( *(__edx - 4) >> 10) * 4 - 1) & 255) + 1 + ( *( &camlPervasives__85 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__85 + ( *( &camlPervasives__85 - 4) >> 10) * 4 - 1) & 255) + ( *( &camlPervasives__85 - 4) >> 10) * 4 - 1 - ( *( &camlPervasives__85 + ( *( &camlPervasives__85 - 4) >> 10) * 4 - 1) & 255) + 1 - 1);
    __esi =  *__esp;
    caml_blit_string(_v12, 1, caml_create_string, 1,  *__esp);
    caml_blit_string(_v4, 1, caml_create_string, __esi, _v8);
    __esp = __esp + 16;
    return caml_create_string;
}

camlPervasives__string_of_format_1315(
    intOrPtr __eax                         // r0
)
{// addr = 0x0804FC00
    intOrPtr _v4;                          // _cfa_fffffffc

    _v4 = __eax;
     *__esp = ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + 1;
    caml_c_call(( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + ( *(__eax - 4) >> 10) * 4 - 1 - ( *(__eax + ( *(__eax - 4) >> 10) * 4 - 1) & 255) + 1);
    caml_blit_string(_v4, 1, caml_create_string, 1,  *__esp);
    return caml_create_string;
}

camlPervasives__at_exit_1322(
    intOrPtr __eax,                        // r0
    _unknown_ __edi,                       // r4
    _unknown_ __esi                        // r5
)
{// addr = 0x0804FC50
    intOrPtr _t9;                          // _t9
    intOrPtr* _t11;                        // _t11

    __esi = __esi;
    __edi = __edi;
    __ebx =  *((intOrPtr*)( *134679816));
    while(1) {
        _t9 = caml_young_ptr - 20;
        caml_young_ptr = _t9;
        if(_t9 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t11 = _t9 + 4;
     *((intOrPtr*)(_t11 - 4)) = 4343;
     *_t11 = camlPervasives__fun_1500;
    _t11[1] = 3;
    _t11[2] = __eax;
    _t11[3] = __ebx;
    caml_modify(__ebx, __edi, __esi,  *134679816, _t11);
    return 1;
}

camlPervasives__do_at_exit_1325()
{// addr = 0x0804FCB0
    goto ( *((intOrPtr*)( *((intOrPtr*)( *134679816)))));
}

camlPervasives__exit_1326()
{// addr = 0x0804FCC0
    intOrPtr _t1;                          // _t1

     *__esp = _t1;
     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *134679816))))))();
    caml_c_call( *__esp);
}

camlPervasives__entry()
{// addr = 0x0804FCF0
    intOrPtr* _t14;                        // _t14
    intOrPtr* _t81;                        // _t81
    intOrPtr* _t82;                        // _t82

     *134679776 =  &camlPervasives__84;
     *134679768 =  &camlPervasives__83;
     *134679764 =  &camlPervasives__82;
     *134679760 =  &camlPervasives__81;
     *134679756 =  &camlPervasives__80;
     *134679752 =  &camlPervasives__79;
     *134679748 =  &camlPervasives__78;
     *134679744 =  &camlPervasives__77;
     *134679728 =  &camlPervasives__76;
     *134679712 =  &camlPervasives__75;
     *134679700 =  &camlPervasives__74;
     *134679696 =  &camlPervasives__73;
     *134679692 =  &camlPervasives__72;
     *134679684 =  &camlPervasives__71;
     *134679680 =  &camlPervasives__70;
     *134679668 =  &camlPervasives__69;
     *134679660 =  &camlPervasives__68;
     *134679492 =  &camlPervasives__67;
    camlPervasives =  &camlPervasives__66;
    _t14 = caml_alloc1() + 4;
     *((intOrPtr*)(_t14 - 4)) = 1024;
     *_t14 = "Pervasives.Exit";
     *134679496 = _t14;
     *134679500 =  &camlPervasives__64;
     *134679504 =  &camlPervasives__63;
     *134679508 =  &camlPervasives__62;
     *134679520 =  &camlPervasives__61;
     *134679516 = -2147483647;
     *134679512 = 2147483647;
    caml_c_call( &camlPervasives__60);
    __esp = __esp + 4;
     *134679524 = caml_int64_float_of_bits;
    caml_c_call( &camlPervasives__59);
     *134679528 = caml_int64_float_of_bits;
    caml_c_call( &camlPervasives__58);
     *134679532 = caml_int64_float_of_bits;
    caml_c_call( &camlPervasives__57);
     *134679536 = caml_int64_float_of_bits;
    caml_c_call( &camlPervasives__56);
     *134679540 = caml_int64_float_of_bits;
    caml_c_call( &camlPervasives__55);
     *134679544 = caml_int64_float_of_bits;
     *134679548 =  &camlPervasives__54;
     *134679552 =  &camlPervasives__53;
     *134679556 =  &camlPervasives__52;
     *134679560 =  &camlPervasives__51;
     *134679564 =  &camlPervasives__50;
     *134679812 =  &camlPervasives__49;
     *134679800 =  &camlPervasives__48;
     *134679568 =  &camlPervasives__47;
     *134679572 =  &camlPervasives__46;
    caml_c_call(1);
     *134679576 = caml_ml_open_descriptor_in;
    caml_c_call(3);
     *134679580 = caml_ml_open_descriptor_out;
    caml_c_call(5);
     *134679584 = caml_ml_open_descriptor_out;
     *134679656 =  &camlPervasives__45;
     *134679648 =  &camlPervasives__44;
     *134679652 =  &camlPervasives__43;
     *134679664 =  &camlPervasives__42;
     *134679672 =  &camlPervasives__41;
     *134679676 =  &camlPervasives__40;
     *134679688 =  &camlPervasives__39;
     *134679704 =  &camlPervasives__38;
     *134679708 =  &camlPervasives__37;
     *134679724 =  &camlPervasives__36;
     *134679716 =  &camlPervasives__35;
     *134679720 =  &camlPervasives__34;
     *134679736 =  &camlPervasives__33;
     *134679804 =  &camlPervasives__32;
     *134679740 =  &camlPervasives__31;
     *134679732 =  &camlPervasives__30;
     *134679772 =  &camlPervasives__29;
     *134679588 =  &camlPervasives__28;
     *134679592 =  &camlPervasives__27;
     *134679596 =  &camlPervasives__26;
     *134679600 =  &camlPervasives__25;
     *134679604 =  &camlPervasives__24;
     *134679608 =  &camlPervasives__23;
     *134679612 =  &camlPervasives__22;
     *134679616 =  &camlPervasives__21;
     *134679620 =  &camlPervasives__20;
     *134679624 =  &camlPervasives__19;
     *134679628 =  &camlPervasives__18;
     *134679632 =  &camlPervasives__17;
     *134679636 =  &camlPervasives__16;
     *134679640 =  &camlPervasives__15;
     *134679644 =  &camlPervasives__14;
    _t81 = caml_allocN(36) + 4;
     *((intOrPtr*)(_t81 - 4)) = 6144;
     *_t81 =  &camlPervasives__7;
     *((intOrPtr*)(_t81 + 4)) =  &camlPervasives__8;
     *((intOrPtr*)(_t81 + 8)) =  &camlPervasives__9;
     *((intOrPtr*)(_t81 + 12)) =  &camlPervasives__10;
     *((intOrPtr*)(_t81 + 16)) =  &camlPervasives__11;
     *((intOrPtr*)(_t81 + 20)) =  &camlPervasives__12;
     *134679780 = _t81;
     *134679788 =  &camlPervasives__6;
     *134679784 =  &camlPervasives__5;
    _t82 = _t81 + 28;
     *((intOrPtr*)(_t82 - 4)) = 1024;
     *_t82 =  *134679664;
     *134679816 = _t82;
     *134679796 =  &camlPervasives__4;
     *134679808 =  &camlPervasives__3;
     *134679792 =  &camlPervasives__2;
    _push( *134679808);
    caml_c_call("Pervasives.do_at_exit");
    __esp = __esp + 4;
    return 1;
}

camlArray__size_1065(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08050380
    unsigned int _t7;                      // _t7
    signed int _t8;                        // _t8

L0:
    while(1) {
L0:
        _t3 = __eax;
        if(__ebx == 1) {
            break;
        }
L1:
        _t7 =  *( *__ebx - 4);
        if((_t7 & 255) == 254) {
            _t8 = _t7 >> 10;
        } else {
            _t8 = _t7 >> 9;
        }
        _t3 = _t3 + (_t8 | 1) - 1;
    }
L5:
    return __eax;
}

signed int camlArray__fill_1070(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x080503D0
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _t29;                         // _t29
    intOrPtr _t32;                         // _t32
    intOrPtr _t42;                         // _t42
    long long* _t44;                       // _t44
    signed int _t45;                       // _t45
    intOrPtr* _t48;                        // _t48
    signed int _t49;                       // _t49
    unsigned int _t50;                     // _t50
    signed int _t51;                       // _t51
    _unknown_ _t53;                        // _t53
    intOrPtr _t54;                         // _t54
    unsigned int _t57;                     // _t57
    signed int _t58;                       // _t58
    _unknown_ _t60;                        // _t60

    _t53 = __ecx;
    _t48 = __ebx;
    _t29 = __eax;
    while(1) {
        __edi = _t53;
        if(_t48 == 1) {
            break;
        }
        _v12 = _t29;
         *__esp = _t48[1];
        _t32 =  *_t48;
        _v16 = _t32;
        _t49 = 1;
        _t57 =  *(_t32 - 4);
        if((_t57 & 255) == 254) {
            _t58 = _t57 >> 10;
        } else {
            _t58 = _t57 >> 9;
        }
        _t60 = (_t58 | 1) + -2;
        if(_t49 <= _t60) {
            do {
                _t54 = _v16;
                if(( *(_t54 - 4) & 255) == 254) {
                    while(1) {
                        _t42 = caml_young_ptr - 12;
                        caml_young_ptr = _t42;
                        if(_t42 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t44 = _t42 + 4;
                     *((intOrPtr*)(_t44 - 4)) = 2301;
                     *_t44 =  *((long long*)(_t54 + _t49 * 4 - 4));
                } else {
                    _t44 =  *((intOrPtr*)(_t54 + _t49 * 2 - 2));
                }
                __ebp = _v12 + _t49 - 1;
                __edx =  *((intOrPtr*)(__edi + 12));
                if(( *(__edx - 4) & 255) == 254) {
                     *((long long*)(__edx + __ebp * 4 - 4)) =  *_t44;
                } else {
                    caml_modify(_t49, __edi, _t60, __edx + __ebp * 2 - 2, _t44);
                }
                _t45 = _t49;
                _t49 = _t49 + 2;
            } while(_t45 != _t60);
        }
        _t50 =  *(_v16 - 4);
        if((_t50 & 255) == 254) {
            _t51 = _t50 >> 10;
        } else {
            _t51 = _t50 >> 9;
        }
        _t29 = _v12 + (_t51 | 1) - 1;
        _t48 =  *__esp;
        _t53 = __edi;
    }
    return 1;
}

camlArray__find_init_1077(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08050500
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr* _t13;                        // _t13
    intOrPtr _t17;                         // _t17
    long long* _t19;                       // _t19
    _unknown_ _t22;                        // _t22
    intOrPtr _t25;                         // _t25
    intOrPtr* _t30;                        // _t30
    intOrPtr* _t34;                        // _t34
    intOrPtr* _t35;                        // _t35
    unsigned int _t36;                     // _t36
    signed int _t37;                       // _t37

    _t13 = __eax;
    while(1) {
        _t30 = _t13;
        if(_t30 == 1) {
            break;
        }
        _t13 = _t30[1];
        _t34 =  *_t30;
        _t36 =  *(_t34 - 4);
        if((_t36 & 255) == 254) {
            _t37 = _t36 >> 10;
        } else {
            _t37 = _t36 >> 9;
        }
        if((_t37 | 1) <= 1) {
            continue;
        } else {
            if(( *(_t34 - 4) & 255) == 254) {
                while(1) {
                    _t17 = caml_young_ptr - 12;
                    caml_young_ptr = _t17;
                    if(_t17 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t19 = _t17 + 4;
                 *((intOrPtr*)(_t19 - 4)) = 2301;
                 *_t19 =  *_t34;
            } else {
                _t19 =  *_t34;
            }
            __esp = __esp + 8;
            __esp = __esp - 8;
             *__esp = _t19;
            _v4 = _t30;
            _t22 = camlArray__size_1065(1, _t30);
            caml_c_call( *__esp);
             *__esp = caml_make_vect;
            while(1) {
                _t25 = caml_young_ptr - 20;
                caml_young_ptr = _t25;
                if(_t25 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t35 = _t25 + 4;
             *((intOrPtr*)(_t35 - 4)) = 4343;
             *_t35 = caml_curry2;
            _t35[1] = 5;
            _t35[2] = camlArray__fill_1070;
            _t35[3] = caml_make_vect;
            camlArray__fill_1070(1, _v4, _t35);
            return  *__esp;
        }
L18:
    }
    return  &camlArray__36;
    goto L18;
}

camlArray__tolist_1123(
    signed int __eax,                      // r0
    intOrPtr* __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x080505A0
    signed int _t14;                       // _t14
    intOrPtr _t17;                         // _t17
    intOrPtr _t20;                         // _t20
    intOrPtr _t24;                         // _t24
    intOrPtr* _t25;                        // _t25

    __ecx = __ecx;
    __ebx = __ebx;
    _t14 = __eax;
    while(1) {
        __edx = _t14;
        if(__edx < 1) {
            break;
        }
        _t24 =  *((intOrPtr*)(__ecx + 12));
        if(( *(_t24 - 4) & 255) == 254) {
            while(1) {
                _t17 = caml_young_ptr - 12;
                caml_young_ptr = _t17;
                if(_t17 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            __edi = _t17 + 4;
             *((intOrPtr*)(__edi - 4)) = 2301;
             *__edi =  *((long long*)(_t24 + __edx * 4 - 4));
        } else {
            __edi =  *((intOrPtr*)(_t24 + __edx * 2 - 2));
            while(1) {
L7:
                _t20 = caml_young_ptr - 12;
                caml_young_ptr = _t20;
                if(_t20 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t25 = _t20 + 4;
             *((intOrPtr*)(_t25 - 4)) = 2048;
             *_t25 = __edi;
            _t25[1] = __ebx;
            _t14 = __edx + -2;
            __ebx = _t25;
            continue;
        }
        goto L7;
    }
    return __ebx;
}

camlArray__fill_1135(
    signed int __eax,                      // r0
    intOrPtr* __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x08050630
    signed int _t11;                       // _t11
    intOrPtr* _t17;                        // _t17
    intOrPtr _t18;                         // _t18
    _unknown_ _t19;                        // _t19
    long long* _t20;                       // _t20

    _t19 = __ecx;
    _t17 = __ebx;
    _t11 = __eax;
    while(1) {
        __edi = _t11;
        __esi = _t19;
        if(_t17 == 1) {
            break;
        }
        __ebp = _t17[1];
        _t20 =  *_t17;
        _t18 =  *((intOrPtr*)(__esi + 12));
        if(( *(_t18 - 4) & 255) == 254) {
             *((long long*)(_t18 + __edi * 4 - 4)) =  *_t20;
        } else {
            caml_modify(_t18, __edi, __esi, _t18 + __edi * 2 - 2, _t20);
        }
        _t11 = __edi + 2;
        _t17 = __ebp;
        _t19 = __esi;
    }
    return  *((intOrPtr*)(__esi + 12));
}

signed int camlArray__maxson_1155(
    signed int __eax,                      // r0
    signed int* __ebx,                     // r1
    signed int __ecx                       // r2
)
{// addr = 0x08050690
    signed int _v12;                       // _cfa_fffffff4
    signed int* _v16;                      // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v76;                       // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _t180;                        // _t180
    signed int _t186;                      // _t186
    intOrPtr _t188;                        // _t188
    intOrPtr* _t190;                       // _t190
    intOrPtr _t205;                        // _t205
    unsigned int _t207;                    // _t207
    intOrPtr* _t210;                       // _t210
    _unknown_ _t211;                       // _t211
    intOrPtr _t213;                        // _t213
    intOrPtr _t215;                        // _t215
    unsigned int _t217;                    // _t217
    intOrPtr* _t220;                       // _t220
    _unknown_ _t221;                       // _t221
    intOrPtr _t224;                        // _t224
    intOrPtr _t226;                        // _t226
    intOrPtr _t236;                        // _t236
    long long* _t238;                      // _t238
    intOrPtr _t240;                        // _t240
    unsigned int _t250;                    // _t250
    intOrPtr _t253;                        // _t253
    signed int _t255;                      // _t255
    intOrPtr _t261;                        // _t261
    signed int _t263;                      // _t263
    intOrPtr _t271;                        // _t271
    long long* _t273;                      // _t273
    unsigned int _t280;                    // _t280
    intOrPtr _t283;                        // _t283
    unsigned int _t285;                    // _t285
    intOrPtr _t288;                        // _t288
    long long* _t290;                      // _t290
    unsigned int _t291;                    // _t291
    intOrPtr _t294;                        // _t294
    unsigned int _t297;                    // _t297
    intOrPtr _t300;                        // _t300
    long long* _t302;                      // _t302
    signed int _t316;                      // _t316
    signed int _t317;                      // _t317
    signed int _t319;                      // _t319
    unsigned int _t322;                    // _t322
    signed int _t335;                      // _t335
    signed int _t337;                      // _t337
    unsigned int _t339;                    // _t339
    unsigned int _t340;                    // _t340
    intOrPtr _t342;                        // _t342
    signed int _t347;                      // _t347
    signed int _t361;                      // _t361
    signed int _t362;                      // _t362
    long long* _t368;                      // _t368
    signed int* _t370;                     // _t370
    unsigned int _t372;                    // _t372
    unsigned int _t375;                    // _t375
    signed int _t379;                      // _t379
    unsigned int _t382;                    // _t382
    signed int _t383;                      // _t383

    _t335 = __ecx;
    __esp = __esp - 20;
    _t379 =  &(__ebx[0]) + __ebx + __ebx + -3;
    _v12 = _t379;
    while(1) {
        _t180 = caml_young_ptr - 8;
        caml_young_ptr = _t180;
        if(_t180 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t370 = _t180 + 4;
     *((intOrPtr*)(_t370 - 4)) = 1024;
     *_t370 = _t379;
    if(_t379 + 4 >= __eax) {
        _v16 = __ebx;
         *__esp = __eax;
        if(_t379 + 2 >= __eax) {
L47:
            _t186 = _v12;
            if(_t186 >=  *__esp) {
L49:
                _t188 = caml_young_ptr - 12;
                caml_young_ptr = _t188;
                if(_t188 >= caml_young_limit) {
                    _t190 = _t188 + 4;
                     *((intOrPtr*)(_t190 - 4)) = 2048;
                     *_t190 =  *134683232;
                     *(_t190 + 4) = _v16;
                    caml_raise_exn(_t190);
                }
                caml_call_gc();
                goto L49;
            }
            __esp =  &(__esp[5]);
            return _t186;
        } else {
            _t316 = _t379 + 2;
            _t361 =  *(_t335 + 16);
            _t371 =  *(_t361 - 4);
            if((_t371 & 255) == 254) {
                if(_t371 >> 10 <= _t316) {
                    goto L61;
                } else {
                    while(1) {
                        _t261 = caml_young_ptr - 12;
                        caml_young_ptr = _t261;
                        if(_t261 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t263 = _t261 + 4;
                     *(_t263 - 4) = 2301;
                     *_t263 =  *((long long*)(_t361 + _t316 * 4 - 4));
                    _t316 = _t263;
                    goto L39;
                }
            } else {
                if(_t371 >> 9 <= _t316) {
L62:
                    caml_ml_array_bound_error();
                    goto L63;
                } else {
                    _t316 =  *(_t361 + _t316 * 2 - 2);
L39:
                    _t361 =  *(_t335 + 16);
                    _t371 =  *(_t361 - 4);
                    if((_t371 & 255) == 254) {
                        if(_t371 >> 10 <= _t379) {
                            caml_ml_array_bound_error();
                            goto L60;
                        } else {
                            while(1) {
                                _t271 = caml_young_ptr - 12;
                                caml_young_ptr = _t271;
                                if(_t271 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            _t273 = _t271 + 4;
                             *((intOrPtr*)(_t273 - 4)) = 2301;
                             *_t273 =  *((long long*)(_t361 + _t379 * 4 - 4));
                            goto L45;
                        }
                    } else {
                        if(_t371 >> 9 <= _t379) {
L60:
                            caml_ml_array_bound_error();
L61:
                            caml_ml_array_bound_error();
                            goto L62;
                        } else {
                            _t273 =  *((intOrPtr*)(_t361 + _t379 * 2 - 2));
L45:
                            caml_apply2();
                            if(_t273 >= 1) {
                                goto L47;
                            } else {
                                __esp =  &(__esp[5]);
                                return _v12 + 2;
                            }
                        }
                    }
                }
            }
        }
    } else {
        _v16 = _t370;
         *__esp = _t335;
        _t361 = _t379 + 2;
        _t371 =  *(_t335 + 16);
        _t280 =  *(_t371 - 4);
        _t316 = _t280 & 255;
        if(_t316 == 254) {
            if(_t280 >> 10 <= _t361) {
                goto L69;
            } else {
                while(1) {
                    _t283 = caml_young_ptr - 12;
                    caml_young_ptr = _t283;
                    if(_t283 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t316 = _t283 + 4;
                 *(_t316 - 4) = 2301;
                 *_t316 =  *((long long*)(_t371 + _t361 * 4 - 4));
                goto L9;
            }
        } else {
            if(_t280 >> 9 <= _t361) {
L70:
                _t205 = caml_ml_array_bound_error();
                __esp = __esp - 28;
                while(1) {
                    _v44 = _t205;
                    _v36 = _t316;
                    _v40 = _t335;
                     *__esp = _t361;
                    _t317 = camlArray__maxson_1155(_t205, _t316,  *((intOrPtr*)(_t361 + 20)));
                    _v32 = _t317;
                    _t362 =  *__esp;
                    _t337 =  *(_t362 + 16);
                    _t207 =  *(_t337 - 4);
                    _t381 = _t207 & 255;
                    if((_t207 & 255) == 254) {
                        goto L75;
                    }
                    if(_t207 >> 9 <= _t317) {
L106:
                        _t210 = caml_ml_array_bound_error();
                        __esp = __esp - 16;
                        _v60 = _t337;
                         *__esp = _t362;
                        L115();
                        if( *_t210 !=  *134683232) {
                            _t211 = caml_raise_exn(_t210);
                            _push(caml_exception_pointer);
                            caml_exception_pointer = __esp;
                            L71();
                            _pop(caml_exception_pointer);
                            __esp =  &(__esp[4]);
                            return _t211;
                        } else {
                            _t319 =  *(_t210 + 4);
                            _t213 =  *((intOrPtr*)( *__esp + 12));
                            _t339 =  *(_t213 - 4);
                            if((_t339 & 255) == 254) {
                                _t340 = _t339 >> 10;
                                if(_t340 <= _t319) {
                                    caml_ml_array_bound_error();
                                    goto L117;
                                } else {
                                     *((long long*)(_t213 + _t319 * 4 - 4)) =  *_v60;
                                    goto L113;
                                }
                            } else {
                                _t340 = _t339 >> 9;
                                if(_t340 <= _t319) {
L117:
                                    _t215 = caml_ml_array_bound_error();
                                    __esp = __esp - 20;
                                    while(1) {
                                        _v80 = _t215;
                                        _v76 = _t319;
                                         *__esp = _t340;
                                        _t319 = camlArray__maxson_1155(_t215, _t319,  *((intOrPtr*)(_t340 + 16)));
                                        _t382 =  *__esp;
                                        _t342 =  *((intOrPtr*)(_t382 + 12));
                                        _t217 =  *(_t342 - 4);
                                        if((_t217 & 255) == 254) {
                                            goto L122;
                                        }
                                        if(_t217 >> 9 > _t319) {
                                            _t368 =  *((intOrPtr*)(_t342 + _t319 * 2 - 2));
L125:
                                            _t226 =  *((intOrPtr*)(_t382 + 12));
                                            _t372 =  *(_t226 - 4);
                                            if((_t372 & 255) == 254) {
                                                _t347 = _v76;
                                                if(_t372 >> 10 <= _t347) {
                                                    caml_ml_array_bound_error();
                                                    goto L133;
                                                } else {
                                                     *((long long*)(_t226 + _t347 * 4 - 4)) =  *_t368;
                                                    goto L130;
                                                }
                                            } else {
                                                _t374 = _t372 >> 9;
                                                _t348 = _v76;
                                                if(_t372 >> 9 <= _v76) {
L133:
                                                    caml_ml_array_bound_error();
L134:
                                                    caml_ml_array_bound_error();
                                                } else {
                                                    caml_modify(_t319, _t374, _t382, _t226 + _t348 * 2 - 2, _t368);
L130:
                                                    _t215 = _v80;
                                                    _t340 = _t382;
                                                    continue;
                                                }
                                            }
                                        }
L135:
                                        _t220 = caml_ml_array_bound_error();
                                        L139();
                                        if( *_t220 !=  *134683232) {
                                            _t221 = caml_raise_exn(_t220);
                                            _push(caml_exception_pointer);
                                            caml_exception_pointer = __esp;
                                            L118();
                                            _pop(caml_exception_pointer);
                                            __esp =  &(__esp[1]);
                                            return _t221;
                                        } else {
                                            return _t220[1];
                                        }
                                        goto L140;
L122:
                                        if(_t217 >> 10 <= _t319) {
                                            goto L134;
                                        } else {
                                            while(1) {
                                                _t224 = caml_young_ptr - 12;
                                                caml_young_ptr = _t224;
                                                if(_t224 >= caml_young_limit) {
                                                    break;
                                                }
                                                caml_call_gc();
                                            }
                                            _t368 = _t224 + 4;
                                             *((intOrPtr*)(_t368 - 4)) = 2301;
                                             *_t368 =  *((long long*)(_t342 + _t319 * 4 - 4));
                                            goto L125;
                                        }
                                        goto L135;
                                    }
                                } else {
                                    caml_modify(_t319, _t371, _t381, _t213 + _t319 * 2 - 2, _v60);
L113:
                                    __esp =  &(__esp[4]);
                                    return 1;
                                }
                            }
                        }
                    } else {
                        _t238 =  *((intOrPtr*)(_t337 + _t317 * 2 - 2));
L78:
                        caml_apply2();
                        if(_t238 <= 1) {
                            _t240 =  *((intOrPtr*)( *__esp + 16));
                            _t322 =  *(_t240 - 4);
                            if((_t322 & 255) == 254) {
                                _t337 = _v36;
                                if(_t322 >> 10 <= _t337) {
                                    caml_ml_array_bound_error();
                                    goto L100;
                                } else {
                                     *((long long*)(_t240 + _t337 * 4 - 4)) =  *_v40;
                                    goto L96;
                                }
                            } else {
                                _t337 = _v36;
                                if(_t322 >> 9 <= _t337) {
L100:
                                    caml_ml_array_bound_error();
                                    goto L101;
                                } else {
                                    caml_modify(_v40, _t371, _t381, _t240 + _t337 * 2 - 2, _v40);
L96:
                                    __esp =  &(__esp[7]);
                                    return 1;
                                }
                            }
                        } else {
                            _t381 =  *__esp;
                            _t337 =  *(_t381 + 16);
                            _t250 =  *(_t337 - 4);
                            if((_t250 & 255) == 254) {
                                _t316 = _v32;
                                if(_t250 >> 10 <= _t316) {
                                    goto L103;
                                } else {
                                    while(1) {
                                        _t253 = caml_young_ptr - 12;
                                        caml_young_ptr = _t253;
                                        if(_t253 >= caml_young_limit) {
                                            break;
                                        }
                                        caml_call_gc();
                                    }
                                    _t362 = _t253 + 4;
                                     *(_t362 - 4) = 2301;
                                     *_t362 =  *((long long*)(_t337 + _t316 * 4 - 4));
                                    goto L85;
                                }
                            } else {
                                _t316 = _v32;
                                if(_t250 >> 9 <= _t316) {
L104:
                                    caml_ml_array_bound_error();
L105:
                                    caml_ml_array_bound_error();
                                    goto L106;
                                } else {
                                    _t362 =  *(_t337 + _t316 * 2 - 2);
L85:
                                    _t255 =  *(_t381 + 16);
                                    _t375 =  *((unsigned int*)(_t255 - 4));
                                    if((_t375 & 255) == 254) {
                                        _t371 = _t375 >> 10;
                                        _t337 = _v36;
                                        if(_t375 >> 10 <= _t337) {
L101:
                                            caml_ml_array_bound_error();
                                            goto L102;
                                        } else {
                                             *((long long*)(_t255 + _t337 * 4 - 4)) =  *_t362;
                                            goto L90;
                                        }
                                    } else {
                                        _t371 = _t375 >> 9;
                                        _t337 = _v36;
                                        if(_t375 >> 9 <= _t337) {
L102:
                                            caml_ml_array_bound_error();
L103:
                                            caml_ml_array_bound_error();
                                            goto L104;
                                        } else {
                                            caml_modify(_t316, _t371, _t381, _t255 + _t337 * 2 - 2, _t362);
L90:
                                            _t205 = _v44;
                                            _t335 = _v40;
                                            _t361 = _t381;
                                            continue;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    goto L140;
L75:
                    if(_t207 >> 10 <= _t317) {
                        goto L105;
                    } else {
                        while(1) {
                            _t236 = caml_young_ptr - 12;
                            caml_young_ptr = _t236;
                            if(_t236 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t238 = _t236 + 4;
                         *((intOrPtr*)(_t238 - 4)) = 2301;
                         *_t238 =  *((long long*)(_t337 + _t317 * 4 - 4));
                        goto L78;
                    }
                    goto L140;
                }
            } else {
                _t316 =  *(_t371 + _t361 * 2 - 2);
L9:
                _t361 =  *(_t335 + 16);
                _t285 =  *(_t361 - 4);
                _t371 = _t285 & 255;
                if((_t285 & 255) == 254) {
                    if(_t285 >> 10 <= _t379) {
                        goto L67;
                    } else {
                        while(1) {
                            _t288 = caml_young_ptr - 12;
                            caml_young_ptr = _t288;
                            if(_t288 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t290 = _t288 + 4;
                         *((intOrPtr*)(_t290 - 4)) = 2301;
                         *_t290 =  *((long long*)(_t361 + _t379 * 4 - 4));
                        goto L15;
                    }
                } else {
                    if(_t285 >> 9 <= _t379) {
L68:
                        caml_ml_array_bound_error();
L69:
                        caml_ml_array_bound_error();
                        goto L70;
                    } else {
                        _t290 =  *((intOrPtr*)(_t361 + _t379 * 2 - 2));
L15:
                        caml_apply2();
                        if(_t290 < 1) {
                             *_v16 = _v12 + 2;
                        }
                        _t335 = _v12 + 4;
                        _t383 =  *__esp;
                        _t361 =  *(_t383 + 16);
                        _t291 =  *(_t361 - 4);
                        _t316 = _t291 & 255;
                        if(_t316 == 254) {
                            if(_t291 >> 10 <= _t335) {
                                goto L65;
                            } else {
                                while(1) {
                                    _t294 = caml_young_ptr - 12;
                                    caml_young_ptr = _t294;
                                    if(_t294 >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc();
                                }
                                _t316 = _t294 + 4;
                                 *(_t316 - 4) = 2301;
                                 *_t316 =  *((long long*)(_t361 + _t335 * 4 - 4));
                                goto L23;
                            }
                        } else {
                            if(_t291 >> 9 <= _t335) {
L66:
                                caml_ml_array_bound_error();
L67:
                                caml_ml_array_bound_error();
                                goto L68;
                            } else {
                                _t316 =  *(_t361 + _t335 * 2 - 2);
L23:
                                _t361 =  *_v16;
                                _t335 =  *(_t383 + 16);
                                _t297 =  *(_t335 - 4);
                                _t371 = _t297 & 255;
                                if((_t297 & 255) == 254) {
                                    if(_t297 >> 10 <= _t361) {
L63:
                                        caml_ml_array_bound_error();
                                        goto L64;
                                    } else {
                                        while(1) {
                                            _t300 = caml_young_ptr - 12;
                                            caml_young_ptr = _t300;
                                            if(_t300 >= caml_young_limit) {
                                                break;
                                            }
                                            caml_call_gc();
                                        }
                                        _t302 = _t300 + 4;
                                         *((intOrPtr*)(_t302 - 4)) = 2301;
                                         *_t302 =  *((long long*)(_t335 + _t361 * 4 - 4));
                                        goto L29;
                                    }
                                } else {
                                    if(_t297 >> 9 <= _t361) {
L64:
                                        caml_ml_array_bound_error();
L65:
                                        caml_ml_array_bound_error();
                                        goto L66;
                                    } else {
                                        _t302 =  *((intOrPtr*)(_t335 + _t361 * 2 - 2));
L29:
                                        caml_apply2();
                                        if(_t302 < 1) {
                                             *_v16 = _v12 + 4;
                                        }
                                        __esp =  &(__esp[5]);
                                        return  *_v16;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
L140:
}

camlArray__trickledown_1160(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    long long* __ecx,                      // r2
    signed int __edx                       // r3
)
{// addr = 0x08050A80
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    long long* _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _t93;                       // _t93
    unsigned int _t95;                     // _t95
    intOrPtr* _t98;                        // _t98
    _unknown_ _t99;                        // _t99
    _unknown_ _t100;                       // _t100
    intOrPtr _t102;                        // _t102
    signed int _t104;                      // _t104
    unsigned int _t106;                    // _t106
    intOrPtr* _t109;                       // _t109
    _unknown_ _t110;                       // _t110
    intOrPtr _t113;                        // _t113
    intOrPtr _t115;                        // _t115
    intOrPtr _t125;                        // _t125
    long long* _t127;                      // _t127
    intOrPtr _t129;                        // _t129
    unsigned int _t139;                    // _t139
    intOrPtr _t142;                        // _t142
    signed int _t144;                      // _t144
    signed int _t149;                      // _t149
    signed int _t150;                      // _t150
    signed int _t152;                      // _t152
    unsigned int _t155;                    // _t155
    long long* _t162;                      // _t162
    signed int _t164;                      // _t164
    unsigned int _t166;                    // _t166
    unsigned int _t167;                    // _t167
    intOrPtr _t169;                        // _t169
    signed int _t174;                      // _t174
    signed int _t183;                      // _t183
    signed int _t184;                      // _t184
    long long* _t190;                      // _t190
    unsigned int _t192;                    // _t192
    unsigned int _t195;                    // _t195
    unsigned int _t198;                    // _t198

    _t183 = __edx;
    _t162 = __ecx;
    _t149 = __ebx;
    _t93 = __eax;
    __esp = __esp - 28;
    while(1) {
        _v24 = _t93;
        _v16 = _t149;
        _v20 = _t162;
         *__esp = _t183;
        _t150 = camlArray__maxson_1155(_t93, _t149,  *((intOrPtr*)(_t183 + 20)));
        _v12 = _t150;
        _t184 =  *__esp;
        _t164 =  *(_t184 + 16);
        _t95 =  *(_t164 - 4);
        _t197 = _t95 & 255;
        if((_t95 & 255) == 254) {
            goto L4;
        }
        if(_t95 >> 9 <= _t150) {
L35:
            _t98 = caml_ml_array_bound_error();
            __esp = __esp - 16;
            _v40 = _t164;
             *__esp = _t184;
            L44();
            _t165 =  *134683232;
            _t151 =  *_t98;
            if( *_t98 !=  *134683232) {
                _t99 = caml_raise_exn(_t98);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                _t100 = camlArray__trickledown_1160(_t99, _t151, _t165,  *(_t184 + 16));
                _pop(caml_exception_pointer);
                __esp =  &(__esp[4]);
                return _t100;
            } else {
                _t152 =  *(_t98 + 4);
                _t102 =  *((intOrPtr*)( *__esp + 12));
                _t166 =  *(_t102 - 4);
                if((_t166 & 255) == 254) {
                    _t167 = _t166 >> 10;
                    if(_t167 <= _t152) {
                        caml_ml_array_bound_error();
                        goto L46;
                    } else {
                         *((long long*)(_t102 + _t152 * 4 - 4)) =  *_v40;
                        goto L42;
                    }
                } else {
                    _t167 = _t166 >> 9;
                    if(_t167 <= _t152) {
L46:
                        _t104 = caml_ml_array_bound_error();
                        __esp = __esp - 20;
                        while(1) {
                            _v60 = _t104;
                            _v56 = _t152;
                             *__esp = _t167;
                            _t152 = camlArray__maxson_1155(_t104, _t152,  *((intOrPtr*)(_t167 + 16)));
                            _t198 =  *__esp;
                            _t169 =  *((intOrPtr*)(_t198 + 12));
                            _t106 =  *(_t169 - 4);
                            if((_t106 & 255) == 254) {
                                goto L51;
                            }
                            if(_t106 >> 9 > _t152) {
                                _t190 =  *((intOrPtr*)(_t169 + _t152 * 2 - 2));
L54:
                                _t115 =  *((intOrPtr*)(_t198 + 12));
                                _t192 =  *(_t115 - 4);
                                if((_t192 & 255) == 254) {
                                    _t174 = _v56;
                                    if(_t192 >> 10 <= _t174) {
                                        caml_ml_array_bound_error();
                                        goto L62;
                                    } else {
                                         *((long long*)(_t115 + _t174 * 4 - 4)) =  *_t190;
                                        goto L59;
                                    }
                                } else {
                                    _t194 = _t192 >> 9;
                                    _t175 = _v56;
                                    if(_t192 >> 9 <= _v56) {
L62:
                                        caml_ml_array_bound_error();
L63:
                                        caml_ml_array_bound_error();
                                    } else {
                                        caml_modify(_t152, _t194, _t198, _t115 + _t175 * 2 - 2, _t190);
L59:
                                        _t104 = _v60;
                                        _t167 = _t198;
                                        continue;
                                    }
                                }
                            }
L64:
                            _t109 = caml_ml_array_bound_error();
                            L68();
                            if( *_t109 !=  *134683232) {
                                _t110 = caml_raise_exn(_t109);
                                _push(caml_exception_pointer);
                                caml_exception_pointer = __esp;
                                L47();
                                _pop(caml_exception_pointer);
                                __esp =  &(__esp[1]);
                                return _t110;
                            } else {
                                return _t109[1];
                            }
                            goto L69;
L51:
                            if(_t106 >> 10 <= _t152) {
                                goto L63;
                            } else {
                                while(1) {
                                    _t113 = caml_young_ptr - 12;
                                    caml_young_ptr = _t113;
                                    if(_t113 >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc();
                                }
                                _t190 = _t113 + 4;
                                 *((intOrPtr*)(_t190 - 4)) = 2301;
                                 *_t190 =  *((long long*)(_t169 + _t152 * 4 - 4));
                                goto L54;
                            }
                            goto L64;
                        }
                    } else {
                        caml_modify(_t152, _t191, _t197, _t102 + _t152 * 2 - 2, _v40);
L42:
                        __esp =  &(__esp[4]);
                        return 1;
                    }
                }
            }
        } else {
            _t127 =  *((intOrPtr*)(_t164 + _t150 * 2 - 2));
L7:
            caml_apply2();
            if(_t127 <= 1) {
                _t129 =  *((intOrPtr*)( *__esp + 16));
                _t155 =  *(_t129 - 4);
                if((_t155 & 255) == 254) {
                    _t164 = _v16;
                    if(_t155 >> 10 <= _t164) {
                        caml_ml_array_bound_error();
                        goto L29;
                    } else {
                         *((long long*)(_t129 + _t164 * 4 - 4)) =  *_v20;
                        goto L25;
                    }
                } else {
                    _t164 = _v16;
                    if(_t155 >> 9 <= _t164) {
L29:
                        caml_ml_array_bound_error();
                        goto L30;
                    } else {
                        caml_modify(_v20, _t191, _t197, _t129 + _t164 * 2 - 2, _v20);
L25:
                        __esp =  &(__esp[7]);
                        return 1;
                    }
                }
            } else {
                _t197 =  *__esp;
                _t164 =  *(_t197 + 16);
                _t139 =  *(_t164 - 4);
                if((_t139 & 255) == 254) {
                    _t149 = _v12;
                    if(_t139 >> 10 <= _t149) {
                        goto L32;
                    } else {
                        while(1) {
                            _t142 = caml_young_ptr - 12;
                            caml_young_ptr = _t142;
                            if(_t142 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t184 = _t142 + 4;
                         *(_t184 - 4) = 2301;
                         *_t184 =  *((long long*)(_t164 + _t149 * 4 - 4));
                        goto L14;
                    }
                } else {
                    _t149 = _v12;
                    if(_t139 >> 9 <= _t149) {
L33:
                        caml_ml_array_bound_error();
L34:
                        caml_ml_array_bound_error();
                        goto L35;
                    } else {
                        _t184 =  *(_t164 + _t149 * 2 - 2);
L14:
                        _t144 =  *(_t197 + 16);
                        _t195 =  *((unsigned int*)(_t144 - 4));
                        if((_t195 & 255) == 254) {
                            _t191 = _t195 >> 10;
                            _t164 = _v16;
                            if(_t195 >> 10 <= _t164) {
L30:
                                caml_ml_array_bound_error();
                                goto L31;
                            } else {
                                 *((long long*)(_t144 + _t164 * 4 - 4)) =  *_t184;
                                goto L19;
                            }
                        } else {
                            _t191 = _t195 >> 9;
                            _t164 = _v16;
                            if(_t195 >> 9 <= _t164) {
L31:
                                caml_ml_array_bound_error();
L32:
                                caml_ml_array_bound_error();
                                goto L33;
                            } else {
                                caml_modify(_t149, _t191, _t197, _t144 + _t164 * 2 - 2, _t184);
L19:
                                _t93 = _v24;
                                _t162 = _v20;
                                _t183 = _t197;
                                continue;
                            }
                        }
                    }
                }
            }
        }
L69:
L4:
        if(_t95 >> 10 <= _t150) {
            goto L34;
        } else {
            while(1) {
                _t125 = caml_young_ptr - 12;
                caml_young_ptr = _t125;
                if(_t125 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t127 = _t125 + 4;
             *((intOrPtr*)(_t127 - 4)) = 2301;
             *_t127 =  *((long long*)(_t164 + _t150 * 4 - 4));
            goto L7;
        }
        goto L69;
    }
}

camlArray__trickle_1165(
    intOrPtr* __eax,                       // r0
    long long* __ecx,                      // r2
    unsigned int __edx                     // r3
)
{// addr = 0x08050C90
    long long* _v12;                       // _cfa_fffffff4
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _t41;                       // _t41
    _unknown_ _t42;                        // _t42
    intOrPtr _t44;                         // _t44
    signed int _t46;                       // _t46
    unsigned int _t48;                     // _t48
    intOrPtr* _t51;                        // _t51
    _unknown_ _t52;                        // _t52
    intOrPtr _t55;                         // _t55
    intOrPtr _t57;                         // _t57
    signed int _t67;                       // _t67
    unsigned int _t71;                     // _t71
    unsigned int _t72;                     // _t72
    intOrPtr _t74;                         // _t74
    signed int _t79;                       // _t79
    long long* _t89;                       // _t89
    _unknown_ _t90;                        // _t90
    unsigned int _t91;                     // _t91
    _unknown_ _t94;                        // _t94
    unsigned int _t95;                     // _t95

    __esp = __esp - 16;
    _v12 = __ecx;
     *__esp = __edx;
    L8();
    _t70 =  *134683232;
    _t66 =  *__eax;
    if( *__eax !=  *134683232) {
        _t41 = caml_raise_exn(__eax);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _t42 = camlArray__trickledown_1160(_t41, _t66, _t70,  *((intOrPtr*)(__edx + 16)));
        _pop(caml_exception_pointer);
        __esp =  &(__esp[4]);
        return _t42;
    } else {
        _t67 =  *(__eax + 4);
        _t44 =  *((intOrPtr*)( *__esp + 12));
        _t71 =  *(_t44 - 4);
        if((_t71 & 255) == 254) {
            _t72 = _t71 >> 10;
            if(_t72 <= _t67) {
                caml_ml_array_bound_error();
                goto L10;
            } else {
                 *((long long*)(_t44 + _t67 * 4 - 4)) =  *_v12;
                goto L6;
            }
        } else {
            _t72 = _t71 >> 9;
            if(_t72 <= _t67) {
L10:
                _t46 = caml_ml_array_bound_error();
                __esp = __esp - 20;
                while(1) {
                    _v32 = _t46;
                    _v28 = _t67;
                     *__esp = _t72;
                    _t67 = camlArray__maxson_1155(_t46, _t67,  *((intOrPtr*)(_t72 + 16)));
                    _t95 =  *__esp;
                    _t74 =  *((intOrPtr*)(_t95 + 12));
                    _t48 =  *(_t74 - 4);
                    if((_t48 & 255) == 254) {
                        goto L15;
                    }
                    if(_t48 >> 9 > _t67) {
                        _t89 =  *((intOrPtr*)(_t74 + _t67 * 2 - 2));
L18:
                        _t57 =  *((intOrPtr*)(_t95 + 12));
                        _t91 =  *(_t57 - 4);
                        if((_t91 & 255) == 254) {
                            _t79 = _v28;
                            if(_t91 >> 10 <= _t79) {
                                caml_ml_array_bound_error();
                                goto L26;
                            } else {
                                 *((long long*)(_t57 + _t79 * 4 - 4)) =  *_t89;
                                goto L23;
                            }
                        } else {
                            _t93 = _t91 >> 9;
                            _t80 = _v28;
                            if(_t91 >> 9 <= _v28) {
L26:
                                caml_ml_array_bound_error();
L27:
                                caml_ml_array_bound_error();
                            } else {
                                caml_modify(_t67, _t93, _t95, _t57 + _t80 * 2 - 2, _t89);
L23:
                                _t46 = _v32;
                                _t72 = _t95;
                                continue;
                            }
                        }
                    }
L28:
                    _t51 = caml_ml_array_bound_error();
                    L32();
                    if( *_t51 !=  *134683232) {
                        _t52 = caml_raise_exn(_t51);
                        _push(caml_exception_pointer);
                        caml_exception_pointer = __esp;
                        L11();
                        _pop(caml_exception_pointer);
                        __esp =  &(__esp[1]);
                        return _t52;
                    } else {
                        return _t51[1];
                    }
                    goto L33;
L15:
                    if(_t48 >> 10 <= _t67) {
                        goto L27;
                    } else {
                        while(1) {
                            _t55 = caml_young_ptr - 12;
                            caml_young_ptr = _t55;
                            if(_t55 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t89 = _t55 + 4;
                         *((intOrPtr*)(_t89 - 4)) = 2301;
                         *_t89 =  *((long long*)(_t74 + _t67 * 4 - 4));
                        goto L18;
                    }
                    goto L28;
                }
            } else {
                caml_modify(_t67, _t90, _t94, _t44 + _t67 * 2 - 2, _v12);
L6:
                __esp =  &(__esp[4]);
                return 1;
            }
        }
    }
L33:
}

L08050D20(
    _unknown_ __edx                        // r3
)
{
    signed int _t2;                        // _t2
    _unknown_ _t3;                         // _t3

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _t3 = camlArray__trickledown_1160(_t2, __ebx, __ecx,  *((intOrPtr*)(__edx + 16)));
    _pop(caml_exception_pointer);
    __esp = __esp + 16;
    return _t3;
}

camlArray__bubbledown_1170(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08050D50
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _t27;                       // _t27
    unsigned int _t29;                     // _t29
    intOrPtr* _t32;                        // _t32
    _unknown_ _t33;                        // _t33
    _unknown_ _t34;                        // _t34
    intOrPtr _t37;                         // _t37
    intOrPtr _t39;                         // _t39
    signed int _t45;                       // _t45
    intOrPtr _t47;                         // _t47
    intOrPtr _t49;                         // _t49
    signed int _t54;                       // _t54
    signed int _t55;                       // _t55
    long long* _t58;                       // _t58
    unsigned int _t59;                     // _t59

    _t47 = __ecx;
    _t45 = __ebx;
    _t27 = __eax;
    __esp = __esp - 20;
    while(1) {
        _v16 = _t27;
        _v12 = _t45;
         *__esp = _t47;
        _t45 = camlArray__maxson_1155(_t27, _t45,  *((intOrPtr*)(_t47 + 16)));
        __esi =  *__esp;
        _t49 =  *((intOrPtr*)(__esi + 12));
        _t29 =  *(_t49 - 4);
        if((_t29 & 255) == 254) {
            goto L4;
        }
        if(_t29 >> 9 > _t45) {
            _t58 =  *((intOrPtr*)(_t49 + _t45 * 2 - 2));
L7:
            _t39 =  *((intOrPtr*)(__esi + 12));
            _t59 =  *(_t39 - 4);
            if((_t59 & 255) == 254) {
                _t54 = _v12;
                if(_t59 >> 10 <= _t54) {
                    caml_ml_array_bound_error();
                    goto L15;
                } else {
                     *((long long*)(_t39 + _t54 * 4 - 4)) =  *_t58;
                    goto L12;
                }
            } else {
                _t61 = _t59 >> 9;
                _t55 = _v12;
                if(_t59 >> 9 <= _t55) {
L15:
                    caml_ml_array_bound_error();
L16:
                    caml_ml_array_bound_error();
                } else {
                    caml_modify(_t45, _t61, __esi, _t39 + _t55 * 2 - 2, _t58);
L12:
                    _t27 = _v16;
                    _t47 = __esi;
                    continue;
                }
            }
        }
L17:
        _t32 = caml_ml_array_bound_error();
        L21();
        _t50 =  *134683232;
        _t46 =  *_t32;
        if( *_t32 !=  *134683232) {
            _t33 = caml_raise_exn(_t32);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            _t34 = camlArray__bubbledown_1170(_t33, _t46,  *((intOrPtr*)(_t50 + 12)));
            _pop(caml_exception_pointer);
            __esp = __esp + 4;
            return _t34;
        } else {
            return _t32[1];
        }
L4:
        if(_t29 >> 10 <= _t45) {
            goto L16;
        } else {
            while(1) {
                _t37 = caml_young_ptr - 12;
                caml_young_ptr = _t37;
                if(_t37 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t58 = _t37 + 4;
             *((intOrPtr*)(_t58 - 4)) = 2301;
             *_t58 =  *((long long*)(_t49 + _t45 * 4 - 4));
            goto L7;
        }
        goto L17;
    }
}

camlArray__bubble_1174(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08050E50
    signed int _t4;                        // _t4
    _unknown_ _t5;                         // _t5

    L3();
    _t7 =  *134683232;
    __ebx =  *__eax;
    if(__ebx !=  *134683232) {
        _t4 = caml_raise_exn(__eax);
        _push(caml_exception_pointer);
        caml_exception_pointer = __esp;
        _t5 = camlArray__bubbledown_1170(_t4, __ebx,  *((intOrPtr*)(_t7 + 12)));
        _pop(caml_exception_pointer);
        __esp = __esp + 4;
        return _t5;
    } else {
        return  *((intOrPtr*)(__eax + 4));
    }
}

L08050E80(
    _unknown_ __ecx                        // r2
)
{
    signed int _t2;                        // _t2
    _unknown_ _t3;                         // _t3

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _t3 = camlArray__bubbledown_1170(_t2, __ebx,  *((intOrPtr*)(__ecx + 12)));
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    return _t3;
}

unsigned int camlArray__trickleup_1178(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx                       // r2
)
{// addr = 0x08050EA0
    unsigned int _t351;                    // _t351
    intOrPtr* _t353;                       // _t353

    __ecx = __ecx;
    __esp = __esp - 24;
    while(1) {
        __esi = __eax;
        __edi = __ecx;
        __ecx = 3;
        __esi = __esi + -2;
        __eax = __esi + -2 >> 1;
        asm("cdq");
        _t73 = __eax % 3;
        __eax = __eax / 3;
        __edx = _t73;
        __ecx = __eax + __eax + 1;
        if(__esi == __ecx) {
            goto L53;
        }
        __esp[3] = __ecx;
         *__esp = __edi;
        __esp[1] = __ebx;
        __esp[2] = __esi;
L55:
        __edx =  *(__edi + 16);
        __eax =  *(__edx - 4);
        __esi = __eax;
        __esi = __eax & 255;
        if(__esi == 254) {
            if(__eax <= __ecx) {
                goto L98;
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 12;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    __eax = caml_call_gc();
                }
                __eax = __eax + 4;
                 *(__eax - 4) = 2301;
                __fp0 =  *((long long*)(__edx + __ecx * 4 - 4));
                 *__eax =  *((long long*)(__edx + __ecx * 4 - 4));
                goto L61;
            }
        } else {
            if(__eax <= __ecx) {
L99:
                __eax = caml_ml_array_bound_error();
                while(1) {
L100:
                    __esp = __esp - 28;
                     *__esp = __eax;
                    __esp[1] = __ecx;
                    __esp[4] = __edx;
                    __esp[2] = __edi;
                    __eax = caml_extra_params;
                    __esp[3] = caml_extra_params;
                    __ebp =  *134694272;
                    __ecx =  *__esp;
                    __edx = __ecx + __ebx - 1;
                    __eax = __esp[4];
                    __esi = __esp[4] + __esi - 1;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 40;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __edi = __eax + 4;
                     *(__edi - 4) = 9463;
                     *__edi = caml_curry5;
                     *((intOrPtr*)(__edi + 4)) = 11;
                     *((intOrPtr*)(__edi + 8)) =  &camlArray__code_begin;
                    __eax =  *(__ebp + 12);
                     *(__edi + 12) =  *(__ebp + 12);
                    __eax =  *(__ebp + 16);
                     *(__edi + 16) =  *(__ebp + 16);
                    __ebx = __esp[1];
                     *(__edi + 20) = __ebx;
                    __eax = __esp[2];
                     *(__edi + 24) = __esp[2];
                     *(__edi + 28) = __edx;
                     *(__edi + 32) = __esi;
                    __eax =  *(__ebx - 4);
                    __eax = __eax & 255;
                    if((__eax & 255) == 254) {
                        if(__eax <= __esp[4]) {
                            goto L120;
                        } else {
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 12;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __edx = __eax + 4;
                             *(__edx - 4) = 2301;
                            __eax = __esp[4];
                            __fp0 =  *((long long*)(__ebx + __eax * 4 - 4));
                             *__edx =  *((long long*)(__ebx + __eax * 4 - 4));
                            goto L108;
                        }
                    } else {
                        if(__eax <= __esp[4]) {
L121:
                            __eax = caml_ml_array_bound_error();
                            while(1) {
L122:
                                __esp = __esp - 40;
                                __edi = 1;
                                __edx = __edx + -2;
                                if(1 > __edx) {
                                    break;
                                }
                                __esp[4] = __edx;
                                __esp[3] = 1;
                                __esp[6] = __esi;
                                __esp[5] = __ecx;
                                __esp[7] = __ebx;
                                 *__esp = __eax;
                                do {
                                    __eax =  *__esp;
                                    __eax =  *__esp + __edi - 1;
                                    __esp[1] = __eax;
                                    __ecx = __esp[6];
                                    __ecx =  *(__esp[6] + 16);
                                    __edx =  *(__ecx - 4);
                                    __esp[2] =  *(__ecx - 4);
                                    __esp[2] = __esp[2] & 255;
                                    if((__esp[2] & 255) == 254) {
                                        __esp[2] = __esp[2] >> 10;
                                        if(__esp[2] >> 10 <= __eax) {
                                            goto L171;
                                        } else {
                                            while(1) {
                                                __eax = caml_young_ptr;
                                                __eax = caml_young_ptr - 12;
                                                caml_young_ptr = __eax;
                                                if(__eax >= caml_young_limit) {
                                                    break;
                                                }
                                                __eax = caml_call_gc();
                                            }
                                            __edx = __eax + 4;
                                             *(__edx - 4) = 2301;
                                            __eax = __esp[1];
                                            __fp0 =  *((long long*)(__ecx + __eax * 4 - 4));
                                             *__edx =  *((long long*)(__ecx + __eax * 4 - 4));
                                            __esp[1] = __edx;
                                            goto L130;
                                        }
                                    } else {
                                        __esp[2] = __esp[2] >> 9;
                                        if(__esp[2] >> 9 <= __eax) {
L172:
                                            __eax = caml_ml_array_bound_error();
                                            __esp = __esp - 24;
                                            if(__edx > 11) {
                                                 *__esp = __esi;
                                                __esp[2] = __ecx;
                                                __esp[5] = __ebx;
                                                __esp[4] = __eax;
                                                __esi = __edx;
                                                __esi = __edx >> 1;
                                                if(__esi < 0) {
                                                    __esi = __esi + 1;
                                                }
                                                __esi = __esi >> 1;
                                                __esi = __esi + __esi + 1;
                                                __esp[1] = __esi;
                                                __edx = __edx - __esi;
                                                __esp[3] = __edx;
                                                __ecx = __ecx + __esi - 1;
                                                __eax = __eax + __esi - 1;
                                                __edx = __esp[3];
                                                __esi =  *__esp;
                                                L173();
                                                __ebx = __esp[3];
                                                __eax = __esp[4];
                                                __ecx = __esp[4] + __esp[3] - 1;
                                                __esi =  *__esp;
                                                __ebx =  *( *__esp + 12);
                                                __edx = __esp[1];
                                                L173();
                                                __eax =  *__esp;
                                                __eax =  *( *__esp + 16);
                                                 *__esp =  *( *__esp + 16);
                                                __ebx = __esp[1];
                                                __ebp = __esp[2];
                                                __edx = __ebp + __ebx - 1;
                                                __esi = __esp[3];
                                                __eax = __esp[4];
                                                __eax = __esp[4] + __esi - 1;
                                                __ecx = __esp[5];
                                                __edi = __ecx;
                                                caml_extra_params = __ebp;
                                                __ebp =  *__esp;
                                                 *134694272 =  *__esp;
                                                __esp =  &(__esp[6]);
                                                goto L100;
                                            } else {
                                                __esi =  *(__esi + 20);
                                                __esp =  &(__esp[6]);
                                                goto L122;
                                            }
                                        } else {
                                            __edx =  *(__ecx + __eax * 2 - 2);
                                            __esp[1] =  *(__ecx + __eax * 2 - 2);
                                            while(1) {
L130:
                                                __eax = caml_young_ptr;
                                                __eax = caml_young_ptr - 8;
                                                caml_young_ptr = __eax;
                                                if(__eax >= caml_young_limit) {
                                                    break;
                                                }
                                                __eax = caml_call_gc();
                                            }
                                            __esi = __eax + 4;
                                            __esp[2] = __esi;
                                             *(__esi - 4) = 1024;
                                            __eax = __esp[5];
                                            __eax = __esp[5] + __edi - 3;
                                             *__esi = __esp[5] + __edi - 3;
                                            while(1) {
                                                __ecx =  *__esi;
                                                __eax = __esp[5];
                                                if( *__esi < __esp[5]) {
                                                    break;
                                                }
                                                __ecx =  *__esi;
                                                __eax =  *(__ebx - 4);
                                                __eax = __eax & 255;
                                                if((__eax & 255) == 254) {
                                                    if(__eax <= __ecx) {
                                                        goto L169;
                                                    } else {
                                                        while(1) {
                                                            __eax = caml_young_ptr;
                                                            __eax = caml_young_ptr - 12;
                                                            caml_young_ptr = __eax;
                                                            if(__eax >= caml_young_limit) {
                                                                break;
                                                            }
                                                            __eax = caml_call_gc();
                                                        }
                                                        __eax = __eax + 4;
                                                         *(__eax - 4) = 2301;
                                                        __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                         *__eax =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                        goto L139;
                                                    }
                                                } else {
                                                    if(__eax <= __ecx) {
L170:
                                                        __eax = caml_ml_array_bound_error();
L171:
                                                        __eax = caml_ml_array_bound_error();
                                                        goto L172;
                                                    } else {
                                                        __eax =  *(__ebx + __ecx * 2 - 2);
L139:
                                                        __ebx = __esp[6];
                                                        __ecx =  *(__esp[6] + 12);
                                                        __ebx = __esp[1];
                                                        caml_apply2();
                                                        if(__eax <= 1) {
                                                            break;
                                                        } else {
                                                            __esi = __esp[2];
                                                            __ecx =  *__esi;
                                                            __ebx = __esp[7];
                                                            __eax =  *(__ebx - 4);
                                                            __eax = __eax & 255;
                                                            if((__eax & 255) == 254) {
                                                                if(__eax <= __ecx) {
                                                                    goto L167;
                                                                } else {
                                                                    while(1) {
                                                                        __eax = caml_young_ptr;
                                                                        __eax = caml_young_ptr - 12;
                                                                        caml_young_ptr = __eax;
                                                                        if(__eax >= caml_young_limit) {
                                                                            break;
                                                                        }
                                                                        __eax = caml_call_gc();
                                                                    }
                                                                    __edx = __eax + 4;
                                                                     *(__edx - 4) = 2301;
                                                                    __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                     *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                    goto L146;
                                                                }
                                                            } else {
                                                                if(__eax <= __ecx) {
L168:
                                                                    __eax = caml_ml_array_bound_error();
L169:
                                                                    __eax = caml_ml_array_bound_error();
                                                                    goto L170;
                                                                } else {
                                                                    __edx =  *(__ebx + __ecx * 2 - 2);
L146:
                                                                    __eax =  *__esi;
                                                                    __eax =  *__esi + 2;
                                                                    __ecx =  *(__ebx - 4);
                                                                    __edi = __ecx;
                                                                    __edi = __ecx & 255;
                                                                    if(__edi == 254) {
                                                                        if(__ecx <= __eax) {
L165:
                                                                            __eax = caml_ml_array_bound_error();
                                                                            goto L166;
                                                                        } else {
                                                                            __fp0 =  *__edx;
                                                                             *((long long*)(__ebx + __eax * 4 - 4)) =  *__edx;
                                                                            goto L151;
                                                                        }
                                                                    } else {
                                                                        if(__ecx <= __eax) {
L166:
                                                                            __eax = caml_ml_array_bound_error();
L167:
                                                                            __eax = caml_ml_array_bound_error();
                                                                            goto L168;
                                                                        } else {
                                                                            _push(__edx);
                                                                            _push(__eax);
                                                                            __eax = caml_modify(__ebx, __edi, __esi);
                                                                            __esp =  &(__esp[2]);
L151:
                                                                             *__esi =  *__esi + -2;
                                                                            continue;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                goto L215;
                                            }
                                            __esp[2] =  *(__esp[2]);
                                            __eax =  *(__esp[2]) + 2;
                                            __ebx = __esp[7];
                                            __ecx =  *(__ebx - 4);
                                            __ecx = __ecx & 255;
                                            if((__ecx & 255) == 254) {
                                                if(__ecx <= __eax) {
                                                    __eax = caml_ml_array_bound_error();
                                                    goto L164;
                                                } else {
                                                    __ecx = __esp[1];
                                                    __fp0 =  *(__esp[1]);
                                                     *((long long*)(__ebx + __eax * 4 - 4)) =  *(__esp[1]);
                                                    goto L157;
                                                }
                                            } else {
                                                if(__ecx <= __eax) {
L164:
                                                    __eax = caml_ml_array_bound_error();
                                                    goto L165;
                                                } else {
                                                    __ecx = __esp[1];
                                                    _push(__esp[1]);
                                                    _push(__eax);
                                                    __eax = caml_modify(__ebx, __edi, __esi);
                                                    __esp =  &(__esp[2]);
                                                    goto L157;
                                                }
                                            }
                                        }
                                    }
                                    goto L215;
L157:
                                    __edi = __esp[3];
                                    __ecx = __edi;
                                    __edi = __edi + 2;
                                    __esp[3] = __edi;
                                    __eax = __esp[4];
                                } while(__ecx != __esp[4]);
                                break;
                            }
                            __eax = 1;
                            __esp =  &(__esp[0xa]);
                            return 1;
                        } else {
                            __eax = __esp[4];
                            __edx =  *(__ebx + __esp[4] * 2 - 2);
L108:
                            __esi =  *(__ebp + 16);
                            __eax =  *(__esi - 4);
                            __ebx = __eax;
                            __ebx = __eax & 255;
                            if(__ebx == 254) {
                                if(__eax <= __ecx) {
                                    __eax = caml_ml_array_bound_error();
                                    goto L119;
                                } else {
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 12;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        __eax = caml_call_gc();
                                    }
                                    __ebx = __eax + 4;
                                     *(__ebx - 4) = 2301;
                                    __fp0 =  *((long long*)(__esi + __ecx * 4 - 4));
                                     *__ebx =  *((long long*)(__esi + __ecx * 4 - 4));
                                    goto L114;
                                }
                            } else {
                                if(__eax <= __ecx) {
L119:
                                    __eax = caml_ml_array_bound_error();
L120:
                                    __eax = caml_ml_array_bound_error();
                                    goto L121;
                                } else {
                                    __ebx =  *(__esi + __ecx * 2 - 2);
L114:
                                    __eax = __ecx;
                                    __ecx = __esp[4];
                                    __esi = __esp[3];
                                    __esp =  &(__esp[7]);
                                    __esp = __esp - 32;
                                    while(1) {
L6:
                                        __esp[1] = __eax;
                                        __eax = __ebx;
                                        __esp[5] = __eax;
                                        __esp[2] = __ecx;
                                        __esp[3] = __edx;
                                        __esp[4] = __esi;
                                         *__esp = __edi;
                                        __ecx =  *(__edi + 12);
                                        __ebx = __edx;
                                        caml_apply2();
                                        if(__eax > 1) {
                                            break;
                                        }
                                        __edi =  *__esp;
                                        __eax =  *(__edi + 24);
                                        __ebx =  *(__eax - 4);
                                        __ebx = __ebx & 255;
                                        if((__ebx & 255) == 254) {
                                            __ebx = __ebx >> 10;
                                            __esi = __esp[4];
                                            if(__ebx <= __esi) {
                                                goto L43;
                                            } else {
                                                __ebx = __esp[5];
                                                __fp0 =  *(__esp[5]);
                                                 *((long long*)(__eax + __esi * 4 - 4)) =  *(__esp[5]);
                                                goto L12;
                                            }
                                        } else {
                                            __ebx = __ebx >> 9;
                                            __esi = __esp[4];
                                            if(__ebx <= __esi) {
L44:
                                                __eax = caml_ml_array_bound_error();
                                                while(__ebx != 1) {
                                                    __ecx =  *(__ebx + 4);
                                                    __ebx =  *__ebx;
                                                    __ebx =  *(__ebx - 4);
                                                    __ebx = __ebx & 255;
                                                    if((__ebx & 255) == 254) {
                                                        __ebx = __ebx >> 10;
                                                    } else {
                                                        __ebx = __ebx >> 9;
                                                    }
                                                    __eax = __eax + __ebx;
                                                    __eax = __eax - 1;
                                                    __ebx = __ecx;
                                                }
                                                return __eax;
                                            } else {
                                                __ebx = __esp[5];
                                                _push(__ebx);
                                                _push(__eax);
                                                __eax = caml_modify(__ebx, __edi, __esi);
                                                __esp =  &(__esp[2]);
L12:
                                                __ecx = __esp[1];
                                                __ecx = __esp[1] + 2;
                                                __eax =  *(__edi + 28);
                                                if(__ecx >=  *(__edi + 28)) {
                                                    __ebp =  *(__edi + 32);
                                                    __ebx = __esp[2];
                                                     *(__edi + 32) - __ebx =  *(__edi + 32) - __ebx + 1;
                                                    __esi = __esi + 2;
                                                    __ecx =  *(__edi + 24);
                                                    __eax =  *(__edi + 20);
                                                    __edx = __esi;
                                                    __esi =  *(__edi + 32) - __ebx + 1;
                                                    __esp =  &(__esp[8]);
L178:
                                                    __esp = __esp - 24;
                                                    __edi = __eax;
                                                    __esp[2] = __ecx;
                                                    __ebp = __edx;
                                                    if(__esi < 1 || __ebx < 1) {
L212:
                                                        __eax = "Array.blit";
                                                        __esp =  &(__esp[6]);
L2:
                                                        _t351 = caml_young_ptr - 12;
                                                        caml_young_ptr = _t351;
                                                        if(_t351 >= caml_young_limit) {
                                                            _t353 = _t351 + 4;
                                                             *(_t353 - 4) = 2048;
                                                             *_t353 =  &caml_exn_Invalid_argument;
                                                            _t353[1] = __eax;
                                                            caml_raise_exn(_t353);
                                                        }
                                                        caml_call_gc();
                                                        goto L2;
                                                    }
                                                    __ecx =  *(__edi - 4);
                                                    __ecx = __ecx & 255;
                                                    if((__ecx & 255) == 254) {
                                                        __eax = __ecx;
                                                        __eax = __ecx >> 10;
                                                    } else {
                                                        __eax = __ecx;
                                                        __eax = __ecx >> 9;
                                                    }
                                                    __eax = __eax | 1;
                                                    __eax = __eax - __esi;
                                                    if(__ebx > __eax || __ebp < 1) {
                                                        goto L212;
                                                    }
                                                    __eax = __esp[2];
                                                    __ecx =  *(__esp[2] - 4);
                                                    __ecx = __ecx & 255;
                                                    if((__ecx & 255) == 254) {
                                                        __eax = __ecx;
                                                        __eax = __ecx >> 10;
                                                    } else {
                                                        __eax = __ecx;
                                                        __eax = __ecx >> 9;
                                                    }
                                                    __eax = __eax | 1;
                                                    __eax = __eax - __esi;
                                                    if(__ebp > __eax) {
                                                        goto L212;
                                                    }
                                                    if(__ebx >= __ebp) {
                                                        __eax = 1;
                                                        __esp[3] = 1;
                                                        __esi = __esi + -2;
                                                        if(__esp[3] <= __esi) {
                                                            __esp[1] = __ebx;
                                                             *__esp = __edi;
                                                            do {
                                                                __ebx = __esp[1];
                                                                __eax = __esp[3];
                                                                __ebx = __esp[1] + __esp[3] - 1;
                                                                __eax =  *__esp;
                                                                __ecx =  *(__eax - 4) & 255;
                                                                if(( *(__eax - 4) & 255) == 254) {
                                                                    while(1) {
                                                                        __eax = caml_young_ptr;
                                                                        __eax = caml_young_ptr - 12;
                                                                        caml_young_ptr = __eax;
                                                                        if(__eax >= caml_young_limit) {
                                                                            break;
                                                                        }
                                                                        __eax = caml_call_gc();
                                                                    }
                                                                    __ecx = __eax + 4;
                                                                     *(__ecx - 4) = 2301;
                                                                    __eax =  *__esp;
                                                                    __fp0 =  *((long long*)(__eax + __ebx * 4 - 4));
                                                                     *__ecx =  *((long long*)(__eax + __ebx * 4 - 4));
                                                                    __ebx = __ecx;
                                                                } else {
                                                                    __ebx =  *(__eax + __ebx * 2 - 2);
                                                                }
                                                                __ecx = __esp[3];
                                                                __eax = __ebp;
                                                                __eax = __ebp + __esp[3] - 1;
                                                                __ecx = __esp[2];
                                                                __ecx =  *(__esp[2] - 4) & 255;
                                                                if(( *(__esp[2] - 4) & 255) == 254) {
                                                                    __fp0 =  *__ebx;
                                                                    __ebx = __esp[2];
                                                                     *((long long*)(__esp[2] + __eax * 4 - 4)) = __fp0;
                                                                } else {
                                                                    _push(__ebx);
                                                                    __ebx = __esp[3];
                                                                    _push(__eax);
                                                                    __eax = caml_modify(__ebx, __edi, __esi);
                                                                    __esp =  &(__esp[2]);
                                                                }
                                                                __ebx = __esp[3];
                                                                __esp[3] = __esp[3] + 2;
                                                                __esp[3] = __esp[3] + 2;
                                                            } while(__esp[3] != __esi);
                                                        }
                                                        __eax = 1;
                                                        __esp =  &(__esp[6]);
                                                        return 1;
                                                    } else {
                                                        __esi = __esi + -2;
                                                        if(__esi >= 1) {
                                                            __esp[1] = __ebx;
                                                            do {
                                                                __eax = __esp[1];
                                                                __ebx = __esp[1] + __esi - 1;
                                                                __eax =  *(__edi - 4) & 255;
                                                                if(( *(__edi - 4) & 255) == 254) {
                                                                    while(1) {
                                                                        __eax = caml_young_ptr;
                                                                        __eax = caml_young_ptr - 12;
                                                                        caml_young_ptr = __eax;
                                                                        if(__eax >= caml_young_limit) {
                                                                            break;
                                                                        }
                                                                        __eax = caml_call_gc();
                                                                    }
                                                                    __eax = __eax + 4;
                                                                     *(__eax - 4) = 2301;
                                                                    __fp0 =  *((long long*)(__edi + __ebx * 4 - 4));
                                                                     *__eax =  *((long long*)(__edi + __ebx * 4 - 4));
                                                                    __ebx = __eax;
                                                                } else {
                                                                    __ebx =  *(__edi + __ebx * 2 - 2);
                                                                }
                                                                __eax = __ebp;
                                                                __eax = __ebp + __esi - 1;
                                                                __ecx = __esp[2];
                                                                __ecx =  *(__esp[2] - 4) & 255;
                                                                if(( *(__esp[2] - 4) & 255) == 254) {
                                                                    __fp0 =  *__ebx;
                                                                    __ebx = __esp[2];
                                                                     *((long long*)(__esp[2] + __eax * 4 - 4)) = __fp0;
                                                                } else {
                                                                    _push(__ebx);
                                                                    __ebx = __esp[3];
                                                                    _push(__eax);
                                                                    __eax = caml_modify(__ebx, __edi, __esi);
                                                                    __esp =  &(__esp[2]);
                                                                }
                                                                __ebx = __esi;
                                                                __esi = __esi - 2;
                                                                __esi = __esi - 2;
                                                            } while(__ebx != 1);
                                                        }
                                                        __eax = 1;
                                                        __esp =  &(__esp[6]);
                                                        return 1;
                                                    }
                                                } else {
                                                    __ebx =  *(__edi + 16);
                                                    __edx =  *(__ebx - 4);
                                                    __edx = __edx & 255;
                                                    if((__edx & 255) == 254) {
                                                        if(__edx >> 10 <= __ecx) {
L41:
                                                            __eax = caml_ml_array_bound_error();
                                                            goto L42;
                                                        } else {
                                                            while(1) {
                                                                __eax = caml_young_ptr;
                                                                __eax = caml_young_ptr - 12;
                                                                caml_young_ptr = __eax;
                                                                if(__eax >= caml_young_limit) {
                                                                    break;
                                                                }
                                                                __eax = caml_call_gc();
                                                            }
                                                            __edx = __eax + 4;
                                                             *(__edx - 4) = 2301;
                                                            __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                             *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                            __ebx = __edx;
                                                            goto L19;
                                                        }
                                                    } else {
                                                        if(__edx >> 9 <= __ecx) {
L42:
                                                            __eax = caml_ml_array_bound_error();
L43:
                                                            __eax = caml_ml_array_bound_error();
                                                            goto L44;
                                                        } else {
                                                            __ebx =  *(__ebx + __ecx * 2 - 2);
L19:
                                                            __esi = __esi + 2;
                                                            __eax = __ecx;
                                                            __ecx = __esp[2];
                                                            __edx = __esp[3];
                                                            continue;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        goto L215;
                                    }
                                    __edi =  *__esp;
                                    __eax =  *(__edi + 24);
                                    __ebx =  *(__eax - 4);
                                    __ebx = __ebx & 255;
                                    if((__ebx & 255) == 254) {
                                        __ebx = __ebx >> 10;
                                        __esi = __esp[4];
                                        if(__ebx <= __esi) {
                                            goto L39;
                                        } else {
                                            __ebx = __esp[3];
                                            __fp0 =  *(__esp[3]);
                                             *((long long*)(__eax + __esi * 4 - 4)) =  *(__esp[3]);
                                            goto L26;
                                        }
                                    } else {
                                        __ebx = __ebx >> 9;
                                        __esi = __esp[4];
                                        if(__ebx <= __esi) {
L40:
                                            __eax = caml_ml_array_bound_error();
                                            goto L41;
                                        } else {
                                            __ebx = __esp[3];
                                            _push(__ebx);
                                            _push(__eax);
                                            __eax = caml_modify(__ebx, __edi, __esi);
                                            __esp =  &(__esp[2]);
L26:
                                            __ecx = __esp[2];
                                            __ecx = __esp[2] + 2;
                                            __eax =  *(__edi + 32);
                                            if(__ecx >=  *(__edi + 32)) {
                                                __ebp =  *(__edi + 28);
                                                __ebx = __esp[1];
                                                 *(__edi + 28) - __ebx =  *(__edi + 28) - __ebx + 1;
                                                __esi = __esi + 2;
                                                __ecx =  *(__edi + 24);
                                                __eax =  *(__edi + 16);
                                                __edx = __esi;
                                                __esi =  *(__edi + 28) - __ebx + 1;
                                                __esp =  &(__esp[8]);
                                                goto L178;
                                            } else {
                                                __ebx =  *(__edi + 20);
                                                __edx =  *(__ebx - 4);
                                                __edx = __edx & 255;
                                                if((__edx & 255) == 254) {
                                                    if(__edx >> 10 <= __ecx) {
                                                        __eax = caml_ml_array_bound_error();
                                                        goto L38;
                                                    } else {
                                                        while(1) {
                                                            __eax = caml_young_ptr;
                                                            __eax = caml_young_ptr - 12;
                                                            caml_young_ptr = __eax;
                                                            if(__eax >= caml_young_limit) {
                                                                break;
                                                            }
                                                            __eax = caml_call_gc();
                                                        }
                                                        __edx = __eax + 4;
                                                         *(__edx - 4) = 2301;
                                                        __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                         *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                        goto L33;
                                                    }
                                                } else {
                                                    if(__edx >> 9 <= __ecx) {
L38:
                                                        __eax = caml_ml_array_bound_error();
L39:
                                                        __eax = caml_ml_array_bound_error();
                                                        goto L40;
                                                    } else {
                                                        __edx =  *(__ebx + __ecx * 2 - 2);
L33:
                                                        __esi = __esi + 2;
                                                        __eax = __esp[1];
                                                        __ebx = __esp[5];
                                                        goto L6;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    goto L215;
                }
            } else {
                __eax =  *(__edx + __ecx * 2 - 2);
L61:
                __ecx =  *(__edi + 12);
                caml_apply2();
                if(__eax >= 1) {
                    __eax =  *__esp;
                    __eax =  *( *__esp + 16);
                    __ebx =  *(__eax - 4);
                    __ebx = __ebx & 255;
                    if((__ebx & 255) == 254) {
                        __ebx = __ebx >> 10;
                        __ecx = __esp[2];
                        if(__ebx <= __ecx) {
                            __eax = caml_ml_array_bound_error();
                            goto L91;
                        } else {
                            __ebx = __esp[1];
                            __fp0 =  *(__esp[1]);
                             *((long long*)(__eax + __ecx * 4 - 4)) =  *(__esp[1]);
                            goto L86;
                        }
                    } else {
                        __ebx = __ebx >> 9;
                        __ecx = __esp[2];
                        if(__ebx <= __ecx) {
L91:
                            __eax = caml_ml_array_bound_error();
                            goto L92;
                        } else {
                            __ebx = __esp[1];
                            _push(__ebx);
                            _push(__eax);
                            __eax = caml_modify(__ebx, __edi, __esi);
                            __esp =  &(__esp[2]);
L86:
                            __eax = 1;
                            __esp =  &(__esp[6]);
                            return 1;
                        }
                    }
                } else {
                    __edi =  *__esp;
                    __ebx =  *(__edi + 16);
                    __eax =  *(__ebx - 4);
                    __eax = __eax & 255;
                    if((__eax & 255) == 254) {
                        __eax = __eax >> 10;
                        __esi = __esp[3];
                        if(__eax <= __esi) {
                            goto L96;
                        } else {
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 12;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __ecx = __eax + 4;
                             *(__ecx - 4) = 2301;
                            __fp0 =  *((long long*)(__ebx + __esi * 4 - 4));
                             *__ecx =  *((long long*)(__ebx + __esi * 4 - 4));
                            goto L68;
                        }
                    } else {
                        __eax = __eax >> 9;
                        __esi = __esp[3];
                        if(__eax <= __esi) {
L97:
                            __eax = caml_ml_array_bound_error();
L98:
                            __eax = caml_ml_array_bound_error();
                            goto L99;
                        } else {
                            __ecx =  *(__ebx + __esi * 2 - 2);
L68:
                            __eax =  *(__edi + 16);
                            __edx =  *(__eax - 4);
                            __edx = __edx & 255;
                            if((__edx & 255) == 254) {
                                __edx = __edx >> 10;
                                __ebx = __esp[2];
                                if(__edx <= __ebx) {
                                    goto L94;
                                } else {
                                    __fp0 =  *__ecx;
                                     *((long long*)(__eax + __ebx * 4 - 4)) =  *__ecx;
                                    goto L73;
                                }
                            } else {
                                __edx = __edx >> 9;
                                __ebx = __esp[2];
                                if(__edx <= __ebx) {
L95:
                                    __eax = caml_ml_array_bound_error();
L96:
                                    __eax = caml_ml_array_bound_error();
                                    goto L97;
                                } else {
                                    _push(__ecx);
                                    _push(__eax);
                                    __eax = caml_modify(__ebx, __edi, __esi);
                                    __esp =  &(__esp[2]);
L73:
                                    if(__esi <= 1) {
                                        __ecx =  *(__edi + 16);
                                        __ebx =  *(__ecx - 4);
                                        __ebx = __ebx & 255;
                                        if((__ebx & 255) == 254) {
                                            __ebx = __ebx >> 10;
                                            if(__ebx >> 10 <= 1) {
L92:
                                                __eax = caml_ml_array_bound_error();
                                                goto L93;
                                            } else {
                                                __eax = __esp[1];
                                                __fp0 =  *(__esp[1]);
                                                 *__ecx =  *(__esp[1]);
                                                goto L80;
                                            }
                                        } else {
                                            __ebx = __ebx >> 9;
                                            if(__ebx >> 9 <= 1) {
L93:
                                                __eax = caml_ml_array_bound_error();
L94:
                                                __eax = caml_ml_array_bound_error();
                                                goto L95;
                                            } else {
                                                __esp[1] = caml_modify(__ebx, __edi, __esi, __ecx, __esp[1]);
L80:
                                                __eax = 1;
                                                __esp =  &(__esp[6]);
                                                return 1;
                                            }
                                        }
                                    } else {
                                        __eax = __esi;
                                        __ebx = __esp[1];
                                        __ecx = __edi;
                                        continue;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
L215:
        while(1) {
L53:
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 12;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __eax = __eax + 4;
         *(__eax - 4) = 2048;
         *__eax =  &caml_exn_Assert_failure;
         *(__eax + 4) =  &camlArray__35;
        __eax = caml_raise_exn(__eax);
        goto L55;
    }
}

camlArray__merge_1191(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx,                       // r2
    _unknown_ __edx,                       // r3
    _unknown_ __edi,                       // r4
    _unknown_ __esi                        // r5
)
{// addr = 0x08051170
    _unknown_ _t289;                       // _t289
    _unknown_ _t291;                       // _t291
    _unknown_ _t293;                       // _t293
    _unknown_ _t296;                       // _t296


}

signed int camlArray__isortto_1209(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx,                      // r2
    _unknown_ __edx,                       // r3
    unsigned int __esi                     // r5
)
{// addr = 0x08051300
    signed int _t290;                      // _t290
    intOrPtr* _t292;                       // _t292

L0:
    while(1) {
L0:
        __esi = __esi;
        __ecx = __ecx;
        __esp = __esp - 40;
        __edi = 1;
        if(1 > __edx + -2) {
            break;
        }
L73:
        __esp[4] = __edx;
        __esp[3] = 1;
        __esp[6] = __esi;
        __esp[5] = __ecx;
        __esp[7] = __ebx;
         *__esp = __eax;
        do {
L74:
            __eax =  *__esp;
            __eax =  *__esp + __edi - 1;
            __esp[1] = __eax;
            __ecx = __esp[6];
            __ecx =  *(__esp[6] + 16);
            __edx =  *(__ecx - 4);
            __esp[2] =  *(__ecx - 4);
            __esp[2] = __esp[2] & 255;
            if((__esp[2] & 255) == 254) {
L77:
                __esp[2] = __esp[2] >> 10;
                if(__esp[2] >> 10 <= __eax) {
                    goto L121;
                } else {
                    while(1) {
L78:
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
L112:
                        __eax = caml_call_gc();
                    }
L79:
                    __edx = __eax + 4;
                     *(__edx - 4) = 2301;
                    __eax = __esp[1];
                    __fp0 =  *((long long*)(__ecx + __eax * 4 - 4));
                     *__edx =  *((long long*)(__ecx + __eax * 4 - 4));
                    __esp[1] = __edx;
                    goto L80;
                }
            } else {
L75:
                __esp[2] = __esp[2] >> 9;
                if(__esp[2] >> 9 <= __eax) {
L122:
                    __eax = caml_ml_array_bound_error();
                    __esp = __esp - 24;
                    if(__edx > 11) {
L125:
                         *__esp = __esi;
                        __esp[2] = __ecx;
                        __esp[5] = __ebx;
                        __esp[4] = __eax;
                        __esi = __edx;
                        __esi = __edx >> 1;
                        if(__esi < 0) {
                            __esi = __esi + 1;
                        }
                        __esi = __esi >> 1;
                        __esi = __esi + __esi + 1;
                        __esp[1] = __esi;
                        __edx = __edx - __esi;
                        __esp[3] = __edx;
                        __ecx = __ecx + __esi - 1;
                        __eax = __eax + __esi - 1;
                        __edx = __esp[3];
                        __esi =  *__esp;
                        L123();
                        __ebx = __esp[3];
                        __eax = __esp[4];
                        __ecx = __esp[4] + __esp[3] - 1;
                        __esi =  *__esp;
                        __ebx =  *( *__esp + 12);
                        __edx = __esp[1];
                        L123();
                        __eax =  *__esp;
                        __eax =  *( *__esp + 16);
                         *__esp =  *( *__esp + 16);
                        __ebx = __esp[1];
                        __ebp = __esp[2];
                        __edx = __ebp + __ebx - 1;
                        __esi = __esp[3];
                        __eax = __esp[4];
                        __eax = __esp[4] + __esi - 1;
                        __ecx = __esp[5];
                        __edi = __ecx;
                        caml_extra_params = __ebp;
                        __ebp =  *__esp;
                         *134694272 =  *__esp;
                        __esp =  &(__esp[6]);
                        __esp = __esp - 28;
                         *__esp = __eax;
                        __esp[1] = __ecx;
                        __esp[4] = __edx;
                        __esp[2] = __edi;
                        __eax = caml_extra_params;
                        __esp[3] = caml_extra_params;
                        __ebp =  *134694272;
                        __ecx =  *__esp;
                        __edx = __ecx + __ebx - 1;
                        __eax = __esp[4];
                        __esi = __esp[4] + __esi - 1;
                        while(1) {
L52:
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 40;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
L68:
                            __eax = caml_call_gc();
                        }
L53:
                        __edi = __eax + 4;
                         *(__edi - 4) = 9463;
                         *__edi = caml_curry5;
                         *((intOrPtr*)(__edi + 4)) = 11;
                         *((intOrPtr*)(__edi + 8)) =  &camlArray__code_begin;
                        __eax =  *(__ebp + 12);
                         *(__edi + 12) =  *(__ebp + 12);
                        __eax =  *(__ebp + 16);
                         *(__edi + 16) =  *(__ebp + 16);
                        __ebx = __esp[1];
                         *(__edi + 20) = __ebx;
                        __eax = __esp[2];
                         *(__edi + 24) = __esp[2];
                         *(__edi + 28) = __edx;
                         *(__edi + 32) = __esi;
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
L56:
                            if(__eax <= __esp[4]) {
                                goto L71;
                            } else {
                                while(1) {
L57:
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
L67:
                                    __eax = caml_call_gc();
                                }
L58:
                                __edx = __eax + 4;
                                 *(__edx - 4) = 2301;
                                __eax = __esp[4];
                                __fp0 =  *((long long*)(__ebx + __eax * 4 - 4));
                                 *__edx =  *((long long*)(__ebx + __eax * 4 - 4));
                                goto L59;
                            }
                        } else {
L54:
                            if(__eax <= __esp[4]) {
L72:
                                __eax = caml_ml_array_bound_error();
                                goto L0;
                            } else {
L55:
                                __eax = __esp[4];
                                __edx =  *(__ebx + __esp[4] * 2 - 2);
L59:
                                __esi =  *(__ebp + 16);
                                __eax =  *(__esi - 4);
                                __ebx = __eax;
                                __ebx = __eax & 255;
                                if(__ebx == 254) {
L62:
                                    if(__eax <= __ecx) {
L69:
                                        __eax = caml_ml_array_bound_error();
                                        goto L70;
                                    } else {
                                        while(1) {
L63:
                                            __eax = caml_young_ptr;
                                            __eax = caml_young_ptr - 12;
                                            caml_young_ptr = __eax;
                                            if(__eax >= caml_young_limit) {
                                                break;
                                            }
L66:
                                            __eax = caml_call_gc();
                                        }
L64:
                                        __ebx = __eax + 4;
                                         *(__ebx - 4) = 2301;
                                        __fp0 =  *((long long*)(__esi + __ecx * 4 - 4));
                                         *__ebx =  *((long long*)(__esi + __ecx * 4 - 4));
                                        goto L65;
                                    }
                                } else {
L60:
                                    if(__eax <= __ecx) {
L70:
                                        __eax = caml_ml_array_bound_error();
L71:
                                        __eax = caml_ml_array_bound_error();
                                        goto L72;
                                    } else {
L61:
                                        __ebx =  *(__esi + __ecx * 2 - 2);
L65:
                                        __eax = __ecx;
                                        __ecx = __esp[4];
                                        __esi = __esp[3];
                                        __esp =  &(__esp[7]);
                                        __esp = __esp - 32;
                                        while(1) {
L6:
                                            __esp[1] = __eax;
                                            __eax = __ebx;
                                            __esp[5] = __eax;
                                            __esp[2] = __ecx;
                                            __esp[3] = __edx;
                                            __esp[4] = __esi;
                                             *__esp = __edi;
                                            __ecx =  *(__edi + 12);
                                            __ebx = __edx;
                                            caml_apply2();
                                            if(__eax > 1) {
                                                break;
                                            }
L7:
                                            __edi =  *__esp;
                                            __eax =  *(__edi + 24);
                                            __ebx =  *(__eax - 4);
                                            __ebx = __ebx & 255;
                                            if((__ebx & 255) == 254) {
L10:
                                                __ebx = __ebx >> 10;
                                                __esi = __esp[4];
                                                if(__ebx <= __esi) {
                                                    goto L43;
                                                } else {
L11:
                                                    __ebx = __esp[5];
                                                    __fp0 =  *(__esp[5]);
                                                     *((long long*)(__eax + __esi * 4 - 4)) =  *(__esp[5]);
                                                    goto L12;
                                                }
                                            } else {
L8:
                                                __ebx = __ebx >> 9;
                                                __esi = __esp[4];
                                                if(__ebx <= __esi) {
L44:
                                                    __eax = caml_ml_array_bound_error();
L45:
                                                    while(__ebx != 1) {
                                                        __ecx =  *(__ebx + 4);
                                                        __ebx =  *__ebx;
                                                        __ebx =  *(__ebx - 4);
                                                        __ebx = __ebx & 255;
                                                        if((__ebx & 255) == 254) {
                                                            __ebx = __ebx >> 10;
                                                        } else {
                                                            __ebx = __ebx >> 9;
                                                        }
                                                        __eax = __eax + __ebx;
                                                        __eax = __eax - 1;
                                                        __ebx = __ecx;
                                                    }
                                                    return __eax;
                                                } else {
L9:
                                                    __ebx = __esp[5];
                                                    _push(__ebx);
                                                    _push(__eax);
                                                    __eax = caml_modify(__ebx, __edi, __esi);
                                                    __esp =  &(__esp[2]);
L12:
                                                    __ecx = __esp[1];
                                                    __ecx = __esp[1] + 2;
                                                    __eax =  *(__edi + 28);
                                                    if(__ecx >=  *(__edi + 28)) {
L20:
                                                        __ebp =  *(__edi + 32);
                                                        __ebx = __esp[2];
                                                         *(__edi + 32) - __ebx =  *(__edi + 32) - __ebx + 1;
                                                        __esi = __esi + 2;
                                                        __ecx =  *(__edi + 24);
                                                        __eax =  *(__edi + 20);
                                                        __edx = __esi;
                                                        __esi =  *(__edi + 32) - __ebx + 1;
                                                        __esp =  &(__esp[8]);
L128:
                                                        __esp = __esp - 24;
                                                        __edi = __eax;
                                                        __esp[2] = __ecx;
                                                        __ebp = __edx;
                                                        if(__esi < 1 || __ebx < 1) {
L162:
                                                            __eax = "Array.blit";
                                                            __esp =  &(__esp[6]);
L1:
L2:
                                                            _t290 = caml_young_ptr - 12;
                                                            caml_young_ptr = _t290;
                                                            if(_t290 >= caml_young_limit) {
                                                                _t292 = _t290 + 4;
                                                                 *((intOrPtr*)(_t292 - 4)) = 2048;
                                                                 *_t292 =  &caml_exn_Invalid_argument;
                                                                _t292[1] = __eax;
                                                                caml_raise_exn(_t292);
                                                            }
                                                            caml_call_gc();
                                                            goto L2;
                                                        }
L130:
                                                        __ecx =  *(__edi - 4);
                                                        __ecx = __ecx & 255;
                                                        if((__ecx & 255) == 254) {
                                                            __eax = __ecx;
                                                            __eax = __ecx >> 10;
                                                        } else {
                                                            __eax = __ecx;
                                                            __eax = __ecx >> 9;
                                                        }
                                                        __eax = __eax | 1;
                                                        __eax = __eax - __esi;
                                                        if(__ebx > __eax || __ebp < 1) {
                                                            goto L162;
                                                        }
L135:
                                                        __eax = __esp[2];
                                                        __ecx =  *(__esp[2] - 4);
                                                        __ecx = __ecx & 255;
                                                        if((__ecx & 255) == 254) {
                                                            __eax = __ecx;
                                                            __eax = __ecx >> 10;
                                                        } else {
                                                            __eax = __ecx;
                                                            __eax = __ecx >> 9;
                                                        }
                                                        __eax = __eax | 1;
                                                        __eax = __eax - __esi;
                                                        if(__ebp > __eax) {
                                                            goto L162;
                                                        }
L139:
                                                        if(__ebx >= __ebp) {
L151:
                                                            __eax = 1;
                                                            __esp[3] = 1;
                                                            __esi = __esi + -2;
                                                            if(__esp[3] <= __esi) {
L152:
                                                                __esp[1] = __ebx;
                                                                 *__esp = __edi;
                                                                do {
L153:
                                                                    __ebx = __esp[1];
                                                                    __eax = __esp[3];
                                                                    __ebx = __esp[1] + __esp[3] - 1;
                                                                    __eax =  *__esp;
                                                                    __ecx =  *(__eax - 4) & 255;
                                                                    if(( *(__eax - 4) & 255) == 254) {
                                                                        while(1) {
L155:
                                                                            __eax = caml_young_ptr;
                                                                            __eax = caml_young_ptr - 12;
                                                                            caml_young_ptr = __eax;
                                                                            if(__eax >= caml_young_limit) {
                                                                                break;
                                                                            }
L163:
                                                                            __eax = caml_call_gc();
                                                                        }
L156:
                                                                        __ecx = __eax + 4;
                                                                         *(__ecx - 4) = 2301;
                                                                        __eax =  *__esp;
                                                                        __fp0 =  *((long long*)(__eax + __ebx * 4 - 4));
                                                                         *__ecx =  *((long long*)(__eax + __ebx * 4 - 4));
                                                                        __ebx = __ecx;
                                                                    } else {
L154:
                                                                        __ebx =  *(__eax + __ebx * 2 - 2);
                                                                    }
L157:
                                                                    __ecx = __esp[3];
                                                                    __eax = __ebp;
                                                                    __eax = __ebp + __esp[3] - 1;
                                                                    __ecx = __esp[2];
                                                                    __ecx =  *(__esp[2] - 4) & 255;
                                                                    if(( *(__esp[2] - 4) & 255) == 254) {
                                                                        __fp0 =  *__ebx;
                                                                        __ebx = __esp[2];
                                                                         *((long long*)(__esp[2] + __eax * 4 - 4)) = __fp0;
                                                                    } else {
                                                                        _push(__ebx);
                                                                        __ebx = __esp[3];
                                                                        _push(__eax);
                                                                        __eax = caml_modify(__ebx, __edi, __esi);
                                                                        __esp =  &(__esp[2]);
                                                                    }
L160:
                                                                    __ebx = __esp[3];
                                                                    __esp[3] = __esp[3] + 2;
                                                                    __esp[3] = __esp[3] + 2;
                                                                } while(__esp[3] != __esi);
                                                            }
L161:
                                                            __eax = 1;
                                                            __esp =  &(__esp[6]);
                                                            return 1;
                                                        } else {
L140:
                                                            __esi = __esi + -2;
                                                            if(__esi >= 1) {
L141:
                                                                __esp[1] = __ebx;
                                                                do {
L142:
                                                                    __eax = __esp[1];
                                                                    __ebx = __esp[1] + __esi - 1;
                                                                    __eax =  *(__edi - 4) & 255;
                                                                    if(( *(__edi - 4) & 255) == 254) {
                                                                        while(1) {
L144:
                                                                            __eax = caml_young_ptr;
                                                                            __eax = caml_young_ptr - 12;
                                                                            caml_young_ptr = __eax;
                                                                            if(__eax >= caml_young_limit) {
                                                                                break;
                                                                            }
L164:
                                                                            __eax = caml_call_gc();
                                                                        }
L145:
                                                                        __eax = __eax + 4;
                                                                         *(__eax - 4) = 2301;
                                                                        __fp0 =  *((long long*)(__edi + __ebx * 4 - 4));
                                                                         *__eax =  *((long long*)(__edi + __ebx * 4 - 4));
                                                                        __ebx = __eax;
                                                                    } else {
L143:
                                                                        __ebx =  *(__edi + __ebx * 2 - 2);
                                                                    }
L146:
                                                                    __eax = __ebp;
                                                                    __eax = __ebp + __esi - 1;
                                                                    __ecx = __esp[2];
                                                                    __ecx =  *(__esp[2] - 4) & 255;
                                                                    if(( *(__esp[2] - 4) & 255) == 254) {
                                                                        __fp0 =  *__ebx;
                                                                        __ebx = __esp[2];
                                                                         *((long long*)(__esp[2] + __eax * 4 - 4)) = __fp0;
                                                                    } else {
                                                                        _push(__ebx);
                                                                        __ebx = __esp[3];
                                                                        _push(__eax);
                                                                        __eax = caml_modify(__ebx, __edi, __esi);
                                                                        __esp =  &(__esp[2]);
                                                                    }
                                                                    __ebx = __esi;
                                                                    __esi = __esi - 2;
                                                                    __esi = __esi - 2;
                                                                } while(__ebx != 1);
                                                            }
L150:
                                                            __eax = 1;
                                                            __esp =  &(__esp[6]);
                                                            return 1;
                                                        }
                                                    } else {
L13:
                                                        __ebx =  *(__edi + 16);
                                                        __edx =  *(__ebx - 4);
                                                        __edx = __edx & 255;
                                                        if((__edx & 255) == 254) {
L16:
                                                            if(__edx >> 10 <= __ecx) {
L41:
                                                                __eax = caml_ml_array_bound_error();
                                                                goto L42;
                                                            } else {
                                                                while(1) {
L17:
                                                                    __eax = caml_young_ptr;
                                                                    __eax = caml_young_ptr - 12;
                                                                    caml_young_ptr = __eax;
                                                                    if(__eax >= caml_young_limit) {
                                                                        break;
                                                                    }
L36:
                                                                    __eax = caml_call_gc();
                                                                }
L18:
                                                                __edx = __eax + 4;
                                                                 *(__edx - 4) = 2301;
                                                                __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                 *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                __ebx = __edx;
                                                                goto L19;
                                                            }
                                                        } else {
L14:
                                                            if(__edx >> 9 <= __ecx) {
L42:
                                                                __eax = caml_ml_array_bound_error();
L43:
                                                                __eax = caml_ml_array_bound_error();
                                                                goto L44;
                                                            } else {
L15:
                                                                __ebx =  *(__ebx + __ecx * 2 - 2);
L19:
                                                                __esi = __esi + 2;
                                                                __eax = __ecx;
                                                                __ecx = __esp[2];
                                                                __edx = __esp[3];
                                                                continue;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            goto L165;
                                        }
L21:
                                        __edi =  *__esp;
                                        __eax =  *(__edi + 24);
                                        __ebx =  *(__eax - 4);
                                        __ebx = __ebx & 255;
                                        if((__ebx & 255) == 254) {
L24:
                                            __ebx = __ebx >> 10;
                                            __esi = __esp[4];
                                            if(__ebx <= __esi) {
                                                goto L39;
                                            } else {
L25:
                                                __ebx = __esp[3];
                                                __fp0 =  *(__esp[3]);
                                                 *((long long*)(__eax + __esi * 4 - 4)) =  *(__esp[3]);
                                                goto L26;
                                            }
                                        } else {
L22:
                                            __ebx = __ebx >> 9;
                                            __esi = __esp[4];
                                            if(__ebx <= __esi) {
L40:
                                                __eax = caml_ml_array_bound_error();
                                                goto L41;
                                            } else {
L23:
                                                __ebx = __esp[3];
                                                _push(__ebx);
                                                _push(__eax);
                                                __eax = caml_modify(__ebx, __edi, __esi);
                                                __esp =  &(__esp[2]);
L26:
                                                __ecx = __esp[2];
                                                __ecx = __esp[2] + 2;
                                                __eax =  *(__edi + 32);
                                                if(__ecx >=  *(__edi + 32)) {
L34:
                                                    __ebp =  *(__edi + 28);
                                                    __ebx = __esp[1];
                                                     *(__edi + 28) - __ebx =  *(__edi + 28) - __ebx + 1;
                                                    __esi = __esi + 2;
                                                    __ecx =  *(__edi + 24);
                                                    __eax =  *(__edi + 16);
                                                    __edx = __esi;
                                                    __esi =  *(__edi + 28) - __ebx + 1;
                                                    __esp =  &(__esp[8]);
                                                    goto L128;
                                                } else {
L27:
                                                    __ebx =  *(__edi + 20);
                                                    __edx =  *(__ebx - 4);
                                                    __edx = __edx & 255;
                                                    if((__edx & 255) == 254) {
L30:
                                                        if(__edx >> 10 <= __ecx) {
L37:
                                                            __eax = caml_ml_array_bound_error();
                                                            goto L38;
                                                        } else {
                                                            while(1) {
L31:
                                                                __eax = caml_young_ptr;
                                                                __eax = caml_young_ptr - 12;
                                                                caml_young_ptr = __eax;
                                                                if(__eax >= caml_young_limit) {
                                                                    break;
                                                                }
L35:
                                                                __eax = caml_call_gc();
                                                            }
L32:
                                                            __edx = __eax + 4;
                                                             *(__edx - 4) = 2301;
                                                            __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                             *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                            goto L33;
                                                        }
                                                    } else {
L28:
                                                        if(__edx >> 9 <= __ecx) {
L38:
                                                            __eax = caml_ml_array_bound_error();
L39:
                                                            __eax = caml_ml_array_bound_error();
                                                            goto L40;
                                                        } else {
L29:
                                                            __edx =  *(__ebx + __ecx * 2 - 2);
L33:
                                                            __esi = __esi + 2;
                                                            __eax = __esp[1];
                                                            __ebx = __esp[5];
                                                            goto L6;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
L124:
                        __esi =  *(__esi + 20);
                        __esp =  &(__esp[6]);
                        goto L0;
                    }
                } else {
L76:
                    __edx =  *(__ecx + __eax * 2 - 2);
                    __esp[1] =  *(__ecx + __eax * 2 - 2);
                    while(1) {
L80:
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 8;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
L111:
                        __eax = caml_call_gc();
                    }
L81:
                    __esi = __eax + 4;
                    __esp[2] = __esi;
                     *(__esi - 4) = 1024;
                    __eax = __esp[5];
                    __eax = __esp[5] + __edi - 3;
                     *__esi = __esp[5] + __edi - 3;
                    while(1) {
L82:
                        __ecx =  *__esi;
                        __eax = __esp[5];
                        if( *__esi < __esp[5]) {
                            break;
                        }
L83:
                        __ecx =  *__esi;
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
L86:
                            if(__eax <= __ecx) {
                                goto L119;
                            } else {
                                while(1) {
L87:
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
L110:
                                    __eax = caml_call_gc();
                                }
L88:
                                __eax = __eax + 4;
                                 *(__eax - 4) = 2301;
                                __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                 *__eax =  *((long long*)(__ebx + __ecx * 4 - 4));
                                goto L89;
                            }
                        } else {
L84:
                            if(__eax <= __ecx) {
L120:
                                __eax = caml_ml_array_bound_error();
L121:
                                __eax = caml_ml_array_bound_error();
                                goto L122;
                            } else {
L85:
                                __eax =  *(__ebx + __ecx * 2 - 2);
L89:
                                __ebx = __esp[6];
                                __ecx =  *(__esp[6] + 12);
                                __ebx = __esp[1];
                                caml_apply2();
                                if(__eax <= 1) {
                                    break;
                                } else {
L90:
                                    __esi = __esp[2];
                                    __ecx =  *__esi;
                                    __ebx = __esp[7];
                                    __eax =  *(__ebx - 4);
                                    __eax = __eax & 255;
                                    if((__eax & 255) == 254) {
L93:
                                        if(__eax <= __ecx) {
                                            goto L117;
                                        } else {
                                            while(1) {
L94:
                                                __eax = caml_young_ptr;
                                                __eax = caml_young_ptr - 12;
                                                caml_young_ptr = __eax;
                                                if(__eax >= caml_young_limit) {
                                                    break;
                                                }
L109:
                                                __eax = caml_call_gc();
                                            }
L95:
                                            __edx = __eax + 4;
                                             *(__edx - 4) = 2301;
                                            __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                             *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                            goto L96;
                                        }
                                    } else {
L91:
                                        if(__eax <= __ecx) {
L118:
                                            __eax = caml_ml_array_bound_error();
L119:
                                            __eax = caml_ml_array_bound_error();
                                            goto L120;
                                        } else {
L92:
                                            __edx =  *(__ebx + __ecx * 2 - 2);
L96:
                                            __eax =  *__esi;
                                            __eax =  *__esi + 2;
                                            __ecx =  *(__ebx - 4);
                                            __edi = __ecx;
                                            __edi = __ecx & 255;
                                            if(__edi == 254) {
L99:
                                                if(__ecx <= __eax) {
L115:
                                                    __eax = caml_ml_array_bound_error();
                                                    goto L116;
                                                } else {
L100:
                                                    __fp0 =  *__edx;
                                                     *((long long*)(__ebx + __eax * 4 - 4)) =  *__edx;
                                                    goto L101;
                                                }
                                            } else {
L97:
                                                if(__ecx <= __eax) {
L116:
                                                    __eax = caml_ml_array_bound_error();
L117:
                                                    __eax = caml_ml_array_bound_error();
                                                    goto L118;
                                                } else {
L98:
                                                    _push(__edx);
                                                    _push(__eax);
                                                    __eax = caml_modify(__ebx, __edi, __esi);
                                                    __esp =  &(__esp[2]);
L101:
                                                     *__esi =  *__esi + -2;
                                                    continue;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        goto L165;
                    }
L102:
                    __esp[2] =  *(__esp[2]);
                    __eax =  *(__esp[2]) + 2;
                    __ebx = __esp[7];
                    __ecx =  *(__ebx - 4);
                    __ecx = __ecx & 255;
                    if((__ecx & 255) == 254) {
L105:
                        if(__ecx <= __eax) {
L113:
                            __eax = caml_ml_array_bound_error();
                            goto L114;
                        } else {
L106:
                            __ecx = __esp[1];
                            __fp0 =  *(__esp[1]);
                             *((long long*)(__ebx + __eax * 4 - 4)) =  *(__esp[1]);
                            goto L107;
                        }
                    } else {
L103:
                        if(__ecx <= __eax) {
L114:
                            __eax = caml_ml_array_bound_error();
                            goto L115;
                        } else {
L104:
                            __ecx = __esp[1];
                            _push(__esp[1]);
                            _push(__eax);
                            __eax = caml_modify(__ebx, __edi, __esi);
                            __esp =  &(__esp[2]);
                            goto L107;
                        }
                    }
                }
            }
L165:
L107:
            __edi = __esp[3];
            __ecx = __edi;
            __edi = __edi + 2;
            __esp[3] = __edi;
            __eax = __esp[4];
        } while(__ecx != __esp[4]);
        break;
    }
L108:
    __esp =  &(__esp[0xa]);
    return 1;
    goto L165;
}

camlArray__sortto_1217(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx,                       // r2
    _unknown_ __edx,                       // r3
    _unknown_ __esi                        // r5
)
{// addr = 0x08051600
    _unknown_ _t287;                       // _t287
    _unknown_ _t295;                       // _t295
    _unknown_ _t299;                       // _t299
    _unknown_ _t304;                       // _t304
    _unknown_ _t307;                       // _t307
    _unknown_ _t310;                       // _t310
    _unknown_ _t313;                       // _t313
    _unknown_ _t317;                       // _t317
    _unknown_ _t324;                       // _t324
    _unknown_ _t336;                       // _t336
    _unknown_ _t339;                       // _t339
    _unknown_ _t341;                       // _t341
    _unknown_ _t342;                       // _t342
    _unknown_ _t345;                       // _t345
    _unknown_ _t348;                       // _t348
    _unknown_ _t354;                       // _t354
    _unknown_ _t357;                       // _t357
    _unknown_ _t362;                       // _t362
    _unknown_ _t364;                       // _t364
    _unknown_ _t365;                       // _t365
    _unknown_ _t366;                       // _t366
    _unknown_ _t372;                       // _t372
    _unknown_ _t375;                       // _t375
    _unknown_ _t377;                       // _t377
    _unknown_ _t379;                       // _t379
    _unknown_ _t384;                       // _t384
    _unknown_ _t392;                       // _t392
    _unknown_ _t399;                       // _t399
    _unknown_ _t401;                       // _t401
    _unknown_ _t405;                       // _t405
    _unknown_ _t414;                       // _t414
    _unknown_ _t416;                       // _t416
    _unknown_ _t418;                       // _t418
    _unknown_ _t432;                       // _t432
    _unknown_ _t438;                       // _t438
    _unknown_ _t445;                       // _t445
    _unknown_ _t457;                       // _t457
    _unknown_ _t458;                       // _t458
    _unknown_ _t462;                       // _t462
    _unknown_ _t464;                       // _t464
    _unknown_ _t465;                       // _t465
    _unknown_ _t467;                       // _t467
    _unknown_ _t468;                       // _t468
    _unknown_ _t471;                       // _t471
    _unknown_ _t472;                       // _t472
    _unknown_ _t474;                       // _t474
    _unknown_ _t475;                       // _t475
    _unknown_ _t479;                       // _t479
    _unknown_ _t480;                       // _t480
    _unknown_ _t482;                       // _t482
    _unknown_ _t485;                       // _t485
    _unknown_ _t491;                       // _t491
    _unknown_ _t492;                       // _t492
    _unknown_ _t495;                       // _t495
    _unknown_ _t500;                       // _t500
    _unknown_ _t501;                       // _t501
    _unknown_ _t505;                       // _t505
    _unknown_ _t507;                       // _t507
    _unknown_ _t508;                       // _t508
    _unknown_ _t509;                       // _t509
    _unknown_ _t511;                       // _t511
    _unknown_ _t520;                       // _t520
    _unknown_ _t526;                       // _t526
    _unknown_ _t527;                       // _t527
    _unknown_ _t529;                       // _t529
    _unknown_ _t530;                       // _t530
    _unknown_ _t535;                       // _t535
    _unknown_ _t543;                       // _t543
    _unknown_ _t544;                       // _t544
    _unknown_ _t545;                       // _t545
    _unknown_ _t546;                       // _t546
    _unknown_ _t547;                       // _t547
    _unknown_ _t548;                       // _t548
    _unknown_ _t550;                       // _t550
    _unknown_ _t552;                       // _t552
    _unknown_ _t555;                       // _t555
    _unknown_ _t557;                       // _t557
    _unknown_ _t560;                       // _t560
    _unknown_ _t561;                       // _t561
    _unknown_ _t562;                       // _t562
    _unknown_ _t563;                       // _t563
    _unknown_ _t565;                       // _t565
    _unknown_ _t566;                       // _t566
    _unknown_ _t567;                       // _t567
    _unknown_ _t568;                       // _t568
    _unknown_ _t570;                       // _t570
    _unknown_ _t572;                       // _t572
    _unknown_ _t576;                       // _t576


}

camlArray__init_1037(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x080516C0
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t22;                         // _t22
    signed int _t24;                       // _t24
    signed int _t35;                       // _t35
    signed int _t36;                       // _t36

    if(__eax != 1) {
        _v20 = __ebx;
         *__esp = __eax;
         *((intOrPtr*)( *__ebx))();
        caml_c_call(_v24);
        __esp = __esp + 4;
        _t29 = caml_make_vect;
        _t35 = 3;
        _t22 =  *__esp + -2;
        if(3 <= _t22) {
            _v16 = _t22;
            _v12 = 3;
             *__esp = caml_make_vect;
            do {
                _t24 = _t35;
                 *((intOrPtr*)( *_v20))();
                _t29 =  *__esp;
                if(( *(_t29 - 4) & 255) == 254) {
                    _t36 = _v12;
                     *((long long*)(_t29 + _t36 * 4 - 4)) =  *_t24;
                } else {
                    _push(_t24);
                    _t36 = _v12;
                    _push(_t29 + _t36 * 2 - 2);
                    caml_modify(_t29, __edi, _t36);
                    __esp = __esp + 8;
                }
                _t35 = _t36 + 2;
                _v12 = _t35;
            } while(_t36 != _v16);
        }
        return _t29;
    } else {
        return  &camlArray__34;
    }
}

camlArray__make_matrix_1042(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08051780
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _t16;                         // _t16
    signed int _t29;                       // _t29

     *__esp = __eax;
    _v12 = __ebx;
    _v16 = __ecx;
    caml_c_call(__eax);
    __esp = __esp + 4;
    _t25 = caml_make_vect;
    _t16 =  *__esp + -2;
    if(1 <= _t16) {
        _v4 = _t16;
         *__esp = 1;
        _v8 = caml_make_vect;
        do {
            caml_c_call(_v16);
            _push(caml_make_vect);
            _t29 = _v20;
            _t25 = _v8;
            _push(_t25 + _t29 * 2 - 2);
            caml_modify(_t25, __edi, _t29);
            __esp = __esp + 8;
             *__esp = _t29 + 2;
        } while(_t29 != _v4);
    }
    return _t25;
}

camlArray__copy_1049(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08051800
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _t28;                         // _t28
    long long* _t30;                       // _t30
    intOrPtr _t35;                         // _t35
    signed int _t38;                       // _t38
    signed int _t43;                       // _t43
    unsigned int _t44;                     // _t44
    signed int _t45;                       // _t45
    signed int _t46;                       // _t46
    intOrPtr _t47;                         // _t47
    _unknown_ _t49;                        // _t49

    _t44 =  *(__eax - 4);
    if((_t44 & 255) == 254) {
        _t45 = _t44 >> 10;
    } else {
        _t45 = _t44 >> 9;
    }
    _t46 = _t45 | 1;
    if(_t46 != 1) {
         *__esp = _t46;
        _v12 = __eax;
        if(( *(__eax - 4) & 255) == 254) {
            while(1) {
                _t28 = caml_young_ptr - 12;
                caml_young_ptr = _t28;
                if(_t28 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t30 = _t28 + 4;
             *((intOrPtr*)(_t30 - 4)) = 2301;
             *_t30 =  *__eax;
        } else {
            _t30 =  *__eax;
        }
        caml_c_call(_t30);
        __esi = caml_make_vect;
        _t43 = 3;
        _t49 =  *__esp + -2;
        if(3 <= _t49) {
            do {
                _t47 = _v12;
                if(( *(_t47 - 4) & 255) == 254) {
                    while(1) {
                        _t35 = caml_young_ptr - 12;
                        caml_young_ptr = _t35;
                        if(_t35 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    __edx = _t35 + 4;
                     *((intOrPtr*)(__edx - 4)) = 2301;
                     *__edx =  *((long long*)(_t47 + _t43 * 4 - 4));
                } else {
                    __edx =  *((intOrPtr*)(_t47 + _t43 * 2 - 2));
                }
                if(( *(caml_make_vect - 4) & 255) == 254) {
                     *((long long*)(caml_make_vect + _t43 * 4 - 4)) =  *__edx;
                } else {
                    caml_modify(_t43, _t49, caml_make_vect, caml_make_vect + _t43 * 2 - 2, __edx);
                }
                _t38 = _t43;
                _t43 = _t43 + 2;
            } while(_t38 != _t49);
        }
        return caml_make_vect;
    } else {
        return  &camlArray__32;
    }
}

camlArray__append_1054(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08051930
    intOrPtr* _v12;                        // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr _t54;                         // _t54
    signed int _t59;                       // _t59
    intOrPtr _t63;                         // _t63
    intOrPtr _t72;                         // _t72
    signed int _t75;                       // _t75
    intOrPtr* _t79;                        // _t79
    signed int _t80;                       // _t80
    signed int _t81;                       // _t81
    unsigned int _t84;                     // _t84
    signed int _t85;                       // _t85
    signed int _t86;                       // _t86
    intOrPtr _t87;                         // _t87
    signed int _t88;                       // _t88
    signed int _t89;                       // _t89
    intOrPtr _t90;                         // _t90
    unsigned int _t91;                     // _t91
    signed int _t92;                       // _t92
    signed int _t93;                       // _t93
    long long* _t94;                       // _t94
    long long* _t95;                       // _t95
    _unknown_ _t97;                        // _t97
    long long* _t101;                      // _t101

    _t79 = __ebx;
    _t91 =  *(__eax - 4);
    if((_t91 & 255) == 254) {
        _t92 = _t91 >> 10;
    } else {
        _t92 = _t91 >> 9;
    }
    _t93 = _t92 | 1;
    _t84 =  *(_t79 - 4);
    if((_t84 & 255) == 254) {
        _t85 = _t84 >> 10;
    } else {
        _t85 = _t84 >> 9;
    }
    _t86 = _t85 | 1;
    if(_t93 != 1) {
         *__esp = _t86;
        _v16 = _t93;
        _v20 = _t79;
        _v12 = __eax;
        goto L11;
    } else {
        if(_t86 != 1) {
             *__esp = _t86;
            _v16 = _t93;
            _v20 = _t79;
            _v12 = __eax;
L11:
            if(_t93 > 1) {
                _t79 = __eax;
            }
            if(( *(_t79 - 4) & 255) == 254) {
                while(1) {
                    _t54 = caml_young_ptr - 12;
                    caml_young_ptr = _t54;
                    if(_t54 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t101 = _t54 + 4;
                 *((intOrPtr*)(_t101 - 4)) = 2301;
                 *_t101 =  *_t79;
            } else {
                _t101 =  *_t79;
            }
            caml_c_call(_t101);
            _t80 = 1;
            _t97 = _v16 + -2;
            if(1 <= _t97) {
                do {
                    _t90 = _v12;
                    if(( *(_t90 - 4) & 255) == 254) {
                        while(1) {
                            _t72 = caml_young_ptr - 12;
                            caml_young_ptr = _t72;
                            if(_t72 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t95 = _t72 + 4;
                         *((intOrPtr*)(_t95 - 4)) = 2301;
                         *_t95 =  *((long long*)(_t90 + _t80 * 4 - 4));
                    } else {
                        _t95 =  *((intOrPtr*)(_t90 + _t80 * 2 - 2));
                    }
                    if(( *(caml_make_vect - 4) & 255) == 254) {
                         *((long long*)(caml_make_vect + _t80 * 4 - 4)) =  *_t95;
                    } else {
                        caml_modify(_t80, _t97, caml_make_vect, caml_make_vect + _t80 * 2 - 2, _t95);
                    }
                    _t75 = _t80;
                    _t80 = _t80 + 2;
                } while(_t75 != _t97);
            }
            _t81 = 1;
            _t59 =  *__esp + -2;
            if(1 <= _t59) {
                 *__esp = _t59;
                do {
                    _t87 = _v20;
                    if(( *(_t87 - 4) & 255) == 254) {
                        while(1) {
                            _t63 = caml_young_ptr - 12;
                            caml_young_ptr = _t63;
                            if(_t63 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t94 = _t63 + 4;
                         *((intOrPtr*)(_t94 - 4)) = 2301;
                         *_t94 =  *((long long*)(_t87 + _t81 * 4 - 4));
                    } else {
                        _t94 =  *((intOrPtr*)(_t87 + _t81 * 2 - 2));
                    }
                    _t88 = _t81 + _v16 - 1;
                    if(( *(caml_make_vect - 4) & 255) == 254) {
                         *((long long*)(caml_make_vect + _t88 * 4 - 4)) =  *_t94;
                    } else {
                        caml_modify(_t81, _t97, caml_make_vect, caml_make_vect + _t88 * 2 - 2, _t94);
                    }
                    _t89 = _t81;
                    _t81 = _t81 + 2;
                } while(_t89 !=  *__esp);
            }
            return caml_make_vect;
        } else {
            return  &camlArray__31;
        }
    }
}

camlArray__concat_aux_1062(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08051B70
    intOrPtr* _v4;                         // _cfa_fffffffc
    _unknown_ _t11;                        // _t11
    intOrPtr _t14;                         // _t14

     *__esp = __eax;
    _v4 = __ebx;
    _t11 = camlArray__size_1065(1, __ebx);
    caml_c_call( *__esp);
     *__esp = caml_make_vect;
    while(1) {
        _t14 = caml_young_ptr - 20;
        caml_young_ptr = _t14;
        if(_t14 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ecx = _t14 + 4;
     *((intOrPtr*)(__ecx - 4)) = 4343;
     *__ecx = caml_curry2;
    __ecx[1] = 5;
    __ecx[2] = camlArray__fill_1070;
    __ecx[3] = caml_make_vect;
    camlArray__fill_1070(1, _v4, __ecx);
    return  *__esp;
}

camlArray__concat_1075(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08051C00
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr* _t13;                        // _t13
    intOrPtr _t17;                         // _t17
    long long* _t19;                       // _t19
    _unknown_ _t22;                        // _t22
    intOrPtr _t25;                         // _t25
    intOrPtr _t29;                         // _t29
    intOrPtr* _t31;                        // _t31
    intOrPtr* _t35;                        // _t35
    intOrPtr* _t36;                        // _t36
    unsigned int _t37;                     // _t37
    signed int _t38;                       // _t38

    _t13 = __eax;
    __esp = __esp - 8;
    while(1) {
        _t31 = _t13;
        if(_t31 == 1) {
            break;
        }
        _t13 = _t31[1];
        _t35 =  *_t31;
        _t37 =  *(_t35 - 4);
        if((_t37 & 255) == 254) {
            _t38 = _t37 >> 10;
        } else {
            _t38 = _t37 >> 9;
        }
        if((_t38 | 1) <= 1) {
            continue;
        } else {
            if(( *(_t35 - 4) & 255) == 254) {
                while(1) {
                    _t17 = caml_young_ptr - 12;
                    caml_young_ptr = _t17;
                    if(_t17 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t19 = _t17 + 4;
                 *((intOrPtr*)(_t19 - 4)) = 2301;
                 *_t19 =  *_t35;
            } else {
                _t19 =  *_t35;
            }
            __esp = __esp + 8;
            __esp = __esp - 8;
             *__esp = _t19;
            _v4 = _t31;
            _t22 = camlArray__size_1065(1, _t31);
            caml_c_call( *__esp);
             *__esp = caml_make_vect;
            while(1) {
                _t25 = caml_young_ptr - 20;
                caml_young_ptr = _t25;
                if(_t25 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t36 = _t25 + 4;
             *((intOrPtr*)(_t36 - 4)) = 4343;
             *_t36 = caml_curry2;
            _t36[1] = 5;
            _t36[2] = camlArray__fill_1070;
            _t36[3] = caml_make_vect;
            camlArray__fill_1070(1, _v4, _t36);
            _t29 =  *__esp;
            __esp = __esp + 8;
            return _t29;
        }
L19:
    }
    __esp = __esp + 8;
    return  &camlArray__36;
    goto L19;
}

unsigned int camlArray__sub_1081(
    signed int __eax,                      // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx,                      // r2
    _unknown_ __edi                        // r4
)
{// addr = 0x08051C10
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _t40;                       // _t40
    intOrPtr* _t42;                        // _t42
    intOrPtr _t45;                         // _t45

    __edi = __edi;
    __ecx = __ecx;
    _t38 = __eax;
    __edx = __eax;
    if(__ebx < 1 || __ecx < 1) {
L27:
        _t38 = "Array.sub";
        __esp =  &(__esp[6]);
        _t45 = _t38;
L2:
        _t40 = caml_young_ptr - 12;
        caml_young_ptr = _t40;
        if(_t40 >= caml_young_limit) {
            _t42 = _t40 + 4;
             *((intOrPtr*)(_t42 - 4)) = 2048;
             *_t42 =  &caml_exn_Invalid_argument;
            _t42[1] = _t45;
            caml_raise_exn(_t42);
        }
        caml_call_gc();
        goto L2;
    }
    __esi =  *(__eax - 4);
    __esi = __esi & 255;
    if((__esi & 255) == 254) {
        __eax = __esi;
        __eax = __esi >> 10;
    } else {
        __eax = __esi;
        __eax = __esi >> 9;
    }
    __eax = __eax | 1;
    __eax = __eax - __ecx;
    __eax = __eax + 1;
    if(__ebx > __eax) {
        goto L27;
    }
    if(__ecx != 1) {
         *__esp = __ecx;
        _v20 = __ebx;
        _v16 = __edx;
        __eax =  *(__edx - 4) & 255;
        if(( *(__edx - 4) & 255) == 254) {
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 12;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __eax = __eax + 4;
             *(__eax - 4) = 2301;
             *__eax =  *((long long*)(__edx + __ebx * 4 - 4));
        } else {
            __eax =  *(__edx + __ebx * 2 - 2);
        }
        _push(__eax);
        _push(__ecx);
        __eax = caml_make_vect;
        caml_c_call();
        __esp =  &(__esp[2]);
        __esi = caml_make_vect;
        __ebx = 3;
        __eax =  *__esp;
        __eax =  *__esp + -2;
        if(3 <= __eax) {
            _v12 = __eax;
             *__esp = caml_make_vect;
            do {
                __eax = _v20;
                __edx = _v20 + __ebx - 1;
                __ecx = _v16;
                __eax =  *(__ecx - 4) & 255;
                if(( *(__ecx - 4) & 255) == 254) {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __eax = __eax + 4;
                     *(__eax - 4) = 2301;
                     *__eax =  *((long long*)(__ecx + __edx * 4 - 4));
                    __ecx = __eax;
                } else {
                    __ecx =  *(__ecx + __edx * 2 - 2);
                }
                __esi =  *__esp;
                __eax =  *(__esi - 4) & 255;
                if(( *(__esi - 4) & 255) == 254) {
                     *((long long*)(__esi + __ebx * 4 - 4)) =  *__ecx;
                } else {
                    _push(__ecx);
                    __eax = __esi + __ebx * 2 - 2;
                    _push(__esi + __ebx * 2 - 2);
                    __eax = caml_modify(__ebx, __edi, __esi);
                    __esp =  &(__esp[2]);
                }
                __ecx = __ebx;
                __ebx = __ebx + 2;
                __ebx = __ebx + 2;
                __eax = _v12;
            } while(__ecx != _v12);
        }
        __eax = __esi;
        return __esi;
    } else {
        __eax =  &camlArray__28;
        return  &camlArray__28;
    }
}

signed int camlArray__fill_1087(
    char* __eax,                           // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx,                      // r2
    unsigned int __edx                     // r3
)
{// addr = 0x08051DC0
    intOrPtr _t16;                         // _t16
    intOrPtr* _t18;                        // _t18
    intOrPtr _t21;                         // _t21

    __edx = __edx;
    __ecx = __ecx;
    _t14 = __eax;
    __esi = __eax;
    __edi = __edx;
    if(__ebx < 1 || __ecx < 1) {
L16:
        _t14 = "Array.fill";
        __esp = __esp + 8;
    } else {
        __edx =  *(__eax - 4);
        __edx = __edx & 255;
        if((__edx & 255) == 254) {
            __eax = __edx;
            __eax = __edx >> 10;
        } else {
            __eax = __edx;
            __eax = __edx >> 9;
        }
        __eax = __eax | 1;
        __eax = __eax - __ecx;
        __eax = __eax + 1;
        if(__ebx > __eax) {
            goto L16;
        } else {
            __ebp = __ebx;
            __ebx = __ebx + __ecx - 3;
            if(__ebp > __ebx) {
L15:
                __eax = 1;
                return 1;
            } else {
                goto L11;
            }
            do {
L11:
                __eax =  *(__esi - 4) & 255;
                if(( *(__esi - 4) & 255) == 254) {
                     *((long long*)(__esi + __ebp * 4 - 4)) =  *__edi;
                } else {
                    _push(__edi);
                    __eax = __esi + __ebp * 2 - 2;
                    _push(__esi + __ebp * 2 - 2);
                    __eax = caml_modify(__ebx, __edi, __esi);
                    __esp = __esp + 8;
                }
                __ecx = __ebp;
                __ebp = __ebp + 2;
                __ebp = __ebp + 2;
            } while(__ecx != __ebx);
            goto L15;
        }
    }
    _t21 = _t14;
L2:
    _t16 = caml_young_ptr - 12;
    caml_young_ptr = _t16;
    if(_t16 >= caml_young_limit) {
        _t18 = _t16 + 4;
         *((intOrPtr*)(_t18 - 4)) = 2048;
         *_t18 =  &caml_exn_Invalid_argument;
        _t18[1] = _t21;
        caml_raise_exn(_t18);
    }
    caml_call_gc();
    goto L2;
}

signed int camlArray__blit_1093(
    signed int __eax,                      // r0
    _unknown_ __ebx,                       // r1
    signed int __ecx,                      // r2
    signed int __edx,                      // r3
    signed int __esi                       // r5
)
{// addr = 0x08051E60
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _t67;                       // _t67
    intOrPtr* _t69;                        // _t69
    intOrPtr _t72;                         // _t72

    __esi = __esi;
    __edx = __edx;
    __ecx = __ecx;
    _t65 = __eax;
    __edi = __eax;
    _v16 = __ecx;
    if(__esi < 1 || __ebx < 1) {
L38:
        _t65 = "Array.blit";
        __esp =  &(__esp[6]);
        _t72 = _t65;
        while(1) {
            _t67 = caml_young_ptr - 12;
            caml_young_ptr = _t67;
            if(_t67 >= caml_young_limit) {
                _t69 = _t67 + 4;
                 *((intOrPtr*)(_t69 - 4)) = 2048;
                 *_t69 =  &caml_exn_Invalid_argument;
                _t69[1] = _t72;
                caml_raise_exn(_t69);
            }
            caml_call_gc();
        }
    }
    __ecx =  *(__eax - 4);
    __ecx = __ecx & 255;
    if((__ecx & 255) == 254) {
        __eax = __ecx;
        __eax = __ecx >> 10;
    } else {
        __eax = __ecx;
        __eax = __ecx >> 9;
    }
    __eax = __eax | 1;
    __eax = __eax - __esi;
    __eax = __eax + 1;
    if(__ebx > __eax || __edx < 1) {
        goto L38;
    }
    __eax = _v16;
    __ecx =  *(_v16 - 4);
    __ecx = __ecx & 255;
    if((__ecx & 255) == 254) {
        __eax = __ecx;
        __eax = __ecx >> 10;
    } else {
        __eax = __ecx;
        __eax = __ecx >> 9;
    }
    __eax = __eax | 1;
    __eax = __eax - __esi;
    __eax = __eax + 1;
    if(__edx > __eax) {
        goto L38;
    }
    if(__ebx >= __edx) {
        __eax = 1;
        _v12 = 1;
        __esi = __esi + -2;
        if(_v12 <= __esi) {
            _v20 = __ebx;
             *__esp = __edi;
            do {
                __ebx = _v20;
                __eax = _v12;
                __ebx = _v20 + _v12 - 1;
                __eax =  *__esp;
                __ecx =  *(__eax - 4) & 255;
                if(( *(__eax - 4) & 255) == 254) {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __ecx = __eax + 4;
                     *(__ecx - 4) = 2301;
                    __eax =  *__esp;
                    __fp0 =  *((long long*)(__eax + __ebx * 4 - 4));
                     *__ecx =  *((long long*)(__eax + __ebx * 4 - 4));
                    __ebx = __ecx;
                } else {
                    __ebx =  *(__eax + __ebx * 2 - 2);
                }
                __ecx = _v12;
                __eax = __edx;
                __eax = __edx + _v12 - 1;
                __ecx = _v16;
                __ecx =  *(_v16 - 4) & 255;
                if(( *(_v16 - 4) & 255) == 254) {
                    __fp0 =  *__ebx;
                    __ebx = _v16;
                     *((long long*)(_v16 + __eax * 4 - 4)) = __fp0;
                } else {
                    _push(__ebx);
                    __ebx = _v16;
                    _push(__eax);
                    __eax = caml_modify(__ebx, __edi, __esi);
                    __esp =  &(__esp[2]);
                }
                __ebx = _v12;
                _v12 = _v12 + 2;
                _v12 = _v12 + 2;
            } while(_v12 != __esi);
        }
        __eax = 1;
        return 1;
    } else {
        __esi = __esi + -2;
        if(__esi >= 1) {
            _v20 = __ebx;
            do {
                __eax = _v20;
                __ebx = _v20 + __esi - 1;
                __eax =  *(__edi - 4) & 255;
                if(( *(__edi - 4) & 255) == 254) {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __eax = __eax + 4;
                     *(__eax - 4) = 2301;
                    __fp0 =  *((long long*)(__edi + __ebx * 4 - 4));
                     *__eax =  *((long long*)(__edi + __ebx * 4 - 4));
                    __ebx = __eax;
                } else {
                    __ebx =  *(__edi + __ebx * 2 - 2);
                }
                __eax = __edx;
                __eax = __edx + __esi - 1;
                __ecx = _v16;
                __ecx =  *(_v16 - 4) & 255;
                if(( *(_v16 - 4) & 255) == 254) {
                    __fp0 =  *__ebx;
                    __ebx = _v16;
                     *((long long*)(_v16 + __eax * 4 - 4)) = __fp0;
                } else {
                    _push(__ebx);
                    __ebx = _v16;
                    _push(__eax);
                    __eax = caml_modify(__ebx, __edi, __esi);
                    __esp =  &(__esp[2]);
                }
                __ebx = __esi;
                __esi = __esi - 2;
                __esi = __esi - 2;
            } while(__ebx != 1);
        }
        __eax = 1;
        return 1;
    }
}

signed int camlArray__iter_1101(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080520C0
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr _t22;                         // _t22
    long long* _t23;                       // _t23
    intOrPtr _t27;                         // _t27
    signed int _t30;                       // _t30
    signed int _t32;                       // _t32
    unsigned int _t33;                     // _t33
    signed int _t34;                       // _t34
    intOrPtr _t36;                         // _t36

    _t30 = 1;
    _t33 =  *(__ebx - 4);
    if((_t33 & 255) == 254) {
        _t34 = _t33 >> 10;
    } else {
        _t34 = _t33 >> 9;
    }
    _t36 = (_t34 | 1) + -2;
    if(_t30 <= _t36) {
        _v12 = _t36;
        _v16 = _t30;
         *__esp = __ebx;
        _v20 = __eax;
        do {
            _t27 =  *__esp;
            if(( *(_t27 - 4) & 255) == 254) {
                while(1) {
                    _t22 = caml_young_ptr - 12;
                    caml_young_ptr = _t22;
                    if(_t22 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t23 = _t22 + 4;
                 *((intOrPtr*)(_t23 - 4)) = 2301;
                 *_t23 =  *((long long*)(_t27 + _t30 * 4 - 4));
            } else {
            }
             *((intOrPtr*)( *_v20))();
            _t32 = _v16;
            _t30 = _t32 + 2;
            _v16 = _t30;
        } while(_t32 != _v12);
    }
    return 1;
}

signed int camlArray__map_1105(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08052170
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr* _v24;                        // _cfa_ffffffe8
    _unknown_ _v28;                        // _cfa_ffffffe4
    unsigned int _t33;                     // _t33
    signed int _t34;                       // _t34
    signed int _t35;                       // _t35
    intOrPtr _t38;                         // _t38
    long long* _t39;                       // _t39
    intOrPtr _t43;                         // _t43
    intOrPtr _t47;                         // _t47
    long long* _t48;                       // _t48
    signed int _t54;                       // _t54
    signed int _t57;                       // _t57
    intOrPtr _t59;                         // _t59

    _t33 =  *(__ebx - 4);
    if((_t33 & 255) == 254) {
        _t34 = _t33 >> 10;
    } else {
        _t34 = _t33 >> 9;
    }
    _t35 = _t34 | 1;
    if(_t35 != 1) {
         *__esp = _t35;
        _v24 = __ebx;
        _v20 = __eax;
        if(( *(__ebx - 4) & 255) == 254) {
            while(1) {
                _t38 = caml_young_ptr - 12;
                caml_young_ptr = _t38;
                if(_t38 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t39 = _t38 + 4;
             *((intOrPtr*)(_t39 - 4)) = 2301;
             *_t39 =  *__ebx;
        } else {
            _t39 =  *__ebx;
        }
         *((intOrPtr*)( *__eax))();
        caml_c_call(_t39);
        __esi = caml_make_vect;
        _t54 = 3;
        _t43 =  *__esp + -2;
        if(3 <= _t43) {
            _v16 = _t43;
            _v12 = 3;
             *__esp = caml_make_vect;
            do {
                _t59 = _v24;
                if(( *(_t59 - 4) & 255) == 254) {
                    while(1) {
                        _t47 = caml_young_ptr - 12;
                        caml_young_ptr = _t47;
                        if(_t47 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t48 = _t47 + 4;
                     *((intOrPtr*)(_t48 - 4)) = 2301;
                     *_t48 =  *((long long*)(_t59 + _t54 * 4 - 4));
                } else {
                    _t48 =  *((intOrPtr*)(_t59 + _t54 * 2 - 2));
                }
                 *((intOrPtr*)( *_v20))();
                __esi =  *__esp;
                if(( *(__esi - 4) & 255) == 254) {
                    _t57 = _v12;
                     *((long long*)(__esi + _t57 * 4 - 4)) =  *_t48;
                } else {
                    _push(_t48);
                    _t57 = _v12;
                    _push(__esi + _t57 * 2 - 2);
                    caml_modify(_t57, __edi, __esi);
                    __esp =  &(__esp[2]);
                }
                _t54 = _t57 + 2;
                _v12 = _t54;
            } while(_t57 != _v16);
        }
        return __esi;
    } else {
        return  &camlArray__24;
    }
}

signed int camlArray__iteri_1111(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080522E0
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t22;                         // _t22
    long long* _t27;                       // _t27
    signed int _t30;                       // _t30
    signed int _t32;                       // _t32
    unsigned int _t33;                     // _t33
    signed int _t34;                       // _t34
    intOrPtr _t36;                         // _t36
    intOrPtr _t37;                         // _t37

    _t30 = 1;
    _t33 =  *(__ebx - 4);
    if((_t33 & 255) == 254) {
        _t34 = _t33 >> 10;
    } else {
        _t34 = _t33 >> 9;
    }
    _t36 = (_t34 | 1) + -2;
    if(_t30 <= _t36) {
        _v12 = _t36;
        _v16 = _t30;
         *__esp = __ebx;
        _v20 = __eax;
        do {
            _t37 =  *__esp;
            if(( *(_t37 - 4) & 255) == 254) {
                while(1) {
                    _t22 = caml_young_ptr - 12;
                    caml_young_ptr = _t22;
                    if(_t22 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t27 = _t22 + 4;
                 *((intOrPtr*)(_t27 - 4)) = 2301;
                 *_t27 =  *((long long*)(_t37 + _t30 * 4 - 4));
            } else {
            }
            caml_apply2();
            _t32 = _v16;
            _t30 = _t32 + 2;
            _v16 = _t30;
        } while(_t32 != _v12);
    }
    return 1;
}

signed int camlArray__mapi_1115(
    intOrPtr __eax,                        // r0
    long long* __ebx,                      // r1
    _unknown_ __edi                        // r4
)
{// addr = 0x08052390
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    long long* _v24;                       // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    unsigned int _t33;                     // _t33
    signed int _t34;                       // _t34
    signed int _t35;                       // _t35
    intOrPtr _t38;                         // _t38
    intOrPtr _t44;                         // _t44
    intOrPtr _t48;                         // _t48
    signed int _t50;                       // _t50
    long long* _t58;                       // _t58
    intOrPtr _t62;                         // _t62
    long long* _t68;                       // _t68
    signed int _t69;                       // _t69
    signed int _t70;                       // _t70

    __edi = __edi;
    _t33 =  *(__ebx - 4);
    if((_t33 & 255) == 254) {
        _t34 = _t33 >> 10;
    } else {
        _t34 = _t33 >> 9;
    }
    _t35 = _t34 | 1;
    if(_t35 != 1) {
         *__esp = _t35;
        _v24 = __ebx;
        _v20 = __eax;
        if(( *(__ebx - 4) & 255) == 254) {
            while(1) {
                _t38 = caml_young_ptr - 12;
                caml_young_ptr = _t38;
                if(_t38 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t68 = _t38 + 4;
             *((intOrPtr*)(_t68 - 4)) = 2301;
             *_t68 =  *__ebx;
        } else {
        }
        caml_apply2();
        caml_c_call(_v28);
        __esp =  &(__esp[1]);
        _t57 = caml_make_vect;
        _t69 = 3;
        _t44 =  *__esp + -2;
        if(3 <= _t44) {
            _v16 = _t44;
            _v12 = 3;
             *__esp = caml_make_vect;
            do {
                _t62 = _v24;
                if(( *(_t62 - 4) & 255) == 254) {
                    while(1) {
                        _t48 = caml_young_ptr - 12;
                        caml_young_ptr = _t48;
                        if(_t48 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t58 = _t48 + 4;
                     *((intOrPtr*)(_t58 - 4)) = 2301;
                     *_t58 =  *((long long*)(_t62 + _t69 * 4 - 4));
                } else {
                }
                _t50 = _t69;
                caml_apply2();
                _t57 =  *__esp;
                if(( *(_t57 - 4) & 255) == 254) {
                    _t70 = _v12;
                     *((long long*)(_t57 + _t70 * 4 - 4)) =  *_t50;
                } else {
                    _push(_t50);
                    _t70 = _v12;
                    _push(_t57 + _t70 * 2 - 2);
                    caml_modify(_t57, __edi, _t70);
                    __esp =  &(__esp[2]);
                }
                _t69 = _t70 + 2;
                _v12 = _t69;
            } while(_t70 != _v16);
        }
        return _t57;
    } else {
        return  &camlArray__23;
    }
}

camlArray__to_list_1121(
    signed int __eax                       // r0
)
{// addr = 0x08052510
    signed int _t20;                       // _t20
    unsigned int _t23;                     // _t23
    unsigned int _t26;                     // _t26
    intOrPtr _t30;                         // _t30
    intOrPtr* _t31;                        // _t31

    _t20 = __eax;
    __ebx = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __ecx = __eax + 4;
     *((intOrPtr*)(__ecx - 4)) = 4343;
     *__ecx = caml_curry2;
    __ecx[1] = 5;
    __ecx[2] = camlArray__tolist_1123;
    __ecx[3] = __ebx;
    __eax =  *(__ebx - 4);
    __eax = __eax & 255;
    if((__eax & 255) == 254) {
        __eax = __eax >> 10;
    } else {
        __eax = __eax >> 9;
    }
    __eax = __eax + -2;
    __ebx = 1;
    __esp = __esp - 8;
    while(1) {
        __edx = _t20;
        if(__edx < 1) {
            break;
        }
        _t30 = __ecx[3];
        if(( *(_t30 - 4) & 255) == 254) {
            while(1) {
                _t23 = caml_young_ptr - 12;
                caml_young_ptr = _t23;
                if(_t23 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            __edi = _t23 + 4;
             *((intOrPtr*)(__edi - 4)) = 2301;
             *__edi =  *((long long*)(_t30 + __edx * 4 - 4));
            while(1) {
L8:
                _t26 = caml_young_ptr - 12;
                caml_young_ptr = _t26;
                if(_t26 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t31 = _t26 + 4;
             *((intOrPtr*)(_t31 - 4)) = 2048;
             *_t31 = __edi;
            _t31[1] = __ebx;
            _t20 = __edx + -2;
            __ebx = _t31;
            continue;
        }
        __edi =  *((intOrPtr*)(_t30 + __edx * 2 - 2));
        goto L8;
    }
    __esp = __esp + 8;
    return __ebx;
}

camlArray__list_length_1126(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08052580
L0:
    while(1) {
L0:
        __eax = __eax;
        if(__ebx == 1) {
            break;
        }
L1:
        __eax = __eax + 2;
    }
L2:
    return __eax;
}

camlArray__of_list_1130(
    signed int __eax                       // r0
)
{// addr = 0x080525A0
    signed int _v4;                        // _cfa_fffffffc
    signed int _t19;                       // _t19
    intOrPtr* _t26;                        // _t26
    intOrPtr _t27;                         // _t27
    _unknown_ _t28;                        // _t28
    long long* _t29;                       // _t29

    _t19 = __eax;
    _t26 = __eax;
    if(__eax == 1) {
        return  &camlArray__22;
    } else {
        __eax =  *((intOrPtr*)(__ebx + 4));
        _v4 =  *((intOrPtr*)(__ebx + 4));
        __eax =  *__ebx;
         *__esp =  *__ebx;
        __eax = 1;
        __eax = camlArray__list_length_1126(1, __ebx);
        __ebx =  *__esp;
        _push( *__esp);
        _push(__eax);
        __eax = caml_make_vect;
        caml_c_call();
        __esp = __esp + 8;
        __ebx = caml_make_vect;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 20;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __ecx = __eax + 4;
         *((intOrPtr*)(__ecx - 4)) = 4343;
         *__ecx = caml_curry2;
        __ecx[1] = 5;
        __ecx[2] = camlArray__fill_1135;
        __ecx[3] = __ebx;
        __eax = 3;
        __ebx = _v4;
        __esp = __esp + 8;
        __esp = __esp - 8;
        while(1) {
            __edi = _t19;
            __esi = _t28;
            if(_t26 == 1) {
                break;
            }
            __ebp = _t26[1];
            _t29 =  *_t26;
            _t27 =  *((intOrPtr*)(__esi + 12));
            if(( *(_t27 - 4) & 255) == 254) {
                 *((long long*)(_t27 + __edi * 4 - 4)) =  *_t29;
            } else {
                caml_modify(_t27, __edi, __esi, _t27 + __edi * 2 - 2, _t29);
            }
            _t19 = __edi + 2;
            _t26 = __ebp;
            _t28 = __esi;
        }
        return  *((intOrPtr*)(__esi + 12));
    }
}

camlArray__fold_left_1139(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08052630
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    intOrPtr* _v20;                        // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t24;                         // _t24
    unsigned int _t26;                     // _t26
    signed int _t27;                       // _t27
    intOrPtr _t29;                         // _t29
    intOrPtr _t33;                         // _t33
    long long* _t41;                       // _t41
    intOrPtr _t44;                         // _t44
    signed int _t46;                       // _t46
    signed int _t47;                       // _t47

    __edi = __eax;
    while(1) {
        _t24 = caml_young_ptr - 8;
        caml_young_ptr = _t24;
        if(_t24 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __esi = _t24 + 4;
     *((intOrPtr*)(__esi - 4)) = 1024;
     *__esi = __ebx;
    _t46 = 1;
    _t26 =  *(__ecx - 4);
    if((_t26 & 255) == 254) {
        _t27 = _t26 >> 10;
    } else {
        _t27 = _t26 >> 9;
    }
    _t29 = (_t27 | 1) + -2;
    if(_t46 <= _t29) {
        _v12 = _t29;
        _v16 = _t46;
        _v20 = __esi;
         *__esp = __ecx;
        _v24 = __eax;
        do {
            _t44 =  *__esp;
            if(( *(_t44 - 4) & 255) == 254) {
                while(1) {
                    _t33 = caml_young_ptr - 12;
                    caml_young_ptr = _t33;
                    if(_t33 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t41 = _t33 + 4;
                 *((intOrPtr*)(_t41 - 4)) = 2301;
                 *_t41 =  *((long long*)(_t44 + _t46 * 4 - 4));
            } else {
                _t41 =  *((intOrPtr*)(_t44 + _t46 * 2 - 2));
            }
            caml_apply2();
            _push( *__esi);
            __esi = _v20;
            _push(__esi);
            caml_modify(_t41, __eax, __esi);
            __esp = __esp + 8;
            _t47 = _v16;
            _t46 = _t47 + 2;
            _v16 = _t46;
        } while(_t47 != _v12);
    }
    return  *__esi;
}

camlArray__fold_right_1145(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx,                        // r2
    _unknown_ __edi                        // r4
)
{// addr = 0x08052730
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t22;                         // _t22
    intOrPtr _t29;                         // _t29
    long long* _t31;                       // _t31
    intOrPtr _t35;                         // _t35
    intOrPtr _t36;                         // _t36
    unsigned int _t38;                     // _t38
    signed int _t39;                       // _t39
    signed int _t41;                       // _t41
    signed int _t43;                       // _t43

    __edi = __edi;
    while(1) {
        _t22 = caml_young_ptr - 8;
        caml_young_ptr = _t22;
        if(_t22 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __esi = _t22 + 4;
     *((intOrPtr*)(__esi - 4)) = 1024;
     *__esi = __ecx;
    _t38 =  *(__ebx - 4);
    if((_t38 & 255) == 254) {
        _t39 = _t38 >> 10;
    } else {
        _t39 = _t38 >> 9;
    }
    _t41 = (_t39 | 1) + -2;
    if(_t41 >= 1) {
        _v12 = _t41;
        _v16 = __esi;
         *__esp = __ebx;
        _v20 = __eax;
        do {
            _t35 =  *__esp;
            if(( *(_t35 - 4) & 255) == 254) {
                while(1) {
                    _t29 = caml_young_ptr - 12;
                    caml_young_ptr = _t29;
                    if(_t29 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t31 = _t29 + 4;
                 *((intOrPtr*)(_t31 - 4)) = 2301;
                 *_t31 =  *((long long*)(_t35 + _t41 * 4 - 4));
            } else {
                _t31 =  *((intOrPtr*)(_t35 + _t41 * 2 - 2));
            }
            _t36 =  *__esi;
            caml_apply2();
            _push(_t31);
            __esi = _v16;
            _push(__esi);
            caml_modify(_t36, __edi, __esi);
            __esp = __esp + 8;
            _t43 = _v12;
            _t41 = _t43 - 2;
            _v12 = _t41;
        } while(_t43 != 1);
    }
    return  *__esi;
}

signed int camlArray__sort_1152(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    signed int __edi                       // r4
)
{// addr = 0x08052820
    signed int _t434;                      // _t434
    intOrPtr* _t436;                       // _t436

    __edi = __edi;
    __esp = __esp - 32;
    __ecx = __eax;
    __esp[4] = __ebx;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 144;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __esi = __eax + 4;
     *(__esi - 4) = 5367;
     *__esi = caml_curry2;
     *((intOrPtr*)(__esi + 4)) = 5;
     *((intOrPtr*)(__esi + 8)) = camlArray__maxson_1155;
     *(__esi + 12) = __ecx;
     *(__esi + 16) = __ebx;
    __edx = __esi + 24;
     *(__edx - 4) = 6391;
     *__edx = caml_curry3;
     *((intOrPtr*)(__edx + 4)) = 7;
     *((intOrPtr*)(__edx + 8)) = camlArray__trickledown_1160;
     *(__edx + 12) = __ecx;
     *(__edx + 16) = __ebx;
     *(__edx + 20) = __esi;
    __eax = __esi + 52;
    __esp[1] = __eax;
     *(__eax - 4) = 5367;
     *__eax = caml_curry3;
     *(__eax + 4) = 7;
     *((intOrPtr*)(__eax + 8)) = camlArray__trickle_1165;
     *(__eax + 12) = __ebx;
     *(__eax + 16) = __edx;
    __edx = __esi + 76;
     *(__edx - 4) = 5367;
     *__edx = caml_curry2;
     *((intOrPtr*)(__edx + 4)) = 5;
     *((intOrPtr*)(__edx + 8)) = camlArray__bubbledown_1170;
     *(__edx + 12) = __ebx;
     *(__edx + 16) = __esi;
    __eax = __esi + 100;
     *__esp = __eax;
     *(__eax - 4) = 4343;
     *__eax = caml_curry2;
     *(__eax + 4) = 5;
     *((intOrPtr*)(__eax + 8)) = camlArray__bubble_1174;
     *(__eax + 12) = __edx;
    __eax = __esi + 120;
    __esp[2] = __eax;
     *(__eax - 4) = 5367;
     *__eax = caml_curry2;
     *(__eax + 4) = 5;
     *((intOrPtr*)(__eax + 8)) = camlArray__trickleup_1178;
     *(__eax + 12) = __ecx;
     *(__eax + 16) = __ebx;
    __eax =  *(__ebx - 4);
    __eax = __eax & 255;
    if((__eax & 255) == 254) {
        __eax = __eax >> 10;
    } else {
        __eax = __eax >> 9;
    }
    __eax = __eax | 1;
    __esp[5] = __eax;
    __ecx = 3;
    __eax = __eax + 2;
    __eax = __eax >> 1;
    asm("cdq");
    _t329 = __eax % 3;
    __eax = __eax / 3;
    __edx = _t329;
    __ebx = __eax + __eax - 1;
    if(__ebx < 1) {
L179:
        __esi = __esp[5];
        __esi = __esp[5] + -2;
        if(__esi < 5) {
L199:
            __eax = __esp[5];
            if(__esp[5] <= 3) {
                __eax = 1;
                __esp =  &(__esp[8]);
                return 1;
            } else {
                __ebx = __esp[4];
                __eax =  *(__ebx - 4);
                __eax = __eax & 255;
                if((__eax & 255) == 254) {
                    if(__eax <= 3) {
                        goto L236;
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 12;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            __eax = caml_call_gc();
                        }
                        __esi = __eax + 4;
                         *(__esi - 4) = 2301;
                        __fp0 =  *((long long*)(__ebx + 8));
                         *__esi =  *((long long*)(__ebx + 8));
                        goto L206;
                    }
                } else {
                    if(__eax <= 3) {
L237:
                        __eax = caml_ml_array_bound_error();
                        goto L238;
                    } else {
                        __esi =  *(__ebx + 4);
L206:
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
                            if(__eax <= 1) {
                                goto L234;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __edx = __eax + 4;
                                 *(__edx - 4) = 2301;
                                __fp0 =  *__ebx;
                                 *__edx =  *__ebx;
                                goto L212;
                            }
                        } else {
                            if(__eax <= 1) {
L235:
                                __eax = caml_ml_array_bound_error();
L236:
                                __eax = caml_ml_array_bound_error();
                                goto L237;
                            } else {
                                __edx =  *__ebx;
L212:
                                __eax =  *(__ebx - 4);
                                __eax = __eax & 255;
                                if((__eax & 255) == 254) {
                                    if(__eax <= 3) {
                                        goto L232;
                                    } else {
                                        __fp0 =  *__edx;
                                         *((long long*)(__ebx + 8)) =  *__edx;
                                        goto L217;
                                    }
                                } else {
                                    if(__eax <= 3) {
L233:
                                        __eax = caml_ml_array_bound_error();
L234:
                                        __eax = caml_ml_array_bound_error();
                                        goto L235;
                                    } else {
                                        _push(__edx);
                                        __ebx = __ebx + 4;
                                        _push(__ebx + 4);
                                        __eax = caml_modify(__ebx, __edi, __esi);
                                        __esp =  &(__esp[2]);
L217:
                                        __eax =  *(__ebx - 4);
                                        __eax = __eax & 255;
                                        if((__eax & 255) == 254) {
                                            if(__eax <= 1) {
                                                __eax = caml_ml_array_bound_error();
                                                goto L231;
                                            } else {
                                                __fp0 =  *__esi;
                                                 *__ebx =  *__esi;
                                                goto L222;
                                            }
                                        } else {
                                            if(__eax <= 1) {
L231:
                                                __eax = caml_ml_array_bound_error();
L232:
                                                __eax = caml_ml_array_bound_error();
                                                goto L233;
                                            } else {
                                                __eax = caml_modify(__ebx, __edi, __esi, __ebx, __esi);
L222:
                                                __eax = 1;
                                                __esp =  &(__esp[8]);
                                                return 1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            __esp[3] = __esi;
            do {
                __ebx = __esp[4];
                __eax =  *(__ebx - 4);
                __eax = __eax & 255;
                if((__eax & 255) == 254) {
                    if(__eax <= __esi) {
                        goto L242;
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 12;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            __eax = caml_call_gc();
                        }
                        __eax = __eax + 4;
                         *(__eax - 4) = 2301;
                        __fp0 =  *((long long*)(__ebx + __esi * 4 - 4));
                         *__eax =  *((long long*)(__ebx + __esi * 4 - 4));
                        __esp[1] = __eax;
                        goto L187;
                    }
                } else {
                    if(__eax <= __esi) {
L243:
                        __eax = caml_ml_array_bound_error();
                        goto L244;
                    } else {
                        __eax =  *(__ebx + __esi * 2 - 2);
                        __esp[1] =  *(__ebx + __esi * 2 - 2);
L187:
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
                            if(__eax <= 1) {
                                goto L240;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __edx = __eax + 4;
                                 *(__edx - 4) = 2301;
                                __fp0 =  *__ebx;
                                 *__edx =  *__ebx;
                                goto L193;
                            }
                        } else {
                            if(__eax <= 1) {
L241:
                                __eax = caml_ml_array_bound_error();
L242:
                                __eax = caml_ml_array_bound_error();
                                goto L243;
                            } else {
                                __edx =  *__ebx;
L193:
                                __eax =  *(__ebx - 4);
                                __eax = __eax & 255;
                                if((__eax & 255) == 254) {
                                    if(__eax <= __esi) {
L238:
                                        __eax = caml_ml_array_bound_error();
                                        goto L239;
                                    } else {
                                        __fp0 =  *__edx;
                                         *((long long*)(__ebx + __esi * 4 - 4)) =  *__edx;
                                        goto L198;
                                    }
                                } else {
                                    if(__eax <= __esi) {
L239:
                                        __eax = caml_ml_array_bound_error();
L240:
                                        __eax = caml_ml_array_bound_error();
                                        goto L241;
                                    } else {
                                        _push(__edx);
                                        __eax = __ebx + __esi * 2 - 2;
                                        _push(__ebx + __esi * 2 - 2);
                                        __eax = caml_modify(__ebx, __edi, __esi);
                                        __esp =  &(__esp[2]);
                                        goto L198;
                                    }
                                }
                            }
                        }
                    }
                }
                goto L267;
L198:
                __ebx = 1;
                __eax = __esi;
                __ecx =  *__esp;
                __eax = camlArray__bubble_1174(__esi);
                __ebx = __esp[1];
                __ecx = __esp[2];
                __eax = camlArray__trickleup_1178(__eax, __esp[1], __esp[2]);
                __esi = __esp[3];
                __eax = __esi;
                __esi = __esi - 2;
                __esp[3] = __esi;
            } while(__eax != 5);
            goto L199;
        }
    } else {
        __esp[3] = __ebx;
        do {
            __edx = __esp[4];
            __eax =  *(__edx - 4);
            __eax = __eax & 255;
            if((__eax & 255) == 254) {
                if(__eax <= __ebx) {
L244:
                    __eax = caml_ml_array_bound_error();
                    goto L245;
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 12;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __ecx = __eax + 4;
                     *(__ecx - 4) = 2301;
                    __fp0 =  *((long long*)(__edx + __ebx * 4 - 4));
                     *__ecx =  *((long long*)(__edx + __ebx * 4 - 4));
                    goto L178;
                }
            } else {
                if(__eax <= __ebx) {
L245:
                    __eax = caml_ml_array_bound_error();
                    __esp = __esp - 32;
                    __ecx = __eax;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 76;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __eax = __eax + 4;
                     *(__eax - 4) = 5367;
                     *__eax = caml_curry7;
                     *(__eax + 4) = 15;
                     *((intOrPtr*)(__eax + 8)) = camlArray__merge_1191;
                     *(__eax + 12) = __ecx;
                     *(__eax + 16) = __ebx;
                    __esi = __eax + 24;
                     *(__esi - 4) = 5367;
                     *__esi = caml_curry4;
                     *((intOrPtr*)(__esi + 4)) = 9;
                     *((intOrPtr*)(__esi + 8)) = camlArray__isortto_1209;
                     *(__esi + 12) = __ecx;
                     *(__esi + 16) = __ebx;
                    __ecx = __eax + 48;
                     *(__ecx - 4) = 6391;
                     *__ecx = caml_curry4;
                     *((intOrPtr*)(__ecx + 4)) = 9;
                     *((intOrPtr*)(__ecx + 8)) = camlArray__sortto_1217;
                     *(__ecx + 12) = __ebx;
                     *(__ecx + 16) = __eax;
                     *(__ecx + 20) = __esi;
                    __edx =  *(__ebx - 4);
                    __edx = __edx & 255;
                    if((__edx & 255) == 254) {
                        __edx = __edx >> 10;
                    } else {
                        __edx = __edx >> 9;
                    }
                    __edx = __edx | 1;
                    if(__edx > 11) {
                         *__esp = __ecx;
                        __esp[5] = __eax;
                        __esp[4] = __ebx;
                        __eax = __edx;
                        __eax = __edx >> 1;
                        if(__eax < 0) {
                            __eax = __eax + 1;
                        }
                        __eax = __eax >> 1;
                        __eax = __eax + __eax + 1;
                        __esp[2] = __eax;
                        __edx = __edx - __eax;
                        __edx = __edx + 1;
                        __esp[1] = __edx;
                        __eax =  *(__ebx - 4);
                        __eax = __eax & 255;
                        if((__eax & 255) == 254) {
                            if(__eax <= 1) {
                                __eax = caml_ml_array_bound_error();
                                goto L265;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 12;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __eax = __eax + 4;
                                 *(__eax - 4) = 2301;
                                __fp0 =  *__ebx;
                                 *__eax =  *__ebx;
                                goto L261;
                            }
                        } else {
                            if(__eax <= 1) {
L265:
                                __eax = caml_ml_array_bound_error();
                                __eax =  &camlArray__21;
                                camlArray =  &camlArray__21;
                                __eax =  &camlArray__20;
                                 *134683148 =  &camlArray__20;
                                __eax =  *134683148;
                                 *134683152 =  *134683148;
                                __eax =  &camlArray__19;
                                 *134683168 =  &camlArray__19;
                                __eax =  &camlArray__18;
                                 *134683156 =  &camlArray__18;
                                __eax =  &camlArray__17;
                                 *134683224 =  &camlArray__17;
                                __eax =  &camlArray__16;
                                 *134683160 =  &camlArray__16;
                                __eax =  &camlArray__15;
                                 *134683164 =  &camlArray__15;
                                __eax =  &camlArray__14;
                                 *134683172 =  &camlArray__14;
                                __eax =  &camlArray__13;
                                 *134683176 =  &camlArray__13;
                                __eax =  &camlArray__12;
                                 *134683188 =  &camlArray__12;
                                __eax =  &camlArray__11;
                                 *134683192 =  &camlArray__11;
                                __eax =  &camlArray__10;
                                 *134683196 =  &camlArray__10;
                                __eax =  &camlArray__9;
                                 *134683200 =  &camlArray__9;
                                __eax =  &camlArray__8;
                                 *134683180 =  &camlArray__8;
                                __eax =  &camlArray__7;
                                 *134683228 =  &camlArray__7;
                                __eax =  &camlArray__6;
                                 *134683184 =  &camlArray__6;
                                __eax =  &camlArray__5;
                                 *134683204 =  &camlArray__5;
                                __eax =  &camlArray__4;
                                 *134683208 =  &camlArray__4;
                                __eax = caml_alloc1();
                                __eax = __eax + 4;
                                 *(__eax - 4) = 1024;
                                 *__eax = "Array.Bottom";
                                 *134683232 = __eax;
                                __eax =  &camlArray__2;
                                 *134683212 =  &camlArray__2;
                                 *134683236 = 11;
                                __eax =  &camlArray__1;
                                 *134683216 =  &camlArray__1;
                                __eax =  *134683216;
                                 *134683220 =  *134683216;
                                __eax = 1;
                                return 1;
                            } else {
                                __eax =  *__ebx;
L261:
                                _push(__eax);
                                _push(__edx);
                                __eax = caml_make_vect;
                                caml_c_call();
                                __esp =  &(__esp[2]);
                                __ebx = caml_make_vect;
                                __esp[3] = caml_make_vect;
                                __ecx = 1;
                                __eax = __esp[2];
                                __edx = __esp[1];
                                __esi =  *__esp;
                                L124();
                                __eax = 1;
                                __ebx = __esp[4];
                                __ecx = __esp[1];
                                __edx = __esp[2];
                                __esi =  *__esp;
                                L124();
                                __ebp = 1;
                                __edx = 1;
                                __eax = __esp[1];
                                __ebx = __esp[2];
                                __ecx = __esp[3];
                                __esi = __eax;
                                __edi = __esp[4];
                                caml_extra_params = 1;
                                __ebp = __esp[5];
                                 *134694272 = __esp[5];
                                __esp =  &(__esp[8]);
                                goto L51;
                            }
                        }
                    } else {
                        __ecx = 1;
                        __eax = 1;
                        __esp =  &(__esp[8]);
                        while(1) {
L73:
                            __esp = __esp - 40;
                            __edi = 1;
                            __edx = __edx + -2;
                            if(1 > __edx) {
                                break;
                            }
                            __esp[4] = __edx;
                            __esp[3] = 1;
                            __esp[6] = __esi;
                            __esp[5] = __ecx;
                            __esp[7] = __ebx;
                             *__esp = __eax;
                            do {
                                __eax =  *__esp;
                                __eax =  *__esp + __edi - 1;
                                __esp[1] = __eax;
                                __ecx = __esp[6];
                                __ecx =  *(__esp[6] + 16);
                                __edx =  *(__ecx - 4);
                                __esp[2] =  *(__ecx - 4);
                                __esp[2] = __esp[2] & 255;
                                if((__esp[2] & 255) == 254) {
                                    __esp[2] = __esp[2] >> 10;
                                    if(__esp[2] >> 10 <= __eax) {
                                        goto L122;
                                    } else {
                                        while(1) {
                                            __eax = caml_young_ptr;
                                            __eax = caml_young_ptr - 12;
                                            caml_young_ptr = __eax;
                                            if(__eax >= caml_young_limit) {
                                                break;
                                            }
                                            __eax = caml_call_gc();
                                        }
                                        __edx = __eax + 4;
                                         *(__edx - 4) = 2301;
                                        __eax = __esp[1];
                                        __fp0 =  *((long long*)(__ecx + __eax * 4 - 4));
                                         *__edx =  *((long long*)(__ecx + __eax * 4 - 4));
                                        __esp[1] = __edx;
                                        goto L81;
                                    }
                                } else {
                                    __esp[2] = __esp[2] >> 9;
                                    if(__esp[2] >> 9 <= __eax) {
L123:
                                        __eax = caml_ml_array_bound_error();
                                        __esp = __esp - 24;
                                        if(__edx > 11) {
                                             *__esp = __esi;
                                            __esp[2] = __ecx;
                                            __esp[5] = __ebx;
                                            __esp[4] = __eax;
                                            __esi = __edx;
                                            __esi = __edx >> 1;
                                            if(__esi < 0) {
                                                __esi = __esi + 1;
                                            }
                                            __esi = __esi >> 1;
                                            __esi = __esi + __esi + 1;
                                            __esp[1] = __esi;
                                            __edx = __edx - __esi;
                                            __esp[3] = __edx;
                                            __ecx = __ecx + __esi - 1;
                                            __eax = __eax + __esi - 1;
                                            __edx = __esp[3];
                                            __esi =  *__esp;
                                            L124();
                                            __ebx = __esp[3];
                                            __eax = __esp[4];
                                            __ecx = __esp[4] + __esp[3] - 1;
                                            __esi =  *__esp;
                                            __ebx =  *( *__esp + 12);
                                            __edx = __esp[1];
                                            L124();
                                            __eax =  *__esp;
                                            __eax =  *( *__esp + 16);
                                             *__esp =  *( *__esp + 16);
                                            __ebx = __esp[1];
                                            __ebp = __esp[2];
                                            __edx = __ebp + __ebx - 1;
                                            __esi = __esp[3];
                                            __eax = __esp[4];
                                            __eax = __esp[4] + __esi - 1;
                                            __ecx = __esp[5];
                                            __edi = __ecx;
                                            caml_extra_params = __ebp;
                                            __ebp =  *__esp;
                                             *134694272 =  *__esp;
                                            __esp =  &(__esp[6]);
L51:
                                            __esp = __esp - 28;
                                             *__esp = __eax;
                                            __esp[1] = __ecx;
                                            __esp[4] = __edx;
                                            __esp[2] = __edi;
                                            __eax = caml_extra_params;
                                            __esp[3] = caml_extra_params;
                                            __ebp =  *134694272;
                                            __ecx =  *__esp;
                                            __edx = __ecx + __ebx - 1;
                                            __eax = __esp[4];
                                            __esi = __esp[4] + __esi - 1;
                                            while(1) {
                                                __eax = caml_young_ptr;
                                                __eax = caml_young_ptr - 40;
                                                caml_young_ptr = __eax;
                                                if(__eax >= caml_young_limit) {
                                                    break;
                                                }
                                                __eax = caml_call_gc();
                                            }
                                            __edi = __eax + 4;
                                             *(__edi - 4) = 9463;
                                             *__edi = caml_curry5;
                                             *((intOrPtr*)(__edi + 4)) = 11;
                                             *((intOrPtr*)(__edi + 8)) =  &camlArray__code_begin;
                                            __eax =  *(__ebp + 12);
                                             *(__edi + 12) =  *(__ebp + 12);
                                            __eax =  *(__ebp + 16);
                                             *(__edi + 16) =  *(__ebp + 16);
                                            __ebx = __esp[1];
                                             *(__edi + 20) = __ebx;
                                            __eax = __esp[2];
                                             *(__edi + 24) = __esp[2];
                                             *(__edi + 28) = __edx;
                                             *(__edi + 32) = __esi;
                                            __eax =  *(__ebx - 4);
                                            __eax = __eax & 255;
                                            if((__eax & 255) == 254) {
                                                if(__eax <= __esp[4]) {
                                                    goto L71;
                                                } else {
                                                    while(1) {
                                                        __eax = caml_young_ptr;
                                                        __eax = caml_young_ptr - 12;
                                                        caml_young_ptr = __eax;
                                                        if(__eax >= caml_young_limit) {
                                                            break;
                                                        }
                                                        __eax = caml_call_gc();
                                                    }
                                                    __edx = __eax + 4;
                                                     *(__edx - 4) = 2301;
                                                    __eax = __esp[4];
                                                    __fp0 =  *((long long*)(__ebx + __eax * 4 - 4));
                                                     *__edx =  *((long long*)(__ebx + __eax * 4 - 4));
                                                    goto L59;
                                                }
                                            } else {
                                                if(__eax <= __esp[4]) {
L72:
                                                    __eax = caml_ml_array_bound_error();
                                                    goto L73;
                                                } else {
                                                    __eax = __esp[4];
                                                    __edx =  *(__ebx + __esp[4] * 2 - 2);
L59:
                                                    __esi =  *(__ebp + 16);
                                                    __eax =  *(__esi - 4);
                                                    __ebx = __eax;
                                                    __ebx = __eax & 255;
                                                    if(__ebx == 254) {
                                                        if(__eax <= __ecx) {
                                                            __eax = caml_ml_array_bound_error();
                                                            goto L70;
                                                        } else {
                                                            while(1) {
                                                                __eax = caml_young_ptr;
                                                                __eax = caml_young_ptr - 12;
                                                                caml_young_ptr = __eax;
                                                                if(__eax >= caml_young_limit) {
                                                                    break;
                                                                }
                                                                __eax = caml_call_gc();
                                                            }
                                                            __ebx = __eax + 4;
                                                             *(__ebx - 4) = 2301;
                                                            __fp0 =  *((long long*)(__esi + __ecx * 4 - 4));
                                                             *__ebx =  *((long long*)(__esi + __ecx * 4 - 4));
                                                            goto L65;
                                                        }
                                                    } else {
                                                        if(__eax <= __ecx) {
L70:
                                                            __eax = caml_ml_array_bound_error();
L71:
                                                            __eax = caml_ml_array_bound_error();
                                                            goto L72;
                                                        } else {
                                                            __ebx =  *(__esi + __ecx * 2 - 2);
L65:
                                                            __eax = __ecx;
                                                            __ecx = __esp[4];
                                                            __esi = __esp[3];
                                                            __esp =  &(__esp[7]);
                                                            __esp = __esp - 32;
                                                            while(1) {
L6:
                                                                __esp[1] = __eax;
                                                                __eax = __ebx;
                                                                __esp[5] = __eax;
                                                                __esp[2] = __ecx;
                                                                __esp[3] = __edx;
                                                                __esp[4] = __esi;
                                                                 *__esp = __edi;
                                                                __ecx =  *(__edi + 12);
                                                                __ebx = __edx;
                                                                caml_apply2();
                                                                if(__eax > 1) {
                                                                    break;
                                                                }
                                                                __edi =  *__esp;
                                                                __eax =  *(__edi + 24);
                                                                __ebx =  *(__eax - 4);
                                                                __ebx = __ebx & 255;
                                                                if((__ebx & 255) == 254) {
                                                                    __ebx = __ebx >> 10;
                                                                    __esi = __esp[4];
                                                                    if(__ebx <= __esi) {
                                                                        goto L43;
                                                                    } else {
                                                                        __ebx = __esp[5];
                                                                        __fp0 =  *(__esp[5]);
                                                                         *((long long*)(__eax + __esi * 4 - 4)) =  *(__esp[5]);
                                                                        goto L12;
                                                                    }
                                                                } else {
                                                                    __ebx = __ebx >> 9;
                                                                    __esi = __esp[4];
                                                                    if(__ebx <= __esi) {
L44:
                                                                        __eax = caml_ml_array_bound_error();
                                                                        while(__ebx != 1) {
                                                                            __ecx =  *(__ebx + 4);
                                                                            __ebx =  *__ebx;
                                                                            __ebx =  *(__ebx - 4);
                                                                            __ebx = __ebx & 255;
                                                                            if((__ebx & 255) == 254) {
                                                                                __ebx = __ebx >> 10;
                                                                            } else {
                                                                                __ebx = __ebx >> 9;
                                                                            }
                                                                            __eax = __eax + __ebx;
                                                                            __eax = __eax - 1;
                                                                            __ebx = __ecx;
                                                                        }
                                                                        return __eax;
                                                                    } else {
                                                                        __ebx = __esp[5];
                                                                        _push(__ebx);
                                                                        _push(__eax);
                                                                        __eax = caml_modify(__ebx, __edi, __esi);
                                                                        __esp =  &(__esp[2]);
L12:
                                                                        __ecx = __esp[1];
                                                                        __ecx = __esp[1] + 2;
                                                                        __eax =  *(__edi + 28);
                                                                        if(__ecx >=  *(__edi + 28)) {
                                                                            __ebp =  *(__edi + 32);
                                                                            __ebx = __esp[2];
                                                                             *(__edi + 32) - __ebx =  *(__edi + 32) - __ebx + 1;
                                                                            __esi = __esi + 2;
                                                                            __ecx =  *(__edi + 24);
                                                                            __eax =  *(__edi + 20);
                                                                            __edx = __esi;
                                                                            __esi =  *(__edi + 32) - __ebx + 1;
                                                                            __esp =  &(__esp[8]);
L129:
                                                                            __esp = __esp - 24;
                                                                            __edi = __eax;
                                                                            __esp[2] = __ecx;
                                                                            __ebp = __edx;
                                                                            if(__esi < 1 || __ebx < 1) {
L163:
                                                                                __eax = "Array.blit";
                                                                                __esp =  &(__esp[6]);
L2:
                                                                                _t434 = caml_young_ptr - 12;
                                                                                caml_young_ptr = _t434;
                                                                                if(_t434 >= caml_young_limit) {
                                                                                    _t436 = _t434 + 4;
                                                                                     *((intOrPtr*)(_t436 - 4)) = 2048;
                                                                                     *_t436 =  &caml_exn_Invalid_argument;
                                                                                    _t436[1] = __eax;
                                                                                    caml_raise_exn(_t436);
                                                                                }
                                                                                caml_call_gc();
                                                                                goto L2;
                                                                            }
                                                                            __ecx =  *(__edi - 4);
                                                                            __ecx = __ecx & 255;
                                                                            if((__ecx & 255) == 254) {
                                                                                __eax = __ecx;
                                                                                __eax = __ecx >> 10;
                                                                            } else {
                                                                                __eax = __ecx;
                                                                                __eax = __ecx >> 9;
                                                                            }
                                                                            __eax = __eax | 1;
                                                                            __eax = __eax - __esi;
                                                                            if(__ebx > __eax || __ebp < 1) {
                                                                                goto L163;
                                                                            }
                                                                            __eax = __esp[2];
                                                                            __ecx =  *(__esp[2] - 4);
                                                                            __ecx = __ecx & 255;
                                                                            if((__ecx & 255) == 254) {
                                                                                __eax = __ecx;
                                                                                __eax = __ecx >> 10;
                                                                            } else {
                                                                                __eax = __ecx;
                                                                                __eax = __ecx >> 9;
                                                                            }
                                                                            __eax = __eax | 1;
                                                                            __eax = __eax - __esi;
                                                                            if(__ebp > __eax) {
                                                                                goto L163;
                                                                            }
                                                                            if(__ebx >= __ebp) {
                                                                                __eax = 1;
                                                                                __esp[3] = 1;
                                                                                __esi = __esi + -2;
                                                                                if(__esp[3] <= __esi) {
                                                                                    __esp[1] = __ebx;
                                                                                     *__esp = __edi;
                                                                                    do {
                                                                                        __ebx = __esp[1];
                                                                                        __eax = __esp[3];
                                                                                        __ebx = __esp[1] + __esp[3] - 1;
                                                                                        __eax =  *__esp;
                                                                                        __ecx =  *(__eax - 4) & 255;
                                                                                        if(( *(__eax - 4) & 255) == 254) {
                                                                                            while(1) {
                                                                                                __eax = caml_young_ptr;
                                                                                                __eax = caml_young_ptr - 12;
                                                                                                caml_young_ptr = __eax;
                                                                                                if(__eax >= caml_young_limit) {
                                                                                                    break;
                                                                                                }
                                                                                                __eax = caml_call_gc();
                                                                                            }
                                                                                            __ecx = __eax + 4;
                                                                                             *(__ecx - 4) = 2301;
                                                                                            __eax =  *__esp;
                                                                                            __fp0 =  *((long long*)(__eax + __ebx * 4 - 4));
                                                                                             *__ecx =  *((long long*)(__eax + __ebx * 4 - 4));
                                                                                            __ebx = __ecx;
                                                                                        } else {
                                                                                            __ebx =  *(__eax + __ebx * 2 - 2);
                                                                                        }
                                                                                        __ecx = __esp[3];
                                                                                        __eax = __ebp;
                                                                                        __eax = __ebp + __esp[3] - 1;
                                                                                        __ecx = __esp[2];
                                                                                        __ecx =  *(__esp[2] - 4) & 255;
                                                                                        if(( *(__esp[2] - 4) & 255) == 254) {
                                                                                            __fp0 =  *__ebx;
                                                                                            __ebx = __esp[2];
                                                                                             *((long long*)(__esp[2] + __eax * 4 - 4)) = __fp0;
                                                                                        } else {
                                                                                            _push(__ebx);
                                                                                            __ebx = __esp[3];
                                                                                            _push(__eax);
                                                                                            __eax = caml_modify(__ebx, __edi, __esi);
                                                                                            __esp =  &(__esp[2]);
                                                                                        }
                                                                                        __ebx = __esp[3];
                                                                                        __esp[3] = __esp[3] + 2;
                                                                                        __esp[3] = __esp[3] + 2;
                                                                                    } while(__esp[3] != __esi);
                                                                                }
                                                                                __eax = 1;
                                                                                __esp =  &(__esp[6]);
                                                                                return 1;
                                                                            } else {
                                                                                __esi = __esi + -2;
                                                                                if(__esi >= 1) {
                                                                                    __esp[1] = __ebx;
                                                                                    do {
                                                                                        __eax = __esp[1];
                                                                                        __ebx = __esp[1] + __esi - 1;
                                                                                        __eax =  *(__edi - 4) & 255;
                                                                                        if(( *(__edi - 4) & 255) == 254) {
                                                                                            while(1) {
                                                                                                __eax = caml_young_ptr;
                                                                                                __eax = caml_young_ptr - 12;
                                                                                                caml_young_ptr = __eax;
                                                                                                if(__eax >= caml_young_limit) {
                                                                                                    break;
                                                                                                }
                                                                                                __eax = caml_call_gc();
                                                                                            }
                                                                                            __eax = __eax + 4;
                                                                                             *(__eax - 4) = 2301;
                                                                                            __fp0 =  *((long long*)(__edi + __ebx * 4 - 4));
                                                                                             *__eax =  *((long long*)(__edi + __ebx * 4 - 4));
                                                                                            __ebx = __eax;
                                                                                        } else {
                                                                                            __ebx =  *(__edi + __ebx * 2 - 2);
                                                                                        }
                                                                                        __eax = __ebp;
                                                                                        __eax = __ebp + __esi - 1;
                                                                                        __ecx = __esp[2];
                                                                                        __ecx =  *(__esp[2] - 4) & 255;
                                                                                        if(( *(__esp[2] - 4) & 255) == 254) {
                                                                                            __fp0 =  *__ebx;
                                                                                            __ebx = __esp[2];
                                                                                             *((long long*)(__esp[2] + __eax * 4 - 4)) = __fp0;
                                                                                        } else {
                                                                                            _push(__ebx);
                                                                                            __ebx = __esp[3];
                                                                                            _push(__eax);
                                                                                            __eax = caml_modify(__ebx, __edi, __esi);
                                                                                            __esp =  &(__esp[2]);
                                                                                        }
                                                                                        __ebx = __esi;
                                                                                        __esi = __esi - 2;
                                                                                        __esi = __esi - 2;
                                                                                    } while(__ebx != 1);
                                                                                }
                                                                                __eax = 1;
                                                                                __esp =  &(__esp[6]);
                                                                                return 1;
                                                                            }
                                                                        } else {
                                                                            __ebx =  *(__edi + 16);
                                                                            __edx =  *(__ebx - 4);
                                                                            __edx = __edx & 255;
                                                                            if((__edx & 255) == 254) {
                                                                                if(__edx >> 10 <= __ecx) {
L41:
                                                                                    __eax = caml_ml_array_bound_error();
                                                                                    goto L42;
                                                                                } else {
                                                                                    while(1) {
                                                                                        __eax = caml_young_ptr;
                                                                                        __eax = caml_young_ptr - 12;
                                                                                        caml_young_ptr = __eax;
                                                                                        if(__eax >= caml_young_limit) {
                                                                                            break;
                                                                                        }
                                                                                        __eax = caml_call_gc();
                                                                                    }
                                                                                    __edx = __eax + 4;
                                                                                     *(__edx - 4) = 2301;
                                                                                    __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                                     *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                                    __ebx = __edx;
                                                                                    goto L19;
                                                                                }
                                                                            } else {
                                                                                if(__edx >> 9 <= __ecx) {
L42:
                                                                                    __eax = caml_ml_array_bound_error();
L43:
                                                                                    __eax = caml_ml_array_bound_error();
                                                                                    goto L44;
                                                                                } else {
                                                                                    __ebx =  *(__ebx + __ecx * 2 - 2);
L19:
                                                                                    __esi = __esi + 2;
                                                                                    __eax = __ecx;
                                                                                    __ecx = __esp[2];
                                                                                    __edx = __esp[3];
                                                                                    continue;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                goto L267;
                                                            }
                                                            __edi =  *__esp;
                                                            __eax =  *(__edi + 24);
                                                            __ebx =  *(__eax - 4);
                                                            __ebx = __ebx & 255;
                                                            if((__ebx & 255) == 254) {
                                                                __ebx = __ebx >> 10;
                                                                __esi = __esp[4];
                                                                if(__ebx <= __esi) {
                                                                    goto L39;
                                                                } else {
                                                                    __ebx = __esp[3];
                                                                    __fp0 =  *(__esp[3]);
                                                                     *((long long*)(__eax + __esi * 4 - 4)) =  *(__esp[3]);
                                                                    goto L26;
                                                                }
                                                            } else {
                                                                __ebx = __ebx >> 9;
                                                                __esi = __esp[4];
                                                                if(__ebx <= __esi) {
L40:
                                                                    __eax = caml_ml_array_bound_error();
                                                                    goto L41;
                                                                } else {
                                                                    __ebx = __esp[3];
                                                                    _push(__ebx);
                                                                    _push(__eax);
                                                                    __eax = caml_modify(__ebx, __edi, __esi);
                                                                    __esp =  &(__esp[2]);
L26:
                                                                    __ecx = __esp[2];
                                                                    __ecx = __esp[2] + 2;
                                                                    __eax =  *(__edi + 32);
                                                                    if(__ecx >=  *(__edi + 32)) {
                                                                        __ebp =  *(__edi + 28);
                                                                        __ebx = __esp[1];
                                                                         *(__edi + 28) - __ebx =  *(__edi + 28) - __ebx + 1;
                                                                        __esi = __esi + 2;
                                                                        __ecx =  *(__edi + 24);
                                                                        __eax =  *(__edi + 16);
                                                                        __edx = __esi;
                                                                        __esi =  *(__edi + 28) - __ebx + 1;
                                                                        __esp =  &(__esp[8]);
                                                                        goto L129;
                                                                    } else {
                                                                        __ebx =  *(__edi + 20);
                                                                        __edx =  *(__ebx - 4);
                                                                        __edx = __edx & 255;
                                                                        if((__edx & 255) == 254) {
                                                                            if(__edx >> 10 <= __ecx) {
                                                                                __eax = caml_ml_array_bound_error();
                                                                                goto L38;
                                                                            } else {
                                                                                while(1) {
                                                                                    __eax = caml_young_ptr;
                                                                                    __eax = caml_young_ptr - 12;
                                                                                    caml_young_ptr = __eax;
                                                                                    if(__eax >= caml_young_limit) {
                                                                                        break;
                                                                                    }
                                                                                    __eax = caml_call_gc();
                                                                                }
                                                                                __edx = __eax + 4;
                                                                                 *(__edx - 4) = 2301;
                                                                                __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                                 *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                                goto L33;
                                                                            }
                                                                        } else {
                                                                            if(__edx >> 9 <= __ecx) {
L38:
                                                                                __eax = caml_ml_array_bound_error();
L39:
                                                                                __eax = caml_ml_array_bound_error();
                                                                                goto L40;
                                                                            } else {
                                                                                __edx =  *(__ebx + __ecx * 2 - 2);
L33:
                                                                                __esi = __esi + 2;
                                                                                __eax = __esp[1];
                                                                                __ebx = __esp[5];
                                                                                goto L6;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            __esi =  *(__esi + 20);
                                            __esp =  &(__esp[6]);
                                            goto L73;
                                        }
                                    } else {
                                        __edx =  *(__ecx + __eax * 2 - 2);
                                        __esp[1] =  *(__ecx + __eax * 2 - 2);
                                        while(1) {
L81:
                                            __eax = caml_young_ptr;
                                            __eax = caml_young_ptr - 8;
                                            caml_young_ptr = __eax;
                                            if(__eax >= caml_young_limit) {
                                                break;
                                            }
                                            __eax = caml_call_gc();
                                        }
                                        __esi = __eax + 4;
                                        __esp[2] = __esi;
                                         *(__esi - 4) = 1024;
                                        __eax = __esp[5];
                                        __eax = __esp[5] + __edi - 3;
                                         *__esi = __esp[5] + __edi - 3;
                                        while(1) {
                                            __ecx =  *__esi;
                                            __eax = __esp[5];
                                            if( *__esi < __esp[5]) {
                                                break;
                                            }
                                            __ecx =  *__esi;
                                            __eax =  *(__ebx - 4);
                                            __eax = __eax & 255;
                                            if((__eax & 255) == 254) {
                                                if(__eax <= __ecx) {
                                                    goto L120;
                                                } else {
                                                    while(1) {
                                                        __eax = caml_young_ptr;
                                                        __eax = caml_young_ptr - 12;
                                                        caml_young_ptr = __eax;
                                                        if(__eax >= caml_young_limit) {
                                                            break;
                                                        }
                                                        __eax = caml_call_gc();
                                                    }
                                                    __eax = __eax + 4;
                                                     *(__eax - 4) = 2301;
                                                    __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                     *__eax =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                    goto L90;
                                                }
                                            } else {
                                                if(__eax <= __ecx) {
L121:
                                                    __eax = caml_ml_array_bound_error();
L122:
                                                    __eax = caml_ml_array_bound_error();
                                                    goto L123;
                                                } else {
                                                    __eax =  *(__ebx + __ecx * 2 - 2);
L90:
                                                    __ebx = __esp[6];
                                                    __ecx =  *(__esp[6] + 12);
                                                    __ebx = __esp[1];
                                                    caml_apply2();
                                                    if(__eax <= 1) {
                                                        break;
                                                    } else {
                                                        __esi = __esp[2];
                                                        __ecx =  *__esi;
                                                        __ebx = __esp[7];
                                                        __eax =  *(__ebx - 4);
                                                        __eax = __eax & 255;
                                                        if((__eax & 255) == 254) {
                                                            if(__eax <= __ecx) {
                                                                goto L118;
                                                            } else {
                                                                while(1) {
                                                                    __eax = caml_young_ptr;
                                                                    __eax = caml_young_ptr - 12;
                                                                    caml_young_ptr = __eax;
                                                                    if(__eax >= caml_young_limit) {
                                                                        break;
                                                                    }
                                                                    __eax = caml_call_gc();
                                                                }
                                                                __edx = __eax + 4;
                                                                 *(__edx - 4) = 2301;
                                                                __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                 *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                goto L97;
                                                            }
                                                        } else {
                                                            if(__eax <= __ecx) {
L119:
                                                                __eax = caml_ml_array_bound_error();
L120:
                                                                __eax = caml_ml_array_bound_error();
                                                                goto L121;
                                                            } else {
                                                                __edx =  *(__ebx + __ecx * 2 - 2);
L97:
                                                                __eax =  *__esi;
                                                                __eax =  *__esi + 2;
                                                                __ecx =  *(__ebx - 4);
                                                                __edi = __ecx;
                                                                __edi = __ecx & 255;
                                                                if(__edi == 254) {
                                                                    if(__ecx <= __eax) {
L116:
                                                                        __eax = caml_ml_array_bound_error();
                                                                        goto L117;
                                                                    } else {
                                                                        __fp0 =  *__edx;
                                                                         *((long long*)(__ebx + __eax * 4 - 4)) =  *__edx;
                                                                        goto L102;
                                                                    }
                                                                } else {
                                                                    if(__ecx <= __eax) {
L117:
                                                                        __eax = caml_ml_array_bound_error();
L118:
                                                                        __eax = caml_ml_array_bound_error();
                                                                        goto L119;
                                                                    } else {
                                                                        _push(__edx);
                                                                        _push(__eax);
                                                                        __eax = caml_modify(__ebx, __edi, __esi);
                                                                        __esp =  &(__esp[2]);
L102:
                                                                         *__esi =  *__esi + -2;
                                                                        continue;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            goto L267;
                                        }
                                        __esp[2] =  *(__esp[2]);
                                        __eax =  *(__esp[2]) + 2;
                                        __ebx = __esp[7];
                                        __ecx =  *(__ebx - 4);
                                        __ecx = __ecx & 255;
                                        if((__ecx & 255) == 254) {
                                            if(__ecx <= __eax) {
                                                __eax = caml_ml_array_bound_error();
                                                goto L115;
                                            } else {
                                                __ecx = __esp[1];
                                                __fp0 =  *(__esp[1]);
                                                 *((long long*)(__ebx + __eax * 4 - 4)) =  *(__esp[1]);
                                                goto L108;
                                            }
                                        } else {
                                            if(__ecx <= __eax) {
L115:
                                                __eax = caml_ml_array_bound_error();
                                                goto L116;
                                            } else {
                                                __ecx = __esp[1];
                                                _push(__esp[1]);
                                                _push(__eax);
                                                __eax = caml_modify(__ebx, __edi, __esi);
                                                __esp =  &(__esp[2]);
                                                goto L108;
                                            }
                                        }
                                    }
                                }
                                goto L267;
L108:
                                __edi = __esp[3];
                                __ecx = __edi;
                                __edi = __edi + 2;
                                __esp[3] = __edi;
                                __eax = __esp[4];
                            } while(__ecx != __esp[4]);
                            break;
                        }
                        __eax = 1;
                        __esp =  &(__esp[0xa]);
                        return 1;
                    }
                } else {
                    __ecx =  *(__edx + __ebx * 2 - 2);
                    goto L178;
                }
            }
            goto L267;
L178:
            __eax = __esp[5];
            __edx = __esp[1];
            __eax = camlArray__trickle_1165(__esp[5], __ecx, __esp[1]);
            __ebx = __esp[3];
            __eax = __ebx;
            __ebx = __ebx - 2;
            __esp[3] = __ebx;
        } while(__eax != 1);
        goto L179;
    }
L267:
}

signed int camlArray__stable_sort_1188(
    signed int __eax,                      // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08052D50
    signed int _t331;                      // _t331
    intOrPtr* _t333;                       // _t333

    __esp = __esp - 32;
    __ecx = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 76;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __eax = __eax + 4;
     *(__eax - 4) = 5367;
     *__eax = caml_curry7;
     *(__eax + 4) = 15;
     *((intOrPtr*)(__eax + 8)) = camlArray__merge_1191;
     *(__eax + 12) = __ecx;
     *(__eax + 16) = __ebx;
    __esi = __eax + 24;
     *(__esi - 4) = 5367;
     *__esi = caml_curry4;
     *((intOrPtr*)(__esi + 4)) = 9;
     *((intOrPtr*)(__esi + 8)) = camlArray__isortto_1209;
     *(__esi + 12) = __ecx;
     *(__esi + 16) = __ebx;
    __ecx = __eax + 48;
     *(__ecx - 4) = 6391;
     *__ecx = caml_curry4;
     *((intOrPtr*)(__ecx + 4)) = 9;
     *((intOrPtr*)(__ecx + 8)) = camlArray__sortto_1217;
     *(__ecx + 12) = __ebx;
     *(__ecx + 16) = __eax;
     *(__ecx + 20) = __esi;
    __edx =  *(__ebx - 4);
    __edx = __edx & 255;
    if((__edx & 255) == 254) {
        __edx = __edx >> 10;
    } else {
        __edx = __edx >> 9;
    }
    __edx = __edx | 1;
    if(__edx > 11) {
         *__esp = __ecx;
        __esp[5] = __eax;
        __esp[4] = __ebx;
        __eax = __edx;
        __eax = __edx >> 1;
        if(__eax < 0) {
            __eax = __eax + 1;
        }
        __eax = __eax >> 1;
        __eax = __eax + __eax + 1;
        __esp[2] = __eax;
        __edx = __edx - __eax;
        __edx = __edx + 1;
        __esp[1] = __edx;
        __eax =  *(__ebx - 4);
        __eax = __eax & 255;
        if((__eax & 255) == 254) {
            if(__eax <= 1) {
                __eax = caml_ml_array_bound_error();
                goto L184;
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 12;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    __eax = caml_call_gc();
                }
                __eax = __eax + 4;
                 *(__eax - 4) = 2301;
                __fp0 =  *__ebx;
                 *__eax =  *__ebx;
                goto L180;
            }
        } else {
            if(__eax <= 1) {
L184:
                __eax = caml_ml_array_bound_error();
                __eax =  &camlArray__21;
                camlArray =  &camlArray__21;
                __eax =  &camlArray__20;
                 *134683148 =  &camlArray__20;
                __eax =  *134683148;
                 *134683152 =  *134683148;
                __eax =  &camlArray__19;
                 *134683168 =  &camlArray__19;
                __eax =  &camlArray__18;
                 *134683156 =  &camlArray__18;
                __eax =  &camlArray__17;
                 *134683224 =  &camlArray__17;
                __eax =  &camlArray__16;
                 *134683160 =  &camlArray__16;
                __eax =  &camlArray__15;
                 *134683164 =  &camlArray__15;
                __eax =  &camlArray__14;
                 *134683172 =  &camlArray__14;
                __eax =  &camlArray__13;
                 *134683176 =  &camlArray__13;
                __eax =  &camlArray__12;
                 *134683188 =  &camlArray__12;
                __eax =  &camlArray__11;
                 *134683192 =  &camlArray__11;
                __eax =  &camlArray__10;
                 *134683196 =  &camlArray__10;
                __eax =  &camlArray__9;
                 *134683200 =  &camlArray__9;
                __eax =  &camlArray__8;
                 *134683180 =  &camlArray__8;
                __eax =  &camlArray__7;
                 *134683228 =  &camlArray__7;
                __eax =  &camlArray__6;
                 *134683184 =  &camlArray__6;
                __eax =  &camlArray__5;
                 *134683204 =  &camlArray__5;
                __eax =  &camlArray__4;
                 *134683208 =  &camlArray__4;
                __eax = caml_alloc1();
                __eax = __eax + 4;
                 *(__eax - 4) = 1024;
                 *__eax = "Array.Bottom";
                 *134683232 = __eax;
                __eax =  &camlArray__2;
                 *134683212 =  &camlArray__2;
                 *134683236 = 11;
                __eax =  &camlArray__1;
                 *134683216 =  &camlArray__1;
                __eax =  *134683216;
                 *134683220 =  *134683216;
                __eax = 1;
                return 1;
            } else {
                __eax =  *__ebx;
L180:
                _push(__eax);
                _push(__edx);
                __eax = caml_make_vect;
                caml_c_call();
                __esp =  &(__esp[2]);
                __ebx = caml_make_vect;
                __esp[3] = caml_make_vect;
                __ecx = 1;
                __eax = __esp[2];
                __edx = __esp[1];
                __esi =  *__esp;
                L124();
                __eax = 1;
                __ebx = __esp[4];
                __ecx = __esp[1];
                __edx = __esp[2];
                __esi =  *__esp;
                L124();
                __ebp = 1;
                __edx = 1;
                __eax = __esp[1];
                __ebx = __esp[2];
                __ecx = __esp[3];
                __esi = __eax;
                __edi = __esp[4];
                caml_extra_params = 1;
                __ebp = __esp[5];
                 *134694272 = __esp[5];
                __esp =  &(__esp[8]);
                goto L51;
            }
        }
    } else {
        __ecx = 1;
        __eax = 1;
        __esp =  &(__esp[8]);
        while(1) {
L73:
            __esp = __esp - 40;
            __edi = 1;
            __edx = __edx + -2;
            if(1 > __edx) {
                break;
            }
            __esp[4] = __edx;
            __esp[3] = 1;
            __esp[6] = __esi;
            __esp[5] = __ecx;
            __esp[7] = __ebx;
             *__esp = __eax;
            do {
                __eax =  *__esp;
                __eax =  *__esp + __edi - 1;
                __esp[1] = __eax;
                __ecx = __esp[6];
                __ecx =  *(__esp[6] + 16);
                __edx =  *(__ecx - 4);
                __esp[2] =  *(__ecx - 4);
                __esp[2] = __esp[2] & 255;
                if((__esp[2] & 255) == 254) {
                    __esp[2] = __esp[2] >> 10;
                    if(__esp[2] >> 10 <= __eax) {
                        goto L122;
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 12;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            __eax = caml_call_gc();
                        }
                        __edx = __eax + 4;
                         *(__edx - 4) = 2301;
                        __eax = __esp[1];
                        __fp0 =  *((long long*)(__ecx + __eax * 4 - 4));
                         *__edx =  *((long long*)(__ecx + __eax * 4 - 4));
                        __esp[1] = __edx;
                        goto L81;
                    }
                } else {
                    __esp[2] = __esp[2] >> 9;
                    if(__esp[2] >> 9 <= __eax) {
L123:
                        __eax = caml_ml_array_bound_error();
                        __esp = __esp - 24;
                        if(__edx > 11) {
                             *__esp = __esi;
                            __esp[2] = __ecx;
                            __esp[5] = __ebx;
                            __esp[4] = __eax;
                            __esi = __edx;
                            __esi = __edx >> 1;
                            if(__esi < 0) {
                                __esi = __esi + 1;
                            }
                            __esi = __esi >> 1;
                            __esi = __esi + __esi + 1;
                            __esp[1] = __esi;
                            __edx = __edx - __esi;
                            __esp[3] = __edx;
                            __ecx = __ecx + __esi - 1;
                            __eax = __eax + __esi - 1;
                            __edx = __esp[3];
                            __esi =  *__esp;
                            L124();
                            __ebx = __esp[3];
                            __eax = __esp[4];
                            __ecx = __esp[4] + __esp[3] - 1;
                            __esi =  *__esp;
                            __ebx =  *( *__esp + 12);
                            __edx = __esp[1];
                            L124();
                            __eax =  *__esp;
                            __eax =  *( *__esp + 16);
                             *__esp =  *( *__esp + 16);
                            __ebx = __esp[1];
                            __ebp = __esp[2];
                            __edx = __ebp + __ebx - 1;
                            __esi = __esp[3];
                            __eax = __esp[4];
                            __eax = __esp[4] + __esi - 1;
                            __ecx = __esp[5];
                            __edi = __ecx;
                            caml_extra_params = __ebp;
                            __ebp =  *__esp;
                             *134694272 =  *__esp;
                            __esp =  &(__esp[6]);
L51:
                            __esp = __esp - 28;
                             *__esp = __eax;
                            __esp[1] = __ecx;
                            __esp[4] = __edx;
                            __esp[2] = __edi;
                            __eax = caml_extra_params;
                            __esp[3] = caml_extra_params;
                            __ebp =  *134694272;
                            __ecx =  *__esp;
                            __edx = __ecx + __ebx - 1;
                            __eax = __esp[4];
                            __esi = __esp[4] + __esi - 1;
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 40;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __edi = __eax + 4;
                             *(__edi - 4) = 9463;
                             *__edi = caml_curry5;
                             *((intOrPtr*)(__edi + 4)) = 11;
                             *((intOrPtr*)(__edi + 8)) =  &camlArray__code_begin;
                            __eax =  *(__ebp + 12);
                             *(__edi + 12) =  *(__ebp + 12);
                            __eax =  *(__ebp + 16);
                             *(__edi + 16) =  *(__ebp + 16);
                            __ebx = __esp[1];
                             *(__edi + 20) = __ebx;
                            __eax = __esp[2];
                             *(__edi + 24) = __esp[2];
                             *(__edi + 28) = __edx;
                             *(__edi + 32) = __esi;
                            __eax =  *(__ebx - 4);
                            __eax = __eax & 255;
                            if((__eax & 255) == 254) {
                                if(__eax <= __esp[4]) {
                                    goto L71;
                                } else {
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 12;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        __eax = caml_call_gc();
                                    }
                                    __edx = __eax + 4;
                                     *(__edx - 4) = 2301;
                                    __eax = __esp[4];
                                    __fp0 =  *((long long*)(__ebx + __eax * 4 - 4));
                                     *__edx =  *((long long*)(__ebx + __eax * 4 - 4));
                                    goto L59;
                                }
                            } else {
                                if(__eax <= __esp[4]) {
L72:
                                    __eax = caml_ml_array_bound_error();
                                    goto L73;
                                } else {
                                    __eax = __esp[4];
                                    __edx =  *(__ebx + __esp[4] * 2 - 2);
L59:
                                    __esi =  *(__ebp + 16);
                                    __eax =  *(__esi - 4);
                                    __ebx = __eax;
                                    __ebx = __eax & 255;
                                    if(__ebx == 254) {
                                        if(__eax <= __ecx) {
                                            __eax = caml_ml_array_bound_error();
                                            goto L70;
                                        } else {
                                            while(1) {
                                                __eax = caml_young_ptr;
                                                __eax = caml_young_ptr - 12;
                                                caml_young_ptr = __eax;
                                                if(__eax >= caml_young_limit) {
                                                    break;
                                                }
                                                __eax = caml_call_gc();
                                            }
                                            __ebx = __eax + 4;
                                             *(__ebx - 4) = 2301;
                                            __fp0 =  *((long long*)(__esi + __ecx * 4 - 4));
                                             *__ebx =  *((long long*)(__esi + __ecx * 4 - 4));
                                            goto L65;
                                        }
                                    } else {
                                        if(__eax <= __ecx) {
L70:
                                            __eax = caml_ml_array_bound_error();
L71:
                                            __eax = caml_ml_array_bound_error();
                                            goto L72;
                                        } else {
                                            __ebx =  *(__esi + __ecx * 2 - 2);
L65:
                                            __eax = __ecx;
                                            __ecx = __esp[4];
                                            __esi = __esp[3];
                                            __esp =  &(__esp[7]);
                                            __esp = __esp - 32;
                                            while(1) {
L6:
                                                __esp[1] = __eax;
                                                __eax = __ebx;
                                                __esp[5] = __eax;
                                                __esp[2] = __ecx;
                                                __esp[3] = __edx;
                                                __esp[4] = __esi;
                                                 *__esp = __edi;
                                                __ecx =  *(__edi + 12);
                                                __ebx = __edx;
                                                caml_apply2();
                                                if(__eax > 1) {
                                                    break;
                                                }
                                                __edi =  *__esp;
                                                __eax =  *(__edi + 24);
                                                __ebx =  *(__eax - 4);
                                                __ebx = __ebx & 255;
                                                if((__ebx & 255) == 254) {
                                                    __ebx = __ebx >> 10;
                                                    __esi = __esp[4];
                                                    if(__ebx <= __esi) {
                                                        goto L43;
                                                    } else {
                                                        __ebx = __esp[5];
                                                        __fp0 =  *(__esp[5]);
                                                         *((long long*)(__eax + __esi * 4 - 4)) =  *(__esp[5]);
                                                        goto L12;
                                                    }
                                                } else {
                                                    __ebx = __ebx >> 9;
                                                    __esi = __esp[4];
                                                    if(__ebx <= __esi) {
L44:
                                                        __eax = caml_ml_array_bound_error();
                                                        while(__ebx != 1) {
                                                            __ecx =  *(__ebx + 4);
                                                            __ebx =  *__ebx;
                                                            __ebx =  *(__ebx - 4);
                                                            __ebx = __ebx & 255;
                                                            if((__ebx & 255) == 254) {
                                                                __ebx = __ebx >> 10;
                                                            } else {
                                                                __ebx = __ebx >> 9;
                                                            }
                                                            __eax = __eax + __ebx;
                                                            __eax = __eax - 1;
                                                            __ebx = __ecx;
                                                        }
                                                        return __eax;
                                                    } else {
                                                        __ebx = __esp[5];
                                                        _push(__ebx);
                                                        _push(__eax);
                                                        __eax = caml_modify(__ebx, __edi, __esi);
                                                        __esp =  &(__esp[2]);
L12:
                                                        __ecx = __esp[1];
                                                        __ecx = __esp[1] + 2;
                                                        __eax =  *(__edi + 28);
                                                        if(__ecx >=  *(__edi + 28)) {
                                                            __ebp =  *(__edi + 32);
                                                            __ebx = __esp[2];
                                                             *(__edi + 32) - __ebx =  *(__edi + 32) - __ebx + 1;
                                                            __esi = __esi + 2;
                                                            __ecx =  *(__edi + 24);
                                                            __eax =  *(__edi + 20);
                                                            __edx = __esi;
                                                            __esi =  *(__edi + 32) - __ebx + 1;
                                                            __esp =  &(__esp[8]);
L129:
                                                            __esp = __esp - 24;
                                                            __edi = __eax;
                                                            __esp[2] = __ecx;
                                                            __ebp = __edx;
                                                            if(__esi < 1 || __ebx < 1) {
L163:
                                                                __eax = "Array.blit";
                                                                __esp =  &(__esp[6]);
L2:
                                                                _t331 = caml_young_ptr - 12;
                                                                caml_young_ptr = _t331;
                                                                if(_t331 >= caml_young_limit) {
                                                                    _t333 = _t331 + 4;
                                                                     *((intOrPtr*)(_t333 - 4)) = 2048;
                                                                     *_t333 =  &caml_exn_Invalid_argument;
                                                                    _t333[1] = __eax;
                                                                    caml_raise_exn(_t333);
                                                                }
                                                                caml_call_gc();
                                                                goto L2;
                                                            }
                                                            __ecx =  *(__edi - 4);
                                                            __ecx = __ecx & 255;
                                                            if((__ecx & 255) == 254) {
                                                                __eax = __ecx;
                                                                __eax = __ecx >> 10;
                                                            } else {
                                                                __eax = __ecx;
                                                                __eax = __ecx >> 9;
                                                            }
                                                            __eax = __eax | 1;
                                                            __eax = __eax - __esi;
                                                            if(__ebx > __eax || __ebp < 1) {
                                                                goto L163;
                                                            }
                                                            __eax = __esp[2];
                                                            __ecx =  *(__esp[2] - 4);
                                                            __ecx = __ecx & 255;
                                                            if((__ecx & 255) == 254) {
                                                                __eax = __ecx;
                                                                __eax = __ecx >> 10;
                                                            } else {
                                                                __eax = __ecx;
                                                                __eax = __ecx >> 9;
                                                            }
                                                            __eax = __eax | 1;
                                                            __eax = __eax - __esi;
                                                            if(__ebp > __eax) {
                                                                goto L163;
                                                            }
                                                            if(__ebx >= __ebp) {
                                                                __eax = 1;
                                                                __esp[3] = 1;
                                                                __esi = __esi + -2;
                                                                if(__esp[3] <= __esi) {
                                                                    __esp[1] = __ebx;
                                                                     *__esp = __edi;
                                                                    do {
                                                                        __ebx = __esp[1];
                                                                        __eax = __esp[3];
                                                                        __ebx = __esp[1] + __esp[3] - 1;
                                                                        __eax =  *__esp;
                                                                        __ecx =  *(__eax - 4) & 255;
                                                                        if(( *(__eax - 4) & 255) == 254) {
                                                                            while(1) {
                                                                                __eax = caml_young_ptr;
                                                                                __eax = caml_young_ptr - 12;
                                                                                caml_young_ptr = __eax;
                                                                                if(__eax >= caml_young_limit) {
                                                                                    break;
                                                                                }
                                                                                __eax = caml_call_gc();
                                                                            }
                                                                            __ecx = __eax + 4;
                                                                             *(__ecx - 4) = 2301;
                                                                            __eax =  *__esp;
                                                                            __fp0 =  *((long long*)(__eax + __ebx * 4 - 4));
                                                                             *__ecx =  *((long long*)(__eax + __ebx * 4 - 4));
                                                                            __ebx = __ecx;
                                                                        } else {
                                                                            __ebx =  *(__eax + __ebx * 2 - 2);
                                                                        }
                                                                        __ecx = __esp[3];
                                                                        __eax = __ebp;
                                                                        __eax = __ebp + __esp[3] - 1;
                                                                        __ecx = __esp[2];
                                                                        __ecx =  *(__esp[2] - 4) & 255;
                                                                        if(( *(__esp[2] - 4) & 255) == 254) {
                                                                            __fp0 =  *__ebx;
                                                                            __ebx = __esp[2];
                                                                             *((long long*)(__esp[2] + __eax * 4 - 4)) = __fp0;
                                                                        } else {
                                                                            _push(__ebx);
                                                                            __ebx = __esp[3];
                                                                            _push(__eax);
                                                                            __eax = caml_modify(__ebx, __edi, __esi);
                                                                            __esp =  &(__esp[2]);
                                                                        }
                                                                        __ebx = __esp[3];
                                                                        __esp[3] = __esp[3] + 2;
                                                                        __esp[3] = __esp[3] + 2;
                                                                    } while(__esp[3] != __esi);
                                                                }
                                                                __eax = 1;
                                                                __esp =  &(__esp[6]);
                                                                return 1;
                                                            } else {
                                                                __esi = __esi + -2;
                                                                if(__esi >= 1) {
                                                                    __esp[1] = __ebx;
                                                                    do {
                                                                        __eax = __esp[1];
                                                                        __ebx = __esp[1] + __esi - 1;
                                                                        __eax =  *(__edi - 4) & 255;
                                                                        if(( *(__edi - 4) & 255) == 254) {
                                                                            while(1) {
                                                                                __eax = caml_young_ptr;
                                                                                __eax = caml_young_ptr - 12;
                                                                                caml_young_ptr = __eax;
                                                                                if(__eax >= caml_young_limit) {
                                                                                    break;
                                                                                }
                                                                                __eax = caml_call_gc();
                                                                            }
                                                                            __eax = __eax + 4;
                                                                             *(__eax - 4) = 2301;
                                                                            __fp0 =  *((long long*)(__edi + __ebx * 4 - 4));
                                                                             *__eax =  *((long long*)(__edi + __ebx * 4 - 4));
                                                                            __ebx = __eax;
                                                                        } else {
                                                                            __ebx =  *(__edi + __ebx * 2 - 2);
                                                                        }
                                                                        __eax = __ebp;
                                                                        __eax = __ebp + __esi - 1;
                                                                        __ecx = __esp[2];
                                                                        __ecx =  *(__esp[2] - 4) & 255;
                                                                        if(( *(__esp[2] - 4) & 255) == 254) {
                                                                            __fp0 =  *__ebx;
                                                                            __ebx = __esp[2];
                                                                             *((long long*)(__esp[2] + __eax * 4 - 4)) = __fp0;
                                                                        } else {
                                                                            _push(__ebx);
                                                                            __ebx = __esp[3];
                                                                            _push(__eax);
                                                                            __eax = caml_modify(__ebx, __edi, __esi);
                                                                            __esp =  &(__esp[2]);
                                                                        }
                                                                        __ebx = __esi;
                                                                        __esi = __esi - 2;
                                                                        __esi = __esi - 2;
                                                                    } while(__ebx != 1);
                                                                }
                                                                __eax = 1;
                                                                __esp =  &(__esp[6]);
                                                                return 1;
                                                            }
                                                        } else {
                                                            __ebx =  *(__edi + 16);
                                                            __edx =  *(__ebx - 4);
                                                            __edx = __edx & 255;
                                                            if((__edx & 255) == 254) {
                                                                if(__edx >> 10 <= __ecx) {
L41:
                                                                    __eax = caml_ml_array_bound_error();
                                                                    goto L42;
                                                                } else {
                                                                    while(1) {
                                                                        __eax = caml_young_ptr;
                                                                        __eax = caml_young_ptr - 12;
                                                                        caml_young_ptr = __eax;
                                                                        if(__eax >= caml_young_limit) {
                                                                            break;
                                                                        }
                                                                        __eax = caml_call_gc();
                                                                    }
                                                                    __edx = __eax + 4;
                                                                     *(__edx - 4) = 2301;
                                                                    __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                     *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                    __ebx = __edx;
                                                                    goto L19;
                                                                }
                                                            } else {
                                                                if(__edx >> 9 <= __ecx) {
L42:
                                                                    __eax = caml_ml_array_bound_error();
L43:
                                                                    __eax = caml_ml_array_bound_error();
                                                                    goto L44;
                                                                } else {
                                                                    __ebx =  *(__ebx + __ecx * 2 - 2);
L19:
                                                                    __esi = __esi + 2;
                                                                    __eax = __ecx;
                                                                    __ecx = __esp[2];
                                                                    __edx = __esp[3];
                                                                    continue;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                goto L186;
                                            }
                                            __edi =  *__esp;
                                            __eax =  *(__edi + 24);
                                            __ebx =  *(__eax - 4);
                                            __ebx = __ebx & 255;
                                            if((__ebx & 255) == 254) {
                                                __ebx = __ebx >> 10;
                                                __esi = __esp[4];
                                                if(__ebx <= __esi) {
                                                    goto L39;
                                                } else {
                                                    __ebx = __esp[3];
                                                    __fp0 =  *(__esp[3]);
                                                     *((long long*)(__eax + __esi * 4 - 4)) =  *(__esp[3]);
                                                    goto L26;
                                                }
                                            } else {
                                                __ebx = __ebx >> 9;
                                                __esi = __esp[4];
                                                if(__ebx <= __esi) {
L40:
                                                    __eax = caml_ml_array_bound_error();
                                                    goto L41;
                                                } else {
                                                    __ebx = __esp[3];
                                                    _push(__ebx);
                                                    _push(__eax);
                                                    __eax = caml_modify(__ebx, __edi, __esi);
                                                    __esp =  &(__esp[2]);
L26:
                                                    __ecx = __esp[2];
                                                    __ecx = __esp[2] + 2;
                                                    __eax =  *(__edi + 32);
                                                    if(__ecx >=  *(__edi + 32)) {
                                                        __ebp =  *(__edi + 28);
                                                        __ebx = __esp[1];
                                                         *(__edi + 28) - __ebx =  *(__edi + 28) - __ebx + 1;
                                                        __esi = __esi + 2;
                                                        __ecx =  *(__edi + 24);
                                                        __eax =  *(__edi + 16);
                                                        __edx = __esi;
                                                        __esi =  *(__edi + 28) - __ebx + 1;
                                                        __esp =  &(__esp[8]);
                                                        goto L129;
                                                    } else {
                                                        __ebx =  *(__edi + 20);
                                                        __edx =  *(__ebx - 4);
                                                        __edx = __edx & 255;
                                                        if((__edx & 255) == 254) {
                                                            if(__edx >> 10 <= __ecx) {
                                                                __eax = caml_ml_array_bound_error();
                                                                goto L38;
                                                            } else {
                                                                while(1) {
                                                                    __eax = caml_young_ptr;
                                                                    __eax = caml_young_ptr - 12;
                                                                    caml_young_ptr = __eax;
                                                                    if(__eax >= caml_young_limit) {
                                                                        break;
                                                                    }
                                                                    __eax = caml_call_gc();
                                                                }
                                                                __edx = __eax + 4;
                                                                 *(__edx - 4) = 2301;
                                                                __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                 *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                                goto L33;
                                                            }
                                                        } else {
                                                            if(__edx >> 9 <= __ecx) {
L38:
                                                                __eax = caml_ml_array_bound_error();
L39:
                                                                __eax = caml_ml_array_bound_error();
                                                                goto L40;
                                                            } else {
                                                                __edx =  *(__ebx + __ecx * 2 - 2);
L33:
                                                                __esi = __esi + 2;
                                                                __eax = __esp[1];
                                                                __ebx = __esp[5];
                                                                goto L6;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            __esi =  *(__esi + 20);
                            __esp =  &(__esp[6]);
                            goto L73;
                        }
                    } else {
                        __edx =  *(__ecx + __eax * 2 - 2);
                        __esp[1] =  *(__ecx + __eax * 2 - 2);
                        while(1) {
L81:
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 8;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            __eax = caml_call_gc();
                        }
                        __esi = __eax + 4;
                        __esp[2] = __esi;
                         *(__esi - 4) = 1024;
                        __eax = __esp[5];
                        __eax = __esp[5] + __edi - 3;
                         *__esi = __esp[5] + __edi - 3;
                        while(1) {
                            __ecx =  *__esi;
                            __eax = __esp[5];
                            if( *__esi < __esp[5]) {
                                break;
                            }
                            __ecx =  *__esi;
                            __eax =  *(__ebx - 4);
                            __eax = __eax & 255;
                            if((__eax & 255) == 254) {
                                if(__eax <= __ecx) {
                                    goto L120;
                                } else {
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 12;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        __eax = caml_call_gc();
                                    }
                                    __eax = __eax + 4;
                                     *(__eax - 4) = 2301;
                                    __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                     *__eax =  *((long long*)(__ebx + __ecx * 4 - 4));
                                    goto L90;
                                }
                            } else {
                                if(__eax <= __ecx) {
L121:
                                    __eax = caml_ml_array_bound_error();
L122:
                                    __eax = caml_ml_array_bound_error();
                                    goto L123;
                                } else {
                                    __eax =  *(__ebx + __ecx * 2 - 2);
L90:
                                    __ebx = __esp[6];
                                    __ecx =  *(__esp[6] + 12);
                                    __ebx = __esp[1];
                                    caml_apply2();
                                    if(__eax <= 1) {
                                        break;
                                    } else {
                                        __esi = __esp[2];
                                        __ecx =  *__esi;
                                        __ebx = __esp[7];
                                        __eax =  *(__ebx - 4);
                                        __eax = __eax & 255;
                                        if((__eax & 255) == 254) {
                                            if(__eax <= __ecx) {
                                                goto L118;
                                            } else {
                                                while(1) {
                                                    __eax = caml_young_ptr;
                                                    __eax = caml_young_ptr - 12;
                                                    caml_young_ptr = __eax;
                                                    if(__eax >= caml_young_limit) {
                                                        break;
                                                    }
                                                    __eax = caml_call_gc();
                                                }
                                                __edx = __eax + 4;
                                                 *(__edx - 4) = 2301;
                                                __fp0 =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                 *__edx =  *((long long*)(__ebx + __ecx * 4 - 4));
                                                goto L97;
                                            }
                                        } else {
                                            if(__eax <= __ecx) {
L119:
                                                __eax = caml_ml_array_bound_error();
L120:
                                                __eax = caml_ml_array_bound_error();
                                                goto L121;
                                            } else {
                                                __edx =  *(__ebx + __ecx * 2 - 2);
L97:
                                                __eax =  *__esi;
                                                __eax =  *__esi + 2;
                                                __ecx =  *(__ebx - 4);
                                                __edi = __ecx;
                                                __edi = __ecx & 255;
                                                if(__edi == 254) {
                                                    if(__ecx <= __eax) {
L116:
                                                        __eax = caml_ml_array_bound_error();
                                                        goto L117;
                                                    } else {
                                                        __fp0 =  *__edx;
                                                         *((long long*)(__ebx + __eax * 4 - 4)) =  *__edx;
                                                        goto L102;
                                                    }
                                                } else {
                                                    if(__ecx <= __eax) {
L117:
                                                        __eax = caml_ml_array_bound_error();
L118:
                                                        __eax = caml_ml_array_bound_error();
                                                        goto L119;
                                                    } else {
                                                        _push(__edx);
                                                        _push(__eax);
                                                        __eax = caml_modify(__ebx, __edi, __esi);
                                                        __esp =  &(__esp[2]);
L102:
                                                         *__esi =  *__esi + -2;
                                                        continue;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            goto L186;
                        }
                        __esp[2] =  *(__esp[2]);
                        __eax =  *(__esp[2]) + 2;
                        __ebx = __esp[7];
                        __ecx =  *(__ebx - 4);
                        __ecx = __ecx & 255;
                        if((__ecx & 255) == 254) {
                            if(__ecx <= __eax) {
                                __eax = caml_ml_array_bound_error();
                                goto L115;
                            } else {
                                __ecx = __esp[1];
                                __fp0 =  *(__esp[1]);
                                 *((long long*)(__ebx + __eax * 4 - 4)) =  *(__esp[1]);
                                goto L108;
                            }
                        } else {
                            if(__ecx <= __eax) {
L115:
                                __eax = caml_ml_array_bound_error();
                                goto L116;
                            } else {
                                __ecx = __esp[1];
                                _push(__esp[1]);
                                _push(__eax);
                                __eax = caml_modify(__ebx, __edi, __esi);
                                __esp =  &(__esp[2]);
                                goto L108;
                            }
                        }
                    }
                }
                goto L186;
L108:
                __edi = __esp[3];
                __ecx = __edi;
                __edi = __edi + 2;
                __esp[3] = __edi;
                __eax = __esp[4];
            } while(__ecx != __esp[4]);
            break;
        }
        __eax = 1;
        __esp =  &(__esp[0xa]);
        return 1;
    }
L186:
}

camlArray__entry()
{// addr = 0x08052F40
    intOrPtr* _t23;                        // _t23

    camlArray =  &camlArray__21;
     *134683148 =  &camlArray__20;
     *134683152 =  *134683148;
     *134683168 =  &camlArray__19;
     *134683156 =  &camlArray__18;
     *134683224 =  &camlArray__17;
     *134683160 =  &camlArray__16;
     *134683164 =  &camlArray__15;
     *134683172 =  &camlArray__14;
     *134683176 =  &camlArray__13;
     *134683188 =  &camlArray__12;
     *134683192 =  &camlArray__11;
     *134683196 =  &camlArray__10;
     *134683200 =  &camlArray__9;
     *134683180 =  &camlArray__8;
     *134683228 =  &camlArray__7;
     *134683184 =  &camlArray__6;
     *134683204 =  &camlArray__5;
     *134683208 =  &camlArray__4;
    _t23 = caml_alloc1() + 4;
     *((intOrPtr*)(_t23 - 4)) = 1024;
     *_t23 = "Array.Bottom";
     *134683232 = _t23;
     *134683212 =  &camlArray__2;
     *134683236 = 11;
     *134683216 =  &camlArray__1;
     *134683220 =  *134683216;
    return 1;
}

camlList__nth_aux_1045(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08053050
    intOrPtr _t7;                          // _t7
    intOrPtr* _t9;                         // _t9

    while(__eax != 1) {
        __ecx = __eax[1];
        __eax =  *__eax;
        if(__ebx != 1) {
            __ebx = __ebx + -2;
            __eax = __ecx;
            continue;
        }
        return __eax;
    }
L2:
    _t7 = caml_young_ptr - 12;
    caml_young_ptr = _t7;
    if(_t7 >= caml_young_limit) {
        _t9 = _t7 + 4;
         *((intOrPtr*)(_t9 - 4)) = 2048;
         *_t9 =  &caml_exn_Failure;
        _t9[1] =  &camlList__53;
        caml_raise_exn(_t9);
    }
    caml_call_gc();
    goto L2;
}

camlList__rmap_f_1070(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08053080
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t10;                        // _t10
    intOrPtr _t14;                         // _t14
    intOrPtr* _t15;                        // _t15
    intOrPtr _t17;                         // _t17
    intOrPtr _t19;                         // _t19

    _t19 = __ecx;
    _t15 = __ebx;
    _t10 = __eax;
    while(_t15 != 1) {
        _v4 = _t19;
         *__esp = _t10;
        _v8 = _t15[1];
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t19 + 12))))))();
        _t17 =  *_t15;
        while(1) {
            _t14 = caml_young_ptr - 12;
            caml_young_ptr = _t14;
            if(_t14 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t10 = _t14 + 4;
         *((intOrPtr*)(_t10 - 4)) = 2048;
         *_t10 = _t17;
        _t10[1] =  *__esp;
        _t15 = _v8;
        _t19 = _v4;
    }
}

camlList__rmap2_f_1103(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x080530F0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t18;                         // _t18
    intOrPtr* _t20;                        // _t20

    __edx = __edx;
    __ecx = __ecx;
    while(__ebx != 1) {
        if(__ecx == 1) {
L12:
            __eax = "List.rev_map2";
            __esp = __esp + 16;
L2:
            _t18 = caml_young_ptr - 12;
            caml_young_ptr = _t18;
            if(_t18 >= caml_young_limit) {
                _t20 = _t18 + 4;
                 *((intOrPtr*)(_t20 - 4)) = 2048;
                 *_t20 =  &caml_exn_Invalid_argument;
                _t20[1] = __eax;
                caml_raise_exn(_t20);
            }
            caml_call_gc();
            goto L2;
        }
        _v4 = __edx;
         *__esp = __eax;
        __eax = __ecx[1];
        _v8 = __ecx[1];
        __esi =  *__ecx;
        __eax = __ebx[1];
        _v12 = __ebx[1];
        __eax =  *__ebx;
        __ecx =  *((intOrPtr*)(__edx + 12));
        __ebx = __esi;
        caml_apply2();
        __ebx = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 12;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __eax = __eax + 4;
         *((intOrPtr*)(__eax - 4)) = 2048;
         *__eax = __ebx;
        __ebx =  *__esp;
        __eax[1] =  *__esp;
        __ebx = _v12;
        __ecx = _v8;
        __edx = _v4;
    }
    if(__ecx != 1) {
        goto L12;
    }
    return __eax;
}

camlList__find_1207(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08053190
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _t19;                        // _t19
    intOrPtr _t22;                         // _t22
    intOrPtr _t24;                         // _t24
    intOrPtr _t26;                         // _t26
    intOrPtr* _t27;                        // _t27
    intOrPtr* _t28;                        // _t28
    intOrPtr _t32;                         // _t32
    intOrPtr* _t33;                        // _t33

    _t32 = __ecx;
    _t27 = __ebx;
    _t19 = __eax;
    __esp = __esp - 16;
    while(_t27 != 1) {
        _v4 = _t32;
        _v12 = _t19;
        _v8 = _t27[1];
        _t24 =  *_t27;
         *__esp = _t24;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t32 + 12))))))();
        if(_t24 == 1) {
            _t19 = _v12;
            _t27 = _v8;
            _t32 = _v4;
        } else {
            while(1) {
                _t26 = caml_young_ptr - 12;
                caml_young_ptr = _t26;
                if(_t26 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t19 = _t26 + 4;
             *((intOrPtr*)(_t19 - 4)) = 2048;
             *_t19 =  *__esp;
            _t19[1] = _v12;
            _t27 = _v8;
            _t32 = _v4;
        }
        continue;
L8:
        while(_t19 != 1) {
            __esi = _t19[1];
            __edx =  *_t19;
            while(1) {
                _t22 = caml_young_ptr - 12;
                caml_young_ptr = _t22;
                if(_t22 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t33 = _t22 + 4;
             *((intOrPtr*)(_t33 - 4)) = 2048;
             *_t33 = __edx;
            _t33[1] = _t28;
            _t19 = __esi;
            _t28 = _t33;
        }
        return _t28;
    }
    _t28 = 1;
    __esp = __esp + 16;
    goto L8;
}

camlList__part_1215(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x08053220
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr* _t25;                        // _t25
    intOrPtr _t26;                         // _t26
    intOrPtr _t27;                         // _t27
    intOrPtr _t29;                         // _t29
    intOrPtr* _t30;                        // _t30
    intOrPtr _t32;                         // _t32
    intOrPtr _t34;                         // _t34
    intOrPtr _t38;                         // _t38
    intOrPtr* _t39;                        // _t39
    intOrPtr _t42;                         // _t42
    intOrPtr* _t47;                        // _t47

    __edx = __edx;
    _t47 = __ecx;
    _t39 = __ebx;
    _t25 = __eax;
    while(1) {
        _v16 = _t25;
        if(_t47 == 1) {
            break;
        }
        _v4 = __edx;
        _v12 = _t39;
        _v8 = _t47[1];
        _t32 =  *_t47;
         *__esp = _t32;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__edx + 12))))))();
        if(_t32 == 1) {
            while(1) {
                _t34 = caml_young_ptr - 12;
                caml_young_ptr = _t34;
                if(_t34 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t39 = _t34 + 4;
             *((intOrPtr*)(_t39 - 4)) = 2048;
             *_t39 =  *__esp;
             *((intOrPtr*)(_t39 + 4)) = _v12;
            _t25 = _v16;
            _t47 = _v8;
            __edx = _v4;
        } else {
            while(1) {
                _t38 = caml_young_ptr - 12;
                caml_young_ptr = _t38;
                if(_t38 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t25 = _t38 + 4;
             *((intOrPtr*)(_t25 - 4)) = 2048;
             *_t25 =  *__esp;
            _t25[1] = _v16;
            _t39 = _v12;
            _t47 = _v8;
            __edx = _v4;
        }
        continue;
        while(1) {
L8:
            _t29 = caml_young_ptr - 12;
            caml_young_ptr = _t29;
            if(_t29 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t30 = _t29 + 4;
         *((intOrPtr*)(_t30 - 4)) = 2048;
         *_t30 = _t42;
        _t30[1] =  *__esp;
        return;
    }
    _t26 = _t39;
    camlList__rev_append_1051(_t26, 1);
     *__esp = _t26;
    _t27 = _v16;
    camlList__rev_append_1051(_t27, 1);
    _t42 = _t27;
    goto L8;
}

camlList__rev_merge_1251(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x08053340
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* _v28;                        // _cfa_ffffffe4
    intOrPtr* _t30;                        // _t30
    intOrPtr _t33;                         // _t33
    intOrPtr _t35;                         // _t35
    intOrPtr _t37;                         // _t37
    intOrPtr _t42;                         // _t42
    intOrPtr* _t46;                        // _t46
    intOrPtr* _t47;                        // _t47
    intOrPtr* _t49;                        // _t49
    intOrPtr* _t50;                        // _t50
    intOrPtr _t54;                         // _t54
    intOrPtr _t55;                         // _t55

    _t54 = __edx;
    _t49 = __ecx;
    _t46 = __ebx;
    _t30 = __eax;
    __esp = __esp - 32;
    while(_t30 != 1) {
        if(_t46 == 1) {
            _t47 = _t49;
            __esp = __esp + 32;
L12:
            while(_t30 != 1) {
                __esi = _t30[1];
                _t55 =  *_t30;
                while(1) {
                    _t33 = caml_young_ptr - 12;
                    caml_young_ptr = _t33;
                    if(_t33 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t50 = _t33 + 4;
                 *((intOrPtr*)(_t50 - 4)) = 2048;
                 *_t50 = _t55;
                _t50[1] = _t47;
                _t30 = __esi;
                _t47 = _t50;
            }
            goto L16;
        } else {
            _v4 = _t54;
            _v16 = _t49;
            _v8 = _t46;
            _v28 = _t30;
            _v24 = _t46[1];
             *__esp =  *_t46;
            _v12 = _t30[1];
            _t35 =  *_t30;
            _v20 = _t35;
            caml_apply2();
            if(_t35 > 1) {
                while(1) {
                    _t37 = caml_young_ptr - 12;
                    caml_young_ptr = _t37;
                    if(_t37 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t49 = _t37 + 4;
                 *((intOrPtr*)(_t49 - 4)) = 2048;
                 *_t49 =  *__esp;
                _t49[1] = _v16;
                _t30 = _v28;
                _t46 = _v24;
                _t54 = _v4;
            } else {
                while(1) {
                    _t42 = caml_young_ptr - 12;
                    caml_young_ptr = _t42;
                    if(_t42 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t49 = _t42 + 4;
                 *((intOrPtr*)(_t49 - 4)) = 2048;
                 *_t49 = _v20;
                _t49[1] = _v16;
                _t30 = _v12;
                _t46 = _v8;
                _t54 = _v4;
            }
            continue;
L16:
            return _t47;
        }
        goto L12;
    }
    _t30 = _t46;
    _t47 = _t49;
    __esp = __esp + 32;
    goto L12;
}

camlList__rev_merge_rev_1261(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x08053440
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* _v28;                        // _cfa_ffffffe4
    intOrPtr* _t30;                        // _t30
    intOrPtr _t33;                         // _t33
    intOrPtr _t35;                         // _t35
    intOrPtr _t37;                         // _t37
    intOrPtr _t42;                         // _t42
    intOrPtr* _t46;                        // _t46
    intOrPtr* _t47;                        // _t47
    intOrPtr* _t49;                        // _t49
    intOrPtr* _t50;                        // _t50
    intOrPtr _t54;                         // _t54
    intOrPtr _t55;                         // _t55

    _t54 = __edx;
    _t49 = __ecx;
    _t46 = __ebx;
    _t30 = __eax;
    __esp = __esp - 32;
    while(_t30 != 1) {
        if(_t46 == 1) {
            _t47 = _t49;
            __esp = __esp + 32;
L12:
            while(_t30 != 1) {
                __esi = _t30[1];
                _t55 =  *_t30;
                while(1) {
                    _t33 = caml_young_ptr - 12;
                    caml_young_ptr = _t33;
                    if(_t33 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t50 = _t33 + 4;
                 *((intOrPtr*)(_t50 - 4)) = 2048;
                 *_t50 = _t55;
                _t50[1] = _t47;
                _t30 = __esi;
                _t47 = _t50;
            }
            goto L16;
        } else {
            _v4 = _t54;
            _v16 = _t49;
            _v8 = _t46;
            _v28 = _t30;
            _v24 = _t46[1];
             *__esp =  *_t46;
            _v12 = _t30[1];
            _t35 =  *_t30;
            _v20 = _t35;
            caml_apply2();
            if(_t35 <= 1) {
                while(1) {
                    _t37 = caml_young_ptr - 12;
                    caml_young_ptr = _t37;
                    if(_t37 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t49 = _t37 + 4;
                 *((intOrPtr*)(_t49 - 4)) = 2048;
                 *_t49 =  *__esp;
                _t49[1] = _v16;
                _t30 = _v28;
                _t46 = _v24;
                _t54 = _v4;
            } else {
                while(1) {
                    _t42 = caml_young_ptr - 12;
                    caml_young_ptr = _t42;
                    if(_t42 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t49 = _t42 + 4;
                 *((intOrPtr*)(_t49 - 4)) = 2048;
                 *_t49 = _v20;
                _t49[1] = _v16;
                _t30 = _v12;
                _t46 = _v8;
                _t54 = _v4;
            }
            continue;
L16:
            return _t47;
        }
        goto L12;
    }
    _t30 = _t46;
    _t47 = _t49;
    __esp = __esp + 32;
    goto L12;
}

signed int camlList__rev_sort_1272(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    signed int __ecx                       // r2
)
{// addr = 0x08053540
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _t137;                      // _t137
    signed int _t149;                      // _t149
    signed int _t151;                      // _t151
    signed int _t153;                      // _t153
    signed int _t158;                      // _t158
    signed int _t162;                      // _t162
    signed int _t164;                      // _t164
    signed int _t170;                      // _t170
    signed int _t178;                      // _t178
    signed int* _t181;                     // _t181
    signed int* _t182;                     // _t182
    signed int _t186;                      // _t186
    signed int _t191;                      // _t191
    signed int* _t196;                     // _t196
    signed int* _t197;                     // _t197
    signed int _t198;                      // _t198
    _unknown_ _t199;                       // _t199
    signed int* _t200;                     // _t200

    _t183 = __ecx;
    _t175 = __ebx;
    _t137 = __eax;
    __esp = __esp - 20;
    if(__eax == 5) {
        if(__ebx == 1) {
            _v4 = __ecx;
            goto L43;
        } else {
            _t200 =  *(__ebx + 4);
            if(_t200 == 1) {
                _v4 = __ecx;
                goto L43;
            } else {
                 *__esp =  *_t200;
                _t162 =  *__ebx;
                _v16 = _t162;
                caml_apply2();
                if(_t162 <= 1) {
                    while(1) {
                        _t164 = caml_young_ptr - 24;
                        caml_young_ptr = _t164;
                        if(_t164 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t196 = _t164 + 4;
                     *((intOrPtr*)(_t196 - 4)) = 2048;
                     *_t196 = _v16;
                    _t196[1] = 1;
                    _t181 =  &(_t196[3]);
                     *((intOrPtr*)(_t181 - 4)) = 2048;
                     *_t181 =  *__esp;
                    _t181[1] = _t196;
                    __esp =  &(__esp[5]);
                    return _t181;
                } else {
                    while(1) {
                        _t170 = caml_young_ptr - 24;
                        caml_young_ptr = _t170;
                        if(_t170 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t197 = _t170 + 4;
                     *((intOrPtr*)(_t197 - 4)) = 2048;
                     *_t197 =  *__esp;
                    _t197[1] = 1;
                    _t182 =  &(_t197[3]);
                     *((intOrPtr*)(_t182 - 4)) = 2048;
                     *_t182 = _v16;
                    _t182[1] = _t197;
                    __esp =  &(__esp[5]);
                    return _t182;
                }
            }
        }
    } else {
        _v4 = __ecx;
        if(__eax != 7 || __ebx == 1) {
L43:
            _v16 = _t175;
            _t186 = _t137 >> 1 | 1;
             *__esp = _t186;
            _v12 = _t137 - _t186 + 1;
            _v8 = camlList__chop_1243(_t186, _t175);
             *__esp = camlList__sort_1271( *__esp, _v16, _v4 + -16);
            __ebx = camlList__sort_1271(_v12, _v8, _v4 + -16);
            _t198 =  *(_v4 + 16);
            _t183 = 1;
            _t137 =  *__esp;
            __esp =  &(__esp[5]);
            __esp = __esp - 32;
            while(_t137 != 1) {
                if(_t175 == 1) {
                    _t178 = _t183;
                    __esp =  &(__esp[8]);
L52:
                    while(_t137 != 1) {
                        __esi =  *(_t137 + 4);
                        _t199 =  *_t137;
                        while(1) {
                            _t149 = caml_young_ptr - 12;
                            caml_young_ptr = _t149;
                            if(_t149 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t191 = _t149 + 4;
                         *(_t191 - 4) = 2048;
                         *_t191 = _t199;
                         *(_t191 + 4) = _t178;
                        _t137 = __esi;
                        _t178 = _t191;
                    }
                    goto L56;
                } else {
                    _v4 = _t198;
                    _v16 = _t183;
                    _v8 = _t175;
                    _v28 = _t137;
                    _v24 =  *(_t175 + 4);
                     *__esp =  *_t175;
                    _v12 =  *(_t137 + 4);
                    _t151 =  *_t137;
                    _v20 = _t151;
                    caml_apply2();
                    if(_t151 > 1) {
                        while(1) {
                            _t153 = caml_young_ptr - 12;
                            caml_young_ptr = _t153;
                            if(_t153 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t183 = _t153 + 4;
                         *(_t183 - 4) = 2048;
                         *_t183 =  *__esp;
                         *(_t183 + 4) = _v16;
                        _t137 = _v28;
                        _t175 = _v24;
                        _t198 = _v4;
                    } else {
                        while(1) {
                            _t158 = caml_young_ptr - 12;
                            caml_young_ptr = _t158;
                            if(_t158 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t183 = _t158 + 4;
                         *(_t183 - 4) = 2048;
                         *_t183 = _v20;
                         *(_t183 + 4) = _v16;
                        _t137 = _v12;
                        _t175 = _v8;
                        _t198 = _v4;
                    }
                    continue;
L56:
                    return _t178;
                    goto L58;
                }
                goto L52;
            }
            _t137 = _t175;
            _t178 = _t183;
            __esp =  &(__esp[8]);
            goto L52;
        } else {
            __esi =  *(__ebx + 4);
            if(__esi == 1) {
                goto L43;
            } else {
                __edx =  *(__esi + 4);
                if(__edx == 1) {
                    goto L43;
                } else {
                    __eax =  *__edx;
                     *__esp =  *__edx;
                    __edx =  *__esi;
                    _v16 = __edx;
                    __eax =  *__ebx;
                    _v12 = __eax;
                    __ecx =  *(__ecx + 12);
                    __ebx = __edx;
                    caml_apply2();
                    if(__eax <= 1) {
                        __eax = _v4;
                        __ecx =  *((intOrPtr*)(_v4 + 12));
                        __eax = _v12;
                        __ebx =  *__esp;
                        caml_apply2();
                        if(_v12 <= 1) {
                            __eax = _v4;
                            __ecx =  *((intOrPtr*)(_v4 + 12));
                            __eax = _v16;
                            __ebx =  *__esp;
                            caml_apply2();
                            if(_v16 <= 1) {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax = _v12;
                                 *__ebx = _v12;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax = _v16;
                                 *__ecx = _v16;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ebx =  *__esp;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax = _v12;
                                 *__ebx = _v12;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ecx =  *__esp;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax = _v16;
                                 *__ebx = _v16;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            }
                        } else {
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 36;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __ebx = __eax + 4;
                             *(__ebx - 4) = 2048;
                            __eax =  *__esp;
                             *__ebx =  *__esp;
                             *(__ebx + 4) = 1;
                            __ecx = __ebx + 12;
                             *(__ecx - 4) = 2048;
                            __eax = _v12;
                             *__ecx = _v12;
                             *(__ecx + 4) = __ebx;
                            __ebx = __ebx + 24;
                             *(__ebx - 4) = 2048;
                            __eax = _v16;
                             *__ebx = _v16;
                             *(__ebx + 4) = __ecx;
                            __eax = __ebx;
                            __esp =  &(__esp[5]);
                            return __ebx;
                        }
                    } else {
                        __eax = _v4;
                        __ecx =  *((intOrPtr*)(_v4 + 12));
                        __eax = _v16;
                        __ebx =  *__esp;
                        caml_apply2();
                        if(_v16 <= 1) {
                            __eax = _v4;
                            __ecx =  *(_v4 + 12);
                            __eax = _v12;
                            __ebx =  *__esp;
                            caml_apply2();
                            if(_v12 <= 1) {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax = _v16;
                                 *__ebx = _v16;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax = _v12;
                                 *__ecx = _v12;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ebx =  *__esp;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax = _v16;
                                 *__ebx = _v16;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ecx =  *__esp;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax = _v12;
                                 *__ebx = _v12;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            }
                        } else {
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 36;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __ebx = __eax + 4;
                             *(__ebx - 4) = 2048;
                            __eax =  *__esp;
                             *__ebx =  *__esp;
                             *(__ebx + 4) = 1;
                            __ecx = __ebx + 12;
                             *(__ecx - 4) = 2048;
                            __eax = _v16;
                             *__ecx = _v16;
                             *(__ecx + 4) = __ebx;
                            __ebx = __ebx + 24;
                             *(__ebx - 4) = 2048;
                            __eax = _v12;
                             *__ebx = _v12;
                             *(__ebx + 4) = __ecx;
                            __eax = __ebx;
                            __esp =  &(__esp[5]);
                            return __ebx;
                        }
                    }
                }
            }
        }
    }
L58:
}

signed int camlList__sort_1271(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    signed int __ecx                       // r2
)
{// addr = 0x08053A00
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _t137;                      // _t137
    signed int _t149;                      // _t149
    signed int _t151;                      // _t151
    signed int _t153;                      // _t153
    signed int _t158;                      // _t158
    signed int _t162;                      // _t162
    signed int _t164;                      // _t164
    signed int _t170;                      // _t170
    signed int _t178;                      // _t178
    signed int* _t181;                     // _t181
    signed int* _t182;                     // _t182
    signed int _t186;                      // _t186
    signed int _t191;                      // _t191
    signed int* _t196;                     // _t196
    signed int* _t197;                     // _t197
    signed int _t198;                      // _t198
    _unknown_ _t199;                       // _t199
    signed int* _t200;                     // _t200

    _t183 = __ecx;
    _t175 = __ebx;
    _t137 = __eax;
    __esp = __esp - 20;
    if(__eax == 5) {
        if(__ebx == 1) {
            _v4 = __ecx;
            goto L43;
        } else {
            _t200 =  *(__ebx + 4);
            if(_t200 == 1) {
                _v4 = __ecx;
                goto L43;
            } else {
                 *__esp =  *_t200;
                _t162 =  *__ebx;
                _v16 = _t162;
                caml_apply2();
                if(_t162 > 1) {
                    while(1) {
                        _t164 = caml_young_ptr - 24;
                        caml_young_ptr = _t164;
                        if(_t164 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t196 = _t164 + 4;
                     *((intOrPtr*)(_t196 - 4)) = 2048;
                     *_t196 = _v16;
                    _t196[1] = 1;
                    _t181 =  &(_t196[3]);
                     *((intOrPtr*)(_t181 - 4)) = 2048;
                     *_t181 =  *__esp;
                    _t181[1] = _t196;
                    __esp =  &(__esp[5]);
                    return _t181;
                } else {
                    while(1) {
                        _t170 = caml_young_ptr - 24;
                        caml_young_ptr = _t170;
                        if(_t170 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t197 = _t170 + 4;
                     *((intOrPtr*)(_t197 - 4)) = 2048;
                     *_t197 =  *__esp;
                    _t197[1] = 1;
                    _t182 =  &(_t197[3]);
                     *((intOrPtr*)(_t182 - 4)) = 2048;
                     *_t182 = _v16;
                    _t182[1] = _t197;
                    __esp =  &(__esp[5]);
                    return _t182;
                }
            }
        }
    } else {
        _v4 = __ecx;
        if(__eax != 7 || __ebx == 1) {
L43:
            _v16 = _t175;
            _t186 = _t137 >> 1 | 1;
             *__esp = _t186;
            _v12 = _t137 - _t186 + 1;
            _v8 = camlList__chop_1243(_t186, _t175);
             *__esp = camlList__rev_sort_1272( *__esp, _v16, _v4 + 16);
            __ebx = camlList__rev_sort_1272(_v12, _v8, _v4 + 16);
            _t198 =  *(_v4 + 36);
            _t183 = 1;
            _t137 =  *__esp;
            __esp =  &(__esp[5]);
            __esp = __esp - 32;
            while(_t137 != 1) {
                if(_t175 == 1) {
                    _t178 = _t183;
                    __esp =  &(__esp[8]);
L52:
                    while(_t137 != 1) {
                        __esi =  *(_t137 + 4);
                        _t199 =  *_t137;
                        while(1) {
                            _t149 = caml_young_ptr - 12;
                            caml_young_ptr = _t149;
                            if(_t149 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t191 = _t149 + 4;
                         *(_t191 - 4) = 2048;
                         *_t191 = _t199;
                         *(_t191 + 4) = _t178;
                        _t137 = __esi;
                        _t178 = _t191;
                    }
                    goto L56;
                } else {
                    _v4 = _t198;
                    _v16 = _t183;
                    _v8 = _t175;
                    _v28 = _t137;
                    _v24 =  *(_t175 + 4);
                     *__esp =  *_t175;
                    _v12 =  *(_t137 + 4);
                    _t151 =  *_t137;
                    _v20 = _t151;
                    caml_apply2();
                    if(_t151 <= 1) {
                        while(1) {
                            _t153 = caml_young_ptr - 12;
                            caml_young_ptr = _t153;
                            if(_t153 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t183 = _t153 + 4;
                         *(_t183 - 4) = 2048;
                         *_t183 =  *__esp;
                         *(_t183 + 4) = _v16;
                        _t137 = _v28;
                        _t175 = _v24;
                        _t198 = _v4;
                    } else {
                        while(1) {
                            _t158 = caml_young_ptr - 12;
                            caml_young_ptr = _t158;
                            if(_t158 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t183 = _t158 + 4;
                         *(_t183 - 4) = 2048;
                         *_t183 = _v20;
                         *(_t183 + 4) = _v16;
                        _t137 = _v12;
                        _t175 = _v8;
                        _t198 = _v4;
                    }
                    continue;
L56:
                    return _t178;
                    goto L58;
                }
                goto L52;
            }
            _t137 = _t175;
            _t178 = _t183;
            __esp =  &(__esp[8]);
            goto L52;
        } else {
            __esi =  *(__ebx + 4);
            if(__esi == 1) {
                goto L43;
            } else {
                __edx =  *(__esi + 4);
                if(__edx == 1) {
                    goto L43;
                } else {
                    __eax =  *__edx;
                     *__esp =  *__edx;
                    __edx =  *__esi;
                    _v16 = __edx;
                    __eax =  *__ebx;
                    _v12 = __eax;
                    __ecx =  *(__ecx + 28);
                    __ebx = __edx;
                    caml_apply2();
                    if(__eax > 1) {
                        __eax = _v4;
                        __ecx =  *((intOrPtr*)(_v4 + 28));
                        __eax = _v12;
                        __ebx =  *__esp;
                        caml_apply2();
                        if(_v12 > 1) {
                            __eax = _v4;
                            __ecx =  *((intOrPtr*)(_v4 + 28));
                            __eax = _v16;
                            __ebx =  *__esp;
                            caml_apply2();
                            if(_v16 > 1) {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax = _v12;
                                 *__ebx = _v12;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax = _v16;
                                 *__ecx = _v16;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ebx =  *__esp;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax = _v12;
                                 *__ebx = _v12;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ecx =  *__esp;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax = _v16;
                                 *__ebx = _v16;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            }
                        } else {
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 36;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __ebx = __eax + 4;
                             *(__ebx - 4) = 2048;
                            __eax =  *__esp;
                             *__ebx =  *__esp;
                             *(__ebx + 4) = 1;
                            __ecx = __ebx + 12;
                             *(__ecx - 4) = 2048;
                            __eax = _v12;
                             *__ecx = _v12;
                             *(__ecx + 4) = __ebx;
                            __ebx = __ebx + 24;
                             *(__ebx - 4) = 2048;
                            __eax = _v16;
                             *__ebx = _v16;
                             *(__ebx + 4) = __ecx;
                            __eax = __ebx;
                            __esp =  &(__esp[5]);
                            return __ebx;
                        }
                    } else {
                        __eax = _v4;
                        __ecx =  *((intOrPtr*)(_v4 + 28));
                        __eax = _v16;
                        __ebx =  *__esp;
                        caml_apply2();
                        if(_v16 > 1) {
                            __eax = _v4;
                            __ecx =  *(_v4 + 28);
                            __eax = _v12;
                            __ebx =  *__esp;
                            caml_apply2();
                            if(_v12 > 1) {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax = _v16;
                                 *__ebx = _v16;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax = _v12;
                                 *__ecx = _v12;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ebx =  *__esp;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax = _v16;
                                 *__ebx = _v16;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ecx =  *__esp;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax = _v12;
                                 *__ebx = _v12;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            }
                        } else {
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 36;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __ebx = __eax + 4;
                             *(__ebx - 4) = 2048;
                            __eax =  *__esp;
                             *__ebx =  *__esp;
                             *(__ebx + 4) = 1;
                            __ecx = __ebx + 12;
                             *(__ecx - 4) = 2048;
                            __eax = _v16;
                             *__ecx = _v16;
                             *(__ecx + 4) = __ebx;
                            __ebx = __ebx + 24;
                             *(__ebx - 4) = 2048;
                            __eax = _v12;
                             *__ebx = _v12;
                             *(__ebx + 4) = __ecx;
                            __eax = __ebx;
                            __esp =  &(__esp[5]);
                            return __ebx;
                        }
                    }
                }
            }
        }
    }
L58:
}

camlList__length_aux_1030(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08053EC0
L0:
    while(1) {
L0:
        __eax = __eax;
        if(__ebx == 1) {
            break;
        }
L1:
        __eax = __eax + 2;
    }
L2:
    return __eax;
}

camlList__length_1034(
    intOrPtr __eax                         // r0
)
{// addr = 0x08053EE0
    _unknown_ _t3;                         // _t3

    __ebx = __eax;
    _t3 = 1;
    while(__ebx != 1) {
        __ebx =  *((intOrPtr*)(__ebx + 4));
        _t3 = _t3 + 2;
    }
    return _t3;
}

camlList__hd_1036(
    _unknown_ __eax                        // r0
)
{// addr = 0x08053EF0
    intOrPtr _t6;                          // _t6
    intOrPtr* _t8;                         // _t8

    if(__eax == 1) {
        __ebx =  &camlList__51;
L2:
        _t6 = caml_young_ptr - 12;
        caml_young_ptr = _t6;
        if(_t6 >= caml_young_limit) {
            _t8 = _t6 + 4;
             *((intOrPtr*)(_t8 - 4)) = 2048;
             *_t8 =  &caml_exn_Failure;
            _t8[1] = __ebx;
            caml_raise_exn(_t8);
        }
        caml_call_gc();
        goto L2;
    }
    return __eax;
}

camlList__tl_1039(
    _unknown_ __eax                        // r0
)
{// addr = 0x08053F10
    intOrPtr _t7;                          // _t7
    intOrPtr* _t9;                         // _t9

    if(__eax == 1) {
        __ebx =  &camlList__50;
L2:
        _t7 = caml_young_ptr - 12;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            _t9 = _t7 + 4;
             *((intOrPtr*)(_t9 - 4)) = 2048;
             *_t9 =  &caml_exn_Failure;
            _t9[1] = __ebx;
            caml_raise_exn(_t9);
        }
        caml_call_gc();
        goto L2;
    }
    return __eax;
}

camlList__nth_1042(
    _unknown_ __ebx                        // r1
)
{// addr = 0x08053F30
    intOrPtr _t10;                         // _t10
    intOrPtr* _t12;                        // _t12
    char _t14;                             // _t14
    _unknown_ _t15;                        // _t15
    char* _t18;                            // _t18

    _t15 = __ebx;
    if(__ebx < 1) {
        __eax = "List.nth";
        __ebx = __eax;
L6:
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 12;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            __eax = __eax + 4;
             *((intOrPtr*)(__eax - 4)) = 2048;
             *__eax =  &caml_exn_Invalid_argument;
            __eax[1] = __ebx;
            __eax = caml_raise_exn(__eax);
        }
        __eax = caml_call_gc();
        goto L6;
    }
    while(_t8 != 1) {
        _t18 =  *((intOrPtr*)(_t8 + 4));
        _t14 =  *_t8;
        if(_t15 != 1) {
            _t15 = _t15 + -2;
            _t8 = _t18;
            continue;
        }
        return _t14;
    }
    _t8 =  &camlList__53;
L2:
    _t10 = caml_young_ptr - 12;
    caml_young_ptr = _t10;
    if(_t10 >= caml_young_limit) {
        _t12 = _t10 + 4;
         *((intOrPtr*)(_t12 - 4)) = 2048;
         *_t12 =  &caml_exn_Failure;
        _t12[1] =  &camlList__53;
        caml_raise_exn(_t12);
    }
    caml_call_gc();
    goto L2;
}

camlList__rev_append_1051(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08053F50
    intOrPtr _t8;                          // _t8

L0:
    while(1) {
L0:
        __ebx = __ebx;
        if(__eax == 1) {
            break;
        }
L1:
        __edx =  *__eax;
        while(1) {
L2:
            _t8 = caml_young_ptr - 12;
            caml_young_ptr = _t8;
            if(_t8 >= caml_young_limit) {
                break;
            }
L5:
            caml_call_gc();
        }
L3:
        __ecx = _t8 + 4;
         *((intOrPtr*)(__ecx - 4)) = 2048;
         *__ecx = __edx;
        __ecx[1] = __ebx;
        __ebx = __ecx;
    }
L4:
    return __ebx;
}

camlList__rev_1056(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08053FA0
    intOrPtr* _t5;                         // _t5
    intOrPtr _t8;                          // _t8

    _t5 = __eax;
    __ebx = 1;
    while(_t5 != 1) {
        __esi = _t5[1];
        __edx =  *_t5;
        while(1) {
            _t8 = caml_young_ptr - 12;
            caml_young_ptr = _t8;
            if(_t8 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        __ecx = _t8 + 4;
         *((intOrPtr*)(__ecx - 4)) = 2048;
         *__ecx = __edx;
        __ecx[1] = __ebx;
        _t5 = __esi;
        __ebx = __ecx;
    }
    return __ebx;
}

camlList__flatten_1058(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08053FB0
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    _unknown_ _t14;                        // _t14
    intOrPtr _t17;                         // _t17

    if(__eax == 1) {
        return 1;
    } else {
         *__esp =  *__eax;
        __eax = camlList__flatten_1058(__eax);
        __eax =  *__esp;
        __esp = __esp + 4;
        __esp = __esp - 4;
        if(__eax == 1) {
            return _t14;
        } else {
             *__esp =  *__eax;
            L1();
            _t17 =  *((intOrPtr*)(__eax + 4));
            while(1) {
                _t11 = caml_young_ptr - 12;
                caml_young_ptr = _t11;
                if(_t11 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 2048;
             *_t13 =  *__esp;
            _t13[1] = _t17;
            return _t13;
        }
    }
}

camlList__map_1062(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08053FF0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t13;                         // _t13
    intOrPtr _t15;                         // _t15
    intOrPtr* _t16;                        // _t16
    intOrPtr _t22;                         // _t22

    if(__ebx == 1) {
        return 1;
    } else {
         *__esp = __eax;
        _v8 =  *((intOrPtr*)(__ebx + 4));
         *((intOrPtr*)( *__eax))();
        _v4 =  *__ebx;
        _t13 =  *__esp;
        camlList__map_1062(_t13, _v8);
        _t22 = _t13;
        while(1) {
            _t15 = caml_young_ptr - 12;
            caml_young_ptr = _t15;
            if(_t15 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t16 = _t15 + 4;
         *((intOrPtr*)(_t16 - 4)) = 2048;
         *_t16 = _v4;
        _t16[1] = _t22;
        return _t16;
    }
}

camlList__rev_map_1067(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054060
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t15;                        // _t15
    intOrPtr _t19;                         // _t19
    intOrPtr* _t20;                        // _t20
    intOrPtr _t22;                         // _t22
    intOrPtr _t24;                         // _t24

    _t20 = __ebx;
    _t15 = __eax;
    __edx = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ecx = __eax + 4;
     *((intOrPtr*)(__ecx - 4)) = 4343;
     *__ecx = caml_curry2;
    __ecx[1] = 5;
    __ecx[2] = camlList__rmap_f_1070;
    __ecx[3] = __edx;
    __eax = 1;
    __esp = __esp - 12;
    while(_t20 != 1) {
        _v4 = _t24;
         *__esp = _t15;
        _v8 = _t20[1];
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t24 + 12))))))();
        _t22 =  *_t20;
        while(1) {
            _t19 = caml_young_ptr - 12;
            caml_young_ptr = _t19;
            if(_t19 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t15 = _t19 + 4;
         *((intOrPtr*)(_t15 - 4)) = 2048;
         *_t15 = _t22;
        _t15[1] =  *__esp;
        _t20 = _v8;
        _t24 = _v4;
    }
    __esp = __esp + 12;
}

camlList__iter_1074(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080540B0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t4;                         // _t4
    intOrPtr _t8;                          // _t8

    _t8 = __ebx;
    _t4 = __eax;
    while(1) {
        __edx = _t4;
        if(_t8 == 1) {
            break;
        }
         *__esp = __edx;
        _v4 =  *((intOrPtr*)(_t8 + 4));
         *((intOrPtr*)( *__edx))();
        _t4 =  *__esp;
        _t8 = _v4;
    }
    return 1;
}

camlList__fold_left_1078(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x080540F0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t4;                          // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t6;                         // _t6
    intOrPtr _t8;                          // _t8

    _t8 = __ecx;
    _t6 = __ebx;
    _t4 = __eax;
    while(1) {
        __edx = _t4;
        _t5 = _t6;
        if(_t8 == 1) {
            break;
        }
         *__esp = __edx;
        _v4 =  *((intOrPtr*)(_t8 + 4));
        caml_apply2();
        _t6 = _t5;
        _t4 =  *__esp;
        _t8 = _v4;
    }
    return _t5;
}

camlList__fold_right_1084(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08054130
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr* _t6;                         // _t6
    intOrPtr* _t8;                         // _t8
    intOrPtr* _t13;                        // _t13

    _t9 = __ebx;
    _t6 = __eax;
    if(__ebx != 1) {
        _v4 = _t8;
         *__esp =  *_t6;
        camlList__fold_right_1084(_t8, _t6[1]);
        _t9 = _t8;
        _t6 =  *__esp;
        _t13 = _v4;
        __esp = __esp + 8;
        __esp = __esp - 4;
        if(_t13[1] != 5) {
             *__esp = _t9;
             *((intOrPtr*)( *_t13))();
            _t11 = _t6;
            _t8 =  *__esp;
            __esp = __esp + 4;
            goto __ecx;
        }
        __esp = __esp + 4;
        goto __edx;
    }
    return _t13;
}

camlList__map2_1090(
    char* __eax,                           // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x08054170
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t17;                         // _t17
    intOrPtr* _t19;                        // _t19
    intOrPtr _t23;                         // _t23

    __ecx = __ecx;
    _t15 = __eax;
    __edx = __eax;
    if(__ebx == 1) {
        if(__ecx != 1) {
            goto L11;
        }
        return 1;
    } else {
        if(__ecx == 1) {
L11:
            _t15 = "List.map2";
            __esp = __esp + 16;
            _t23 = _t15;
L2:
            _t17 = caml_young_ptr - 12;
            caml_young_ptr = _t17;
            if(_t17 >= caml_young_limit) {
                _t19 = _t17 + 4;
                 *((intOrPtr*)(_t19 - 4)) = 2048;
                 *_t19 =  &caml_exn_Invalid_argument;
                _t19[1] = _t23;
                caml_raise_exn(_t19);
            }
            caml_call_gc();
            goto L2;
        }
         *__esp = __eax;
        __eax =  *((intOrPtr*)(__ecx + 4));
        _v8 =  *((intOrPtr*)(__ecx + 4));
        __ecx =  *__ecx;
        __eax = __ebx[1];
        _v12 = __ebx[1];
        __eax =  *__ebx;
        __ebx =  *__ecx;
        __ecx = __edx;
        caml_apply2();
        _v4 = __eax;
        __eax =  *__esp;
        __ebx = _v12;
        __ecx = _v8;
        __ecx = camlList__map2_1090( *__esp, _v12, _v8);
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 12;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __eax = __eax + 4;
         *((intOrPtr*)(__eax - 4)) = 2048;
        __ebx = _v4;
         *__eax = _v4;
        __eax[1] = __ecx;
        return __eax;
    }
}

camlList__rev_map2_1099(
    intOrPtr* __eax,                       // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x08054210
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t23;                         // _t23
    intOrPtr* _t25;                        // _t25

    __ecx = __ecx;
    __esi = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __edx = __eax + 4;
     *((intOrPtr*)(__edx - 4)) = 4343;
     *__edx = caml_curry3;
     *((intOrPtr*)(__edx + 4)) = 7;
     *((intOrPtr*)(__edx + 8)) = camlList__rmap2_f_1103;
     *((intOrPtr*)(__edx + 12)) = __esi;
    __eax = 1;
    __esp = __esp - 16;
    while(__ebx != 1) {
        if(__ecx == 1) {
L13:
            __eax = "List.rev_map2";
            __esp = __esp + 16;
L2:
            _t23 = caml_young_ptr - 12;
            caml_young_ptr = _t23;
            if(_t23 >= caml_young_limit) {
                _t25 = _t23 + 4;
                 *((intOrPtr*)(_t25 - 4)) = 2048;
                 *_t25 =  &caml_exn_Invalid_argument;
                _t25[1] = __eax;
                caml_raise_exn(_t25);
            }
            caml_call_gc();
            goto L2;
        }
        _v4 = __edx;
         *__esp = __eax;
        __eax = __ecx[1];
        _v8 = __ecx[1];
        __esi =  *__ecx;
        __eax = __ebx[1];
        _v12 = __ebx[1];
        __eax =  *__ebx;
        __ecx =  *((intOrPtr*)(__edx + 12));
        __ebx = __esi;
        caml_apply2();
        __ebx = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 12;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __eax = __eax + 4;
         *((intOrPtr*)(__eax - 4)) = 2048;
         *__eax = __ebx;
        __ebx =  *__esp;
        __eax[1] =  *__esp;
        __ebx = _v12;
        __ecx = _v8;
        __edx = _v4;
    }
    if(__ecx != 1) {
        goto L13;
    }
    __esp = __esp + 16;
    return __eax;
}

camlList__iter2_1111(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x08054260
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t12;                         // _t12
    intOrPtr* _t14;                        // _t14

    __ecx = __ecx;
    while(1) {
        __edx = __eax;
        if(__ebx == 1) {
            break;
        }
        if(__ecx == 1) {
L10:
            __eax = "List.iter2";
            __esp = __esp + 12;
L2:
            _t12 = caml_young_ptr - 12;
            caml_young_ptr = _t12;
            if(_t12 >= caml_young_limit) {
                _t14 = _t12 + 4;
                 *((intOrPtr*)(_t14 - 4)) = 2048;
                 *_t14 =  &caml_exn_Invalid_argument;
                _t14[1] = __eax;
                caml_raise_exn(_t14);
            }
            caml_call_gc();
            goto L2;
        }
         *__esp = __edx;
        __eax = __ecx[1];
        _v4 = __ecx[1];
        __ecx =  *__ecx;
        __eax = __ebx[1];
        _v8 = __ebx[1];
        __eax =  *__ebx;
        __ebx = __ecx;
        __ecx = __edx;
        caml_apply2();
        __eax =  *__esp;
        __ebx = _v8;
        __ecx = _v4;
    }
    if(__ecx != 1) {
        goto L10;
    }
    __eax = 1;
    return 1;
}

camlList__fold_left2_1119(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr* __edx                        // r3
)
{// addr = 0x080542C0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t12;                         // _t12
    intOrPtr* _t14;                        // _t14

    __edx = __edx;
    __ecx = __ecx;
    while(1) {
        __esi = __eax;
        if(__ecx == 1) {
            break;
        }
        if(__edx == 1) {
L10:
            __eax = "List.fold_left2";
            __esp = __esp + 12;
L2:
            _t12 = caml_young_ptr - 12;
            caml_young_ptr = _t12;
            if(_t12 >= caml_young_limit) {
                _t14 = _t12 + 4;
                 *((intOrPtr*)(_t14 - 4)) = 2048;
                 *_t14 =  &caml_exn_Invalid_argument;
                _t14[1] = __eax;
                caml_raise_exn(_t14);
            }
            caml_call_gc();
            goto L2;
        }
         *__esp = __esi;
        __eax = __edx[1];
        _v4 = __edx[1];
        __edx =  *__edx;
        __eax = __ecx[1];
        _v8 = __ecx[1];
        __ecx =  *__ecx;
        __eax = __ebx;
        __ebx = __ecx;
        __ecx = __edx;
        __edx = __esi;
        caml_apply3();
        __ebx = __eax;
        __eax =  *__esp;
        __ecx = _v8;
        __edx = _v4;
    }
    if(__edx != 1) {
        goto L10;
    }
    __eax = __ebx;
    return __ebx;
}

camlList__fold_right2_1128(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08054320
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    char* _t15;                            // _t15
    intOrPtr _t17;                         // _t17
    intOrPtr* _t18;                        // _t18
    intOrPtr _t22;                         // _t22

    if(__ebx != 1) {
        if(__ecx == 1) {
L12:
            _t15 = "List.fold_right2";
            __esp = __esp + 12;
            _t22 = _t15;
L5:
            _t17 = caml_young_ptr - 12;
            caml_young_ptr = _t17;
            if(_t17 >= caml_young_limit) {
                _t18 = _t17 + 4;
                 *((intOrPtr*)(_t18 - 4)) = 2048;
                 *_t18 =  &caml_exn_Invalid_argument;
                _t18[1] = _t22;
                caml_raise_exn(_t18);
            }
            caml_call_gc();
            goto L5;
        }
        _v4 = __eax;
        __esi =  *((intOrPtr*)(__ecx + 4));
        _v8 = __ecx;
        __ecx =  *__ebx;
         *__esp =  *__ebx;
        __ebx =  *((intOrPtr*)(__ebx + 4));
        __ecx = __esi;
        camlList__fold_right2_1128(__eax, __ebx, __esi);
        __ecx = __eax;
        __eax =  *__esp;
        __ebx = _v8;
        __edx = _v4;
        __esp = __esp + 12;
        __esp = __esp - 8;
        if(__edx[1] != 7) {
            _v4 = __ecx;
             *__esp = __ebx;
             *((intOrPtr*)( *__edx))();
             *((intOrPtr*)( *__eax))();
            _t15 = _v4;
            __esp = __esp + 8;
            goto __ecx;
        }
        __esp = __esp + 8;
        goto __esi;
    }
    if(__ecx != 1) {
        goto L12;
    }
    return __edx;
}

camlList__for_all_1137(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054380
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t4;                         // _t4
    intOrPtr* _t9;                         // _t9

    _t9 = __ebx;
    _t4 = __eax;
    while(1) {
        __edx = _t4;
        if(_t9 == 1) {
            break;
        }
         *__esp = __edx;
        _v4 = _t9[1];
         *((intOrPtr*)( *__edx))();
        if( *_t9 == 1) {
            return 1;
        } else {
            _t4 =  *__esp;
            _t9 = _v4;
            continue;
        }
L6:
    }
    return 3;
    goto L6;
}

camlList__exists_1141(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x080543D0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t4;                         // _t4
    intOrPtr* _t9;                         // _t9

    _t9 = __ebx;
    _t4 = __eax;
    while(1) {
        __edx = _t4;
        if(_t9 == 1) {
            break;
        }
         *__esp = __edx;
        _v4 = _t9[1];
         *((intOrPtr*)( *__edx))();
        if( *_t9 == 1) {
            _t4 =  *__esp;
            _t9 = _v4;
            continue;
        } else {
            return 3;
        }
L6:
    }
    return 1;
    goto L6;
}

camlList__for_all2_1145(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x08054420
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t12;                         // _t12
    intOrPtr* _t14;                        // _t14

    __ecx = __ecx;
    while(1) {
        __edx = __eax;
        if(__ebx == 1) {
            break;
        }
        if(__ecx == 1) {
L12:
            __eax = "List.for_all2";
            __esp = __esp + 12;
L2:
            _t12 = caml_young_ptr - 12;
            caml_young_ptr = _t12;
            if(_t12 >= caml_young_limit) {
                _t14 = _t12 + 4;
                 *((intOrPtr*)(_t14 - 4)) = 2048;
                 *_t14 =  &caml_exn_Invalid_argument;
                _t14[1] = __eax;
                caml_raise_exn(_t14);
            }
            caml_call_gc();
            goto L2;
        }
         *__esp = __edx;
        __eax = __ecx[1];
        _v4 = __ecx[1];
        __ecx =  *__ecx;
        __eax = __ebx[1];
        _v8 = __ebx[1];
        __eax =  *__ebx;
        __ebx = __ecx;
        __ecx = __edx;
        caml_apply2();
        if(__eax == 1) {
            __eax = 1;
            return 1;
        } else {
            __eax =  *__esp;
            __ebx = _v8;
            __ecx = _v4;
            continue;
        }
L13:
    }
    if(__ecx != 1) {
        goto L12;
    }
    __eax = 3;
    return 3;
    goto L13;
}

camlList__exists2_1153(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x08054490
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t12;                         // _t12
    intOrPtr* _t14;                        // _t14

    __ecx = __ecx;
    while(1) {
        __edx = __eax;
        if(__ebx == 1) {
            break;
        }
        if(__ecx == 1) {
L12:
            __eax = "List.exists2";
            __esp = __esp + 12;
L2:
            _t12 = caml_young_ptr - 12;
            caml_young_ptr = _t12;
            if(_t12 >= caml_young_limit) {
                _t14 = _t12 + 4;
                 *((intOrPtr*)(_t14 - 4)) = 2048;
                 *_t14 =  &caml_exn_Invalid_argument;
                _t14[1] = __eax;
                caml_raise_exn(_t14);
            }
            caml_call_gc();
            goto L2;
        }
         *__esp = __edx;
        __eax = __ecx[1];
        _v4 = __ecx[1];
        __ecx =  *__ecx;
        __eax = __ebx[1];
        _v8 = __ebx[1];
        __eax =  *__ebx;
        __ebx = __ecx;
        __ecx = __edx;
        caml_apply2();
        if(__eax == 1) {
            __eax =  *__esp;
            __ebx = _v8;
            __ecx = _v4;
            continue;
        } else {
            __eax = 3;
            return 3;
        }
L13:
    }
    if(__ecx != 1) {
        goto L12;
    }
    __eax = 1;
    return 1;
    goto L13;
}

camlList__mem_1161(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08054500
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t4;                          // _t4
    intOrPtr _t8;                          // _t8

    _t8 = __ebx;
    _t4 = __eax;
    while(_t8 != 1) {
         *__esp = _t4;
        _v4 =  *((intOrPtr*)(_t8 + 4));
        caml_c_call(_t4);
        if(caml_compare != 1) {
            _t4 =  *__esp;
            _t8 = _v4;
            continue;
        } else {
            return 3;
        }
L6:
    }
    return 1;
    goto L6;
}

camlList__memq_1165(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054560
    while(__ebx != 1) {
        if( *__ebx != __eax) {
            continue;
        } else {
            return 3;
        }
L5:
    }
    return 1;
    goto L5;
}

camlList__assoc_1169(
    intOrPtr __eax                         // r0
)
{// addr = 0x080545A0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t9;                          // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    intOrPtr* _t17;                        // _t17
    intOrPtr _t21;                         // _t21

    _t9 = __eax;
    while(_t17 != 1) {
         *__esp = _t9;
        _v8 = _t17[1];
        _t21 =  *_t17;
        _v4 =  *((intOrPtr*)(_t21 + 4));
        caml_c_call(_t9);
        if(caml_compare != 1) {
            _t9 =  *__esp;
            _t17 = _v8;
            continue;
        }
        return _v4;
    }
    while(1) {
        _t11 = caml_young_ptr - 8;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 1024;
             *_t13 =  &caml_exn_Not_found;
            caml_raise_exn(_t13);
        }
        caml_call_gc();
    }
}

camlList__assq_1174(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054630
    intOrPtr _t7;                          // _t7
    intOrPtr* _t9;                         // _t9
    intOrPtr* _t14;                        // _t14

    while(__ebx != 1) {
        _t14 =  *__ebx;
        __edx = _t14[1];
        if( *_t14 != __eax) {
            continue;
        }
        return __edx;
    }
    while(1) {
        _t7 = caml_young_ptr - 8;
        caml_young_ptr = _t7;
        if(_t7 >= caml_young_limit) {
            _t9 = _t7 + 4;
             *((intOrPtr*)(_t9 - 4)) = 1024;
             *_t9 =  &caml_exn_Not_found;
            caml_raise_exn(_t9);
        }
        caml_call_gc();
    }
}

camlList__mem_assoc_1179(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080546A0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t4;                          // _t4
    intOrPtr _t8;                          // _t8

    _t8 = __ebx;
    _t4 = __eax;
    while(_t8 != 1) {
         *__esp = _t4;
        _v4 =  *((intOrPtr*)(_t8 + 4));
        caml_c_call(_t4);
        if(caml_compare != 1) {
            _t4 =  *__esp;
            _t8 = _v4;
            continue;
        } else {
            return 3;
        }
L6:
    }
    return 1;
    goto L6;
}

camlList__mem_assq_1184(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054700
    while(__ebx != 1) {
        if( *((intOrPtr*)( *__ebx)) != __eax) {
            continue;
        } else {
            return 3;
        }
L5:
    }
    return 1;
    goto L5;
}

camlList__remove_assoc_1189(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054740
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t16;                         // _t16
    intOrPtr* _t18;                        // _t18
    intOrPtr _t21;                         // _t21
    intOrPtr _t26;                         // _t26

    if(__ebx == 1) {
        return 1;
    } else {
         *__esp = __eax;
        _v4 =  *((intOrPtr*)(__ebx + 4));
        _t21 =  *__ebx;
        _v8 = _t21;
        caml_c_call(__eax);
        if(caml_compare != 1) {
            _t26 = camlList__remove_assoc_1189( *__esp, _v4);
            while(1) {
                _t16 = caml_young_ptr - 12;
                caml_young_ptr = _t16;
                if(_t16 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t18 = _t16 + 4;
             *((intOrPtr*)(_t18 - 4)) = 2048;
             *_t18 = _v8;
            _t18[1] = _t26;
            return _t18;
        } else {
            return _v4;
        }
    }
}

camlList__remove_assq_1195(
    _unknown_ __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x080547D0
    intOrPtr _t9;                          // _t9
    intOrPtr* _t11;                        // _t11
    intOrPtr _t17;                         // _t17

    if(__ebx == 1) {
        return 1;
    } else {
        __esi =  *((intOrPtr*)(__ebx + 4));
        __edx =  *__ebx;
        if( *__edx != __eax) {
             *__esp = __edx;
            _t17 = camlList__remove_assq_1195(__eax, __esi);
            while(1) {
                _t9 = caml_young_ptr - 12;
                caml_young_ptr = _t9;
                if(_t9 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t11 = _t9 + 4;
             *((intOrPtr*)(_t11 - 4)) = 2048;
             *_t11 =  *__esp;
            _t11[1] = _t17;
            return _t11;
        } else {
            return __esi;
        }
    }
}

camlList__find_1201(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054840
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t8;                         // _t8
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11
    intOrPtr _t13;                         // _t13
    intOrPtr* _t15;                        // _t15

    _t15 = __ebx;
    _t8 = __eax;
    while(1) {
        __edx = _t8;
        if(_t15 == 1) {
            goto L5;
        }
         *__esp = __edx;
        _v8 = _t15[1];
        _t13 =  *_t15;
        _v4 = _t13;
         *((intOrPtr*)( *__edx))();
        if(_t13 == 1) {
            _t8 =  *__esp;
            _t15 = _v8;
            continue;
        }
        return _v4;
    }
    while(1) {
L5:
        _t10 = caml_young_ptr - 8;
        caml_young_ptr = _t10;
        if(_t10 >= caml_young_limit) {
            _t11 = _t10 + 4;
             *((intOrPtr*)(_t11 - 4)) = 1024;
             *_t11 =  &caml_exn_Not_found;
            caml_raise_exn(_t11);
        }
        caml_call_gc();
    }
}

camlList__find_all_1205()
{// addr = 0x080548C0
    intOrPtr _t6;                          // _t6
    intOrPtr _t8;                          // _t8

    __ecx = _t6;
    while(1) {
        _t8 = caml_young_ptr - 20;
        caml_young_ptr = _t8;
        if(_t8 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __ebx = _t8 + 4;
     *((intOrPtr*)(__ebx - 4)) = 4343;
     *__ebx = caml_curry2;
    __ebx[1] = 5;
    __ebx[2] = camlList__find_1207;
    __ebx[3] = __ecx;
    __ecx =  *__ebx;
    goto ( *__ebx);
}

camlList__partition_1212(
    intOrPtr* __eax,                       // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08054910
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr* _t30;                        // _t30
    intOrPtr* _t31;                        // _t31
    intOrPtr* _t32;                        // _t32
    intOrPtr _t34;                         // _t34
    intOrPtr* _t35;                        // _t35
    intOrPtr _t37;                         // _t37
    intOrPtr _t39;                         // _t39
    intOrPtr _t43;                         // _t43
    intOrPtr* _t44;                        // _t44
    intOrPtr* _t47;                        // _t47
    intOrPtr* _t52;                        // _t52

    _t44 = __ebx;
    _t30 = __eax;
    __esi = __eax;
    _t52 = __ebx;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __edx = __eax + 4;
     *((intOrPtr*)(__edx - 4)) = 4343;
     *__edx = caml_curry3;
     *((intOrPtr*)(__edx + 4)) = 7;
     *((intOrPtr*)(__edx + 8)) = camlList__part_1215;
     *((intOrPtr*)(__edx + 12)) = __esi;
    __ebx = 1;
    __eax = 1;
    __esp = __esp - 20;
    while(1) {
        _v16 = _t30;
        if(_t52 == 1) {
            break;
        }
        _v4 = __edx;
        _v12 = _t44;
        _v8 = _t52[1];
        _t37 =  *_t52;
         *__esp = _t37;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__edx + 12))))))();
        if(_t37 == 1) {
            while(1) {
                _t39 = caml_young_ptr - 12;
                caml_young_ptr = _t39;
                if(_t39 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t44 = _t39 + 4;
             *((intOrPtr*)(_t44 - 4)) = 2048;
             *_t44 =  *__esp;
            _t44[1] = _v12;
            _t30 = _v16;
            _t52 = _v8;
            __edx = _v4;
        } else {
            while(1) {
                _t43 = caml_young_ptr - 12;
                caml_young_ptr = _t43;
                if(_t43 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t30 = _t43 + 4;
             *((intOrPtr*)(_t30 - 4)) = 2048;
             *_t30 =  *__esp;
            _t30[1] = _v16;
            _t44 = _v12;
            _t52 = _v8;
            __edx = _v4;
        }
        continue;
        while(1) {
L9:
            _t34 = caml_young_ptr - 12;
            caml_young_ptr = _t34;
            if(_t34 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t35 = _t34 + 4;
         *((intOrPtr*)(_t35 - 4)) = 2048;
         *_t35 = _t47;
        _t35[1] =  *__esp;
        __esp = __esp + 20;
        return;
    }
    _t31 = _t44;
    camlList__rev_append_1051(_t31, 1);
     *__esp = _t31;
    _t32 = _v16;
    camlList__rev_append_1051(_t32, 1);
    _t47 = _t32;
    goto L9;
}

camlList__split_1220(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08054960
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t18;                        // _t18
    intOrPtr _t20;                         // _t20
    intOrPtr* _t24;                        // _t24
    intOrPtr _t27;                         // _t27
    intOrPtr* _t28;                        // _t28
    intOrPtr* _t29;                        // _t29
    intOrPtr* _t30;                        // _t30
    intOrPtr _t32;                         // _t32

    if(__eax == 1) {
        return  &camlList__41;
    } else {
        _t29 =  *__eax;
         *__esp = _t29[1];
        _v4 =  *_t29;
        _t18 = camlList__split_1220( *((intOrPtr*)(__eax + 4)));
        _t27 = _t18[1];
        _t32 =  *_t18;
        while(1) {
            _t20 = caml_young_ptr - 36;
            caml_young_ptr = _t20;
            if(_t20 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t30 = _t20 + 4;
         *((intOrPtr*)(_t30 - 4)) = 2048;
         *_t30 =  *__esp;
         *((intOrPtr*)(_t30 + 4)) = _t27;
        _t28 = _t30 + 12;
         *((intOrPtr*)(_t28 - 4)) = 2048;
         *_t28 = _v4;
         *((intOrPtr*)(_t28 + 4)) = _t32;
        _t24 = _t30 + 24;
         *((intOrPtr*)(_t24 - 4)) = 2048;
         *_t24 = _t28;
        _t24[1] = _t30;
        return _t24;
    }
}

camlList__combine_1226(
    char* __eax,                           // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x080549F0
    intOrPtr* _v4;                         // _cfa_fffffffc
    intOrPtr _t16;                         // _t16
    intOrPtr* _t18;                        // _t18
    intOrPtr _t22;                         // _t22

    _t14 = __eax;
    if(__eax == 1) {
        if(__ebx != 1) {
            goto L11;
        }
        return 1;
    } else {
        if(__ebx == 1) {
L11:
            _t14 = "List.combine";
            __esp = __esp + 8;
            _t22 = _t14;
L2:
            _t16 = caml_young_ptr - 12;
            caml_young_ptr = _t16;
            if(_t16 >= caml_young_limit) {
                _t18 = _t16 + 4;
                 *((intOrPtr*)(_t18 - 4)) = 2048;
                 *_t18 =  &caml_exn_Invalid_argument;
                _t18[1] = _t22;
                caml_raise_exn(_t18);
            }
            caml_call_gc();
            goto L2;
        }
        __ecx =  *__ebx;
        _v4 =  *__ebx;
        __ecx =  *__eax;
         *__esp =  *__eax;
        __eax = __eax[1];
        __ecx = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 24;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __ebx = __eax + 4;
         *((intOrPtr*)(__ebx - 4)) = 2048;
        __eax =  *__esp;
         *__ebx =  *__esp;
        __eax = _v4;
         *((intOrPtr*)(__ebx + 4)) = _v4;
        __eax = __ebx + 12;
         *((intOrPtr*)(__eax - 4)) = 2048;
         *__eax = __ebx;
        __eax[1] = __ecx;
        return __eax;
    }
}

camlList__merge_1233(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx,                       // r1
    intOrPtr* __ecx                        // r2
)
{// addr = 0x08054A90
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t26;                         // _t26
    intOrPtr _t30;                         // _t30
    intOrPtr _t37;                         // _t37
    intOrPtr* _t44;                        // _t44
    intOrPtr* _t46;                        // _t46
    intOrPtr _t51;                         // _t51
    intOrPtr _t53;                         // _t53

    if(__ebx == 1) {
        return __ecx;
    } else {
        if(__ecx == 1) {
            return __ebx;
        } else {
            _v8 = __ecx;
             *__esp = __ebx;
            _v16 = __eax;
            _v24 =  *((intOrPtr*)(__ecx + 4));
            _v20 =  *__ecx;
            _v12 =  *((intOrPtr*)(__ebx + 4));
            _t26 =  *__ebx;
            _v4 = _t26;
            caml_apply2();
            if(_t26 > 1) {
                _t51 = camlList__merge_1233(_v16,  *__esp, _v24);
                while(1) {
                    _t30 = caml_young_ptr - 12;
                    caml_young_ptr = _t30;
                    if(_t30 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t44 = _t30 + 4;
                 *((intOrPtr*)(_t44 - 4)) = 2048;
                 *_t44 = _v20;
                _t44[1] = _t51;
                return _t44;
            } else {
                _t53 = camlList__merge_1233(_v16, _v12, _v8);
                while(1) {
                    _t37 = caml_young_ptr - 12;
                    caml_young_ptr = _t37;
                    if(_t37 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t46 = _t37 + 4;
                 *((intOrPtr*)(_t46 - 4)) = 2048;
                 *_t46 = _v4;
                _t46[1] = _t53;
                return _t46;
            }
        }
    }
}

camlList__chop_1243(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08054B90
    intOrPtr _t7;                          // _t7
    intOrPtr* _t9;                         // _t9

    while(__eax != 1) {
        if(__ebx == 1) {
            while(1) {
                _t7 = caml_young_ptr - 12;
                caml_young_ptr = _t7;
                if(_t7 >= caml_young_limit) {
                    _t9 = _t7 + 4;
                     *((intOrPtr*)(_t9 - 4)) = 2048;
                     *_t9 =  &caml_exn_Assert_failure;
                    _t9[1] =  &camlList__39;
                    caml_raise_exn(_t9);
                }
                caml_call_gc();
            }
        }
    }
    return __ebx;
}

signed int camlList__stable_sort_1248(
    signed int __eax,                      // r0
    signed int __ebx                       // r1
)
{// addr = 0x08054BF0
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _t161;                      // _t161
    signed int _t164;                      // _t164
    signed int _t166;                      // _t166
    signed int _t168;                      // _t168
    signed int _t173;                      // _t173
    signed int _t177;                      // _t177
    signed int _t178;                      // _t178
    signed int _t180;                      // _t180
    signed int _t181;                      // _t181
    signed int _t185;                      // _t185
    _unknown_ _t186;                       // _t186
    signed int _t188;                      // _t188

    _t177 = __ebx;
    _t161 = __eax;
    __esp = __esp - 8;
    _v4 = __ebx;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 84;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __edx = __eax + 4;
     *(__edx - 4) = 4343;
     *__edx = caml_curry3;
     *(__edx + 4) = 7;
     *((intOrPtr*)(__edx + 8)) = camlList__rev_merge_1251;
     *(__edx + 12) = __esi;
    __ecx = __edx + 20;
     *(__ecx - 4) = 4343;
     *__ecx = caml_curry3;
     *(__ecx + 4) = 7;
     *((intOrPtr*)(__ecx + 8)) = camlList__rev_merge_rev_1261;
     *(__ecx + 12) = __esi;
    __eax = __edx + 40;
     *__esp = __eax;
     *(__eax - 4) = 10487;
     *__eax = caml_curry2;
     *(__eax + 4) = 5;
     *((intOrPtr*)(__eax + 8)) = camlList__sort_1271;
     *((intOrPtr*)(__eax + 12)) = 4345;
     *((intOrPtr*)(__eax + 16)) = caml_curry2;
     *((intOrPtr*)(__eax + 20)) = 5;
     *((intOrPtr*)(__eax + 24)) = camlList__rev_sort_1272;
     *(__eax + 28) = __esi;
     *(__eax + 32) = __edx;
     *(__eax + 36) = __ecx;
    __eax = 1;
    __eax = camlList__length_aux_1030(1, __ebx);
    if(__eax >= 5) {
        __ebx = _v4;
        __ecx =  *__esp;
        __esp =  &(__esp[2]);
        __esp = __esp - 20;
        if(__eax == 5) {
            if(__ebx == 1) {
                _v4 = __ecx;
                goto L44;
            } else {
                __edx =  *(__ebx + 4);
                if(__edx == 1) {
                    _v4 = __ecx;
                    goto L44;
                } else {
                    __edx =  *__edx;
                     *__esp = __edx;
                    __eax =  *__ebx;
                    _v16 = __eax;
                    __ecx =  *(__ecx + 28);
                    __ebx = __edx;
                    caml_apply2();
                    if(__eax > 1) {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 24;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            __eax = caml_call_gc();
                        }
                        __ecx = __eax + 4;
                         *(__ecx - 4) = 2048;
                        __eax = _v16;
                         *__ecx = _v16;
                         *(__ecx + 4) = 1;
                        __ebx = __ecx + 12;
                         *(__ebx - 4) = 2048;
                        __eax =  *__esp;
                         *__ebx =  *__esp;
                         *(__ebx + 4) = __ecx;
                        __eax = __ebx;
                        __esp =  &(__esp[5]);
                        return __ebx;
                    } else {
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 24;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            __eax = caml_call_gc();
                        }
                        __ecx = __eax + 4;
                         *(__ecx - 4) = 2048;
                        __eax =  *__esp;
                         *__ecx =  *__esp;
                         *(__ecx + 4) = 1;
                        __ebx = __ecx + 12;
                         *(__ebx - 4) = 2048;
                        __eax = _v16;
                         *__ebx = _v16;
                         *(__ebx + 4) = __ecx;
                        __eax = __ebx;
                        __esp =  &(__esp[5]);
                        return __ebx;
                    }
                }
            }
        } else {
            _v4 = __ecx;
            if(__eax != 7 || __ebx == 1) {
L44:
                _v16 = __ebx;
                __eax = __eax >> 1;
                __ecx = __eax >> 1 | 1;
                 *__esp = __ecx;
                __eax = __eax - __ecx;
                _v12 = __eax;
                __eax = __ecx;
                _v8 = camlList__chop_1243(__ecx, __ebx);
                __ecx = _v4;
                __ecx = _v4 + 16;
                __eax =  *__esp;
                __ebx = _v16;
                 *__esp = camlList__rev_sort_1272( *__esp, _v16, _v4 + 16);
                __ecx = _v4;
                __ecx = _v4 + 16;
                __eax = _v12;
                __ebx = _v8;
                __ebx = camlList__rev_sort_1272(_v12, _v8, _v4 + 16);
                __eax = _v4;
                __edx =  *(_v4 + 36);
                __ecx = 1;
                __eax =  *__esp;
                __esp =  &(__esp[5]);
                __esp = __esp - 32;
                while(_t161 != 1) {
                    if(_t177 == 1) {
                        _t178 = _t180;
                        __esp =  &(__esp[8]);
L53:
                        while(_t161 != 1) {
                            _t188 =  *(_t161 + 4);
                            _t186 =  *_t161;
                            while(1) {
                                _t164 = caml_young_ptr - 12;
                                caml_young_ptr = _t164;
                                if(_t164 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            _t181 = _t164 + 4;
                             *(_t181 - 4) = 2048;
                             *_t181 = _t186;
                             *(_t181 + 4) = _t178;
                            _t161 = _t188;
                            _t178 = _t181;
                        }
                        goto L57;
                    } else {
                        _v4 = _t185;
                        _v16 = _t180;
                        _v8 = _t177;
                        _v28 = _t161;
                        _v24 =  *(_t177 + 4);
                         *__esp =  *_t177;
                        _v12 =  *(_t161 + 4);
                        _t166 =  *_t161;
                        _v20 = _t166;
                        caml_apply2();
                        if(_t166 <= 1) {
                            while(1) {
                                _t168 = caml_young_ptr - 12;
                                caml_young_ptr = _t168;
                                if(_t168 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            _t180 = _t168 + 4;
                             *(_t180 - 4) = 2048;
                             *_t180 =  *__esp;
                             *(_t180 + 4) = _v16;
                            _t161 = _v28;
                            _t177 = _v24;
                            _t185 = _v4;
                        } else {
                            while(1) {
                                _t173 = caml_young_ptr - 12;
                                caml_young_ptr = _t173;
                                if(_t173 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            _t180 = _t173 + 4;
                             *(_t180 - 4) = 2048;
                             *_t180 = _v20;
                             *(_t180 + 4) = _v16;
                            _t161 = _v12;
                            _t177 = _v8;
                            _t185 = _v4;
                        }
                        continue;
L57:
                        return _t178;
                        goto L64;
                    }
                    goto L53;
                }
                _t161 = _t177;
                _t178 = _t180;
                __esp =  &(__esp[8]);
                goto L53;
            } else {
                __esi =  *(__ebx + 4);
                if(__esi == 1) {
                    goto L44;
                } else {
                    __edx =  *(__esi + 4);
                    if(__edx == 1) {
                        goto L44;
                    } else {
                        __eax =  *__edx;
                         *__esp =  *__edx;
                        __edx =  *__esi;
                        _v16 = __edx;
                        __eax =  *__ebx;
                        _v12 = __eax;
                        __ecx =  *(__ecx + 28);
                        __ebx = __edx;
                        caml_apply2();
                        if(__eax > 1) {
                            __eax = _v4;
                            __ecx =  *(_v4 + 28);
                            __eax = _v12;
                            __ebx =  *__esp;
                            caml_apply2();
                            if(_v12 > 1) {
                                __eax = _v4;
                                __ecx =  *(_v4 + 28);
                                __eax = _v16;
                                __ebx =  *__esp;
                                caml_apply2();
                                if(_v16 > 1) {
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 36;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        __eax = caml_call_gc();
                                    }
                                    __ebx = __eax + 4;
                                     *(__ebx - 4) = 2048;
                                    __eax = _v12;
                                     *__ebx = _v12;
                                     *(__ebx + 4) = 1;
                                    __ecx = __ebx + 12;
                                     *(__ecx - 4) = 2048;
                                    __eax = _v16;
                                     *__ecx = _v16;
                                     *(__ecx + 4) = __ebx;
                                    __ebx = __ebx + 24;
                                     *(__ebx - 4) = 2048;
                                    __eax =  *__esp;
                                     *__ebx =  *__esp;
                                     *(__ebx + 4) = __ecx;
                                    __eax = __ebx;
                                    __esp =  &(__esp[5]);
                                    return __ebx;
                                } else {
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 36;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        __eax = caml_call_gc();
                                    }
                                    __ebx = __eax + 4;
                                     *(__ebx - 4) = 2048;
                                    __eax = _v12;
                                     *__ebx = _v12;
                                     *(__ebx + 4) = 1;
                                    __ecx = __ebx + 12;
                                     *(__ecx - 4) = 2048;
                                    __eax =  *__esp;
                                     *__ecx =  *__esp;
                                     *(__ecx + 4) = __ebx;
                                    __ebx = __ebx + 24;
                                     *(__ebx - 4) = 2048;
                                    __eax = _v16;
                                     *__ebx = _v16;
                                     *(__ebx + 4) = __ecx;
                                    __eax = __ebx;
                                    __esp =  &(__esp[5]);
                                    return __ebx;
                                }
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ebx =  *__esp;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax = _v12;
                                 *__ecx = _v12;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax = _v16;
                                 *__ebx = _v16;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            }
                        } else {
                            __eax = _v4;
                            __ecx =  *(_v4 + 28);
                            __eax = _v16;
                            __ebx =  *__esp;
                            caml_apply2();
                            if(_v16 > 1) {
                                __eax = _v4;
                                __ecx =  *(_v4 + 28);
                                __eax = _v12;
                                __ebx =  *__esp;
                                caml_apply2();
                                if(_v12 > 1) {
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 36;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        __eax = caml_call_gc();
                                    }
                                    __ebx = __eax + 4;
                                     *(__ebx - 4) = 2048;
                                    __eax = _v16;
                                     *__ebx = _v16;
                                     *(__ebx + 4) = 1;
                                    __ecx = __ebx + 12;
                                     *(__ecx - 4) = 2048;
                                    __eax = _v12;
                                     *__ecx = _v12;
                                     *(__ecx + 4) = __ebx;
                                    __ebx = __ebx + 24;
                                     *(__ebx - 4) = 2048;
                                    __eax =  *__esp;
                                     *__ebx =  *__esp;
                                     *(__ebx + 4) = __ecx;
                                    __eax = __ebx;
                                    __esp =  &(__esp[5]);
                                    return __ebx;
                                } else {
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 36;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        __eax = caml_call_gc();
                                    }
                                    __ebx = __eax + 4;
                                     *(__ebx - 4) = 2048;
                                    __eax = _v16;
                                     *__ebx = _v16;
                                     *(__ebx + 4) = 1;
                                    __ecx = __ebx + 12;
                                     *(__ecx - 4) = 2048;
                                    __eax =  *__esp;
                                     *__ecx =  *__esp;
                                     *(__ecx + 4) = __ebx;
                                    __ebx = __ebx + 24;
                                     *(__ebx - 4) = 2048;
                                    __eax = _v12;
                                     *__ebx = _v12;
                                     *(__ebx + 4) = __ecx;
                                    __eax = __ebx;
                                    __esp =  &(__esp[5]);
                                    return __ebx;
                                }
                            } else {
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 36;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 2048;
                                __eax =  *__esp;
                                 *__ebx =  *__esp;
                                 *(__ebx + 4) = 1;
                                __ecx = __ebx + 12;
                                 *(__ecx - 4) = 2048;
                                __eax = _v16;
                                 *__ecx = _v16;
                                 *(__ecx + 4) = __ebx;
                                __ebx = __ebx + 24;
                                 *(__ebx - 4) = 2048;
                                __eax = _v12;
                                 *__ebx = _v12;
                                 *(__ebx + 4) = __ecx;
                                __eax = __ebx;
                                __esp =  &(__esp[5]);
                                return __ebx;
                            }
                        }
                    }
                }
            }
        }
    } else {
        __eax = _v4;
        __esp =  &(__esp[2]);
        return _v4;
    }
L64:
}

camlList__entry()
{// addr = 0x08054CE0
     *134687076 =  &camlList__38;
    camlList =  &camlList__37;
     *134686916 =  &camlList__36;
     *134686920 =  &camlList__35;
     *134686924 =  &camlList__34;
     *134686932 =  *134679572;
     *134686936 =  &camlList__33;
     *134686928 =  &camlList__32;
     *134686944 =  &camlList__31;
     *134686940 =  *134686944;
     *134686952 =  &camlList__30;
     *134686956 =  &camlList__29;
     *134686948 =  &camlList__28;
     *134686960 =  &camlList__27;
     *134686964 =  &camlList__26;
     *134686972 =  &camlList__25;
     *134686976 =  &camlList__24;
     *134686968 =  &camlList__23;
     *134686980 =  &camlList__22;
     *134686984 =  &camlList__21;
     *134686988 =  &camlList__20;
     *134686992 =  &camlList__19;
     *134686996 =  &camlList__18;
     *134687000 =  &camlList__17;
     *134687004 =  &camlList__16;
     *134687008 =  &camlList__15;
     *134687028 =  &camlList__14;
     *134687032 =  &camlList__13;
     *134687036 =  &camlList__12;
     *134687040 =  &camlList__11;
     *134687044 =  &camlList__10;
     *134687048 =  &camlList__9;
     *134687012 =  &camlList__8;
     *134687020 =  &camlList__7;
     *134687016 =  *134687020;
     *134687024 =  &camlList__6;
     *134687052 =  &camlList__5;
     *134687056 =  &camlList__4;
     *134687072 =  &camlList__3;
     *134687080 =  &camlList__2;
     *134687064 =  &camlList__1;
     *134687060 =  *134687064;
     *134687068 =  *134687064;
    return 1;
}

camlSys__set_signal_1057(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08054EE0
    __ebx = __ebx;
    caml_c_call(__ebx);
    return 1;
}

camlSys__catch_break_1082(
    intOrPtr __eax                         // r0
)
{// addr = 0x08054F00
    intOrPtr _t3;                          // _t3

    _t3 = __eax;
    if(__eax == 1) {
        __ebx = 1;
        _t3 = -11;
    } else {
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 8;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __ebx = __eax + 4;
         *((intOrPtr*)(__ebx - 4)) = 1024;
         *__ebx =  &camlSys__5;
        __eax = -11;
    }
    caml_c_call(__ebx);
    return 1;
}

camlSys__entry()
{// addr = 0x08054F60
    signed int _t16;                       // _t16
    intOrPtr* _t24;                        // _t24
    signed int _t31;                       // _t31
    intOrPtr* _t32;                        // _t32

    caml_c_call(1);
    __esp = __esp + 4;
     *134689852 =  *caml_sys_get_argv;
    camlSys =  *((intOrPtr*)(0x80662cd));
    caml_c_call(1);
     *134689860 =  *caml_sys_get_config;
     *134689864 =  *0x08066249;
     *134689872 = (2 <<  *134689864 + -20 >> 1) - 3 + 2;
    _t31 =  *134689872 >> 1;
    _t16 =  *134689864 >> 1;
    if(_t16 < 0) {
        _t16 = _t16 + 7;
    }
     *134689868 = (_t16 >> 3 << 1) * _t31 - 3 + 2;
    _t32 = caml_alloc3() + 4;
     *((intOrPtr*)(_t32 - 4)) = 1024;
     *_t32 = 1;
     *134689856 = _t32;
     *134689876 =  &camlSys__4;
     *134689880 = -1;
     *134689884 = -3;
     *134689888 = -5;
     *134689892 = -7;
     *134689896 = -9;
     *134689900 = -11;
     *134689904 = -13;
     *134689908 = -15;
     *134689912 = -17;
     *134689916 = -19;
     *134689920 = -21;
     *134689924 = -23;
     *134689928 = -25;
     *134689932 = -27;
     *134689936 = -29;
     *134689940 = -31;
     *134689944 = -33;
     *134689948 = -35;
     *134689952 = -37;
     *134689956 = -39;
     *134689960 = -41;
    _t24 = _t32 + 8;
     *((intOrPtr*)(_t24 - 4)) = 1024;
     *_t24 = "Sys.Break";
     *134689964 = _t24;
     *134689968 =  &camlSys__2;
     *134689972 = "3.12.1";
    return 1;
}

camlHashtbl__code_begin(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08055110
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t20;                         // _t20
    intOrPtr _t24;                         // _t24
    intOrPtr* _t26;                        // _t26
    intOrPtr _t39;                         // _t39

    if(__eax == 1) {
        return 1;
    } else {
        _v8 = __ebx;
        _v4 =  *((intOrPtr*)(__eax + 8));
        _v12 =  *((intOrPtr*)(__eax + 4));
        _t20 =  *__eax;
         *__esp = _t20;
        caml_apply2();
        if(_t20 == 1) {
            _t39 = camlHashtbl__code_begin(_v4, _v8);
            while(1) {
                _t24 = caml_young_ptr - 16;
                caml_young_ptr = _t24;
                if(_t24 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t26 = _t24 + 4;
             *((intOrPtr*)(_t26 - 4)) = 3072;
             *_t26 =  *__esp;
            _t26[1] = _v12;
            _t26[2] = _t39;
            return _t26;
        } else {
             *((intOrPtr*)( *((intOrPtr*)(_v8 + 12)))) =  *((intOrPtr*)( *((intOrPtr*)(_v8 + 12)))) + -2;
            return _v4;
        }
    }
}

camlHashtbl__find_in_bucket_1213(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080551C0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr* _t13;                        // _t13
    intOrPtr _t19;                         // _t19
    intOrPtr* _t21;                        // _t21
    intOrPtr _t22;                         // _t22
    intOrPtr _t30;                         // _t30

    _t22 = __ebx;
    _t13 = __eax;
    while(_t13 != 1) {
        _v8 = _t22;
         *__esp = _t13[2];
        _v4 = _t13[1];
        caml_apply2();
        if( *_t13 == 1) {
            _t13 =  *__esp;
            _t22 = _v8;
            continue;
        } else {
            _t30 = camlHashtbl__find_in_bucket_1213( *__esp, _v8);
            while(1) {
                _t19 = caml_young_ptr - 12;
                caml_young_ptr = _t19;
                if(_t19 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t21 = _t19 + 4;
             *((intOrPtr*)(_t21 - 4)) = 2048;
             *_t21 = _v4;
            _t21[1] = _t30;
            return _t21;
        }
L9:
    }
    return 1;
    goto L9;
}

camlHashtbl__replace_bucket_1221(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08055250
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t27;                         // _t27
    intOrPtr* _t29;                        // _t29
    intOrPtr _t31;                         // _t31
    intOrPtr _t35;                         // _t35
    intOrPtr* _t37;                        // _t37
    intOrPtr _t39;                         // _t39
    intOrPtr* _t41;                        // _t41
    intOrPtr _t55;                         // _t55

    if(__eax == 1) {
L7:
        _t27 = caml_young_ptr - 8;
        caml_young_ptr = _t27;
        if(_t27 >= caml_young_limit) {
            _t29 = _t27 + 4;
             *((intOrPtr*)(_t29 - 4)) = 1024;
             *_t29 =  &caml_exn_Not_found;
            caml_raise_exn(_t29);
        }
        caml_call_gc();
        goto L7;
    }
    _v8 = __ebx;
    _v4 =  *((intOrPtr*)(__eax + 8));
     *__esp =  *((intOrPtr*)(__eax + 4));
    _t31 =  *__eax;
    _v12 = _t31;
    caml_apply2();
    if(_t31 == 1) {
        _t55 = camlHashtbl__replace_bucket_1221(_v4, _v8);
        while(1) {
            _t35 = caml_young_ptr - 16;
            caml_young_ptr = _t35;
            if(_t35 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t37 = _t35 + 4;
         *((intOrPtr*)(_t37 - 4)) = 3072;
         *_t37 = _v12;
        _t37[1] =  *__esp;
        _t37[2] = _t55;
        return _t37;
    } else {
        while(1) {
            _t39 = caml_young_ptr - 16;
            caml_young_ptr = _t39;
            if(_t39 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t41 = _t39 + 4;
         *((intOrPtr*)(_t41 - 4)) = 3072;
         *_t41 = _v12;
        _t41[1] =  *((intOrPtr*)(_v8 + 16));
        _t41[2] = _v4;
        return _t41;
    }
}

camlHashtbl__mem_in_bucket_1230(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08055370
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t6;                         // _t6
    intOrPtr _t10;                         // _t10

    _t10 = __ebx;
    _t6 = __eax;
    while(_t6 != 1) {
        _v4 = _t10;
         *__esp = _t6[2];
        caml_apply2();
        if( *_t6 == 1) {
            _t6 =  *__esp;
            _t10 = _v4;
            continue;
        } else {
            return 3;
        }
L6:
    }
    return 1;
    goto L6;
}

unsigned int* camlHashtbl__insert_bucket_1068(
    signed int* __eax                      // r0
)
{// addr = 0x080553C0
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    unsigned int _t50;                     // _t50
    unsigned int _t53;                     // _t53
    intOrPtr _t59;                         // _t59
    unsigned int* _t60;                    // _t60
    intOrPtr _t65;                         // _t65
    unsigned int _t71;                     // _t71
    signed int _t73;                       // _t73
    unsigned int _t74;                     // _t74
    unsigned int _t86;                     // _t86
    signed int _t89;                       // _t89
    signed int _t91;                       // _t91
    intOrPtr _t94;                         // _t94

    if(__eax == 1) {
        return 1;
    } else {
         *__esp = _t71;
        _t89 = __eax[2];
        _v12 = __eax[1];
        _v8 =  *__eax;
        camlHashtbl__insert_bucket_1068(_t89);
        _t50 =  *__esp;
        _t73 =  *(_t50 + 12) >> 1;
        if(_t73 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _v4 = _t73;
             *__esp = _t50;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t50 + 8))))))();
            asm("cdq");
            _t89 = (_v8 >> 1) % _v4;
        }
        _t91 = (_t89 << 1) + 1;
        _t74 =  *__esp;
        _t83 =  *((intOrPtr*)(_t74 + 16));
        _t53 =  *( *((intOrPtr*)(_t74 + 16)) - 4) >> 9;
        if(_t53 <= _t91) {
L11:
            caml_ml_array_bound_error();
            __esp = __esp - 16;
            if(_t53 == 1) {
                return 1;
            } else {
                _v24 = _t74;
                _v20 =  *(_t53 + 8);
                _v28 =  *(_t53 + 4);
                 *__esp =  *_t53;
                caml_c_call( *((intOrPtr*)(_t74 + 12)));
                if(caml_compare != 1) {
                    L12();
                    _t86 = _v20;
                    while(1) {
                        _t59 = caml_young_ptr - 16;
                        caml_young_ptr = _t59;
                        if(_t59 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t60 = _t59 + 4;
                     *((intOrPtr*)(_t60 - 4)) = 3072;
                     *_t60 =  *__esp;
                    _t60[1] = _v28;
                    _t60[2] = _t86;
                    return _t60;
                } else {
                     *((intOrPtr*)( *((intOrPtr*)(_v24 + 8)))) =  *((intOrPtr*)( *((intOrPtr*)(_v24 + 8)))) + -2;
                    return _v20;
                }
            }
        } else {
            while(1) {
                _t65 = caml_young_ptr - 16;
                caml_young_ptr = _t65;
                if(_t65 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t53 = _t65 + 4;
             *(_t53 - 4) = 3072;
             *_t53 = _v8;
             *(_t53 + 4) = _v12;
            _t94 =  *((intOrPtr*)(_t74 + 16));
            _t74 =  *(_t94 - 4) >> 9;
            if(_t74 <= _t91) {
                caml_ml_array_bound_error();
                goto L11;
            } else {
                 *(_t53 + 8) =  *(_t94 + _t91 * 2 - 2);
                caml_modify( *(_t94 + _t91 * 2 - 2), __edi, _t94, _t83 + _t91 * 2 - 2, _t53);
                return 1;
            }
        }
    }
}

camlHashtbl__remove_bucket_1083(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080554B0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t24;                         // _t24
    intOrPtr* _t26;                        // _t26
    intOrPtr _t36;                         // _t36

    if(__eax == 1) {
        return 1;
    } else {
        _v8 = __ebx;
        _v4 =  *((intOrPtr*)(__eax + 8));
        _v12 =  *((intOrPtr*)(__eax + 4));
         *__esp =  *__eax;
        caml_c_call( *((intOrPtr*)(__ebx + 12)));
        if(caml_compare != 1) {
            _t36 = camlHashtbl__remove_bucket_1083(_v4, _v8);
            while(1) {
                _t24 = caml_young_ptr - 16;
                caml_young_ptr = _t24;
                if(_t24 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t26 = _t24 + 4;
             *((intOrPtr*)(_t26 - 4)) = 3072;
             *_t26 =  *__esp;
            _t26[1] = _v12;
            _t26[2] = _t36;
            return _t26;
        } else {
             *((intOrPtr*)( *((intOrPtr*)(_v8 + 8)))) =  *((intOrPtr*)( *((intOrPtr*)(_v8 + 8)))) + -2;
            return _v4;
        }
    }
}

camlHashtbl__find_in_bucket_1108(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08055560
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t12;                         // _t12
    intOrPtr _t19;                         // _t19
    intOrPtr* _t21;                        // _t21
    intOrPtr _t22;                         // _t22
    intOrPtr _t27;                         // _t27

    _t22 = __ebx;
    _t12 = __eax;
    while(_t12 != 1) {
        _v8 = _t22;
         *__esp =  *((intOrPtr*)(_t12 + 8));
        _v4 =  *((intOrPtr*)(_t12 + 4));
        caml_c_call( *((intOrPtr*)(_t22 + 8)));
        if(caml_compare != 1) {
            _t12 =  *__esp;
            _t22 = _v8;
            continue;
        } else {
            _t27 = camlHashtbl__find_in_bucket_1108( *__esp, _v8);
            while(1) {
                _t19 = caml_young_ptr - 12;
                caml_young_ptr = _t19;
                if(_t19 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t21 = _t19 + 4;
             *((intOrPtr*)(_t21 - 4)) = 2048;
             *_t21 = _v4;
            _t21[1] = _t27;
            return _t21;
        }
L9:
    }
    return 1;
    goto L9;
}

camlHashtbl__replace_bucket_1116(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080555F0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t26;                         // _t26
    intOrPtr* _t28;                        // _t28
    intOrPtr _t35;                         // _t35
    intOrPtr* _t37;                        // _t37
    intOrPtr _t39;                         // _t39
    intOrPtr* _t41;                        // _t41
    intOrPtr _t52;                         // _t52

    if(__eax == 1) {
L7:
        _t26 = caml_young_ptr - 8;
        caml_young_ptr = _t26;
        if(_t26 >= caml_young_limit) {
            _t28 = _t26 + 4;
             *((intOrPtr*)(_t28 - 4)) = 1024;
             *_t28 =  &caml_exn_Not_found;
            caml_raise_exn(_t28);
        }
        caml_call_gc();
        goto L7;
    }
    _v8 = __ebx;
    _v4 =  *((intOrPtr*)(__eax + 8));
     *__esp =  *((intOrPtr*)(__eax + 4));
    _t30 =  *__eax;
    _v12 =  *__eax;
    caml_c_call( *((intOrPtr*)(__ebx + 8)));
    if(caml_compare != 1) {
        _t52 = camlHashtbl__replace_bucket_1116(_v4, _v8);
        while(1) {
            _t35 = caml_young_ptr - 16;
            caml_young_ptr = _t35;
            if(_t35 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t37 = _t35 + 4;
         *((intOrPtr*)(_t37 - 4)) = 3072;
         *_t37 = _v12;
        _t37[1] =  *__esp;
        _t37[2] = _t52;
        return _t37;
    } else {
        while(1) {
            _t39 = caml_young_ptr - 16;
            caml_young_ptr = _t39;
            if(_t39 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t41 = _t39 + 4;
         *((intOrPtr*)(_t41 - 4)) = 3072;
         *_t41 = _v12;
        _t41[1] =  *((intOrPtr*)(_v8 + 12));
        _t41[2] = _v4;
        return _t41;
    }
}

camlHashtbl__mem_in_bucket_1125(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08055710
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t5;                          // _t5

    __ebx = __ebx;
    _t5 = __eax;
    while(_t5 != 1) {
        _v4 = __ebx;
         *__esp =  *((intOrPtr*)(_t5 + 8));
        caml_c_call( *((intOrPtr*)(__ebx + 8)));
        if(caml_compare != 1) {
            _t5 =  *__esp;
            __ebx = _v4;
            continue;
        } else {
            return 3;
        }
L6:
    }
    return 1;
    goto L6;
}

camlHashtbl__do_bucket_1132(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x08055770
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _t6;                          // _t6
    intOrPtr _t9;                          // _t9

    _t9 = __ebx;
    _t6 = __eax;
    while(_t6 != 1) {
        _v4 = _t9;
         *__esp =  *((intOrPtr*)(_t6 + 8));
        caml_apply2();
        _t6 =  *__esp;
        _t9 = _v4;
    }
    return 1;
}

camlHashtbl__do_bucket_1142(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x080557B0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _t6;                         // _t6
    intOrPtr _t9;                          // _t9
    intOrPtr _t12;                         // _t12

    _t12 = __ecx;
    _t9 = __ebx;
    _t6 = __eax;
    while(1) {
        __esi = _t9;
        if(_t6 == 1) {
            break;
        }
        _v4 = _t12;
         *__esp = _t6[2];
        caml_apply3();
        _t9 =  *_t6;
        _t6 =  *__esp;
        _t12 = _v4;
    }
    return __esi;
}

camlHashtbl__safehash_1177(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x080557F0
     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ebx + 8)) + 4))))))();
}

signed int camlHashtbl__add_1179(
    signed int __eax                       // r0
)
{// addr = 0x08055810
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    intOrPtr _t171;                        // _t171
    signed int _t172;                      // _t172
    intOrPtr _t174;                        // _t174
    intOrPtr* _t175;                       // _t175
    unsigned int _t177;                    // _t177
    intOrPtr _t179;                        // _t179
    intOrPtr* _t180;                       // _t180
    intOrPtr* _t183;                       // _t183
    unsigned int _t201;                    // _t201
    signed int _t202;                      // _t202
    signed int _t205;                      // _t205
    signed int _t207;                      // _t207
    intOrPtr _t211;                        // _t211
    signed int _t214;                      // _t214
    signed int _t219;                      // _t219
    intOrPtr _t222;                        // _t222
    unsigned int _t223;                    // _t223
    intOrPtr _t225;                        // _t225
    signed int _t226;                      // _t226
    unsigned int _t228;                    // _t228
    unsigned int _t230;                    // _t230
    intOrPtr _t232;                        // _t232
    intOrPtr* _t233;                       // _t233
    intOrPtr* _t237;                       // _t237
    signed int _t253;                      // _t253
    signed int _t260;                      // _t260
    signed int _t263;                      // _t263
    unsigned int _t264;                    // _t264
    unsigned int _t266;                    // _t266
    signed int _t273;                      // _t273
    signed int _t277;                      // _t277
    unsigned int _t280;                    // _t280
    unsigned int _t281;                    // _t281
    signed int _t290;                      // _t290
    unsigned int _t292;                    // _t292
    unsigned int _t299;                    // _t299
    unsigned int _t301;                    // _t301
    signed int _t302;                      // _t302
    unsigned int _t303;                    // _t303
    signed int _t306;                      // _t306
    signed int _t313;                      // _t313
    signed int _t315;                      // _t315
    signed int _t316;                      // _t316
    signed int _t318;                      // _t318
    signed int _t324;                      // _t324
    signed int _t326;                      // _t326
    unsigned int _t327;                    // _t327
    unsigned int _t330;                    // _t330
    signed int _t331;                      // _t331
    unsigned int _t335;                    // _t335
    signed int _t339;                      // _t339

    __esp = __esp - 20;
    _t330 =  *( *((intOrPtr*)(__eax + 4)) - 4) >> 10;
    if(_t330 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v4 = _t330;
        _v8 = _t313;
        _v16 = _t290;
         *__esp = _t260;
        _v12 = __eax;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t313 + 12)) + 8)) + 4))))))();
        asm("cdq");
        _t313 = ((_t260 & 2147483647) >> 1) % _v4;
    }
    _t315 = (_t313 << 1) + 1;
    while(1) {
        _t171 = caml_young_ptr - 16;
        caml_young_ptr = _t171;
        if(_t171 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t172 = _t171 + 4;
     *(_t172 - 4) = 3072;
     *_t172 =  *__esp;
     *(_t172 + 4) = _v16;
    _t263 = _v12;
    _t331 =  *(_t263 + 4);
    _t292 =  *((unsigned int*)(_t331 - 4)) >> 9;
    if(_t292 <= _t315) {
L12:
        caml_ml_array_bound_error();
        __esp = __esp - 12;
        _t316 = _t172;
        while(1) {
            _t174 = caml_young_ptr - 24;
            caml_young_ptr = _t174;
            if(_t174 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t175 = _t174 + 4;
         *((intOrPtr*)(_t175 - 4)) = 5367;
         *_t175 = camlHashtbl__code_begin;
         *(_t175 + 4) = 3;
         *((intOrPtr*)(_t175 + 8)) =  *((intOrPtr*)(_t292 + 12));
         *(_t175 + 12) = _t316;
         *(_t175 + 16) = _t263;
        _t335 =  *( *((intOrPtr*)(_t316 + 4)) - 4) >> 10;
        if(_t335 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _v24 = _t335;
            _v28 = _t175;
             *__esp = _t316;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t292 + 16)) + 8)) + 4))))))();
            _t292 = _v24;
            asm("cdq");
            _t316 = ((_t263 & 2147483647) >> 1) % _t292;
        }
        _t318 = (_t316 << 1) + 1;
        _v24 = _t318;
        _t177 =  *__esp;
        _t264 =  *(_t177 + 4);
         *__esp = _t264;
        _t266 =  *((unsigned int*)(_t264 - 4)) >> 9;
        if(_t266 <= _t318) {
L23:
            caml_ml_array_bound_error();
            __esp = __esp - 16;
            while(_t266 != 1) {
                _v40 = _t292;
                 *__esp = _t177;
                _v44 =  *(_t266 + 8);
                _v36 =  *((intOrPtr*)(_t266 + 4));
                caml_apply2();
                if(_t177 == 1) {
                    _t177 =  *__esp;
                    _t266 = _v44;
                    _t292 = _v40;
                    continue;
                }
                __esp =  &(__esp[4]);
                return _v36;
                goto L75;
            }
L29:
            _t179 = caml_young_ptr - 8;
            caml_young_ptr = _t179;
            if(_t179 >= caml_young_limit) {
                _t180 = _t179 + 4;
                 *((intOrPtr*)(_t180 - 4)) = 1024;
                 *_t180 =  &caml_exn_Not_found;
                caml_raise_exn(_t180);
            }
            caml_call_gc();
            goto L29;
        } else {
            _t266 =  *(_t177 + 4);
            _t177 =  *(_t266 - 4) >> 9;
            if(_t177 <= _t318) {
                caml_ml_array_bound_error();
                goto L23;
            } else {
                _t183 =  *((intOrPtr*)(_t266 + _t318 * 2 - 2));
                camlHashtbl__code_begin(_t183, _v28);
                caml_modify(_v32, _t326, _t335, _v32 + _v24 * 2 - 2, _t183);
                __esp =  &(__esp[3]);
                return 1;
            }
        }
    } else {
         *((intOrPtr*)(_t172 + 8)) =  *((intOrPtr*)(_t331 + _t315 * 2 - 2));
        _t336 =  *(_t263 + 4);
        _t292 =  *( *(_t263 + 4) - 4) >> 9;
        if(_t292 <= _t315) {
            caml_ml_array_bound_error();
            goto L12;
        } else {
            caml_modify(_t263, _t326, _t336, _t336 + _t315 * 2 - 2, _t172);
             *_t263 =  *_t263 + 2;
            if( *_t263 <= ( *( *(_t263 + 4) - 4) >> 9 | 1) + ( *( *(_t263 + 4) - 4) >> 9 | 1) - 1) {
                __esp =  &(__esp[5]);
                return 1;
            } else {
                _t201 =  *(_v8 + 12);
                __esp =  &(__esp[5]);
                while(1) {
                    __esp = __esp - 24;
                     *__esp = _t201;
                    _v8 = _t263;
                    _t202 =  *(_t263 + 4);
                    _v4 = _t202;
                    _t205 =  *((unsigned int*)(_t202 - 4)) >> 9 | 1;
                    _v16 = _t205;
                    _t207 = 3 + (_t205 >> 1) * 4;
                    camlPervasives__min_1022(_t207);
                    _t273 = _v16;
                    if(_t207 == _t273) {
                        break;
                    }
                    _v20 = _t207;
                    _v16 = _t273;
                    caml_c_call(_t207);
                    __esp =  &(__esp[1]);
                    _v12 = caml_make_vect;
                    while(1) {
                        _t211 = caml_young_ptr - 24;
                        caml_young_ptr = _t211;
                        if(_t211 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t299 = _t211 + 4;
                     *(_t299 - 4) = 5367;
                     *_t299 = camlHashtbl__insert_bucket_1068;
                     *(_t299 + 4) = 3;
                     *(_t299 + 8) =  *__esp;
                     *(_t299 + 12) = _v20;
                     *((intOrPtr*)(_t299 + 16)) = caml_make_vect;
                    _t214 = 1;
                    _t276 = _v16 + -2;
                    if(1 > _t276) {
L39:
                        caml_modify(_t276, _t326, _t336, _v8 + 4, _v12);
                        __esp =  &(__esp[6]);
                        return 1;
                    } else {
                        _v16 = _t276;
                        _v20 = 1;
                         *__esp = _t299;
                        while(1) {
                            _t277 = _v4;
                            _t301 =  *((unsigned int*)(_t277 - 4)) >> 9;
                            if(_t301 <= _t214) {
                                break;
                            }
                            camlHashtbl__insert_bucket_1068( *((intOrPtr*)(_t277 + _t214 * 2 - 2)));
                            _t253 = _v20;
                            _t214 = _t253 + 2;
                            _v20 = _t214;
                            _t276 = _v16;
                            if(_t253 != _v16) {
                                continue;
                            } else {
                                goto L39;
                            }
                            goto L75;
                        }
                        caml_ml_array_bound_error();
                        __esp = __esp - 4;
                        _t326 = _t214;
                        _t219 =  *(_t326 + 4);
                        _t336 =  *(_t219 - 4) >> 10;
                        if(_t336 == 0) {
                            caml_raise_exn( &caml_bucket_Division_by_zero);
                        } else {
                             *__esp = _t301;
                            caml_hash_univ_param(21, 201, _t277);
                            asm("cdq");
                            _t315 = (_t219 >> 1) % _t336;
                        }
                        _t315 = (_t315 << 1) + 1;
                        while(1) {
                            _t222 = caml_young_ptr - 16;
                            caml_young_ptr = _t222;
                            if(_t222 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t223 = _t222 + 4;
                         *(_t223 - 4) = 3072;
                         *_t223 = _t277;
                         *(_t223 + 4) =  *__esp;
                        _t302 =  *(_t326 + 4);
                        _t280 =  *((unsigned int*)(_t302 - 4)) >> 9;
                        if(_t280 <= _t315) {
L55:
                            caml_ml_array_bound_error();
                            __esp = __esp - 8;
                            _t327 = _t223;
                            _t303 = _t280;
                            while(1) {
                                _t225 = caml_young_ptr - 20;
                                caml_young_ptr = _t225;
                                if(_t225 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            _t281 = _t225 + 4;
                             *(_t281 - 4) = 4343;
                             *_t281 = camlHashtbl__remove_bucket_1083;
                             *(_t281 + 4) = 3;
                             *(_t281 + 8) = _t327;
                             *(_t281 + 12) = _t303;
                            _t226 =  *(_t327 + 4);
                            _t339 =  *(_t226 - 4) >> 10;
                            if(_t339 == 0) {
                                caml_raise_exn( &caml_bucket_Division_by_zero);
                            } else {
                                caml_hash_univ_param(21, 201, _t303);
                                asm("cdq");
                                _t315 = (_t226 >> 1) % _t339;
                            }
                            _t324 = (_t315 << 1) + 1;
                            _v32 = _t324;
                            _t228 =  *(_t327 + 4);
                             *__esp = _t228;
                            _t230 =  *((unsigned int*)(_t228 - 4)) >> 9;
                            if(_t230 <= _t324) {
L66:
                                caml_ml_array_bound_error();
                                __esp = __esp - 12;
                                while(_t281 != 1) {
                                     *__esp = _t230;
                                    _v44 =  *(_t281 + 8);
                                    _v40 =  *(_t281 + 4);
                                    caml_c_call( *_t281);
                                    if(caml_compare != 1) {
                                        _t230 =  *__esp;
                                        _t281 = _v44;
                                        continue;
                                    }
                                    __esp =  &(__esp[3]);
                                    return _v40;
                                    goto L75;
                                }
                                while(1) {
                                    _t232 = caml_young_ptr - 8;
                                    caml_young_ptr = _t232;
                                    if(_t232 >= caml_young_limit) {
                                        _t233 = _t232 + 4;
                                         *((intOrPtr*)(_t233 - 4)) = 1024;
                                         *_t233 =  &caml_exn_Not_found;
                                        caml_raise_exn(_t233);
                                    }
                                    caml_call_gc();
                                }
                            } else {
                                _t306 =  *(_t327 + 4);
                                _t230 =  *((unsigned int*)(_t306 - 4)) >> 9;
                                if(_t230 <= _t324) {
                                    caml_ml_array_bound_error();
                                    goto L66;
                                } else {
                                    _t237 =  *((intOrPtr*)(_t306 + _t324 * 2 - 2));
                                    camlHashtbl__remove_bucket_1083(_t237, _t281);
                                    caml_modify(_v36, _t327, _t339, _v36 + _v32 * 2 - 2, _t237);
                                    __esp =  &(__esp[2]);
                                    return 1;
                                }
                            }
                        } else {
                             *((intOrPtr*)(_t223 + 8)) =  *((intOrPtr*)(_t302 + _t315 * 2 - 2));
                            _t308 =  *(_t326 + 4);
                            _t280 =  *( *(_t326 + 4) - 4) >> 9;
                            if(_t280 <= _t315) {
                                caml_ml_array_bound_error();
                                goto L55;
                            } else {
                                caml_modify(_t280, _t326, _t336, _t308 + _t315 * 2 - 2, _t223);
                                 *_t326 =  *_t326 + 2;
                                if( *_t326 <= ( *( *(_t326 + 4) - 4) >> 9 | 1) + ( *( *(_t326 + 4) - 4) >> 9 | 1) - 1) {
                                    __esp =  &(__esp[1]);
                                    return 1;
                                } else {
                                    _t201 =  *134690256;
                                    _t263 = _t326;
                                    __esp =  &(__esp[1]);
                                    continue;
                                }
                            }
                        }
                    }
                    goto L75;
                }
                __esp =  &(__esp[6]);
                return 1;
            }
        }
    }
L75:
}

camlHashtbl__remove_1185(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    signed int __ecx                       // r2
)
{// addr = 0x08055920
    signed int _v4;                        // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    intOrPtr _t47;                         // _t47
    intOrPtr* _t48;                        // _t48
    unsigned int _t50;                     // _t50
    intOrPtr _t52;                         // _t52
    intOrPtr* _t53;                        // _t53
    intOrPtr* _t56;                        // _t56
    unsigned int _t67;                     // _t67
    unsigned int _t69;                     // _t69
    signed int _t75;                       // _t75
    signed int _t79;                       // _t79
    signed int _t81;                       // _t81
    unsigned int _t88;                     // _t88

    _t75 = __ecx;
    __esp = __esp - 12;
    _t79 = __eax;
    while(1) {
        _t47 = caml_young_ptr - 24;
        caml_young_ptr = _t47;
        if(_t47 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t48 = _t47 + 4;
     *((intOrPtr*)(_t48 - 4)) = 5367;
     *_t48 = camlHashtbl__code_begin;
     *((intOrPtr*)(_t48 + 4)) = 3;
     *((intOrPtr*)(_t48 + 8)) =  *((intOrPtr*)(_t75 + 12));
     *(_t48 + 12) = _t79;
     *((intOrPtr*)(_t48 + 16)) = __ebx;
    _t88 =  *( *((intOrPtr*)(_t79 + 4)) - 4) >> 10;
    if(_t88 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v4 = _t88;
        _v8 = _t48;
         *__esp = _t79;
         *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t75 + 16)) + 8)) + 4))))))();
        _t75 = _v4;
        asm("cdq");
        _t79 = ((__ebx & 2147483647) >> 1) % _t75;
    }
    _t81 = (_t79 << 1) + 1;
    _v4 = _t81;
    _t50 =  *__esp;
    _t67 =  *(_t50 + 4);
     *__esp = _t67;
    _t69 =  *((unsigned int*)(_t67 - 4)) >> 9;
    if(_t69 <= _t81) {
L10:
        caml_ml_array_bound_error();
        __esp = __esp - 16;
        while(_t69 != 1) {
            _v20 = _t75;
             *__esp = _t50;
            _v24 =  *(_t69 + 8);
            _v16 =  *((intOrPtr*)(_t69 + 4));
            caml_apply2();
            if(_t50 == 1) {
                _t50 =  *__esp;
                _t69 = _v24;
                _t75 = _v20;
                continue;
            }
            __esp =  &(__esp[4]);
            return _v16;
            goto L19;
        }
        while(1) {
            _t52 = caml_young_ptr - 8;
            caml_young_ptr = _t52;
            if(_t52 >= caml_young_limit) {
                _t53 = _t52 + 4;
                 *((intOrPtr*)(_t53 - 4)) = 1024;
                 *_t53 =  &caml_exn_Not_found;
                caml_raise_exn(_t53);
            }
            caml_call_gc();
        }
    } else {
        _t69 =  *(_t50 + 4);
        _t50 =  *(_t69 - 4) >> 9;
        if(_t50 <= _t81) {
            caml_ml_array_bound_error();
            goto L10;
        } else {
            _t56 =  *((intOrPtr*)(_t69 + _t81 * 2 - 2));
            camlHashtbl__code_begin(_t56, _v8);
            caml_modify(_v12, __edi, _t88, _v12 + _v4 * 2 - 2, _t56);
            __esp =  &(__esp[3]);
            return 1;
        }
    }
L19:
}

camlHashtbl__find_rec_1193(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08055A20
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t12;                         // _t12
    intOrPtr _t14;                         // _t14
    intOrPtr* _t16;                        // _t16
    intOrPtr _t19;                         // _t19
    intOrPtr _t21;                         // _t21

    _t21 = __ecx;
    _t19 = __ebx;
    _t12 = __eax;
    while(_t19 != 1) {
        _v8 = _t21;
         *__esp = _t12;
        _v12 =  *((intOrPtr*)(_t19 + 8));
        _v4 =  *((intOrPtr*)(_t19 + 4));
        caml_apply2();
        if(_t12 == 1) {
            _t12 =  *__esp;
            _t19 = _v12;
            _t21 = _v8;
            continue;
        }
        return _v4;
    }
    while(1) {
        _t14 = caml_young_ptr - 8;
        caml_young_ptr = _t14;
        if(_t14 >= caml_young_limit) {
            _t16 = _t14 + 4;
             *((intOrPtr*)(_t16 - 4)) = 1024;
             *_t16 =  &caml_exn_Not_found;
            caml_raise_exn(_t16);
        }
        caml_call_gc();
    }
}

signed int camlHashtbl__find_1198(
    unsigned int __eax                     // r0
)
{// addr = 0x08055AB0
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int* _v72;                      // _cfa_ffffffb8
    unsigned int _t270;                    // _t270
    signed int _t274;                      // _t274
    intOrPtr _t276;                        // _t276
    intOrPtr* _t277;                       // _t277
    unsigned int _t281;                    // _t281
    intOrPtr _t283;                        // _t283
    signed int _t284;                      // _t284
    unsigned int _t287;                    // _t287
    intOrPtr _t289;                        // _t289
    signed int _t290;                      // _t290
    unsigned int _t294;                    // _t294
    unsigned int _t295;                    // _t295
    intOrPtr _t310;                        // _t310
    unsigned int _t322;                    // _t322
    signed int _t323;                      // _t323
    signed int _t326;                      // _t326
    signed int _t328;                      // _t328
    intOrPtr _t332;                        // _t332
    signed int _t335;                      // _t335
    signed int _t340;                      // _t340
    intOrPtr _t343;                        // _t343
    signed int* _t344;                     // _t344
    intOrPtr _t346;                        // _t346
    signed int _t347;                      // _t347
    unsigned int _t349;                    // _t349
    unsigned int _t351;                    // _t351
    intOrPtr _t353;                        // _t353
    intOrPtr* _t354;                       // _t354
    intOrPtr* _t358;                       // _t358
    signed int _t374;                      // _t374
    intOrPtr _t385;                        // _t385
    signed int* _t387;                     // _t387
    intOrPtr _t395;                        // _t395
    intOrPtr* _t396;                       // _t396
    unsigned int _t402;                    // _t402
    intOrPtr _t404;                        // _t404
    intOrPtr* _t405;                       // _t405
    unsigned int _t409;                    // _t409
    intOrPtr _t411;                        // _t411
    intOrPtr* _t412;                       // _t412
    unsigned int _t417;                    // _t417
    intOrPtr _t419;                        // _t419
    intOrPtr* _t421;                       // _t421
    intOrPtr _t427;                        // _t427
    signed int _t428;                      // _t428
    signed int _t429;                      // _t429
    unsigned int _t430;                    // _t430
    signed int _t431;                      // _t431
    signed int _t432;                      // _t432
    _unknown_ _t436;                       // _t436
    signed int _t437;                      // _t437
    signed int _t442;                      // _t442
    signed int _t446;                      // _t446
    unsigned int _t449;                    // _t449
    signed int* _t450;                     // _t450
    intOrPtr _t464;                        // _t464
    signed int _t472;                      // _t472
    signed int _t474;                      // _t474
    signed int _t475;                      // _t475
    unsigned int _t482;                    // _t482
    unsigned int _t484;                    // _t484
    signed int _t485;                      // _t485
    unsigned int _t486;                    // _t486
    signed int _t489;                      // _t489
    unsigned int _t500;                    // _t500
    signed int _t505;                      // _t505
    signed int _t510;                      // _t510
    signed int _t512;                      // _t512
    signed int _t513;                      // _t513
    signed int _t515;                      // _t515
    signed int _t517;                      // _t517
    signed int _t518;                      // _t518
    signed int _t520;                      // _t520
    signed int _t522;                      // _t522
    signed int _t525;                      // _t525
    unsigned int _t532;                    // _t532
    signed int* _t533;                     // _t533
    unsigned int _t537;                    // _t537
    unsigned int _t538;                    // _t538
    unsigned int _t542;                    // _t542
    signed int _t543;                      // _t543
    signed int _t546;                      // _t546

    _t270 = __eax;
    __esp = __esp - 16;
    _t510 =  *( *((intOrPtr*)(__eax + 4)) - 4) >> 10;
    if(_t510 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v4 = __edx;
        _v12 = __ecx;
        _v8 = __ebx;
         *__esp = __eax;
         *((intOrPtr*)(__ecx + 16)) =  *((intOrPtr*)( *((intOrPtr*)(__ecx + 16)) + 8));
        __edx =  *( *((intOrPtr*)( *((intOrPtr*)(__ecx + 16)) + 8)) + 4);
        __ecx =  *__edx;
        __eax = __ebx;
        __ebx = __edx;
         *( *__edx)();
        __ebx = 2147483647;
        __eax = __eax & 2147483647;
        __eax = __eax >> 1;
        __ecx = _v4;
        asm("cdq");
        _t39 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t39;
    }
    _t512 = (_t510 << 1) + 1;
    _t428 =  *( *__esp + 4);
    _t274 =  *(_t428 - 4) >> 9;
    if(_t274 <= _t512) {
        caml_ml_array_bound_error();
        __esp = __esp - 12;
        _t513 = _t274;
        while(1) {
            _t276 = caml_young_ptr - 20;
            caml_young_ptr = _t276;
            if(_t276 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t277 = _t276 + 4;
         *((intOrPtr*)(_t277 - 4)) = 4343;
         *_t277 = camlHashtbl__find_in_bucket_1213;
         *(_t277 + 4) = 3;
         *((intOrPtr*)(_t277 + 8)) =  *((intOrPtr*)(_t474 + 12));
         *(_t277 + 12) = _t428;
        _t537 =  *( *((intOrPtr*)(_t513 + 4)) - 4) >> 10;
        if(_t537 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _v20 = _t537;
            _v24 = _t277;
             *__esp = _t513;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t474 + 16)) + 8)) + 4))))))();
            _t474 = _v20;
            asm("cdq");
            _t513 = ((_t428 & 2147483647) >> 1) % _t474;
        }
        _t515 = (_t513 << 1) + 1;
        _t429 =  *( *__esp + 4);
        _t281 =  *(_t429 - 4) >> 9;
        if(_t281 <= _t515) {
            caml_ml_array_bound_error();
            __esp = __esp - 32;
            _t538 = _t281;
            while(1) {
                _t283 = caml_young_ptr - 24;
                caml_young_ptr = _t283;
                if(_t283 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t284 = _t283 + 4;
             *(_t284 - 4) = 5367;
             *_t284 = camlHashtbl__replace_bucket_1221;
             *(_t284 + 4) = 3;
             *((intOrPtr*)(_t284 + 8)) =  *((intOrPtr*)(_t515 + 12));
             *(_t284 + 12) = _t429;
             *(_t284 + 16) = _t474;
            _t532 =  *( *((intOrPtr*)(_t538 + 4)) - 4) >> 10;
            if(_t532 == 0) {
                caml_raise_exn( &caml_bucket_Division_by_zero);
            } else {
                _v52 = _t532;
                _v44 = _t284;
                _v48 = _t515;
                _v56 = _t474;
                _v32 = _t429;
                 *__esp = _t538;
                 *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t515 + 16)) + 8)) + 4))))))();
                asm("cdq");
                _t515 = ((_v32 & 2147483647) >> 1) % _v52;
            }
            _t517 = (_t515 << 1) + 1;
            _v36 = _t517;
            _t430 =  *__esp;
            _t475 =  *(_t430 + 4);
            _t287 =  *(_t475 - 4) >> 9;
            if(_t287 <= _t517) {
L75:
                caml_ml_array_bound_error();
                __esp = __esp - 12;
                _t518 = _t287;
                while(1) {
                    _t289 = caml_young_ptr - 20;
                    caml_young_ptr = _t289;
                    if(_t289 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t290 = _t289 + 4;
                 *(_t290 - 4) = 4343;
                 *_t290 = camlHashtbl__mem_in_bucket_1230;
                 *(_t290 + 4) = 3;
                 *((intOrPtr*)(_t290 + 8)) =  *((intOrPtr*)(_t475 + 12));
                 *(_t290 + 12) = _t430;
                _t542 =  *( *((intOrPtr*)(_t518 + 4)) - 4) >> 10;
                if(_t542 == 0) {
                    caml_raise_exn( &caml_bucket_Division_by_zero);
                } else {
                    _v64 = _t542;
                    _v68 = _t290;
                     *__esp = _t518;
                     *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(_t475 + 16)) + 8)) + 4))))))();
                    asm("cdq");
                    _t518 = ((_t430 & 2147483647) >> 1) % _v64;
                }
                _t520 = (_t518 << 1) + 1;
                _t431 =  *( *__esp + 4);
                _t294 =  *((unsigned int*)(_t431 - 4)) >> 9;
                if(_t294 <= _t520) {
                    caml_ml_array_bound_error();
                    caml_hash_univ_param(21, 201, _t294);
                    return _t294;
                } else {
                    _t295 =  *(_t431 + _t520 * 2 - 2);
                    _t432 = _v68;
                    __esp =  &(__esp[3]);
                    __esp = __esp - 8;
                    while(_t295 != 1) {
                        _v64 = _t432;
                         *__esp =  *(_t295 + 8);
                        caml_apply2();
                        if( *_t295 == 1) {
                            _t295 =  *__esp;
                            _t432 = _v64;
                            continue;
                        } else {
                            __esp =  &(__esp[2]);
                            return 3;
                        }
                        goto L129;
                    }
                    __esp =  &(__esp[2]);
                    return 1;
                }
            } else {
                _t287 =  *(_t475 + _t517 * 2 - 2);
                _v52 = _t287;
                L69();
                _t475 =  &caml_exn_Not_found;
                _t436 =  *_t287;
                if(_t436 !=  &caml_exn_Not_found) {
                    caml_raise_exn(_t287);
                    _push(caml_exception_pointer);
                    caml_exception_pointer = __esp;
                    _t437 =  *(_t436 + 4);
                    _v36 = _t437;
                    _t430 =  *((unsigned int*)(_t437 - 4)) >> 9;
                    if(_t430 <= _t517) {
                        caml_ml_array_bound_error();
                        goto L74;
                    } else {
                        camlHashtbl__replace_bucket_1221(_t287, _v40);
                        caml_modify(_v36, _t532, _t538, _v36 + _v32 * 2 - 2, _t287);
                        _pop(caml_exception_pointer);
                        __esp =  &(__esp[8]);
                        return 1;
                    }
                } else {
                    _t430 =  *__esp;
                    _t522 =  *(_t430 + 4);
                    _t287 =  *(_t522 - 4) >> 9;
                    _t475 = _v36;
                    if(_t287 <= _t475) {
L74:
                        caml_ml_array_bound_error();
                        goto L75;
                    } else {
                        while(1) {
                            _t310 = caml_young_ptr - 16;
                            caml_young_ptr = _t310;
                            if(_t310 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t543 = _t310 + 4;
                         *(_t543 - 4) = 3072;
                         *_t543 = _v32;
                         *(_t543 + 4) = _v56;
                         *(_t543 + 8) = _v52;
                        caml_modify(_t430, _t532, _t543, _t522 + _t475 * 2 - 2, _t543);
                         *_t430 =  *_t430 + 2;
                        if( *_t430 <= ( *( *(_t430 + 4) - 4) >> 9 | 1) + ( *( *(_t430 + 4) - 4) >> 9 | 1) - 1) {
                            __esp =  &(__esp[8]);
                            return 1;
                        } else {
                            _t322 =  *(_v48 + 16);
                            __esp =  &(__esp[8]);
                            while(1) {
                                __esp = __esp - 24;
                                 *__esp = _t322;
                                _v36 = _t430;
                                _t323 =  *(_t430 + 4);
                                _v32 = _t323;
                                _t326 =  *((unsigned int*)(_t323 - 4)) >> 9 | 1;
                                _v44 = _t326;
                                _t328 = 3 + (_t326 >> 1) * 4;
                                camlPervasives__min_1022(_t328);
                                _t442 = _v44;
                                if(_t328 == _t442) {
                                    break;
                                }
                                _v48 = _t328;
                                _v44 = _t442;
                                caml_c_call(_t328);
                                __esp =  &(__esp[1]);
                                _v40 = caml_make_vect;
                                while(1) {
                                    _t332 = caml_young_ptr - 24;
                                    caml_young_ptr = _t332;
                                    if(_t332 >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc();
                                }
                                _t482 = _t332 + 4;
                                 *(_t482 - 4) = 5367;
                                 *_t482 = camlHashtbl__insert_bucket_1068;
                                 *(_t482 + 4) = 3;
                                 *(_t482 + 8) =  *__esp;
                                 *(_t482 + 12) = _v48;
                                 *((intOrPtr*)(_t482 + 16)) = caml_make_vect;
                                _t335 = 1;
                                _t445 = _v44 + -2;
                                if(1 > _t445) {
L93:
                                    caml_modify(_t445, _t532, _t543, _v36 + 4, _v40);
                                    __esp =  &(__esp[6]);
                                    return 1;
                                } else {
                                    _v44 = _t445;
                                    _v48 = 1;
                                     *__esp = _t482;
                                    while(1) {
                                        _t446 = _v32;
                                        _t484 =  *((unsigned int*)(_t446 - 4)) >> 9;
                                        if(_t484 <= _t335) {
                                            break;
                                        }
                                        camlHashtbl__insert_bucket_1068( *((intOrPtr*)(_t446 + _t335 * 2 - 2)));
                                        _t374 = _v48;
                                        _t335 = _t374 + 2;
                                        _v48 = _t335;
                                        _t445 = _v44;
                                        if(_t374 != _v44) {
                                            continue;
                                        } else {
                                            goto L93;
                                        }
                                        goto L129;
                                    }
                                    caml_ml_array_bound_error();
                                    __esp = __esp - 4;
                                    _t532 = _t335;
                                    _t340 =  *(_t532 + 4);
                                    _t543 =  *(_t340 - 4) >> 10;
                                    if(_t543 == 0) {
                                        caml_raise_exn( &caml_bucket_Division_by_zero);
                                    } else {
                                         *__esp = _t484;
                                        caml_hash_univ_param(21, 201, _t446);
                                        asm("cdq");
                                        _t522 = (_t340 >> 1) % _t543;
                                    }
                                    _t522 = (_t522 << 1) + 1;
                                    while(1) {
                                        _t343 = caml_young_ptr - 16;
                                        caml_young_ptr = _t343;
                                        if(_t343 >= caml_young_limit) {
                                            break;
                                        }
                                        caml_call_gc();
                                    }
                                    _t344 = _t343 + 4;
                                     *((intOrPtr*)(_t344 - 4)) = 3072;
                                     *_t344 = _t446;
                                    _t344[1] =  *__esp;
                                    _t485 =  *(_t532 + 4);
                                    _t449 =  *((unsigned int*)(_t485 - 4)) >> 9;
                                    if(_t449 <= _t522) {
L109:
                                        caml_ml_array_bound_error();
                                        __esp = __esp - 8;
                                        _t533 = _t344;
                                        _t486 = _t449;
                                        while(1) {
                                            _t346 = caml_young_ptr - 20;
                                            caml_young_ptr = _t346;
                                            if(_t346 >= caml_young_limit) {
                                                break;
                                            }
                                            caml_call_gc();
                                        }
                                        _t450 = _t346 + 4;
                                         *((intOrPtr*)(_t450 - 4)) = 4343;
                                         *_t450 = camlHashtbl__remove_bucket_1083;
                                        _t450[1] = 3;
                                        _t450[2] = _t533;
                                        _t450[3] = _t486;
                                        _t347 = _t533[1];
                                        _t546 =  *(_t347 - 4) >> 10;
                                        if(_t546 == 0) {
                                            caml_raise_exn( &caml_bucket_Division_by_zero);
                                        } else {
                                            caml_hash_univ_param(21, 201, _t486);
                                            asm("cdq");
                                            _t522 = (_t347 >> 1) % _t546;
                                        }
                                        _t525 = (_t522 << 1) + 1;
                                        _v60 = _t525;
                                        _t349 = _t533[1];
                                         *__esp = _t349;
                                        _t351 =  *((unsigned int*)(_t349 - 4)) >> 9;
                                        if(_t351 <= _t525) {
L120:
                                            caml_ml_array_bound_error();
                                            __esp = __esp - 12;
                                            while(_t450 != 1) {
                                                 *__esp = _t351;
                                                _v72 = _t450[2];
                                                _v68 = _t450[1];
                                                caml_c_call( *_t450);
                                                if(caml_compare != 1) {
                                                    _t351 =  *__esp;
                                                    _t450 = _v72;
                                                    continue;
                                                }
                                                __esp =  &(__esp[3]);
                                                return _v68;
                                                goto L129;
                                            }
                                            while(1) {
                                                _t353 = caml_young_ptr - 8;
                                                caml_young_ptr = _t353;
                                                if(_t353 >= caml_young_limit) {
                                                    _t354 = _t353 + 4;
                                                     *((intOrPtr*)(_t354 - 4)) = 1024;
                                                     *_t354 =  &caml_exn_Not_found;
                                                    caml_raise_exn(_t354);
                                                }
                                                caml_call_gc();
                                            }
                                        } else {
                                            _t489 = _t533[1];
                                            _t351 =  *((unsigned int*)(_t489 - 4)) >> 9;
                                            if(_t351 <= _t525) {
                                                caml_ml_array_bound_error();
                                                goto L120;
                                            } else {
                                                _t358 =  *((intOrPtr*)(_t489 + _t525 * 2 - 2));
                                                camlHashtbl__remove_bucket_1083(_t358, _t450);
                                                caml_modify(_v64, _t533, _t546, _v64 + _v60 * 2 - 2, _t358);
                                                __esp =  &(__esp[2]);
                                                return 1;
                                            }
                                        }
                                    } else {
                                        _t344[2] =  *(_t485 + _t522 * 2 - 2);
                                        _t491 =  *(_t532 + 4);
                                        _t449 =  *( *(_t532 + 4) - 4) >> 9;
                                        if(_t449 <= _t522) {
                                            caml_ml_array_bound_error();
                                            goto L109;
                                        } else {
                                            caml_modify(_t449, _t532, _t543, _t491 + _t522 * 2 - 2, _t344);
                                             *_t532 =  *_t532 + 2;
                                            if( *_t532 <= ( *( *(_t532 + 4) - 4) >> 9 | 1) + ( *( *(_t532 + 4) - 4) >> 9 | 1) - 1) {
                                                __esp =  &(__esp[1]);
                                                return 1;
                                            } else {
                                                _t322 =  *134690256;
                                                _t430 = _t532;
                                                __esp =  &(__esp[1]);
                                                continue;
                                            }
                                        }
                                    }
                                }
                                goto L129;
                            }
                            __esp =  &(__esp[6]);
                            return 1;
                        }
                    }
                }
            }
        } else {
            _t270 =  *(_t429 + _t515 * 2 - 2);
            _t427 = _v24;
            __esp =  &(__esp[3]);
            __esp = __esp - 12;
            while(_t270 != 1) {
                _v24 = _t427;
                 *__esp =  *(_t270 + 8);
                _v20 =  *(_t270 + 4);
                caml_apply2();
                if( *_t270 == 1) {
                    _t270 =  *__esp;
                    _t427 = _v24;
                    continue;
                } else {
                    L1();
                    _t500 =  *__esp;
                    while(1) {
                        _t385 = caml_young_ptr - 12;
                        caml_young_ptr = _t385;
                        if(_t385 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t387 = _t385 + 4;
                     *((intOrPtr*)(_t387 - 4)) = 2048;
                     *_t387 = _v20;
                    _t387[1] = _t500;
                    __esp =  &(__esp[3]);
                    return _t387;
                }
                goto L129;
            }
            __esp =  &(__esp[3]);
            return 1;
        }
    } else {
        _t464 =  *((intOrPtr*)(_t428 + _t512 * 2 - 2));
        if(_t464 == 1) {
L41:
            _t395 = caml_young_ptr - 8;
            caml_young_ptr = _t395;
            if(_t395 >= caml_young_limit) {
                _t396 = _t395 + 4;
                 *((intOrPtr*)(_t396 - 4)) = 1024;
                 *_t396 =  &caml_exn_Not_found;
                caml_raise_exn(_t396);
            }
            caml_call_gc();
            goto L41;
        }
         *__esp =  *(_t464 + 8);
        _v4 =  *(_t464 + 4);
        caml_apply2();
        if(_v8 == 1) {
            _t402 =  *__esp;
            if(_t402 == 1) {
                while(1) {
L39:
                    _t404 = caml_young_ptr - 8;
                    caml_young_ptr = _t404;
                    if(_t404 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t405 = _t404 + 4;
                 *((intOrPtr*)(_t405 - 4)) = 1024;
                 *_t405 =  &caml_exn_Not_found;
                caml_raise_exn(_t405);
                goto L41;
            }
             *__esp =  *(_t402 + 8);
            _v4 =  *(_t402 + 4);
            caml_apply2();
            if(_v8 == 1) {
                _t409 =  *__esp;
                if(_t409 == 1) {
                    while(1) {
                        _t411 = caml_young_ptr - 8;
                        caml_young_ptr = _t411;
                        if(_t411 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t412 = _t411 + 4;
                     *((intOrPtr*)(_t412 - 4)) = 1024;
                     *_t412 =  &caml_exn_Not_found;
                    caml_raise_exn(_t412);
                    goto L39;
                }
                 *__esp =  *(_t409 + 8);
                _v4 =  *(_t409 + 4);
                caml_apply2();
                if(_v8 == 1) {
                    _t505 =  *(_v12 + 20);
                    _t417 = _v8;
                    _t472 =  *__esp;
                    __esp =  &(__esp[4]);
                    __esp = __esp - 16;
                    while(_t472 != 1) {
                        _v8 = _t505;
                         *__esp = _t417;
                        _v12 =  *(_t472 + 8);
                        _v4 =  *(_t472 + 4);
                        caml_apply2();
                        if(_t417 == 1) {
                            _t417 =  *__esp;
                            _t472 = _v12;
                            _t505 = _v8;
                            continue;
                        }
                        __esp =  &(__esp[4]);
                        return _v4;
                        goto L129;
                    }
L21:
                    _t419 = caml_young_ptr - 8;
                    caml_young_ptr = _t419;
                    if(_t419 >= caml_young_limit) {
                        _t421 = _t419 + 4;
                         *((intOrPtr*)(_t421 - 4)) = 1024;
                         *_t421 =  &caml_exn_Not_found;
                        caml_raise_exn(_t421);
                    }
                    caml_call_gc();
                    goto L21;
                } else {
                    __esp =  &(__esp[4]);
                    return _v4;
                }
            } else {
                __esp =  &(__esp[4]);
                return _v4;
            }
        } else {
            __esp =  &(__esp[4]);
            return _v4;
        }
    }
L129:
}

unsigned int camlHashtbl__find_all_1210(
    unsigned int __eax                     // r0
)
{// addr = 0x08055CC0
    signed int _v4;                        // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    signed int _v16;                       // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    unsigned int _t211;                    // _t211
    unsigned int _t216;                    // _t216
    signed int* _t218;                     // _t218
    unsigned int _t219;                    // _t219
    unsigned int _t227;                    // _t227

    _t211 = __eax;
    __esp = __esp - 12;
    __edx = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __eax = __eax + 4;
     *(__eax - 4) = 4343;
     *__eax = camlHashtbl__find_in_bucket_1213;
     *(__eax + 4) = 3;
    __esi =  *(__ecx + 12);
     *(__eax + 8) =  *(__ecx + 12);
     *(__eax + 12) = __ebx;
    __esi =  *(__edx + 4);
    __esi =  *( *(__edx + 4) - 4);
    __esi =  *( *(__edx + 4) - 4) >> 10;
    if(__esi == 0) {
        __eax =  &caml_bucket_Division_by_zero;
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v4 = __esi;
        _v8 = __eax;
         *__esp = __edx;
        __eax =  *(__ecx + 16);
        __eax =  *( *(__ecx + 16) + 8);
        __edx =  *( *( *(__ecx + 16) + 8) + 4);
        __ecx =  *__edx;
        __eax = __ebx;
        __ebx = __edx;
         *( *__edx)();
        __ebx = 2147483647;
        __eax = __eax & 2147483647;
        __eax = __eax >> 1;
        __ecx = _v4;
        asm("cdq");
        _t33 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t33;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    __eax =  *__esp;
    __ebx =  *( *__esp + 4);
     *(__ebx - 4) =  *(__ebx - 4) >> 9;
    if( *(__ebx - 4) >> 9 <= __edx) {
        caml_ml_array_bound_error();
        __esp = __esp - 32;
        __esi = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 24;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        __eax = __eax + 4;
         *(__eax - 4) = 5367;
         *__eax = camlHashtbl__replace_bucket_1221;
         *(__eax + 4) = 3;
        __edi =  *(__edx + 12);
         *(__eax + 8) =  *(__edx + 12);
         *(__eax + 12) = __ebx;
         *(__eax + 16) = __ecx;
        __edi =  *(__esi + 4);
        __edi =  *( *(__esi + 4) - 4);
        __edi =  *( *(__esi + 4) - 4) >> 10;
        if(__edi == 0) {
            __eax =  &caml_bucket_Division_by_zero;
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _v36 = __edi;
            _v28 = __eax;
            _v32 = __edx;
            _v40 = __ecx;
            _v16 = __ebx;
             *__esp = __esi;
            __eax =  *(__edx + 16);
            __eax =  *( *(__edx + 16) + 8);
            __ebx =  *(__eax + 4);
            __ecx =  *( *(__eax + 4));
            __eax = _v16;
             *__ecx();
            __ebx = 2147483647;
            __eax = _v16 & 2147483647;
            __eax = (_v16 & 2147483647) >> 1;
            __ecx = _v36;
            asm("cdq");
            _t62 = __eax % __ecx;
            __eax = __eax / __ecx;
            __edx = _t62;
        }
        __edx = __edx << 1;
        __edx = __edx + 1;
        _v20 = __edx;
        __ebx =  *__esp;
        __ecx =  *(__ebx + 4);
         *(__ecx - 4) =  *(__ecx - 4) >> 9;
        if( *(__ecx - 4) >> 9 <= __edx) {
L43:
            caml_ml_array_bound_error();
            __esp = __esp - 12;
            __edx = __eax;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 20;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            __eax = __eax + 4;
             *(__eax - 4) = 4343;
             *__eax = camlHashtbl__mem_in_bucket_1230;
             *(__eax + 4) = 3;
            __esi =  *(__ecx + 12);
             *(__eax + 8) =  *(__ecx + 12);
             *(__eax + 12) = __ebx;
            __esi =  *(__edx + 4);
            __esi =  *( *(__edx + 4) - 4);
            __esi =  *( *(__edx + 4) - 4) >> 10;
            if(__esi == 0) {
                __eax =  &caml_bucket_Division_by_zero;
                caml_raise_exn( &caml_bucket_Division_by_zero);
            } else {
                _v48 = __esi;
                _v52 = __eax;
                 *__esp = __edx;
                __eax =  *(__ecx + 16);
                __eax =  *( *(__ecx + 16) + 8);
                __edx =  *( *( *(__ecx + 16) + 8) + 4);
                __ecx =  *__edx;
                __eax = __ebx;
                __ebx = __edx;
                 *( *__edx)();
                __ebx = 2147483647;
                __eax = __eax & 2147483647;
                __eax = __eax >> 1;
                __ecx = _v48;
                asm("cdq");
                _t115 = __eax % __ecx;
                __eax = __eax / __ecx;
                __edx = _t115;
            }
            __edx = __edx << 1;
            __edx = __edx + 1;
            __eax =  *__esp;
            __ebx =  *( *__esp + 4);
             *(__ebx - 4) =  *(__ebx - 4) >> 9;
            if( *(__ebx - 4) >> 9 <= __edx) {
                caml_ml_array_bound_error();
                caml_hash_univ_param(21, 201, __eax);
                return __eax;
            } else {
                __eax =  *(__ebx + __edx * 2 - 2);
                __ebx = _v52;
                __esp =  &(__esp[3]);
                __esp = __esp - 8;
                while(__eax != 1) {
                    _v48 = __ebx;
                    __ecx =  *(__eax + 8);
                     *__esp =  *(__eax + 8);
                    __eax =  *__eax;
                     *(__ebx + 8) =  *( *(__ebx + 8));
                    __ebx =  *(__ebx + 12);
                    caml_apply2();
                    if(__eax == 1) {
                        __eax =  *__esp;
                        __ebx = _v48;
                        continue;
                    } else {
                        __eax = 3;
                        __esp =  &(__esp[2]);
                        return 3;
                    }
                    goto L97;
                }
                __eax = 1;
                __esp =  &(__esp[2]);
                return 1;
            }
        } else {
            __eax =  *(__ecx + __edx * 2 - 2);
            _v36 = __eax;
            L37();
            __ecx =  &caml_exn_Not_found;
            __ebx =  *__eax;
            if(__ebx !=  &caml_exn_Not_found) {
                caml_raise_exn(__eax);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                __ebx =  *(__ebx + 4);
                _v20 = __ebx;
                __ebx =  *(__ebx - 4);
                __ebx = __ebx >> 9;
                if(__ebx <= __edx) {
                    caml_ml_array_bound_error();
                    goto L42;
                } else {
                    __ebx = _v24;
                    camlHashtbl__replace_bucket_1221(__eax, _v24);
                    _push(__eax);
                    __ebx = _v20;
                    __eax = _v16;
                    __eax = __ebx + _v16 * 2 - 2;
                    _push(__ebx + _v16 * 2 - 2);
                    caml_modify(__ebx, __edi, __esi);
                    __esp =  &(__esp[2]);
                    __eax = 1;
                    _pop(caml_exception_pointer);
                    __esp =  &(__esp[8]);
                    return 1;
                }
            } else {
                __ebx =  *__esp;
                __edx =  *(__ebx + 4);
                 *(__edx - 4) =  *(__edx - 4) >> 9;
                __ecx = _v20;
                if( *(__edx - 4) >> 9 <= __ecx) {
L42:
                    caml_ml_array_bound_error();
                    goto L43;
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 16;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    __esi = __eax + 4;
                     *(__esi - 4) = 3072;
                    __eax = _v16;
                     *__esi = _v16;
                    __eax = _v40;
                     *(__esi + 4) = _v40;
                    __eax = _v36;
                     *(__esi + 8) = _v36;
                    _push(__esi);
                    __eax = __edx + __ecx * 2 - 2;
                    _push(__edx + __ecx * 2 - 2);
                    caml_modify(__ebx, __edi, __esi);
                    __esp =  &(__esp[2]);
                     *__ebx =  *__ebx + 2;
                    __eax =  *(__ebx + 4);
                    __eax =  *( *(__ebx + 4) - 4);
                    __eax =  *( *(__ebx + 4) - 4) >> 9;
                    __ecx = ( *( *(__ebx + 4) - 4) >> 9 | 1) + ( *( *(__ebx + 4) - 4) >> 9 | 1) - 1;
                    __eax =  *__ebx;
                    if( *__ebx <= __ecx) {
                        __eax = 1;
                        __esp =  &(__esp[8]);
                        return 1;
                    } else {
                        __eax = _v32;
                        __eax =  *(_v32 + 16);
                        __esp =  &(__esp[8]);
                        while(1) {
                            __esp = __esp - 24;
                             *__esp = __eax;
                            _v20 = __ebx;
                            __eax =  *(__ebx + 4);
                            _v16 = __eax;
                            __eax =  *(__eax - 4);
                            __eax = __eax >> 9;
                            __eax = __eax | 1;
                            _v28 = __eax;
                            __ebx =  *134689872;
                            __eax = __eax >> 1;
                            __eax = 3 + __eax * 4;
                            camlPervasives__min_1022(__eax);
                            __ebx = _v28;
                            if(__eax == __ebx) {
                                break;
                            }
                            _v32 = __eax;
                            _v28 = __ebx;
                            _push(__eax);
                            __eax = caml_make_vect;
                            caml_c_call(1);
                            __esp =  &(__esp[2]);
                            __ebx = caml_make_vect;
                            _v24 = caml_make_vect;
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 24;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            __ecx = __eax + 4;
                             *(__ecx - 4) = 5367;
                             *__ecx = camlHashtbl__insert_bucket_1068;
                             *(__ecx + 4) = 3;
                            __eax =  *__esp;
                             *(__ecx + 8) =  *__esp;
                            __eax = _v32;
                             *(__ecx + 12) = _v32;
                             *(__ecx + 16) = __ebx;
                            __eax = 1;
                            __ebx = _v28;
                            __ebx = _v28 + -2;
                            if(1 > __ebx) {
L61:
                                __eax = _v24;
                                _push(_v24);
                                __eax = _v20;
                                __eax = _v20 + 4;
                                _push(_v20 + 4);
                                caml_modify(__ebx, __edi, __esi);
                                __esp =  &(__esp[2]);
                                __eax = 1;
                                __esp =  &(__esp[6]);
                                return 1;
                            } else {
                                _v28 = __ebx;
                                _v32 = 1;
                                 *__esp = __ecx;
                                while(1) {
                                    __ebx = _v16;
                                     *(__ebx - 4) =  *(__ebx - 4) >> 9;
                                    if( *(__ebx - 4) >> 9 <= __eax) {
                                        break;
                                    }
                                    __eax =  *(__ebx + __eax * 2 - 2);
                                    __ebx =  *__esp;
                                    camlHashtbl__insert_bucket_1068(__eax);
                                    __eax = _v32;
                                    __ecx = __eax;
                                    __eax = __eax + 2;
                                    _v32 = __eax;
                                    __ebx = _v28;
                                    if(__ecx != __ebx) {
                                        continue;
                                    } else {
                                        goto L61;
                                    }
                                    goto L97;
                                }
                                caml_ml_array_bound_error();
                                __esp = __esp - 4;
                                __edi = __eax;
                                __eax =  *(__edi + 4);
                                __esi =  *(__eax - 4);
                                __esi =  *(__eax - 4) >> 10;
                                if(__esi == 0) {
                                    __eax =  &caml_bucket_Division_by_zero;
                                    caml_raise_exn( &caml_bucket_Division_by_zero);
                                } else {
                                     *__esp = __ecx;
                                    caml_hash_univ_param(21, 201, __ebx);
                                    __eax = __eax >> 1;
                                    __ecx = __esi;
                                    asm("cdq");
                                    _t158 = __eax % __ecx;
                                    __eax = __eax / __ecx;
                                    __edx = _t158;
                                }
                                __edx = __edx << 1;
                                __edx = __edx + 1;
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 16;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc();
                                }
                                __eax = __eax + 4;
                                 *(__eax - 4) = 3072;
                                 *__eax = __ebx;
                                __ebx =  *__esp;
                                 *(__eax + 4) =  *__esp;
                                __ecx =  *(__edi + 4);
                                __ebx =  *(__ecx - 4);
                                __ebx =  *(__ecx - 4) >> 9;
                                if(__ebx <= __edx) {
L77:
                                    caml_ml_array_bound_error();
                                    __esp = __esp - 8;
                                    __edi = __eax;
                                    __ecx = __ebx;
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 20;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        caml_call_gc();
                                    }
                                    __ebx = __eax + 4;
                                     *(__ebx - 4) = 4343;
                                     *__ebx = camlHashtbl__remove_bucket_1083;
                                     *(__ebx + 4) = 3;
                                     *(__ebx + 8) = __edi;
                                     *(__ebx + 12) = __ecx;
                                    __eax =  *(__edi + 4);
                                    __esi =  *(__eax - 4);
                                    __esi =  *(__eax - 4) >> 10;
                                    if(__esi == 0) {
                                        __eax =  &caml_bucket_Division_by_zero;
                                        caml_raise_exn( &caml_bucket_Division_by_zero);
                                    } else {
                                        caml_hash_univ_param(21, 201, __ecx);
                                        __eax = __eax >> 1;
                                        __ecx = __esi;
                                        asm("cdq");
                                        _t187 = __eax % __ecx;
                                        __eax = __eax / __ecx;
                                        __edx = _t187;
                                    }
                                    __edx = __edx << 1;
                                    __edx = __edx + 1;
                                    _v44 = __edx;
                                    __eax =  *(__edi + 4);
                                     *__esp = __eax;
                                    __eax =  *(__eax - 4);
                                    if(__eax <= __edx) {
L88:
                                        caml_ml_array_bound_error();
                                        __esp = __esp - 12;
                                        while(__ebx != 1) {
                                             *__esp = __eax;
                                            __ecx =  *(__ebx + 8);
                                            _v56 =  *(__ebx + 8);
                                            __ecx =  *(__ebx + 4);
                                            _v52 =  *(__ebx + 4);
                                            _push(__ebx);
                                            _push(__eax);
                                            __eax = caml_compare;
                                            caml_c_call();
                                            __esp =  &(__esp[2]);
                                            if(caml_compare != 1) {
                                                __eax =  *__esp;
                                                __ebx = _v56;
                                                continue;
                                            }
                                            __eax = _v52;
                                            __esp =  &(__esp[3]);
                                            return _v52;
                                            goto L97;
                                        }
                                        while(1) {
                                            __eax = caml_young_ptr;
                                            __eax = caml_young_ptr - 8;
                                            caml_young_ptr = __eax;
                                            if(__eax >= caml_young_limit) {
                                                __eax = __eax + 4;
                                                 *(__eax - 4) = 1024;
                                                 *__eax =  &caml_exn_Not_found;
                                                caml_raise_exn(__eax);
                                            }
                                            caml_call_gc();
                                        }
                                    } else {
                                        __ecx =  *(__edi + 4);
                                         *(__ecx - 4) =  *(__ecx - 4) >> 9;
                                        if( *(__ecx - 4) >> 9 <= __edx) {
                                            caml_ml_array_bound_error();
                                            goto L88;
                                        } else {
                                            __eax =  *(__ecx + __edx * 2 - 2);
                                            camlHashtbl__remove_bucket_1083(__eax, __ebx);
                                            _push(__eax);
                                            __ebx = _v48;
                                            __eax = _v44;
                                            __eax = __ebx + _v44 * 2 - 2;
                                            _push(__ebx + _v44 * 2 - 2);
                                            caml_modify(__ebx, __edi, __esi);
                                            __esp =  &(__esp[2]);
                                            __eax = 1;
                                            __esp =  &(__esp[2]);
                                            return 1;
                                        }
                                    }
                                } else {
                                    __ebx =  *(__ecx + __edx * 2 - 2);
                                     *(__eax + 8) =  *(__ecx + __edx * 2 - 2);
                                    __ecx =  *(__edi + 4);
                                    __ebx =  *(__ecx - 4);
                                    __ebx =  *(__ecx - 4) >> 9;
                                    if(__ebx <= __edx) {
                                        caml_ml_array_bound_error();
                                        goto L77;
                                    } else {
                                        _push(__eax);
                                        __eax = __ecx + __edx * 2 - 2;
                                        _push(__ecx + __edx * 2 - 2);
                                        caml_modify(__ebx, __edi, __esi);
                                        __esp =  &(__esp[2]);
                                         *__edi =  *__edi + 2;
                                        __eax =  *(__edi + 4);
                                        __eax =  *( *(__edi + 4) - 4);
                                        __eax =  *( *(__edi + 4) - 4) >> 9;
                                        __ebx = ( *( *(__edi + 4) - 4) >> 9 | 1) + ( *( *(__edi + 4) - 4) >> 9 | 1) - 1;
                                        __eax =  *__edi;
                                        if( *__edi <= __ebx) {
                                            __eax = 1;
                                            __esp =  &(__esp[1]);
                                            return 1;
                                        } else {
                                            __eax =  *134690256;
                                            __ebx = __edi;
                                            __esp =  &(__esp[1]);
                                            continue;
                                        }
                                    }
                                }
                            }
                            goto L97;
                        }
                        __eax = 1;
                        __esp =  &(__esp[6]);
                        return 1;
                    }
                }
            }
        }
    } else {
        __eax =  *(__ebx + __edx * 2 - 2);
        __ebx = _v8;
        __esp =  &(__esp[3]);
        __esp = __esp - 12;
        while(_t211 != 1) {
            _v8 = _t219;
             *__esp =  *(_t211 + 8);
            _v4 =  *(_t211 + 4);
            caml_apply2();
            if( *_t211 == 1) {
                _t211 =  *__esp;
                _t219 = _v8;
                continue;
            } else {
                L1();
                _t227 =  *__esp;
                while(1) {
                    _t216 = caml_young_ptr - 12;
                    caml_young_ptr = _t216;
                    if(_t216 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t218 = _t216 + 4;
                 *((intOrPtr*)(_t218 - 4)) = 2048;
                 *_t218 = _v4;
                _t218[1] = _t227;
                __esp =  &(__esp[3]);
                return _t218;
            }
            goto L97;
        }
        __esp =  &(__esp[3]);
        return 1;
    }
L97:
}

unsigned int camlHashtbl__replace_1217(
    unsigned int __eax,                    // r0
    unsigned int __ebx,                    // r1
    _unknown_ __ecx,                       // r2
    signed int __edx                       // r3
)
{// addr = 0x08055D90
    signed int _v4;                        // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    unsigned int _t175;                    // _t175
    unsigned int _t179;                    // _t179

    __edx = __edx;
    _t179 = __ebx;
    _t175 = __eax;
    __esp = __esp - 32;
    __esi = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 24;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __eax = __eax + 4;
     *(__eax - 4) = 5367;
     *__eax = camlHashtbl__replace_bucket_1221;
     *(__eax + 4) = 3;
    __edi =  *(__edx + 12);
     *(__eax + 8) =  *(__edx + 12);
     *(__eax + 12) = __ebx;
     *(__eax + 16) = __ecx;
    __edi =  *(__esi + 4);
    __edi =  *( *(__esi + 4) - 4);
    __edi =  *( *(__esi + 4) - 4) >> 10;
    if(__edi == 0) {
        __eax =  &caml_bucket_Division_by_zero;
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v24 = __edi;
        _v16 = __eax;
        _v20 = __edx;
        _v28 = __ecx;
        _v4 = __ebx;
         *__esp = __esi;
        __eax =  *(__edx + 16);
        __eax =  *( *(__edx + 16) + 8);
        __ebx =  *(__eax + 4);
        __ecx =  *( *(__eax + 4));
        __eax = _v4;
         *__ecx();
        __ebx = 2147483647;
        __eax = _v4 & 2147483647;
        __eax = (_v4 & 2147483647) >> 1;
        __ecx = _v24;
        asm("cdq");
        _t26 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t26;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    _v8 = __edx;
    __ebx =  *__esp;
    __ecx =  *(__ebx + 4);
     *(__ecx - 4) =  *(__ecx - 4) >> 9;
    if( *(__ecx - 4) >> 9 <= __edx) {
L25:
        caml_ml_array_bound_error();
        __esp = __esp - 12;
        __edx = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 20;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        __eax = __eax + 4;
         *(__eax - 4) = 4343;
         *__eax = camlHashtbl__mem_in_bucket_1230;
         *(__eax + 4) = 3;
        __esi =  *(__ecx + 12);
         *(__eax + 8) =  *(__ecx + 12);
         *(__eax + 12) = __ebx;
        __esi =  *(__edx + 4);
        __esi =  *( *(__edx + 4) - 4);
        __esi =  *( *(__edx + 4) - 4) >> 10;
        if(__esi == 0) {
            __eax =  &caml_bucket_Division_by_zero;
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _v36 = __esi;
            _v40 = __eax;
             *__esp = __edx;
            __eax =  *(__ecx + 16);
            __eax =  *( *(__ecx + 16) + 8);
            __edx =  *( *( *(__ecx + 16) + 8) + 4);
            __ecx =  *__edx;
            __eax = __ebx;
            __ebx = __edx;
             *( *__edx)();
            __ebx = 2147483647;
            __eax = __eax & 2147483647;
            __eax = __eax >> 1;
            __ecx = _v36;
            asm("cdq");
            _t79 = __eax % __ecx;
            __eax = __eax / __ecx;
            __edx = _t79;
        }
        __edx = __edx << 1;
        __edx = __edx + 1;
        __eax =  *__esp;
        __ebx =  *( *__esp + 4);
         *(__ebx - 4) =  *(__ebx - 4) >> 9;
        if( *(__ebx - 4) >> 9 <= __edx) {
            caml_ml_array_bound_error();
            caml_hash_univ_param(21, 201, __eax);
            return __eax;
        } else {
            __eax =  *(__ebx + __edx * 2 - 2);
            __ebx = _v40;
            __esp =  &(__esp[3]);
            __esp = __esp - 8;
            while(_t175 != 1) {
                _v36 = _t179;
                 *__esp =  *(_t175 + 8);
                caml_apply2();
                if( *_t175 == 1) {
                    _t175 =  *__esp;
                    _t179 = _v36;
                    continue;
                } else {
                    __esp =  &(__esp[2]);
                    return 3;
                }
                goto L79;
            }
            __esp =  &(__esp[2]);
            return 1;
        }
    } else {
        __eax =  *(__ecx + __edx * 2 - 2);
        _v24 = __eax;
        L19();
        __ecx =  &caml_exn_Not_found;
        __ebx =  *__eax;
        if(__ebx !=  &caml_exn_Not_found) {
            caml_raise_exn(__eax);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            __ebx =  *(__ebx + 4);
            _v8 = __ebx;
            __ebx =  *(__ebx - 4);
            __ebx = __ebx >> 9;
            if(__ebx <= __edx) {
                caml_ml_array_bound_error();
                goto L24;
            } else {
                __ebx = _v12;
                camlHashtbl__replace_bucket_1221(__eax, _v12);
                _push(__eax);
                __ebx = _v8;
                __eax = _v4;
                __eax = __ebx + _v4 * 2 - 2;
                _push(__ebx + _v4 * 2 - 2);
                caml_modify(__ebx, __edi, __esi);
                __esp =  &(__esp[2]);
                __eax = 1;
                _pop(caml_exception_pointer);
                __esp =  &(__esp[8]);
                return 1;
            }
        } else {
            __ebx =  *__esp;
            __edx =  *(__ebx + 4);
             *(__edx - 4) =  *(__edx - 4) >> 9;
            __ecx = _v8;
            if( *(__edx - 4) >> 9 <= __ecx) {
L24:
                caml_ml_array_bound_error();
                goto L25;
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 16;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                __esi = __eax + 4;
                 *(__esi - 4) = 3072;
                __eax = _v4;
                 *__esi = _v4;
                __eax = _v28;
                 *(__esi + 4) = _v28;
                __eax = _v24;
                 *(__esi + 8) = _v24;
                _push(__esi);
                __eax = __edx + __ecx * 2 - 2;
                _push(__edx + __ecx * 2 - 2);
                caml_modify(__ebx, __edi, __esi);
                __esp =  &(__esp[2]);
                 *__ebx =  *__ebx + 2;
                __eax =  *(__ebx + 4);
                __eax =  *( *(__ebx + 4) - 4);
                __eax =  *( *(__ebx + 4) - 4) >> 9;
                __ecx = ( *( *(__ebx + 4) - 4) >> 9 | 1) + ( *( *(__ebx + 4) - 4) >> 9 | 1) - 1;
                __eax =  *__ebx;
                if( *__ebx <= __ecx) {
                    __eax = 1;
                    __esp =  &(__esp[8]);
                    return 1;
                } else {
                    __eax = _v20;
                    __eax =  *(_v20 + 16);
                    __esp =  &(__esp[8]);
                    while(1) {
                        __esp = __esp - 24;
                         *__esp = __eax;
                        _v8 = __ebx;
                        __eax =  *(__ebx + 4);
                        _v4 = __eax;
                        __eax =  *(__eax - 4);
                        __eax = __eax >> 9;
                        __eax = __eax | 1;
                        _v16 = __eax;
                        __ebx =  *134689872;
                        __eax = __eax >> 1;
                        __eax = 3 + __eax * 4;
                        camlPervasives__min_1022(__eax);
                        __ebx = _v16;
                        if(__eax == __ebx) {
                            break;
                        }
                        _v20 = __eax;
                        _v16 = __ebx;
                        _push(__eax);
                        __eax = caml_make_vect;
                        caml_c_call(1);
                        __esp =  &(__esp[2]);
                        __ebx = caml_make_vect;
                        _v12 = caml_make_vect;
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 24;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        __ecx = __eax + 4;
                         *(__ecx - 4) = 5367;
                         *__ecx = camlHashtbl__insert_bucket_1068;
                         *(__ecx + 4) = 3;
                        __eax =  *__esp;
                         *(__ecx + 8) =  *__esp;
                        __eax = _v20;
                         *(__ecx + 12) = _v20;
                         *(__ecx + 16) = __ebx;
                        __eax = 1;
                        __ebx = _v16;
                        __ebx = _v16 + -2;
                        if(1 > __ebx) {
L43:
                            __eax = _v12;
                            _push(_v12);
                            __eax = _v8;
                            __eax = _v8 + 4;
                            _push(_v8 + 4);
                            caml_modify(__ebx, __edi, __esi);
                            __esp =  &(__esp[2]);
                            __eax = 1;
                            __esp =  &(__esp[6]);
                            return 1;
                        } else {
                            _v16 = __ebx;
                            _v20 = 1;
                             *__esp = __ecx;
                            while(1) {
                                __ebx = _v4;
                                 *(__ebx - 4) =  *(__ebx - 4) >> 9;
                                if( *(__ebx - 4) >> 9 <= __eax) {
                                    break;
                                }
                                __eax =  *(__ebx + __eax * 2 - 2);
                                __ebx =  *__esp;
                                camlHashtbl__insert_bucket_1068(__eax);
                                __eax = _v20;
                                __ecx = __eax;
                                __eax = __eax + 2;
                                _v20 = __eax;
                                __ebx = _v16;
                                if(__ecx != __ebx) {
                                    continue;
                                } else {
                                    goto L43;
                                }
                                goto L79;
                            }
                            caml_ml_array_bound_error();
                            __esp = __esp - 4;
                            __edi = __eax;
                            __eax =  *(__edi + 4);
                            __esi =  *(__eax - 4);
                            __esi =  *(__eax - 4) >> 10;
                            if(__esi == 0) {
                                __eax =  &caml_bucket_Division_by_zero;
                                caml_raise_exn( &caml_bucket_Division_by_zero);
                            } else {
                                 *__esp = __ecx;
                                caml_hash_univ_param(21, 201, __ebx);
                                __eax = __eax >> 1;
                                __ecx = __esi;
                                asm("cdq");
                                _t122 = __eax % __ecx;
                                __eax = __eax / __ecx;
                                __edx = _t122;
                            }
                            __edx = __edx << 1;
                            __edx = __edx + 1;
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 16;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            __eax = __eax + 4;
                             *(__eax - 4) = 3072;
                             *__eax = __ebx;
                            __ebx =  *__esp;
                             *(__eax + 4) =  *__esp;
                            __ecx =  *(__edi + 4);
                            __ebx =  *(__ecx - 4);
                            __ebx =  *(__ecx - 4) >> 9;
                            if(__ebx <= __edx) {
L59:
                                caml_ml_array_bound_error();
                                __esp = __esp - 8;
                                __edi = __eax;
                                __ecx = __ebx;
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 20;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 4343;
                                 *__ebx = camlHashtbl__remove_bucket_1083;
                                 *(__ebx + 4) = 3;
                                 *(__ebx + 8) = __edi;
                                 *(__ebx + 12) = __ecx;
                                __eax =  *(__edi + 4);
                                __esi =  *(__eax - 4);
                                __esi =  *(__eax - 4) >> 10;
                                if(__esi == 0) {
                                    __eax =  &caml_bucket_Division_by_zero;
                                    caml_raise_exn( &caml_bucket_Division_by_zero);
                                } else {
                                    caml_hash_univ_param(21, 201, __ecx);
                                    __eax = __eax >> 1;
                                    __ecx = __esi;
                                    asm("cdq");
                                    _t151 = __eax % __ecx;
                                    __eax = __eax / __ecx;
                                    __edx = _t151;
                                }
                                __edx = __edx << 1;
                                __edx = __edx + 1;
                                _v32 = __edx;
                                __eax =  *(__edi + 4);
                                 *__esp = __eax;
                                __eax =  *(__eax - 4);
                                if(__eax <= __edx) {
L70:
                                    caml_ml_array_bound_error();
                                    __esp = __esp - 12;
                                    while(__ebx != 1) {
                                         *__esp = __eax;
                                        __ecx =  *(__ebx + 8);
                                        _v44 =  *(__ebx + 8);
                                        __ecx =  *(__ebx + 4);
                                        _v40 =  *(__ebx + 4);
                                        _push(__ebx);
                                        _push(__eax);
                                        __eax = caml_compare;
                                        caml_c_call();
                                        __esp =  &(__esp[2]);
                                        if(caml_compare != 1) {
                                            __eax =  *__esp;
                                            __ebx = _v44;
                                            continue;
                                        }
                                        __eax = _v40;
                                        __esp =  &(__esp[3]);
                                        return _v40;
                                        goto L79;
                                    }
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 8;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            __eax = __eax + 4;
                                             *(__eax - 4) = 1024;
                                             *__eax =  &caml_exn_Not_found;
                                            caml_raise_exn(__eax);
                                        }
                                        caml_call_gc();
                                    }
                                } else {
                                    __ecx =  *(__edi + 4);
                                     *(__ecx - 4) =  *(__ecx - 4) >> 9;
                                    if( *(__ecx - 4) >> 9 <= __edx) {
                                        caml_ml_array_bound_error();
                                        goto L70;
                                    } else {
                                        __eax =  *(__ecx + __edx * 2 - 2);
                                        camlHashtbl__remove_bucket_1083(__eax, __ebx);
                                        _push(__eax);
                                        __ebx = _v36;
                                        __eax = _v32;
                                        __eax = __ebx + _v32 * 2 - 2;
                                        _push(__ebx + _v32 * 2 - 2);
                                        caml_modify(__ebx, __edi, __esi);
                                        __esp =  &(__esp[2]);
                                        __eax = 1;
                                        __esp =  &(__esp[2]);
                                        return 1;
                                    }
                                }
                            } else {
                                __ebx =  *(__ecx + __edx * 2 - 2);
                                 *(__eax + 8) =  *(__ecx + __edx * 2 - 2);
                                __ecx =  *(__edi + 4);
                                __ebx =  *(__ecx - 4);
                                __ebx =  *(__ecx - 4) >> 9;
                                if(__ebx <= __edx) {
                                    caml_ml_array_bound_error();
                                    goto L59;
                                } else {
                                    _push(__eax);
                                    __eax = __ecx + __edx * 2 - 2;
                                    _push(__ecx + __edx * 2 - 2);
                                    caml_modify(__ebx, __edi, __esi);
                                    __esp =  &(__esp[2]);
                                     *__edi =  *__edi + 2;
                                    __eax =  *(__edi + 4);
                                    __eax =  *( *(__edi + 4) - 4);
                                    __eax =  *( *(__edi + 4) - 4) >> 9;
                                    __ebx = ( *( *(__edi + 4) - 4) >> 9 | 1) + ( *( *(__edi + 4) - 4) >> 9 | 1) - 1;
                                    __eax =  *__edi;
                                    if( *__edi <= __ebx) {
                                        __eax = 1;
                                        __esp =  &(__esp[1]);
                                        return 1;
                                    } else {
                                        __eax =  *134690256;
                                        __ebx = __edi;
                                        __esp =  &(__esp[1]);
                                        continue;
                                    }
                                }
                            }
                        }
                        goto L79;
                    }
                    __eax = 1;
                    __esp =  &(__esp[6]);
                    return 1;
                }
            }
        }
    }
L79:
}

L08055F10(
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx,                       // r2
    _unknown_ __edx,                       // r3
    intOrPtr _a20,                         // _cfa_14
    intOrPtr _a24,                         // _cfa_18
    signed int _a28                        // _cfa_1c
)
{
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _t39;                       // _t39
    signed int _t42;                       // _t42
    intOrPtr _t44;                         // _t44
    signed int _t45;                       // _t45
    intOrPtr _t60;                         // _t60
    signed int _t62;                       // _t62
    intOrPtr _t63;                         // _t63
    signed int _t74;                       // _t74
    signed int _t76;                       // _t76
    unsigned int _t81;                     // _t81

    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _t60 =  *((intOrPtr*)(__ebx + 4));
    _a24 = _t60;
    _t62 =  *(_t60 - 4) >> 9;
    if(_t62 <= __edx) {
        caml_ml_array_bound_error();
        caml_ml_array_bound_error();
        _t42 = caml_ml_array_bound_error();
        __esp = __esp - 12;
        _t74 = _t42;
        while(1) {
            _t44 = caml_young_ptr - 20;
            caml_young_ptr = _t44;
            if(_t44 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t45 = _t44 + 4;
         *(_t45 - 4) = 4343;
         *_t45 = camlHashtbl__mem_in_bucket_1230;
         *((intOrPtr*)(_t45 + 4)) = 3;
         *((intOrPtr*)(_t45 + 8)) =  *((intOrPtr*)(__ecx + 12));
         *(_t45 + 12) = _t62;
        _t81 =  *( *((intOrPtr*)(_t74 + 4)) - 4) >> 10;
        if(_t81 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _v8 = _t81;
            _v12 = _t45;
             *__esp = _t74;
             *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)( *((intOrPtr*)(__ecx + 16)) + 8)) + 4))))))();
            asm("cdq");
            _t74 = ((_t62 & 2147483647) >> 1) % _v8;
        }
        _t76 = (_t74 << 1) + 1;
        _t63 =  *((intOrPtr*)( *__esp + 4));
        _t49 =  *(_t63 - 4) >> 9;
        if( *(_t63 - 4) >> 9 <= _t76) {
            caml_ml_array_bound_error();
            caml_hash_univ_param(21, 201, _t49);
            return;
        } else {
            _t39 =  *(_t63 + _t76 * 2 - 2);
            _t62 = _v12;
            __esp =  &(__esp[3]);
            __esp = __esp - 8;
            while(_t39 != 1) {
                _v8 = _t62;
                 *__esp =  *(_t39 + 8);
                caml_apply2();
                if( *_t39 == 1) {
                    _t39 =  *__esp;
                    _t62 = _v8;
                    continue;
                } else {
                    __esp =  &(__esp[2]);
                    return;
                }
                goto L21;
            }
            __esp =  &(__esp[2]);
            return;
        }
    } else {
        __ebx = _a20;
        _push(__eax);
        __ebx = _a24;
        _a28 = __ebx + _a28 * 2 - 2;
        _push(__ebx + _a28 * 2 - 2);
        __eax = caml_modify(__ebx, __edi, __esi);
        __esp =  &(__esp[2]);
        __eax = 1;
        _pop(caml_exception_pointer);
        __esp =  &(__esp[1]);
        __esp =  &(__esp[8]);
        return;
    }
L21:
}

camlHashtbl__mem_1227(
    signed int __eax,                      // r0
    signed int __ebx,                      // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x08055F90
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _t30;                       // _t30
    signed int _t34;                       // _t34

    _t34 = __ebx;
    _t30 = __eax;
    __esp = __esp - 12;
    __edx = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    __eax = __eax + 4;
     *(__eax - 4) = 4343;
     *__eax = camlHashtbl__mem_in_bucket_1230;
     *(__eax + 4) = 3;
    __esi =  *(__ecx + 12);
     *(__eax + 8) =  *(__ecx + 12);
     *(__eax + 12) = __ebx;
    __esi =  *(__edx + 4);
    __esi =  *( *(__edx + 4) - 4);
    __esi =  *( *(__edx + 4) - 4) >> 10;
    if(__esi == 0) {
        __eax =  &caml_bucket_Division_by_zero;
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v4 = __esi;
        _v8 = __eax;
         *__esp = __edx;
        __eax =  *(__ecx + 16);
        __eax =  *( *(__ecx + 16) + 8);
        __edx =  *( *( *(__ecx + 16) + 8) + 4);
        __ecx =  *__edx;
        __eax = __ebx;
        __ebx = __edx;
         *( *__edx)();
        __ebx = 2147483647;
        __eax = __eax & 2147483647;
        __eax = __eax >> 1;
        __ecx = _v4;
        asm("cdq");
        _t21 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t21;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    __eax =  *__esp;
    __ebx =  *( *__esp + 4);
     *(__ebx - 4) =  *(__ebx - 4) >> 9;
    if( *(__ebx - 4) >> 9 <= __edx) {
        caml_ml_array_bound_error();
        caml_hash_univ_param(21, 201, __eax);
        return;
    } else {
        __eax =  *(__ebx + __edx * 2 - 2);
        __ebx = _v8;
        __esp =  &(__esp[3]);
        __esp = __esp - 8;
        while(_t30 != 1) {
            _v4 = _t34;
             *__esp =  *(_t30 + 8);
            caml_apply2();
            if( *_t30 == 1) {
                _t30 =  *__esp;
                _t34 = _v4;
                continue;
            } else {
                __esp =  &(__esp[2]);
                return;
            }
            goto L16;
        }
        __esp =  &(__esp[2]);
        return;
    }
L16:
}

camlHashtbl__hash_1031(
    _unknown_ __eax                        // r0
)
{// addr = 0x08056060
    return caml_hash_univ_param(21, 201, __eax);
}

camlHashtbl__create_1051(
    _unknown_ __eax                        // r0
)
{// addr = 0x08056080
    intOrPtr _t10;                         // _t10
    intOrPtr* _t12;                        // _t12

    caml_c_call(camlPervasives__min_1022(camlPervasives__max_1025(3)));
    __esp = __esp + 4;
    while(1) {
        _t10 = caml_young_ptr - 12;
        caml_young_ptr = _t10;
        if(_t10 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t12 = _t10 + 4;
     *((intOrPtr*)(_t12 - 4)) = 2048;
     *_t12 = 1;
    _t12[1] = caml_make_vect;
    return _t12;
}

signed int camlHashtbl__clear_1054(
    signed int* __eax                      // r0
)
{// addr = 0x080560E0
    intOrPtr _t17;                         // _t17
    intOrPtr _t21;                         // _t21
    intOrPtr* _t23;                        // _t23
    signed int _t26;                       // _t26
    signed int _t27;                       // _t27
    intOrPtr _t31;                         // _t31
    _unknown_ _t35;                        // _t35

    __edi = __eax;
    _t27 = 1;
    _t35 = ( *(__eax[1] - 4) >> 9 | 1) + -2;
    if(1 > _t35) {
L3:
         *__eax = 1;
        return 1;
    } else {
        while(1) {
            _t30 = __eax[1];
            if( *(__eax[1] - 4) >> 9 <= _t27) {
                break;
            }
            caml_modify(_t27, __eax, _t35, _t30 + _t27 * 2 - 2, 1);
            _t26 = _t27;
            _t27 = _t27 + 2;
            if(_t26 != _t35) {
                continue;
            } else {
                goto L3;
            }
            goto L9;
        }
        _t17 = caml_ml_array_bound_error();
        __esp = __esp - 4;
         *__esp = _t17;
        _t31 = camlArray__copy_1049( *((intOrPtr*)(_t17 + 4)));
        while(1) {
            _t21 = caml_young_ptr - 12;
            caml_young_ptr = _t21;
            if(_t21 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t23 = _t21 + 4;
         *((intOrPtr*)(_t23 - 4)) = 2048;
         *_t23 =  *((intOrPtr*)( *__esp));
        _t23[1] = _t31;
        __esp = __esp + 4;
        return _t23;
    }
L9:
}

camlHashtbl__copy_1057(
    intOrPtr __eax                         // r0
)
{// addr = 0x08056130
    intOrPtr _t9;                          // _t9
    intOrPtr* _t11;                        // _t11

     *__esp = __eax;
    __ecx = camlArray__copy_1049( *((intOrPtr*)(__eax + 4)));
    while(1) {
        _t9 = caml_young_ptr - 12;
        caml_young_ptr = _t9;
        if(_t9 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t11 = _t9 + 4;
     *((intOrPtr*)(_t11 - 4)) = 2048;
     *_t11 =  *((intOrPtr*)( *__esp));
    _t11[1] = __ecx;
    return _t11;
}

camlHashtbl__length_1059(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08056180
    return  *__eax;
}

camlHashtbl__resize_1061(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08056190
    _unknown_ _v4;                         // _cfa_fffffffc
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v32;                        // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    _unknown_ _v44;                        // _cfa_ffffffd4
    _unknown_ _t89;                        // _t89
    _unknown_ _t95;                        // _t95
    _unknown_ _t99;                        // _t99
    _unknown_ _t103;                       // _t103
    _unknown_ _t109;                       // _t109
    _unknown_ _t114;                       // _t114
    _unknown_ _t116;                       // _t116
    _unknown_ _t117;                       // _t117
    _unknown_ _t119;                       // _t119
    _unknown_ _t124;                       // _t124
    _unknown_ _t127;                       // _t127
    _unknown_ _t129;                       // _t129
    _unknown_ _t131;                       // _t131
    _unknown_ _t144;                       // _t144
    _unknown_ _t157;                       // _t157
    _unknown_ _t162;                       // _t162
    _unknown_ _t165;                       // _t165
    _unknown_ _t169;                       // _t169
    _unknown_ _t172;                       // _t172
    _unknown_ _t173;                       // _t173
    _unknown_ _t181;                       // _t181
    _unknown_ _t183;                       // _t183
    _unknown_ _t184;                       // _t184
    _unknown_ _t185;                       // _t185
    _unknown_ _t193;                       // _t193
    _unknown_ _t195;                       // _t195
    _unknown_ _t197;                       // _t197
    _unknown_ _t198;                       // _t198
    _unknown_ _t199;                       // _t199
    _unknown_ _t200;                       // _t200
    _unknown_ _t201;                       // _t201
    _unknown_ _t203;                       // _t203
    _unknown_ _t205;                       // _t205


}

camlHashtbl__add_1074(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x080562C0
    _unknown_ _v4;                         // _cfa_fffffffc
    _unknown_ _v8;                         // _cfa_fffffff8
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _t93;                        // _t93
    _unknown_ _t95;                        // _t95
    _unknown_ _t96;                        // _t96
    _unknown_ _t98;                        // _t98
    _unknown_ _t103;                       // _t103
    _unknown_ _t106;                       // _t106
    _unknown_ _t108;                       // _t108
    _unknown_ _t110;                       // _t110
    _unknown_ _t123;                       // _t123
    _unknown_ _t135;                       // _t135
    _unknown_ _t141;                       // _t141
    _unknown_ _t145;                       // _t145
    _unknown_ _t149;                       // _t149
    _unknown_ _t156;                       // _t156
    _unknown_ _t161;                       // _t161
    _unknown_ _t165;                       // _t165
    _unknown_ _t166;                       // _t166
    _unknown_ _t173;                       // _t173
    _unknown_ _t179;                       // _t179
    _unknown_ _t180;                       // _t180
    _unknown_ _t186;                       // _t186
    _unknown_ _t188;                       // _t188
    _unknown_ _t191;                       // _t191
    _unknown_ _t193;                       // _t193
    _unknown_ _t195;                       // _t195
    _unknown_ _t197;                       // _t197
    _unknown_ _t199;                       // _t199
    _unknown_ _t201;                       // _t201


}

camlHashtbl__remove_1080(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx                         // r1
)
{// addr = 0x080563B0
    signed int _v4;                        // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _t35;                         // _t35
    intOrPtr _t40;                         // _t40
    intOrPtr _t43;                         // _t43
    intOrPtr _t45;                         // _t45
    intOrPtr* _t47;                        // _t47
    signed int _t60;                       // _t60
    intOrPtr* _t64;                        // _t64
    signed int _t72;                       // _t72
    signed int _t74;                       // _t74
    signed int _t76;                       // _t76

    __esp = __esp - 8;
    __edi = __eax;
    while(1) {
        _t35 = caml_young_ptr - 20;
        caml_young_ptr = _t35;
        if(_t35 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t64 = _t35 + 4;
     *((intOrPtr*)(_t64 - 4)) = 4343;
     *_t64 = camlHashtbl__remove_bucket_1083;
    _t64[1] = 3;
    _t64[2] = __eax;
    _t64[3] = __ebx;
    _t76 =  *( *((intOrPtr*)(__eax + 4)) - 4) >> 10;
    if(_t76 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _t60 = caml_hash_univ_param(21, 201, __ebx);
        asm("cdq");
        _t72 = (_t60 >> 1) % _t76;
    }
    _t74 = (_t72 << 1) + 1;
    _v4 = _t74;
    _t40 =  *((intOrPtr*)(__eax + 4));
     *__esp = _t40;
    if( *(_t40 - 4) >> 9 <= _t74) {
L10:
        _t43 = caml_ml_array_bound_error();
        __esp = __esp - 12;
        while(_t64 != 1) {
             *__esp = _t43;
            _v16 = _t64[2];
            _v12 = _t64[1];
            caml_c_call( *_t64);
            if(caml_compare != 1) {
                _t43 =  *__esp;
                _t64 = _v16;
                continue;
            }
            __esp = __esp + 12;
            return _v12;
            goto L19;
        }
        while(1) {
            _t45 = caml_young_ptr - 8;
            caml_young_ptr = _t45;
            if(_t45 >= caml_young_limit) {
                _t47 = _t45 + 4;
                 *((intOrPtr*)(_t47 - 4)) = 1024;
                 *_t47 =  &caml_exn_Not_found;
                caml_raise_exn(_t47);
            }
            caml_call_gc();
        }
    } else {
        _t70 =  *((intOrPtr*)(__eax + 4));
        if( *( *((intOrPtr*)(__eax + 4)) - 4) >> 9 <= _t74) {
            caml_ml_array_bound_error();
            goto L10;
        } else {
            caml_modify(_v8, __eax, _t76, _v8 + _v4 * 2 - 2, camlHashtbl__remove_bucket_1083( *((intOrPtr*)(_t70 + _t74 * 2 - 2)), _t64));
            __esp = __esp + 8;
            return 1;
        }
    }
L19:
}

camlHashtbl__find_rec_1088(
    intOrPtr __eax,                        // r0
    intOrPtr* __ebx                        // r1
)
{// addr = 0x08056490
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t9;                          // _t9
    intOrPtr _t11;                         // _t11
    intOrPtr* _t13;                        // _t13
    intOrPtr* _t17;                        // _t17

    _t17 = __ebx;
    _t9 = __eax;
    while(_t17 != 1) {
         *__esp = _t9;
        _v8 = _t17[2];
        _v4 = _t17[1];
        caml_c_call( *_t17);
        if(caml_compare != 1) {
            _t9 =  *__esp;
            _t17 = _v8;
            continue;
        }
        return _v4;
    }
    while(1) {
        _t11 = caml_young_ptr - 8;
        caml_young_ptr = _t11;
        if(_t11 >= caml_young_limit) {
            _t13 = _t11 + 4;
             *((intOrPtr*)(_t13 - 4)) = 1024;
             *_t13 =  &caml_exn_Not_found;
            caml_raise_exn(_t13);
        }
        caml_call_gc();
    }
}

signed int camlHashtbl__find_1093(
    _unknown_ __eax,                       // r0
    unsigned int __ebx                     // r1
)
{// addr = 0x08056520
    intOrPtr _v4;                          // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    unsigned int* _v68;                    // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    unsigned int _v80;                     // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    unsigned int _v92;                     // _cfa_ffffffa4
    unsigned int _v96;                     // _cfa_ffffffa0
    unsigned int _v100;                    // _cfa_ffffff9c
    _unknown_ _t327;                       // _t327
    intOrPtr _t329;                        // _t329
    unsigned int _t336;                    // _t336
    intOrPtr _t338;                        // _t338
    _unknown_ _t345;                       // _t345
    intOrPtr _t347;                        // _t347
    intOrPtr _t354;                        // _t354
    intOrPtr _t356;                        // _t356
    signed int _t358;                      // _t358
    intOrPtr _t360;                        // _t360
    intOrPtr _t362;                        // _t362
    signed int _t364;                      // _t364
    intOrPtr _t366;                        // _t366
    intOrPtr _t371;                        // _t371
    intOrPtr* _t373;                       // _t373
    unsigned int* _t374;                   // _t374
    signed int _t378;                      // _t378
    signed int _t381;                      // _t381
    unsigned int _t382;                    // _t382
    signed int _t387;                      // _t387
    signed int _t390;                      // _t390
    intOrPtr* _t391;                       // _t391
    intOrPtr _t402;                        // _t402
    unsigned int _t415;                    // _t415
    signed int _t416;                      // _t416
    signed int _t422;                      // _t422
    intOrPtr _t426;                        // _t426
    signed int _t430;                      // _t430
    unsigned int _t436;                    // _t436
    intOrPtr _t441;                        // _t441
    signed int* _t443;                     // _t443
    unsigned int _t444;                    // _t444
    intOrPtr _t446;                        // _t446
    unsigned int _t451;                    // _t451
    unsigned int _t454;                    // _t454
    intOrPtr _t456;                        // _t456
    intOrPtr* _t458;                       // _t458
    signed int _t471;                      // _t471
    signed int _t483;                      // _t483
    signed int _t488;                      // _t488
    signed int _t489;                      // _t489
    intOrPtr _t497;                        // _t497
    signed int* _t499;                     // _t499
    signed int _t500;                      // _t500
    intOrPtr _t504;                        // _t504
    intOrPtr* _t506;                       // _t506
    unsigned int _t512;                    // _t512
    intOrPtr _t514;                        // _t514
    intOrPtr* _t516;                       // _t516
    unsigned int _t521;                    // _t521
    intOrPtr _t523;                        // _t523
    intOrPtr* _t525;                       // _t525
    unsigned int _t533;                    // _t533
    unsigned int _t534;                    // _t534
    signed int _t535;                      // _t535
    signed int _t539;                      // _t539
    unsigned int _t540;                    // _t540
    unsigned int* _t541;                   // _t541
    unsigned int _t542;                    // _t542
    intOrPtr _t543;                        // _t543
    signed int _t555;                      // _t555
    signed int _t560;                      // _t560
    signed int _t564;                      // _t564
    unsigned int _t567;                    // _t567
    unsigned int _t568;                    // _t568
    unsigned int _t581;                    // _t581
    unsigned int _t582;                    // _t582
    signed int _t583;                      // _t583
    unsigned int _t584;                    // _t584
    intOrPtr _t585;                        // _t585
    unsigned int _t586;                    // _t586
    unsigned int _t588;                    // _t588
    intOrPtr _t592;                        // _t592
    unsigned int _t594;                    // _t594
    unsigned int _t595;                    // _t595
    unsigned int _t596;                    // _t596
    unsigned int _t597;                    // _t597
    unsigned int _t606;                    // _t606
    unsigned int _t608;                    // _t608
    unsigned int _t609;                    // _t609
    unsigned int _t610;                    // _t610
    unsigned int _t621;                    // _t621
    intOrPtr* _t623;                       // _t623
    signed int _t624;                      // _t624
    signed int _t626;                      // _t626
    signed int _t628;                      // _t628
    signed int _t629;                      // _t629
    signed int _t631;                      // _t631
    signed int _t633;                      // _t633
    intOrPtr _t634;                        // _t634
    unsigned int _t635;                    // _t635
    intOrPtr* _t636;                       // _t636
    intOrPtr* _t639;                       // _t639
    unsigned int _t640;                    // _t640
    signed int _t644;                      // _t644
    _unknown_ _t646;                       // _t646
    unsigned int _t647;                    // _t647
    _unknown_ _t648;                       // _t648
    unsigned int _t650;                    // _t650
    signed int _t654;                      // _t654
    signed int _t656;                      // _t656
    signed int _t658;                      // _t658
    intOrPtr _t659;                        // _t659
    unsigned int _t660;                    // _t660
    unsigned int _t661;                    // _t661
    signed int _t662;                      // _t662
    signed int _t665;                      // _t665

    _t533 = __ebx;
    __esp = __esp - 12;
    _t322 =  *(__eax + 4);
    if( *( *(__eax + 4) - 4) >> 10 == 0) {
        caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        __eax = caml_hash_univ_param(21, 201, __ebx);
        __eax = __eax >> 1;
        __ecx = __esi;
        asm("cdq");
        __eax = __eax / __esi;
    }
    _t626 = (_t624 << 1) + 1;
    _t581 =  *(__eax + 4);
    if( *(_t581 - 4) >> 9 <= _t626) {
        _t327 = caml_ml_array_bound_error();
        _t646 = _t327;
        _t582 = _t533;
        while(1) {
            _t329 = caml_young_ptr - 16;
            caml_young_ptr = _t329;
            if(_t329 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t533 = _t329 + 4;
         *(_t533 - 4) = 3319;
         *_t533 = camlHashtbl__find_in_bucket_1108;
         *(_t533 + 4) = 3;
         *(_t533 + 8) = _t582;
        _t654 =  *((unsigned int*)( *(_t646 + 4) - 4)) >> 10;
        if(_t654 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _t500 = caml_hash_univ_param(21, 201, _t582);
            asm("cdq");
            _t626 = (_t500 >> 1) % _t654;
        }
        _t628 = (_t626 << 1) + 1;
        _t583 =  *(_t646 + 4);
        if( *((unsigned int*)(_t583 - 4)) >> 9 <= _t628) {
            _t336 = caml_ml_array_bound_error();
            __esp = __esp - 28;
            _t647 = _t336;
            while(1) {
                _t338 = caml_young_ptr - 20;
                caml_young_ptr = _t338;
                if(_t338 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t629 = _t338 + 4;
             *(_t629 - 4) = 4343;
             *_t629 = camlHashtbl__replace_bucket_1116;
             *(_t629 + 4) = 3;
             *(_t629 + 8) = _t533;
             *(_t629 + 12) = _t583;
            _t656 =  *( *(_t647 + 4) - 4) >> 10;
            if(_t656 == 0) {
                caml_raise_exn( &caml_bucket_Division_by_zero);
            } else {
                _v24 = _t629;
                _v32 = _t583;
                _v36 = _t533;
                 *__esp = _t647;
                _t489 = caml_hash_univ_param(21, 201, _t533);
                asm("cdq");
                _t629 = (_t489 >> 1) % _t656;
            }
            _t631 = (_t629 << 1) + 1;
            _v16 = _t631;
            _t534 =  *(_t647 + 4);
            if( *(_t534 - 4) >> 9 <= _t631) {
L110:
                _t345 = caml_ml_array_bound_error();
                _t648 = _t345;
                _t584 = _t534;
                while(1) {
                    _t347 = caml_young_ptr - 16;
                    caml_young_ptr = _t347;
                    if(_t347 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t535 = _t347 + 4;
                 *(_t535 - 4) = 3319;
                 *_t535 = camlHashtbl__mem_in_bucket_1125;
                 *(_t535 + 4) = 3;
                 *(_t535 + 8) = _t584;
                _t658 =  *( *((intOrPtr*)(_t648 + 4)) - 4) >> 10;
                if(_t658 == 0) {
                    caml_raise_exn( &caml_bucket_Division_by_zero);
                } else {
                    _t387 = caml_hash_univ_param(21, 201, _t584);
                    asm("cdq");
                    _t631 = (_t387 >> 1) % _t658;
                }
                _t633 = (_t631 << 1) + 1;
                _t585 =  *((intOrPtr*)(_t648 + 4));
                if( *(_t585 - 4) >> 9 <= _t633) {
                    _t354 = caml_ml_array_bound_error();
                    __esp = __esp - 16;
                    _t634 = _t354;
                    while(1) {
                        _t356 = caml_young_ptr - 16;
                        caml_young_ptr = _t356;
                        if(_t356 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t586 = _t356 + 4;
                     *(_t586 - 4) = 3319;
                     *_t586 = camlHashtbl__do_bucket_1132;
                     *(_t586 + 4) = 3;
                     *((intOrPtr*)(_t586 + 8)) = _t634;
                    _t635 =  *(_t535 + 4);
                    _t358 = 1;
                    _t539 = ( *((unsigned int*)(_t635 - 4)) >> 9 | 1) + -2;
                    if(1 > _t539) {
L126:
                        __esp =  &(__esp[4]);
                        return 1;
                    } else {
                        _v44 = _t539;
                        _v48 = 1;
                         *__esp = _t635;
                        _v52 = _t586;
                        while(1) {
                            _t540 =  *__esp;
                            _t588 =  *(_t540 - 4) >> 9;
                            if(_t588 <= _t358) {
                                break;
                            }
                            camlHashtbl__do_bucket_1132( *((intOrPtr*)(_t540 + _t358 * 2 - 2)), _v52);
                            _t381 = _v48;
                            _t358 = _t381 + 2;
                            _v48 = _t358;
                            if(_t381 != _v44) {
                                continue;
                            } else {
                                goto L126;
                            }
                            goto L142;
                        }
                        _t360 = caml_ml_array_bound_error();
                        __esp = __esp - 20;
                        _t659 = _t360;
                        while(1) {
                            _t362 = caml_young_ptr - 28;
                            caml_young_ptr = _t362;
                            if(_t362 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t636 = _t362 + 4;
                         *((intOrPtr*)(_t636 - 4)) = 4343;
                         *_t636 = caml_curry2;
                         *((intOrPtr*)(_t636 + 4)) = 5;
                         *((intOrPtr*)(_t636 + 8)) = camlHashtbl__do_bucket_1142;
                         *((intOrPtr*)(_t636 + 12)) = _t659;
                        _t660 =  *(_t540 + 4);
                        _t541 = _t636 + 20;
                         *((intOrPtr*)(_t541 - 4)) = 1024;
                         *_t541 = _t588;
                        _t364 = 1;
                        _t592 = ( *((unsigned int*)(_t660 - 4)) >> 9 | 1) + -2;
                        if(1 > _t592) {
L135:
                            __esp =  &(__esp[5]);
                            return  *_t541;
                        } else {
                            _v60 = _t592;
                            _v64 = 1;
                            _v68 = _t541;
                             *__esp = _t660;
                            _v72 = _t636;
                            while(1) {
                                _t542 =  *_t541;
                                _t593 =  *__esp;
                                if( *( *__esp - 4) >> 9 <= _t364) {
                                    break;
                                }
                                _push(camlHashtbl__do_bucket_1142( *((intOrPtr*)(_t593 + _t364 * 2 - 2)), _t542, _v72));
                                _t541 = _v68;
                                _push(_t541);
                                caml_modify(_t541, _t648, _t660);
                                __esp =  &(__esp[2]);
                                _t378 = _v64;
                                _t364 = _t378 + 2;
                                _v64 = _t364;
                                if(_t378 != _v60) {
                                    continue;
                                } else {
                                    goto L135;
                                }
                                goto L142;
                            }
                            _t366 = caml_ml_array_bound_error();
                            __esp = __esp - 28;
                            _t543 = _t366;
                             *__esp = camlHashtbl;
                            _v100 =  *134690208;
                            _v96 =  *134690216;
                            while(1) {
                                _t371 = caml_young_ptr - 232;
                                caml_young_ptr = _t371;
                                if(_t371 >= caml_young_limit) {
                                    break;
                                }
                                caml_call_gc();
                            }
                            _t373 = _t371 + 4;
                             *((intOrPtr*)(_t373 - 4)) = 3319;
                             *_t373 = camlHashtbl__safehash_1177;
                             *(_t373 + 4) = 3;
                             *((intOrPtr*)(_t373 + 8)) = _t543;
                            _t594 = _t373 + 16;
                            _v92 = _t594;
                             *(_t594 - 4) = 4343;
                             *_t594 = caml_curry3;
                             *((intOrPtr*)(_t594 + 4)) = 7;
                             *((intOrPtr*)(_t594 + 8)) = camlHashtbl__add_1179;
                             *((intOrPtr*)(_t594 + 12)) = _t373;
                            _t595 = _t373 + 36;
                            _v88 = _t595;
                             *(_t595 - 4) = 5367;
                             *_t595 = caml_curry2;
                             *((intOrPtr*)(_t595 + 4)) = 5;
                             *((intOrPtr*)(_t595 + 8)) = camlHashtbl__remove_1185;
                             *((intOrPtr*)(_t595 + 12)) = _t543;
                             *((intOrPtr*)(_t595 + 16)) = _t373;
                            _t639 = _t373 + 60;
                             *((intOrPtr*)(_t639 - 4)) = 4343;
                             *_t639 = caml_curry2;
                             *((intOrPtr*)(_t639 + 4)) = 5;
                             *((intOrPtr*)(_t639 + 8)) = camlHashtbl__find_rec_1193;
                             *((intOrPtr*)(_t639 + 12)) = _t543;
                            _t596 = _t373 + 80;
                            _v84 = _t596;
                             *(_t596 - 4) = 6391;
                             *_t596 = caml_curry2;
                             *((intOrPtr*)(_t596 + 4)) = 5;
                             *((intOrPtr*)(_t596 + 8)) = camlHashtbl__find_1198;
                             *((intOrPtr*)(_t596 + 12)) = _t543;
                             *((intOrPtr*)(_t596 + 16)) = _t373;
                             *((intOrPtr*)(_t596 + 20)) = _t639;
                            _t661 = _t373 + 108;
                             *(_t661 - 4) = 5367;
                             *_t661 = caml_curry2;
                             *((intOrPtr*)(_t661 + 4)) = 5;
                             *((intOrPtr*)(_t661 + 8)) = camlHashtbl__find_all_1210;
                             *((intOrPtr*)(_t661 + 12)) = _t543;
                             *((intOrPtr*)(_t661 + 16)) = _t373;
                            _t640 = _t373 + 132;
                             *(_t640 - 4) = 5367;
                             *_t640 = caml_curry3;
                             *((intOrPtr*)(_t640 + 4)) = 7;
                             *((intOrPtr*)(_t640 + 8)) = camlHashtbl__replace_1217;
                             *((intOrPtr*)(_t640 + 12)) = _t543;
                             *((intOrPtr*)(_t640 + 16)) = _t373;
                            _t597 = _t373 + 156;
                             *(_t597 - 4) = 5367;
                             *_t597 = caml_curry2;
                             *((intOrPtr*)(_t597 + 4)) = 5;
                             *((intOrPtr*)(_t597 + 8)) = camlHashtbl__mem_1227;
                             *((intOrPtr*)(_t597 + 12)) = _t543;
                             *((intOrPtr*)(_t597 + 16)) = _t373;
                            _v80 =  *134690240;
                            _t374 = _t373 + 180;
                             *((intOrPtr*)(_t374 - 4)) = 12288;
                             *_t374 =  *__esp;
                            _t374[1] = _v100;
                            _t374[2] = _v96;
                            _t374[3] = _v92;
                            _t374[4] = _v88;
                            _t374[5] = _v84;
                            _t374[6] = _t661;
                            _t374[7] = _t640;
                            _t374[8] = _t597;
                            _t374[9] = _v80;
                            _t374[0xa] =  *134690244;
                            _t374[0xb] =  *134690248;
                            __esp =  &(__esp[7]);
                            return _t374;
                        }
                    }
                } else {
                    _t382 =  *(_t585 + _t633 * 2 - 2);
                    __esp = __esp - 8;
                    while(_t382 != 1) {
                        _v44 = _t535;
                         *__esp =  *(_t382 + 8);
                        caml_c_call( *(_t535 + 8));
                        if(caml_compare != 1) {
                            _t382 =  *__esp;
                            _t535 = _v44;
                            continue;
                        } else {
                            __esp =  &(__esp[2]);
                            return 3;
                        }
                        goto L142;
                    }
                    __esp =  &(__esp[2]);
                    return 1;
                }
            } else {
                _t390 =  *(_t534 + _t631 * 2 - 2);
                _v28 = _t390;
                L104();
                if( *_t390 !=  &caml_exn_Not_found) {
                    _t391 = caml_raise_exn(_t390);
                    _push(caml_exception_pointer);
                    caml_exception_pointer = __esp;
                    _t555 =  *(_t647 + 4);
                    _v16 = _t555;
                    _t534 =  *((unsigned int*)(_t555 - 4)) >> 9;
                    if(_t534 <= _t631) {
                        caml_ml_array_bound_error();
                        goto L109;
                    } else {
                        caml_modify(_v16, _t647, _t656, _v16 + _v12 * 2 - 2, camlHashtbl__replace_bucket_1116(_t391, _v20));
                        _pop(caml_exception_pointer);
                        __esp =  &(__esp[7]);
                        return 1;
                    }
                } else {
                    _t534 =  *__esp;
                    _t631 =  *(_t534 + 4);
                    _t604 = _v16;
                    if( *(_t631 - 4) >> 9 <= _v16) {
L109:
                        caml_ml_array_bound_error();
                        goto L110;
                    } else {
                        while(1) {
                            _t402 = caml_young_ptr - 16;
                            caml_young_ptr = _t402;
                            if(_t402 >= caml_young_limit) {
                                break;
                            }
                            caml_call_gc();
                        }
                        _t662 = _t402 + 4;
                         *(_t662 - 4) = 3072;
                         *_t662 = _v36;
                         *(_t662 + 4) = _v32;
                         *(_t662 + 8) = _v28;
                        caml_modify(_t534, _t647, _t662, _t631 + _t604 * 2 - 2, _t662);
                         *_t534 =  *_t534 + 2;
                        if( *_t534 <= ( *( *(_t534 + 4) - 4) >> 9 | 1) + ( *( *(_t534 + 4) - 4) >> 9 | 1) - 1) {
                            __esp =  &(__esp[7]);
                            return 1;
                        } else {
                            _t415 =  *134690256;
                            __esp =  &(__esp[7]);
                            while(1) {
                                __esp = __esp - 24;
                                 *__esp = _t415;
                                _v20 = _t534;
                                _t416 =  *(_t534 + 4);
                                _v16 = _t416;
                                _v28 =  *(_t416 - 4) >> 9 | 1;
                                _t422 = camlPervasives__min_1022(3 + (( *(_t416 - 4) >> 9 | 1) >> 1) * 4);
                                _t560 = _v28;
                                if(_t422 == _t560) {
                                    break;
                                }
                                _v32 = _t422;
                                _v28 = _t560;
                                caml_c_call(_t422);
                                __esp =  &(__esp[1]);
                                _v24 = caml_make_vect;
                                while(1) {
                                    _t426 = caml_young_ptr - 24;
                                    caml_young_ptr = _t426;
                                    if(_t426 >= caml_young_limit) {
                                        break;
                                    }
                                    caml_call_gc();
                                }
                                _t606 = _t426 + 4;
                                 *(_t606 - 4) = 5367;
                                 *_t606 = camlHashtbl__insert_bucket_1068;
                                 *(_t606 + 4) = 3;
                                 *(_t606 + 8) =  *__esp;
                                 *(_t606 + 12) = _v32;
                                 *((intOrPtr*)(_t606 + 16)) = caml_make_vect;
                                _t430 = 1;
                                _t563 = _v28 + -2;
                                if(1 > _t563) {
L23:
                                    caml_modify(_t563, _t647, _t662, _v20 + 4, _v24);
                                    __esp =  &(__esp[6]);
                                    return 1;
                                } else {
                                    _v28 = _t563;
                                    _v32 = 1;
                                     *__esp = _t606;
                                    while(1) {
                                        _t564 = _v16;
                                        _t608 =  *((unsigned int*)(_t564 - 4)) >> 9;
                                        if(_t608 <= _t430) {
                                            break;
                                        }
                                        camlHashtbl__insert_bucket_1068( *((intOrPtr*)(_t564 + _t430 * 2 - 2)));
                                        _t488 = _v32;
                                        _t430 = _t488 + 2;
                                        _v32 = _t430;
                                        _t563 = _v28;
                                        if(_t488 != _v28) {
                                            continue;
                                        } else {
                                            goto L23;
                                        }
                                        goto L142;
                                    }
                                    _t436 = caml_ml_array_bound_error();
                                    __esp = __esp - 4;
                                    _t647 = _t436;
                                    _t662 =  *( *(_t647 + 4) - 4) >> 10;
                                    if(_t662 == 0) {
                                        caml_raise_exn( &caml_bucket_Division_by_zero);
                                    } else {
                                         *__esp = _t608;
                                        _t483 = caml_hash_univ_param(21, 201, _t564);
                                        asm("cdq");
                                        _t631 = (_t483 >> 1) % _t662;
                                    }
                                    _t631 = (_t631 << 1) + 1;
                                    while(1) {
                                        _t441 = caml_young_ptr - 16;
                                        caml_young_ptr = _t441;
                                        if(_t441 >= caml_young_limit) {
                                            break;
                                        }
                                        caml_call_gc();
                                    }
                                    _t443 = _t441 + 4;
                                     *((intOrPtr*)(_t443 - 4)) = 3072;
                                     *_t443 = _t564;
                                    _t443[1] =  *__esp;
                                    _t609 =  *(_t647 + 4);
                                    _t567 =  *((unsigned int*)(_t609 - 4)) >> 9;
                                    if(_t567 <= _t631) {
L39:
                                        _t444 = caml_ml_array_bound_error();
                                        __esp = __esp - 8;
                                        _t650 = _t444;
                                        _t610 = _t567;
                                        while(1) {
                                            _t446 = caml_young_ptr - 20;
                                            caml_young_ptr = _t446;
                                            if(_t446 >= caml_young_limit) {
                                                break;
                                            }
                                            caml_call_gc();
                                        }
                                        _t568 = _t446 + 4;
                                         *(_t568 - 4) = 4343;
                                         *_t568 = camlHashtbl__remove_bucket_1083;
                                         *(_t568 + 4) = 3;
                                         *(_t568 + 8) = _t650;
                                         *(_t568 + 12) = _t610;
                                        _t665 =  *( *(_t650 + 4) - 4) >> 10;
                                        if(_t665 == 0) {
                                            caml_raise_exn( &caml_bucket_Division_by_zero);
                                        } else {
                                            _t471 = caml_hash_univ_param(21, 201, _t610);
                                            asm("cdq");
                                            _t631 = (_t471 >> 1) % _t665;
                                        }
                                        _t644 = (_t631 << 1) + 1;
                                        _v44 = _t644;
                                        _t451 =  *(_t650 + 4);
                                         *__esp = _t451;
                                        if( *(_t451 - 4) >> 9 <= _t644) {
L50:
                                            _t454 = caml_ml_array_bound_error();
                                            goto L51;
                                        } else {
                                            _t613 =  *(_t650 + 4);
                                            if( *( *(_t650 + 4) - 4) >> 9 <= _t644) {
                                                caml_ml_array_bound_error();
                                                goto L50;
                                            } else {
                                                caml_modify(_v48, _t650, _t665, _v48 + _v44 * 2 - 2, camlHashtbl__remove_bucket_1083( *((intOrPtr*)(_t613 + _t644 * 2 - 2)), _t568));
                                                __esp =  &(__esp[2]);
                                                return 1;
                                            }
                                        }
                                    } else {
                                        _t443[2] =  *(_t609 + _t631 * 2 - 2);
                                        _t615 =  *(_t647 + 4);
                                        _t567 =  *( *(_t647 + 4) - 4) >> 9;
                                        if(_t567 <= _t631) {
                                            caml_ml_array_bound_error();
                                            goto L39;
                                        } else {
                                            caml_modify(_t567, _t647, _t662, _t615 + _t631 * 2 - 2, _t443);
                                             *_t647 =  *_t647 + 2;
                                            if( *_t647 <= ( *( *(_t647 + 4) - 4) >> 9 | 1) + ( *( *(_t647 + 4) - 4) >> 9 | 1) - 1) {
                                                __esp =  &(__esp[1]);
                                                return 1;
                                            } else {
                                                _t415 =  *134690256;
                                                _t534 = _t647;
                                                __esp =  &(__esp[1]);
                                                continue;
                                            }
                                        }
                                    }
                                }
                                goto L142;
                            }
                            __esp =  &(__esp[6]);
                            return 1;
                        }
                    }
                }
            }
        } else {
            _t322 =  *(_t583 + _t628 * 2 - 2);
            __esp = __esp - 12;
            while(_t322 != 1) {
                _v20 = _t533;
                 *__esp =  *(_t322 + 8);
                _v16 =  *(_t322 + 4);
                caml_c_call( *(_t533 + 8));
                if(caml_compare != 1) {
                    _t322 =  *__esp;
                    _t533 = _v20;
                    continue;
                } else {
                    L1();
                    _t621 =  *__esp;
                    while(1) {
                        _t497 = caml_young_ptr - 12;
                        caml_young_ptr = _t497;
                        if(_t497 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t499 = _t497 + 4;
                     *((intOrPtr*)(_t499 - 4)) = 2048;
                     *_t499 = _v16;
                    _t499[1] = _t621;
                    __esp =  &(__esp[3]);
                    return _t499;
                }
                goto L142;
            }
            __esp =  &(__esp[3]);
            return 1;
        }
    } else {
        _t623 =  *((intOrPtr*)(_t581 + _t626 * 2 - 2));
        if(_t623 == 1) {
L76:
            _t504 = caml_young_ptr - 8;
            caml_young_ptr = _t504;
            if(_t504 >= caml_young_limit) {
                _t506 = _t504 + 4;
                 *((intOrPtr*)(_t506 - 4)) = 1024;
                 *_t506 =  &caml_exn_Not_found;
                caml_raise_exn(_t506);
            }
            caml_call_gc();
            goto L76;
        }
        _v8 = _t533;
         *__esp =  *(_t623 + 8);
        _v4 = _t623[1];
        caml_c_call( *_t623);
        if(caml_compare != 1) {
            _t512 =  *__esp;
            if(_t512 == 1) {
                while(1) {
L74:
                    _t514 = caml_young_ptr - 8;
                    caml_young_ptr = _t514;
                    if(_t514 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t516 = _t514 + 4;
                 *((intOrPtr*)(_t516 - 4)) = 1024;
                 *_t516 =  &caml_exn_Not_found;
                caml_raise_exn(_t516);
                goto L76;
            }
             *__esp =  *(_t512 + 8);
            _v4 =  *((intOrPtr*)(_t512 + 4));
            caml_c_call( *_t512);
            if(caml_compare != 1) {
                _t521 =  *__esp;
                if(_t521 == 1) {
                    while(1) {
                        _t523 = caml_young_ptr - 8;
                        caml_young_ptr = _t523;
                        if(_t523 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t525 = _t523 + 4;
                     *((intOrPtr*)(_t525 - 4)) = 1024;
                     *_t525 =  &caml_exn_Not_found;
                    caml_raise_exn(_t525);
                    goto L74;
                }
                 *__esp =  *(_t521 + 8);
                _v4 =  *((intOrPtr*)(_t521 + 4));
                caml_c_call( *_t521);
                if(caml_compare != 1) {
                    _t454 = _v8;
                    _t568 =  *__esp;
                    __esp =  &(__esp[3]);
L51:
                    __esp = __esp - 12;
                    while(_t568 != 1) {
                         *__esp = _t454;
                        _v56 =  *(_t568 + 8);
                        _v52 =  *(_t568 + 4);
                        caml_c_call( *_t568);
                        if(caml_compare != 1) {
                            _t454 =  *__esp;
                            _t568 = _v56;
                            continue;
                        }
                        __esp =  &(__esp[3]);
                        return _v52;
                        goto L142;
                    }
L56:
                    _t456 = caml_young_ptr - 8;
                    caml_young_ptr = _t456;
                    if(_t456 >= caml_young_limit) {
                        _t458 = _t456 + 4;
                         *((intOrPtr*)(_t458 - 4)) = 1024;
                         *_t458 =  &caml_exn_Not_found;
                        caml_raise_exn(_t458);
                    }
                    caml_call_gc();
                    goto L56;
                } else {
                    __esp =  &(__esp[3]);
                    return _v4;
                }
            } else {
                __esp =  &(__esp[3]);
                return _v4;
            }
        } else {
            __esp =  &(__esp[3]);
            return _v4;
        }
    }
L142:
}

unsigned int camlHashtbl__find_all_1105(
    unsigned int __eax,                    // r0
    unsigned int __ebx                     // r1
)
{// addr = 0x080566F0
    signed int _v0;                        // _cfa_0
    unsigned int _v4;                      // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    unsigned int _v68;                     // _cfa_ffffffbc
    unsigned int _v72;                     // _cfa_ffffffb8
    unsigned int _v76;                     // _cfa_ffffffb4
    unsigned int _v80;                     // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    unsigned int _t288;                    // _t288
    unsigned int _t294;                    // _t294
    unsigned int* _t296;                   // _t296
    unsigned int _t297;                    // _t297
    unsigned int _t303;                    // _t303

    _t297 = __ebx;
    _t288 = __eax;
    __edi = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 16;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __ebx = __eax + 4;
     *(__ebx - 4) = 3319;
     *__ebx = camlHashtbl__find_in_bucket_1108;
     *(__ebx + 4) = 3;
     *(__ebx + 8) = __ecx;
    __eax =  *(__edi + 4);
    __esi =  *(__eax - 4);
    __esi =  *(__eax - 4) >> 10;
    if(__esi == 0) {
         &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        __eax = caml_hash_univ_param(21, 201, __ecx);
        __eax = __eax >> 1;
        __ecx = __esi;
        asm("cdq");
        _t110 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t110;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    __ecx =  *(__edi + 4);
     *(__ecx - 4) =  *(__ecx - 4) >> 9;
    if( *(__ecx - 4) >> 9 <= __edx) {
        __eax = caml_ml_array_bound_error();
        __esp = __esp - 28;
        __edi = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 20;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __edx = __eax + 4;
         *(__edx - 4) = 4343;
         *__edx = camlHashtbl__replace_bucket_1116;
         *(__edx + 4) = 3;
         *(__edx + 8) = __ebx;
         *(__edx + 12) = __ecx;
        __eax =  *(__edi + 4);
        __esi =  *(__eax - 4);
        __esi =  *(__eax - 4) >> 10;
        if(__esi == 0) {
             &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _v12 = __edx;
            _v20 = __ecx;
            _v24 = __ebx;
             *__esp = __edi;
            __eax = caml_hash_univ_param(21, 201, __ebx);
            __eax = __eax >> 1;
            __ecx = __esi;
            asm("cdq");
            _t129 = __eax % __ecx;
            __eax = __eax / __ecx;
            __edx = _t129;
        }
        __edx = __edx << 1;
        __edx = __edx + 1;
        _v4 = __edx;
        __ebx =  *(__edi + 4);
         *(__ebx - 4) =  *(__ebx - 4) >> 9;
        if( *(__ebx - 4) >> 9 <= __edx) {
L86:
            __eax = caml_ml_array_bound_error();
            __edi = __eax;
            __ecx = __ebx;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 16;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __ebx = __eax + 4;
             *(__ebx - 4) = 3319;
             *__ebx = camlHashtbl__mem_in_bucket_1125;
             *(__ebx + 4) = 3;
             *(__ebx + 8) = __ecx;
            __eax =  *(__edi + 4);
            __esi =  *(__eax - 4);
            __esi =  *(__eax - 4) >> 10;
            if(__esi == 0) {
                 &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
            } else {
                __eax = caml_hash_univ_param(21, 201, __ecx);
                __eax = __eax >> 1;
                __ecx = __esi;
                asm("cdq");
                _t172 = __eax % __ecx;
                __eax = __eax / __ecx;
                __edx = _t172;
            }
            __edx = __edx << 1;
            __edx = __edx + 1;
            __ecx =  *(__edi + 4);
             *(__ecx - 4) =  *(__ecx - 4) >> 9;
            if( *(__ecx - 4) >> 9 <= __edx) {
                __eax = caml_ml_array_bound_error();
                __esp = __esp - 16;
                __edx = __eax;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 16;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    __eax = caml_call_gc();
                }
                __ecx = __eax + 4;
                 *(__ecx - 4) = 3319;
                 *__ecx = camlHashtbl__do_bucket_1132;
                 *(__ecx + 4) = 3;
                 *(__ecx + 8) = __edx;
                __edx =  *(__ebx + 4);
                __eax = 1;
                 *(__edx - 4) =  *(__edx - 4) >> 9;
                __ebx =  *(__edx - 4) >> 9 | 1;
                __ebx = ( *(__edx - 4) >> 9 | 1) + -2;
                if(1 > __ebx) {
L102:
                    __eax = 1;
                    __esp =  &(__esp[4]);
                    return 1;
                } else {
                    _v32 = __ebx;
                    _v36 = 1;
                     *__esp = __edx;
                    _v40 = __ecx;
                    while(1) {
                        __ebx =  *__esp;
                         *(__ebx - 4) =  *(__ebx - 4) >> 9;
                        if( *(__ebx - 4) >> 9 <= __eax) {
                            break;
                        }
                        __eax =  *(__ebx + __eax * 2 - 2);
                        __ebx = _v40;
                        __eax = camlHashtbl__do_bucket_1132(__eax, _v40);
                        __eax = _v36;
                        __ecx = __eax;
                        __eax = __eax + 2;
                        _v36 = __eax;
                        __ebx = _v32;
                        if(__ecx != _v32) {
                            continue;
                        } else {
                            goto L102;
                        }
                        goto L118;
                    }
                    __eax = caml_ml_array_bound_error();
                    __esp = __esp - 20;
                    __esi = __eax;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 28;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __edx = __eax + 4;
                     *(__edx - 4) = 4343;
                     *__edx = caml_curry2;
                     *(__edx + 4) = 5;
                     *(__edx + 8) = camlHashtbl__do_bucket_1142;
                     *(__edx + 12) = __esi;
                    __esi =  *(__ebx + 4);
                    __ebx = __edx + 20;
                     *(__ebx - 4) = 1024;
                     *__ebx = __ecx;
                    __eax = 1;
                     *(__esi - 4) =  *(__esi - 4) >> 9;
                    __ecx =  *(__esi - 4) >> 9 | 1;
                    __ecx = ( *(__esi - 4) >> 9 | 1) + -2;
                    if(1 > __ecx) {
L111:
                        __eax =  *__ebx;
                        __esp =  &(__esp[5]);
                        return  *__ebx;
                    } else {
                        _v48 = __ecx;
                        _v52 = 1;
                        _v56 = __ebx;
                         *__esp = __esi;
                        _v60 = __edx;
                        while(1) {
                            __ebx =  *__ebx;
                            __ecx =  *__esp;
                             *(__ecx - 4) =  *(__ecx - 4) >> 9;
                            if( *(__ecx - 4) >> 9 <= __eax) {
                                break;
                            }
                            __eax =  *(__ecx + __eax * 2 - 2);
                            __ecx = _v60;
                            _push(__eax);
                            __ebx = _v56;
                            _push(__ebx);
                            __eax = caml_modify(__ebx, __edi, __esi);
                            __esp =  &(__esp[2]);
                            __eax = _v52;
                            __edx = __eax;
                            __eax = __eax + 2;
                            _v52 = __eax;
                            __ecx = _v48;
                            if(__edx != _v48) {
                                continue;
                            } else {
                                goto L111;
                            }
                            goto L118;
                        }
                        __eax = caml_ml_array_bound_error();
                        __esp = __esp - 28;
                        __ebx = __eax;
                        __eax = camlHashtbl;
                         *__esp = camlHashtbl;
                        __eax =  *134690208;
                        _v88 =  *134690208;
                        __eax =  *134690216;
                        _v84 =  *134690216;
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 232;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            __eax = caml_call_gc();
                        }
                        __eax = __eax + 4;
                         *(__eax - 4) = 3319;
                         *__eax = camlHashtbl__safehash_1177;
                         *(__eax + 4) = 3;
                         *(__eax + 8) = __ebx;
                        __ecx = __eax + 16;
                        _v80 = __ecx;
                         *(__ecx - 4) = 4343;
                         *__ecx = caml_curry3;
                         *(__ecx + 4) = 7;
                         *(__ecx + 8) = camlHashtbl__add_1179;
                         *(__ecx + 12) = __eax;
                        __ecx = __eax + 36;
                        _v76 = __ecx;
                         *(__ecx - 4) = 5367;
                         *__ecx = caml_curry2;
                         *(__ecx + 4) = 5;
                         *(__ecx + 8) = camlHashtbl__remove_1185;
                         *(__ecx + 12) = __ebx;
                         *(__ecx + 16) = __eax;
                        __edx = __eax + 60;
                         *(__edx - 4) = 4343;
                         *__edx = caml_curry2;
                         *(__edx + 4) = 5;
                         *(__edx + 8) = camlHashtbl__find_rec_1193;
                         *(__edx + 12) = __ebx;
                        __ecx = __eax + 80;
                        _v72 = __ecx;
                         *(__ecx - 4) = 6391;
                         *__ecx = caml_curry2;
                         *(__ecx + 4) = 5;
                         *(__ecx + 8) = camlHashtbl__find_1198;
                         *(__ecx + 12) = __ebx;
                         *(__ecx + 16) = __eax;
                         *(__ecx + 20) = __edx;
                        __esi = __eax + 108;
                         *(__esi - 4) = 5367;
                         *__esi = caml_curry2;
                         *(__esi + 4) = 5;
                         *(__esi + 8) = camlHashtbl__find_all_1210;
                         *(__esi + 12) = __ebx;
                         *(__esi + 16) = __eax;
                        __edx = __eax + 132;
                         *(__edx - 4) = 5367;
                         *__edx = caml_curry3;
                         *(__edx + 4) = 7;
                         *(__edx + 8) = camlHashtbl__replace_1217;
                         *(__edx + 12) = __ebx;
                         *(__edx + 16) = __eax;
                        __ecx = __eax + 156;
                         *(__ecx - 4) = 5367;
                         *__ecx = caml_curry2;
                         *(__ecx + 4) = 5;
                         *(__ecx + 8) = camlHashtbl__mem_1227;
                         *(__ecx + 12) = __ebx;
                         *(__ecx + 16) = __eax;
                        __ebx =  *134690240;
                        _v68 =  *134690240;
                        __edi =  *134690248;
                        __eax = __eax + 180;
                         *(__eax - 4) = 12288;
                        __ebx =  *__esp;
                         *__eax =  *__esp;
                        __ebx = _v88;
                         *(__eax + 4) = _v88;
                        __ebx = _v84;
                         *(__eax + 8) = _v84;
                        __ebx = _v80;
                         *(__eax + 12) = _v80;
                        __ebx = _v76;
                         *(__eax + 16) = _v76;
                        __ebx = _v72;
                         *(__eax + 20) = _v72;
                         *(__eax + 24) = __esi;
                         *(__eax + 28) = __edx;
                         *(__eax + 32) = __ecx;
                        __ebx = _v68;
                         *(__eax + 36) = _v68;
                         *((intOrPtr*)(__eax + 40)) =  *134690244;
                         *(__eax + 44) =  *134690248;
                        __esp =  &(__esp[7]);
                        return __eax;
                    }
                }
            } else {
                __eax =  *(__ecx + __edx * 2 - 2);
                __esp = __esp - 8;
                while(__eax != 1) {
                    _v32 = __ebx;
                    __ecx =  *(__eax + 8);
                     *__esp =  *(__eax + 8);
                    __eax =  *__eax;
                    _push( *(__ebx + 8));
                    _push(__eax);
                    __eax = caml_compare;
                    caml_c_call();
                    __esp =  &(__esp[2]);
                    if(caml_compare != 1) {
                        __eax =  *__esp;
                        __ebx = _v32;
                        continue;
                    } else {
                        __eax = 3;
                        __esp =  &(__esp[2]);
                        return 3;
                    }
                    goto L118;
                }
                __eax = 1;
                __esp =  &(__esp[2]);
                return 1;
            }
        } else {
            __eax =  *(__ebx + __edx * 2 - 2);
            _v16 = __eax;
            L80();
            __ecx =  &caml_exn_Not_found;
            __ebx =  *__eax;
            if( *__eax !=  &caml_exn_Not_found) {
                __eax = caml_raise_exn(__eax);
                _push(caml_exception_pointer);
                caml_exception_pointer = __esp;
                __ebx =  *(__edi + 4);
                _v4 = __ebx;
                __ebx =  *(__ebx - 4);
                __ebx = __ebx >> 9;
                if(__ebx <= __edx) {
                    __eax = caml_ml_array_bound_error();
                    goto L85;
                } else {
                    __ebx = _v8;
                    _push(__eax);
                    __ebx = _v4;
                    __eax = _v0;
                    __eax = __ebx + _v0 * 2 - 2;
                    _push(__ebx + _v0 * 2 - 2);
                    __eax = caml_modify(__ebx, __edi, __esi);
                    __esp =  &(__esp[2]);
                    __eax = 1;
                    _pop(caml_exception_pointer);
                    __esp =  &(__esp[7]);
                    return 1;
                }
            } else {
                __ebx =  *__esp;
                __edx =  *(__ebx + 4);
                 *(__edx - 4) =  *(__edx - 4) >> 9;
                __ecx = _v4;
                if( *(__edx - 4) >> 9 <= __ecx) {
L85:
                    __eax = caml_ml_array_bound_error();
                    goto L86;
                } else {
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 16;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __esi = __eax + 4;
                     *(__esi - 4) = 3072;
                    __eax = _v24;
                     *__esi = _v24;
                    __eax = _v20;
                     *(__esi + 4) = _v20;
                    __eax = _v16;
                     *(__esi + 8) = _v16;
                    _push(__esi);
                    __eax = __edx + __ecx * 2 - 2;
                    _push(__edx + __ecx * 2 - 2);
                    __eax = caml_modify(__ebx, __edi, __esi);
                    __esp =  &(__esp[2]);
                     *__ebx =  *__ebx + 2;
                    __eax =  *(__ebx + 4);
                    __eax =  *( *(__ebx + 4) - 4);
                    __eax =  *( *(__ebx + 4) - 4) >> 9;
                    __ecx = ( *( *(__ebx + 4) - 4) >> 9 | 1) + ( *( *(__ebx + 4) - 4) >> 9 | 1) - 1;
                    __eax =  *__ebx;
                    if( *__ebx <= __ecx) {
                        __eax = 1;
                        __esp =  &(__esp[7]);
                        return 1;
                    } else {
                        __eax =  *134690256;
                        __esp =  &(__esp[7]);
                        while(1) {
                            __esp = __esp - 24;
                             *__esp = __eax;
                            _v8 = __ebx;
                            __eax =  *(__ebx + 4);
                            _v4 = __eax;
                            __eax =  *(__eax - 4);
                            __eax = __eax >> 9;
                            __eax = __eax | 1;
                            _v16 = __eax;
                            __ebx =  *134689872;
                            __eax = __eax >> 1;
                            __eax = 3 + __eax * 4;
                            __eax = camlPervasives__min_1022(__eax);
                            __ebx = _v16;
                            if(__eax == __ebx) {
                                break;
                            }
                            _v20 = __eax;
                            _v16 = __ebx;
                            _push(__eax);
                            __eax = caml_make_vect;
                            caml_c_call(1);
                            __esp =  &(__esp[2]);
                            __ebx = caml_make_vect;
                            _v12 = caml_make_vect;
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 24;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __ecx = __eax + 4;
                             *(__ecx - 4) = 5367;
                             *__ecx = camlHashtbl__insert_bucket_1068;
                             *(__ecx + 4) = 3;
                            __eax =  *__esp;
                             *(__ecx + 8) =  *__esp;
                            __eax = _v20;
                             *(__ecx + 12) = _v20;
                             *(__ecx + 16) = __ebx;
                            __eax = 1;
                            __ebx = _v16;
                            __ebx = _v16 + -2;
                            if(1 > __ebx) {
L23:
                                __eax = _v12;
                                _push(_v12);
                                __eax = _v8;
                                __eax = _v8 + 4;
                                _push(_v8 + 4);
                                __eax = caml_modify(__ebx, __edi, __esi);
                                __esp =  &(__esp[2]);
                                __eax = 1;
                                __esp =  &(__esp[6]);
                                return 1;
                            } else {
                                _v16 = __ebx;
                                _v20 = 1;
                                 *__esp = __ecx;
                                while(1) {
                                    __ebx = _v4;
                                     *(__ebx - 4) =  *(__ebx - 4) >> 9;
                                    if( *(__ebx - 4) >> 9 <= __eax) {
                                        break;
                                    }
                                    __eax =  *(__ebx + __eax * 2 - 2);
                                    __ebx =  *__esp;
                                    __eax = camlHashtbl__insert_bucket_1068(__eax);
                                    __eax = _v20;
                                    __ecx = __eax;
                                    __eax = __eax + 2;
                                    _v20 = __eax;
                                    __ebx = _v16;
                                    if(__ecx != __ebx) {
                                        continue;
                                    } else {
                                        goto L23;
                                    }
                                    goto L118;
                                }
                                __eax = caml_ml_array_bound_error();
                                __esp = __esp - 4;
                                __edi = __eax;
                                __eax =  *(__edi + 4);
                                __esi =  *(__eax - 4);
                                __esi =  *(__eax - 4) >> 10;
                                if(__esi == 0) {
                                     &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
                                } else {
                                     *__esp = __ecx;
                                    __eax = caml_hash_univ_param(21, 201, __ebx);
                                    __eax = __eax >> 1;
                                    __ecx = __esi;
                                    asm("cdq");
                                    _t50 = __eax % __ecx;
                                    __eax = __eax / __ecx;
                                    __edx = _t50;
                                }
                                __edx = __edx << 1;
                                __edx = __edx + 1;
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 16;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __eax = __eax + 4;
                                 *(__eax - 4) = 3072;
                                 *__eax = __ebx;
                                __ebx =  *__esp;
                                 *(__eax + 4) =  *__esp;
                                __ecx =  *(__edi + 4);
                                __ebx =  *(__ecx - 4);
                                __ebx =  *(__ecx - 4) >> 9;
                                if(__ebx <= __edx) {
L39:
                                    __eax = caml_ml_array_bound_error();
                                    __esp = __esp - 8;
                                    __edi = __eax;
                                    __ecx = __ebx;
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 20;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            break;
                                        }
                                        __eax = caml_call_gc();
                                    }
                                    __ebx = __eax + 4;
                                     *(__ebx - 4) = 4343;
                                     *__ebx = camlHashtbl__remove_bucket_1083;
                                     *(__ebx + 4) = 3;
                                     *(__ebx + 8) = __edi;
                                     *(__ebx + 12) = __ecx;
                                    __eax =  *(__edi + 4);
                                    __esi =  *(__eax - 4);
                                    __esi =  *(__eax - 4) >> 10;
                                    if(__esi == 0) {
                                         &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
                                    } else {
                                        __eax = caml_hash_univ_param(21, 201, __ecx);
                                        __eax = __eax >> 1;
                                        __ecx = __esi;
                                        asm("cdq");
                                        _t79 = __eax % __ecx;
                                        __eax = __eax / __ecx;
                                        __edx = _t79;
                                    }
                                    __edx = __edx << 1;
                                    __edx = __edx + 1;
                                    _v32 = __edx;
                                    __eax =  *(__edi + 4);
                                     *__esp = __eax;
                                    __eax =  *(__eax - 4);
                                    if(__eax <= __edx) {
L50:
                                        __eax = caml_ml_array_bound_error();
                                        __esp = __esp - 12;
                                        while(__ebx != 1) {
                                             *__esp = __eax;
                                            __ecx =  *(__ebx + 8);
                                            _v44 =  *(__ebx + 8);
                                            __ecx =  *(__ebx + 4);
                                            _v40 =  *(__ebx + 4);
                                            _push(__ebx);
                                            _push(__eax);
                                            __eax = caml_compare;
                                            caml_c_call();
                                            __esp =  &(__esp[2]);
                                            if(caml_compare != 1) {
                                                __eax =  *__esp;
                                                __ebx = _v44;
                                                continue;
                                            }
                                            __eax = _v40;
                                            __esp =  &(__esp[3]);
                                            return _v40;
                                            goto L118;
                                        }
L56:
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 8;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            __eax = __eax + 4;
                                             *(__eax - 4) = 1024;
                                             *__eax =  &caml_exn_Not_found;
                                            __eax = caml_raise_exn(__eax);
                                        }
                                        __eax = caml_call_gc();
                                        goto L56;
                                    } else {
                                        __ecx =  *(__edi + 4);
                                         *(__ecx - 4) =  *(__ecx - 4) >> 9;
                                        if( *(__ecx - 4) >> 9 <= __edx) {
                                            __eax = caml_ml_array_bound_error();
                                            goto L50;
                                        } else {
                                            __eax =  *(__ecx + __edx * 2 - 2);
                                            _push(camlHashtbl__remove_bucket_1083( *(__ecx + __edx * 2 - 2), __ebx));
                                            __ebx = _v36;
                                            __eax = _v32;
                                            __eax = __ebx + _v32 * 2 - 2;
                                            _push(__ebx + _v32 * 2 - 2);
                                            __eax = caml_modify(__ebx, __edi, __esi);
                                            __esp =  &(__esp[2]);
                                            __eax = 1;
                                            __esp =  &(__esp[2]);
                                            return 1;
                                        }
                                    }
                                } else {
                                    __ebx =  *(__ecx + __edx * 2 - 2);
                                     *(__eax + 8) =  *(__ecx + __edx * 2 - 2);
                                    __ecx =  *(__edi + 4);
                                    __ebx =  *(__ecx - 4);
                                    __ebx =  *(__ecx - 4) >> 9;
                                    if(__ebx <= __edx) {
                                        __eax = caml_ml_array_bound_error();
                                        goto L39;
                                    } else {
                                        _push(__eax);
                                        __eax = __ecx + __edx * 2 - 2;
                                        _push(__ecx + __edx * 2 - 2);
                                        __eax = caml_modify(__ebx, __edi, __esi);
                                        __esp =  &(__esp[2]);
                                         *__edi =  *__edi + 2;
                                        __eax =  *(__edi + 4);
                                        __eax =  *( *(__edi + 4) - 4);
                                        __eax =  *( *(__edi + 4) - 4) >> 9;
                                        __ebx = ( *( *(__edi + 4) - 4) >> 9 | 1) + ( *( *(__edi + 4) - 4) >> 9 | 1) - 1;
                                        __eax =  *__edi;
                                        if( *__edi <= __ebx) {
                                            __eax = 1;
                                            __esp =  &(__esp[1]);
                                            return 1;
                                        } else {
                                            __eax =  *134690256;
                                            __ebx = __edi;
                                            __esp =  &(__esp[1]);
                                            continue;
                                        }
                                    }
                                }
                            }
                            goto L118;
                        }
                        __eax = 1;
                        __esp =  &(__esp[6]);
                        return 1;
                    }
                }
            }
        }
    } else {
        __eax =  *(__ecx + __edx * 2 - 2);
        __esp = __esp - 12;
        while(_t288 != 1) {
            _v8 = _t297;
             *__esp =  *(_t288 + 8);
            _v4 =  *(_t288 + 4);
            caml_c_call( *((intOrPtr*)(_t297 + 8)));
            if(caml_compare != 1) {
                _t288 =  *__esp;
                _t297 = _v8;
                continue;
            } else {
                L1();
                _t303 =  *__esp;
                while(1) {
                    _t294 = caml_young_ptr - 12;
                    caml_young_ptr = _t294;
                    if(_t294 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t296 = _t294 + 4;
                 *((intOrPtr*)(_t296 - 4)) = 2048;
                 *_t296 = _v4;
                _t296[1] = _t303;
                __esp =  &(__esp[3]);
                return _t296;
            }
            goto L118;
        }
        __esp =  &(__esp[3]);
        return 1;
    }
L118:
}

unsigned int camlHashtbl__replace_1112(
    unsigned int __eax,                    // r0
    unsigned int __ebx,                    // r1
    _unknown_ __ecx                        // r2
)
{// addr = 0x08056790
    signed int _v0;                        // _cfa_0
    unsigned int _v4;                      // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    unsigned int _v16;                     // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    unsigned int _v68;                     // _cfa_ffffffbc
    unsigned int _v72;                     // _cfa_ffffffb8
    unsigned int _v76;                     // _cfa_ffffffb4
    unsigned int _v80;                     // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    unsigned int _v88;                     // _cfa_ffffffa8
    unsigned int _t262;                    // _t262

    __ebx = __ebx;
    _t262 = __eax;
    __esp = __esp - 28;
    __edi = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 20;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __edx = __eax + 4;
     *(__edx - 4) = 4343;
     *__edx = camlHashtbl__replace_bucket_1116;
     *(__edx + 4) = 3;
     *(__edx + 8) = __ebx;
     *(__edx + 12) = __ecx;
    __eax =  *(__edi + 4);
    __esi =  *(__eax - 4);
    __esi =  *(__eax - 4) >> 10;
    if(__esi == 0) {
         &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        _v12 = __edx;
        _v20 = __ecx;
        _v24 = __ebx;
         *__esp = __edi;
        __eax = caml_hash_univ_param(21, 201, __ebx);
        __eax = __eax >> 1;
        __ecx = __esi;
        asm("cdq");
        _t103 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t103;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    _v4 = __edx;
    __ebx =  *(__edi + 4);
     *(__ebx - 4) =  *(__ebx - 4) >> 9;
    if( *(__ebx - 4) >> 9 <= __edx) {
L68:
        __eax = caml_ml_array_bound_error();
        __edi = __eax;
        __ecx = __ebx;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 16;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __ebx = __eax + 4;
         *(__ebx - 4) = 3319;
         *__ebx = camlHashtbl__mem_in_bucket_1125;
         *(__ebx + 4) = 3;
         *(__ebx + 8) = __ecx;
        __eax =  *(__edi + 4);
        __esi =  *(__eax - 4);
        __esi =  *(__eax - 4) >> 10;
        if(__esi == 0) {
             &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            __eax = caml_hash_univ_param(21, 201, __ecx);
            __eax = __eax >> 1;
            __ecx = __esi;
            asm("cdq");
            _t146 = __eax % __ecx;
            __eax = __eax / __ecx;
            __edx = _t146;
        }
        __edx = __edx << 1;
        __edx = __edx + 1;
        __ecx =  *(__edi + 4);
         *(__ecx - 4) =  *(__ecx - 4) >> 9;
        if( *(__ecx - 4) >> 9 <= __edx) {
            __eax = caml_ml_array_bound_error();
            __esp = __esp - 16;
            __edx = __eax;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 16;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __ecx = __eax + 4;
             *(__ecx - 4) = 3319;
             *__ecx = camlHashtbl__do_bucket_1132;
             *(__ecx + 4) = 3;
             *(__ecx + 8) = __edx;
            __edx =  *(__ebx + 4);
            __eax = 1;
             *(__edx - 4) =  *(__edx - 4) >> 9;
            __ebx =  *(__edx - 4) >> 9 | 1;
            __ebx = ( *(__edx - 4) >> 9 | 1) + -2;
            if(1 > __ebx) {
L84:
                __eax = 1;
                __esp =  &(__esp[4]);
                return 1;
            } else {
                _v32 = __ebx;
                _v36 = 1;
                 *__esp = __edx;
                _v40 = __ecx;
                while(1) {
                    __ebx =  *__esp;
                     *(__ebx - 4) =  *(__ebx - 4) >> 9;
                    if( *(__ebx - 4) >> 9 <= __eax) {
                        break;
                    }
                    __eax =  *(__ebx + __eax * 2 - 2);
                    __ebx = _v40;
                    __eax = camlHashtbl__do_bucket_1132(__eax, _v40);
                    __eax = _v36;
                    __ecx = __eax;
                    __eax = __eax + 2;
                    _v36 = __eax;
                    __ebx = _v32;
                    if(__ecx != _v32) {
                        continue;
                    } else {
                        goto L84;
                    }
                    goto L100;
                }
                __eax = caml_ml_array_bound_error();
                __esp = __esp - 20;
                __esi = __eax;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 28;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    __eax = caml_call_gc();
                }
                __edx = __eax + 4;
                 *(__edx - 4) = 4343;
                 *__edx = caml_curry2;
                 *(__edx + 4) = 5;
                 *(__edx + 8) = camlHashtbl__do_bucket_1142;
                 *(__edx + 12) = __esi;
                __esi =  *(__ebx + 4);
                __ebx = __edx + 20;
                 *(__ebx - 4) = 1024;
                 *__ebx = __ecx;
                __eax = 1;
                 *(__esi - 4) =  *(__esi - 4) >> 9;
                __ecx =  *(__esi - 4) >> 9 | 1;
                __ecx = ( *(__esi - 4) >> 9 | 1) + -2;
                if(1 > __ecx) {
L93:
                    __eax =  *__ebx;
                    __esp =  &(__esp[5]);
                    return  *__ebx;
                } else {
                    _v48 = __ecx;
                    _v52 = 1;
                    _v56 = __ebx;
                     *__esp = __esi;
                    _v60 = __edx;
                    while(1) {
                        __ebx =  *__ebx;
                        __ecx =  *__esp;
                         *(__ecx - 4) =  *(__ecx - 4) >> 9;
                        if( *(__ecx - 4) >> 9 <= __eax) {
                            break;
                        }
                        __eax =  *(__ecx + __eax * 2 - 2);
                        __ecx = _v60;
                        _push(__eax);
                        __ebx = _v56;
                        _push(__ebx);
                        __eax = caml_modify(__ebx, __edi, __esi);
                        __esp =  &(__esp[2]);
                        __eax = _v52;
                        __edx = __eax;
                        __eax = __eax + 2;
                        _v52 = __eax;
                        __ecx = _v48;
                        if(__edx != _v48) {
                            continue;
                        } else {
                            goto L93;
                        }
                        goto L100;
                    }
                    __eax = caml_ml_array_bound_error();
                    __esp = __esp - 28;
                    __ebx = __eax;
                    __eax = camlHashtbl;
                     *__esp = camlHashtbl;
                    __eax =  *134690208;
                    _v88 =  *134690208;
                    __eax =  *134690216;
                    _v84 =  *134690216;
                    while(1) {
                        __eax = caml_young_ptr;
                        __eax = caml_young_ptr - 232;
                        caml_young_ptr = __eax;
                        if(__eax >= caml_young_limit) {
                            break;
                        }
                        __eax = caml_call_gc();
                    }
                    __eax = __eax + 4;
                     *(__eax - 4) = 3319;
                     *__eax = camlHashtbl__safehash_1177;
                     *(__eax + 4) = 3;
                     *(__eax + 8) = __ebx;
                    __ecx = __eax + 16;
                    _v80 = __ecx;
                     *(__ecx - 4) = 4343;
                     *__ecx = caml_curry3;
                     *(__ecx + 4) = 7;
                     *(__ecx + 8) = camlHashtbl__add_1179;
                     *(__ecx + 12) = __eax;
                    __ecx = __eax + 36;
                    _v76 = __ecx;
                     *(__ecx - 4) = 5367;
                     *__ecx = caml_curry2;
                     *(__ecx + 4) = 5;
                     *(__ecx + 8) = camlHashtbl__remove_1185;
                     *(__ecx + 12) = __ebx;
                     *(__ecx + 16) = __eax;
                    __edx = __eax + 60;
                     *(__edx - 4) = 4343;
                     *__edx = caml_curry2;
                     *(__edx + 4) = 5;
                     *(__edx + 8) = camlHashtbl__find_rec_1193;
                     *(__edx + 12) = __ebx;
                    __ecx = __eax + 80;
                    _v72 = __ecx;
                     *(__ecx - 4) = 6391;
                     *__ecx = caml_curry2;
                     *(__ecx + 4) = 5;
                     *(__ecx + 8) = camlHashtbl__find_1198;
                     *(__ecx + 12) = __ebx;
                     *(__ecx + 16) = __eax;
                     *(__ecx + 20) = __edx;
                    __esi = __eax + 108;
                     *(__esi - 4) = 5367;
                     *__esi = caml_curry2;
                     *(__esi + 4) = 5;
                     *(__esi + 8) = camlHashtbl__find_all_1210;
                     *(__esi + 12) = __ebx;
                     *(__esi + 16) = __eax;
                    __edx = __eax + 132;
                     *(__edx - 4) = 5367;
                     *__edx = caml_curry3;
                     *(__edx + 4) = 7;
                     *(__edx + 8) = camlHashtbl__replace_1217;
                     *(__edx + 12) = __ebx;
                     *(__edx + 16) = __eax;
                    __ecx = __eax + 156;
                     *(__ecx - 4) = 5367;
                     *__ecx = caml_curry2;
                     *(__ecx + 4) = 5;
                     *(__ecx + 8) = camlHashtbl__mem_1227;
                     *(__ecx + 12) = __ebx;
                     *(__ecx + 16) = __eax;
                    __ebx =  *134690240;
                    _v68 =  *134690240;
                    __edi =  *134690248;
                    __eax = __eax + 180;
                     *(__eax - 4) = 12288;
                    __ebx =  *__esp;
                     *__eax =  *__esp;
                    __ebx = _v88;
                     *(__eax + 4) = _v88;
                    __ebx = _v84;
                     *(__eax + 8) = _v84;
                    __ebx = _v80;
                     *(__eax + 12) = _v80;
                    __ebx = _v76;
                     *(__eax + 16) = _v76;
                    __ebx = _v72;
                     *(__eax + 20) = _v72;
                     *(__eax + 24) = __esi;
                     *(__eax + 28) = __edx;
                     *(__eax + 32) = __ecx;
                    __ebx = _v68;
                     *(__eax + 36) = _v68;
                     *((intOrPtr*)(__eax + 40)) =  *134690244;
                     *(__eax + 44) =  *134690248;
                    __esp =  &(__esp[7]);
                    return __eax;
                }
            }
        } else {
            __eax =  *(__ecx + __edx * 2 - 2);
            __esp = __esp - 8;
            while(_t262 != 1) {
                _v32 = __ebx;
                 *__esp =  *(_t262 + 8);
                caml_c_call( *(__ebx + 8));
                if(caml_compare != 1) {
                    _t262 =  *__esp;
                    __ebx = _v32;
                    continue;
                } else {
                    __esp =  &(__esp[2]);
                    return 3;
                }
                goto L100;
            }
            __esp =  &(__esp[2]);
            return 1;
        }
    } else {
        __eax =  *(__ebx + __edx * 2 - 2);
        _v16 = __eax;
        L62();
        __ecx =  &caml_exn_Not_found;
        __ebx =  *__eax;
        if( *__eax !=  &caml_exn_Not_found) {
            __eax = caml_raise_exn(__eax);
            _push(caml_exception_pointer);
            caml_exception_pointer = __esp;
            __ebx =  *(__edi + 4);
            _v4 = __ebx;
            __ebx =  *(__ebx - 4);
            __ebx = __ebx >> 9;
            if(__ebx <= __edx) {
                __eax = caml_ml_array_bound_error();
                goto L67;
            } else {
                __ebx = _v8;
                _push(__eax);
                __ebx = _v4;
                __eax = _v0;
                __eax = __ebx + _v0 * 2 - 2;
                _push(__ebx + _v0 * 2 - 2);
                __eax = caml_modify(__ebx, __edi, __esi);
                __esp =  &(__esp[2]);
                __eax = 1;
                _pop(caml_exception_pointer);
                __esp =  &(__esp[7]);
                return 1;
            }
        } else {
            __ebx =  *__esp;
            __edx =  *(__ebx + 4);
             *(__edx - 4) =  *(__edx - 4) >> 9;
            __ecx = _v4;
            if( *(__edx - 4) >> 9 <= __ecx) {
L67:
                __eax = caml_ml_array_bound_error();
                goto L68;
            } else {
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 16;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    __eax = caml_call_gc();
                }
                __esi = __eax + 4;
                 *(__esi - 4) = 3072;
                __eax = _v24;
                 *__esi = _v24;
                __eax = _v20;
                 *(__esi + 4) = _v20;
                __eax = _v16;
                 *(__esi + 8) = _v16;
                _push(__esi);
                __eax = __edx + __ecx * 2 - 2;
                _push(__edx + __ecx * 2 - 2);
                __eax = caml_modify(__ebx, __edi, __esi);
                __esp =  &(__esp[2]);
                 *__ebx =  *__ebx + 2;
                __eax =  *(__ebx + 4);
                __eax =  *( *(__ebx + 4) - 4);
                __eax =  *( *(__ebx + 4) - 4) >> 9;
                __ecx = ( *( *(__ebx + 4) - 4) >> 9 | 1) + ( *( *(__ebx + 4) - 4) >> 9 | 1) - 1;
                __eax =  *__ebx;
                if( *__ebx <= __ecx) {
                    __eax = 1;
                    __esp =  &(__esp[7]);
                    return 1;
                } else {
                    __eax =  *134690256;
                    __esp =  &(__esp[7]);
                    while(1) {
                        __esp = __esp - 24;
                         *__esp = __eax;
                        _v8 = __ebx;
                        __eax =  *(__ebx + 4);
                        _v4 = __eax;
                        __eax =  *(__eax - 4);
                        __eax = __eax >> 9;
                        __eax = __eax | 1;
                        _v16 = __eax;
                        __ebx =  *134689872;
                        __eax = __eax >> 1;
                        __eax = 3 + __eax * 4;
                        __eax = camlPervasives__min_1022(__eax);
                        __ebx = _v16;
                        if(__eax == __ebx) {
                            break;
                        }
                        _v20 = __eax;
                        _v16 = __ebx;
                        _push(__eax);
                        __eax = caml_make_vect;
                        caml_c_call(1);
                        __esp =  &(__esp[2]);
                        __ebx = caml_make_vect;
                        _v12 = caml_make_vect;
                        while(1) {
                            __eax = caml_young_ptr;
                            __eax = caml_young_ptr - 24;
                            caml_young_ptr = __eax;
                            if(__eax >= caml_young_limit) {
                                break;
                            }
                            __eax = caml_call_gc();
                        }
                        __ecx = __eax + 4;
                         *(__ecx - 4) = 5367;
                         *__ecx = camlHashtbl__insert_bucket_1068;
                         *(__ecx + 4) = 3;
                        __eax =  *__esp;
                         *(__ecx + 8) =  *__esp;
                        __eax = _v20;
                         *(__ecx + 12) = _v20;
                         *(__ecx + 16) = __ebx;
                        __eax = 1;
                        __ebx = _v16;
                        __ebx = _v16 + -2;
                        if(1 > __ebx) {
L14:
                            __eax = _v12;
                            _push(_v12);
                            __eax = _v8;
                            __eax = _v8 + 4;
                            _push(_v8 + 4);
                            __eax = caml_modify(__ebx, __edi, __esi);
                            __esp =  &(__esp[2]);
                            __eax = 1;
                            __esp =  &(__esp[6]);
                            return 1;
                        } else {
                            _v16 = __ebx;
                            _v20 = 1;
                             *__esp = __ecx;
                            while(1) {
                                __ebx = _v4;
                                 *(__ebx - 4) =  *(__ebx - 4) >> 9;
                                if( *(__ebx - 4) >> 9 <= __eax) {
                                    break;
                                }
                                __eax =  *(__ebx + __eax * 2 - 2);
                                __ebx =  *__esp;
                                __eax = camlHashtbl__insert_bucket_1068(__eax);
                                __eax = _v20;
                                __ecx = __eax;
                                __eax = __eax + 2;
                                _v20 = __eax;
                                __ebx = _v16;
                                if(__ecx != __ebx) {
                                    continue;
                                } else {
                                    goto L14;
                                }
                                goto L100;
                            }
                            __eax = caml_ml_array_bound_error();
                            __esp = __esp - 4;
                            __edi = __eax;
                            __eax =  *(__edi + 4);
                            __esi =  *(__eax - 4);
                            __esi =  *(__eax - 4) >> 10;
                            if(__esi == 0) {
                                 &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
                            } else {
                                 *__esp = __ecx;
                                __eax = caml_hash_univ_param(21, 201, __ebx);
                                __eax = __eax >> 1;
                                __ecx = __esi;
                                asm("cdq");
                                _t39 = __eax % __ecx;
                                __eax = __eax / __ecx;
                                __edx = _t39;
                            }
                            __edx = __edx << 1;
                            __edx = __edx + 1;
                            while(1) {
                                __eax = caml_young_ptr;
                                __eax = caml_young_ptr - 16;
                                caml_young_ptr = __eax;
                                if(__eax >= caml_young_limit) {
                                    break;
                                }
                                __eax = caml_call_gc();
                            }
                            __eax = __eax + 4;
                             *(__eax - 4) = 3072;
                             *__eax = __ebx;
                            __ebx =  *__esp;
                             *(__eax + 4) =  *__esp;
                            __ecx =  *(__edi + 4);
                            __ebx =  *(__ecx - 4);
                            __ebx =  *(__ecx - 4) >> 9;
                            if(__ebx <= __edx) {
L30:
                                __eax = caml_ml_array_bound_error();
                                __esp = __esp - 8;
                                __edi = __eax;
                                __ecx = __ebx;
                                while(1) {
                                    __eax = caml_young_ptr;
                                    __eax = caml_young_ptr - 20;
                                    caml_young_ptr = __eax;
                                    if(__eax >= caml_young_limit) {
                                        break;
                                    }
                                    __eax = caml_call_gc();
                                }
                                __ebx = __eax + 4;
                                 *(__ebx - 4) = 4343;
                                 *__ebx = camlHashtbl__remove_bucket_1083;
                                 *(__ebx + 4) = 3;
                                 *(__ebx + 8) = __edi;
                                 *(__ebx + 12) = __ecx;
                                __eax =  *(__edi + 4);
                                __esi =  *(__eax - 4);
                                __esi =  *(__eax - 4) >> 10;
                                if(__esi == 0) {
                                     &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
                                } else {
                                    __eax = caml_hash_univ_param(21, 201, __ecx);
                                    __eax = __eax >> 1;
                                    __ecx = __esi;
                                    asm("cdq");
                                    _t68 = __eax % __ecx;
                                    __eax = __eax / __ecx;
                                    __edx = _t68;
                                }
                                __edx = __edx << 1;
                                __edx = __edx + 1;
                                _v32 = __edx;
                                __eax =  *(__edi + 4);
                                 *__esp = __eax;
                                __eax =  *(__eax - 4);
                                if(__eax <= __edx) {
L41:
                                    __eax = caml_ml_array_bound_error();
                                    __esp = __esp - 12;
                                    while(__ebx != 1) {
                                         *__esp = __eax;
                                        __ecx =  *(__ebx + 8);
                                        _v44 =  *(__ebx + 8);
                                        __ecx =  *(__ebx + 4);
                                        _v40 =  *(__ebx + 4);
                                        _push(__ebx);
                                        _push(__eax);
                                        __eax = caml_compare;
                                        caml_c_call();
                                        __esp =  &(__esp[2]);
                                        if(caml_compare != 1) {
                                            __eax =  *__esp;
                                            __ebx = _v44;
                                            continue;
                                        }
                                        __eax = _v40;
                                        __esp =  &(__esp[3]);
                                        return _v40;
                                        goto L100;
                                    }
                                    while(1) {
                                        __eax = caml_young_ptr;
                                        __eax = caml_young_ptr - 8;
                                        caml_young_ptr = __eax;
                                        if(__eax >= caml_young_limit) {
                                            __eax = __eax + 4;
                                             *(__eax - 4) = 1024;
                                             *__eax =  &caml_exn_Not_found;
                                            __eax = caml_raise_exn(__eax);
                                        }
                                        __eax = caml_call_gc();
                                    }
                                } else {
                                    __ecx =  *(__edi + 4);
                                     *(__ecx - 4) =  *(__ecx - 4) >> 9;
                                    if( *(__ecx - 4) >> 9 <= __edx) {
                                        __eax = caml_ml_array_bound_error();
                                        goto L41;
                                    } else {
                                        __eax =  *(__ecx + __edx * 2 - 2);
                                        _push(camlHashtbl__remove_bucket_1083( *(__ecx + __edx * 2 - 2), __ebx));
                                        __ebx = _v36;
                                        __eax = _v32;
                                        __eax = __ebx + _v32 * 2 - 2;
                                        _push(__ebx + _v32 * 2 - 2);
                                        __eax = caml_modify(__ebx, __edi, __esi);
                                        __esp =  &(__esp[2]);
                                        __eax = 1;
                                        __esp =  &(__esp[2]);
                                        return 1;
                                    }
                                }
                            } else {
                                __ebx =  *(__ecx + __edx * 2 - 2);
                                 *(__eax + 8) =  *(__ecx + __edx * 2 - 2);
                                __ecx =  *(__edi + 4);
                                __ebx =  *(__ecx - 4);
                                __ebx =  *(__ecx - 4) >> 9;
                                if(__ebx <= __edx) {
                                    __eax = caml_ml_array_bound_error();
                                    goto L30;
                                } else {
                                    _push(__eax);
                                    __eax = __ecx + __edx * 2 - 2;
                                    _push(__ecx + __edx * 2 - 2);
                                    __eax = caml_modify(__ebx, __edi, __esi);
                                    __esp =  &(__esp[2]);
                                     *__edi =  *__edi + 2;
                                    __eax =  *(__edi + 4);
                                    __eax =  *( *(__edi + 4) - 4);
                                    __eax =  *( *(__edi + 4) - 4) >> 9;
                                    __ebx = ( *( *(__edi + 4) - 4) >> 9 | 1) + ( *( *(__edi + 4) - 4) >> 9 | 1) - 1;
                                    __eax =  *__edi;
                                    if( *__edi <= __ebx) {
                                        __eax = 1;
                                        __esp =  &(__esp[1]);
                                        return 1;
                                    } else {
                                        __eax =  *134690256;
                                        __ebx = __edi;
                                        __esp =  &(__esp[1]);
                                        continue;
                                    }
                                }
                            }
                        }
                        goto L100;
                    }
                    __eax = 1;
                    __esp =  &(__esp[6]);
                    return 1;
                }
            }
        }
    }
L100:
}

signed int L080568F0(
    signed int __edx,                      // r3
    _unknown_ __edi,                       // r4
    intOrPtr _a20,                         // _cfa_14
    intOrPtr _a24,                         // _cfa_18
    signed int _a28                        // _cfa_1c
)
{
    unsigned int _v8;                      // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    unsigned int* _v32;                    // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr* _v48;                        // _cfa_ffffffd0
    intOrPtr* _v52;                        // _cfa_ffffffcc
    intOrPtr* _v56;                        // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _t137;                        // _t137
    _unknown_ _t140;                       // _t140
    intOrPtr _t142;                        // _t142
    intOrPtr _t149;                        // _t149
    intOrPtr _t151;                        // _t151
    signed int _t153;                      // _t153
    intOrPtr _t155;                        // _t155
    intOrPtr _t157;                        // _t157
    signed int _t159;                      // _t159
    intOrPtr _t161;                        // _t161
    intOrPtr _t166;                        // _t166
    intOrPtr* _t168;                       // _t168
    intOrPtr* _t169;                       // _t169
    signed int _t173;                      // _t173
    signed int _t176;                      // _t176
    signed int _t181;                      // _t181
    intOrPtr _t184;                        // _t184
    unsigned int _t186;                    // _t186
    unsigned int _t190;                    // _t190
    intOrPtr _t191;                        // _t191
    unsigned int* _t192;                   // _t192
    unsigned int _t193;                    // _t193
    intOrPtr _t194;                        // _t194
    unsigned int _t205;                    // _t205
    intOrPtr _t206;                        // _t206
    intOrPtr* _t207;                       // _t207
    unsigned int _t209;                    // _t209
    intOrPtr _t213;                        // _t213
    intOrPtr* _t215;                       // _t215
    intOrPtr* _t216;                       // _t216
    intOrPtr* _t217;                       // _t217
    intOrPtr* _t218;                       // _t218
    signed int _t224;                      // _t224
    signed int _t226;                      // _t226
    intOrPtr _t227;                        // _t227
    intOrPtr _t228;                        // _t228
    intOrPtr* _t229;                       // _t229
    intOrPtr* _t232;                       // _t232
    intOrPtr* _t233;                       // _t233
    _unknown_ _t236;                       // _t236
    signed int _t239;                      // _t239
    intOrPtr _t240;                        // _t240
    intOrPtr _t241;                        // _t241
    intOrPtr* _t242;                       // _t242

    _t224 = __edx;
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    _t184 =  *((intOrPtr*)(__edi + 4));
    _a24 = _t184;
    _t186 =  *(_t184 - 4) >> 9;
    if(_t186 <= __edx) {
        caml_ml_array_bound_error();
        caml_ml_array_bound_error();
        _t140 = caml_ml_array_bound_error();
        _t236 = _t140;
        _t205 = _t186;
        while(1) {
            _t142 = caml_young_ptr - 16;
            caml_young_ptr = _t142;
            if(_t142 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t186 = _t142 + 4;
         *(_t186 - 4) = 3319;
         *_t186 = camlHashtbl__mem_in_bucket_1125;
         *((intOrPtr*)(_t186 + 4)) = 3;
         *(_t186 + 8) = _t205;
        _t239 =  *( *((intOrPtr*)(_t236 + 4)) - 4) >> 10;
        if(_t239 == 0) {
            caml_raise_exn( &caml_bucket_Division_by_zero);
        } else {
            _t181 = caml_hash_univ_param(21, 201, _t205);
            asm("cdq");
            _t224 = (_t181 >> 1) % _t239;
        }
        _t226 = (_t224 << 1) + 1;
        _t206 =  *((intOrPtr*)(_t236 + 4));
        if( *(_t206 - 4) >> 9 <= _t226) {
            _t149 = caml_ml_array_bound_error();
            __esp = __esp - 16;
            _t227 = _t149;
            while(1) {
                _t151 = caml_young_ptr - 16;
                caml_young_ptr = _t151;
                if(_t151 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t207 = _t151 + 4;
             *((intOrPtr*)(_t207 - 4)) = 3319;
             *_t207 = camlHashtbl__do_bucket_1132;
             *((intOrPtr*)(_t207 + 4)) = 3;
             *((intOrPtr*)(_t207 + 8)) = _t227;
            _t228 =  *((intOrPtr*)(_t186 + 4));
            _t153 = 1;
            _t190 = ( *(_t228 - 4) >> 9 | 1) + -2;
            if(1 > _t190) {
L26:
                __esp = __esp + 16;
                return 1;
            } else {
                _v8 = _t190;
                _v12 = 1;
                 *__esp = _t228;
                _v16 = _t207;
                while(1) {
                    _t191 =  *__esp;
                    _t209 =  *(_t191 - 4) >> 9;
                    if(_t209 <= _t153) {
                        break;
                    }
                    camlHashtbl__do_bucket_1132( *((intOrPtr*)(_t191 + _t153 * 2 - 2)), _v16);
                    _t176 = _v12;
                    _t153 = _t176 + 2;
                    _v12 = _t153;
                    if(_t176 != _v8) {
                        continue;
                    } else {
                        goto L26;
                    }
                    goto L42;
                }
                _t155 = caml_ml_array_bound_error();
                __esp = __esp - 20;
                _t240 = _t155;
                while(1) {
                    _t157 = caml_young_ptr - 28;
                    caml_young_ptr = _t157;
                    if(_t157 >= caml_young_limit) {
                        break;
                    }
                    caml_call_gc();
                }
                _t229 = _t157 + 4;
                 *((intOrPtr*)(_t229 - 4)) = 4343;
                 *_t229 = caml_curry2;
                 *((intOrPtr*)(_t229 + 4)) = 5;
                 *((intOrPtr*)(_t229 + 8)) = camlHashtbl__do_bucket_1142;
                 *((intOrPtr*)(_t229 + 12)) = _t240;
                _t241 =  *((intOrPtr*)(_t191 + 4));
                _t192 = _t229 + 20;
                 *((intOrPtr*)(_t192 - 4)) = 1024;
                 *_t192 = _t209;
                _t159 = 1;
                _t213 = ( *(_t241 - 4) >> 9 | 1) + -2;
                if(1 > _t213) {
L35:
                    __esp = __esp + 20;
                    return  *_t192;
                } else {
                    _v24 = _t213;
                    _v28 = 1;
                    _v32 = _t192;
                     *__esp = _t241;
                    _v36 = _t229;
                    while(1) {
                        _t193 =  *_t192;
                        _t214 =  *__esp;
                        if( *( *__esp - 4) >> 9 <= _t159) {
                            break;
                        }
                        _push(camlHashtbl__do_bucket_1142( *((intOrPtr*)(_t214 + _t159 * 2 - 2)), _t193, _v36));
                        _t192 = _v32;
                        _push(_t192);
                        caml_modify(_t192, _t236, _t241);
                        __esp = __esp + 8;
                        _t173 = _v28;
                        _t159 = _t173 + 2;
                        _v28 = _t159;
                        if(_t173 != _v24) {
                            continue;
                        } else {
                            goto L35;
                        }
                        goto L42;
                    }
                    _t161 = caml_ml_array_bound_error();
                    __esp = __esp - 28;
                    _t194 = _t161;
                     *__esp = camlHashtbl;
                    _v64 =  *134690208;
                    _v60 =  *134690216;
                    while(1) {
                        _t166 = caml_young_ptr - 232;
                        caml_young_ptr = _t166;
                        if(_t166 >= caml_young_limit) {
                            break;
                        }
                        caml_call_gc();
                    }
                    _t168 = _t166 + 4;
                     *((intOrPtr*)(_t168 - 4)) = 3319;
                     *_t168 = camlHashtbl__safehash_1177;
                     *((intOrPtr*)(_t168 + 4)) = 3;
                     *((intOrPtr*)(_t168 + 8)) = _t194;
                    _t215 = _t168 + 16;
                    _v56 = _t215;
                     *((intOrPtr*)(_t215 - 4)) = 4343;
                     *_t215 = caml_curry3;
                    _t215[1] = 7;
                    _t215[2] = camlHashtbl__add_1179;
                    _t215[3] = _t168;
                    _t216 = _t168 + 36;
                    _v52 = _t216;
                     *((intOrPtr*)(_t216 - 4)) = 5367;
                     *_t216 = caml_curry2;
                    _t216[1] = 5;
                    _t216[2] = camlHashtbl__remove_1185;
                    _t216[3] = _t194;
                    _t216[4] = _t168;
                    _t232 = _t168 + 60;
                     *((intOrPtr*)(_t232 - 4)) = 4343;
                     *_t232 = caml_curry2;
                     *((intOrPtr*)(_t232 + 4)) = 5;
                     *((intOrPtr*)(_t232 + 8)) = camlHashtbl__find_rec_1193;
                     *((intOrPtr*)(_t232 + 12)) = _t194;
                    _t217 = _t168 + 80;
                    _v48 = _t217;
                     *((intOrPtr*)(_t217 - 4)) = 6391;
                     *_t217 = caml_curry2;
                    _t217[1] = 5;
                    _t217[2] = camlHashtbl__find_1198;
                    _t217[3] = _t194;
                    _t217[4] = _t168;
                    _t217[5] = _t232;
                    _t242 = _t168 + 108;
                     *((intOrPtr*)(_t242 - 4)) = 5367;
                     *_t242 = caml_curry2;
                     *((intOrPtr*)(_t242 + 4)) = 5;
                     *((intOrPtr*)(_t242 + 8)) = camlHashtbl__find_all_1210;
                     *((intOrPtr*)(_t242 + 12)) = _t194;
                     *((intOrPtr*)(_t242 + 16)) = _t168;
                    _t233 = _t168 + 132;
                     *((intOrPtr*)(_t233 - 4)) = 5367;
                     *_t233 = caml_curry3;
                     *((intOrPtr*)(_t233 + 4)) = 7;
                     *((intOrPtr*)(_t233 + 8)) = camlHashtbl__replace_1217;
                     *((intOrPtr*)(_t233 + 12)) = _t194;
                     *((intOrPtr*)(_t233 + 16)) = _t168;
                    _t218 = _t168 + 156;
                     *((intOrPtr*)(_t218 - 4)) = 5367;
                     *_t218 = caml_curry2;
                     *((intOrPtr*)(_t218 + 4)) = 5;
                     *((intOrPtr*)(_t218 + 8)) = camlHashtbl__mem_1227;
                     *((intOrPtr*)(_t218 + 12)) = _t194;
                     *((intOrPtr*)(_t218 + 16)) = _t168;
                    _v44 =  *134690240;
                    _t169 = _t168 + 180;
                     *((intOrPtr*)(_t169 - 4)) = 12288;
                     *_t169 =  *__esp;
                    _t169[1] = _v64;
                    _t169[2] = _v60;
                    _t169[3] = _v56;
                    _t169[4] = _v52;
                    _t169[5] = _v48;
                    _t169[6] = _t242;
                    _t169[7] = _t233;
                    _t169[8] = _t218;
                    _t169[9] = _v44;
                    _t169[0xa] =  *134690244;
                    _t169[0xb] =  *134690248;
                    __esp = __esp + 28;
                    return _t169;
                }
            }
        } else {
            _t137 =  *((intOrPtr*)(_t206 + _t226 * 2 - 2));
            __esp = __esp - 8;
            while(_t137 != 1) {
                _v8 = _t186;
                 *__esp =  *((intOrPtr*)(_t137 + 8));
                caml_c_call( *(_t186 + 8));
                if(caml_compare != 1) {
                    _t137 =  *__esp;
                    _t186 = _v8;
                    continue;
                } else {
                    __esp = __esp + 8;
                    return 3;
                }
                goto L42;
            }
            __esp = __esp + 8;
            return 1;
        }
    } else {
        __ebx = _a20;
        _push(__eax);
        __ebx = _a24;
        _a28 = __ebx + _a28 * 2 - 2;
        _push(__ebx + _a28 * 2 - 2);
        __eax = caml_modify(__ebx, __edi, __esi);
        __esp = __esp + 8;
        __eax = 1;
        _pop(caml_exception_pointer);
        __esp = __esp + 28;
        return 1;
    }
L42:
}

signed int camlHashtbl__mem_1122(
    signed int __eax,                      // r0
    signed int __ebx                       // r1
)
{// addr = 0x08056970
    signed int _v4;                        // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _t128;                      // _t128

    __ebx = __ebx;
    _t128 = __eax;
    __edi = __eax;
    while(1) {
        __eax = caml_young_ptr;
        __eax = caml_young_ptr - 16;
        caml_young_ptr = __eax;
        if(__eax >= caml_young_limit) {
            break;
        }
        __eax = caml_call_gc();
    }
    __ebx = __eax + 4;
     *(__ebx - 4) = 3319;
     *__ebx = camlHashtbl__mem_in_bucket_1125;
     *(__ebx + 4) = 3;
     *(__ebx + 8) = __ecx;
    __eax =  *(__edi + 4);
    __esi =  *(__eax - 4);
    __esi =  *(__eax - 4) >> 10;
    if(__esi == 0) {
         &caml_bucket_Division_by_zero = caml_raise_exn( &caml_bucket_Division_by_zero);
    } else {
        __eax = caml_hash_univ_param(21, 201, __ecx);
        __eax = __eax >> 1;
        __ecx = __esi;
        asm("cdq");
        _t12 = __eax % __ecx;
        __eax = __eax / __ecx;
        __edx = _t12;
    }
    __edx = __edx << 1;
    __edx = __edx + 1;
    __ecx =  *(__edi + 4);
     *(__ecx - 4) =  *(__ecx - 4) >> 9;
    if( *(__ecx - 4) >> 9 <= __edx) {
        __eax = caml_ml_array_bound_error();
        __esp = __esp - 16;
        __edx = __eax;
        while(1) {
            __eax = caml_young_ptr;
            __eax = caml_young_ptr - 16;
            caml_young_ptr = __eax;
            if(__eax >= caml_young_limit) {
                break;
            }
            __eax = caml_call_gc();
        }
        __ecx = __eax + 4;
         *(__ecx - 4) = 3319;
         *__ecx = camlHashtbl__do_bucket_1132;
         *(__ecx + 4) = 3;
         *(__ecx + 8) = __edx;
        __edx =  *(__ebx + 4);
        __eax = 1;
         *(__edx - 4) =  *(__edx - 4) >> 9;
        __ebx =  *(__edx - 4) >> 9 | 1;
        __ebx = ( *(__edx - 4) >> 9 | 1) + -2;
        if(1 > __ebx) {
L21:
            __eax = 1;
            __esp =  &(__esp[4]);
            return 1;
        } else {
            _v4 = __ebx;
            _v8 = 1;
             *__esp = __edx;
            _v12 = __ecx;
            while(1) {
                __ebx =  *__esp;
                 *(__ebx - 4) =  *(__ebx - 4) >> 9;
                if( *(__ebx - 4) >> 9 <= __eax) {
                    break;
                }
                __eax =  *(__ebx + __eax * 2 - 2);
                __ebx = _v12;
                __eax = camlHashtbl__do_bucket_1132(__eax, _v12);
                __eax = _v8;
                __ecx = __eax;
                __eax = __eax + 2;
                _v8 = __eax;
                __ebx = _v4;
                if(__ecx != _v4) {
                    continue;
                } else {
                    goto L21;
                }
                goto L37;
            }
            __eax = caml_ml_array_bound_error();
            __esp = __esp - 20;
            __esi = __eax;
            while(1) {
                __eax = caml_young_ptr;
                __eax = caml_young_ptr - 28;
                caml_young_ptr = __eax;
                if(__eax >= caml_young_limit) {
                    break;
                }
                __eax = caml_call_gc();
            }
            __edx = __eax + 4;
             *(__edx - 4) = 4343;
             *__edx = caml_curry2;
             *(__edx + 4) = 5;
             *((intOrPtr*)(__edx + 8)) = camlHashtbl__do_bucket_1142;
             *(__edx + 12) = __esi;
            __esi =  *(__ebx + 4);
            __ebx = __edx + 20;
             *(__ebx - 4) = 1024;
             *__ebx = __ecx;
            __eax = 1;
             *(__esi - 4) =  *(__esi - 4) >> 9;
            __ecx =  *(__esi - 4) >> 9 | 1;
            __ecx = ( *(__esi - 4) >> 9 | 1) + -2;
            if(1 > __ecx) {
L30:
                __eax =  *__ebx;
                __esp =  &(__esp[5]);
                return  *__ebx;
            } else {
                _v20 = __ecx;
                _v24 = 1;
                _v28 = __ebx;
                 *__esp = __esi;
                _v32 = __edx;
                while(1) {
                    __ebx =  *__ebx;
                    __ecx =  *__esp;
                     *(__ecx - 4) =  *(__ecx - 4) >> 9;
                    if( *(__ecx - 4) >> 9 <= __eax) {
                        break;
                    }
                    __eax =  *(__ecx + __eax * 2 - 2);
                    __ecx = _v32;
                    _push(__eax);
                    __ebx = _v28;
                    _push(__ebx);
                    __eax = caml_modify(__ebx, __edi, __esi);
                    __esp =  &(__esp[2]);
                    __eax = _v24;
                    __edx = __eax;
                    __eax = __eax + 2;
                    _v24 = __eax;
                    __ecx = _v20;
                    if(__edx != _v20) {
                        continue;
                    } else {
                        goto L30;
                    }
                    goto L37;
                }
                __eax = caml_ml_array_bound_error();
                __esp = __esp - 28;
                __ebx = __eax;
                __eax = camlHashtbl;
                 *__esp = camlHashtbl;
                __eax =  *134690208;
                _v60 =  *134690208;
                __eax =  *134690216;
                _v56 =  *134690216;
                while(1) {
                    __eax = caml_young_ptr;
                    __eax = caml_young_ptr - 232;
                    caml_young_ptr = __eax;
                    if(__eax >= caml_young_limit) {
                        break;
                    }
                    __eax = caml_call_gc();
                }
                __eax = __eax + 4;
                 *(__eax - 4) = 3319;
                 *__eax = camlHashtbl__safehash_1177;
                 *(__eax + 4) = 3;
                 *(__eax + 8) = __ebx;
                __ecx = __eax + 16;
                _v52 = __ecx;
                 *(__ecx - 4) = 4343;
                 *__ecx = caml_curry3;
                 *(__ecx + 4) = 7;
                 *(__ecx + 8) = camlHashtbl__add_1179;
                 *(__ecx + 12) = __eax;
                __ecx = __eax + 36;
                _v48 = __ecx;
                 *(__ecx - 4) = 5367;
                 *__ecx = caml_curry2;
                 *(__ecx + 4) = 5;
                 *(__ecx + 8) = camlHashtbl__remove_1185;
                 *(__ecx + 12) = __ebx;
                 *(__ecx + 16) = __eax;
                __edx = __eax + 60;
                 *(__edx - 4) = 4343;
                 *__edx = caml_curry2;
                 *(__edx + 4) = 5;
                 *((intOrPtr*)(__edx + 8)) = camlHashtbl__find_rec_1193;
                 *(__edx + 12) = __ebx;
                __ecx = __eax + 80;
                _v44 = __ecx;
                 *(__ecx - 4) = 6391;
                 *__ecx = caml_curry2;
                 *(__ecx + 4) = 5;
                 *(__ecx + 8) = camlHashtbl__find_1198;
                 *(__ecx + 12) = __ebx;
                 *(__ecx + 16) = __eax;
                 *(__ecx + 20) = __edx;
                __esi = __eax + 108;
                 *(__esi - 4) = 5367;
                 *__esi = caml_curry2;
                 *(__esi + 4) = 5;
                 *((intOrPtr*)(__esi + 8)) = camlHashtbl__find_all_1210;
                 *(__esi + 12) = __ebx;
                 *(__esi + 16) = __eax;
                __edx = __eax + 132;
                 *(__edx - 4) = 5367;
                 *__edx = caml_curry3;
                 *(__edx + 4) = 7;
                 *((intOrPtr*)(__edx + 8)) = camlHashtbl__replace_1217;
                 *(__edx + 12) = __ebx;
                 *(__edx + 16) = __eax;
                __ecx = __eax + 156;
                 *(__ecx - 4) = 5367;
                 *__ecx = caml_curry2;
                 *(__ecx + 4) = 5;
                 *(__ecx + 8) = camlHashtbl__mem_1227;
                 *(__ecx + 12) = __ebx;
                 *(__ecx + 16) = __eax;
                __ebx =  *134690240;
                _v40 =  *134690240;
                __edi =  *134690248;
                __eax = __eax + 180;
                 *(__eax - 4) = 12288;
                __ebx =  *__esp;
                 *__eax =  *__esp;
                __ebx = _v60;
                 *(__eax + 4) = _v60;
                __ebx = _v56;
                 *(__eax + 8) = _v56;
                __ebx = _v52;
                 *(__eax + 12) = _v52;
                __ebx = _v48;
                 *(__eax + 16) = _v48;
                __ebx = _v44;
                 *(__eax + 20) = _v44;
                 *(__eax + 24) = __esi;
                 *(__eax + 28) = __edx;
                 *(__eax + 32) = __ecx;
                __ebx = _v40;
                 *(__eax + 36) = _v40;
                 *((intOrPtr*)(__eax + 40)) =  *134690244;
                 *((intOrPtr*)(__eax + 44)) =  *134690248;
                __esp =  &(__esp[7]);
                return __eax;
            }
        }
    } else {
        __eax =  *(__ecx + __edx * 2 - 2);
        __esp = __esp - 8;
        while(_t128 != 1) {
            _v4 = __ebx;
             *__esp =  *(_t128 + 8);
            caml_c_call( *(__ebx + 8));
            if(caml_compare != 1) {
                _t128 =  *__esp;
                __ebx = _v4;
                continue;
            } else {
                __esp =  &(__esp[2]);
                return 3;
            }
            goto L37;
        }
        __esp =  &(__esp[2]);
        return 1;
    }
L37:
}

signed int camlHashtbl__iter_1129(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx                        // r1
)
{// addr = 0x08056A10
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    unsigned int* _v28;                    // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr* _v44;                        // _cfa_ffffffd4
    intOrPtr* _v48;                        // _cfa_ffffffd0
    intOrPtr* _v52;                        // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _t111;                        // _t111
    signed int _t113;                      // _t113
    intOrPtr _t115;                        // _t115
    intOrPtr _t117;                        // _t117
    signed int _t119;                      // _t119
    intOrPtr _t121;                        // _t121
    intOrPtr _t126;                        // _t126
    intOrPtr* _t128;                       // _t128
    intOrPtr* _t129;                       // _t129
    signed int _t133;                      // _t133
    signed int _t136;                      // _t136
    intOrPtr _t141;                        // _t141
    intOrPtr _t142;                        // _t142
    unsigned int* _t143;                   // _t143
    unsigned int _t144;                    // _t144
    intOrPtr _t145;                        // _t145
    intOrPtr* _t156;                       // _t156
    unsigned int _t158;                    // _t158
    intOrPtr _t162;                        // _t162
    intOrPtr* _t164;                       // _t164
    intOrPtr* _t165;                       // _t165
    intOrPtr* _t166;                       // _t166
    intOrPtr* _t167;                       // _t167
    intOrPtr _t172;                        // _t172
    intOrPtr* _t173;                       // _t173
    intOrPtr* _t176;                       // _t176
    intOrPtr* _t177;                       // _t177
    _unknown_ _t179;                       // _t179
    intOrPtr _t181;                        // _t181
    intOrPtr _t182;                        // _t182
    intOrPtr* _t183;                       // _t183

    __esp = __esp - 16;
    while(1) {
        _t111 = caml_young_ptr - 16;
        caml_young_ptr = _t111;
        if(_t111 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t156 = _t111 + 4;
     *((intOrPtr*)(_t156 - 4)) = 3319;
     *_t156 = camlHashtbl__do_bucket_1132;
     *((intOrPtr*)(_t156 + 4)) = 3;
     *((intOrPtr*)(_t156 + 8)) = __eax;
    _t172 =  *((intOrPtr*)(__ebx + 4));
    _t113 = 1;
    _t141 = ( *(_t172 - 4) >> 9 | 1) + -2;
    if(1 > _t141) {
L6:
        __esp = __esp + 16;
        return 1;
    } else {
        _v4 = _t141;
        _v8 = 1;
         *__esp = _t172;
        _v12 = _t156;
        while(1) {
            _t142 =  *__esp;
            _t158 =  *(_t142 - 4) >> 9;
            if(_t158 <= _t113) {
                break;
            }
            camlHashtbl__do_bucket_1132( *((intOrPtr*)(_t142 + _t113 * 2 - 2)), _v12);
            _t136 = _v8;
            _t113 = _t136 + 2;
            _v8 = _t113;
            if(_t136 != _v4) {
                continue;
            } else {
                goto L6;
            }
            goto L22;
        }
        _t115 = caml_ml_array_bound_error();
        __esp = __esp - 20;
        _t181 = _t115;
        while(1) {
            _t117 = caml_young_ptr - 28;
            caml_young_ptr = _t117;
            if(_t117 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t173 = _t117 + 4;
         *((intOrPtr*)(_t173 - 4)) = 4343;
         *_t173 = caml_curry2;
         *((intOrPtr*)(_t173 + 4)) = 5;
         *((intOrPtr*)(_t173 + 8)) = camlHashtbl__do_bucket_1142;
         *((intOrPtr*)(_t173 + 12)) = _t181;
        _t182 =  *((intOrPtr*)(_t142 + 4));
        _t143 = _t173 + 20;
         *((intOrPtr*)(_t143 - 4)) = 1024;
         *_t143 = _t158;
        _t119 = 1;
        _t162 = ( *(_t182 - 4) >> 9 | 1) + -2;
        if(1 > _t162) {
L15:
            __esp = __esp + 20;
            return  *_t143;
        } else {
            _v20 = _t162;
            _v24 = 1;
            _v28 = _t143;
             *__esp = _t182;
            _v32 = _t173;
            while(1) {
                _t144 =  *_t143;
                _t163 =  *__esp;
                if( *( *__esp - 4) >> 9 <= _t119) {
                    break;
                }
                _push(camlHashtbl__do_bucket_1142( *((intOrPtr*)(_t163 + _t119 * 2 - 2)), _t144, _v32));
                _t143 = _v28;
                _push(_t143);
                caml_modify(_t143, _t179, _t182);
                __esp = __esp + 8;
                _t133 = _v24;
                _t119 = _t133 + 2;
                _v24 = _t119;
                if(_t133 != _v20) {
                    continue;
                } else {
                    goto L15;
                }
                goto L22;
            }
            _t121 = caml_ml_array_bound_error();
            __esp = __esp - 28;
            _t145 = _t121;
             *__esp = camlHashtbl;
            _v60 =  *134690208;
            _v56 =  *134690216;
            while(1) {
                _t126 = caml_young_ptr - 232;
                caml_young_ptr = _t126;
                if(_t126 >= caml_young_limit) {
                    break;
                }
                caml_call_gc();
            }
            _t128 = _t126 + 4;
             *((intOrPtr*)(_t128 - 4)) = 3319;
             *_t128 = camlHashtbl__safehash_1177;
             *((intOrPtr*)(_t128 + 4)) = 3;
             *((intOrPtr*)(_t128 + 8)) = _t145;
            _t164 = _t128 + 16;
            _v52 = _t164;
             *((intOrPtr*)(_t164 - 4)) = 4343;
             *_t164 = caml_curry3;
            _t164[1] = 7;
            _t164[2] = camlHashtbl__add_1179;
            _t164[3] = _t128;
            _t165 = _t128 + 36;
            _v48 = _t165;
             *((intOrPtr*)(_t165 - 4)) = 5367;
             *_t165 = caml_curry2;
            _t165[1] = 5;
            _t165[2] = camlHashtbl__remove_1185;
            _t165[3] = _t145;
            _t165[4] = _t128;
            _t176 = _t128 + 60;
             *((intOrPtr*)(_t176 - 4)) = 4343;
             *_t176 = caml_curry2;
             *((intOrPtr*)(_t176 + 4)) = 5;
             *((intOrPtr*)(_t176 + 8)) = camlHashtbl__find_rec_1193;
             *((intOrPtr*)(_t176 + 12)) = _t145;
            _t166 = _t128 + 80;
            _v44 = _t166;
             *((intOrPtr*)(_t166 - 4)) = 6391;
             *_t166 = caml_curry2;
            _t166[1] = 5;
            _t166[2] = camlHashtbl__find_1198;
            _t166[3] = _t145;
            _t166[4] = _t128;
            _t166[5] = _t176;
            _t183 = _t128 + 108;
             *((intOrPtr*)(_t183 - 4)) = 5367;
             *_t183 = caml_curry2;
             *((intOrPtr*)(_t183 + 4)) = 5;
             *((intOrPtr*)(_t183 + 8)) = camlHashtbl__find_all_1210;
             *((intOrPtr*)(_t183 + 12)) = _t145;
             *((intOrPtr*)(_t183 + 16)) = _t128;
            _t177 = _t128 + 132;
             *((intOrPtr*)(_t177 - 4)) = 5367;
             *_t177 = caml_curry3;
             *((intOrPtr*)(_t177 + 4)) = 7;
             *((intOrPtr*)(_t177 + 8)) = camlHashtbl__replace_1217;
             *((intOrPtr*)(_t177 + 12)) = _t145;
             *((intOrPtr*)(_t177 + 16)) = _t128;
            _t167 = _t128 + 156;
             *((intOrPtr*)(_t167 - 4)) = 5367;
             *_t167 = caml_curry2;
             *((intOrPtr*)(_t167 + 4)) = 5;
             *((intOrPtr*)(_t167 + 8)) = camlHashtbl__mem_1227;
             *((intOrPtr*)(_t167 + 12)) = _t145;
             *((intOrPtr*)(_t167 + 16)) = _t128;
            _v40 =  *134690240;
            _t129 = _t128 + 180;
             *((intOrPtr*)(_t129 - 4)) = 12288;
             *_t129 =  *__esp;
            _t129[1] = _v60;
            _t129[2] = _v56;
            _t129[3] = _v52;
            _t129[4] = _v48;
            _t129[5] = _v44;
            _t129[6] = _t183;
            _t129[7] = _t177;
            _t129[8] = _t167;
            _t129[9] = _v40;
            _t129[0xa] =  *134690244;
            _t129[0xb] =  *134690248;
            __esp = __esp + 28;
            return _t129;
        }
    }
L22:
}

camlHashtbl__fold_1138(
    intOrPtr __eax,                        // r0
    _unknown_ __ebx,                       // r1
    intOrPtr __ecx                         // r2
)
{// addr = 0x08056AC0
    intOrPtr _v4;                          // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* _v28;                        // _cfa_ffffffe4
    intOrPtr* _v32;                        // _cfa_ffffffe0
    intOrPtr* _v36;                        // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _t94;                         // _t94
    signed int _t96;                       // _t96
    intOrPtr _t98;                         // _t98
    intOrPtr _t103;                        // _t103
    intOrPtr* _t105;                       // _t105
    intOrPtr* _t106;                       // _t106
    signed int _t110;                      // _t110
    intOrPtr* _t112;                       // _t112
    intOrPtr _t113;                        // _t113
    intOrPtr _t114;                        // _t114
    intOrPtr _t127;                        // _t127
    intOrPtr* _t129;                       // _t129
    intOrPtr* _t130;                       // _t130
    intOrPtr* _t131;                       // _t131
    intOrPtr* _t132;                       // _t132
    intOrPtr* _t135;                       // _t135
    intOrPtr* _t138;                       // _t138
    intOrPtr* _t139;                       // _t139
    _unknown_ _t141;                       // _t141
    intOrPtr _t144;                        // _t144
    intOrPtr* _t145;                       // _t145

    __esp = __esp - 20;
    while(1) {
        _t94 = caml_young_ptr - 28;
        caml_young_ptr = _t94;
        if(_t94 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t135 = _t94 + 4;
     *((intOrPtr*)(_t135 - 4)) = 4343;
     *_t135 = caml_curry2;
     *((intOrPtr*)(_t135 + 4)) = 5;
     *((intOrPtr*)(_t135 + 8)) = camlHashtbl__do_bucket_1142;
     *((intOrPtr*)(_t135 + 12)) = __eax;
    _t144 =  *((intOrPtr*)(__ebx + 4));
    _t112 = _t135 + 20;
     *((intOrPtr*)(_t112 - 4)) = 1024;
     *_t112 = __ecx;
    _t96 = 1;
    _t127 = ( *(_t144 - 4) >> 9 | 1) + -2;
    if(1 > _t127) {
L6:
        __esp = __esp + 20;
        return  *_t112;
    } else {
        _v4 = _t127;
        _v8 = 1;
        _v12 = _t112;
         *__esp = _t144;
        _v16 = _t135;
        while(1) {
            _t113 =  *_t112;
            _t128 =  *__esp;
            if( *( *__esp - 4) >> 9 <= _t96) {
                break;
            }
            _push(camlHashtbl__do_bucket_1142( *((intOrPtr*)(_t128 + _t96 * 2 - 2)), _t113, _v16));
            _t112 = _v12;
            _push(_t112);
            caml_modify(_t112, _t141, _t144);
            __esp = __esp + 8;
            _t110 = _v8;
            _t96 = _t110 + 2;
            _v8 = _t96;
            if(_t110 != _v4) {
                continue;
            } else {
                goto L6;
            }
            goto L13;
        }
        _t98 = caml_ml_array_bound_error();
        __esp = __esp - 28;
        _t114 = _t98;
         *__esp = camlHashtbl;
        _v44 =  *134690208;
        _v40 =  *134690216;
        while(1) {
            _t103 = caml_young_ptr - 232;
            caml_young_ptr = _t103;
            if(_t103 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t105 = _t103 + 4;
         *((intOrPtr*)(_t105 - 4)) = 3319;
         *_t105 = camlHashtbl__safehash_1177;
         *((intOrPtr*)(_t105 + 4)) = 3;
         *((intOrPtr*)(_t105 + 8)) = _t114;
        _t129 = _t105 + 16;
        _v36 = _t129;
         *((intOrPtr*)(_t129 - 4)) = 4343;
         *_t129 = caml_curry3;
        _t129[1] = 7;
        _t129[2] = camlHashtbl__add_1179;
        _t129[3] = _t105;
        _t130 = _t105 + 36;
        _v32 = _t130;
         *((intOrPtr*)(_t130 - 4)) = 5367;
         *_t130 = caml_curry2;
        _t130[1] = 5;
        _t130[2] = camlHashtbl__remove_1185;
        _t130[3] = _t114;
        _t130[4] = _t105;
        _t138 = _t105 + 60;
         *((intOrPtr*)(_t138 - 4)) = 4343;
         *_t138 = caml_curry2;
         *((intOrPtr*)(_t138 + 4)) = 5;
         *((intOrPtr*)(_t138 + 8)) = camlHashtbl__find_rec_1193;
         *((intOrPtr*)(_t138 + 12)) = _t114;
        _t131 = _t105 + 80;
        _v28 = _t131;
         *((intOrPtr*)(_t131 - 4)) = 6391;
         *_t131 = caml_curry2;
        _t131[1] = 5;
        _t131[2] = camlHashtbl__find_1198;
        _t131[3] = _t114;
        _t131[4] = _t105;
        _t131[5] = _t138;
        _t145 = _t105 + 108;
         *((intOrPtr*)(_t145 - 4)) = 5367;
         *_t145 = caml_curry2;
         *((intOrPtr*)(_t145 + 4)) = 5;
         *((intOrPtr*)(_t145 + 8)) = camlHashtbl__find_all_1210;
         *((intOrPtr*)(_t145 + 12)) = _t114;
         *((intOrPtr*)(_t145 + 16)) = _t105;
        _t139 = _t105 + 132;
         *((intOrPtr*)(_t139 - 4)) = 5367;
         *_t139 = caml_curry3;
         *((intOrPtr*)(_t139 + 4)) = 7;
         *((intOrPtr*)(_t139 + 8)) = camlHashtbl__replace_1217;
         *((intOrPtr*)(_t139 + 12)) = _t114;
         *((intOrPtr*)(_t139 + 16)) = _t105;
        _t132 = _t105 + 156;
         *((intOrPtr*)(_t132 - 4)) = 5367;
         *_t132 = caml_curry2;
         *((intOrPtr*)(_t132 + 4)) = 5;
         *((intOrPtr*)(_t132 + 8)) = camlHashtbl__mem_1227;
         *((intOrPtr*)(_t132 + 12)) = _t114;
         *((intOrPtr*)(_t132 + 16)) = _t105;
        _v24 =  *134690240;
        _t106 = _t105 + 180;
         *((intOrPtr*)(_t106 - 4)) = 12288;
         *_t106 =  *__esp;
        _t106[1] = _v44;
        _t106[2] = _v40;
        _t106[3] = _v36;
        _t106[4] = _v32;
        _t106[5] = _v28;
        _t106[6] = _t145;
        _t106[7] = _t139;
        _t106[8] = _t132;
        _t106[9] = _v24;
        _t106[0xa] =  *134690244;
        _t106[0xb] =  *134690248;
        __esp = __esp + 28;
        return _t106;
    }
L13:
}

camlHashtbl__Make_1251(
    intOrPtr __eax                         // r0
)
{// addr = 0x08056B90
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr* _v8;                         // _cfa_fffffff8
    intOrPtr* _v12;                        // _cfa_fffffff4
    intOrPtr* _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t75;                         // _t75
    intOrPtr* _t77;                        // _t77
    intOrPtr* _t78;                        // _t78
    intOrPtr* _t88;                        // _t88
    intOrPtr* _t89;                        // _t89
    intOrPtr* _t90;                        // _t90
    intOrPtr* _t91;                        // _t91
    intOrPtr* _t92;                        // _t92
    intOrPtr* _t93;                        // _t93

     *__esp = camlHashtbl;
    _v24 =  *134690208;
    _v20 =  *134690216;
    while(1) {
        _t75 = caml_young_ptr - 232;
        caml_young_ptr = _t75;
        if(_t75 >= caml_young_limit) {
            break;
        }
        caml_call_gc();
    }
    _t77 = _t75 + 4;
     *((intOrPtr*)(_t77 - 4)) = 3319;
     *_t77 = camlHashtbl__safehash_1177;
     *((intOrPtr*)(_t77 + 4)) = 3;
     *((intOrPtr*)(_t77 + 8)) = __eax;
    _t88 = _t77 + 16;
    _v16 = _t88;
     *((intOrPtr*)(_t88 - 4)) = 4343;
     *_t88 = caml_curry3;
    _t88[1] = 7;
    _t88[2] = camlHashtbl__add_1179;
    _t88[3] = _t77;
    _t89 = _t77 + 36;
    _v12 = _t89;
     *((intOrPtr*)(_t89 - 4)) = 5367;
     *_t89 = caml_curry2;
    _t89[1] = 5;
    _t89[2] = camlHashtbl__remove_1185;
    _t89[3] = __eax;
    _t89[4] = _t77;
    _t92 = _t77 + 60;
     *((intOrPtr*)(_t92 - 4)) = 4343;
     *_t92 = caml_curry2;
     *((intOrPtr*)(_t92 + 4)) = 5;
     *((intOrPtr*)(_t92 + 8)) = camlHashtbl__find_rec_1193;
     *((intOrPtr*)(_t92 + 12)) = __eax;
    _t90 = _t77 + 80;
    _v8 = _t90;
     *((intOrPtr*)(_t90 - 4)) = 6391;
     *_t90 = caml_curry2;
    _t90[1] = 5;
    _t90[2] = camlHashtbl__find_1198;
    _t90[3] = __eax;
    _t90[4] = _t77;
    _t90[5] = _t92;
    __esi = _t77 + 108;
     *((intOrPtr*)(__esi - 4)) = 5367;
     *__esi = caml_curry2;
     *((intOrPtr*)(__esi + 4)) = 5;
     *((intOrPtr*)(__esi + 8)) = camlHashtbl__find_all_1210;
     *((intOrPtr*)(__esi + 12)) = __eax;
     *((intOrPtr*)(__esi + 16)) = _t77;
    _t93 = _t77 + 132;
     *((intOrPtr*)(_t93 - 4)) = 5367;
     *_t93 = caml_curry3;
     *((intOrPtr*)(_t93 + 4)) = 7;
     *((intOrPtr*)(_t93 + 8)) = camlHashtbl__replace_1217;
     *((intOrPtr*)(_t93 + 12)) = __eax;
     *((intOrPtr*)(_t93 + 16)) = _t77;
    _t91 = _t77 + 156;
     *((intOrPtr*)(_t91 - 4)) = 5367;
     *_t91 = caml_curry2;
     *((intOrPtr*)(_t91 + 4)) = 5;
     *((intOrPtr*)(_t91 + 8)) = camlHashtbl__mem_1227;
     *((intOrPtr*)(_t91 + 12)) = __eax;
     *((intOrPtr*)(_t91 + 16)) = _t77;
    _v4 =  *134690240;
    _t78 = _t77 + 180;
     *((intOrPtr*)(_t78 - 4)) = 12288;
     *_t78 =  *__esp;
    _t78[1] = _v24;
    _t78[2] = _v20;
    _t78[3] = _v16;
    _t78[4] = _v12;
    _t78[5] = _v8;
    _t78[6] = __esi;
    _t78[7] = _t93;
    _t78[8] = _t91;
    _t78[9] = _v4;
    _t78[0xa] =  *134690244;
    _t78[0xb] =  *134690248;
    return _t78;
}

camlHashtbl__entry()
{// addr = 0x08056D60
     *134690256 =  &camlHashtbl__16;
    camlHashtbl =  &camlHashtbl__15;
     *134690208 =  &camlHashtbl__14;
     *134690216 =  &camlHashtbl__13;
     *134690248 =  &camlHashtbl__12;
     *134690260 =  &camlHashtbl__11;
     *134690212 =  &camlHashtbl__10;
     *134690232 =  &camlHashtbl__9;
     *134690264 =  &camlHashtbl__8;
     *134690220 =  &camlHashtbl__7;
     *134690224 =  &camlHashtbl__6;
     *134690236 =  &camlHashtbl__5;
     *134690228 =  &camlHashtbl__4;
     *134690240 =  &camlHashtbl__3;
     *134690244 =  &camlHashtbl__2;
     *134690252 =  &camlHashtbl__1;
    return 1;
}

camlCallback__register_exception_1034(
    _unknown_ __eax                        // r0
)
{// addr = 0x08056E20
    intOrPtr _t7;                          // _t7
    long long* _t9;                        // _t9

    if(( *(__ebx - 4) & 255) == 254) {
        while(1) {
            _t7 = caml_young_ptr - 12;
            caml_young_ptr = _t7;
            if(_t7 >= caml_young_limit) {
                break;
            }
            caml_call_gc();
        }
        _t9 = _t7 + 4;
         *((intOrPtr*)(_t9 - 4)) = 2301;
         *_t9 =  *__ebx;
    } else {
        _t9 =  *__ebx;
    }
    caml_c_call(_t9);
    return caml_register_named_value;
}

camlCallback__entry()
{// addr = 0x08056E80
    camlCallback =  &camlCallback__2;
     *134692736 =  &camlCallback__1;
    return 1;
}

unix_accept(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08056E9C
    char _v32;                             // _cfa_ffffffe0
    char _v144;                            // _cfa_ffffff70
    char _v148;                            // _cfa_ffffff6c
    char* _v168;                           // _cfa_ffffff58
    intOrPtr _v172;                        // _cfa_ffffff54
    intOrPtr _v176;                        // _cfa_ffffff50
    char _v180;                            // _cfa_ffffff4c
    char* _v196;                           // _cfa_ffffff3c (outparam)
    char* _v200;                           // _cfa_ffffff38 (outparam)
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t27;                        // _t27
    signed int _t33;                       // _t33
    intOrPtr* _t41;                        // _t41
    _unknown_ _t44;                        // _t44
    _unknown_ _t45;                        // _t45
    _unknown_ _t49;                        // _t49
    intOrPtr* _t50;                        // _t50

    __i686.get_pc_thunk.bx(_t27);
    _t45 = _t44 + 92919;
    _v148 = 112;
    caml_enter_blocking_section();
    _v196 =  &_v148;
    _v200 =  &_v144;
    _t33 = _a4 >> 1;
     *__esp = _t33;
    accept();
    __edi = _t33;
    caml_leave_blocking_section();
    if(__edi == -1) {
        _v200 = 0;
        uerror(_t45, _t49, _t45 - 9752);
    }
    _v32 = alloc_sockaddr(_t45, __edi, _t49,  &_v144, _v148, __edi);
    _t50 =  *((intOrPtr*)(_t45 - 24));
    _v180 =  *_t50;
     *_t50 =  &_v180;
    _v172 = 1;
    _v176 = 1;
    _v168 =  &_v32;
    _t41 = caml_alloc_small(_t45, _t50, 2, 0);
     *_t41 = __edi + __edi + 1;
    _t41[1] = _v32;
     *_t50 = _v180;
    return _t41;
}

__i686.get_pc_thunk.bx(
    _unknown_ __eax                        // r0
)
{// addr = 0x08056F8A
    __eax = __eax;
    return __eax;
}

unix_access(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08056F90
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8 (outparam)
    _unknown_ _t12;                        // _t12
    intOrPtr _t16;                         // _t16
    intOrPtr _t24;                         // _t24

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t12);
    _t21 = __ebx + 92675;
    _t24 = _a4;
    _t16 = caml_convert_flag_list(_a8, __ebx + 0x1d047);
    _v24 = _t16;
     *__esp = _t24;
    access();
    if(_t16 == -1) {
        _v24 = _t24;
        uerror(_t21, _t24, _t21 - 9745);
    }
    return 1;
}

intOrPtr unix_inet_addr_of_string(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08056FF4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v16;                             // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ _t15;                        // _t15
    _unknown_ _t20;                        // _t20
    _unknown_ _t24;                        // _t24
    intOrPtr _t27;                         // _t27

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t15);
    _t24 = __ebx + 92575;
    _t27 = _a4;
    _v52 =  &_v16;
    _v56 = _t27;
     *__esp = 2;
    inet_pton();
    if( &_v16 <= 0) {
        _v52 =  &_v32;
        _v56 = _t27;
         *__esp = 10;
        inet_pton();
        if( &_v32 <= 0) {
             *__esp = _t24 - 9738;
            _t20 = caml_failwith();
        } else {
            _t20 = alloc_inet6_addr(_t24, _t27,  &_v32);
        }
    } else {
        _t20 = alloc_inet_addr( &_v16);
    }
    return _t20;
}

unix_alarm(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08057078
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    signed int _t7;                        // _t7
    _unknown_ _t9;                         // _t9

    __i686.get_pc_thunk.bx(_t4);
    _t7 = _a4 >> 1;
     *__esp = _t7;
    alarm();
    return _t7 + _t7 + 1;
}

unix_bind(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080570A4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v124;                            // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    intOrPtr _v148;                        // _cfa_ffffff6c (outparam)
    char* _v152;                           // _cfa_ffffff68 (outparam)
    _unknown_ _t16;                        // _t16
    signed int _t23;                       // _t23

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t16);
    _t28 = __ebx + 92396;
    get_sockaddr(__ebx + 92396, __edi,  &_v124, _a8,  &_v124,  &_v128);
    _v148 = _v128;
    _v152 =  &_v124;
    _t23 = _a4 >> 1;
     *__esp = _t23;
    bind();
    if(_t23 == -1) {
        _v152 = 0;
        uerror(_t28,  &_v124, _t28 - 9718);
    }
    return 1;
}

unix_chdir(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805711C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t14;                        // _t14
    intOrPtr _t17;                         // _t17

    _v12 = __ebx;
    _v8 = __esi;
    _t9 = __i686.get_pc_thunk.bx(_t8);
    _t14 = __ebx + 92279;
    _t17 = _a4;
     *__esp = _t17;
    chdir();
    if(_t9 == -1) {
        _v24 = _t17;
        uerror(_t14, _t17, _t14 - 9713);
    }
    return 1;
}

unix_chmod(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08057164
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t10;                        // _t10
    signed int _t13;                       // _t13
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t10);
    _t18 = __ebx + 92207;
    _t21 = _a4;
    _t13 = _a8 >> 1;
    _v24 = _t13;
     *__esp = _t21;
    chmod();
    if(_t13 == -1) {
        _v24 = _t21;
        uerror(_t18, _t21, _t18 - 9647);
    }
    return 1;
}

unix_chown(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080571B8
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t12;                        // _t12
    signed int _t17;                       // _t17
    _unknown_ _t22;                        // _t22
    signed int _t25;                       // _t25

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t12);
    _t22 = __ebx + 92123;
    _t25 = _a4;
    _v20 = _a12 >> 1;
    _t17 = _a8 >> 1;
    _v24 = _t17;
     *__esp = _t25;
    chown();
    if(_t17 == -1) {
        _v24 = _t25;
        uerror(_t22, _t25, _t22 - 9640);
    }
    return 1;
}

unix_chroot(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08057214
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t14;                        // _t14
    intOrPtr _t17;                         // _t17

    _v12 = __ebx;
    _v8 = __esi;
    _t9 = __i686.get_pc_thunk.bx(_t8);
    _t14 = __ebx + 92031;
    _t17 = _a4;
     *__esp = _t17;
    chroot();
    if(_t9 == -1) {
        _v24 = _t17;
        uerror(_t14, _t17, _t14 - 9707);
    }
    return 1;
}

unix_close(
    _unknown_ __esi,                       // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805725C
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    signed int _t7;                        // _t7
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t4);
    _t12 = _t11 + 91964;
    _t7 = _a4 >> 1;
     *__esp = _t7;
    close();
    if(_t7 == -1) {
        _v24 = 0;
        uerror(_t12, __esi, _t12 - 9700);
    }
    return 1;
}

unix_closedir(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080572A4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t9;                         // _t9
    intOrPtr _t11;                         // _t11
    _unknown_ _t15;                        // _t15
    intOrPtr* _t18;                        // _t18

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t9);
    _t15 = __ebx + 91887;
    _t18 = _a4;
    _t11 =  *_t18;
    if(_t11 == 0) {
        _v20 = 0;
        _v24 = _t15 - 9694;
        _t11 = unix_error(_t15, _t18, 9);
    }
     *__esp = _t11;
    closedir();
     *_t18 = 0;
    return 1;
}

unix_connect(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08057300
    char _v124;                            // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    intOrPtr _v148;                        // _cfa_ffffff6c (outparam)
    char* _v152;                           // _cfa_ffffff68 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t12;                        // _t12
    signed int _t20;                       // _t20
    _unknown_ _t25;                        // _t25

    __i686.get_pc_thunk.bx(_t12);
    _t26 = _t25 + 91796;
    get_sockaddr(_t25 + 91796, __edi,  &_v124, _a8,  &_v124,  &_v128);
    caml_enter_blocking_section();
    _v148 = _v128;
    _v152 =  &_v124;
    _t20 = _a4 >> 1;
     *__esp = _t20;
    connect();
    _t28 = _t20;
    caml_leave_blocking_section();
    if(_t20 == -1) {
        _v152 = 0;
        uerror(_t26, _t20, _t26 - 9685);
    }
    return 1;
}

intOrPtr unix_dup(
    _unknown_ __esi,                       // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x08057380
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    signed int _t9;                        // _t9
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t6);
    _t13 = _t12 + 91672;
    _t9 = _a4 >> 1;
     *__esp = _t9;
    dup();
    if(_t9 == -1) {
        _v24 = 0;
        _t9 = uerror(_t13, __esi, _t13 - 9677);
    }
    return _t9 + _t9 + 1;
}

unix_dup2(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080573C4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    signed int _t11;                       // _t11
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t6);
    _t16 = _t15 + 91604;
    _v24 = _a8 >> 1;
    _t11 = _a4 >> 1;
     *__esp = _t11;
    dup2();
    if(_t11 == -1) {
        _v24 = 0;
        uerror(_t16, __esi, _t16 - 9673);
    }
    return 1;
}

unix_environment()
{// addr = 0x08057414
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx(_t2);
    return caml_copy_string_array( *((intOrPtr*)( *((intOrPtr*)(_t7 + 91524 - 20)))));
}

unix_error_message(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805743C
    _unknown_ __ebx;                       // r1
    _unknown_ _t7;                         // _t7
    signed int _t9;                        // _t9
    signed int _t11;                       // _t11
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15

    __i686.get_pc_thunk.bx(_t7);
    _t15 = _t14 + 91484;
    _t9 = _a4;
    if((_t9 & 1) != 0) {
        _t11 =  *( *((intOrPtr*)(_t15 - 8)) + (_t9 >> 1) * 4);
    } else {
        _t11 =  *_t9 >> 1;
    }
     *__esp = _t11;
    strerror();
    return caml_copy_string(_t15, __edi, __esi, _t11);
}

unix_execv(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805747C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    intOrPtr _v96;                         // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v140;                        // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    signed int _v156;                      // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    intOrPtr _v164;                        // _cfa_ffffff5c
    signed int _v184;                      // _cfa_ffffff48
    signed int _v188;                      // _cfa_ffffff44
    signed int _v216;                      // _cfa_ffffff28
    _unknown_ _t46;                        // _t46
    signed int _t49;                       // _t49
    _unknown_ _t52;                        // _t52
    intOrPtr _t57;                         // _t57
    _unknown_ _t63;                        // _t63
    _unknown_ _t77;                        // _t77
    signed int _t80;                       // _t80
    _unknown_ _t83;                        // _t83
    signed int _t88;                       // _t88
    intOrPtr _t93;                         // _t93
    intOrPtr _t94;                         // _t94
    intOrPtr _t95;                         // _t95
    _unknown_ _t96;                        // _t96
    _unknown_ _t97;                        // _t97
    signed int _t99;                       // _t99
    intOrPtr _t100;                        // _t100
    signed int _t101;                      // _t101
    signed int _t102;                      // _t102
    signed int _t104;                      // _t104
    signed int _t105;                      // _t105
    intOrPtr* _t106;                       // _t106
    _unknown_ _t108;                       // _t108
    signed int* _t109;                     // _t109
    signed int* _t110;                     // _t110
    signed int* _t111;                     // _t111

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t46);
    _t93 = __ebx + 91412;
    _t99 = _a4;
    _t49 = cstringvect(_a8);
    _t104 = _t49;
    _v40 = _t49;
     *__esp = _t99;
    execv();
    caml_stat_free(_t104);
    _v40 = _t99;
    _t52 = uerror(_t93, _t104, _t93 - 9668);
    _push(_t108);
    _t109 = __esp;
    __esp = __esp - 40;
    _v60 = _t93;
    _v56 = _t104;
    _v52 = _t99;
    __i686.get_pc_thunk.bx(_t52);
    _t94 = _t93 + 91332;
    _t105 = cstringvect(_v36);
    _t57 = cstringvect(_v32);
    _t100 = _t57;
    _v80 = _t57;
    _v84 = _t105;
     *__esp = _v40;
    execve();
    caml_stat_free(_t105);
    caml_stat_free(_t100);
    _v84 = _v40;
    _t63 = uerror(_t94, _t105, _t94 - 9662);
    _push(_t109);
    _t110 = __esp;
    __esp = __esp - 56;
    _v104 = _t94;
    _v100 = _t105;
    _v96 = _t100;
    __i686.get_pc_thunk.bx(_t63);
    _t95 = _t94 + 91224;
    _t101 = cstringvect(_v80);
    _t106 =  *((intOrPtr*)(_t95 - 20));
    _v120 =  *_t106;
     *_t106 = cstringvect(_v76);
    _v144 = _t101;
     *__esp = _v84;
    execvp();
    caml_stat_free(_t101);
    caml_stat_free( *_t106);
     *_t106 = _v120;
    _v144 = _v84;
    _t77 = uerror(_t95, _t106, _t95 - 9655);
    _push(_t110);
    _t111 = __esp;
    __esp = __esp - 40;
    _v164 = _t95;
    _v160 = _t106;
    _v156 = _t101;
    __i686.get_pc_thunk.bx(_t77);
    _t96 = _t95 + 91102;
    _t102 = _v144;
    _t80 = cstringvect(_v140);
    _t107 = _t80;
    _v188 = _t80;
     *__esp = _t102;
    execvp();
    caml_stat_free(_t80);
    _v188 = _t102;
    _t83 = uerror(_t96, _t80, _t96 - 9655);
    _push(_t111);
    _push(_t96);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx(_t83);
    _t97 = _t96 + 91028;
    _v216 = _v184 >> 1;
    _t88 = _v188 >> 1;
     *__esp = _t88;
    fchmod();
    if(_t88 == -1) {
        _v216 = 0;
        uerror(_t97, _t80, _t97 - 9648);
    }
    __esp =  &(__esp[5]);
    _pop(__ebx);
    return 1;
}

unix_execve(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080574CC
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    intOrPtr _v52;                         // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v96;                         // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v112;                      // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    signed int _v140;                      // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    signed int _v172;                      // _cfa_ffffff54
    _unknown_ _t38;                        // _t38
    intOrPtr _t43;                         // _t43
    _unknown_ _t49;                        // _t49
    _unknown_ _t63;                        // _t63
    signed int _t66;                       // _t66
    _unknown_ _t69;                        // _t69
    signed int _t74;                       // _t74
    intOrPtr _t79;                         // _t79
    intOrPtr _t80;                         // _t80
    _unknown_ _t81;                        // _t81
    _unknown_ _t82;                        // _t82
    intOrPtr _t84;                         // _t84
    signed int _t85;                       // _t85
    signed int _t86;                       // _t86
    signed int _t88;                       // _t88
    intOrPtr* _t89;                        // _t89
    _unknown_ _t91;                        // _t91
    signed int* _t92;                      // _t92
    signed int* _t93;                      // _t93

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t38);
    _t79 = __ebx + 91332;
    _t88 = cstringvect(_a8);
    _t43 = cstringvect(_a12);
    _t84 = _t43;
    _v36 = _t43;
    _v40 = _t88;
     *__esp = _a4;
    execve();
    caml_stat_free(_t88);
    caml_stat_free(_t84);
    _v40 = _a4;
    _t49 = uerror(_t79, _t88, _t79 - 9662);
    _push(_t91);
    _t92 = __esp;
    __esp = __esp - 56;
    _v60 = _t79;
    _v56 = _t88;
    _v52 = _t84;
    __i686.get_pc_thunk.bx(_t49);
    _t80 = _t79 + 91224;
    _t85 = cstringvect(_v36);
    _t89 =  *((intOrPtr*)(_t80 - 20));
    _v76 =  *_t89;
     *_t89 = cstringvect(_v32);
    _v100 = _t85;
     *__esp = _v40;
    execvp();
    caml_stat_free(_t85);
    caml_stat_free( *_t89);
     *_t89 = _v76;
    _v100 = _v40;
    _t63 = uerror(_t80, _t89, _t80 - 9655);
    _push(_t92);
    _t93 = __esp;
    __esp = __esp - 40;
    _v120 = _t80;
    _v116 = _t89;
    _v112 = _t85;
    __i686.get_pc_thunk.bx(_t63);
    _t81 = _t80 + 91102;
    _t86 = _v100;
    _t66 = cstringvect(_v96);
    _t90 = _t66;
    _v144 = _t66;
     *__esp = _t86;
    execvp();
    caml_stat_free(_t66);
    _v144 = _t86;
    _t69 = uerror(_t81, _t66, _t81 - 9655);
    _push(_t93);
    _push(_t81);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx(_t69);
    _t82 = _t81 + 91028;
    _v172 = _v140 >> 1;
    _t74 = _v144 >> 1;
     *__esp = _t74;
    fchmod();
    if(_t74 == -1) {
        _v172 = 0;
        uerror(_t82, _t66, _t82 - 9648);
    }
    __esp =  &(__esp[5]);
    _pop(__ebx);
    return 1;
}

unix_execvpe(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08057538
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v68;                       // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    signed int _v96;                       // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v128;                      // _cfa_ffffff80
    _unknown_ _t27;                        // _t27
    _unknown_ _t41;                        // _t41
    signed int _t44;                       // _t44
    _unknown_ _t47;                        // _t47
    signed int _t52;                       // _t52
    intOrPtr _t57;                         // _t57
    _unknown_ _t58;                        // _t58
    _unknown_ _t59;                        // _t59
    signed int _t61;                       // _t61
    signed int _t62;                       // _t62
    intOrPtr* _t64;                        // _t64
    _unknown_ _t66;                        // _t66
    signed int* _t67;                      // _t67

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t27);
    _t57 = __ebx + 91224;
    _t61 = cstringvect(_a8);
    _t64 =  *((intOrPtr*)(_t57 - 20));
    _v32 =  *_t64;
     *_t64 = cstringvect(_a12);
    _v56 = _t61;
     *__esp = _a4;
    execvp();
    caml_stat_free(_t61);
    caml_stat_free( *_t64);
     *_t64 = _v32;
    _v56 = _a4;
    _t41 = uerror(_t57, _t64, _t57 - 9655);
    _push(_t66);
    _t67 = __esp;
    __esp = __esp - 40;
    _v76 = _t57;
    _v72 = _t64;
    _v68 = _t61;
    __i686.get_pc_thunk.bx(_t41);
    _t58 = _t57 + 91102;
    _t62 = _v56;
    _t44 = cstringvect(_v52);
    _t65 = _t44;
    _v100 = _t44;
     *__esp = _t62;
    execvp();
    caml_stat_free(_t44);
    _v100 = _t62;
    _t47 = uerror(_t58, _t44, _t58 - 9655);
    _push(_t67);
    _push(_t58);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx(_t47);
    _t59 = _t58 + 91028;
    _v128 = _v96 >> 1;
    _t52 = _v100 >> 1;
     *__esp = _t52;
    fchmod();
    if(_t52 == -1) {
        _v128 = 0;
        uerror(_t59, _t44, _t59 - 9648);
    }
    __esp =  &(__esp[5]);
    _pop(__ebx);
    return 1;
}

unix_execvp(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080575B2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v68;                       // _cfa_ffffffbc
    _unknown_ _t14;                        // _t14
    signed int _t17;                       // _t17
    _unknown_ _t20;                        // _t20
    signed int _t25;                       // _t25
    _unknown_ _t30;                        // _t30
    _unknown_ _t31;                        // _t31
    signed int _t33;                       // _t33
    _unknown_ _t36;                        // _t36

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t14);
    _t30 = __ebx + 91102;
    _t33 = _a4;
    _t17 = cstringvect(_a8);
    _t35 = _t17;
    _v40 = _t17;
     *__esp = _t33;
    execvp();
    caml_stat_free(_t17);
    _v40 = _t33;
    _t20 = uerror(_t30, _t17, _t30 - 9655);
    _push(_t36);
    _push(_t30);
    __esp = __esp - 20;
    __i686.get_pc_thunk.bx(_t20);
    _t31 = _t30 + 91028;
    _v68 = _v36 >> 1;
    _t25 = _v40 >> 1;
     *__esp = _t25;
    fchmod();
    if(_t25 == -1) {
        _v68 = 0;
        uerror(_t31, _t17, _t31 - 9648);
    }
    __esp =  &(__esp[5]);
    _pop(__ebx);
    return 1;
}

unix_fchmod(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08057604
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    signed int _t11;                       // _t11
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __i686.get_pc_thunk.bx(_t6);
    _t16 = _t15 + 91028;
    _v24 = _a8 >> 1;
    _t11 = _a4 >> 1;
     *__esp = _t11;
    fchmod();
    if(_t11 == -1) {
        _v24 = 0;
        uerror(_t16, __esi, _t16 - 9648);
    }
    return 1;
}

unix_fchown(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08057654
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t8;                         // _t8
    signed int _t15;                       // _t15
    _unknown_ _t19;                        // _t19
    _unknown_ _t20;                        // _t20

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t8);
    _t20 = _t19 + 90948;
    _v20 = _a12 >> 1;
    _v24 = _a8 >> 1;
    _t15 = _a4 >> 1;
     *__esp = _t15;
    fchown();
    if(_t15 == -1) {
        _v24 = 0;
        uerror(_t20, __esi, _t20 - 9641);
    }
    return 1;
}

signed int unix_clear_close_on_exec(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x080576AC
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t12;                        // _t12
    signed int _t13;                       // _t13
    signed int _t17;                       // _t17
    _unknown_ _t19;                        // _t19
    signed int _t23;                       // _t23

    _v12 = __ebx;
    _v8 = __esi;
    _t13 = __i686.get_pc_thunk.bx(_t12);
    _t19 = __ebx + 90855;
    _t23 = _a4 >> 1;
    _v20 = 0;
    _v24 = 1;
     *__esp = _t23;
    fcntl();
    if(_t13 == -1) {
L2:
        _v24 = 0;
        uerror(_t19, _t23, _t19 - 9634);
    } else {
        _t17 = _t13 & -2;
        _v20 = _t17;
        _v24 = 2;
         *__esp = _t23;
        fcntl();
        if(_t17 == -1) {
            goto L2;
        }
    }
    return 1;
}

signed int unix_set_close_on_exec(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x08057726
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t12;                        // _t12
    signed int _t13;                       // _t13
    signed int _t17;                       // _t17
    _unknown_ _t19;                        // _t19
    signed int _t23;                       // _t23

    _v12 = __ebx;
    _v8 = __esi;
    _t13 = __i686.get_pc_thunk.bx(_t12);
    _t19 = __ebx + 90733;
    _t23 = _a4 >> 1;
    _v20 = 0;
    _v24 = 1;
     *__esp = _t23;
    fcntl();
    if(_t13 == -1) {
L2:
        _v24 = 0;
        uerror(_t19, _t23, _t19 - 9614);
    } else {
        _t17 = _t13 | 1;
        _v20 = _t17;
        _v24 = 2;
         *__esp = _t23;
        fcntl();
        if(_t17 == -1) {
            goto L2;
        }
    }
    return 1;
}

unix_clear_nonblock(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x080577A0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed char _v20;                      // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t12;                        // _t12
    signed char _t13;                      // _t13
    signed char _t17;                      // _t17
    _unknown_ _t19;                        // _t19
    signed int _t23;                       // _t23

    _v12 = __ebx;
    _v8 = __esi;
    _t13 = __i686.get_pc_thunk.bx(_t12);
    _t19 = __ebx + 90611;
    _t23 = _a4 >> 1;
    _v20 = 0;
    _v24 = 3;
     *__esp = _t23;
    fcntl();
    if(_t13 == -1) {
L2:
        _v24 = 0;
        uerror(_t19, _t23, _t19 - 9596);
    } else {
        _t17 = _t13 & 247;
        _v20 = _t17;
        _v24 = 4;
         *__esp = _t23;
        fcntl();
        if(_t17 == -1) {
            goto L2;
        }
    }
    return 1;
}

unix_set_nonblock(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805781A
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed char _v20;                      // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t12;                        // _t12
    signed char _t13;                      // _t13
    signed char _t17;                      // _t17
    _unknown_ _t19;                        // _t19
    signed int _t23;                       // _t23

    _v12 = __ebx;
    _v8 = __esi;
    _t13 = __i686.get_pc_thunk.bx(_t12);
    _t19 = __ebx + 90489;
    _t23 = _a4 >> 1;
    _v20 = 0;
    _v24 = 3;
     *__esp = _t23;
    fcntl();
    if(_t13 == -1) {
L2:
        _v24 = 0;
        uerror(_t19, _t23, _t19 - 9581);
    } else {
        _t17 = _t13 | 8;
        _v20 = _t17;
        _v24 = 4;
         *__esp = _t23;
        fcntl();
        if(_t17 == -1) {
            goto L2;
        }
    }
    return 1;
}

unsigned int unix_fork(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x080578A0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12
    intOrPtr _t16;                         // _t16
    _unknown_ _t21;                        // _t21
    _unknown_ _t24;                        // _t24

    _v12 = __ebx;
    _v8 = __esi;
    _t12 = __i686.get_pc_thunk.bx(_t11);
    _t21 = __ebx + 90355;
    fork();
    _t24 = _t12;
    if(_t12 == -1) {
        _v24 = 0;
        uerror(_t21, _t24, _t21 - 9568);
    }
    if( *((intOrPtr*)( *((intOrPtr*)(_t21 - 16)))) == 0) {
L8:
        return _t24 + _t24 + 1;
    }
    _t16 =  *((intOrPtr*)( *((intOrPtr*)(_t21 - 12))));
    if(_t16 == 0 || _t24 != 0) {
        if(_t16 != 0 || _t24 == 0) {
            goto L8;
        } else {
            goto L7;
        }
    } else {
L7:
        caml_debugger_cleanup_fork(_t16);
        goto L8;
    }
}

unix_ftruncate_64(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08057914
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t9;                         // _t9
    intOrPtr _t11;                         // _t11
    signed int _t14;                       // _t14
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t9);
    _t19 = _t18 + 90244;
    _t11 = _a8;
    _v24 =  *((intOrPtr*)(_t11 + 4));
    _v20 =  *((intOrPtr*)(_t11 + 8));
    _t14 = _a4 >> 1;
     *__esp = _t14;
    ftruncate64();
    if(_t14 == -1) {
        _v24 = 0;
        uerror(_t19, __esi, _t19 - 9563);
    }
    return 1;
}

unix_ftruncate(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805796A
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t7;                         // _t7
    signed int _t10;                       // _t10
    signed int _t12;                       // _t12
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t7);
    _t17 = _t16 + 90158;
    _t10 = _a8 >> 1;
    _v24 = _t10;
    _v20 = _t10 >> 31;
    _t12 = _a4 >> 1;
     *__esp = _t12;
    ftruncate64();
    if(_t12 == -1) {
        _v24 = 0;
        uerror(_t17, __esi, _t17 - 9563);
    }
    return 1;
}

signed int unix_getaddrinfo(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed char _a12                       // _cfa_c
)
{// addr = 0x080579D0
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    char* _v92;                            // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    char _v104;                            // _cfa_ffffff98
    signed int _v124;                      // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    signed int _v136;                      // _cfa_ffffff78
    signed int _v140;                      // _cfa_ffffff74
    signed int _v144;                      // _cfa_ffffff70
    signed int _v148;                      // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    char* _v164;                           // _cfa_ffffff5c
    char* _v168;                           // _cfa_ffffff58
    char* _v172;                           // _cfa_ffffff54
    signed int _v176;                      // _cfa_ffffff50
    intOrPtr _v180;                        // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48
    char _v296;                            // _cfa_fffffed8
    char* _v304;                           // _cfa_fffffed0
    signed int _v308;                      // _cfa_fffffecc
    char* _v312;                           // _cfa_fffffec8
    char* _v316;                           // _cfa_fffffec4
    char* _v320;                           // _cfa_fffffec0 (outparam)
    char* _v324;                           // _cfa_fffffebc (outparam)
    signed int _v328;                      // _cfa_fffffeb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t146;                       // _t146
    char** _t148;                          // _t148
    _unknown_ _t153;                       // _t153
    _unknown_ _t155;                       // _t155
    signed int _t156;                      // _t156
    signed char _t157;                     // _t157
    char* _t166;                           // _t166
    signed int _t177;                      // _t177
    signed int _t189;                      // _t189
    signed int _t194;                      // _t194
    signed int _t195;                      // _t195
    _unknown_ _t211;                       // _t211
    _unknown_ _t212;                       // _t212
    intOrPtr _t221;                        // _t221
    char* _t222;                           // _t222
    signed int _t236;                      // _t236
    signed int _t238;                      // _t238
    signed int _t244;                      // _t244
    signed int _t245;                      // _t245

    __i686.get_pc_thunk.bx(_t146);
    _t212 = _t211 + 90051;
    _t148 =  *(_t212 - 24);
    _t222 =  *_t148;
    _v316 = _t222;
    _v60 = _t222;
    _v52 = 1;
    _v56 = 3;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v64 = 0;
    _v68 = 0;
    _v72 = 0;
    _v104 =  &_v60;
     *_t148 =  &_v104;
    _v96 = 1;
    _v100 = 3;
    _v92 =  &_v64;
    _v88 =  &_v68;
    _v84 =  &_v72;
    _t153 = caml_string_length(_a4);
    _t244 = 0;
    if(_t153 != 0) {
        _t244 = caml_stat_alloc(_t153 + 1, _t153 + 1);
        _v328 = _a4;
         *__esp = _t244;
        strcpy();
    }
    _t155 = caml_string_length(_a8);
    _t238 = 0;
    if(_t155 != 0) {
        _t238 = caml_stat_alloc(_t155 + 1, _t155 + 1);
        _v328 = _a8;
         *__esp = _t238;
        strcpy();
    }
    _t156 = 0;
    do {
         *( &_v136 + _t156) = 0;
        _t156 = _t156 + 4;
    } while(_t156 < 32);
    _v132 = 0;
    _t157 = _a12;
    if((_t157 & 1) != 0) {
L23:
        caml_enter_blocking_section();
        _v320 =  &_v140;
        _v324 =  &_v136;
        _v328 = _t238;
         *__esp = _t244;
        getaddrinfo();
        _v304 =  &_v136;
        caml_leave_blocking_section();
        if(_t244 != 0) {
            caml_stat_free(_t244);
        }
        if(_t238 != 0) {
            caml_stat_free(_t238);
        }
        _v64 = 1;
        if(_v304 != 0) {
L32:
             *( *(_t212 - 24)) = _v316;
            return _v64;
        } else {
            _t245 = _v140;
            if(_t245 == 0) {
L31:
                 *__esp = _v140;
                freeaddrinfo();
                goto L32;
            }
            _v312 =  &_v184;
            do {
                _t166 =  *( *(_t212 - 24));
                _v304 = _t166;
                _v144 = 0;
                _v148 = 0;
                _v152 = 0;
                _v184 = _t166;
                 *( *(_t212 - 24)) = _v312;
                _v176 = 1;
                _v180 = 3;
                _v172 =  &_v144;
                _v168 =  &_v148;
                _v164 =  &_v152;
                _t240 =  *((intOrPtr*)(_t245 + 16)) - 112 <= 0 ?  *((intOrPtr*)(_t245 + 16)) : 112;
                _v308 =  &_v296;
                _v324 = 112;
                _v328 =  *(_t245 + 20);
                 *__esp = _v308;
                memcpy();
                _v148 = alloc_sockaddr(_t212,  *((intOrPtr*)(_t245 + 16)) - 112 <= 0 ?  *((intOrPtr*)(_t245 + 16)) : 112, _t245, _v308, 112, -1);
                _t175 =  *((intOrPtr*)(_t245 + 24)) == 0 ? _t212 - 5244 :  *((intOrPtr*)(_t245 + 24));
                _v152 = caml_copy_string(_t212,  *((intOrPtr*)(_t245 + 16)) - 112 <= 0 ?  *((intOrPtr*)(_t245 + 16)) : 112, _t245,  *((intOrPtr*)(_t245 + 24)) == 0 ? _t212 - 5244 :  *((intOrPtr*)(_t245 + 24)));
                _t177 = caml_alloc_small(_t212, _t245, 5, 0);
                _v144 = _t177;
                 *_t177 = cst_to_constr( *((intOrPtr*)(_t245 + 4)),  *((intOrPtr*)(_t212 - 32)), 3, 0);
                 *((intOrPtr*)(_v144 + 4)) = cst_to_constr( *((intOrPtr*)(_t245 + 8)),  *((intOrPtr*)(_t212 - 28)), 4, 0);
                 *((intOrPtr*)(_v144 + 8)) =  *((intOrPtr*)(_t245 + 12)) +  *((intOrPtr*)(_t245 + 12)) + 1;
                 *(_v144 + 12) = _v148;
                 *(_v144 + 16) = _v152;
                 *( *(_t212 - 24)) = _v304;
                _v72 = _v144;
                _t189 = caml_alloc_small(_t212, _t245, 2, 0);
                _v68 = _t189;
                 *_t189 = _v72;
                 *(_v68 + 4) = _v64;
                _v64 = _v68;
                _t245 =  *(_t245 + 28);
            } while(_t245 != 0);
            goto L31;
        }
    } else {
        _t221 =  *((intOrPtr*)(_t212 - 28));
        do {
            _t194 =  *_t157;
            _v68 = _t194;
            if((_t194 & 1) != 0) {
                _t195 = _t194 >> 1;
                if(_t195 == 1) {
                    _v136 = _v136 | 2;
                } else {
                    if(_t195 == 2) {
                        _v136 = _v136 | 1;
                    } else {
                        if(_t195 == 0) {
                            _v136 = _v136 | 4;
                        }
                    }
                }
            } else {
                _t236 =  *(_t194 - 4) & 255;
                if(_t236 == 1) {
                    _v128 =  *((intOrPtr*)(_t221 + ( *_t194 >> 1) * 4));
                } else {
                    if(_t236 < 1) {
                        _v132 =  *( *((intOrPtr*)(_t212 - 32)) + ( *_t194 >> 1) * 4);
                    } else {
                        if(_t236 == 2) {
                            _v124 =  *_t194 >> 1;
                        }
                    }
                }
            }
            _t157 =  *(_a12 + 4);
            _a12 = _t157;
        } while((_t157 & 1) == 0);
        goto L23;
    }
}

unix_getcwd(
    _unknown_ __esi                        // r5
)
{// addr = 0x08057DDC
    char _v4108;                           // _cfa_ffffeff4
    intOrPtr _v4120;                       // _cfa_ffffefe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    _unknown_ _t13;                        // _t13
    _unknown_ _t14;                        // _t14

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t6);
    _t14 = _t13 + 89017;
    _v4120 = 4096;
     *__esp =  &_v4108;
    getcwd();
    if( &_v4108 == 0) {
        _v4120 = 0;
        uerror(_t14, __esi, _t14 - 9553);
    }
    return caml_copy_string(_t14, __edi, __esi,  &_v4108);
}

unix_getegid()
{// addr = 0x08057E38
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _t4 = __i686.get_pc_thunk.bx(_t3);
    getegid();
    return _t4 + _t4 + 1;
}

unix_geteuid()
{// addr = 0x08057E5C
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _t4 = __i686.get_pc_thunk.bx(_t3);
    geteuid();
    return _t4 + _t4 + 1;
}

unix_getgid()
{// addr = 0x08057E80
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _t4 = __i686.get_pc_thunk.bx(_t3);
    getgid();
    return _t4 + _t4 + 1;
}

alloc_group_entry()
{// addr = 0x08057EB0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ _t31;                        // _t31
    intOrPtr* _t32;                        // _t32
    intOrPtr* _t44;                        // _t44
    _unknown_ _t45;                        // _t45

    _t32 = __i686.get_pc_thunk.bx(_t31);
    _t46 = _t45 + 88806;
    __esi = _t32;
    _v32 = 1;
    _v36 = 1;
    _v40 = 1;
    __edi =  *((intOrPtr*)(_t45 + 88806 - 24));
    _v72 =  *__edi;
     *__edi =  &_v72;
    _v64 = 1;
    _v68 = 3;
    _v60 =  &_v32;
    _v56 =  &_v36;
    _v52 =  &_v40;
    _v32 = caml_copy_string(_t46, __edi, __esi,  *__esi);
    _v36 = caml_copy_string(_t46, __edi, __esi, __esi[1]);
    _v40 = caml_copy_string_array(__esi[3]);
    _t44 = caml_alloc_small(_t46, __esi, 4, 0);
     *_t44 = _v32;
    _t44[1] = _v36;
    _t44[2] = __esi[2] + __esi[2] + 1;
    _t44[3] = _v40;
     *__edi = _v72;
    return _t44;
}

unix_getgrgid(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08057F70
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    signed int _t5;                        // _t5
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx(_t2);
    _t5 = _a4 >> 1;
     *__esp = _t5;
    getgrgid();
    if(_t5 == 0) {
        caml_raise_not_found();
    }
    return alloc_group_entry();
}

unix_getgrnam(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08057FA3
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    intOrPtr _t4;                          // _t4
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx(_t2);
    _t4 = _a4;
     *__esp = _t4;
    getgrnam();
    if(_t4 == 0) {
        caml_raise_not_found();
    }
    return alloc_group_entry();
}

unix_getgroups()
{// addr = 0x08057FD4
    char _v262172;                         // _cfa_fffbffe4
    signed int _v262184;                   // _cfa_fffbffd8
    _unknown_ __ebx;                       // r1
    char* __esi;                           // r5
    _unknown_ _t12;                        // _t12
    char* _t14;                            // _t14
    _unknown_ _t15;                        // _t15
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    __i686.get_pc_thunk.bx(_t12);
    _t18 = _t17 + 88511;
    _t14 =  &_v262172;
    _v262184 =  &_v262172;
     *__esp = 65536;
    getgroups();
    __esi =  &_v262172;
    if( &_v262172 == -1) {
        _v262184 = 0;
        _t14 = uerror(_t18,  &_v262172, _t18 - 9546);
    }
    _t15 = caml_alloc_tuple(_t14);
    if(__esi > 0) {
        __edx = 0;
        do {
             *((intOrPtr*)(_t15 + __edx * 4)) =  *((intOrPtr*)( &_v262172 + __edx * 4)) +  *((intOrPtr*)( &_v262172 + __edx * 4)) + 1;
            __edx = __edx + 1;
        } while(__edx != __esi);
    }
    return _t15;
}

alloc_host_entry()
{// addr = 0x08058054
    char _v16;                             // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    char _v28;                             // _cfa_ffffffe4
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ _t43;                        // _t43
    intOrPtr* _t44;                        // _t44
    intOrPtr* _t45;                        // _t45
    intOrPtr* _t59;                        // _t59
    _unknown_ _t61;                        // _t61
    _unknown_ _t62;                        // _t62
    intOrPtr _t64;                         // _t64
    intOrPtr* _t73;                        // _t73

    _t44 = __i686.get_pc_thunk.bx(_t43);
    _t62 = _t61 + 88387;
    __esi = _t44;
    _v16 = 1;
    _v20 = 1;
    _v24 = 1;
    _v28 = 1;
    _t45 =  *((intOrPtr*)(_t62 - 24));
    _v60 =  *_t45;
     *_t45 =  &_v60;
    _v52 = 1;
    _v56 = 4;
    _v48 =  &_v16;
    _v44 =  &_v20;
    _v40 =  &_v24;
    _v36 =  &_v28;
    _v16 = caml_copy_string(_t62, __edi, __esi,  *__esi);
    _t52 = __esi[1];
    if(__esi[1] == 0) {
        _v20 =  *((intOrPtr*)(_t62 - 4)) + 4;
    } else {
        _v20 = caml_copy_string_array(_t52);
    }
     *((intOrPtr*)(_t62 + 27688)) = __esi[3];
    _v24 = caml_alloc_array(_t62 - 87954, __esi[4]);
    _t59 = caml_alloc_small(_t62, __esi, 4, 0);
     *_t59 = _v16;
    _t73 = _t59;
    _t59[1] = _v20;
    _t64 = __esi[2];
    if(_t64 == 1) {
        _t59[2] = 1;
    } else {
        _t59[2] = (_t64 != 2 & 255) + (_t64 != 2 & 255) + 3;
    }
    _t73[3] = _v24;
     *((intOrPtr*)( *((intOrPtr*)(_t62 - 24)))) = _v60;
    return _t59;
}

intOrPtr unix_gethostbyname(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char* _a4                              // _cfa_4
)
{// addr = 0x08058163
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    char _v52;                             // _cfa_ffffffcc
    char _v10052;                          // _cfa_ffffd8bc
    intOrPtr _v10072;                      // _cfa_ffffd8a8
    char* _v10076;                         // _cfa_ffffd8a4
    intOrPtr _v10080;                      // _cfa_ffffd8a0
    char* _v10084;                         // _cfa_ffffd89c
    char* _v10088;                         // _cfa_ffffd898
    _unknown_ _t19;                        // _t19
    intOrPtr _t23;                         // _t23
    intOrPtr _t24;                         // _t24
    char* _t37;                            // _t37

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t19);
    _t37 = _a4;
    _t23 = caml_stat_alloc(caml_string_length(_t37) + 1, caml_string_length(_t37) + 1);
    _t41 = _t23;
    _v10088 = _t37;
     *__esp = _t23;
    strcpy();
    _t24 = caml_enter_blocking_section();
    __h_errno_location();
    _v10072 = _t24;
    _v10076 =  &_v32;
    _v10080 = 10000;
    _v10084 =  &_v10052;
    _v10088 =  &_v52;
     *__esp = _t23;
    gethostbyname_r();
    caml_leave_blocking_section();
    if( &_v52 != 0) {
        _v32 = 0;
    }
    caml_stat_free(_t23);
    if(_v32 == 0) {
        caml_raise_not_found();
    }
    return alloc_host_entry();
}

alloc_one_addr(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08058212
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v16;                             // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ _t13;                        // _t13
    intOrPtr _t15;                         // _t15
    _unknown_ _t16;                        // _t16

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t13);
    _t18 = __ebx + 87937;
    _t15 = _a4;
    if( *((intOrPtr*)(__ebx + 0x1c3a9)) != 16) {
        _v52 = 4;
        _v56 = _t15;
         *__esp =  &_v16;
        memmove();
        _t16 = alloc_inet_addr( &_v16);
    } else {
        _v52 = 16;
        _v56 = _t15;
         *__esp =  &_v32;
        memmove();
        _t16 = alloc_inet6_addr(_t18,  &_v32,  &_v32);
    }
    return _t16;
}

intOrPtr* unix_gethostbyaddr(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805827F
    char _v16;                             // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char _v40;                             // _cfa_ffffffd8
    char _v10040;                          // _cfa_ffffd8c8
    char _v10044;                          // _cfa_ffffd8c4
    char* _v10048;                         // _cfa_ffffd8c0
    char* _v10052;                         // _cfa_ffffd8bc
    intOrPtr _v10056;                      // _cfa_ffffd8b8
    char* _v10060;                         // _cfa_ffffd8b4
    char* _v10064;                         // _cfa_ffffd8b0
    intOrPtr _v10068;                      // _cfa_ffffd8ac
    intOrPtr _v10072;                      // _cfa_ffffd8a8
    _unknown_ __ebx;                       // r1
    _unknown_ _t17;                        // _t17
    _unknown_ _t31;                        // _t31

    __i686.get_pc_thunk.bx(_t17);
    _v16 =  *_a4;
    caml_enter_blocking_section();
    _v10048 =  &_v10044;
    _v10052 =  &_v20;
    _v10056 = 10000;
    _v10060 =  &_v10040;
    _v10064 =  &_v40;
    _v10068 = 2;
    _v10072 = 4;
     *__esp =  &_v16;
    gethostbyaddr_r();
    caml_leave_blocking_section();
    if( &_v16 == 0) {
        if(_v20 == 0) {
            goto L3;
        }
    } else {
        _v20 = 0;
L3:
        caml_raise_not_found();
    }
    return alloc_host_entry();
}

unix_gethostname(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x08058318
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v13;                             // _cfa_fffffff3
    char _v76;                             // _cfa_ffffffb4
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ _t8;                         // _t8

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t8);
    _v88 = 64;
     *__esp =  &_v76;
    gethostname();
    _v13 = 0;
    return caml_copy_string(__ebx + 87675, __edi,  &_v76,  &_v76);
}

unix_getlogin()
{// addr = 0x08058358
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    _unknown_ _t5;                         // _t5
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9

    _t5 = __i686.get_pc_thunk.bx(_t4);
    _t9 = _t8 + 87616;
    getlogin();
    if(_t5 == 0) {
        _v20 = 0;
        _v24 = _t9 - 9536;
        _t5 = unix_error(_t9, __esi, 2);
    }
    return caml_copy_string(_t9, __edi, __esi, _t5);
}

unix_getnameinfo(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080583A0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    _unknown_ _v40;                        // _cfa_ffffffd8
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    char _v184;                            // _cfa_ffffff48
    char _v188;                            // _cfa_ffffff44
    char _v4284;                           // _cfa_ffffef44
    char _v5308;                           // _cfa_ffffeb44
    intOrPtr _v5312;                       // _cfa_ffffeb40
    intOrPtr _v5332;                       // _cfa_ffffeb2c
    intOrPtr _v5336;                       // _cfa_ffffeb28
    char* _v5340;                          // _cfa_ffffeb24
    intOrPtr _v5344;                       // _cfa_ffffeb20
    char* _v5348;                          // _cfa_ffffeb1c (outparam)
    intOrPtr _v5352;                       // _cfa_ffffeb18 (outparam)
    _unknown_ __ebx;                       // r1
    char __edi;                            // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t46;                        // _t46
    intOrPtr* _t48;                        // _t48
    intOrPtr _t62;                         // _t62
    intOrPtr* _t68;                        // _t68
    _unknown_ _t73;                        // _t73
    _unknown_ _t74;                        // _t74

    __i686.get_pc_thunk.bx(_t46);
    _t74 = _t73 + 87539;
    _t48 =  *((intOrPtr*)(_t74 - 24));
    __edi =  *_t48;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v72 = __edi;
     *_t48 =  &_v72;
    _v64 = 1;
    _v68 = 3;
    _v60 =  &_v32;
    _v56 =  &_v36;
    _v52 =  &_v40;
    get_sockaddr(_t74, __edi,  &_v184, _a4,  &_v184,  &_v188);
    _v5312 = caml_convert_flag_list(_a8, _t74 + 26196);
    caml_enter_blocking_section();
    _v5332 = _v5312;
    _v5336 = 1024;
    _v5340 =  &_v5308;
    _v5344 = 4096;
    _v5348 =  &_v4284;
    _t62 = _v188;
    _v5352 = _t62;
     *__esp =  &_v184;
    getnameinfo();
    _t79 = _t62;
    caml_leave_blocking_section();
    if(_t62 != 0) {
        caml_raise_not_found();
    }
    _v32 = caml_copy_string(_t74, __edi, _t62,  &_v4284);
    _v36 = caml_copy_string(_t74, __edi, _t62,  &_v5308);
    _t68 = caml_alloc_small(_t74, _t62, 2, 0);
    _v40 = _t68;
     *_t68 = _v32;
     *((intOrPtr*)(_v40 + 4)) = _v36;
     *((intOrPtr*)( *((intOrPtr*)(_t74 - 24)))) = __edi;
    return _v40;
}

unix_getpeername(
    _unknown_ __esi,                       // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x080584E8
    char _v124;                            // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    char* _v148;                           // _cfa_ffffff6c (outparam)
    char* _v152;                           // _cfa_ffffff68 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t13;                        // _t13
    signed int _t18;                       // _t18
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t13);
    _t25 = _t24 + 87213;
    _v128 = 112;
    _v148 =  &_v128;
    _v152 =  &_v124;
    _t18 = _a4 >> 1;
     *__esp = _t18;
    getpeername();
    if(_t18 == -1) {
        _v152 = 0;
        uerror(_t25, __esi, _t25 - 9527);
    }
    return alloc_sockaddr(_t25, __edi, __esi,  &_v124, _v128, -1);
}

unix_getpid()
{// addr = 0x08058560
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _t4 = __i686.get_pc_thunk.bx(_t3);
    getpid();
    return _t4 + _t4 + 1;
}

unix_getppid()
{// addr = 0x08058584
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _t4 = __i686.get_pc_thunk.bx(_t3);
    getppid();
    return _t4 + _t4 + 1;
}

alloc_proto_entry(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x080585B0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    char _v68;                             // _cfa_ffffffbc
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ _t30;                        // _t30
    intOrPtr* _t31;                        // _t31
    intOrPtr* _t40;                        // _t40
    intOrPtr* _t50;                        // _t50
    intOrPtr* _t53;                        // _t53

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t31 = __i686.get_pc_thunk.bx(_t30);
    _t42 = __ebx + 87008;
    _t53 = _t31;
    _v32 = 1;
    _v36 = 1;
    _t50 =  *((intOrPtr*)(__ebx + 87008 - 24));
    _v68 =  *_t50;
     *_t50 =  &_v68;
    _v60 = 1;
    _v64 = 2;
    _v56 =  &_v32;
    _v52 =  &_v36;
    _v32 = caml_copy_string(_t42, _t50, _t53,  *_t53);
    _v36 = caml_copy_string_array(_t53[1]);
    _t40 = caml_alloc_small(_t42, _t53, 3, 0);
     *_t40 = _v32;
    _t40[1] = _v36;
    _t40[2] = _t53[2] + _t53[2] + 1;
     *_t50 = _v68;
    return _t40;
}

unix_getprotobynumber(
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805865A
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    signed int _t5;                        // _t5
    _unknown_ _t8;                         // _t8
    intOrPtr _t9;                          // _t9

    __esi = __esi;
    __edi = __edi;
    __i686.get_pc_thunk.bx(_t2);
    _t9 = _t8 + 86846;
    _t5 = _a4 >> 1;
     *__esp = _t5;
    getprotobynumber();
    if(_t5 == 0) {
        caml_raise_not_found();
    }
    return alloc_proto_entry(_t9, __edi, __esi);
}

unix_getprotobyname(
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805868D
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    intOrPtr _t4;                          // _t4
    _unknown_ _t7;                         // _t7
    intOrPtr _t8;                          // _t8

    __esi = __esi;
    __edi = __edi;
    __i686.get_pc_thunk.bx(_t2);
    _t8 = _t7 + 86795;
    _t4 = _a4;
     *__esp = _t4;
    getprotobyname();
    if(_t4 == 0) {
        caml_raise_not_found();
    }
    return alloc_proto_entry(_t8, __edi, __esi);
}

alloc_passwd_entry()
{// addr = 0x080586C0
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ _t49;                        // _t49
    intOrPtr* _t50;                        // _t50
    intOrPtr* _t68;                        // _t68
    _unknown_ _t69;                        // _t69

    _t50 = __i686.get_pc_thunk.bx(_t49);
    _t70 = _t69 + 86742;
    __esi = _t50;
    _v32 = 1;
    _v36 = 1;
    _v40 = 1;
    _v44 = 1;
    _v48 = 1;
    __edi =  *((intOrPtr*)(_t69 + 86742 - 24));
    _v80 =  *__edi;
     *__edi =  &_v80;
    _v72 = 1;
    _v76 = 5;
    _v68 =  &_v32;
    _v64 =  &_v36;
    _v60 =  &_v40;
    _v56 =  &_v44;
    _v52 =  &_v48;
    _v32 = caml_copy_string(_t70, __edi, __esi,  *__esi);
    _v36 = caml_copy_string(_t70, __edi, __esi, __esi[1]);
    _v40 = caml_copy_string(_t70, __edi, __esi, __esi[4]);
    _v44 = caml_copy_string(_t70, __edi, __esi, __esi[5]);
    _v48 = caml_copy_string(_t70, __edi, __esi, __esi[6]);
    _t68 = caml_alloc_small(_t70, __esi, 7, 0);
     *_t68 = _v32;
    _t68[1] = _v36;
    _t68[2] = __esi[2] + __esi[2] + 1;
    _t68[3] = __esi[3] + __esi[3] + 1;
    _t68[4] = _v40;
    _t68[5] = _v44;
    _t68[6] = _v48;
     *__edi = _v80;
    return _t68;
}

unix_getpwuid(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080587CC
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    signed int _t5;                        // _t5
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx(_t2);
    _t5 = _a4 >> 1;
     *__esp = _t5;
    getpwuid();
    if(_t5 == 0) {
        caml_raise_not_found();
    }
    return alloc_passwd_entry();
}

unix_getpwnam(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080587FF
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    intOrPtr _t4;                          // _t4
    _unknown_ _t7;                         // _t7

    __i686.get_pc_thunk.bx(_t2);
    _t4 = _a4;
     *__esp = _t4;
    getpwnam();
    if(_t4 == 0) {
        caml_raise_not_found();
    }
    return alloc_passwd_entry();
}

unix_gettimeofday(
    _unknown_ __esi,                       // r5
    signed int __fp0                       // r28
)
{// addr = 0x08058830
    char _v20;                             // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t6);
    _t13 = _t12 + 86376;
    _v40 = 0;
     *__esp =  &_v20;
    gettimeofday();
    if( &_v20 == -1) {
        _v40 = 0;
        uerror(_t13, __esi, _t13 - 9515);
    }
    asm("fild dword [ebp-0x10]");
    asm("fild dword [ebp-0xc]");
    asm("faddp st1, st0");
     *__esp = __fp0 /  *(_t13 - 9500);
    return caml_copy_double();
}

alloc_service_entry()
{// addr = 0x08058890
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ _t31;                        // _t31
    intOrPtr* _t32;                        // _t32
    intOrPtr* _t44;                        // _t44
    _unknown_ _t45;                        // _t45

    _t32 = __i686.get_pc_thunk.bx(_t31);
    _t46 = _t45 + 86278;
    __esi = _t32;
    _v32 = 1;
    _v36 = 1;
    _v40 = 1;
    __edi =  *((intOrPtr*)(_t45 + 86278 - 24));
    _v72 =  *__edi;
     *__edi =  &_v72;
    _v64 = 1;
    _v68 = 3;
    _v60 =  &_v32;
    _v56 =  &_v36;
    _v52 =  &_v40;
    _v32 = caml_copy_string(_t46, __edi, __esi,  *__esi);
    _v36 = caml_copy_string_array(__esi[1]);
    _v40 = caml_copy_string(_t46, __edi, __esi, __esi[3]);
    _t44 = caml_alloc_small(_t46, __esi, 4, 0);
     *_t44 = _v32;
    _t44[1] = _v36;
    asm("ror dx, 0x8");
    _t44[2] = ( *(__esi + 8) & 65535) + ( *(__esi + 8) & 65535) + 1;
    _t44[3] = _v40;
     *__edi = _v72;
    return _t44;
}

intOrPtr* unix_getservbyport(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08058957
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    signed int _t8;                        // _t8
    _unknown_ _t11;                        // _t11

    __i686.get_pc_thunk.bx(_t4);
    asm("ror ax, 0x8");
    _v24 = _a8;
    _t8 = _a4 >> 1 & 65535;
     *__esp = _t8;
    getservbyport();
    if(_t8 == 0) {
        caml_raise_not_found();
    }
    return alloc_service_entry();
}

unix_getservbyname(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805899B
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    intOrPtr _t7;                          // _t7
    _unknown_ _t10;                        // _t10

    __i686.get_pc_thunk.bx(_t4);
    _v24 = _a8;
    _t7 = _a4;
     *__esp = _t7;
    getservbyname();
    if(_t7 == 0) {
        caml_raise_not_found();
    }
    return alloc_service_entry();
}

unix_getsockname(
    _unknown_ __esi,                       // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x080589D4
    char _v124;                            // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    char* _v148;                           // _cfa_ffffff6c (outparam)
    char* _v152;                           // _cfa_ffffff68 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t13;                        // _t13
    signed int _t18;                       // _t18
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t13);
    _t25 = _t24 + 85953;
    _v128 = 112;
    _v148 =  &_v128;
    _v152 =  &_v124;
    _t18 = _a4 >> 1;
     *__esp = _t18;
    getsockname();
    if(_t18 == -1) {
        _v152 = 0;
        uerror(_t25, __esi, _t25 - 9496);
    }
    return alloc_sockaddr(_t25, __edi, __esi,  &_v124, _v128, -1);
}

unix_getuid()
{// addr = 0x08058A4C
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _t4 = __i686.get_pc_thunk.bx(_t3);
    getuid();
    return _t4 + _t4 + 1;
}

alloc_tm()
{// addr = 0x08058A70
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    _unknown_ _t34;                        // _t34
    intOrPtr* _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    signed int _t54;                       // _t54

    __esi = __i686.get_pc_thunk.bx(_t34);
    _t36 = caml_alloc_small(_t37 + 85799, __esi, 9, 0);
     *_t36 =  *__esi +  *__esi + 1;
    _t36[1] = __esi[1] + __esi[1] + 1;
    _t36[2] = __esi[2] + __esi[2] + 1;
    _t36[3] = __esi[3] + __esi[3] + 1;
    _t36[4] = __esi[4] + __esi[4] + 1;
    _t36[5] = __esi[5] + __esi[5] + 1;
    _t36[6] = __esi[6] + __esi[6] + 1;
    _t54 = __esi[7] + __esi[7] + 1;
     *(_t36 + 28) = _t54;
    asm("sbb edx, edx");
    _t36[8] = (_t54 & -2) + 3;
    return _t36;
}

unix_mktime(
    char* __fp0,                           // r28
    signed int* _a4                        // _cfa_4
)
{// addr = 0x08058AFD
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    char _v56;                             // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    char* _v112;                           // _cfa_ffffff90
    intOrPtr _v132;                        // _cfa_ffffff7c
    intOrPtr _v136;                        // _cfa_ffffff78 (outparam)
    _unknown_ __ebx;                       // r1
    char* __esi;                           // r5
    _unknown_ _t43;                        // _t43
    signed int* _t45;                      // _t45
    intOrPtr* _t52;                        // _t52
    _unknown_ _t55;                        // _t55
    _unknown_ _t56;                        // _t56
    intOrPtr* _t60;                        // _t60

    __fp0 = __fp0;
    __i686.get_pc_thunk.bx(_t43);
    _t56 = _t55 + 85658;
    _t45 = _a4;
    _v60 = 1;
    _v64 = 1;
    _t60 =  *((intOrPtr*)(_t56 - 24));
    _v96 =  *_t60;
     *_t60 =  &_v96;
    _v88 = 1;
    _v92 = 2;
    _v84 =  &_v60;
    _v80 =  &_v64;
    _v56 =  *_t45 >> 1;
    _v52 = _t45[1] >> 1;
    _v48 = _t45[2] >> 1;
    _v44 = _t45[3] >> 1;
    _v40 = _t45[4] >> 1;
    _v36 = _t45[5] >> 1;
    _v32 = _t45[6] >> 1;
    _v28 = _t45[7] >> 1;
    _v24 = -1;
     *__esp =  &_v56;
    mktime();
    __esi =  &_v56;
    if( &_v56 == -1) {
        _v132 = 0;
        _v136 = _t56 - 9484;
        unix_error(_t56,  &_v56, 34);
    }
    _v60 = alloc_tm();
    _v112 =  &_v56;
    asm("fild dword [ebp-0x6c]");
     *__esp = __fp0;
    _v64 = caml_copy_double();
    _t52 = caml_alloc_small(_t56,  &_v56, 2, 0);
     *_t52 = _v64;
    _t52[1] = _v60;
     *((intOrPtr*)( *((intOrPtr*)(_t56 - 24)))) = _v96;
    return _t52;
}

unix_localtime(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08058C0E
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v30;                        // _cfa_ffffffe2
    short _v32;                            // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ _t8;                         // _t8
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    __i686.get_pc_thunk.bx(_t8);
    _t18 = _t17 + 85386;
    asm("fnstcw word [ebp-0x1a]");
    _v32 = 12;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp dword [ebp-0xc]");
    asm("fldcw word [ebp-0x1a]");
     *__esp =  &_v16;
    localtime();
    if( &_v16 == 0) {
        _v52 = 0;
        _v56 = _t18 - 9477;
        unix_error(_t18, __esi, 22);
    }
    return alloc_tm();
}

unix_gmtime(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08058C73
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v30;                        // _cfa_ffffffe2
    short _v32;                            // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ _t8;                         // _t8
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    __i686.get_pc_thunk.bx(_t8);
    _t18 = _t17 + 85285;
    asm("fnstcw word [ebp-0x1a]");
    _v32 = 12;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp dword [ebp-0xc]");
    asm("fldcw word [ebp-0x1a]");
     *__esp =  &_v16;
    gmtime();
    if( &_v16 == 0) {
        _v52 = 0;
        _v56 = _t18 - 9467;
        unix_error(_t18, __esi, 22);
    }
    return alloc_tm();
}

unix_initgroups(
    _unknown_ __esi,                       // r5
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08058CD8
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    intOrPtr _t10;                         // _t10
    _unknown_ _t14;                        // _t14
    _unknown_ _t15;                        // _t15

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t6);
    _t15 = _t14 + 85184;
    _v24 = _a8 >> 1;
    _t10 = _a4;
     *__esp = _t10;
    initgroups();
    if(_t10 == -1) {
        _v24 = 0;
        uerror(_t15, __esi, _t15 - 9460);
    }
    return 1;
}

unix_isatty(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08058D24
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    signed int _t5;                        // _t5
    _unknown_ _t8;                         // _t8

    __i686.get_pc_thunk.bx(_t2);
    _t5 = _a4 >> 1;
     *__esp = _t5;
    isatty();
    asm("sbb eax, eax");
    return (_t5 & -2) + 3;
}

signed long long* unix_convert_itimer(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x08058D54
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    signed long long* _t10;                // _t10
    _unknown_ _t12;                        // _t12
    signed long long _t18;                 // _t18

    _v12 = __ebx;
    _v8 = __esi;
    _t9 = __i686.get_pc_thunk.bx(_t8);
    _t12 = __ebx + 85055;
    _t10 = caml_alloc_small(_t12, _t9, 4, 254);
    asm("fild dword [esi]");
    asm("fild dword [esi+0x4]");
    _t18 =  *(_t12 - 9500) / st0;
    asm("fxch st0, st1");
    asm("faddp st2, st0");
    asm("fxch st0, st1");
     *_t10 = _t18;
    asm("fild dword [esi+0x8]");
    asm("fild dword [esi+0xc]");
    asm("fdivrp st2, st0");
    asm("faddp st1, st0");
    _t10[1] = _t18;
    return _t10;
}

unix_getitimer(
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x08058DAD
    char _v28;                             // _cfa_ffffffe4
    char* _v40;                            // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ _t10;                        // _t10
    intOrPtr _t15;                         // _t15
    _unknown_ _t20;                        // _t20

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t10);
    _t21 = _t20 + 84971;
    _v40 =  &_v28;
    _t15 =  *((intOrPtr*)(_t20 + 84971 + (_a4 >> 1) * 4 - 9428));
     *__esp = _t15;
    getitimer();
    if(_t15 == -1) {
        _v40 = 0;
        uerror(_t21, __esi, _t21 - 9449);
    }
    return unix_convert_itimer(_t21, __esi);
}

unix_set_timeval(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed long long _a4                   // _cfa_4
)
{// addr = 0x08058E03
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed long long _v36;                 // _cfa_ffffffdc
    _unknown_ _v46;                        // _cfa_ffffffd2
    short _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char* _v68;                            // _cfa_ffffffbc
    _unknown_ _t20;                        // _t20
    intOrPtr _t27;                         // _t27
    intOrPtr _t32;                         // _t32
    intOrPtr* _t36;                        // _t36

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t36 = __i686.get_pc_thunk.bx(_t20);
    _v68 =  &_v36;
     *__esp = _a4;
    modf();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = 12;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x30]");
    asm("fldcw word [ebp-0x2a]");
    _t32 = _v52;
     *_t36 = _t32;
     *__esp = _v36 *  *(__ebx + 84877 - 9500);
    ceil();
    asm("fnstcw word [ebp-0x2a]");
    _v48 = 12;
    asm("fldcw word [ebp-0x2c]");
    asm("fistp dword [ebp-0x30]");
    asm("fldcw word [ebp-0x2a]");
    _t27 = _v52;
    _t36[1] = _t27;
    if(_t27 > 999999) {
         *_t36 = _t32 + 1;
        _t36[1] = 0;
    }
    return _t27;
}

unix_setitimer(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x08058E99
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc
    char _v44;                             // _cfa_ffffffd4
    char _v60;                             // _cfa_ffffffc4
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    _unknown_ _t21;                        // _t21
    intOrPtr _t30;                         // _t30
    intOrPtr _t36;                         // _t36
    long long* _t42;                       // _t42

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t21);
    _t36 = __ebx + 84727;
    _t42 = _a8;
     *__esp =  *_t42;
    unix_set_timeval(_t36,  &_v44, _t42);
     *__esp =  *((long long*)(_t42 + 8));
    unix_set_timeval(_t36,  &_v44, _t42);
    _v68 =  &_v60;
    _v72 =  &_v44;
    _t30 =  *((intOrPtr*)(_t36 + (_a4 >> 1) * 4 - 9428));
     *__esp = _t30;
    setitimer();
    if(_t30 == -1) {
        _v72 = 0;
        uerror(_t36, _t42, _t36 - 9439);
    }
    return unix_convert_itimer(_t36, _t42);
}

unix_kill(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08058F24
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    signed int _t12;                       // _t12
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t6);
    _t17 = _t16 + 84596;
    _v24 = caml_convert_signal_number(_a8 >> 1);
    _t12 = _a4 >> 1;
     *__esp = _t12;
    kill();
    if(_t12 == -1) {
        _v24 = 0;
        uerror(_t17, __esi, _t17 - 9416);
    }
    return 1;
}

unix_link(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08058F7C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t10;                        // _t10
    intOrPtr _t12;                         // _t12
    _unknown_ _t17;                        // _t17
    intOrPtr _t20;                         // _t20

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t10);
    _t17 = __ebx + 84503;
    _t20 = _a8;
    _v24 = _t20;
    _t12 = _a4;
     *__esp = _t12;
    link();
    if(_t12 == -1) {
        _v24 = _t20;
        uerror(_t17, _t20, _t17 - 9320);
    }
    return 1;
}

unix_listen(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08058FCC
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    signed int _t11;                       // _t11
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t6);
    _t16 = _t15 + 84428;
    _v24 = _a8 >> 1;
    _t11 = _a4 >> 1;
     *__esp = _t11;
    listen();
    if(_t11 == -1) {
        _v24 = 0;
        uerror(_t16, __esi, _t16 - 9411);
    }
    return 1;
}

unix_lockf(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805901C
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    short _v34;                            // _cfa_ffffffde
    signed int _v56;                       // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21
    signed int _t23;                       // _t23
    signed int _t27;                       // _t27
    _unknown_ _t28;                        // _t28
    signed int _t39;                       // _t39

    __i686.get_pc_thunk.bx(_t18);
    _t29 = _t28 + 84347;
    _t39 = _a4 >> 1;
    _v34 = 1;
    _t21 = _a12 >> 1;
    if(_t28 + 84347 >= 0) {
        _v32 = 0;
        _v28 = 0;
        _v24 = _t21;
        _v20 = _t21 >> 31;
    } else {
        _v32 = _t21;
        _v28 = _t21 >> 31;
        _t27 =  ~_t21;
        _v24 = _t27;
        _v20 = _t27 >> 31;
    }
    _t23 = _a8 >> 1;
    if(_t23 <= 5) {
        goto __edx;
    }
    __errno_location();
     *_t23 = 22;
    _v56 = 0;
    uerror(_t29, _t39, _t29 - 9404);
    return 1;
}

unix_lseek_64(
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080591D8
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ _t21;                        // _t21
    intOrPtr _t23;                         // _t23
    signed int _t29;                       // _t29

    __edx = __edx;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t21);
    _t37 = __ebx + 83896;
    _t23 = _a8;
    caml_enter_blocking_section();
    _v32 =  *((intOrPtr*)(__ebx + 83896 + (_a12 >> 1) * 4 - 9392));
    _v40 =  *((intOrPtr*)(_t23 + 4));
    _v36 =  *((intOrPtr*)(_t23 + 8));
    _t29 = _a4 >> 1;
     *__esp = _t29;
    lseek64();
    _t45 = _t29;
    caml_leave_blocking_section();
    if((_t29 & __edx) == -1) {
        _v40 = 0;
        uerror(_t37, _t29, _t37 - 9398);
    }
    return caml_copy_int64(_t37, _t29, _t29, __edx);
}

unix_lseek(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08059266
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    _unknown_ _t23;                        // _t23
    signed int _t30;                       // _t30
    signed int _t32;                       // _t32
    _unknown_ _t42;                        // _t42
    signed int _t45;                       // _t45
    signed int _t47;                       // _t47
    signed int _t50;                       // _t50

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t23);
    _t42 = __ebx + 83754;
    caml_enter_blocking_section();
    _v32 =  *((intOrPtr*)(_t42 + (_a12 >> 1) * 4 - 9392));
    _t30 = _a8 >> 1;
    _v40 = _t30;
    _t45 = _t30 >> 31;
    _v36 = _t45;
    _t32 = _a4 >> 1;
     *__esp = _t32;
    lseek64();
    _t47 = _t32;
    _t50 = _t45;
    caml_leave_blocking_section();
    if((_t47 & _t50) == -1) {
        _v40 = 0;
        uerror(_t42, _t50, _t42 - 9398);
    }
    if(_t50 >= 0 && (_t50 > 0 || _t47 > 1073741823)) {
        _v36 = 0;
        _v40 = _t42 - 9398;
        unix_error(_t42, _t50, 75);
    }
    return _t47 + _t47 + 1;
}

unix_mkdir(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805931C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t10;                        // _t10
    signed int _t13;                       // _t13
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t10);
    _t18 = __ebx + 83575;
    _t21 = _a4;
    _t13 = _a8 >> 1;
    _v24 = _t13;
     *__esp = _t21;
    mkdir();
    if(_t13 == -1) {
        _v24 = _t21;
        uerror(_t18, _t21, _t18 - 9380);
    }
    return 1;
}

unix_mkfifo(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08059370
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t10;                        // _t10
    signed int _t13;                       // _t13
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t10);
    _t18 = __ebx + 83491;
    _t21 = _a4;
    _t13 = _a8 >> 1;
    _v24 = _t13;
     *__esp = _t21;
    mkfifo();
    if(_t13 == -1) {
        _v24 = _t21;
        uerror(_t18, _t21, _t18 - 9374);
    }
    return 1;
}

unix_nice(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x080593C4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t10;                        // _t10
    intOrPtr* _t11;                        // _t11
    signed int _t13;                       // _t13
    _unknown_ _t17;                        // _t17
    intOrPtr* _t20;                        // _t20

    _v12 = __ebx;
    _v8 = __esi;
    _t11 = __i686.get_pc_thunk.bx(_t10);
    _t17 = __ebx + 83407;
    __errno_location();
    _t20 = _t11;
     *_t11 = 0;
    _t13 = _a4 >> 1;
     *__esp = _t13;
    nice();
    if(_t13 == -1 &&  *_t20 != 0) {
        _v24 = 0;
        _t13 = uerror(_t17, _t20, _t17 - 9367);
    }
    return _t13 + _t13 + 1;
}

unix_open(
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08059424
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    char __edi;                            // r4
    intOrPtr __esi;                        // r5
    _unknown_ _t32;                        // _t32
    intOrPtr* _t34;                        // _t34
    signed int _t48;                       // _t48
    _unknown_ _t56;                        // _t56
    _unknown_ _t57;                        // _t57

    __i686.get_pc_thunk.bx(_t32);
    _t57 = _t56 + 83314;
    _t34 =  *((intOrPtr*)(_t57 - 24));
    __edi =  *_t34;
    _v60 = __edi;
     *_t34 =  &_v60;
    _v52 = 1;
    _v56 = 3;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v64 = caml_convert_flag_list(_a8, _t57 + 26236);
    __esi = caml_stat_alloc(caml_string_length(_a4) + 1, caml_string_length(_a4) + 1);
    _v88 = _a4;
     *__esp = __esi;
    strcpy();
    caml_enter_blocking_section();
    _t48 = _a12 >> 1;
    _v84 = _t48;
    _v88 = _v64;
     *__esp = __esi;
    open64();
    _v64 = _t48;
    caml_leave_blocking_section();
    caml_stat_free(__esi);
    if(_v64 == -1) {
        _v88 = _a4;
        uerror(_t57, __esi, _t57 - 9362);
    }
     *((intOrPtr*)( *((intOrPtr*)(_t57 - 24)))) = __edi;
    return _v64 + _v64 + 1;
}

unix_opendir(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08059508
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ _t11;                        // _t11
    intOrPtr _t12;                         // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t17;                        // _t17
    intOrPtr _t20;                         // _t20
    intOrPtr _t23;                         // _t23

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t12 = __i686.get_pc_thunk.bx(_t11);
    _t17 = __ebx + 83080;
    _t20 = _a4;
     *__esp = _t20;
    opendir();
    _t23 = _t12;
    if(_t12 == 0) {
        _v40 = _t20;
        uerror(_t17, _t23, _t17 - 9357);
    }
    _t13 = caml_alloc_small(_t17, _t23, 1, 251);
     *_t13 = _t23;
    return _t13;
}

intOrPtr* unix_pipe(
    _unknown_ __esi                        // r5
)
{// addr = 0x08059568
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t12;                        // _t12
    intOrPtr* _t15;                        // _t15
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t12);
    _t19 = _t18 + 82992;
     *__esp =  &_v20;
    pipe();
    if( &_v20 == -1) {
        _v40 = 0;
        uerror(_t19, __esi, _t19 - 9349);
    }
    _t15 = caml_alloc_small(_t19, __esi, 2, 0);
     *_t15 = _v20 + _v20 + 1;
    _t15[1] = _v16 + _v16 + 1;
    return _t15;
}

unix_putenv(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080595D0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ _t27;                        // _t27
    intOrPtr _t32;                         // _t32
    intOrPtr _t40;                         // _t40
    _unknown_ _t46;                        // _t46
    intOrPtr _t49;                         // _t49
    intOrPtr _t52;                         // _t52

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t27);
    _t46 = __ebx + 82880;
    _t49 = caml_string_length(_a4);
    _t32 = caml_string_length(_a8);
    _v32 = _t32;
    _t33 = _t32 + _t49;
    _v36 = _t32 + _t49;
    _t52 = caml_stat_alloc(_t33 + 2, _t33 + 2);
    _v52 = _t49;
    _v56 = _a4;
     *__esp = _t52;
    memmove();
     *((char*)(_t52 + _t49)) = 61;
    _v52 = _v32;
    _v56 = _a8;
     *__esp = _t52 + _t49 + 1;
    memmove();
    _t40 = _v36;
     *((char*)(_t52 + _t40 + 1)) = 0;
     *__esp = _t52;
    putenv();
    if(_t40 == -1) {
        _v56 = _a4;
        uerror(_t46, _t52, _t46 - 9344);
    }
    return 1;
}

unix_read(
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x08059684
    char _v16396;                          // _cfa_ffffbff4
    char* _v16416;                         // _cfa_ffffbfe0
    intOrPtr _v16420;                      // _cfa_ffffbfdc
    intOrPtr _v16424;                      // _cfa_ffffbfd8
    char _v16428;                          // _cfa_ffffbfd4
    signed int _v16436;                    // _cfa_ffffbfcc
    char* _v16440;                         // _cfa_ffffbfc8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t25;                        // _t25
    intOrPtr* _t27;                        // _t27
    signed int _t33;                       // _t33
    _unknown_ _t43;                        // _t43
    _unknown_ _t44;                        // _t44
    signed int _t49;                       // _t49
    signed int _t51;                       // _t51

    __i686.get_pc_thunk.bx(_t25);
    _t44 = _t43 + 82704;
    _t27 =  *((intOrPtr*)(_t44 - 24));
    _v16428 =  *_t27;
     *_t27 =  &_v16428;
    _v16420 = 1;
    _v16424 = 1;
    _v16416 =  &_a8;
    _t49 = _a16 >> 1;
    caml_enter_blocking_section();
    _t50 = _t49 - 16384 > 0 ? 16384 : _t49;
    _v16436 = _t49 - 16384 > 0 ? 16384 : _t49;
    _v16440 =  &_v16396;
    _t33 = _a4 >> 1;
     *__esp = _t33;
    read();
    _t51 = _t33;
    caml_leave_blocking_section();
    if(_t51 == -1) {
        _v16440 = 0;
        uerror(_t44, _t51, _t44 - 9337);
    }
    _v16436 = _t51;
    _v16440 =  &_v16396;
     *__esp = (_a12 >> 1) + _a8;
    memmove();
     *((intOrPtr*)( *((intOrPtr*)(_t44 - 24)))) = _v16428;
    return _t51 + _t51 + 1;
}

unix_readdir(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805975C
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t5;                         // _t5
    intOrPtr _t8;                          // _t8
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __i686.get_pc_thunk.bx(_t5);
    _t13 = _t12 + 82492;
    _t8 =  *_a4;
    if(_t8 == 0) {
        _v20 = 0;
        _v24 = _t13 - 9332;
        _t8 = unix_error(_t13, __esi, 9);
    }
     *__esp = _t8;
    readdir64();
    if(_t8 == 0) {
        _t8 = caml_raise_end_of_file();
    }
    return caml_copy_string(_t13, __edi, __esi, _t8 + 19);
}

unix_readlink(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080597B8
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v4108;                           // _cfa_ffffeff4
    intOrPtr _v4116;                       // _cfa_ffffefec
    char* _v4120;                          // _cfa_ffffefe8
    _unknown_ _t14;                        // _t14
    char* _t16;                            // _t16
    _unknown_ _t21;                        // _t21
    intOrPtr _t24;                         // _t24

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t14);
    _t21 = __ebx + 82392;
    _t24 = _a4;
    _v4116 = 4095;
    _t16 =  &_v4108;
    _v4120 =  &_v4108;
     *__esp = _t24;
    readlink();
    if( &_v4108 == -1) {
        _v4120 = _t24;
        _t16 = uerror(_t21, _t24, _t21 - 9324);
    }
     *((char*)(__ebp + _t16 - 4104)) = 0;
    return caml_copy_string(_t21, __edi, _t24,  &_v4108);
}

unix_rename(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08059828
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t10;                        // _t10
    intOrPtr _t12;                         // _t12
    _unknown_ _t17;                        // _t17
    intOrPtr _t20;                         // _t20

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t10);
    _t17 = __ebx + 82283;
    _t20 = _a4;
    _t12 = _a8;
    _v24 = _t12;
     *__esp = _t20;
    rename();
    if(_t12 == -1) {
        _v24 = _t20;
        uerror(_t17, _t20, _t17 - 9315);
    }
    return 1;
}

unix_rewinddir(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08059878
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t5;                         // _t5
    intOrPtr _t8;                          // _t8
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    __i686.get_pc_thunk.bx(_t5);
    _t12 = _t11 + 82208;
    _t8 =  *_a4;
    if(_t8 == 0) {
        _v20 = 0;
        _v24 = _t12 - 9308;
        _t8 = unix_error(_t12, __esi, 9);
    }
     *__esp = _t8;
    rewinddir();
    return 1;
}

unix_rmdir(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080598C4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t14;                        // _t14
    intOrPtr _t17;                         // _t17

    _v12 = __ebx;
    _v8 = __esi;
    _t9 = __i686.get_pc_thunk.bx(_t8);
    _t14 = __ebx + 82127;
    _t17 = _a4;
     *__esp = _t17;
    rmdir();
    if(_t9 == -1) {
        _v24 = _t17;
        uerror(_t14, _t17, _t14 - 9298);
    }
    return 1;
}

signed int fdlist_to_fdset(
    signed int* __eax,                     // r0
    intOrPtr __edx,                        // r3
    signed int* _a4                        // _cfa_4
)
{// addr = 0x0805990C
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t14;                       // _t14
    signed int* _t22;                      // _t22
    signed int* _t24;                      // _t24
    signed int _t27;                       // _t27

    _v16 = __edx;
    _t14 = 0;
    asm("cld");
    _push(32 << 2);
    _push(0);
    _push(__edx);
    memset();
    __esp = __esp + 12;
    if(__eax != 1) {
        _t24 = __eax;
        do {
            _t27 =  *_t24;
            _t14 = _t27 >> 1;
            _t35 = _t14 >= 0 ? _t14 : _t14 + 31;
            _t36 = (_t14 >= 0 ? _t14 : _t14 + 31) >> 5;
            _t29 = _t27 >> 31 >> 27;
             *(_v16 + _t36 * 4) =  *(_v16 + ((_t14 >= 0 ? _t14 : _t14 + 31) >> 5) * 4) | 1 << (_t14 + (_t27 >> 31 >> 27) & 31) - _t29;
            _t22 = _a4;
            if(_t14 >  *_t22) {
                 *_t22 = _t14;
            }
            _t24 = _t24[1];
        } while(_t24 != 1);
    }
    return _t14;
}

fdset_to_fdlist(
    _unknown_ __edx                        // r3
)
{// addr = 0x08059975
    signed int* _v32;                      // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    char _v68;                             // _cfa_ffffffbc
    _unknown_ _v88;                        // _cfa_ffffffa8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t29;                        // _t29
    signed int* _t30;                      // _t30
    signed int _t33;                       // _t33
    intOrPtr* _t37;                        // _t37
    _unknown_ _t38;                        // _t38
    _unknown_ _t39;                        // _t39
    intOrPtr* _t46;                        // _t46
    signed int _t52;                       // _t52
    signed int _t57;                       // _t57

    _t30 = __i686.get_pc_thunk.bx(_t29);
    _t39 = _t38 + 81953;
    _v36 = 1;
    _t46 =  *((intOrPtr*)(_t39 - 24));
    _v68 =  *_t46;
     *_t46 =  &_v68;
    _v60 = 1;
    _v64 = 2;
    _v56 =  &_v32;
    _v52 =  &_v36;
    if(_t30 != 1) {
        _v32 = _t30;
        while(1) {
            _t33 =  *_t30;
            _t57 = _t33 >> 1;
            _t51 = _t57 >= 0 ? _t57 : _t57 + 31;
            _t52 = (_t57 >= 0 ? _t57 : _t57 + 31) >> 5;
            asm("bt edx, ecx");
            if((_t57 + (_t33 >> 31 >> 27) & 31) - (_t33 >> 31 >> 27) < 0) {
                _t37 = caml_alloc_small(_t39, _t57, 2, 0);
                 *_t37 = _t57 + _t57 + 1;
                 *((intOrPtr*)(_t37 + 4)) = _v36;
                _v36 = _t37;
            }
            _t30 = _v32[1];
            if(_t30 == 1) {
                goto L6;
            }
            _v32 = _t30;
        }
    }
L6:
     *((intOrPtr*)( *((intOrPtr*)(_t39 - 24)))) = _v68;
    return _v36;
}

unix_select(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    long long* _a16                        // _cfa_10
)
{// addr = 0x08059A34
    char _v140;                            // _cfa_ffffff74
    char _v268;                            // _cfa_fffffef4
    char _v396;                            // _cfa_fffffe74
    char _v400;                            // _cfa_fffffe70
    char _v408;                            // _cfa_fffffe68
    char* _v420;                           // _cfa_fffffe5c
    char* _v424;                           // _cfa_fffffe58
    char* _v428;                           // _cfa_fffffe54
    intOrPtr _v432;                        // _cfa_fffffe50
    intOrPtr _v436;                        // _cfa_fffffe4c
    char _v440;                            // _cfa_fffffe48
    _unknown_ _v446;                       // _cfa_fffffe42
    short _v448;                           // _cfa_fffffe40
    char _v452;                            // _cfa_fffffe3c
    intOrPtr _v476;                        // _cfa_fffffe24
    char* _v480;                           // _cfa_fffffe20
    char* _v484;                           // _cfa_fffffe1c
    char* _v488;                           // _cfa_fffffe18 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t55;                        // _t55
    intOrPtr* _t57;                        // _t57
    intOrPtr _t73;                         // _t73
    intOrPtr* _t81;                        // _t81
    char _t86;                             // _t86
    _unknown_ _t87;                        // _t87
    _unknown_ _t88;                        // _t88
    char* _t102;                           // _t102
    long long _t106;                       // _t106

    __i686.get_pc_thunk.bx(_t55);
    _t88 = _t87 + 81760;
    _t57 =  *((intOrPtr*)(_t88 - 24));
    _v440 =  *_t57;
     *_t57 =  &_v440;
    _v432 = 1;
    _v436 = 3;
    _v428 =  &_a4;
    _v424 =  &_a8;
    _v420 =  &_a12;
    _v400 = -1;
    fdlist_to_fdset(_a4,  &_v140,  &_v400);
    fdlist_to_fdset(_a8,  &_v268,  &_v400);
    fdlist_to_fdset(_a12,  &_v396,  &_v400);
    _t106 =  *_a16;
    _t102 = 0;
    asm("fldz");
    asm("fucomip st0, st1");
    if(_t88 > 0) {
        st0 = _t106;
    } else {
        asm("fnstcw word [ebp-0x1ba]");
        _v448 = 12;
        asm("fldcw word [ebp-0x1bc]");
        asm("fist dword [ebp-0x1c0]");
        asm("fldcw word [ebp-0x1ba]");
        _t86 = _v452;
        _v408 = _t86;
        _v452 = _t86;
        asm("fild dword [ebp-0x1c0]");
        asm("fsubp st1, st0");
        asm("fldcw word [ebp-0x1bc]");
        asm("fistp dword [ebp-0x190]");
        asm("fldcw word [ebp-0x1ba]");
        _t102 =  &_v408;
    }
    caml_enter_blocking_section();
    _v476 = _t102;
    _v480 =  &_v396;
    _v484 =  &_v268;
    _v488 =  &_v140;
    _t73 = _v400 + 1;
     *__esp = _t73;
    select();
    _t103 = _t73;
    caml_leave_blocking_section();
    if(_t73 == -1) {
        _v488 = 0;
        uerror(_t88, _t73, _t88 - 9292);
    }
    _a4 = fdset_to_fdlist( &_v140);
    _a8 = fdset_to_fdlist( &_v268);
    _a12 = fdset_to_fdlist( &_v396);
    _t81 = caml_alloc_small(_t88, _t73, 3, 0);
     *_t81 = _a4;
    _t81[1] = _a8;
    _t81[2] = _a12;
     *((intOrPtr*)( *((intOrPtr*)(_t88 - 24)))) = _v440;
    return _t81;
}

unix_sendto_native(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr _a20,                         // _cfa_14
    intOrPtr _a24                          // _cfa_18
)
{// addr = 0x08059C10
    char _v16412;                          // _cfa_ffffbfe4
    char _v16524;                          // _cfa_ffffbf74
    char _v16528;                          // _cfa_ffffbf70
    char* _v16544;                         // _cfa_ffffbf60
    intOrPtr _v16548;                      // _cfa_ffffbf5c
    intOrPtr _v16568;                      // _cfa_ffffbf48
    char* _v16572;                         // _cfa_ffffbf44
    intOrPtr _v16576;                      // _cfa_ffffbf40
    intOrPtr _v16580;                      // _cfa_ffffbf3c (outparam)
    intOrPtr _v16584;                      // _cfa_ffffbf38 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t31;                        // _t31
    signed int _t49;                       // _t49
    _unknown_ _t54;                        // _t54
    _unknown_ _t56;                        // _t56
    intOrPtr _t59;                         // _t59
    signed int _t61;                       // _t61

    __i686.get_pc_thunk.bx(_t31);
    _t55 = _t54 + 81283;
    _v16548 = caml_convert_flag_list(_a20, _t54 + 0x1a42f);
    get_sockaddr(_t55, _t56,  &_v16524, _a24,  &_v16524,  &_v16528);
    _t59 = _a16 >> 1 - 16384 > 0 ? 16384 : _a16 >> 1;
    _v16580 = _t59;
    _v16584 = (_a12 >> 1) + _a8;
    _v16544 =  &_v16412;
     *__esp =  &_v16412;
    memmove();
    caml_enter_blocking_section();
    _v16568 = _v16528;
    _v16572 =  &_v16524;
    _v16576 = _v16548;
    _v16580 = _t59;
    _v16584 = _v16544;
    _t49 = _a4 >> 1;
     *__esp = _t49;
    sendto();
    _t61 = _t49;
    caml_leave_blocking_section();
    if(_t61 == -1) {
        _v16584 = 0;
        uerror(_t55, _t61, _t55 - 9285);
    }
    return _t61 + _t61 + 1;
}

unix_sendto(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08059D01
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t12;                        // _t12
    _unknown_ _t17;                        // _t17

    __i686.get_pc_thunk.bx(_t12);
    return unix_sendto_native( *_a4,  *((intOrPtr*)(_t14 + 4)),  *((intOrPtr*)(_t14 + 8)),  *((intOrPtr*)(_t14 + 12)),  *((intOrPtr*)(_t14 + 16)),  *((intOrPtr*)(_t14 + 20)));
}

unix_send(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{// addr = 0x08059D49
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v16412;                          // _cfa_ffffbfe4
    intOrPtr _v16416;                      // _cfa_ffffbfe0
    intOrPtr _v16432;                      // _cfa_ffffbfd0
    intOrPtr _v16436;                      // _cfa_ffffbfcc
    char* _v16440;                         // _cfa_ffffbfc8 (outparam)
    _unknown_ _t27;                        // _t27
    signed int _t39;                       // _t39
    intOrPtr _t53;                         // _t53
    signed int _t54;                       // _t54

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t27);
    _t45 = __ebx + 80964;
    _v16416 = caml_convert_flag_list(_a20, __ebx + 0x1a2f0);
    _t53 = _a16 >> 1 - 16384 > 0 ? 16384 : _a16 >> 1;
    _v16436 = _t53;
    _v16440 = (_a12 >> 1) + _a8;
     *__esp =  &_v16412;
    memmove();
    caml_enter_blocking_section();
    _v16432 = _v16416;
    _v16436 = _t53;
    _v16440 =  &_v16412;
    _t39 = _a4 >> 1;
     *__esp = _t39;
    send();
    _t54 = _t39;
    caml_leave_blocking_section();
    if(_t54 == -1) {
        _v16440 = 0;
        uerror(_t45, _t54, _t45 - 9278);
    }
    return _t54 + _t54 + 1;
}

unix_recvfrom(
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{// addr = 0x08059E09
    char _v16412;                          // _cfa_ffffbfe4
    char _v16416;                          // _cfa_ffffbfe0
    char _v16528;                          // _cfa_ffffbf70
    char _v16532;                          // _cfa_ffffbf6c
    char* _v16548;                         // _cfa_ffffbf5c
    char* _v16552;                         // _cfa_ffffbf58
    intOrPtr _v16556;                      // _cfa_ffffbf54
    intOrPtr _v16560;                      // _cfa_ffffbf50
    char _v16564;                          // _cfa_ffffbf4c
    char* _v16584;                         // _cfa_ffffbf38
    char* _v16588;                         // _cfa_ffffbf34
    intOrPtr _v16592;                      // _cfa_ffffbf30
    signed int _v16596;                    // _cfa_ffffbf2c (outparam)
    char* _v16600;                         // _cfa_ffffbf28 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t45;                        // _t45
    intOrPtr* _t50;                        // _t50
    signed int _t59;                       // _t59
    intOrPtr* _t68;                        // _t68
    _unknown_ _t71;                        // _t71
    _unknown_ _t72;                        // _t72
    signed int _t79;                       // _t79
    signed int _t81;                       // _t81

    __i686.get_pc_thunk.bx(_t45);
    _t72 = _t71 + 80778;
    _v16416 = 1;
    __edi = caml_convert_flag_list(_a20, _t72 + 26284);
    _t50 =  *((intOrPtr*)(_t72 - 24));
    _v16564 =  *_t50;
     *_t50 =  &_v16564;
    _v16556 = 1;
    _v16560 = 2;
    _v16552 =  &_a8;
    _v16548 =  &_v16416;
    _t79 = _a16 >> 1;
    _v16532 = 112;
    caml_enter_blocking_section();
    _v16584 =  &_v16532;
    _v16588 =  &_v16528;
    _v16592 = __edi;
    _t80 = _t79 - 16384 > 0 ? 16384 : _t79;
    _v16596 = _t79 - 16384 > 0 ? 16384 : _t79;
    _v16600 =  &_v16412;
    _t59 = _a4 >> 1;
     *__esp = _t59;
    recvfrom();
    _t81 = _t59;
    caml_leave_blocking_section();
    if(_t81 == -1) {
        _v16600 = 0;
        uerror(_t72, _t81, _t72 - 9273);
    }
    _v16596 = _t81;
    _v16600 =  &_v16412;
     *__esp = (_a12 >> 1) + _a8;
    memmove();
    _v16416 = alloc_sockaddr(_t72, __edi, _t81,  &_v16528, _v16532, -1);
    _t68 = caml_alloc_small(_t72, _t81, 2, 0);
     *_t68 = _t81 + _t81 + 1;
    _t68[1] = _v16416;
     *((intOrPtr*)( *((intOrPtr*)(_t72 - 24)))) = _v16564;
    return _t68;
}

unix_recv(
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{// addr = 0x08059F77
    char _v16412;                          // _cfa_ffffbfe4
    char* _v16432;                         // _cfa_ffffbfd0
    intOrPtr _v16436;                      // _cfa_ffffbfcc
    intOrPtr _v16440;                      // _cfa_ffffbfc8
    char _v16444;                          // _cfa_ffffbfc4
    intOrPtr _v16448;                      // _cfa_ffffbfc0
    signed int _v16452;                    // _cfa_ffffbfbc
    char* _v16456;                         // _cfa_ffffbfb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t29;                        // _t29
    intOrPtr _t33;                         // _t33
    intOrPtr* _t34;                        // _t34
    signed int _t40;                       // _t40
    _unknown_ _t50;                        // _t50
    _unknown_ _t51;                        // _t51
    signed int _t56;                       // _t56
    signed int _t58;                       // _t58

    __i686.get_pc_thunk.bx(_t29);
    _t51 = _t50 + 80412;
    _t33 = caml_convert_flag_list(_a20, _t51 + 26284);
    _t34 =  *((intOrPtr*)(_t51 - 24));
    _v16444 =  *_t34;
     *_t34 =  &_v16444;
    _v16436 = 1;
    _v16440 = 1;
    _v16432 =  &_a8;
    _t56 = _a16 >> 1;
    caml_enter_blocking_section();
    _v16448 = _t33;
    _t57 = _t56 - 16384 > 0 ? 16384 : _t56;
    _v16452 = _t56 - 16384 > 0 ? 16384 : _t56;
    _v16456 =  &_v16412;
    _t40 = _a4 >> 1;
     *__esp = _t40;
    recv();
    _t58 = _t40;
    caml_leave_blocking_section();
    if(_t58 == -1) {
        _v16456 = 0;
        uerror(_t51, _t58, _t51 - 9264);
    }
    _v16452 = _t58;
    _v16456 =  &_v16412;
     *__esp = (_a12 >> 1) + _a8;
    memmove();
     *((intOrPtr*)( *((intOrPtr*)(_t51 - 24)))) = _v16444;
    return _t58 + _t58 + 1;
}

unix_setgid(
    _unknown_ __esi,                       // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805A06C
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    signed int _t7;                        // _t7
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t4);
    _t12 = _t11 + 80172;
    _t7 = _a4 >> 1;
     *__esp = _t7;
    setgid();
    if(_t7 == -1) {
        _v24 = 0;
        uerror(_t12, __esi, _t12 - 9259);
    }
    return 1;
}

unix_setgroups(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805A0B4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v56;                       // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t14;                        // _t14
    signed int _t17;                       // _t17
    signed int _t18;                       // _t18
    _unknown_ _t24;                        // _t24
    _unknown_ _t25;                        // _t25
    signed int _t29;                       // _t29
    intOrPtr _t30;                         // _t30

    __i686.get_pc_thunk.bx(_t14);
    _t25 = _t24 + 80098;
    _t30 = _a4;
    _t29 =  *(_t30 - 4) >> 10;
    _t17 = caml_stat_alloc(_t29 * 4, _t29 * 4);
    _v32 = _t17;
    if(_t29 != 0) {
        __edx = 0;
        do {
             *(_t17 + __edx * 4) =  *(_t30 + __edx * 4) >> 1;
            __edx = __edx + 1;
        } while(_t29 > __edx);
    }
    _t18 = _v32;
    _v56 = _t18;
     *__esp = _t29;
    setgroups();
    _t31 = _t18;
    caml_stat_free(_v32);
    if(_t18 == -1) {
        _v56 = 0;
        uerror(_t25, _t18, _t25 - 9252);
    }
    return 1;
}

unix_setsid()
{// addr = 0x0805A140
    _unknown_ __ebx;                       // r1
    _unknown_ _t3;                         // _t3
    _unknown_ _t4;                         // _t4
    _unknown_ _t6;                         // _t6

    _t4 = __i686.get_pc_thunk.bx(_t3);
    setsid();
    return _t4 + _t4 + 1;
}

unix_setuid(
    _unknown_ __esi,                       // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805A164
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    signed int _t7;                        // _t7
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t4);
    _t12 = _t11 + 79924;
    _t7 = _a4 >> 1;
     *__esp = _t7;
    setuid();
    if(_t7 == -1) {
        _v24 = 0;
        uerror(_t12, __esi, _t12 - 9242);
    }
    return 1;
}

unix_shutdown(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805A1AC
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t9;                         // _t9
    signed int _t15;                       // _t15
    _unknown_ _t19;                        // _t19

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t9);
    _t20 = _t19 + 79852;
    _v24 =  *((intOrPtr*)(_t19 + 79852 + (_a8 >> 1) * 4 - 9224));
    _t15 = _a4 >> 1;
     *__esp = _t15;
    shutdown();
    if(_t15 == -1) {
        _v24 = 0;
        uerror(_t20, __esi, _t20 - 9235);
    }
    return 1;
}

signed int* decode_sigset(
    intOrPtr __edx                         // r3
)
{// addr = 0x0805A210
    signed int* _v40;                      // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    signed int* __esi;                     // r5
    _unknown_ _t3;                         // _t3
    signed int* _t4;                       // _t4
    _unknown_ _t7;                         // _t7

    __edx = __edx;
    _t4 = __i686.get_pc_thunk.bx(_t3);
    __esi = _t4;
     *__esp = __edx;
    sigemptyset();
    while(__esi != 1) {
        _t4 = caml_convert_signal_number( *__esi >> 1);
        _v40 = _t4;
         *__esp = __edx;
        sigaddset();
        __esi = __esi[1];
    }
    return _t4;
}

unix_sigsuspend(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x0805A25D
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v140;                            // _cfa_ffffff74
    intOrPtr _v152;                        // _cfa_ffffff68
    _unknown_ _t9;                         // _t9
    _unknown_ _t13;                        // _t13
    intOrPtr* _t14;                        // _t14
    _unknown_ _t19;                        // _t19

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t9);
    _t19 = __ebx + 79667;
    __edx =  &_v140;
    decode_sigset( &_v140);
    _t13 = caml_enter_blocking_section();
     *__esp =  &_v140;
    sigsuspend();
    _t23 = _t13;
    _t14 = caml_leave_blocking_section();
    if(_t13 == -1) {
        __errno_location();
        if( *_t14 != 4) {
            _v152 = 0;
            uerror(_t19, _t13, _t19 - 9212);
        }
    }
    return 1;
}

encode_sigset()
{// addr = 0x0805A2CF
    char _v32;                             // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v104;                        // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr __esi;                        // r5
    _unknown_ _t21;                        // _t21
    intOrPtr _t22;                         // _t22
    intOrPtr* _t23;                        // _t23
    intOrPtr _t25;                         // _t25
    _unknown_ _t32;                        // _t32
    _unknown_ _t33;                        // _t33

    _t22 = __i686.get_pc_thunk.bx(_t21);
    _t33 = _t32 + 79559;
    _v80 = _t22;
    _v32 = 1;
    _t23 =  *((intOrPtr*)(_t33 - 24));
    _v64 =  *_t23;
     *_t23 =  &_v64;
    _v56 = 1;
    _v60 = 1;
    _v52 =  &_v32;
    __esi = 1;
    do {
        _v104 = __esi;
        _t25 = _v80;
         *__esp = _t25;
        sigismember();
        if(_t25 > 0) {
            __edi = caml_alloc_small(_t33, __esi, 2, 0);
             *__edi = caml_rev_convert_signal_number(__esi) + _t29 + 1;
             *((intOrPtr*)(__edi + 4)) = _v32;
            _v32 = __edi;
        }
        __esi = __esi + 1;
    } while(__esi != 65);
     *((intOrPtr*)( *((intOrPtr*)(_t33 - 24)))) = _v64;
    return _v32;
}

unix_sigpending(
    _unknown_ __esi                        // r5
)
{// addr = 0x0805A374
    char _v140;                            // _cfa_ffffff74
    intOrPtr _v152;                        // _cfa_ffffff68
    _unknown_ __ebx;                       // r1
    _unknown_ _t5;                         // _t5
    _unknown_ _t12;                        // _t12
    _unknown_ _t13;                        // _t13

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t5);
    _t13 = _t12 + 79393;
     *__esp =  &_v140;
    sigpending();
    if( &_v140 == -1) {
        _v152 = 0;
        uerror(_t13, __esi, _t13 - 9201);
    }
    return encode_sigset();
}

unix_sigprocmask(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x0805A3C6
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v156;                            // _cfa_ffffff64
    char _v284;                            // _cfa_fffffee4
    char* _v292;                           // _cfa_fffffedc
    char* _v296;                           // _cfa_fffffed8
    _unknown_ _t19;                        // _t19

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t19);
    _t33 = __ebx + 79303;
    __edx =  &_v156;
    decode_sigset( &_v156);
    caml_enter_blocking_section();
    _v292 =  &_v284;
    _v296 =  &_v156;
     *__esp =  *((intOrPtr*)(__ebx + 79303 + (_a4 >> 1) * 4 - 9176));
    sigprocmask();
    caml_leave_blocking_section();
    if( &_v284 == -1) {
        _v296 = 0;
        uerror(_t33,  &_v284, _t33 - 9190);
    }
    return encode_sigset();
}

unix_sleep(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805A454
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    _unknown_ _t9;                         // _t9

    __i686.get_pc_thunk.bx(_t2);
    caml_enter_blocking_section();
     *__esp = _a4 >> 1;
    sleep();
    caml_leave_blocking_section();
    return 1;
}

intOrPtr unix_socket(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805A488
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t16;                        // _t16
    intOrPtr _t23;                         // _t23
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t16);
    _t27 = _t26 + 79120;
    _v20 = _a12 >> 1;
    _v24 =  *((intOrPtr*)( *((intOrPtr*)(_t27 - 28)) + (_a8 >> 1) * 4));
    _t23 =  *((intOrPtr*)( *((intOrPtr*)(_t27 - 32)) + (_a4 >> 1) * 4));
     *__esp = _t23;
    socket();
    if(_t23 == -1) {
        _v24 = 0;
        _t23 = uerror(_t27, __esi, _t27 - 9164);
    }
    return _t23 + _t23 + 1;
}

get_sockaddr(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4,                         // _cfa_4
    short* _a8,                            // _cfa_8
    intOrPtr* _a12                         // _cfa_c
)
{// addr = 0x0805A4F0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr* _v32;                        // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ _t41;                        // _t41
    intOrPtr* _t43;                        // _t43
    _unknown_ _t45;                        // _t45
    intOrPtr _t55;                         // _t55
    intOrPtr* _t56;                        // _t56
    _unknown_ _t61;                        // _t61
    signed int _t63;                       // _t63
    short* _t66;                           // _t66
    intOrPtr* _t72;                        // _t72
    _unknown_ _t73;                        // _t73
    short* _t77;                           // _t77

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t41);
    _t61 = __ebx + 79008;
    _t43 = _a4;
    _t77 = _a8;
    _t72 = _t43;
    _t63 =  *(_t43 - 4) & 255;
    if(_t63 == 0) {
        _t44 =  *_t43;
        _v32 =  *_t43;
        _t45 = caml_string_length(_t44);
        _t73 = _t45;
         *_t77 = 1;
        if(_t45 > 107) {
            _v52 = _v32;
            _v56 = _t61 - 5244;
            _t45 = unix_error(_t61, _t77, 36);
        }
        _v52 = _t45 + 1;
        _v56 = _v32;
         *__esp = _t77 + 2;
        memmove();
        _t43 = _a12;
         *_t43 = _t73 + 2;
    } else {
        if(_t63 == 1) {
            _v32 = _t43;
            if(caml_string_length( *_t43) != 16) {
                 *_t77 = 0;
                 *((intOrPtr*)(_t77 + 4)) = 0;
                 *((intOrPtr*)(_t77 + 8)) = 0;
                 *((intOrPtr*)(_t77 + 12)) = 0;
                 *_t77 = 2;
                 *((intOrPtr*)(_t77 + 4)) =  *((intOrPtr*)( *_v32));
                asm("ror ax, 0x8");
                _t77[1] =  *(_t72 + 4) >> 1;
                _t43 = _a12;
                 *_t43 = 16;
            } else {
                _t66 = _t77;
                _t55 = 0;
                do {
                     *((intOrPtr*)(_t66 + _t55)) = 0;
                    _t55 = _t55 + 4;
                } while(_t55 < 28);
                 *_t77 = 10;
                _t56 =  *_v32;
                 *((intOrPtr*)(_t77 + 8)) =  *_t56;
                 *((intOrPtr*)(_t77 + 12)) = _t56[1];
                 *((intOrPtr*)(_t77 + 16)) = _t56[2];
                 *((intOrPtr*)(_t77 + 20)) = _t56[3];
                asm("ror ax, 0x8");
                _t77[1] =  *(_t72 + 4) >> 1;
                _t43 = _a12;
                 *_t43 = 28;
            }
        }
    }
    return _t43;
}

alloc_inet6_addr(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805A62D
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _t12;                        // _t12
    intOrPtr* _t14;                        // _t14
    intOrPtr* _t23;                        // _t23

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t12);
    _t23 = _a4;
    _t14 = caml_alloc_string(__ebx + 78694, __edi, _t23, __fp0, 16);
     *_t14 =  *_t23;
    _t14[1] = _t23[1];
    _t14[2] = _t23[2];
    _t14[3] = _t23[3];
    return _t14;
}

alloc_inet_addr(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805A673
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    intOrPtr* _t4;                         // _t4
    _unknown_ _t5;                         // _t5

    __i686.get_pc_thunk.bx(_t2);
    _t4 = caml_alloc_string(_t5 + 78629, __edi, __esi, __fp0, 4);
     *_t4 =  *_a4;
    return _t4;
}

alloc_sockaddr(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed short* _a4,                     // _cfa_4
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805A69E
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v32;                             // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8 (outparam)
    _unknown_ _t55;                        // _t55
    signed int _t57;                       // _t57
    intOrPtr* _t63;                        // _t63
    intOrPtr _t75;                         // _t75
    intOrPtr _t77;                         // _t77
    intOrPtr* _t91;                        // _t91
    intOrPtr* _t93;                        // _t93
    signed short* _t95;                    // _t95
    intOrPtr* _t98;                        // _t98

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t55);
    _t75 = __ebx + 78578;
    _t95 = _a4;
    _t77 = _a12;
    _t57 =  *_t95 & 65535;
    if(_t57 == 2) {
        _v32 = alloc_inet_addr( &(_t95[2]));
        _t91 =  *((intOrPtr*)(_t75 - 24));
        _v64 =  *_t91;
         *_t91 =  &_v64;
        _v56 = 1;
        _v60 = 1;
        _v52 =  &_v32;
        _t63 = caml_alloc_small(_t75, _t95, 2, 1);
         *_t63 = _v32;
        asm("ror dx, 0x8");
        _t63[1] = (_t95[1] & 0xffff) + (_t95[1] & 0xffff) + 1;
         *_t91 = _v64;
    } else {
        if(_t57 == 10) {
            _v32 = alloc_inet6_addr(_t75, _t95,  &(_t95[4]));
            _t93 =  *((intOrPtr*)(_t75 - 24));
            _v64 =  *_t93;
             *_t93 =  &_v64;
            _v56 = 1;
            _v60 = 1;
            _v52 =  &_v32;
            _t63 = caml_alloc_small(_t75, _t95, 2, 1);
             *_t63 = _v32;
            asm("ror dx, 0x8");
            _t63[1] = (_t95[1] & 0xffff) + (_t95[1] & 0xffff) + 1;
             *_t93 = _v64;
        } else {
            if(_t57 != 1) {
                if(_t77 != -1) {
                     *__esp = _t77;
                    close();
                }
                _v84 = 0;
                _v88 = _t75 - 5244;
                _t63 = unix_error(_t75, _t95, 97);
            } else {
                _v32 = caml_copy_string(_t75, __edi,  &(_t95[1]),  &(_t95[1]));
                _t98 =  *((intOrPtr*)(_t75 - 24));
                _v64 =  *_t98;
                 *_t98 =  &_v64;
                _v56 = 1;
                _v60 = 1;
                _v52 =  &_v32;
                _t63 = caml_alloc_small(_t75, _t98, 1, 0);
                 *_t63 = _v32;
                 *_t98 = _v64;
            }
        }
    }
    return _t63;
}

unix_socketpair(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805A834
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char* _v32;                            // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t24;                        // _t24
    intOrPtr _t32;                         // _t32
    intOrPtr* _t33;                        // _t33
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t24);
    _t37 = _t36 + 78180;
    _v32 =  &_v20;
    _v36 = _a12 >> 1;
    _v40 =  *((intOrPtr*)( *((intOrPtr*)(_t37 - 28)) + (_a8 >> 1) * 4));
    _t32 =  *((intOrPtr*)( *((intOrPtr*)(_t37 - 32)) + (_a4 >> 1) * 4));
     *__esp = _t32;
    socketpair();
    if(_t32 == -1) {
        _v40 = 0;
        uerror(_t37, __esi, _t37 - 9157);
    }
    _t33 = caml_alloc_small(_t37, __esi, 2, 0);
     *_t33 = _v20 + _v20 + 1;
    _t33[1] = _v16 + _v16 + 1;
    return _t33;
}

unix_setsockopt_aux(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    signed int _a20,                       // _cfa_14
    signed int _a24                        // _cfa_18
)
{// addr = 0x0805A8D0
    signed int _v16;                       // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v30;                        // _cfa_ffffffe2
    short _v32;                            // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v60;                         // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ _t24;                        // _t24
    intOrPtr _t26;                         // _t26
    intOrPtr _t27;                         // _t27
    signed int _t32;                       // _t32
    signed int _t39;                       // _t39
    _unknown_ _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    signed int _t44;                       // _t44
    signed int _t45;                       // _t45

    __i686.get_pc_thunk.bx(_t24);
    _t41 = _t40 + 78023;
    __esi = _a4;
    _t26 = _a8;
    _t45 = _a24;
    if(_t26 == 2) {
        _t44 = (_t45 ^ 1) & 1;
        _v20 = _t44;
        _t27 = 8;
        if(_t44 != 0) {
            _v16 =  *_t45 >> 1;
            _t27 = 8;
        }
    } else {
        if(_t26 < 2) {
            _v20 = _t45 >> 1;
            _t27 = 4;
        } else {
            if(_t26 != 3) {
                _v68 = 0;
                _v72 = __esi;
                _t27 = unix_error(_t41, __esi, 22);
            } else {
                asm("fnstcw word [ebp-0x1a]");
                _v32 = 12;
                asm("fldcw word [ebp-0x1c]");
                asm("fist dword [ebp-0x20]");
                asm("fldcw word [ebp-0x1a]");
                _t39 = _v36;
                _v20 = _t39;
                _v36 = _t39;
                asm("fild dword [ebp-0x20]");
                asm("fsubp st1, st0");
                asm("fldcw word [ebp-0x1c]");
                asm("fistp dword [ebp-0xc]");
                asm("fldcw word [ebp-0x1a]");
                _t27 = 8;
            }
        }
    }
    _v60 = _t27;
    _v64 =  &_v20;
    _v68 = _a16;
    _v72 = _a12;
    _t32 = _a20 >> 1;
     *__esp = _t32;
    setsockopt();
    if(_t32 == -1) {
        _v72 = 0;
        uerror(_t41, __esi, __esi);
    }
    return 1;
}

unix_setsockopt(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805A9CB
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t17;                        // _t17
    signed int _t20;                       // _t20
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24

    __i686.get_pc_thunk.bx(_t17);
    _t24 = _t23 + 77773;
    _t20 = _a4 >> 1;
    return unix_setsockopt_aux( *((intOrPtr*)(_t24 + _t20 * 4 - 292)), _t20,  *((intOrPtr*)((_a12 >> 1 << 3) +  *((intOrPtr*)(_t24 + _t20 * 4 - 312)))),  *((intOrPtr*)(_t31 + 4)), _a8, _a16);
}

unix_getsockopt_aux(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    signed int _a20                        // _cfa_14
)
{// addr = 0x0805AA25
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char* _v92;                            // _cfa_ffffffa4
    char* _v96;                            // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    intOrPtr _v104;                        // _cfa_ffffff98
    _unknown_ _t29;                        // _t29
    signed int _t37;                       // _t37
    _unknown_ _t46;                        // _t46
    intOrPtr _t49;                         // _t49
    intOrPtr _t52;                         // _t52

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t29);
    _t46 = __ebx + 77675;
    _t49 = _a4;
    _t52 = _a8;
    if(_t52 <= 4) {
        goto __eax;
    }
    _v100 = 0;
    _v104 = _t49;
    unix_error(_t46, _t52, 22);
    _v92 =  &_v40;
    _v96 =  &_v36;
    _v100 = _a16;
    _v104 = _a12;
    _t37 = _a20 >> 1;
     *__esp = _t37;
    getsockopt();
    if(_t37 == -1) {
        _v104 = 0;
        uerror(_t46, _t52, _t49);
    }
    if(_t52 <= 4) {
        goto __eax;
    }
    _v100 = 0;
    _v104 = _t49;
    unix_error(_t46, _t52, 22);
    return 1;
}

unix_getsockopt(
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805ABD8
    _unknown_ _v28;                        // _cfa_ffffffe4 (outparam)
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ _t15;                        // _t15
    signed int _t18;                       // _t18
    _unknown_ _t21;                        // _t21
    intOrPtr _t22;                         // _t22

    __esi = __esi;
    __edi = __edi;
    __i686.get_pc_thunk.bx(_t15);
    _t22 = _t21 + 77248;
    _t18 = _a4 >> 1;
    return unix_getsockopt_aux(_t22, __edi, __esi,  *((intOrPtr*)(_t22 + _t18 * 4 - 272)), _t18,  *((intOrPtr*)((_a12 >> 1 << 3) +  *((intOrPtr*)(_t22 + _t18 * 4 - 312)))),  *((intOrPtr*)(_t28 + 4)), _a8);
}

stat_aux(
    intOrPtr* __edx,                       // r3
    long long __fp0                        // r28
)
{// addr = 0x0805AC2C
    char _v32;                             // _cfa_ffffffe0
    char _v36;                             // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    intOrPtr* _v96;                        // _cfa_ffffffa0
    _unknown_ _v112;                       // _cfa_ffffff90 (outparam)
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    char __edi;                            // r4
    intOrPtr* __esi;                       // r5
    _unknown_ _t89;                        // _t89
    intOrPtr* _t90;                        // _t90
    intOrPtr* _t91;                        // _t91
    intOrPtr _t101;                        // _t101
    intOrPtr* _t102;                       // _t102
    _unknown_ _t129;                       // _t129
    _unknown_ _t130;                       // _t130

    __fp0 = __fp0;
    _t90 = __i686.get_pc_thunk.bx(_t89);
    _t130 = _t129 + 77162;
    _v96 = _t90;
    __esi = __edx;
    _t91 =  *((intOrPtr*)(_t130 - 24));
    __edi =  *_t91;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    _v48 = 0;
    _v80 = __edi;
     *_t91 =  &_v80;
    _v72 = 1;
    _v76 = 5;
    _v68 =  &_v32;
    _v64 =  &_v36;
    _v60 =  &_v40;
    _v56 =  &_v44;
    _v52 =  &_v48;
    asm("fild dword [esi+0x40]");
     *__esp = __fp0;
    _v32 = caml_copy_double();
    asm("fild dword [esi+0x48]");
     *__esp = __fp0;
    _v36 = caml_copy_double();
    asm("fild dword [esi+0x50]");
     *__esp = __fp0;
    _v40 = caml_copy_double();
    if(_v96 == 0) {
        _t101 =  *((intOrPtr*)(__edx + 44)) +  *((intOrPtr*)(__edx + 44)) + 1;
    } else {
        _t101 = caml_copy_int64(_t130, __edx,  *((intOrPtr*)(__edx + 44)),  *((intOrPtr*)(__edx + 48)));
    }
    _v44 = _t101;
    _t102 = caml_alloc_small(_t130, __edx, 12, 0);
    _v48 = _t102;
     *_t102 =  *__edx +  *__edx + 1;
     *((intOrPtr*)(_v48 + 4)) =  *((intOrPtr*)(__edx + 88)) +  *((intOrPtr*)(__edx + 88)) + 1;
    _v96 = _v48 + 8;
     *_v96 = cst_to_constr( *(__edx + 16) & 61440, _t130 + 26508, 7, 0);
     *((intOrPtr*)(_v48 + 12)) = ( *(__edx + 16) & 4095) + ( *(__edx + 16) & 4095) + 1;
     *((intOrPtr*)(_v48 + 16)) =  *((intOrPtr*)(__edx + 20)) +  *((intOrPtr*)(__edx + 20)) + 1;
     *((intOrPtr*)(_v48 + 20)) =  *((intOrPtr*)(__edx + 24)) +  *((intOrPtr*)(__edx + 24)) + 1;
     *((intOrPtr*)(_v48 + 24)) =  *((intOrPtr*)(__edx + 28)) +  *((intOrPtr*)(__edx + 28)) + 1;
     *((intOrPtr*)(_v48 + 28)) =  *((intOrPtr*)(__edx + 32)) +  *((intOrPtr*)(__edx + 32)) + 1;
     *((intOrPtr*)(_v48 + 32)) = _v44;
     *((intOrPtr*)(_v48 + 36)) = _v32;
     *((intOrPtr*)(_v48 + 40)) = _v36;
     *((intOrPtr*)(_v48 + 44)) = _v40;
     *((intOrPtr*)( *((intOrPtr*)(_t130 - 24)))) = __edi;
    return _v48;
}

unix_fstat_64(
    _unknown_ __esi,                       // r5
    long long __fp0,                       // r28
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805ADD3
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ _t8;                         // _t8
    signed int _t12;                       // _t12
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18

    __fp0 = __fp0;
    __esi = __esi;
    __i686.get_pc_thunk.bx(_t8);
    _t18 = _t17 + 76741;
    _v116 =  &_v108;
    _t12 = _a4 >> 1;
    _v120 = _t12;
     *__esp = 3;
    __fxstat64();
    if(_t12 == -1) {
        _v120 = 0;
        uerror(_t18, __esi, _t18 - 8990);
    }
    __edx =  &_v108;
    return stat_aux( &_v108, __fp0);
}

unix_lstat_64(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    long long __fp0,                       // r28
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805AE2F
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ _t12;                        // _t12
    _unknown_ _t20;                        // _t20
    intOrPtr _t23;                         // _t23

    __fp0 = __fp0;
    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t12);
    _t20 = __ebx + 76644;
    _t23 = _a4;
    _v116 =  &_v108;
    _v120 = _t23;
     *__esp = 3;
    __lxstat64();
    if( &_v108 == -1) {
        _v120 = _t23;
        uerror(_t20, _t23, _t20 - 8984);
    }
    __edx =  &_v108;
    return stat_aux( &_v108, __fp0);
}

unix_stat_64(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    long long __fp0,                       // r28
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805AE8E
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ _t12;                        // _t12
    _unknown_ _t20;                        // _t20
    intOrPtr _t23;                         // _t23

    __fp0 = __fp0;
    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t12);
    _t20 = __ebx + 76549;
    _t23 = _a4;
    _v116 =  &_v108;
    _v120 = _t23;
     *__esp = 3;
    __xstat64();
    if( &_v108 == -1) {
        _v120 = _t23;
        uerror(_t20, _t23, _t20 - 8989);
    }
    __edx =  &_v108;
    return stat_aux( &_v108, __fp0);
}

unix_fstat(
    _unknown_ __esi,                       // r5
    long long __fp0,                       // r28
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805AEED
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    signed int _v116;                      // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    _unknown_ _t15;                        // _t15
    signed int _t19;                       // _t19
    _unknown_ _t28;                        // _t28
    _unknown_ _t29;                        // _t29

    __fp0 = __fp0;
    __esi = __esi;
    __i686.get_pc_thunk.bx(_t15);
    _t29 = _t28 + 76459;
    _v116 =  &_v108;
    _t19 = _a4 >> 1;
    _v120 = _t19;
     *__esp = 3;
    __fxstat64();
    if(_t19 == -1) {
        _v120 = 0;
        uerror(_t29, __esi, _t29 - 8990);
    }
    if(_v60 >= 0 && (_v60 > 0 || _v64 > 1073741823)) {
        if((_v92 & 61440) == 32768) {
            _v116 = 0;
            _v120 = _t29 - 8990;
            unix_error(_t29, __esi, 75);
        }
    }
    __edx =  &_v108;
    return stat_aux( &_v108, __fp0);
}

unix_lstat(
    long long __fp0,                       // r28
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805AF8B
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ _t15;                        // _t15
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27

    __fp0 = __fp0;
    __i686.get_pc_thunk.bx(_t15);
    _t27 = _t26 + 76300;
    __esi = _a4;
    _v116 =  &_v108;
    _v120 = __esi;
     *__esp = 3;
    __lxstat64();
    if( &_v108 == -1) {
        _v120 = __esi;
        uerror(_t27, __esi, _t27 - 8984);
    }
    if(_v60 >= 0 && (_v60 > 0 || _v64 > 1073741823)) {
        if((_v92 & 61440) == 32768) {
            _v116 = __esi;
            _v120 = _t27 - 8984;
            unix_error(_t27, __esi, 75);
        }
    }
    __edx =  &_v108;
    return stat_aux( &_v108, __fp0);
}

unix_stat(
    long long __fp0,                       // r28
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805B021
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ _t15;                        // _t15
    _unknown_ _t26;                        // _t26
    _unknown_ _t27;                        // _t27

    __fp0 = __fp0;
    __i686.get_pc_thunk.bx(_t15);
    _t27 = _t26 + 76150;
    __esi = _a4;
    _v116 =  &_v108;
    _v120 = __esi;
     *__esp = 3;
    __xstat64();
    if( &_v108 == -1) {
        _v120 = __esi;
        uerror(_t27, __esi, _t27 - 8989);
    }
    if(_v60 >= 0 && (_v60 > 0 || _v64 > 1073741823)) {
        if((_v92 & 61440) == 32768) {
            _v116 = __esi;
            _v120 = _t27 - 8989;
            unix_error(_t27, __esi, 75);
        }
    }
    __edx =  &_v108;
    return stat_aux( &_v108, __fp0);
}

intOrPtr* unix_string_of_inet_addr(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805B0B8
    char _v76;                             // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ _t12;                        // _t12
    char* _t15;                            // _t15
    _unknown_ _t18;                        // _t18
    _unknown_ _t19;                        // _t19

    __i686.get_pc_thunk.bx(_t12);
    _t19 = _t18 + 75999;
    __esi = _a4;
    if(caml_string_length(__esi) != 16) {
        _v80 = 64;
        _t15 =  &_v76;
        _v84 =  &_v76;
        _v88 = __esi;
         *__esp = 2;
        inet_ntop();
    } else {
        _v80 = 64;
        _t15 =  &_v76;
        _v84 =  &_v76;
        _v88 = __esi;
         *__esp = 10;
        inet_ntop();
    }
    if(_t15 == 0) {
        _v88 = 0;
        _t15 = uerror(_t19, __esi, _t19 - 8978);
    }
    return caml_copy_string(_t19, __edi, __esi, _t15);
}

unix_symlink(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805B144
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t10;                        // _t10
    intOrPtr _t12;                         // _t12
    _unknown_ _t17;                        // _t17
    intOrPtr _t20;                         // _t20

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t10);
    _t17 = __ebx + 75855;
    _t20 = _a8;
    _v24 = _t20;
    _t12 = _a4;
     *__esp = _t12;
    symlink();
    if(_t12 == -1) {
        _v24 = _t20;
        uerror(_t17, _t20, _t17 - 8958);
    }
    return 1;
}

unix_tcflow(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805B1A0
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t9;                         // _t9
    signed int _t15;                       // _t15
    _unknown_ _t19;                        // _t19

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t9);
    _t20 = _t19 + 75768;
    _v24 =  *((intOrPtr*)(_t19 + 75768 + (_a8 >> 1) * 4 - 8868));
    _t15 = _a4 >> 1;
     *__esp = _t15;
    tcflow();
    if(_t15 == -1) {
        _v24 = 0;
        uerror(_t20, __esi, _t20 - 8950);
    }
    return 1;
}

unix_tcflush(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805B1F5
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t9;                         // _t9
    signed int _t15;                       // _t15
    _unknown_ _t19;                        // _t19

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t9);
    _t20 = _t19 + 75683;
    _v24 =  *((intOrPtr*)(_t19 + 75683 + (_a8 >> 1) * 4 - 8852));
    _t15 = _a4 >> 1;
     *__esp = _t15;
    tcflush();
    if(_t15 == -1) {
        _v24 = 0;
        uerror(_t20, __esi, _t20 - 8943);
    }
    return 1;
}

unix_tcdrain(
    _unknown_ __esi,                       // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805B24A
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    signed int _t7;                        // _t7
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t4);
    _t12 = _t11 + 75598;
    _t7 = _a4 >> 1;
     *__esp = _t7;
    tcdrain();
    if(_t7 == -1) {
        _v24 = 0;
        uerror(_t12, __esi, _t12 - 8935);
    }
    return 1;
}

unix_tcsendbreak(
    _unknown_ __esi,                       // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805B28F
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ _t6;                         // _t6
    signed int _t11;                       // _t11
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16

    __esi = __esi;
    __i686.get_pc_thunk.bx(_t6);
    _t16 = _t15 + 75529;
    _v24 = _a8 >> 1;
    _t11 = _a4 >> 1;
     *__esp = _t11;
    tcsendbreak();
    if(_t11 == -1) {
        _v24 = 0;
        uerror(_t16, __esi, _t16 - 8927);
    }
    return 1;
}

signed int unix_tcsetattr(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int* _a12                       // _cfa_c
)
{// addr = 0x0805B2DD
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    _unknown_ __ebx;                       // r1
    signed int* __edi;                     // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t65;                        // _t65
    signed int _t70;                       // _t70
    signed int _t71;                       // _t71
    signed int _t76;                       // _t76
    signed int* _t80;                      // _t80
    signed int _t83;                       // _t83
    signed int _t87;                       // _t87
    signed int _t89;                       // _t89
    signed int* _t91;                      // _t91
    _unknown_ _t94;                        // _t94
    _unknown_ _t95;                        // _t95
    signed int _t100;                      // _t100
    signed int _t101;                      // _t101
    signed int _t102;                      // _t102
    signed int* _t106;                     // _t106
    signed int _t108;                      // _t108
    signed int* _t114;                     // _t114
    signed int* _t115;                     // _t115
    _unknown_ _t116;                       // _t116
    signed int _t117;                      // _t117

    __i686.get_pc_thunk.bx(_t65);
    _t95 = _t94 + 75449;
    _v44 = _a4 >> 1;
    _v72 = _t95 + 27708;
    _t70 = _v44;
     *__esp = _t70;
    tcgetattr();
    if(_t70 == -1) {
        _v72 = 0;
        uerror(_t95, _t115, _t95 - 8915);
    }
    _t71 =  *(_t95 + 26556);
    if(_t71 == 4) {
L35:
        _v68 = _t95 + 27708;
        _v72 =  *(_t95 + (_a8 >> 1) * 4 - 8840);
        _t76 = _v44;
         *__esp = _t76;
        tcsetattr();
        if(_t76 == -1) {
            _v72 = 0;
            uerror(_t95, _t115, _t95 - 8915);
        }
        return 1;
    } else {
        __edi = _a12;
        _t116 = _t95 + 26556;
        _v40 = _t95 - 8804;
        _v48 = _t95 + 27708;
        while(1) {
            _t117 = _t116 + 4;
            if(_t71 == 1) {
                goto L14;
            }
            if(_t71 > 1) {
                if(_t71 == 2) {
L18:
                    _t101 =  *_t117;
                    _t108 =  *__edi >> 1;
                    _t83 = 1;
                    if(_t108 !=  *((intOrPtr*)(_t95 - 8800))) {
                        _v32 = _t117;
                        _t117 = _v40;
L21:
                        if(_t108 !=  *((intOrPtr*)(_t117 + 4 + _t83 * 8))) {
L30:
                            _t83 = _t83 + 1;
                            if(_t83 != 18) {
                                goto L21;
                            }
                            _v68 = 0;
                            _v72 = _t95 - 8915;
                            unix_error(_t95, _t117, 22);
L32:
                            _t115 = _t117 + 4;
                             *((char*)( &(( *_t117)[0x1b13]) + _t95)) =  *__edi >> 1;
                            goto L33;
                        }
                        _t117 = _v32;
L23:
                        if(_t101 == 0) {
                            _t87 =  *(_t95 + _t83 * 8 - 8804);
                            _v72 = _t87;
                            _t101 = _v48;
                             *__esp = _t101;
                            cfsetispeed();
                            _t108 = _t87;
                        } else {
                            _t108 = 0;
                            if(_t101 == 1) {
                                _t89 =  *(_t95 + _t83 * 8 - 8804);
                                _v72 = _t89;
                                 *__esp = _v48;
                                cfsetospeed();
                                _t108 = _t89;
                            }
                        }
                        if(_t108 == -1) {
                            _v72 = 0;
                            _t83 = uerror(_t95, _t117, _t95 - 8915);
                            goto L30;
                        } else {
                            _t115 = _t117 + 4;
                            goto L33;
                        }
                    }
                    _t83 = 0;
                    goto L23;
                }
                if(_t71 != 3) {
                    goto L33;
                }
                goto L32;
            } else {
                if(_t71 == 0) {
                    _t91 =  *_t117;
                    _t102 =  *(_t117 + 4);
                    _t115 = _t117 + 8;
                    if( *__edi >> 1 == 0) {
                         *_t91 =  *_t91 &  !_t102;
                    } else {
                         *_t91 =  *_t91 | _t102;
                    }
                }
L33:
                _t71 =  *_t115;
                if(_t71 == 4) {
                    goto L35;
                }
                __edi =  &(__edi[1]);
                continue;
            }
L14:
            _t80 =  *_t117;
            _v32 =  *(_t117 + 8);
            _t106 = _t117 + 12;
            _v36 =  *_t106;
            _t100 = ( *__edi >> 1) -  *(_t117 + 4);
            if(_t100 < 0 || _v32 <= _t100) {
                _v68 = 0;
                _v72 = _t95 - 8915;
                unix_error(_t95, _t117, 22);
                goto L18;
            } else {
                _t114 =  &(_t106[1]);
                 *_t80 =  !_v36 &  *_t80 | _t114[_t100];
                _t115 =  &(_t114[_v32]);
                goto L33;
            }
        }
    }
}

unix_tcgetattr(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805B511
    signed int* _v32;                      // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    intOrPtr* _v44;                        // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v88;                       // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t55;                        // _t55
    signed int _t59;                       // _t59
    signed int _t61;                       // _t61
    signed int _t64;                       // _t64
    signed int _t68;                       // _t68
    signed int _t72;                       // _t72
    signed int _t75;                       // _t75
    signed int _t80;                       // _t80
    _unknown_ _t85;                        // _t85
    _unknown_ _t86;                        // _t86
    signed int _t90;                       // _t90
    signed int* _t93;                      // _t93
    signed int _t94;                       // _t94
    signed int _t95;                       // _t95
    signed int* _t96;                      // _t96
    _unknown_ _t97;                        // _t97
    signed int* _t98;                      // _t98
    signed int _t101;                      // _t101

    __i686.get_pc_thunk.bx(_t55);
    _t86 = _t85 + 74885;
    _v88 = _t86 + 27708;
    _t59 = _a4 >> 1;
     *__esp = _t59;
    tcgetattr();
    if(_t59 == -1) {
        _v88 = 0;
        uerror(_t86, _t97, _t86 - 8905);
    }
    _v44 = caml_alloc_tuple(38);
    _t61 =  *(_t86 + 26556);
    if(_t61 == 4) {
L34:
        return _v44;
    }
    __edi = _v44;
    _t93 = _t86 + 26556;
    _v48 = -8804;
    _v52 = _t86 + 27708;
    while(1) {
        _t98 =  &(_t93[1]);
        if(_t61 == 1) {
            goto L12;
        }
        if(_t61 > 1) {
            if(_t61 == 2) {
                _t94 =  *_t98;
                _t98 =  &(_t98[1]);
                 *__edi = 19201;
                if(_t94 == 0) {
                    _t72 = _v52;
                     *__esp = _t72;
                    cfgetispeed();
                } else {
                    _t72 = 0;
                    if(_t94 == 1) {
                         *__esp = _v52;
                        cfgetospeed();
                    }
                }
                _t95 = 1;
                if( *((intOrPtr*)(_t86 + _v48)) != _t72) {
                    while( *((intOrPtr*)(_t86 + _t95 * 8 - 8804)) != _t72) {
                        _t95 = _t95 + 1;
                        if(_t95 != 18) {
                            continue;
                        }
                        goto L32;
                    }
                    goto L28;
                } else {
                    _t95 = 0;
L28:
                     *__edi =  *((intOrPtr*)(_t86 + _t95 * 8 - 8800)) +  *((intOrPtr*)(_t86 + _t95 * 8 - 8800)) + 1;
L32:
                    _t61 =  *_t98;
                    if(_t61 == 4) {
                        goto L34;
                    }
                    __edi = __edi + 4;
                    _t93 = _t98;
                    continue;
                }
            }
            if(_t61 == 3) {
                _t75 =  *_t98;
                _t98 =  &(_t98[1]);
                 *__edi = ( *(_t86 + _t75 + 27725) & 255) + ( *(_t86 + _t75 + 27725) & 255) + 1;
            }
            goto L32;
        }
        if(_t61 == 0) {
            _t96 =  &(_t98[1]);
            _t80 =  *( *_t98) &  *_t96;
            asm("sbb eax, eax");
            _t98 =  &(_t96[1]);
             *__edi = (_t80 & -2) + 3;
        }
        goto L32;
L12:
        _v36 =  *_t98;
        _v40 = _t98[1];
        _t90 = _t98[2];
        _t64 = _t98[3];
        _v64 = _t64;
        _v32 =  &(_t98[4]);
        if(_t90 <= 0) {
L20:
            _t98 =  &(_v32[_t90]);
            goto L32;
        }
        _t101 = _t64 &  *_v36;
        _v36 = 0;
        if(_t101 !=  *_v32) {
            _t68 = _v36;
            while(1) {
                _t68 = _t68 + 1;
                if(_t90 <= _t68) {
                    goto L20;
                }
                if( *((intOrPtr*)(_t93 + 20 + _t68 * 4)) != _t101) {
                    continue;
                }
                _v36 = _t68;
L17:
                 *__edi = _v36 + _v40 + _v36 + _v40 + 1;
                goto L20;
            }
            goto L20;
        }
        goto L17;
    }
}

unix_time(
    long long __fp0                        // r28
)
{// addr = 0x0805B6CC
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ _t2;                         // _t2
    intOrPtr _t3;                          // _t3
    _unknown_ _t5;                         // _t5

    __fp0 = __fp0;
    _t3 = __i686.get_pc_thunk.bx(_t2);
     *__esp = 0;
    time();
    _v16 = _t3;
    asm("fild dword [ebp-0xc]");
     *__esp = __fp0;
    return caml_copy_double();
}

signed long long* unix_times(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int __fp0                       // r28
)
{// addr = 0x0805B700
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v100;                            // _cfa_ffffff9c
    char* _v120;                           // _cfa_ffffff88 (outparam)
    _unknown_ _t16;                        // _t16
    signed long long* _t19;                // _t19
    signed long long* _t20;                // _t20
    _unknown_ _t23;                        // _t23
    signed long long* _t29;                // _t29
    signed long long _t32;                 // _t32
    signed long long _t33;                 // _t33
    signed long long _t34;                 // _t34

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t16);
    _t23 = __ebx + 74384;
    _t29 = caml_alloc_small(_t23, __esi, 8, 254);
    _v120 =  &_v100;
     *__esp = 0;
    getrusage();
    asm("fild dword [ebp-0x60]");
    asm("fild dword [ebp-0x5c]");
    _t19 = _t23 - 8660;
    _t32 = __fp0 /  *_t19;
    asm("faddp st1, st0");
     *_t29 = _t32;
    asm("fild dword [ebp-0x58]");
    asm("fild dword [ebp-0x54]");
    _t33 = _t32 /  *_t19;
    asm("faddp st1, st0");
    _t29[1] = _t33;
    _v120 =  &_v100;
     *__esp = -1;
    getrusage();
    asm("fild dword [ebp-0x60]");
    asm("fild dword [ebp-0x5c]");
    _t20 = _t23 - 8660;
    _t34 = _t33 /  *_t20;
    asm("faddp st1, st0");
    _t29[2] = _t34;
    asm("fild dword [ebp-0x58]");
    asm("fild dword [ebp-0x54]");
    asm("faddp st1, st0");
    _t29[3] = _t34 /  *_t20;
    return _t29;
}

unix_truncate_64(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805B7A4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t13;                        // _t13
    intOrPtr _t15;                         // _t15
    intOrPtr _t16;                         // _t16
    _unknown_ _t21;                        // _t21
    intOrPtr _t24;                         // _t24

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t13);
    _t21 = __ebx + 74223;
    _t24 = _a4;
    _t15 = _a8;
    _t16 =  *((intOrPtr*)(_t15 + 4));
    _v24 = _t16;
    _v20 =  *((intOrPtr*)(_t15 + 8));
     *__esp = _t24;
    truncate64();
    if(_t16 == -1) {
        _v24 = _t24;
        uerror(_t21, _t24, _t21 - 9562);
    }
    return 1;
}

unix_truncate(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805B7FD
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ _t11;                        // _t11
    signed int _t14;                       // _t14
    _unknown_ _t19;                        // _t19
    signed int _t24;                       // _t24

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t11);
    _t19 = __ebx + 74134;
    _t24 = _a4;
    _t14 = _a8 >> 1;
    _v24 = _t14;
    _v20 = _t14 >> 31;
     *__esp = _t24;
    truncate64();
    if(_t14 == -1) {
        _v24 = _t24;
        uerror(_t19, _t24, _t19 - 9562);
    }
    return 1;
}

unix_umask(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805B858
    _unknown_ __ebx;                       // r1
    _unknown_ _t4;                         // _t4
    signed int _t7;                        // _t7
    _unknown_ _t9;                         // _t9

    __i686.get_pc_thunk.bx(_t4);
    _t7 = _a4 >> 1;
     *__esp = _t7;
    umask();
    return _t7 + _t7 + 1;
}

unix_error_of_code(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805B884
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _t13;                        // _t13
    intOrPtr* _t16;                        // _t16
    intOrPtr _t24;                         // _t24

    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t13);
    _t21 = __ebx + 73999;
    _t24 = _a4;
    _t16 = cst_to_constr(_t24,  *((intOrPtr*)(__ebx + 73999 - 8)), 68, -1);
    __edx = _t16;
    if(_t16 == -1) {
        __edx = caml_alloc_small(_t21, _t24, 1, 0);
         *__edx = _t24 + _t24 + 1;
    }
    return __edx;
}

unix_error(
    _unknown_ __ebx,                       // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805B8EF
    char _v16;                             // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char _v56;                             // _cfa_ffffffc8
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v96;                         // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c (outparam)
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v128;                        // _cfa_ffffff80
    _unknown_ _t47;                        // _t47
    intOrPtr _t49;                         // _t49
    intOrPtr* _t54;                        // _t54
    _unknown_ _t55;                        // _t55
    intOrPtr* _t56;                        // _t56
    _unknown_ _t58;                        // _t58
    _unknown_ _t59;                        // _t59
    intOrPtr _t63;                         // _t63
    intOrPtr _t68;                         // _t68
    intOrPtr _t69;                         // _t69
    _unknown_ _t70;                        // _t70
    intOrPtr* _t75;                        // _t75
    intOrPtr _t88;                         // _t88
    _unknown_ _t90;                        // _t90
    intOrPtr* _t91;                        // _t91

    _push(__ebx);
    __esp = __esp - 68;
    __i686.get_pc_thunk.bx(_t47);
    _t68 = __ebx + 73897;
    _t49 = _a12;
    _v16 = 1;
    _v20 = 1;
    _v24 = 1;
    _t75 =  *((intOrPtr*)(_t68 - 24));
    _v56 =  *_t75;
     *_t75 =  &_v56;
    _v48 = 1;
    _v52 = 3;
    _v44 =  &_v16;
    _v40 =  &_v20;
    _v36 =  &_v24;
    if(_t49 == 0) {
        _t49 = caml_copy_string(_t68, __edi, __esi, _t68 - 5244);
    }
    _v24 = _t49;
    _v16 = caml_copy_string(_t68, __edi, __esi, _a8);
    _v20 = unix_error_of_code(_t68, __esi, _a4);
    if( *((intOrPtr*)(_t68 + 27768)) == 0) {
        _t63 = caml_named_value(_t68 - 8652);
         *((intOrPtr*)(_t68 + 27768)) = _t63;
        if(_t63 == 0) {
             *__esp = _t68 - 8636;
            caml_invalid_argument();
        }
    }
    _t54 = caml_alloc_small(_t68, __esi, 4, 0);
     *_t54 =  *((intOrPtr*)( *((intOrPtr*)(_t68 + 27768))));
     *((intOrPtr*)(_t54 + 4)) = _v20;
     *((intOrPtr*)(_t54 + 8)) = _v16;
     *((intOrPtr*)(_t54 + 12)) = _v24;
     *((intOrPtr*)( *((intOrPtr*)(_t68 - 24)))) = _v56;
     *__esp = _t54;
    _t55 = caml_raise();
    _push(_t90);
    _t91 = __esp;
    _push(_t68);
    __esp = __esp - 20;
    _t56 = __i686.get_pc_thunk.bx(_t55);
    _t69 = _t68 + 73644;
    __errno_location();
    _v96 = _v68;
    _v100 = _v72;
    _t58 = unix_error(_t69, __esi,  *_t56);
    _push(_t91);
    __esp = __esp - 24;
    _v116 = _t69;
    _v112 = __esi;
    _t59 = __i686.get_pc_thunk.bx(_t58);
    _t70 = _t69 + 73591;
    _t88 = _v100;
     *__esp = _t88;
    unlink();
    if(_t59 == -1) {
        _v128 = _t88;
         *__esp = _t70 - 8572;
        L6();
    }
    return 1;
}

uerror(
    _unknown_ __ebx,                       // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805B9EC
    _unknown_ _v12;                        // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v52;                         // _cfa_ffffffcc
    _unknown_ _t12;                        // _t12
    intOrPtr* _t13;                        // _t13
    _unknown_ _t15;                        // _t15
    _unknown_ _t16;                        // _t16
    intOrPtr _t21;                         // _t21
    _unknown_ _t22;                        // _t22
    intOrPtr _t27;                         // _t27
    _unknown_ _t29;                        // _t29

    _push(__ebx);
    __esp = __esp - 20;
    _t13 = __i686.get_pc_thunk.bx(_t12);
    _t21 = __ebx + 73644;
    __errno_location();
    _v20 = _a8;
    _v24 = _a4;
    _t15 = unix_error(_t21, __esi,  *_t13);
    _push(_t29);
    __esp = __esp - 24;
    _v40 = _t21;
    _v36 = __esi;
    _t16 = __i686.get_pc_thunk.bx(_t15);
    _t22 = _t21 + 73591;
    _t27 = _v24;
     *__esp = _t27;
    unlink();
    if(_t16 == -1) {
        _v52 = _t27;
        uerror(_t22, _t27, _t22 - 8572);
    }
    return 1;
}

unix_unlink(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805BA1C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v24;                         // _cfa_ffffffe8
    _unknown_ _t8;                         // _t8
    _unknown_ _t9;                         // _t9
    _unknown_ _t14;                        // _t14
    intOrPtr _t17;                         // _t17

    _v12 = __ebx;
    _v8 = __esi;
    _t9 = __i686.get_pc_thunk.bx(_t8);
    _t14 = __ebx + 73591;
    _t17 = _a4;
     *__esp = _t17;
    unlink();
    if(_t9 == -1) {
        _v24 = _t17;
        uerror(_t14, _t17, _t14 - 8572);
    }
    return 1;
}

unix_utimes(
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12                         // _cfa_c
)
{// addr = 0x0805BA64
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v30;                        // _cfa_ffffffe2
    short _v32;                            // _cfa_ffffffe0
    char* _v36;                            // _cfa_ffffffdc
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ _t14;                        // _t14
    char* _t19;                            // _t19
    _unknown_ _t23;                        // _t23
    _unknown_ _t24;                        // _t24
    intOrPtr _t26;                         // _t26

    __i686.get_pc_thunk.bx(_t14);
    _t24 = _t23 + 73523;
    __esi = _a4;
    asm("fnstcw word [ebp-0x1a]");
    _v32 = 12;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp dword [ebp-0x20]");
    asm("fldcw word [ebp-0x1a]");
    _t19 = _v36;
    _v20 = _t19;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp dword [ebp-0x20]");
    asm("fldcw word [ebp-0x1a]");
    _t26 = _v36;
    if(_t19 != 0 || _t26 != 0) {
        _t19 =  &_v20;
    }
    _v16 = _t26;
    _v56 = _t19;
     *__esp = __esi;
    utime();
    if(_t19 == -1) {
        _v56 = __esi;
        uerror(_t24, __esi, _t24 - 8565);
    }
    return 1;
}

alloc_process_status(
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0805BAEC
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    signed int _v80;                       // _cfa_ffffffb0
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    _unknown_ _t36;                        // _t36
    _unknown_ _t37;                        // _t37
    signed int _t39;                       // _t39
    signed int _t40;                       // _t40
    intOrPtr* _t47;                        // _t47
    signed int _t48;                       // _t48
    signed int _t51;                       // _t51
    _unknown_ _t53;                        // _t53
    _unknown_ _t64;                        // _t64
    intOrPtr* _t69;                        // _t69

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t37 = __i686.get_pc_thunk.bx(_t36);
    _t53 = __ebx + 73380;
    _t64 = _t37;
    _t39 = __edx & 127;
    _v80 = _t39;
    if(_t39 != 0) {
        if(__edx != 127) {
            _t40 = caml_alloc_small(_t53, __edx, 1, 1);
            _v32 = _t40;
             *_t40 = caml_rev_convert_signal_number(_v80) + _t42 + 1;
        } else {
            _t48 = caml_alloc_small(_t53, __edx, 1, 2);
            _v80 = _t48;
            _v32 = _t48;
             *_v80 = caml_rev_convert_signal_number(__edx & 255) + _t49 + 1;
        }
    } else {
        _t51 = caml_alloc_small(_t53, __edx, 1, 0);
        _v32 = _t51;
         *_t51 = (__edx & 255) + (__edx & 255) + 1;
    }
    _t69 =  *((intOrPtr*)(_t53 - 24));
    _v64 =  *_t69;
     *_t69 =  &_v64;
    _v56 = 1;
    _v60 = 1;
    _v52 =  &_v32;
    _t47 = caml_alloc_small(_t53, _t69, 2, 0);
     *_t47 = _t64 + _t64 + 1;
     *(_t47 + 4) = _v32;
     *_t69 = _v64;
    return _t47;
}

unix_waitpid(
    intOrPtr __edi,                        // r4
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805BBEF
    _unknown_ _v16;                        // _cfa_fffffff0
    intOrPtr _v36;                         // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t11;                        // _t11
    intOrPtr _t15;                         // _t15
    signed int _t19;                       // _t19
    _unknown_ _t25;                        // _t25

    __edi = __edi;
    __i686.get_pc_thunk.bx(_t11);
    _t26 = _t25 + 73128;
    _t15 = caml_convert_flag_list(_a4, _t25 + 0x18854);
    caml_enter_blocking_section();
    _v36 = _t15;
    _v40 =  &_v16;
    _t19 = _a8 >> 1;
     *__esp = _t19;
    waitpid();
    _t28 = _t19;
    caml_leave_blocking_section();
    if(_t19 == -1) {
        _v40 = 0;
        uerror(_t26, _t19, _t26 - 8558);
    }
    __edx = _v16;
    return alloc_process_status(_t26, _v16, __edi, _t19);
}

unix_wait(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0805BC69
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v16;                             // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ _t9;                         // _t9
    intOrPtr _t19;                         // _t19

    __edi = __edi;
    _v12 = __ebx;
    _v8 = __esi;
    __i686.get_pc_thunk.bx(_t9);
    _t19 = __ebx + 73002;
    caml_enter_blocking_section();
     *__esp =  &_v16;
    wait();
    caml_leave_blocking_section();
    if( &_v16 == -1) {
        _v40 = 0;
        uerror(_t19,  &_v16, _t19 - 8550);
    }
    __edx = _v16;
    return alloc_process_status(_t19, _v16, __edi,  &_v16);
}

unix_single_write(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805BCC8
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v16412;                          // _cfa_ffffbfe4
    char* _v16432;                         // _cfa_ffffbfd0
    intOrPtr _v16436;                      // _cfa_ffffbfcc
    intOrPtr _v16440;                      // _cfa_ffffbfc8
    char _v16444;                          // _cfa_ffffbfc4
    intOrPtr _v16452;                      // _cfa_ffffbfbc
    signed int _v16456;                    // _cfa_ffffbfb8
    _unknown_ _t30;                        // _t30
    intOrPtr* _t32;                        // _t32
    signed int _t42;                       // _t42
    _unknown_ _t47;                        // _t47
    signed int _t57;                       // _t57
    signed int _t58;                       // _t58
    intOrPtr _t60;                         // _t60

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    __i686.get_pc_thunk.bx(_t30);
    _t47 = __ebx + 72901;
    _t32 =  *((intOrPtr*)(_t47 - 24));
    _v16444 =  *_t32;
     *_t32 =  &_v16444;
    _v16436 = 1;
    _v16440 = 1;
    _v16432 =  &_a8;
    _t57 = _a16 >> 1;
    if(_t57 <= 0) {
L3:
        _t58 = 0;
    } else {
        _t60 = _t57 - 16384 > 0 ? 16384 : _t57;
        _v16452 = _t60;
        _v16456 = (_a12 >> 1) + _a8;
         *__esp =  &_v16412;
        memmove();
        caml_enter_blocking_section();
        _v16452 = _t60;
        _v16456 =  &_v16412;
        _t42 = _a4 >> 1;
         *__esp = _t42;
        write();
        _t58 = _t42;
        caml_leave_blocking_section();
        if(_t58 == -1) {
            _v16456 = 0;
            uerror(_t47, _t58, _t47 - 8545);
            goto L3;
        }
    }
     *((intOrPtr*)( *((intOrPtr*)(_t47 - 24)))) = _v16444;
    return _t58 + _t58 + 1;
}

unix_write(
    signed int _a4,                        // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0805BDAD
    char _v16412;                          // _cfa_ffffbfe4
    char* _v16432;                         // _cfa_ffffbfd0
    intOrPtr _v16436;                      // _cfa_ffffbfcc
    intOrPtr _v16440;                      // _cfa_ffffbfc8
    char _v16444;                          // _cfa_ffffbfc4
    signed int _v16448;                    // _cfa_ffffbfc0
    signed int _v16452;                    // _cfa_ffffbfbc
    signed int _v16456;                    // _cfa_ffffbfb8
    signed int _v16460;                    // _cfa_ffffbfb4
    intOrPtr _v16468;                      // _cfa_ffffbfac
    signed int _v16472;                    // _cfa_ffffbfa8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t39;                        // _t39
    intOrPtr* _t41;                        // _t41
    signed int _t53;                       // _t53
    intOrPtr* _t54;                        // _t54
    _unknown_ _t57;                        // _t57
    _unknown_ _t58;                        // _t58
    signed int _t67;                       // _t67
    signed int _t69;                       // _t69

    __i686.get_pc_thunk.bx(_t39);
    _t58 = _t57 + 72678;
    _t41 =  *((intOrPtr*)(_t58 - 24));
    _v16444 =  *_t41;
     *_t41 =  &_v16444;
    _v16436 = 1;
    _v16440 = 1;
    _v16432 =  &_a8;
    _t69 = _a16 >> 1;
    if(_t69 <= 0) {
        _v16452 = 0;
L9:
         *((intOrPtr*)( *((intOrPtr*)(_t58 - 24)))) = _v16444;
        return _v16452 + _v16452 + 1;
    }
    _v16448 = _a12 >> 1;
    _v16460 = _a4 >> 1;
    _v16452 = 0;
    _v16456 =  &_v16412;
    while(1) {
        _t66 = _t69 - 16384 <= 0 ? _t69 : 16384;
        _v16468 = 16384;
        _v16472 = _v16448 + _a8;
         *__esp = _v16456;
        memmove();
        caml_enter_blocking_section();
        _v16468 = _t69 - 16384 <= 0 ? _t69 : 16384;
        _t53 = _v16456;
        _v16472 = _t53;
         *__esp = _v16460;
        write();
        _t67 = _t53;
        _t54 = caml_leave_blocking_section();
        if(_t67 != -1) {
            goto L6;
        }
        _t69 = _v16452;
        __errno_location();
        if( *_t54 != 11 || _t69 <= 0) {
            _v16472 = 0;
            uerror(_t58, _t69, _t58 - 8538);
        } else {
            goto L9;
        }
L6:
        _v16452 = _v16452 + _t67;
        _t69 = _t69 - _t67;
        if(_t69 <= 0) {
            goto L9;
        }
        _v16448 = _v16448 + _t67;
    }
}

cst_to_constr(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0805BF00
    intOrPtr* __esi;                       // r5
    signed int _t13;                       // _t13

    __ecx = _a4;
    __esi = _a8;
    __edx = _a12;
    if(__edx <= 0) {
L6:
        return _a16 + _a16 + 1;
    }
    _t13 = 0;
    if( *__esi != __ecx) {
        while(1) {
            _t13 = _t13 + 1;
            if(__edx <= _t13) {
                goto L6;
            }
            if( *((intOrPtr*)(__esi + _t13 * 4)) != __ecx) {
                continue;
            }
L4:
            return _t13 + _t13 + 1;
        }
        goto L6;
    }
    goto L4;
}

cstringvect(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805BF38
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    intOrPtr __esi;                        // r5
    _unknown_ _t14;                        // _t14
    intOrPtr _t17;                         // _t17
    _unknown_ _t20;                        // _t20
    signed int _t23;                       // _t23

    __i686.get_pc_thunk.bx(_t14);
    __esi = _a4;
    _t23 =  *(__esi - 4) >> 10;
    _t17 = caml_stat_alloc(4 + _t23 * 4, 4 + _t23 * 4);
    _v32 = _t17;
    if(_t23 != 0) {
        __edx = 0;
        do {
             *((intOrPtr*)(_t17 + __edx * 4)) =  *((intOrPtr*)(__esi + __edx * 4));
            __edx = __edx + 1;
        } while(_t23 > __edx);
    }
     *(_v32 + _t23 * 4) = 0;
    return _v32;
}

signed int scanmult(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    signed int* __edx,                     // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0805BFA0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed char _v29;                      // _cfa_ffffffe3
    signed int _v36;                       // _cfa_ffffffdc
    signed int* _v48;                      // _cfa_ffffffd0
    char* _v64;                            // _cfa_ffffffc0
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    signed int _t27;                       // _t27
    signed int _t29;                       // _t29

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v48 = __edx;
    _v29 = 32;
    _v64 =  &_v29;
    _v68 =  &_v36;
    _v72 = 134658128;
     *__esp = __eax;
    __isoc99_sscanf();
    _v64 =  &_v29;
    _v68 =  &_v36;
    _v72 = "=0x%x%c";
     *__esp = __eax;
    __isoc99_sscanf();
    _t27 = _v29 & 255;
    if(_t27 == 77) {
        _t29 = _v36 << 20;
         *_v48 = _t29;
    } else {
        if(_t27 == 107) {
            _t29 = _v36 << 10;
             *_v48 = _t29;
        } else {
            if(_t27 != 71) {
                _t29 = _v36;
                 *_v48 = _t29;
            } else {
                _t29 = _v36 << 30;
                 *_v48 = _t29;
            }
        }
    }
    return _t29;
}

caml_main(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805C03E
    char _v29;                             // _cfa_ffffffe3
    char _v36;                             // _cfa_ffffffdc
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    signed int _v72;                       // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    char* __edi;                           // r4
    char* __esi;                           // r5
    _unknown_ _t31;                        // _t31
    signed int _t35;                       // _t35
    signed char _t36;                      // _t36
    signed int _t44;                       // _t44
    signed int _t47;                       // _t47
    intOrPtr _t49;                         // _t49
    _unknown_ _t54;                        // _t54
    signed int _t56;                       // _t56
    signed int _t57;                       // _t57
    signed int _t61;                       // _t61
    intOrPtr _t64;                         // _t64
    char* _t67;                            // _t67
    signed int _t70;                       // _t70

    caml_init_ieee_floats(_t31);
    caml_init_custom_operations();
    caml_top_of_stack =  &_v29;
     *__esp = "OCAMLRUNPARAM";
    getenv();
    _t61 =  &_v29;
    if( &_v29 != 0) {
L5:
        __esi = 134658216;
        __edi =  &_v36;
        while(1) {
            _t35 =  *_t61 & 255;
            if(_t35 == 0) {
                goto L7;
            }
            _t61 = _t61 + 1;
            _t36 = _t35 - 79;
            __eflags = _t36 - 39;
            if(_t36 <= 39) {
                goto ( *((intOrPtr*)(__esi + (_t36 & 255) * 4)));
            }
        }
    } else {
         *__esp =  &M0806B85F;
        getenv();
        _t61 =  &_v29;
        if( &_v29 != 0) {
            goto L5;
        }
    }
L7:
    caml_init_gc(__fp0, minor_heap_init, heap_size_init, heap_chunk_init, percent_free_init, max_percent_free_init);
    _t44 = 0;
    do {
         *( &caml_atom_table + _t44 * 4) = _t44;
        _t44 = _t44 + 1;
    } while(_t44 != 256);
    if(caml_page_table_add(4,  &caml_atom_table,  &caml_frame_descriptors_mask) != 0) {
        _t46 = caml_fatal_error("Fatal error: not enough memory for the initial page table");
        goto L13;
    } else {
        _t46 = caml_data_segments;
        _t61 = 0;
        __esi = 134668380;
        __edi =  &caml_data_segments;
        if(caml_data_segments != 0) {
            do {
L13:
                _t47 = caml_page_table_add(4, _t46,  *((intOrPtr*)(__esi + _t61 * 8)));
                __eflags = _t47;
                if(_t47 != 0) {
                    caml_fatal_error("Fatal error: not enough memory for the initial page table");
                }
                _t61 = _t61 + 1;
                _t46 =  *(__edi + _t61 * 8);
                __eflags =  *(__edi + _t61 * 8);
            } while(__eflags != 0);
        } else {
        }
    }
    caml_code_area_start = caml_code_segments;
    __ecx =  *134668472;
    caml_code_area_end = __ecx;
    _t49 =  *134668476;
    if(_t49 != 0) {
        _t64 = caml_code_area_start;
        _t70 = 1;
        __edi = 134668472;
        __esi =  &caml_code_segments;
        do {
            _t64 = _t64 - _t49 > 0 ? _t49 : _t64;
            __ecx = __ecx -  *((intOrPtr*)(__edi + _t70 * 8)) < 0 ?  *((intOrPtr*)(__edi + _t70 * 8)) : __ecx;
            _t70 = _t70 + 1;
            _t49 =  *((intOrPtr*)(__esi + _t70 * 8));
        } while(_t49 != 0);
        caml_code_area_start = _t64;
        caml_code_area_end = __ecx;
    }
    caml_debugger_init(caml_init_signals());
    _t63 =  *_a4 == 0 ? 134661416 :  *_a4;
    _t54 = caml_executable_name(134661416,  *_a4 == 0 ? 134661416 :  *_a4, __esi,  &proc_self_exe.2949, 256);
    _t67 =  &proc_self_exe.2949;
    if(_t54 != 0) {
        _t67 = caml_search_exe_in_path(_t63, __edi, __esi, _t63);
    }
    _t56 = caml_sys_init(_t67, _a4);
    _v72 = 0;
     *__esp =  &caml_termination_jmpbuf;
    __sigsetjmp();
    if(_t56 == 0) {
        caml_start_program();
        __eflags = (_t56 & 3) - 2;
        if(__eflags == 0) {
            _t57 = _t56 & -4;
            __eflags = _t57;
             *__esp = _t57;
            caml_fatal_uncaught_exception(_t63, __edi, __esi);
            return;
        }
    } else {
        _t56 = caml_termination_hook;
        if(_t56 != 0) {
             *__esp = 0;
             *_t56();
            return;
        }
    }
}

caml_startup(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805C2F9
    __eax = _a4;
    caml_main(__eax);
    return __eax;
}

main(
    intOrPtr* _a8                          // _cfa_8
)
{// addr = 0x0805C30C
    __esp = __esp & -16;
    __esp = __esp - 16;
    caml_main(_a8);
     *__esp = 1;
    caml_sys_exit(__edi, __fp0);
    return 0;
}

caml_raise(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805C340
    signed int* _v40;                      // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0 (outparam)
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    intOrPtr* _v56;                        // _cfa_ffffffc8 (outparam)
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    char _v108;                            // _cfa_ffffff94
    char* _v144;                           // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    char _v156;                            // _cfa_ffffff64
    signed int _v176;                      // _cfa_ffffff50
    signed int _v180;                      // _cfa_ffffff4c
    intOrPtr _v184;                        // _cfa_ffffff48
    char _v188;                            // _cfa_ffffff44
    char _v196;                            // _cfa_ffffff3c
    signed int _v200;                      // _cfa_ffffff38
    char* _v232;                           // _cfa_ffffff18
    char* _v236;                           // _cfa_ffffff14
    intOrPtr _v240;                        // _cfa_ffffff10
    intOrPtr _v244;                        // _cfa_ffffff0c
    char _v248;                            // _cfa_ffffff08
    signed int _v252;                      // _cfa_ffffff04
    char* _v272;                           // _cfa_fffffef0
    intOrPtr _v276;                        // _cfa_fffffeec
    intOrPtr _v280;                        // _cfa_fffffee8
    char _v284;                            // _cfa_fffffee4
    signed int _v308;                      // _cfa_fffffecc
    signed int _v332;                      // _cfa_fffffeb4
    signed int _v336;                      // _cfa_fffffeb0
    signed int _v364;                      // _cfa_fffffe94
    signed int _v392;                      // _cfa_fffffe78
    signed int _v420;                      // _cfa_fffffe5c
    char* _v456;                           // _cfa_fffffe38
    intOrPtr _v460;                        // _cfa_fffffe34
    intOrPtr _v464;                        // _cfa_fffffe30
    char _v468;                            // _cfa_fffffe2c
    signed int _v472;                      // _cfa_fffffe28
    char* _v492;                           // _cfa_fffffe14
    intOrPtr _v496;                        // _cfa_fffffe10
    intOrPtr _v500;                        // _cfa_fffffe0c
    char _v504;                            // _cfa_fffffe08
    _unknown_ _v528;                       // _cfa_fffffdf0
    signed int _v636;                      // _cfa_fffffd84
    signed int* _v700;                     // _cfa_fffffd44
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    intOrPtr* _t120;                       // _t120
    signed int _t125;                      // _t125
    signed int _t135;                      // _t135
    signed int* _t147;                     // _t147
    signed int _t150;                      // _t150
    signed int* _t152;                     // _t152
    signed int _t156;                      // _t156
    signed int* _t157;                     // _t157
    _unknown_ _t161;                       // _t161
    signed int _t162;                      // _t162
    signed int _t163;                      // _t163
    intOrPtr* _t164;                       // _t164
    intOrPtr _t165;                        // _t165
    intOrPtr _t167;                        // _t167
    unsigned int _t173;                    // _t173
    signed int _t176;                      // _t176
    _unknown_ _t177;                       // _t177
    signed int* _t179;                     // _t179
    signed int _t180;                      // _t180
    _unknown_ _t181;                       // _t181
    signed int* _t182;                     // _t182
    signed int* _t183;                     // _t183
    signed int* _t184;                     // _t184
    signed int* _t185;                     // _t185
    signed int* _t186;                     // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int* _t193;                     // _t193
    signed int* _t194;                     // _t194
    signed int* _t195;                     // _t195

    _push(_t161);
    __esp = __esp - 20;
    _t162 = _a4;
    _t120 = caml_channel_mutex_unlock_exn;
    if(_t120 != 0) {
         *_t120();
    }
    _t167 = caml_exception_pointer;
    if(_t167 == 0) {
         *__esp = _t162;
        caml_fatal_uncaught_exception(_t162, __edi, _t177);
        goto L7;
    } else {
        _t120 = caml_local_roots;
        if(_t120 != 0) {
            if(_t120 < _t167) {
                do {
L7:
                    _t120 =  *_t120;
                    caml_local_roots = _t120;
                } while(_t120 != 0 && _t167 > _t120);
            } else {
            }
        }
    }
    caml_raise_exception(_t162);
    _push(_t181);
    _t182 = __esp;
    __esp = __esp - 24;
    if(array_bound_error_bucket_inited == 0) {
        array_bound_error_msg = 5372;
         *134694023 = 0;
        array_bound_error_bucket = 2048;
         *134694732 =  &caml_exn_Invalid_argument;
         *134694736 = "index out of bounds";
        array_bound_error_bucket_inited = 1;
        caml_page_table_add(4,  &array_bound_error_msg,  &caml_last_return_address);
        array_bound_error_bucket_inited = 1;
    }
     *__esp = 134694732;
    caml_raise();
    _push(_t182);
    _t183 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_bucket_Stack_overflow;
    caml_raise();
    _push(_t183);
    _t184 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_bucket_Out_of_memory;
    caml_raise();
    _push(_t184);
    _t185 = __esp;
    _push(_t177);
    _push(_t162);
    __esp = __esp - 80;
    _t178 = _v104;
    _t163 = _v100;
    _v156 = caml_local_roots;
    _v148 = 1;
    _v152 = 1;
    _v144 =  &_v108;
    _v188 =  &_v156;
    caml_local_roots =  &_v188;
    _v180 = _t178;
    _v184 = 1;
    _v176 = _t163;
    _v200 = 0;
    _t125 = _t178 + 1;
     *__esp = _t125;
    caml_alloc_small(_t163, _t178);
     *_t125 = _v108;
    if(_t178 > 0) {
        _t176 = 0;
        do {
             *((intOrPtr*)(_t125 + 4 + _t176 * 4)) =  *((intOrPtr*)(_t163 + _t176 * 4));
            _t176 = _t176 + 1;
        } while(_t176 != _t178);
    }
     *__esp = _t125;
    caml_raise();
    _push(_t185);
    _t186 = __esp;
    __esp = __esp - 104;
    _v248 = caml_local_roots;
    _v240 = 1;
    _v244 = 2;
    _v236 =  &_v200;
    _v232 =  &_v196;
    _v252 = 0;
    _v284 =  &_v248;
    caml_local_roots =  &_v284;
    _v276 = 1;
    _v280 = 1;
    _v272 =  &_v252;
    caml_alloc_small(_t163, _t178, 2, 0);
    _v252 =  &_v252;
    _v252 = _v200;
     *((intOrPtr*)(_v252 + 4)) = _v196;
     *__esp = _v252;
    caml_raise();
    _push(_t186);
    _t187 = __esp;
    __esp = __esp - 24;
    _v336 = _v308;
     *__esp =  &caml_exn_Sys_error;
    L19();
    _push(_t187);
    _t188 = __esp;
    __esp = __esp - 24;
    _t135 = _v332;
    caml_copy_string(_t163, __edi, _t178, _t135);
    _v364 = _t135;
     *__esp = _v336;
    L19();
    _push(_t188);
    _t189 = __esp;
    __esp = __esp - 24;
    _v392 = _v364;
     *__esp =  &caml_exn_Invalid_argument;
    L21();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 24;
    _v420 = _v392;
     *__esp =  &caml_exn_Failure;
    L21();
    _push(_t190);
    _t191 = __esp;
    __esp = __esp - 104;
    _v468 = caml_local_roots;
    _v460 = 1;
    _v464 = 1;
    _v456 =  &_v420;
    _v472 = 0;
    _v504 =  &_v468;
    caml_local_roots =  &_v504;
    _v496 = 1;
    _v500 = 1;
    _v492 =  &_v472;
    caml_alloc_small(_t163, _t178, 1, 0);
    _v472 =  &_v472;
    _v472 = _v420;
     *__esp = _v472;
    caml_raise();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L24();
    _push(_t192);
    _t193 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L24();
    _push(_t193);
    _t194 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L24();
    _push(_t194);
    _t195 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L24();
    _push(_t195);
    _push(__edi);
    _push(_t178);
    _push(_t163);
    __esp = __esp - 44;
    _t145 = _v636;
    if(_t145 != 0) {
        _v96 = _v44;
        _t173 = _v48;
        _v92 = _t145;
        while(1) {
            _t178 = caml_frame_descriptors_mask;
            _t150 = _t173 >> 3 & _t178;
            _t165 = caml_frame_descriptors;
            _t163 =  *(_t165 + _t150 * 4);
            if( *_t163 != _t173) {
                goto L34;
            }
            do {
L34:
                _t150 = _t150 + 1 & _t178;
                _t163 =  *(_t165 + _t150 * 4);
            } while( *_t163 != _t173);
L35:
            if( *(_t163 + 4) != 65535) {
                _t180 =  *(_t163 + 6) & 65535;
                if(_t180 > 0) {
                    __edi = _t163 + 8;
                    _v100 = _t163;
                    _t164 = _v56;
                    while(1) {
                        _t156 =  *__edi & 65535;
                        if((_t156 & 1) == 0) {
                            _t157 = _t156 + _v92;
                        } else {
                            _t157 = _v96 + (_t156 >> 1) * 4;
                        }
L41:
                        _v700 = _t157;
                         *__esp =  *_t157;
                         *_t164();
                        _t180 = _t180 - 1;
                        if(_t180 > 0) {
                            __edi = __edi + 2;
                            _t156 =  *__edi & 65535;
                            if((_t156 & 1) == 0) {
                                _t157 = _t156 + _v92;
                            } else {
                                _t157 = _v96 + (_t156 >> 1) * 4;
                            }
                            goto L41;
                        }
                        _t163 = _v100;
                        goto L44;
                    }
                }
L44:
                _v92 = _v92 + ( *(_t163 + 4) & 0xfffc);
                _t173 =  *(_v92 - 4);
                do {
                    _t178 = caml_frame_descriptors_mask;
                    _t150 = _t173 >> 3 & _t178;
                    _t165 = caml_frame_descriptors;
                    _t163 =  *(_t165 + _t150 * 4);
                    if( *_t163 != _t173) {
                        goto L34;
                    }
                    goto L35;
                } while(_v92 != 0);
                goto L31;
            }
            _t152 = _v92 + 8;
            _v92 =  *_t152;
            _t173 = _t152[1];
            _t145 = _t152[2];
            _v96 = _t152[2];
        }
    }
L31:
    if(_v40 != 0) {
        _t179 = _v40;
        _v92 = 0;
        do {
            __edi = 0;
            if(_t179[1] > 0) {
                do {
                    _t163 = _v92;
                    if(_t179[2] > 0) {
                        do {
                            _t147 = _t163 * 4 +  *((intOrPtr*)(_t179 + 12 + __edi * 4));
                            _v700 = _t147;
                            _t145 =  *_t147;
                             *__esp =  *_t147;
                            _v56();
                            _t163 = _t163 + 1;
                        } while(_t179[2] > _t163);
                    } else {
                    }
                    goto L48;
L48:
                    __edi = __edi + 1;
                } while(_t179[1] > __edi);
            } else {
            }
            goto L51;
L55:
L51:
            _t178 =  *_t179;
        } while( *_t179 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L55;
}

caml_array_bound_error()
{// addr = 0x0805C38D
    _unknown_ _v20;                        // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    signed int* _v36;                      // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    unsigned int _v44;                     // _cfa_ffffffd4
    intOrPtr* _v52;                        // _cfa_ffffffcc
    signed int _v72;                       // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    signed int _v88;                       // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    signed int _v148;                      // _cfa_ffffff6c
    signed int _v152;                      // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    char _v160;                            // _cfa_ffffff60
    char _v168;                            // _cfa_ffffff58 (outparam)
    char _v172;                            // _cfa_ffffff54 (outparam)
    char* _v204;                           // _cfa_ffffff34
    char* _v208;                           // _cfa_ffffff30
    intOrPtr _v212;                        // _cfa_ffffff2c
    intOrPtr _v216;                        // _cfa_ffffff28
    char _v220;                            // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    char* _v244;                           // _cfa_ffffff0c
    intOrPtr _v248;                        // _cfa_ffffff08
    intOrPtr _v252;                        // _cfa_ffffff04
    char _v256;                            // _cfa_ffffff00
    signed int _v280;                      // _cfa_fffffee8
    intOrPtr _v304;                        // _cfa_fffffed0
    signed int _v308;                      // _cfa_fffffecc
    char _v336;                            // _cfa_fffffeb0
    char _v364;                            // _cfa_fffffe94
    char _v392;                            // _cfa_fffffe78
    char* _v428;                           // _cfa_fffffe54
    intOrPtr _v432;                        // _cfa_fffffe50
    intOrPtr _v436;                        // _cfa_fffffe4c
    char _v440;                            // _cfa_fffffe48
    signed int _v444;                      // _cfa_fffffe44
    char* _v464;                           // _cfa_fffffe30
    intOrPtr _v468;                        // _cfa_fffffe2c
    intOrPtr _v472;                        // _cfa_fffffe28
    char _v476;                            // _cfa_fffffe24
    _unknown_ _v500;                       // _cfa_fffffe0c
    signed int _v608;                      // _cfa_fffffda0
    signed int* _v672;                     // _cfa_fffffd60
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t127;                      // _t127
    signed int _t135;                      // _t135
    signed int _t150;                      // _t150
    signed int* _t155;                     // _t155
    signed int _t158;                      // _t158
    signed int* _t160;                     // _t160
    signed int _t164;                      // _t164
    signed int* _t165;                     // _t165
    _unknown_ _t170;                       // _t170
    signed int _t171;                      // _t171
    intOrPtr* _t172;                       // _t172
    intOrPtr _t173;                        // _t173
    unsigned int _t180;                    // _t180
    signed int _t183;                      // _t183
    _unknown_ _t184;                       // _t184
    signed int* _t186;                     // _t186
    signed int _t187;                      // _t187
    _unknown_ _t188;                       // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int* _t193;                     // _t193
    signed int* _t194;                     // _t194
    signed int* _t195;                     // _t195
    signed int* _t196;                     // _t196
    signed int* _t197;                     // _t197
    signed int* _t198;                     // _t198
    signed int* _t199;                     // _t199
    signed int* _t200;                     // _t200
    signed int* _t201;                     // _t201

    if(array_bound_error_bucket_inited == 0) {
        array_bound_error_msg = 5372;
         *134694023 = 0;
        array_bound_error_bucket = 2048;
         *134694732 =  &caml_exn_Invalid_argument;
         *134694736 = "index out of bounds";
        array_bound_error_bucket_inited = 1;
        caml_page_table_add(4,  &array_bound_error_msg,  &caml_last_return_address);
        array_bound_error_bucket_inited = 1;
    }
     *__esp = 134694732;
    caml_raise();
    _push(_t188);
    _t189 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_bucket_Stack_overflow;
    caml_raise();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_bucket_Out_of_memory;
    caml_raise();
    _push(_t190);
    _t191 = __esp;
    _push(_t184);
    _push(_t170);
    __esp = __esp - 80;
    _t185 = _v76;
    _t171 = _v72;
    _v128 = caml_local_roots;
    _v120 = 1;
    _v124 = 1;
    _v116 =  &_v80;
    _v160 =  &_v128;
    caml_local_roots =  &_v160;
    _v152 = _t185;
    _v156 = 1;
    _v148 = _t171;
    _t127 = caml_alloc_small(_t171, _t185, _t185 + 1, 0);
     *_t127 = _v80;
    if(_t185 > 0) {
        _t183 = 0;
        do {
             *((intOrPtr*)(_t127 + 4 + _t183 * 4)) =  *((intOrPtr*)(_t171 + _t183 * 4));
            _t183 = _t183 + 1;
        } while(_t183 != _t185);
    }
     *__esp = _t127;
    caml_raise();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 104;
    _v220 = caml_local_roots;
    _v212 = 1;
    _v216 = 2;
    _v208 =  &_v172;
    _v204 =  &_v168;
    _v224 = 0;
    _v256 =  &_v220;
    caml_local_roots =  &_v256;
    _v248 = 1;
    _v252 = 1;
    _v244 =  &_v224;
    _t135 = caml_alloc_small(_t171, _t185, 2, 0);
    _v224 = _t135;
     *_t135 = _v172;
     *((intOrPtr*)(_v224 + 4)) = _v168;
     *__esp = _v224;
    caml_raise();
    _push(_t192);
    _t193 = __esp;
    __esp = __esp - 24;
    _v308 = _v280;
     *__esp =  &caml_exn_Sys_error;
    L9();
    _push(_t193);
    _t194 = __esp;
    __esp = __esp - 24;
    _v336 = caml_copy_string(_t171, __edi, _t185, _v304);
     *__esp = _v308;
    L9();
    _push(_t194);
    _t195 = __esp;
    __esp = __esp - 24;
    _v364 = _v336;
     *__esp =  &caml_exn_Invalid_argument;
    L11();
    _push(_t195);
    _t196 = __esp;
    __esp = __esp - 24;
    _v392 = _v364;
     *__esp =  &caml_exn_Failure;
    L11();
    _push(_t196);
    _t197 = __esp;
    __esp = __esp - 104;
    _v440 = caml_local_roots;
    _v432 = 1;
    _v436 = 1;
    _v428 =  &_v392;
    _v444 = 0;
    _v476 =  &_v440;
    caml_local_roots =  &_v476;
    _v468 = 1;
    _v472 = 1;
    _v464 =  &_v444;
    _t150 = caml_alloc_small(_t171, _t185, 1, 0);
    _v444 = _t150;
     *_t150 = _v392;
     *__esp = _v444;
    caml_raise();
    _push(_t197);
    _t198 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L14();
    _push(_t198);
    _t199 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L14();
    _push(_t199);
    _t200 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L14();
    _push(_t200);
    _t201 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L14();
    _push(_t201);
    _push(__edi);
    _push(_t185);
    _push(_t171);
    __esp = __esp - 44;
    _t153 = _v608;
    if(_t153 != 0) {
        _v92 = _v40;
        _t180 = _v44;
        _v88 = _t153;
        while(1) {
            _t185 = caml_frame_descriptors_mask;
            _t158 = _t180 >> 3 & _t185;
            _t173 = caml_frame_descriptors;
            _t171 =  *(_t173 + _t158 * 4);
            if( *_t171 != _t180) {
                goto L24;
            }
            do {
L24:
                _t158 = _t158 + 1 & _t185;
                _t171 =  *(_t173 + _t158 * 4);
            } while( *_t171 != _t180);
L25:
            if( *(_t171 + 4) != 65535) {
                _t187 =  *(_t171 + 6) & 65535;
                if(_t187 > 0) {
                    __edi = _t171 + 8;
                    _v96 = _t171;
                    _t172 = _v52;
                    while(1) {
                        _t164 =  *__edi & 65535;
                        if((_t164 & 1) == 0) {
                            _t165 = _t164 + _v88;
                        } else {
                            _t165 = _v92 + (_t164 >> 1) * 4;
                        }
L31:
                        _v672 = _t165;
                         *__esp =  *_t165;
                         *_t172();
                        _t187 = _t187 - 1;
                        if(_t187 > 0) {
                            __edi = __edi + 2;
                            _t164 =  *__edi & 65535;
                            if((_t164 & 1) == 0) {
                                _t165 = _t164 + _v88;
                            } else {
                                _t165 = _v92 + (_t164 >> 1) * 4;
                            }
                            goto L31;
                        }
                        _t171 = _v96;
                        goto L34;
                    }
                }
L34:
                _v88 = _v88 + ( *(_t171 + 4) & 0xfffc);
                _t180 =  *(_v88 - 4);
                do {
                    _t185 = caml_frame_descriptors_mask;
                    _t158 = _t180 >> 3 & _t185;
                    _t173 = caml_frame_descriptors;
                    _t171 =  *(_t173 + _t158 * 4);
                    if( *_t171 != _t180) {
                        goto L24;
                    }
                    goto L25;
                } while(_v88 != 0);
                goto L21;
            }
            _t160 = _v88 + 8;
            _v88 =  *_t160;
            _t180 = _t160[1];
            _t153 = _t160[2];
            _v92 = _t160[2];
        }
    }
L21:
    if(_v36 != 0) {
        _t186 = _v36;
        _v88 = 0;
        do {
            __edi = 0;
            if(_t186[1] > 0) {
                do {
                    _t171 = _v88;
                    if(_t186[2] > 0) {
                        do {
                            _t155 = _t171 * 4 +  *((intOrPtr*)(_t186 + 12 + __edi * 4));
                            _v672 = _t155;
                            _t153 =  *_t155;
                             *__esp =  *_t155;
                            _v52();
                            _t171 = _t171 + 1;
                        } while(_t186[2] > _t171);
                    } else {
                    }
                    goto L38;
L38:
                    __edi = __edi + 1;
                } while(_t186[1] > __edi);
            } else {
            }
            goto L41;
L45:
L41:
            _t185 =  *_t186;
        } while( *_t186 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L45;
}

caml_raise_stack_overflow()
{// addr = 0x0805C407
    signed int* _v32;                      // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    signed int _v120;                      // _cfa_ffffff88
    signed int _v124;                      // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    char _v132;                            // _cfa_ffffff7c
    char _v140;                            // _cfa_ffffff74
    char _v144;                            // _cfa_ffffff70 (outparam)
    char* _v176;                           // _cfa_ffffff50
    char* _v180;                           // _cfa_ffffff4c
    signed int _v184;                      // _cfa_ffffff48
    intOrPtr _v188;                        // _cfa_ffffff44
    char _v192;                            // _cfa_ffffff40
    signed int _v196;                      // _cfa_ffffff3c
    char* _v216;                           // _cfa_ffffff28
    signed int _v220;                      // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    char _v228;                            // _cfa_ffffff1c
    signed int _v252;                      // _cfa_ffffff04
    intOrPtr _v276;                        // _cfa_fffffeec
    signed int _v280;                      // _cfa_fffffee8
    char _v308;                            // _cfa_fffffecc
    char _v336;                            // _cfa_fffffeb0
    char _v364;                            // _cfa_fffffe94
    char* _v400;                           // _cfa_fffffe70
    signed int _v404;                      // _cfa_fffffe6c
    signed int _v408;                      // _cfa_fffffe68
    char _v412;                            // _cfa_fffffe64
    signed int _v416;                      // _cfa_fffffe60
    char* _v436;                           // _cfa_fffffe4c
    signed int _v440;                      // _cfa_fffffe48
    signed int _v444;                      // _cfa_fffffe44
    char _v448;                            // _cfa_fffffe40
    _unknown_ _v472;                       // _cfa_fffffe28
    signed int _v580;                      // _cfa_fffffdbc
    signed int* _v644;                     // _cfa_fffffd7c
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t124;                      // _t124
    signed int _t132;                      // _t132
    signed int _t147;                      // _t147
    signed int* _t152;                     // _t152
    signed int _t155;                      // _t155
    signed int* _t157;                     // _t157
    signed int _t161;                      // _t161
    signed int* _t162;                     // _t162
    _unknown_ _t166;                       // _t166
    signed int _t167;                      // _t167
    signed int _t168;                      // _t168
    intOrPtr _t169;                        // _t169
    unsigned int _t176;                    // _t176
    signed int _t179;                      // _t179
    _unknown_ _t180;                       // _t180
    signed int* _t182;                     // _t182
    signed int _t183;                      // _t183
    _unknown_ _t184;                       // _t184
    signed int* _t185;                     // _t185
    signed int* _t186;                     // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int* _t193;                     // _t193
    signed int* _t194;                     // _t194
    signed int* _t195;                     // _t195
    signed int* _t196;                     // _t196

     *__esp =  &caml_bucket_Stack_overflow;
    caml_raise();
    _push(_t184);
    _t185 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_bucket_Out_of_memory;
    caml_raise();
    _push(_t185);
    _t186 = __esp;
    _push(_t180);
    _push(_t166);
    __esp = __esp - 80;
    _t181 = _v48;
    _t167 = _v44;
    _v100 = caml_local_roots;
    _v92 = 1;
    _v96 = 1;
    _v88 =  &_v52;
    _v132 =  &_v100;
    caml_local_roots =  &_v132;
    _v124 = _t181;
    _v128 = 1;
    _v120 = _t167;
    _t124 = caml_alloc_small(_t167, _t181, _t181 + 1, 0);
     *_t124 = _v52;
    if(_t181 > 0) {
        _t179 = 0;
        do {
             *((intOrPtr*)(_t124 + 4 + _t179 * 4)) =  *((intOrPtr*)(_t167 + _t179 * 4));
            _t179 = _t179 + 1;
        } while(_t179 != _t181);
    }
     *__esp = _t124;
    caml_raise();
    _push(_t186);
    _t187 = __esp;
    __esp = __esp - 104;
    _v192 = caml_local_roots;
    _v184 = 1;
    _v188 = 2;
    _v180 =  &_v144;
    _v176 =  &_v140;
    _v196 = 0;
    _v228 =  &_v192;
    caml_local_roots =  &_v228;
    _v220 = 1;
    _v224 = 1;
    _v216 =  &_v196;
    _t132 = caml_alloc_small(_t167, _t181, 2, 0);
    _v196 = _t132;
     *_t132 = _v144;
     *((intOrPtr*)(_v196 + 4)) = _v140;
     *__esp = _v196;
    caml_raise();
    _push(_t187);
    _t188 = __esp;
    __esp = __esp - 24;
    _v280 = _v252;
     *__esp =  &caml_exn_Sys_error;
    L6();
    _push(_t188);
    _t189 = __esp;
    __esp = __esp - 24;
    _v308 = caml_copy_string(_t167, __edi, _t181, _v276);
     *__esp = _v280;
    L6();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 24;
    _v336 = _v308;
     *__esp =  &caml_exn_Invalid_argument;
    L8();
    _push(_t190);
    _t191 = __esp;
    __esp = __esp - 24;
    _v364 = _v336;
     *__esp =  &caml_exn_Failure;
    L8();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 104;
    _v412 = caml_local_roots;
    _v404 = 1;
    _v408 = 1;
    _v400 =  &_v364;
    _v416 = 0;
    _v448 =  &_v412;
    caml_local_roots =  &_v448;
    _v440 = 1;
    _v444 = 1;
    _v436 =  &_v416;
    _t147 = caml_alloc_small(_t167, _t181, 1, 0);
    _v416 = _t147;
     *_t147 = _v364;
     *__esp = _v416;
    caml_raise();
    _push(_t192);
    _t193 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L11();
    _push(_t193);
    _t194 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L11();
    _push(_t194);
    _t195 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L11();
    _push(_t195);
    _t196 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L11();
    _push(_t196);
    _push(__edi);
    _push(_t181);
    _push(_t167);
    __esp = __esp - 44;
    _t150 = _v580;
    if(_t150 != 0) {
        _v88 = _v36;
        _t176 = _v40;
        _v84 = _t150;
        while(1) {
            _t181 = caml_frame_descriptors_mask;
            _t155 = _t176 >> 3 & _t181;
            _t169 = caml_frame_descriptors;
            _t167 =  *(_t169 + _t155 * 4);
            if( *_t167 != _t176) {
                goto L21;
            }
            do {
L21:
                _t155 = _t155 + 1 & _t181;
                _t167 =  *(_t169 + _t155 * 4);
            } while( *_t167 != _t176);
L22:
            if( *(_t167 + 4) != 65535) {
                _t183 =  *(_t167 + 6) & 65535;
                if(_t183 > 0) {
                    __edi = _t167 + 8;
                    _v92 = _t167;
                    _t168 = _v48;
                    while(1) {
                        _t161 =  *__edi & 65535;
                        if((_t161 & 1) == 0) {
                            _t162 = _t161 + _v84;
                        } else {
                            _t162 = _v88 + (_t161 >> 1) * 4;
                        }
L28:
                        _v644 = _t162;
                         *__esp =  *_t162;
                         *_t168();
                        _t183 = _t183 - 1;
                        if(_t183 > 0) {
                            __edi = __edi + 2;
                            _t161 =  *__edi & 65535;
                            if((_t161 & 1) == 0) {
                                _t162 = _t161 + _v84;
                            } else {
                                _t162 = _v88 + (_t161 >> 1) * 4;
                            }
                            goto L28;
                        }
                        _t167 = _v92;
                        goto L31;
                    }
                }
L31:
                _v84 = _v84 + ( *(_t167 + 4) & 0xfffc);
                _t176 =  *(_v84 - 4);
                do {
                    _t181 = caml_frame_descriptors_mask;
                    _t155 = _t176 >> 3 & _t181;
                    _t169 = caml_frame_descriptors;
                    _t167 =  *(_t169 + _t155 * 4);
                    if( *_t167 != _t176) {
                        goto L21;
                    }
                    goto L22;
                } while(_v84 != 0);
                goto L18;
            }
            _t157 = _v84 + 8;
            _v84 =  *_t157;
            _t176 = _t157[1];
            _t150 = _t157[2];
            _v88 = _t157[2];
        }
    }
L18:
    if(_v32 != 0) {
        _t182 = _v32;
        _v84 = 0;
        do {
            __edi = 0;
            if(_t182[1] > 0) {
                do {
                    _t167 = _v84;
                    if(_t182[2] > 0) {
                        do {
                            _t152 = _t167 * 4 +  *((intOrPtr*)(_t182 + 12 + __edi * 4));
                            _v644 = _t152;
                            _t150 =  *_t152;
                             *__esp =  *_t152;
                            _v48();
                            _t167 = _t167 + 1;
                        } while(_t182[2] > _t167);
                    } else {
                    }
                    goto L35;
L35:
                    __edi = __edi + 1;
                } while(_t182[1] > __edi);
            } else {
            }
            goto L38;
L42:
L38:
            _t181 =  *_t182;
        } while( *_t182 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L42;
}

caml_raise_out_of_memory()
{// addr = 0x0805C419
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    signed int* _v28;                      // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr* _v44;                        // _cfa_ffffffd4
    char* _v60;                            // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    intOrPtr _v100;                        // _cfa_ffffff9c
    char _v104;                            // _cfa_ffffff98
    char _v112;                            // _cfa_ffffff90
    char _v116;                            // _cfa_ffffff8c (outparam)
    char* _v148;                           // _cfa_ffffff6c
    char* _v152;                           // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    char _v164;                            // _cfa_ffffff5c
    signed int _v168;                      // _cfa_ffffff58
    char* _v188;                           // _cfa_ffffff44
    intOrPtr _v192;                        // _cfa_ffffff40
    intOrPtr _v196;                        // _cfa_ffffff3c
    char _v200;                            // _cfa_ffffff38
    signed int _v224;                      // _cfa_ffffff20
    intOrPtr _v248;                        // _cfa_ffffff08
    signed int _v252;                      // _cfa_ffffff04
    char _v280;                            // _cfa_fffffee8
    char _v308;                            // _cfa_fffffecc
    char _v336;                            // _cfa_fffffeb0
    char* _v372;                           // _cfa_fffffe8c
    intOrPtr _v376;                        // _cfa_fffffe88
    intOrPtr _v380;                        // _cfa_fffffe84
    char _v384;                            // _cfa_fffffe80
    signed int _v388;                      // _cfa_fffffe7c
    char* _v408;                           // _cfa_fffffe68
    intOrPtr _v412;                        // _cfa_fffffe64
    intOrPtr _v416;                        // _cfa_fffffe60
    char _v420;                            // _cfa_fffffe5c
    _unknown_ _v444;                       // _cfa_fffffe44
    signed int _v552;                      // _cfa_fffffdd8
    signed int* _v616;                     // _cfa_fffffd98
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t123;                      // _t123
    signed int _t131;                      // _t131
    signed int _t146;                      // _t146
    signed int* _t151;                     // _t151
    signed int _t154;                      // _t154
    signed int* _t156;                     // _t156
    signed int _t160;                      // _t160
    signed int* _t161;                     // _t161
    _unknown_ _t165;                       // _t165
    signed int _t166;                      // _t166
    intOrPtr* _t167;                       // _t167
    intOrPtr _t168;                        // _t168
    unsigned int _t175;                    // _t175
    signed int _t178;                      // _t178
    _unknown_ _t179;                       // _t179
    signed int* _t181;                     // _t181
    signed int _t182;                      // _t182
    _unknown_ _t183;                       // _t183
    signed int* _t184;                     // _t184
    signed int* _t185;                     // _t185
    signed int* _t186;                     // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192
    signed int* _t193;                     // _t193
    signed int* _t194;                     // _t194

     *__esp =  &caml_bucket_Out_of_memory;
    caml_raise();
    _push(_t183);
    _t184 = __esp;
    _push(_t179);
    _push(_t165);
    __esp = __esp - 80;
    _t180 = _v20;
    _t166 = _v16;
    _v72 = caml_local_roots;
    _v64 = 1;
    _v68 = 1;
    _v60 =  &_v24;
    _v104 =  &_v72;
    caml_local_roots =  &_v104;
    _v96 = _t180;
    _v100 = 1;
    _v92 = _t166;
    _t123 = caml_alloc_small(_t166, _t180, _t180 + 1, 0);
     *_t123 = _v24;
    if(_t180 > 0) {
        _t178 = 0;
        do {
             *((intOrPtr*)(_t123 + 4 + _t178 * 4)) =  *((intOrPtr*)(_t166 + _t178 * 4));
            _t178 = _t178 + 1;
        } while(_t178 != _t180);
    }
     *__esp = _t123;
    caml_raise();
    _push(_t184);
    _t185 = __esp;
    __esp = __esp - 104;
    _v164 = caml_local_roots;
    _v156 = 1;
    _v160 = 2;
    _v152 =  &_v116;
    _v148 =  &_v112;
    _v168 = 0;
    _v200 =  &_v164;
    caml_local_roots =  &_v200;
    _v192 = 1;
    _v196 = 1;
    _v188 =  &_v168;
    _t131 = caml_alloc_small(_t166, _t180, 2, 0);
    _v168 = _t131;
     *_t131 = _v116;
     *((intOrPtr*)(_v168 + 4)) = _v112;
     *__esp = _v168;
    caml_raise();
    _push(_t185);
    _t186 = __esp;
    __esp = __esp - 24;
    _v252 = _v224;
     *__esp =  &caml_exn_Sys_error;
    L5();
    _push(_t186);
    _t187 = __esp;
    __esp = __esp - 24;
    _v280 = caml_copy_string(_t166, __edi, _t180, _v248);
     *__esp = _v252;
    L5();
    _push(_t187);
    _t188 = __esp;
    __esp = __esp - 24;
    _v308 = _v280;
     *__esp =  &caml_exn_Invalid_argument;
    L7();
    _push(_t188);
    _t189 = __esp;
    __esp = __esp - 24;
    _v336 = _v308;
     *__esp =  &caml_exn_Failure;
    L7();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 104;
    _v384 = caml_local_roots;
    _v376 = 1;
    _v380 = 1;
    _v372 =  &_v336;
    _v388 = 0;
    _v420 =  &_v384;
    caml_local_roots =  &_v420;
    _v412 = 1;
    _v416 = 1;
    _v408 =  &_v388;
    _t146 = caml_alloc_small(_t166, _t180, 1, 0);
    _v388 = _t146;
     *_t146 = _v336;
     *__esp = _v388;
    caml_raise();
    _push(_t190);
    _t191 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L10();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L10();
    _push(_t192);
    _t193 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L10();
    _push(_t193);
    _t194 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L10();
    _push(_t194);
    _push(__edi);
    _push(_t180);
    _push(_t166);
    __esp = __esp - 44;
    _t149 = _v552;
    if(_t149 != 0) {
        _v84 = _v32;
        _t175 = _v36;
        _v80 = _t149;
        while(1) {
            _t180 = caml_frame_descriptors_mask;
            _t154 = _t175 >> 3 & _t180;
            _t168 = caml_frame_descriptors;
            _t166 =  *(_t168 + _t154 * 4);
            if( *_t166 != _t175) {
                goto L20;
            }
            do {
L20:
                _t154 = _t154 + 1 & _t180;
                _t166 =  *(_t168 + _t154 * 4);
            } while( *_t166 != _t175);
L21:
            if( *(_t166 + 4) != 65535) {
                _t182 =  *(_t166 + 6) & 65535;
                if(_t182 > 0) {
                    __edi = _t166 + 8;
                    _v88 = _t166;
                    _t167 = _v44;
                    while(1) {
                        _t160 =  *__edi & 65535;
                        if((_t160 & 1) == 0) {
                            _t161 = _t160 + _v80;
                        } else {
                            _t161 = _v84 + (_t160 >> 1) * 4;
                        }
L27:
                        _v616 = _t161;
                         *__esp =  *_t161;
                         *_t167();
                        _t182 = _t182 - 1;
                        if(_t182 > 0) {
                            __edi = __edi + 2;
                            _t160 =  *__edi & 65535;
                            if((_t160 & 1) == 0) {
                                _t161 = _t160 + _v80;
                            } else {
                                _t161 = _v84 + (_t160 >> 1) * 4;
                            }
                            goto L27;
                        }
                        _t166 = _v88;
                        goto L30;
                    }
                }
L30:
                _v80 = _v80 + ( *(_t166 + 4) & 0xfffc);
                _t175 =  *(_v80 - 4);
                do {
                    _t180 = caml_frame_descriptors_mask;
                    _t154 = _t175 >> 3 & _t180;
                    _t168 = caml_frame_descriptors;
                    _t166 =  *(_t168 + _t154 * 4);
                    if( *_t166 != _t175) {
                        goto L20;
                    }
                    goto L21;
                } while(_v80 != 0);
                goto L17;
            }
            _t156 = _v80 + 8;
            _v80 =  *_t156;
            _t175 = _t156[1];
            _t149 = _t156[2];
            _v84 = _t156[2];
        }
    }
L17:
    if(_v28 != 0) {
        _t181 = _v28;
        _v80 = 0;
        do {
            __edi = 0;
            if(_t181[1] > 0) {
                do {
                    _t166 = _v80;
                    if(_t181[2] > 0) {
                        do {
                            _t151 = _t166 * 4 +  *((intOrPtr*)(_t181 + 12 + __edi * 4));
                            _v616 = _t151;
                            _t149 =  *_t151;
                             *__esp =  *_t151;
                            _v44();
                            _t166 = _t166 + 1;
                        } while(_t181[2] > _t166);
                    } else {
                    }
                    goto L34;
L34:
                    __edi = __edi + 1;
                } while(_t181[1] > __edi);
            } else {
            }
            goto L37;
L41:
L37:
            _t180 =  *_t181;
        } while( *_t181 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L41;
}

caml_raise_with_args(
    char _a4,                              // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0805C42B
    signed int* _v24;                      // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    unsigned int _v32;                     // _cfa_ffffffe0
    intOrPtr* _v36;                        // _cfa_ffffffdc
    intOrPtr* _v40;                        // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v84;                       // _cfa_ffffffac
    char _v88;                             // _cfa_ffffffa8 (outparam)
    char* _v120;                           // _cfa_ffffff88
    char* _v124;                           // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    char _v136;                            // _cfa_ffffff78
    signed int _v140;                      // _cfa_ffffff74
    char* _v160;                           // _cfa_ffffff60
    intOrPtr _v164;                        // _cfa_ffffff5c
    intOrPtr _v168;                        // _cfa_ffffff58
    char _v172;                            // _cfa_ffffff54
    signed int _v196;                      // _cfa_ffffff3c
    intOrPtr _v220;                        // _cfa_ffffff24
    signed int _v224;                      // _cfa_ffffff20
    char _v252;                            // _cfa_ffffff04
    char _v280;                            // _cfa_fffffee8
    char _v308;                            // _cfa_fffffecc
    char* _v344;                           // _cfa_fffffea8
    intOrPtr _v348;                        // _cfa_fffffea4
    intOrPtr _v352;                        // _cfa_fffffea0
    char _v356;                            // _cfa_fffffe9c
    signed int _v360;                      // _cfa_fffffe98
    char* _v380;                           // _cfa_fffffe84
    intOrPtr _v384;                        // _cfa_fffffe80
    intOrPtr _v388;                        // _cfa_fffffe7c
    char _v392;                            // _cfa_fffffe78
    _unknown_ _v416;                       // _cfa_fffffe60
    signed int _v524;                      // _cfa_fffffdf4
    signed int* _v588;                     // _cfa_fffffdb4
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t122;                      // _t122
    signed int _t130;                      // _t130
    signed int _t145;                      // _t145
    signed int* _t150;                     // _t150
    signed int _t153;                      // _t153
    signed int* _t155;                     // _t155
    signed int _t159;                      // _t159
    signed int* _t160;                     // _t160
    _unknown_ _t164;                       // _t164
    signed int _t165;                      // _t165
    intOrPtr* _t166;                       // _t166
    intOrPtr _t167;                        // _t167
    unsigned int _t174;                    // _t174
    signed int _t177;                      // _t177
    _unknown_ _t178;                       // _t178
    signed int* _t180;                     // _t180
    signed int _t181;                      // _t181
    _unknown_ _t182;                       // _t182
    signed int* _t183;                     // _t183
    signed int* _t184;                     // _t184
    signed int* _t185;                     // _t185
    signed int* _t186;                     // _t186
    signed int* _t187;                     // _t187
    signed int* _t188;                     // _t188
    signed int* _t189;                     // _t189
    signed int* _t190;                     // _t190
    signed int* _t191;                     // _t191
    signed int* _t192;                     // _t192

    _push(_t178);
    _push(_t164);
    __esp = __esp - 80;
    _t179 = _a8;
    _t165 = _a12;
    _v44 = caml_local_roots;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    _v76 =  &_v44;
    caml_local_roots =  &_v76;
    _v68 = _t179;
    _v72 = 1;
    _v64 = _t165;
    _t122 = caml_alloc_small(_t165, _t179, _t179 + 1, 0);
     *_t122 = _a4;
    if(_t179 > 0) {
        _t177 = 0;
        do {
             *((intOrPtr*)(_t122 + 4 + _t177 * 4)) =  *((intOrPtr*)(_t165 + _t177 * 4));
            _t177 = _t177 + 1;
        } while(_t177 != _t179);
    }
     *__esp = _t122;
    caml_raise();
    _push(_t182);
    _t183 = __esp;
    __esp = __esp - 104;
    _v136 = caml_local_roots;
    _v128 = 1;
    _v132 = 2;
    _v124 =  &_v88;
    _v120 =  &_v84;
    _v140 = 0;
    _v172 =  &_v136;
    caml_local_roots =  &_v172;
    _v164 = 1;
    _v168 = 1;
    _v160 =  &_v140;
    _t130 = caml_alloc_small(_t165, _t179, 2, 0);
    _v140 = _t130;
     *_t130 = _v88;
     *(_v140 + 4) = _v84;
     *__esp = _v140;
    caml_raise();
    _push(_t183);
    _t184 = __esp;
    __esp = __esp - 24;
    _v224 = _v196;
     *__esp =  &caml_exn_Sys_error;
    L4();
    _push(_t184);
    _t185 = __esp;
    __esp = __esp - 24;
    _v252 = caml_copy_string(_t165, __edi, _t179, _v220);
     *__esp = _v224;
    L4();
    _push(_t185);
    _t186 = __esp;
    __esp = __esp - 24;
    _v280 = _v252;
     *__esp =  &caml_exn_Invalid_argument;
    L6();
    _push(_t186);
    _t187 = __esp;
    __esp = __esp - 24;
    _v308 = _v280;
     *__esp =  &caml_exn_Failure;
    L6();
    _push(_t187);
    _t188 = __esp;
    __esp = __esp - 104;
    _v356 = caml_local_roots;
    _v348 = 1;
    _v352 = 1;
    _v344 =  &_v308;
    _v360 = 0;
    _v392 =  &_v356;
    caml_local_roots =  &_v392;
    _v384 = 1;
    _v388 = 1;
    _v380 =  &_v360;
    _t145 = caml_alloc_small(_t165, _t179, 1, 0);
    _v360 = _t145;
     *_t145 = _v308;
     *__esp = _v360;
    caml_raise();
    _push(_t188);
    _t189 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L9();
    _push(_t189);
    _t190 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L9();
    _push(_t190);
    _t191 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L9();
    _push(_t191);
    _t192 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L9();
    _push(_t192);
    _push(__edi);
    _push(_t179);
    _push(_t165);
    __esp = __esp - 44;
    _t148 = _v524;
    if(_t148 != 0) {
        _v80 = _v28;
        _t174 = _v32;
        _v76 = _t148;
        while(1) {
            _t179 = caml_frame_descriptors_mask;
            _t153 = _t174 >> 3 & _t179;
            _t167 = caml_frame_descriptors;
            _t165 =  *(_t167 + _t153 * 4);
            if( *_t165 != _t174) {
                goto L19;
            }
            do {
L19:
                _t153 = _t153 + 1 & _t179;
                _t165 =  *(_t167 + _t153 * 4);
            } while( *_t165 != _t174);
L20:
            if( *(_t165 + 4) != 65535) {
                _t181 =  *(_t165 + 6) & 65535;
                if(_t181 > 0) {
                    __edi = _t165 + 8;
                    _v84 = _t165;
                    _t166 = _v40;
                    while(1) {
                        _t159 =  *__edi & 65535;
                        if((_t159 & 1) == 0) {
                            _t160 = _t159 + _v76;
                        } else {
                            _t160 = _v80 + (_t159 >> 1) * 4;
                        }
L26:
                        _v588 = _t160;
                         *__esp =  *_t160;
                         *_t166();
                        _t181 = _t181 - 1;
                        if(_t181 > 0) {
                            __edi = __edi + 2;
                            _t159 =  *__edi & 65535;
                            if((_t159 & 1) == 0) {
                                _t160 = _t159 + _v76;
                            } else {
                                _t160 = _v80 + (_t159 >> 1) * 4;
                            }
                            goto L26;
                        }
                        _t165 = _v84;
                        goto L29;
                    }
                }
L29:
                _v76 = _v76 + ( *(_t165 + 4) & 0xfffc);
                _t174 =  *(_v76 - 4);
                do {
                    _t179 = caml_frame_descriptors_mask;
                    _t153 = _t174 >> 3 & _t179;
                    _t167 = caml_frame_descriptors;
                    _t165 =  *(_t167 + _t153 * 4);
                    if( *_t165 != _t174) {
                        goto L19;
                    }
                    goto L20;
                } while(_v76 != 0);
                goto L16;
            }
            _t155 = _v76 + 8;
            _v76 =  *_t155;
            _t174 = _t155[1];
            _t148 = _t155[2];
            _v80 = _t155[2];
        }
    }
L16:
    if(_v24 != 0) {
        _t180 = _v24;
        _v76 = 0;
        do {
            __edi = 0;
            if(_t180[1] > 0) {
                do {
                    _t165 = _v76;
                    if(_t180[2] > 0) {
                        do {
                            _t150 = _t165 * 4 +  *((intOrPtr*)(_t180 + 12 + __edi * 4));
                            _v588 = _t150;
                            _t148 =  *_t150;
                             *__esp =  *_t150;
                            _v40();
                            _t165 = _t165 + 1;
                        } while(_t180[2] > _t165);
                    } else {
                    }
                    goto L33;
L33:
                    __edi = __edi + 1;
                } while(_t180[1] > __edi);
            } else {
            }
            goto L36;
L40:
L36:
            _t179 =  *_t180;
        } while( *_t180 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L40;
}

caml_raise_with_arg(
    char _a4,                              // _cfa_4
    char _a8                               // _cfa_8
)
{// addr = 0x0805C4A7
    signed int* _v20;                      // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    char* _v68;                            // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    signed int _v80;                       // _cfa_ffffffb0
    signed int _v104;                      // _cfa_ffffff98
    intOrPtr _v128;                        // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    char _v160;                            // _cfa_ffffff60
    char _v188;                            // _cfa_ffffff44
    char _v216;                            // _cfa_ffffff28
    char* _v252;                           // _cfa_ffffff04
    signed int _v256;                      // _cfa_ffffff00
    signed int _v260;                      // _cfa_fffffefc
    char _v264;                            // _cfa_fffffef8
    signed int _v268;                      // _cfa_fffffef4
    char* _v288;                           // _cfa_fffffee0
    signed int _v292;                      // _cfa_fffffedc
    signed int _v296;                      // _cfa_fffffed8
    char _v300;                            // _cfa_fffffed4
    _unknown_ _v324;                       // _cfa_fffffebc (outparam)
    signed int _v432;                      // _cfa_fffffe50
    signed int* _v496;                     // _cfa_fffffe10
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t102;                      // _t102
    signed int _t119;                      // _t119
    signed int* _t124;                     // _t124
    signed int _t127;                      // _t127
    signed int* _t129;                     // _t129
    signed int _t133;                      // _t133
    signed int* _t134;                     // _t134
    signed int _t138;                      // _t138
    signed int _t139;                      // _t139
    unsigned int _t144;                    // _t144
    signed int* _t148;                     // _t148
    signed int _t149;                      // _t149
    _unknown_ _t150;                       // _t150
    signed int* _t151;                     // _t151
    signed int* _t152;                     // _t152
    signed int* _t153;                     // _t153
    signed int* _t154;                     // _t154
    signed int* _t155;                     // _t155
    signed int* _t156;                     // _t156
    signed int* _t157;                     // _t157
    signed int* _t158;                     // _t158
    signed int* _t159;                     // _t159

    _v44 = caml_local_roots;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _v48 = 0;
    _v80 =  &_v44;
    caml_local_roots =  &_v80;
    _v72 = 1;
    _v76 = 1;
    _v68 =  &_v48;
    _t102 = caml_alloc_small(_t138, _t147, 2, 0);
    _v48 = _t102;
     *_t102 = _a4;
     *((intOrPtr*)(_v48 + 4)) = _a8;
     *__esp = _v48;
    caml_raise();
    _push(_t150);
    _t151 = __esp;
    __esp = __esp - 24;
    _v132 = _v104;
     *__esp =  &caml_exn_Sys_error;
    caml_raise_with_arg();
    _push(_t151);
    _t152 = __esp;
    __esp = __esp - 24;
    _v160 = caml_copy_string(_t138, __edi, _t147, _v128);
     *__esp = _v132;
    caml_raise_with_arg();
    _push(_t152);
    _t153 = __esp;
    __esp = __esp - 24;
    _v188 = _v160;
     *__esp =  &caml_exn_Invalid_argument;
    L2();
    _push(_t153);
    _t154 = __esp;
    __esp = __esp - 24;
    _v216 = _v188;
     *__esp =  &caml_exn_Failure;
    L2();
    _push(_t154);
    _t155 = __esp;
    __esp = __esp - 104;
    _v264 = caml_local_roots;
    _v256 = 1;
    _v260 = 1;
    _v252 =  &_v216;
    _v268 = 0;
    _v300 =  &_v264;
    caml_local_roots =  &_v300;
    _v292 = 1;
    _v296 = 1;
    _v288 =  &_v268;
    _t119 = caml_alloc_small(_t138, _t147, 1, 0);
    _v268 = _t119;
     *_t119 = _v216;
     *__esp = _v268;
    caml_raise();
    _push(_t155);
    _t156 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L5();
    _push(_t156);
    _t157 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L5();
    _push(_t157);
    _t158 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L5();
    _push(_t158);
    _t159 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L5();
    _push(_t159);
    _push(__edi);
    _push(_t147);
    _push(_t138);
    __esp = __esp - 44;
    _t122 = _v432;
    if(_t122 != 0) {
        _v76 = _v24;
        _t144 = _v28;
        _v72 = _t122;
        while(1) {
            _t147 = caml_frame_descriptors_mask;
            _t127 = _t144 >> 3 & _t147;
            __ecx = caml_frame_descriptors;
            _t138 =  *(__ecx + _t127 * 4);
            if( *_t138 != _t144) {
                goto L15;
            }
            do {
L15:
                _t127 = _t127 + 1 & _t147;
                _t138 =  *(__ecx + _t127 * 4);
            } while( *_t138 != _t144);
L16:
            if( *(_t138 + 4) != 65535) {
                _t149 =  *(_t138 + 6) & 65535;
                if(_t149 > 0) {
                    __edi = _t138 + 8;
                    _v80 = _t138;
                    _t139 = _v36;
                    while(1) {
                        _t133 =  *__edi & 65535;
                        if((_t133 & 1) == 0) {
                            _t134 = _t133 + _v72;
                        } else {
                            _t134 = _v76 + (_t133 >> 1) * 4;
                        }
L22:
                        _v496 = _t134;
                         *__esp =  *_t134;
                         *_t139();
                        _t149 = _t149 - 1;
                        if(_t149 > 0) {
                            __edi = __edi + 2;
                            _t133 =  *__edi & 65535;
                            if((_t133 & 1) == 0) {
                                _t134 = _t133 + _v72;
                            } else {
                                _t134 = _v76 + (_t133 >> 1) * 4;
                            }
                            goto L22;
                        }
                        _t138 = _v80;
                        goto L25;
                    }
                }
L25:
                _v72 = _v72 + ( *(_t138 + 4) & 0xfffc);
                _t144 =  *(_v72 - 4);
                do {
                    _t147 = caml_frame_descriptors_mask;
                    _t127 = _t144 >> 3 & _t147;
                    __ecx = caml_frame_descriptors;
                    _t138 =  *(__ecx + _t127 * 4);
                    if( *_t138 != _t144) {
                        goto L15;
                    }
                    goto L16;
                } while(_v72 != 0);
                goto L12;
            }
            _t129 = _v72 + 8;
            _v72 =  *_t129;
            _t144 = _t129[1];
            _t122 = _t129[2];
            _v76 = _t129[2];
        }
    }
L12:
    if(_v20 != 0) {
        _t148 = _v20;
        _v72 = 0;
        do {
            __edi = 0;
            if(_t148[1] > 0) {
                do {
                    _t138 = _v72;
                    if(_t148[2] > 0) {
                        do {
                            _t124 = _t138 * 4 +  *((intOrPtr*)(_t148 + 12 + __edi * 4));
                            _v496 = _t124;
                            _t122 =  *_t124;
                             *__esp =  *_t124;
                            _v36();
                            _t138 = _t138 + 1;
                        } while(_t148[2] > _t138);
                    } else {
                    }
                    goto L29;
L29:
                    __edi = __edi + 1;
                } while(_t148[1] > __edi);
            } else {
            }
            goto L32;
L36:
L32:
            _t147 =  *_t148;
        } while( *_t148 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L36;
}

caml_raise_sys_error(
    unsigned int _a4                       // _cfa_4
)
{// addr = 0x0805C528
    signed int* _v16;                      // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    unsigned int _v24;                     // _cfa_ffffffe8
    intOrPtr* _v32;                        // _cfa_ffffffe0
    char _v52;                             // _cfa_ffffffcc
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    char _v108;                            // _cfa_ffffff94
    char* _v144;                           // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    intOrPtr _v152;                        // _cfa_ffffff68
    char _v156;                            // _cfa_ffffff64
    signed int _v160;                      // _cfa_ffffff60
    char* _v180;                           // _cfa_ffffff4c
    intOrPtr _v184;                        // _cfa_ffffff48
    intOrPtr _v188;                        // _cfa_ffffff44
    char _v192;                            // _cfa_ffffff40
    _unknown_ _v216;                       // _cfa_ffffff28 (outparam)
    signed int _v324;                      // _cfa_fffffebc
    signed int* _v388;                     // _cfa_fffffe7c
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t87;                       // _t87
    signed int* _t92;                      // _t92
    signed int _t95;                       // _t95
    signed int* _t97;                      // _t97
    signed int _t101;                      // _t101
    signed int* _t102;                     // _t102
    signed int _t106;                      // _t106
    intOrPtr* _t107;                       // _t107
    unsigned int _t110;                    // _t110
    signed int* _t114;                     // _t114
    signed int _t115;                      // _t115
    _unknown_ _t116;                       // _t116
    signed int* _t117;                     // _t117
    signed int* _t118;                     // _t118
    signed int* _t119;                     // _t119
    signed int* _t120;                     // _t120
    signed int* _t121;                     // _t121
    signed int* _t122;                     // _t122
    signed int* _t123;                     // _t123
    signed int* _t124;                     // _t124

    _v24 = _a4;
     *__esp =  &caml_exn_Sys_error;
    caml_raise_with_arg();
    _push(_t116);
    _t117 = __esp;
    __esp = __esp - 24;
    _v52 = caml_copy_string(_t106, __edi, _t113, _v20);
     *__esp = _v24;
    caml_raise_with_arg();
    _push(_t117);
    _t118 = __esp;
    __esp = __esp - 24;
    _v80 = _v52;
     *__esp =  &caml_exn_Invalid_argument;
    L1();
    _push(_t118);
    _t119 = __esp;
    __esp = __esp - 24;
    _v108 = _v80;
     *__esp =  &caml_exn_Failure;
    L1();
    _push(_t119);
    _t120 = __esp;
    __esp = __esp - 104;
    _v156 = caml_local_roots;
    _v148 = 1;
    _v152 = 1;
    _v144 =  &_v108;
    _v160 = 0;
    _v192 =  &_v156;
    caml_local_roots =  &_v192;
    _v184 = 1;
    _v188 = 1;
    _v180 =  &_v160;
    _t87 = caml_alloc_small(_t106, _t113, 1, 0);
    _v160 = _t87;
     *_t87 = _v108;
     *__esp = _v160;
    caml_raise();
    _push(_t120);
    _t121 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L4();
    _push(_t121);
    _t122 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L4();
    _push(_t122);
    _t123 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L4();
    _push(_t123);
    _t124 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L4();
    _push(_t124);
    _push(__edi);
    _push(_t113);
    _push(_t106);
    __esp = __esp - 44;
    _t90 = _v324;
    if(_t90 != 0) {
        _v72 = _v20;
        _t110 = _v24;
        _v68 = _t90;
        while(1) {
            _t113 = caml_frame_descriptors_mask;
            _t95 = _t110 >> 3 & _t113;
            __ecx = caml_frame_descriptors;
            _t106 =  *(__ecx + _t95 * 4);
            if( *_t106 != _t110) {
                goto L14;
            }
            do {
L14:
                _t95 = _t95 + 1 & _t113;
                _t106 =  *(__ecx + _t95 * 4);
            } while( *_t106 != _t110);
L15:
            if( *(_t106 + 4) != 65535) {
                _t115 =  *(_t106 + 6) & 65535;
                if(_t115 > 0) {
                    __edi = _t106 + 8;
                    _v76 = _t106;
                    _t107 = _v32;
                    while(1) {
                        _t101 =  *__edi & 65535;
                        if((_t101 & 1) == 0) {
                            _t102 = _t101 + _v68;
                        } else {
                            _t102 = _v72 + (_t101 >> 1) * 4;
                        }
L21:
                        _v388 = _t102;
                         *__esp =  *_t102;
                         *_t107();
                        _t115 = _t115 - 1;
                        if(_t115 > 0) {
                            __edi = __edi + 2;
                            _t101 =  *__edi & 65535;
                            if((_t101 & 1) == 0) {
                                _t102 = _t101 + _v68;
                            } else {
                                _t102 = _v72 + (_t101 >> 1) * 4;
                            }
                            goto L21;
                        }
                        _t106 = _v76;
                        goto L24;
                    }
                }
L24:
                _v68 = _v68 + ( *(_t106 + 4) & 0xfffc);
                _t110 =  *(_v68 - 4);
                do {
                    _t113 = caml_frame_descriptors_mask;
                    _t95 = _t110 >> 3 & _t113;
                    __ecx = caml_frame_descriptors;
                    _t106 =  *(__ecx + _t95 * 4);
                    if( *_t106 != _t110) {
                        goto L14;
                    }
                    goto L15;
                } while(_v68 != 0);
                goto L11;
            }
            _t97 = _v68 + 8;
            _v68 =  *_t97;
            _t110 = _t97[1];
            _t90 = _t97[2];
            _v72 = _t97[2];
        }
    }
L11:
    if(_v16 != 0) {
        _t114 = _v16;
        _v68 = 0;
        do {
            __edi = 0;
            if(_t114[1] > 0) {
                do {
                    _t106 = _v68;
                    if(_t114[2] > 0) {
                        do {
                            _t92 = _t106 * 4 +  *((intOrPtr*)(_t114 + 12 + __edi * 4));
                            _v388 = _t92;
                            _t90 =  *_t92;
                             *__esp =  *_t92;
                            _v32();
                            _t106 = _t106 + 1;
                        } while(_t114[2] > _t106);
                    } else {
                    }
                    goto L28;
L28:
                    __edi = __edi + 1;
                } while(_t114[1] > __edi);
            } else {
            }
            goto L31;
L35:
L31:
            _t113 =  *_t114;
        } while( *_t114 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L35;
}

caml_raise_with_string(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805C541
    signed int* _v12;                      // _cfa_fffffff4
    signed int _v16;                       // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    intOrPtr* _v28;                        // _cfa_ffffffe4
    char _v52;                             // _cfa_ffffffcc
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    char _v80;                             // _cfa_ffffffb0
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    char _v128;                            // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    char* _v152;                           // _cfa_ffffff68
    intOrPtr _v156;                        // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    char _v164;                            // _cfa_ffffff5c
    _unknown_ _v188;                       // _cfa_ffffff44 (outparam)
    signed int _v296;                      // _cfa_fffffed8
    signed int* _v360;                     // _cfa_fffffe98
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t85;                       // _t85
    signed int* _t90;                      // _t90
    signed int _t93;                       // _t93
    signed int* _t95;                      // _t95
    signed int _t99;                       // _t99
    signed int* _t100;                     // _t100
    signed int _t104;                      // _t104
    intOrPtr* _t105;                       // _t105
    unsigned int _t108;                    // _t108
    signed int* _t112;                     // _t112
    signed int _t113;                      // _t113
    _unknown_ _t114;                       // _t114
    signed int* _t115;                     // _t115
    signed int* _t116;                     // _t116
    signed int* _t117;                     // _t117
    signed int* _t118;                     // _t118
    signed int* _t119;                     // _t119
    signed int* _t120;                     // _t120
    signed int* _t121;                     // _t121

    _v24 = caml_copy_string(_t104, __edi, _t111, _a8);
     *__esp = _a4;
    caml_raise_with_arg();
    _push(_t114);
    _t115 = __esp;
    __esp = __esp - 24;
    _v52 = _v24;
     *__esp =  &caml_exn_Invalid_argument;
    caml_raise_with_string();
    _push(_t115);
    _t116 = __esp;
    __esp = __esp - 24;
    _v80 = _v52;
     *__esp =  &caml_exn_Failure;
    caml_raise_with_string();
    _push(_t116);
    _t117 = __esp;
    __esp = __esp - 104;
    _v128 = caml_local_roots;
    _v120 = 1;
    _v124 = 1;
    _v116 =  &_v80;
    _v132 = 0;
    _v164 =  &_v128;
    caml_local_roots =  &_v164;
    _v156 = 1;
    _v160 = 1;
    _v152 =  &_v132;
    _t85 = caml_alloc_small(_t104, _t111, 1, 0);
    _v132 = _t85;
     *_t85 = _v80;
     *__esp = _v132;
    caml_raise();
    _push(_t117);
    _t118 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L3();
    _push(_t118);
    _t119 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L3();
    _push(_t119);
    _t120 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L3();
    _push(_t120);
    _t121 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L3();
    _push(_t121);
    _push(__edi);
    _push(_t111);
    _push(_t104);
    __esp = __esp - 44;
    _t88 = _v296;
    if(_t88 != 0) {
        _v68 = _v16;
        _t108 = _v20;
        _v64 = _t88;
        while(1) {
            _t111 = caml_frame_descriptors_mask;
            _t93 = _t108 >> 3 & _t111;
            __ecx = caml_frame_descriptors;
            _t104 =  *(__ecx + _t93 * 4);
            if( *_t104 != _t108) {
                goto L13;
            }
            do {
L13:
                _t93 = _t93 + 1 & _t111;
                _t104 =  *(__ecx + _t93 * 4);
            } while( *_t104 != _t108);
L14:
            if( *(_t104 + 4) != 65535) {
                _t113 =  *(_t104 + 6) & 65535;
                if(_t113 > 0) {
                    __edi = _t104 + 8;
                    _v72 = _t104;
                    _t105 = _v28;
                    while(1) {
                        _t99 =  *__edi & 65535;
                        if((_t99 & 1) == 0) {
                            _t100 = _t99 + _v64;
                        } else {
                            _t100 = _v68 + (_t99 >> 1) * 4;
                        }
L20:
                        _v360 = _t100;
                         *__esp =  *_t100;
                         *_t105();
                        _t113 = _t113 - 1;
                        if(_t113 > 0) {
                            __edi = __edi + 2;
                            _t99 =  *__edi & 65535;
                            if((_t99 & 1) == 0) {
                                _t100 = _t99 + _v64;
                            } else {
                                _t100 = _v68 + (_t99 >> 1) * 4;
                            }
                            goto L20;
                        }
                        _t104 = _v72;
                        goto L23;
                    }
                }
L23:
                _v64 = _v64 + ( *(_t104 + 4) & 0xfffc);
                _t108 =  *(_v64 - 4);
                do {
                    _t111 = caml_frame_descriptors_mask;
                    _t93 = _t108 >> 3 & _t111;
                    __ecx = caml_frame_descriptors;
                    _t104 =  *(__ecx + _t93 * 4);
                    if( *_t104 != _t108) {
                        goto L13;
                    }
                    goto L14;
                } while(_v64 != 0);
                goto L10;
            }
            _t95 = _v64 + 8;
            _v64 =  *_t95;
            _t108 = _t95[1];
            _t88 = _t95[2];
            _v68 = _t95[2];
        }
    }
L10:
    if(_v12 != 0) {
        _t112 = _v12;
        _v64 = 0;
        do {
            __edi = 0;
            if(_t112[1] > 0) {
                do {
                    _t104 = _v64;
                    if(_t112[2] > 0) {
                        do {
                            _t90 = _t104 * 4 +  *((intOrPtr*)(_t112 + 12 + __edi * 4));
                            _v360 = _t90;
                            _t88 =  *_t90;
                             *__esp =  *_t90;
                            _v28();
                            _t104 = _t104 + 1;
                        } while(_t112[2] > _t104);
                    } else {
                    }
                    goto L27;
L27:
                    __edi = __edi + 1;
                } while(_t112[1] > __edi);
            } else {
            }
            goto L30;
L34:
L30:
            _t111 =  *_t112;
        } while( *_t112 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L34;
}

caml_invalid_argument(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805C561
    signed int* _v8;                       // _cfa_fffffff8
    signed int _v12;                       // _cfa_fffffff4
    unsigned int _v16;                     // _cfa_fffffff0
    _unknown_ _v24;                        // _cfa_ffffffe8
    char _v52;                             // _cfa_ffffffcc
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char* _v88;                            // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    char* _v124;                           // _cfa_ffffff84
    intOrPtr _v128;                        // _cfa_ffffff80
    intOrPtr _v132;                        // _cfa_ffffff7c
    char _v136;                            // _cfa_ffffff78
    _unknown_ _v160;                       // _cfa_ffffff60 (outparam)
    signed int _v268;                      // _cfa_fffffef4
    signed int* _v332;                     // _cfa_fffffeb4
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t78;                       // _t78
    signed int* _t83;                      // _t83
    signed int _t86;                       // _t86
    signed int* _t88;                      // _t88
    signed int _t92;                       // _t92
    signed int* _t93;                      // _t93
    signed int _t97;                       // _t97
    intOrPtr* _t98;                        // _t98
    unsigned int _t101;                    // _t101
    signed int* _t105;                     // _t105
    signed int _t106;                      // _t106
    _unknown_ _t107;                       // _t107
    signed int* _t108;                     // _t108
    signed int* _t109;                     // _t109
    signed int* _t110;                     // _t110
    signed int* _t111;                     // _t111
    signed int* _t112;                     // _t112
    signed int* _t113;                     // _t113

    _v24 = _a4;
     *__esp =  &caml_exn_Invalid_argument;
    caml_raise_with_string();
    _push(_t107);
    _t108 = __esp;
    __esp = __esp - 24;
    _v52 = _v24;
     *__esp =  &caml_exn_Failure;
    caml_raise_with_string();
    _push(_t108);
    _t109 = __esp;
    __esp = __esp - 104;
    _v100 = caml_local_roots;
    _v92 = 1;
    _v96 = 1;
    _v88 =  &_v52;
    _v104 = 0;
    _v136 =  &_v100;
    caml_local_roots =  &_v136;
    _v128 = 1;
    _v132 = 1;
    _v124 =  &_v104;
    _t78 = caml_alloc_small(_t97, _t104, 1, 0);
    _v104 = _t78;
     *_t78 = _v52;
     *__esp = _v104;
    caml_raise();
    _push(_t109);
    _t110 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L2();
    _push(_t110);
    _t111 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L2();
    _push(_t111);
    _t112 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L2();
    _push(_t112);
    _t113 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L2();
    _push(_t113);
    _push(__edi);
    _push(_t104);
    _push(_t97);
    __esp = __esp - 44;
    _t81 = _v268;
    if(_t81 != 0) {
        _v64 = _v12;
        _t101 = _v16;
        _v60 = _t81;
        while(1) {
            _t104 = caml_frame_descriptors_mask;
            _t86 = _t101 >> 3 & _t104;
            __ecx = caml_frame_descriptors;
            _t97 =  *(__ecx + _t86 * 4);
            if( *_t97 != _t101) {
                goto L12;
            }
            do {
L12:
                _t86 = _t86 + 1 & _t104;
                _t97 =  *(__ecx + _t86 * 4);
            } while( *_t97 != _t101);
L13:
            if( *(_t97 + 4) != 65535) {
                _t106 =  *(_t97 + 6) & 65535;
                if(_t106 > 0) {
                    __edi = _t97 + 8;
                    _v68 = _t97;
                    _t98 = _v24;
                    while(1) {
                        _t92 =  *__edi & 65535;
                        if((_t92 & 1) == 0) {
                            _t93 = _t92 + _v60;
                        } else {
                            _t93 = _v64 + (_t92 >> 1) * 4;
                        }
L19:
                        _v332 = _t93;
                         *__esp =  *_t93;
                         *_t98();
                        _t106 = _t106 - 1;
                        if(_t106 > 0) {
                            __edi = __edi + 2;
                            _t92 =  *__edi & 65535;
                            if((_t92 & 1) == 0) {
                                _t93 = _t92 + _v60;
                            } else {
                                _t93 = _v64 + (_t92 >> 1) * 4;
                            }
                            goto L19;
                        }
                        _t97 = _v68;
                        goto L22;
                    }
                }
L22:
                _v60 = _v60 + ( *(_t97 + 4) & 0xfffc);
                _t101 =  *(_v60 - 4);
                do {
                    _t104 = caml_frame_descriptors_mask;
                    _t86 = _t101 >> 3 & _t104;
                    __ecx = caml_frame_descriptors;
                    _t97 =  *(__ecx + _t86 * 4);
                    if( *_t97 != _t101) {
                        goto L12;
                    }
                    goto L13;
                } while(_v60 != 0);
                goto L9;
            }
            _t88 = _v60 + 8;
            _v60 =  *_t88;
            _t101 = _t88[1];
            _t81 = _t88[2];
            _v64 = _t88[2];
        }
    }
L9:
    if(_v8 != 0) {
        _t105 = _v8;
        _v60 = 0;
        do {
            __edi = 0;
            if(_t105[1] > 0) {
                do {
                    _t97 = _v60;
                    if(_t105[2] > 0) {
                        do {
                            _t83 = _t97 * 4 +  *((intOrPtr*)(_t105 + 12 + __edi * 4));
                            _v332 = _t83;
                            _t81 =  *_t83;
                             *__esp =  *_t83;
                            _v24();
                            _t97 = _t97 + 1;
                        } while(_t105[2] > _t97);
                    } else {
                    }
                    goto L26;
L26:
                    __edi = __edi + 1;
                } while(_t105[1] > __edi);
            } else {
            }
            goto L29;
L33:
L29:
            _t104 =  *_t105;
        } while( *_t105 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L33;
}

caml_failwith(
    char _a4                               // _cfa_4
)
{// addr = 0x0805C57A
    signed int* _v4;                       // _cfa_fffffffc
    signed int _v8;                        // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    intOrPtr* _v20;                        // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char _v72;                             // _cfa_ffffffb8
    signed int _v76;                       // _cfa_ffffffb4
    char* _v96;                            // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    char _v108;                            // _cfa_ffffff94
    _unknown_ _v132;                       // _cfa_ffffff7c (outparam)
    signed int _v240;                      // _cfa_ffffff10
    signed int* _v304;                     // _cfa_fffffed0
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t74;                       // _t74
    signed int* _t79;                      // _t79
    signed int _t82;                       // _t82
    signed int* _t84;                      // _t84
    signed int _t88;                       // _t88
    signed int* _t89;                      // _t89
    signed int _t93;                       // _t93
    intOrPtr* _t94;                        // _t94
    unsigned int _t97;                     // _t97
    signed int* _t101;                     // _t101
    signed int _t102;                      // _t102
    _unknown_ _t103;                       // _t103
    signed int* _t104;                     // _t104
    signed int* _t105;                     // _t105
    signed int* _t106;                     // _t106
    signed int* _t107;                     // _t107
    signed int* _t108;                     // _t108

    _v24 = _a4;
     *__esp =  &caml_exn_Failure;
    caml_raise_with_string();
    _push(_t103);
    _t104 = __esp;
    __esp = __esp - 104;
    _v72 = caml_local_roots;
    _v64 = 1;
    _v68 = 1;
    _v60 =  &_v24;
    _v76 = 0;
    _v108 =  &_v72;
    caml_local_roots =  &_v108;
    _v100 = 1;
    _v104 = 1;
    _v96 =  &_v76;
    _t74 = caml_alloc_small(_t93, _t100, 1, 0);
    _v76 = _t74;
     *_t74 = _v24;
     *__esp = _v76;
    caml_raise();
    _push(_t104);
    _t105 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    L1();
    _push(_t105);
    _t106 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    L1();
    _push(_t106);
    _t107 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    L1();
    _push(_t107);
    _t108 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    L1();
    _push(_t108);
    _push(__edi);
    _push(_t100);
    _push(_t93);
    __esp = __esp - 44;
    _t77 = _v240;
    if(_t77 != 0) {
        _v60 = _v8;
        _t97 = _v12;
        _v56 = _t77;
        while(1) {
            _t100 = caml_frame_descriptors_mask;
            _t82 = _t97 >> 3 & _t100;
            __ecx = caml_frame_descriptors;
            _t93 =  *(__ecx + _t82 * 4);
            if( *_t93 != _t97) {
                goto L11;
            }
            do {
L11:
                _t82 = _t82 + 1 & _t100;
                _t93 =  *(__ecx + _t82 * 4);
            } while( *_t93 != _t97);
L12:
            if( *(_t93 + 4) != 65535) {
                _t102 =  *(_t93 + 6) & 65535;
                if(_t102 > 0) {
                    __edi = _t93 + 8;
                    _v64 = _t93;
                    _t94 = _v20;
                    while(1) {
                        _t88 =  *__edi & 65535;
                        if((_t88 & 1) == 0) {
                            _t89 = _t88 + _v56;
                        } else {
                            _t89 = _v60 + (_t88 >> 1) * 4;
                        }
L18:
                        _v304 = _t89;
                         *__esp =  *_t89;
                         *_t94();
                        _t102 = _t102 - 1;
                        if(_t102 > 0) {
                            __edi = __edi + 2;
                            _t88 =  *__edi & 65535;
                            if((_t88 & 1) == 0) {
                                _t89 = _t88 + _v56;
                            } else {
                                _t89 = _v60 + (_t88 >> 1) * 4;
                            }
                            goto L18;
                        }
                        _t93 = _v64;
                        goto L21;
                    }
                }
L21:
                _v56 = _v56 + ( *(_t93 + 4) & 0xfffc);
                _t97 =  *(_v56 - 4);
                do {
                    _t100 = caml_frame_descriptors_mask;
                    _t82 = _t97 >> 3 & _t100;
                    __ecx = caml_frame_descriptors;
                    _t93 =  *(__ecx + _t82 * 4);
                    if( *_t93 != _t97) {
                        goto L11;
                    }
                    goto L12;
                } while(_v56 != 0);
                goto L8;
            }
            _t84 = _v56 + 8;
            _v56 =  *_t84;
            _t97 = _t84[1];
            _t77 = _t84[2];
            _v60 = _t84[2];
        }
    }
L8:
    if(_v4 != 0) {
        _t101 = _v4;
        _v56 = 0;
        do {
            __edi = 0;
            if(_t101[1] > 0) {
                do {
                    _t93 = _v56;
                    if(_t101[2] > 0) {
                        do {
                            _t79 = _t93 * 4 +  *((intOrPtr*)(_t101 + 12 + __edi * 4));
                            _v304 = _t79;
                            _t77 =  *_t79;
                             *__esp =  *_t79;
                            _v20();
                            _t93 = _t93 + 1;
                        } while(_t101[2] > _t93);
                    } else {
                    }
                    goto L25;
L25:
                    __edi = __edi + 1;
                } while(_t101[1] > __edi);
            } else {
            }
            goto L28;
L32:
L28:
            _t100 =  *_t101;
        } while( *_t101 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L32;
}

caml_raise_constant(
    char _a4                               // _cfa_4
)
{// addr = 0x0805C593
    signed int* _v0;                       // _cfa_0
    signed int _v4;                        // _cfa_fffffffc
    unsigned int _v8;                      // _cfa_fffffff8
    intOrPtr* _v16;                        // _cfa_fffffff0
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    signed int _v212;                      // _cfa_ffffff2c
    signed int* _v276;                     // _cfa_fffffeec
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t70;                       // _t70
    signed int* _t79;                      // _t79
    signed int _t82;                       // _t82
    signed int* _t84;                      // _t84
    signed int _t88;                       // _t88
    signed int* _t89;                      // _t89
    signed int _t93;                       // _t93
    intOrPtr* _t94;                        // _t94
    unsigned int _t97;                     // _t97
    signed int* _t101;                     // _t101
    signed int _t102;                      // _t102
    _unknown_ _t103;                       // _t103
    signed int* _t104;                     // _t104
    signed int* _t105;                     // _t105
    signed int* _t106;                     // _t106
    signed int* _t107;                     // _t107

    _v44 = caml_local_roots;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    _v48 = 0;
    _v80 =  &_v44;
    caml_local_roots =  &_v80;
    _v72 = 1;
    _v76 = 1;
    _v68 =  &_v48;
    _t70 = caml_alloc_small(_t93, _t100, 1, 0);
    _v48 = _t70;
     *_t70 = _a4;
     *__esp = _v48;
    caml_raise();
    _push(_t103);
    _t104 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Sys_blocked_io;
    caml_raise_constant();
    _push(_t104);
    _t105 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    caml_raise_constant();
    _push(_t105);
    _t106 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    caml_raise_constant();
    _push(_t106);
    _t107 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t107);
    _push(__edi);
    _push(_t100);
    _push(_t93);
    __esp = __esp - 44;
    _t77 = _v212;
    if(_t77 != 0) {
        _v56 = _v4;
        _t97 = _v8;
        _v52 = _t77;
        while(1) {
            _t100 = caml_frame_descriptors_mask;
            _t82 = _t97 >> 3 & _t100;
            __ecx = caml_frame_descriptors;
            _t93 =  *(__ecx + _t82 * 4);
            if( *_t93 != _t97) {
                goto L10;
            }
            do {
L10:
                _t82 = _t82 + 1 & _t100;
                _t93 =  *(__ecx + _t82 * 4);
            } while( *_t93 != _t97);
L11:
            if( *(_t93 + 4) != 65535) {
                _t102 =  *(_t93 + 6) & 65535;
                if(_t102 > 0) {
                    __edi = _t93 + 8;
                    _v60 = _t93;
                    _t94 = _v16;
                    while(1) {
                        _t88 =  *__edi & 65535;
                        if((_t88 & 1) == 0) {
                            _t89 = _t88 + _v52;
                        } else {
                            _t89 = _v56 + (_t88 >> 1) * 4;
                        }
L17:
                        _v276 = _t89;
                         *__esp =  *_t89;
                         *_t94();
                        _t102 = _t102 - 1;
                        if(_t102 > 0) {
                            __edi = __edi + 2;
                            _t88 =  *__edi & 65535;
                            if((_t88 & 1) == 0) {
                                _t89 = _t88 + _v52;
                            } else {
                                _t89 = _v56 + (_t88 >> 1) * 4;
                            }
                            goto L17;
                        }
                        _t93 = _v60;
                        goto L20;
                    }
                }
L20:
                _v52 = _v52 + ( *(_t93 + 4) & 0xfffc);
                _t97 =  *(_v52 - 4);
                do {
                    _t100 = caml_frame_descriptors_mask;
                    _t82 = _t97 >> 3 & _t100;
                    __ecx = caml_frame_descriptors;
                    _t93 =  *(__ecx + _t82 * 4);
                    if( *_t93 != _t97) {
                        goto L10;
                    }
                    goto L11;
                } while(_v52 != 0);
                goto L7;
            }
            _t84 = _v52 + 8;
            _v52 =  *_t84;
            _t97 = _t84[1];
            _t77 = _t84[2];
            _v56 = _t84[2];
        }
    }
L7:
    if(_v0 != 0) {
        _t101 = _v0;
        _v52 = 0;
        do {
            __edi = 0;
            if(_t101[1] > 0) {
                do {
                    _t93 = _v52;
                    if(_t101[2] > 0) {
                        do {
                            _t79 = _t93 * 4 +  *((intOrPtr*)(_t101 + 12 + __edi * 4));
                            _v276 = _t79;
                            _t77 =  *_t79;
                             *__esp =  *_t79;
                            _v16();
                            _t93 = _t93 + 1;
                        } while(_t101[2] > _t93);
                    } else {
                    }
                    goto L24;
L24:
                    __edi = __edi + 1;
                } while(_t101[1] > __edi);
            } else {
            }
            goto L27;
L31:
L27:
            _t100 =  *_t101;
        } while( *_t101 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L31;
}

caml_raise_sys_blocked_io(
    signed int* _a4                        // _cfa_4
)
{// addr = 0x0805C605
    signed int _v0;                        // _cfa_0
    unsigned int _v4;                      // _cfa_fffffffc
    intOrPtr* _v12;                        // _cfa_fffffff4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v104;                      // _cfa_ffffff98
    signed int* _v168;                     // _cfa_ffffff58
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int* _t54;                      // _t54
    signed int _t57;                       // _t57
    signed int* _t59;                      // _t59
    signed int _t63;                       // _t63
    signed int* _t64;                      // _t64
    signed int _t68;                       // _t68
    intOrPtr* _t69;                        // _t69
    unsigned int _t71;                     // _t71
    signed int* _t75;                      // _t75
    signed int _t76;                       // _t76
    _unknown_ _t77;                        // _t77
    signed int* _t78;                      // _t78
    signed int* _t79;                      // _t79
    signed int* _t80;                      // _t80

     *__esp =  &caml_exn_Sys_blocked_io;
    caml_raise_constant();
    _push(_t77);
    _t78 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Not_found;
    caml_raise_constant();
    _push(_t78);
    _t79 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    caml_raise_constant();
    _push(_t79);
    _t80 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t80);
    _push(__edi);
    _push(_t74);
    _push(_t68);
    __esp = __esp - 44;
    _t52 = _v104;
    if(_t52 != 0) {
        _v52 = _v0;
        _t71 = _v4;
        _v48 = _t52;
        while(1) {
            _t74 = caml_frame_descriptors_mask;
            _t57 = _t71 >> 3 & _t74;
            __ecx = caml_frame_descriptors;
            _t68 =  *(__ecx + _t57 * 4);
            if( *_t68 != _t71) {
                goto L9;
            }
            do {
L9:
                _t57 = _t57 + 1 & _t74;
                _t68 =  *(__ecx + _t57 * 4);
            } while( *_t68 != _t71);
L10:
            if( *(_t68 + 4) != 65535) {
                _t76 =  *(_t68 + 6) & 65535;
                if(_t76 > 0) {
                    __edi = _t68 + 8;
                    _v56 = _t68;
                    _t69 = _v12;
                    while(1) {
                        _t63 =  *__edi & 65535;
                        if((_t63 & 1) == 0) {
                            _t64 = _t63 + _v48;
                        } else {
                            _t64 = _v52 + (_t63 >> 1) * 4;
                        }
L16:
                        _v168 = _t64;
                         *__esp =  *_t64;
                         *_t69();
                        _t76 = _t76 - 1;
                        if(_t76 > 0) {
                            __edi = __edi + 2;
                            _t63 =  *__edi & 65535;
                            if((_t63 & 1) == 0) {
                                _t64 = _t63 + _v48;
                            } else {
                                _t64 = _v52 + (_t63 >> 1) * 4;
                            }
                            goto L16;
                        }
                        _t68 = _v56;
                        goto L19;
                    }
                }
L19:
                _v48 = _v48 + ( *(_t68 + 4) & 0xfffc);
                _t71 =  *(_v48 - 4);
                do {
                    _t74 = caml_frame_descriptors_mask;
                    _t57 = _t71 >> 3 & _t74;
                    __ecx = caml_frame_descriptors;
                    _t68 =  *(__ecx + _t57 * 4);
                    if( *_t68 != _t71) {
                        goto L9;
                    }
                    goto L10;
                } while(_v48 != 0);
                goto L6;
            }
            _t59 = _v48 + 8;
            _v48 =  *_t59;
            _t71 = _t59[1];
            _t52 = _t59[2];
            _v52 = _t59[2];
        }
    }
L6:
    if(_a4 != 0) {
        _t75 = _a4;
        _v48 = 0;
        do {
            __edi = 0;
            if(_t75[1] > 0) {
                do {
                    _t68 = _v48;
                    if(_t75[2] > 0) {
                        do {
                            _t54 = _t68 * 4 +  *((intOrPtr*)(_t75 + 12 + __edi * 4));
                            _v168 = _t54;
                            _t52 =  *_t54;
                             *__esp =  *_t54;
                            _v12();
                            _t68 = _t68 + 1;
                        } while(_t75[2] > _t68);
                    } else {
                    }
                    goto L23;
L23:
                    __edi = __edi + 1;
                } while(_t75[1] > __edi);
            } else {
            }
            goto L26;
L30:
L26:
            _t74 =  *_t75;
        } while( *_t75 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L30;
}

caml_raise_not_found(
    signed int _a4,                        // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x0805C617
    unsigned int _v0;                      // _cfa_0
    intOrPtr* _v8;                         // _cfa_fffffff8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v76;                       // _cfa_ffffffb4
    signed int* _v140;                     // _cfa_ffffff74
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int* _t53;                      // _t53
    signed int _t56;                       // _t56
    signed int* _t58;                      // _t58
    signed int _t62;                       // _t62
    signed int* _t63;                      // _t63
    signed int _t67;                       // _t67
    intOrPtr* _t68;                        // _t68
    unsigned int _t70;                     // _t70
    signed int* _t74;                      // _t74
    signed int _t75;                       // _t75
    _unknown_ _t76;                        // _t76
    signed int* _t77;                      // _t77
    signed int* _t78;                      // _t78

     *__esp =  &caml_exn_Not_found;
    caml_raise_constant();
    _push(_t76);
    _t77 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_Division_by_zero;
    caml_raise_constant();
    _push(_t77);
    _t78 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t78);
    _push(__edi);
    _push(_t73);
    _push(_t67);
    __esp = __esp - 44;
    _t51 = _v76;
    if(_t51 != 0) {
        _v48 = _a4;
        _t70 = _v0;
        _v44 = _t51;
        while(1) {
            _t73 = caml_frame_descriptors_mask;
            _t56 = _t70 >> 3 & _t73;
            __ecx = caml_frame_descriptors;
            _t67 =  *(__ecx + _t56 * 4);
            if( *_t67 != _t70) {
                goto L8;
            }
            do {
L8:
                _t56 = _t56 + 1 & _t73;
                _t67 =  *(__ecx + _t56 * 4);
            } while( *_t67 != _t70);
L9:
            if( *(_t67 + 4) != 65535) {
                _t75 =  *(_t67 + 6) & 65535;
                if(_t75 > 0) {
                    __edi = _t67 + 8;
                    _v52 = _t67;
                    _t68 = _v8;
                    while(1) {
                        _t62 =  *__edi & 65535;
                        if((_t62 & 1) == 0) {
                            _t63 = _t62 + _v44;
                        } else {
                            _t63 = _v48 + (_t62 >> 1) * 4;
                        }
L15:
                        _v140 = _t63;
                         *__esp =  *_t63;
                         *_t68();
                        _t75 = _t75 - 1;
                        if(_t75 > 0) {
                            __edi = __edi + 2;
                            _t62 =  *__edi & 65535;
                            if((_t62 & 1) == 0) {
                                _t63 = _t62 + _v44;
                            } else {
                                _t63 = _v48 + (_t62 >> 1) * 4;
                            }
                            goto L15;
                        }
                        _t67 = _v52;
                        goto L18;
                    }
                }
L18:
                _v44 = _v44 + ( *(_t67 + 4) & 0xfffc);
                _t70 =  *(_v44 - 4);
                do {
                    _t73 = caml_frame_descriptors_mask;
                    _t56 = _t70 >> 3 & _t73;
                    __ecx = caml_frame_descriptors;
                    _t67 =  *(__ecx + _t56 * 4);
                    if( *_t67 != _t70) {
                        goto L8;
                    }
                    goto L9;
                } while(_v44 != 0);
                goto L5;
            }
            _t58 = _v44 + 8;
            _v44 =  *_t58;
            _t70 = _t58[1];
            _t51 = _t58[2];
            _v48 = _t58[2];
        }
    }
L5:
    if(_a8 != 0) {
        _t74 = _a8;
        _v44 = 0;
        do {
            __edi = 0;
            if(_t74[1] > 0) {
                do {
                    _t67 = _v44;
                    if(_t74[2] > 0) {
                        do {
                            _t53 = _t67 * 4 +  *((intOrPtr*)(_t74 + 12 + __edi * 4));
                            _v140 = _t53;
                            _t51 =  *_t53;
                             *__esp =  *_t53;
                            _v8();
                            _t67 = _t67 + 1;
                        } while(_t74[2] > _t67);
                    } else {
                    }
                    goto L22;
L22:
                    __edi = __edi + 1;
                } while(_t74[1] > __edi);
            } else {
            }
            goto L25;
L29:
L25:
            _t73 =  *_t74;
        } while( *_t74 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L29;
}

caml_raise_zero_divide(
    unsigned int _a4,                      // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int* _a12                       // _cfa_c
)
{// addr = 0x0805C629
    intOrPtr* _v4;                         // _cfa_fffffffc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int* _v112;                     // _cfa_ffffff90
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int* _t52;                      // _t52
    signed int _t55;                       // _t55
    signed int* _t57;                      // _t57
    signed int _t61;                       // _t61
    signed int* _t62;                      // _t62
    signed int _t66;                       // _t66
    intOrPtr* _t67;                        // _t67
    unsigned int _t69;                     // _t69
    signed int* _t73;                      // _t73
    signed int _t74;                       // _t74
    _unknown_ _t75;                        // _t75
    signed int* _t76;                      // _t76

     *__esp =  &caml_exn_Division_by_zero;
    caml_raise_constant();
    _push(_t75);
    _t76 = __esp;
    __esp = __esp - 24;
     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t76);
    _push(__edi);
    _push(_t72);
    _push(_t66);
    __esp = __esp - 44;
    _t50 = _v48;
    if(_t50 != 0) {
        _v44 = _a8;
        _t69 = _a4;
        _v40 = _t50;
        while(1) {
            _t72 = caml_frame_descriptors_mask;
            _t55 = _t69 >> 3 & _t72;
            __ecx = caml_frame_descriptors;
            _t66 =  *(__ecx + _t55 * 4);
            if( *_t66 != _t69) {
                goto L7;
            }
            do {
L7:
                _t55 = _t55 + 1 & _t72;
                _t66 =  *(__ecx + _t55 * 4);
            } while( *_t66 != _t69);
L8:
            if( *(_t66 + 4) != 65535) {
                _t74 =  *(_t66 + 6) & 65535;
                if(_t74 > 0) {
                    __edi = _t66 + 8;
                    _v48 = _t66;
                    _t67 = _v4;
                    while(1) {
                        _t61 =  *__edi & 65535;
                        if((_t61 & 1) == 0) {
                            _t62 = _t61 + _v40;
                        } else {
                            _t62 = _v44 + (_t61 >> 1) * 4;
                        }
L14:
                        _v112 = _t62;
                         *__esp =  *_t62;
                         *_t67();
                        _t74 = _t74 - 1;
                        if(_t74 > 0) {
                            __edi = __edi + 2;
                            _t61 =  *__edi & 65535;
                            if((_t61 & 1) == 0) {
                                _t62 = _t61 + _v40;
                            } else {
                                _t62 = _v44 + (_t61 >> 1) * 4;
                            }
                            goto L14;
                        }
                        _t66 = _v48;
                        goto L17;
                    }
                }
L17:
                _v40 = _v40 + ( *(_t66 + 4) & 0xfffc);
                _t69 =  *(_v40 - 4);
                do {
                    _t72 = caml_frame_descriptors_mask;
                    _t55 = _t69 >> 3 & _t72;
                    __ecx = caml_frame_descriptors;
                    _t66 =  *(__ecx + _t55 * 4);
                    if( *_t66 != _t69) {
                        goto L7;
                    }
                    goto L8;
                } while(_v40 != 0);
                goto L4;
            }
            _t57 = _v40 + 8;
            _v40 =  *_t57;
            _t69 = _t57[1];
            _t50 = _t57[2];
            _v44 = _t57[2];
        }
    }
L4:
    if(_a12 != 0) {
        _t73 = _a12;
        _v40 = 0;
        do {
            __edi = 0;
            if(_t73[1] > 0) {
                do {
                    _t66 = _v40;
                    if(_t73[2] > 0) {
                        do {
                            _t52 = _t66 * 4 +  *((intOrPtr*)(_t73 + 12 + __edi * 4));
                            _v112 = _t52;
                            _t50 =  *_t52;
                             *__esp =  *_t52;
                            _v4();
                            _t66 = _t66 + 1;
                        } while(_t73[2] > _t66);
                    } else {
                    }
                    goto L21;
L21:
                    __edi = __edi + 1;
                } while(_t73[1] > __edi);
            } else {
            }
            goto L24;
L28:
L24:
            _t72 =  *_t73;
        } while( *_t73 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L28;
}

caml_raise_end_of_file(
    unsigned int _a8,                      // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int* _a16                       // _cfa_10
)
{// addr = 0x0805C63B
    intOrPtr* _v0;                         // _cfa_0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int* _v84;                      // _cfa_ffffffac
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int* _t51;                      // _t51
    signed int _t54;                       // _t54
    signed int* _t56;                      // _t56
    signed int _t60;                       // _t60
    signed int* _t61;                      // _t61
    signed int _t65;                       // _t65
    intOrPtr* _t66;                        // _t66
    unsigned int _t68;                     // _t68
    signed int* _t72;                      // _t72
    signed int _t73;                       // _t73
    _unknown_ _t74;                        // _t74

     *__esp =  &caml_exn_End_of_file;
    caml_raise_constant();
    _push(_t74);
    _push(__edi);
    _push(_t71);
    _push(_t65);
    __esp = __esp - 44;
    _t49 = _v20;
    if(_t49 != 0) {
        _v40 = _a12;
        _t68 = _a8;
        _v36 = _t49;
        while(1) {
            _t71 = caml_frame_descriptors_mask;
            _t54 = _t68 >> 3 & _t71;
            __ecx = caml_frame_descriptors;
            _t65 =  *(__ecx + _t54 * 4);
            if( *_t65 != _t68) {
                goto L6;
            }
            do {
L6:
                _t54 = _t54 + 1 & _t71;
                _t65 =  *(__ecx + _t54 * 4);
            } while( *_t65 != _t68);
L7:
            if( *(_t65 + 4) != 65535) {
                _t73 =  *(_t65 + 6) & 65535;
                if(_t73 > 0) {
                    __edi = _t65 + 8;
                    _v44 = _t65;
                    _t66 = _v0;
                    while(1) {
                        _t60 =  *__edi & 65535;
                        if((_t60 & 1) == 0) {
                            _t61 = _t60 + _v36;
                        } else {
                            _t61 = _v40 + (_t60 >> 1) * 4;
                        }
L13:
                        _v84 = _t61;
                         *__esp =  *_t61;
                         *_t66();
                        _t73 = _t73 - 1;
                        if(_t73 > 0) {
                            __edi = __edi + 2;
                            _t60 =  *__edi & 65535;
                            if((_t60 & 1) == 0) {
                                _t61 = _t60 + _v36;
                            } else {
                                _t61 = _v40 + (_t60 >> 1) * 4;
                            }
                            goto L13;
                        }
                        _t65 = _v44;
                        goto L16;
                    }
                }
L16:
                _v36 = _v36 + ( *(_t65 + 4) & 0xfffc);
                _t68 =  *(_v36 - 4);
                do {
                    _t71 = caml_frame_descriptors_mask;
                    _t54 = _t68 >> 3 & _t71;
                    __ecx = caml_frame_descriptors;
                    _t65 =  *(__ecx + _t54 * 4);
                    if( *_t65 != _t68) {
                        goto L6;
                    }
                    goto L7;
                } while(_v36 != 0);
                goto L3;
            }
            _t56 = _v36 + 8;
            _v36 =  *_t56;
            _t68 = _t56[1];
            _t49 = _t56[2];
            _v40 = _t56[2];
        }
    }
L3:
    if(_a16 != 0) {
        _t72 = _a16;
        _v36 = 0;
        do {
            __edi = 0;
            if(_t72[1] > 0) {
                do {
                    _t65 = _v36;
                    if(_t72[2] > 0) {
                        do {
                            _t51 = _t65 * 4 +  *((intOrPtr*)(_t72 + 12 + __edi * 4));
                            _v84 = _t51;
                            _t49 =  *_t51;
                             *__esp =  *_t51;
                            _v0();
                            _t65 = _t65 + 1;
                        } while(_t72[2] > _t65);
                    } else {
                    }
                    goto L20;
L20:
                    __edi = __edi + 1;
                } while(_t72[1] > __edi);
            } else {
            }
            goto L23;
L27:
L23:
            _t71 =  *_t72;
        } while( *_t72 != 0);
    }
    __esp =  &(__esp[0xb]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return;
    goto L27;
}

caml_do_local_roots(
    intOrPtr* _a4,                         // _cfa_4
    signed int _a8,                        // _cfa_8
    unsigned int _a12,                     // _cfa_c
    signed int _a16,                       // _cfa_10
    intOrPtr* _a20                         // _cfa_14
)
{// addr = 0x0805C650
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr* _v40;                        // _cfa_ffffffd8
    signed int* _v56;                      // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int* _t50;                      // _t50
    signed int _t53;                       // _t53
    signed int* _t55;                      // _t55
    signed int _t59;                       // _t59
    signed int* _t60;                      // _t60
    signed int _t64;                       // _t64
    intOrPtr* _t65;                        // _t65
    intOrPtr* _t66;                        // _t66
    unsigned int _t68;                     // _t68
    signed int _t71;                       // _t71
    signed short* _t72;                    // _t72
    intOrPtr* _t73;                        // _t73
    signed int _t74;                       // _t74
    signed int _t75;                       // _t75

    _t48 = _a8;
    if(_t48 != 0) {
        _v36 = _a16;
        _t68 = _a12;
        _v32 = _t48;
        while(1) {
            _t74 = caml_frame_descriptors_mask;
            _t53 = _t68 >> 3 & _t74;
            __ecx = caml_frame_descriptors;
            _t65 =  *((intOrPtr*)(__ecx + _t53 * 4));
            if( *_t65 != _t68) {
                goto L5;
            }
            do {
L5:
                _t53 = _t53 + 1 & _t74;
                _t65 =  *((intOrPtr*)(__ecx + _t53 * 4));
            } while( *_t65 != _t68);
L6:
            if( *(_t65 + 4) != 65535) {
                _t75 =  *(_t65 + 6) & 65535;
                if(_t75 > 0) {
                    _t72 = _t65 + 8;
                    _v40 = _t65;
                    _t66 = _a4;
                    while(1) {
                        _t59 =  *_t72 & 65535;
                        if((_t59 & 1) == 0) {
                            _t60 = _t59 + _v32;
                        } else {
                            _t60 = _v36 + (_t59 >> 1) * 4;
                        }
                        _v56 = _t60;
                         *__esp =  *_t60;
                         *_t66();
                        _t75 = _t75 - 1;
                        if(_t75 <= 0) {
                            break;
                        }
                        _t72 =  &(_t72[1]);
                    }
                    _t65 = _v40;
                }
                _v32 = _v32 + ( *(_t65 + 4) & 0xfffc);
                _t68 =  *(_v32 - 4);
                do {
                    _t74 = caml_frame_descriptors_mask;
                    _t53 = _t68 >> 3 & _t74;
                    __ecx = caml_frame_descriptors;
                    _t65 =  *((intOrPtr*)(__ecx + _t53 * 4));
                    if( *_t65 != _t68) {
                        goto L5;
                    }
                    goto L6;
                } while(_v32 != 0);
                goto L2;
            }
            _t55 = _v32 + 8;
            _v32 =  *_t55;
            _t68 = _t55[1];
            _t48 = _t55[2];
            _v36 = _t55[2];
        }
    }
L2:
    if(_a20 != 0) {
        _t73 = _a20;
        _v32 = 0;
        do {
            _t71 = 0;
            if(_t73[1] > 0) {
                do {
                    _t64 = _v32;
                    if(_t73[2] > 0) {
                        do {
                            _t50 = _t64 * 4 +  *((intOrPtr*)(_t73 + 12 + _t71 * 4));
                            _v56 = _t50;
                            _t48 =  *_t50;
                             *__esp =  *_t50;
                            _a4();
                            _t64 = _t64 + 1;
                        } while(_t73[2] > _t64);
                    } else {
                    }
                    goto L19;
L19:
                    _t71 = _t71 + 1;
                } while(_t73[1] > _t71);
            } else {
            }
            goto L22;
L26:
L22:
            _t73 =  *_t73;
        } while(_t73 != 0);
    }
    return;
    goto L26;
}

signed int caml_stack_usage()
{// addr = 0x0805C777
    _unknown_ __ebx;                       // r1
    intOrPtr* _t1;                         // _t1
    signed int _t5;                        // _t5

    _t5 = caml_top_of_stack - caml_bottom_of_stack >> 2;
    _t1 = caml_stack_usage_hook;
    if(_t1 != 0) {
         *_t1();
        _t5 = _t5 + _t1;
    }
    return _t5;
}

cons(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edx,                        // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x0805C7A2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr* _t7;                         // _t7

    __edx = __edx;
    _v12 = __ebx;
    _v8 = __esi;
    _t7 = caml_stat_alloc(__eax, 8);
     *_t7 = __eax;
    _t7[1] = __edx;
    return _t7;
}

caml_register_dyn_global(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805C7CD
    intOrPtr _t3;                          // _t3

    __edx = caml_dyn_globals;
    _t3 = cons(_a4, __ebx, caml_dyn_globals, __esi);
    caml_dyn_globals = _t3;
    return _t3;
}

caml_register_frametable(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805C7E8
    intOrPtr _t4;                          // _t4
    _unknown_ _t5;                         // _t5

    __esi = __esi;
    __ebx = __ebx;
    __edx = frametables;
    frametables = cons(_a4, __ebx, frametables, __esi);
    _t4 = caml_frame_descriptors;
    if(_t4 != 0) {
        _t5 = caml_stat_free(_t4);
        caml_frame_descriptors = 0;
        return _t5;
    }
    return _t4;
}

caml_init_frame_descriptors()
{// addr = 0x0805C81E
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr* _v36;                        // _cfa_ffffffdc
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    intOrPtr* _t27;                        // _t27
    signed int _t29;                       // _t29
    intOrPtr* _t30;                        // _t30
    intOrPtr _t32;                         // _t32
    intOrPtr _t34;                         // _t34
    signed int _t37;                       // _t37
    unsigned int* _t41;                    // _t41
    signed int _t49;                       // _t49
    signed int _t50;                       // _t50
    signed int _t51;                       // _t51
    intOrPtr _t52;                         // _t52
    unsigned int** _t55;                   // _t55
    signed int _t57;                       // _t57
    _unknown_ _t58;                        // _t58
    intOrPtr* _t59;                        // _t59
    unsigned int* _t60;                    // _t60

    if(inited.3139 == 0) {
        _t45 = caml_frametable;
        if(caml_frametable != 0) {
            _t51 = 0;
            do {
                caml_register_frametable(_t51,  &caml_frametable, _t45);
                _t51 = _t51 + 1;
                _t45 =  *((intOrPtr*)( &caml_frametable + _t51 * 4));
            } while( *((intOrPtr*)( &caml_frametable + _t51 * 4)) != 0);
        }
        inited.3139 = 1;
    }
    _t27 = frametables;
    if(_t27 == 0) {
L23:
        caml_frame_descriptors = caml_stat_alloc(_t27, 16);
        goto L24;
    } else {
        _t57 = 0;
        do {
            _t57 = _t57 +  *((intOrPtr*)( *_t27));
            _t27 = _t27[1];
        } while(_t27 != 0);
        _t58 = _t57 + _t57;
        if(_t58 <= 4) {
            goto L23;
        } else {
            _t50 = 4;
            do {
                _t50 = _t50 + _t50;
            } while(_t50 < _t58);
            caml_frame_descriptors = caml_stat_alloc(_t50 * 4, _t50 * 4);
            if(_t50 > 0) {
L24:
                _t29 = 0;
                do {
                     *(caml_frame_descriptors + _t29 * 4) = 0;
                    _t29 = _t29 + 1;
                } while(_t29 < 4);
            } else {
            }
        }
    }
    caml_frame_descriptors_mask = 3;
    _t30 = frametables;
    _v36 = _t30;
    if(_t30 != 0) {
        do {
            _t59 =  *_v36;
            _t32 =  *_t59;
            _v32 = _t32;
            if(_t32 <= 0) {
                goto L21;
            }
            _t60 = _t59 + 4;
            __edi = 0;
            while(1) {
                _t49 = caml_frame_descriptors_mask;
                _t37 =  *_t60 >> 3 & _t49;
                _t52 = caml_frame_descriptors;
                _t55 = _t52 + _t37 * 4;
                if( *_t55 == 0) {
                    goto L19;
                }
                do {
L18:
                    _t37 = _t37 + 1 & _t49;
                    _t55 = _t52 + _t37 * 4;
                } while( *_t55 != 0);
L19:
                 *_t55 = _t60;
                _t41 = (_t60[1] & 1) != 0 ? (_t60 + 11 + (_t60[1] & 65535) * 2 & -4) + 8 : _t60 + 11 + (_t60[1] & 65535) * 2 & -4;
                __edi = __edi + 1;
                if(__edi == _v32) {
                    break;
                }
                _t60 = _t41;
                _t49 = caml_frame_descriptors_mask;
                _t37 =  *_t60 >> 3 & _t49;
                _t52 = caml_frame_descriptors;
                _t55 = _t52 + _t37 * 4;
                if( *_t55 == 0) {
                    goto L19;
                }
                goto L18;
            }
L21:
            _t34 =  *((intOrPtr*)(_v36 + 4));
            _v36 = _t34;
        } while(_t34 != 0);
        return _t34;
    }
    return _t30;
}

caml_do_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805C975
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v60;                        // _cfa_ffffffc4 (outparam)
    _unknown_ _v64;                        // _cfa_ffffffc0 (outparam)
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    intOrPtr* _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t30;                       // _t30
    intOrPtr* _t36;                        // _t36
    signed int _t40;                       // _t40
    signed int _t41;                       // _t41
    intOrPtr* _t42;                        // _t42
    signed int _t44;                       // _t44
    intOrPtr* _t45;                        // _t45
    signed int _t48;                       // _t48
    signed int _t49;                       // _t49
    char _t61;                             // _t61
    _unknown_ _t62;                        // _t62
    unsigned int* _t63;                    // _t63
    unsigned int* _t64;                    // _t64

    _t61 = caml_globals;
    if(_t61 != 0) {
        _v32 = 0;
        do {
            _t64 = _t61 - 4;
            _t44 = 0;
            _t49 = 0;
            if( *_t64 >> 10 != 0) {
                do {
                    _t45 = _t61 + _t44 * 4;
                    _v72 = _t45;
                     *__esp =  *_t45;
                    _a4();
                    _t49 = _t49 + 1;
                    _t44 = _t49;
                } while(_t49 <  *_t64 >> 10);
            } else {
            }
            goto L3;
L11:
            if(caml_frame_descriptors == 0) {
                caml_init_frame_descriptors();
            }
            caml_do_local_roots(_a4, caml_bottom_of_stack, caml_last_return_address, caml_gc_regs, caml_local_roots);
            caml_scan_global_roots(_a4);
            caml_final_do_strong_roots(_a4);
            _t36 = caml_scan_roots_hook;
            if(_t36 != 0) {
                 *__esp = _a4;
                 *_t36();
                return;
            }
            return;
L3:
            _v32 = _v32 + 1;
            _t61 =  *((intOrPtr*)( &caml_globals + _v32 * 4));
        } while(_t61 != 0);
    }
    _t30 = caml_dyn_globals;
    _v32 = _t30;
    if(_t30 != 0) {
        do {
            _t62 =  *_v32;
            _t63 = _t62 - 4;
            if( *_t63 >> 10 != 0) {
                _t41 = 0;
                _t48 = 0;
                do {
                    _t42 = _t62 + _t41 * 4;
                    _v72 = _t42;
                     *__esp =  *_t42;
                    _a4();
                    _t48 = _t48 + 1;
                    _t41 = _t48;
                } while( *_t63 >> 10 > _t48);
            }
            _t40 =  *(_v32 + 4);
            _v32 = _t40;
        } while(_t40 != 0);
    }
    goto L11;
}

caml_darken_all_roots()
{// addr = 0x0805CA96
    return caml_do_roots(caml_darken);
}

caml_oldify_local_roots()
{// addr = 0x0805CAAA
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t72;                       // _t72
    signed char _t74;                      // _t74
    intOrPtr* _t77;                        // _t77
    signed int _t81;                       // _t81
    signed int* _t83;                      // _t83
    signed char _t88;                      // _t88
    signed int _t95;                       // _t95
    signed char _t96;                      // _t96
    signed int _t98;                       // _t98
    signed char _t99;                      // _t99
    signed int _t101;                      // _t101
    intOrPtr* _t102;                       // _t102
    signed int _t103;                      // _t103
    signed int _t104;                      // _t104
    signed int _t105;                      // _t105
    signed int _t106;                      // _t106
    intOrPtr _t107;                        // _t107
    unsigned int _t110;                    // _t110
    signed int _t114;                      // _t114
    signed char* _t115;                    // _t115
    signed int _t118;                      // _t118
    signed int _t129;                      // _t129
    signed short* _t130;                   // _t130
    _unknown_ _t131;                       // _t131
    intOrPtr _t132;                        // _t132
    intOrPtr* _t133;                       // _t133
    signed int _t134;                      // _t134
    signed int _t135;                      // _t135
    unsigned int* _t136;                   // _t136
    unsigned int* _t137;                   // _t137

    _v32 = caml_globals_scanned;
    _t72 = caml_globals_inited;
    if(_v32 > _t72) {
L12:
        caml_globals_scanned = _t72;
        _t105 = caml_dyn_globals;
        _v32 = _t105;
        if(_t105 == 0) {
L21:
            if(caml_frame_descriptors == 0) {
                caml_init_frame_descriptors();
            }
            _t106 = caml_bottom_of_stack;
            _v32 = _t106;
            _t110 = caml_last_return_address;
            _v36 = caml_gc_regs;
            if(_t106 == 0) {
L40:
                _t133 = caml_local_roots;
                _v32 = 0;
                if(_t133 != 0) {
                    do {
                        _t129 = 0;
                        if(_t133[1] > 0) {
                            do {
                                _t101 = _v32;
                                if(_t133[2] > 0) {
                                    do {
                                        _t112 = _t101 * 4 +  *((intOrPtr*)(_t133 + 12 + _t129 * 4));
                                        _t74 =  *(_t101 * 4 +  *((intOrPtr*)(_t133 + 12 + _t129 * 4)));
                                        if((_t74 & 1) == 0 && _t74 < caml_young_end && _t74 > caml_young_start) {
                                            caml_oldify_one(_t74, _t112);
                                        }
                                        _t101 = _t101 + 1;
                                    } while(_t133[2] > _t101);
                                    goto L47;
                                }
L47:
                                _t129 = _t129 + 1;
                            } while(_t133[1] > _t129);
                            goto L50;
                        }
L50:
                        _t133 =  *_t133;
                    } while(_t133 != 0);
L53:
                    caml_scan_global_young_roots(caml_oldify_one);
                    caml_final_do_young_roots(caml_oldify_one);
                    _t77 = caml_scan_roots_hook;
                    if(_t77 == 0) {
                        return;
                    }
                     *__esp = caml_oldify_one;
                     *_t77();
                    return;
                }
                goto L53;
            } else {
                while(1) {
                    _t134 = caml_frame_descriptors_mask;
                    _t81 = _t110 >> 3 & _t134;
                    _t107 = caml_frame_descriptors;
                    _t102 =  *((intOrPtr*)(_t107 + _t81 * 4));
                    if( *_t102 == _t110) {
                        goto L26;
                    }
                    do {
L25:
                        _t81 = _t81 + 1 & _t134;
                        _t102 =  *((intOrPtr*)(_t107 + _t81 * 4));
                    } while( *_t102 != _t110);
L26:
                    if( *(_t102 + 4) == 65535) {
L39:
                        _t83 = _v32 + 8;
                        _v32 =  *_t83;
                        _t110 = _t83[1];
                        _v36 = _t83[2];
                        if(_v32 != 0) {
                            do {
                                _t134 = caml_frame_descriptors_mask;
                                _t81 = _t110 >> 3 & _t134;
                                _t107 = caml_frame_descriptors;
                                _t102 =  *((intOrPtr*)(_t107 + _t81 * 4));
                                if( *_t102 == _t110) {
                                    goto L26;
                                }
                                goto L25;
                            } while(_v32 != 0);
                        }
                        goto L40;
                    }
                    _t135 =  *(_t102 + 6) & 65535;
                    if(_t135 <= 0) {
L38:
                        _v32 = _v32 + ( *(_t102 + 4) & 0xfffc);
                        _t110 =  *(_v32 - 4);
                        continue;
                    }
                    _t130 = _t102 + 8;
                    while(1) {
                        _t114 =  *_t130 & 65535;
                        if((_t114 & 1) == 0) {
                            _t115 = _t114 + _v32;
                        } else {
                            _t115 = _v36 + (_t114 >> 1) * 4;
                        }
                        _t88 =  *_t115;
                        if((_t88 & 1) == 0 && _t88 < caml_young_end && _t88 > caml_young_start) {
                            caml_oldify_one(_t88, _t115);
                        }
                        _t135 = _t135 - 1;
                        if(_t135 <= 0) {
                            goto L38;
                        }
                        _t130 =  &(_t130[1]);
                    }
                    goto L38;
                }
            }
        } else {
            goto L13;
        }
        do {
L13:
            _t131 =  *_v32;
            _t136 = _t131 - 4;
            if( *_t136 >> 10 == 0) {
                goto L20;
            }
            _t95 = 0;
            _t103 = 0;
            do {
                _t119 = _t131 + _t95 * 4;
                _t96 =  *(_t131 + _t95 * 4);
                if((_t96 & 1) == 0 && _t96 < caml_young_end && _t96 > caml_young_start) {
                    caml_oldify_one(_t96, _t119);
                }
                _t103 = _t103 + 1;
                _t95 = _t103;
            } while(_t103 <  *_t136 >> 10);
L20:
            _t118 =  *(_v32 + 4);
            _v32 = _t118;
        } while(_t118 != 0);
        goto L21;
    }
    _t132 =  *((intOrPtr*)(_v32 * 4 +  &caml_globals));
    if(_t132 != 0) {
        do {
            _t137 = _t132 - 4;
            _t98 = 0;
            _t104 = 0;
            if( *_t137 >> 10 != 0) {
                do {
                    _t125 = _t132 + _t98 * 4;
                    _t99 =  *(_t132 + _t98 * 4);
                    if((_t99 & 1) == 0) {
                        if(_t99 < caml_young_end) {
                            if(_t99 > caml_young_start) {
                                caml_oldify_one(_t99, _t125);
                            }
                        }
                    }
                    _t104 = _t104 + 1;
                    _t98 = _t104;
                } while(_t104 <  *_t137 >> 10);
                goto L8;
            } else {
L8:
                _v32 = _v32 + 1;
                _t72 = caml_globals_inited;
                if(_t72 < _v32) {
                    goto L12;
                }
            }
            _t132 =  *((intOrPtr*)( &caml_globals + _v32 * 4));
        } while(_t132 != 0);
    } else {
    }
}

caml_iterate_global_roots(
    intOrPtr* __eax,                       // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0805CD30
    intOrPtr* _v24;                        // _cfa_ffffffe8
    intOrPtr* __ebx;                       // r1
    intOrPtr* __esi;                       // r5
    intOrPtr* _t5;                         // _t5

    __edx = __edx;
    __esi = __eax;
    __ebx =  *((intOrPtr*)(__edx + 4));
    while(__ebx != 0) {
        _t5 =  *__ebx;
        _v24 = _t5;
         *__esp =  *_t5;
         *__esi();
        __ebx = __ebx[1];
    }
}

caml_scan_global_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805CD5C
    intOrPtr* __ebx;                       // r1
    intOrPtr* _t4;                         // _t4

    __ebx = _a4;
    caml_iterate_global_roots(__ebx,  &caml_global_roots);
    caml_iterate_global_roots(__ebx,  &caml_global_roots_young);
    _t4 = __ebx;
    caml_iterate_global_roots(_t4,  &caml_global_roots_old);
    return _t4;
}

caml_insert_global_root(
    intOrPtr __eax,                        // r0
    intOrPtr __edx                         // r3
)
{// addr = 0x0805CD90
    char _v96;                             // _cfa_ffffffa0
    signed int _v112;                      // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t33;                       // _t33
    intOrPtr* _t34;                        // _t34
    signed int _t36;                       // _t36
    signed int _t39;                       // _t39
    intOrPtr* _t41;                        // _t41
    signed int _t44;                       // _t44
    intOrPtr _t45;                         // _t45
    intOrPtr _t47;                         // _t47
    signed int _t50;                       // _t50
    signed int _t56;                       // _t56

    _v116 = __eax;
    _t33 =  *(__eax + 72);
    _v112 = _t33;
    _t44 = _t33;
    _t47 = __eax;
    if(_t33 < 0) {
L6:
        _t34 =  *((intOrPtr*)(_t47 + 4));
        if(_t34 == 0 ||  *_t34 != __edx) {
            _t36 = 25173 + random_seed * 69069;
            random_seed = _t36;
            _t56 = 0;
            if((_t36 & -1073741824) != -1073741824) {
L10:
                if(_v112 >= _t56) {
L15:
                    _t34 = caml_stat_alloc(8 + _t56 * 4, 8 + _t56 * 4);
                     *_t34 = __edx;
                    if(_t56 < 0) {
                        goto L18;
                    }
                    _t50 = 0;
                    do {
                        _t45 =  *((intOrPtr*)( &_v96 + _t50 * 4));
                         *((intOrPtr*)(_t34 + 4 + _t50 * 4)) =  *((intOrPtr*)(_t45 + 4 + _t50 * 4));
                         *((intOrPtr*)(_t45 + 4 + _t50 * 4)) = _t34;
                        _t50 = _t50 + 1;
                    } while(_t50 <= _t56);
                    goto L18;
                }
                _t39 = _v112 + 1;
                if(_t39 > _t56) {
L14:
                     *(_v116 + 72) = _t56;
                    goto L15;
                }
                do {
                     *((intOrPtr*)( &_v96 + _t39 * 4)) = __eax;
                    _t39 = _t39 + 1;
                } while(_t39 <= _t56);
                goto L14;
            } else {
                goto L9;
            }
            do {
L9:
                _t56 = _t56 + 1;
                _t36 = _t36 << 2;
            } while((_t36 & -1073741824) == -1073741824);
            goto L10;
        } else {
L18:
            return _t34;
        }
    } else {
        while(1) {
L2:
            _t41 =  *((intOrPtr*)(_t47 + 4 + _t44 * 4));
            if(_t41 == 0 ||  *_t41 >= __edx) {
                break;
            }
            _t47 = _t41;
        }
         *((intOrPtr*)( &_v96 + _t44 * 4)) = _t47;
        _t44 = _t44 - 1;
        if(_t44 != -1) {
            goto L2;
        }
        goto L6;
    }
}

unsigned int caml_register_generational_global_root(
    unsigned int* _a4                      // _cfa_4
)
{// addr = 0x0805CE77
    unsigned int _t8;                      // _t8
    signed int _t15;                       // _t15

    __edx = _a4;
    _t8 =  *__edx;
    if((_t8 & 1) != 0) {
L6:
        return _t8;
    }
    if(_t8 >= caml_young_end || _t8 <= caml_young_start) {
        _t15 = _t8 >> 23;
        _t8 = _t8 >> 12 & 2047;
        if(( *( *((intOrPtr*)(_t15 * 4 +  &caml_page_table)) + _t8) & 1) != 0) {
            return caml_insert_global_root( &caml_global_roots_old, __edx);
        }
        goto L6;
    } else {
        return caml_insert_global_root( &caml_global_roots_young, __edx);
    }
}

caml_register_global_root(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805CECA
    __edx = _a4;
    return caml_insert_global_root( &caml_global_roots, _a4);
}

caml_scan_global_young_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805CEDF
    _unknown_ __ebx;                       // r1
    intOrPtr* _t7;                         // _t7
    signed int _t8;                        // _t8
    intOrPtr* _t11;                        // _t11
    intOrPtr* _t12;                        // _t12
    intOrPtr* _t13;                        // _t13
    signed int _t16;                       // _t16

    _t11 = _a4;
    caml_iterate_global_roots(_t11,  &caml_global_roots);
    _t7 = _t11;
    caml_iterate_global_roots(_t7,  &caml_global_roots_young);
    _t12 =  *134694884;
    if(_t12 != 0) {
        do {
            caml_insert_global_root( &caml_global_roots_old,  *_t12);
            _t12 = _t12[1];
        } while(_t12 != 0);
        _t7 =  *134694884;
        if(_t7 != 0) {
            while(1) {
                _t13 = _t7[1];
                _t7 = caml_stat_free(_t7);
                if(_t13 == 0) {
                    goto L5;
                }
                _t7 = _t13;
            }
        }
    }
L5:
    _t16 =  *134694952;
    if(_t16 >= 0) {
        _t8 = 0;
        do {
             *(134694884 + _t8 * 4) = 0;
            _t8 = _t8 + 1;
        } while(_t8 <= _t16);
    }
     *134694952 = 0;
    return _t7;
}

signed int caml_delete_global_root(
    intOrPtr __eax,                        // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x0805CF6C
    char _v96;                             // _cfa_ffffffa0
    signed int _v112;                      // _cfa_ffffff90
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t34;                       // _t34
    signed int _t36;                       // _t36
    intOrPtr _t37;                         // _t37
    intOrPtr* _t38;                        // _t38
    intOrPtr _t40;                         // _t40
    signed int _t44;                       // _t44

    _t37 = __eax;
    _t34 =  *(__eax + 72);
    _v112 = _t34;
    if(_t34 < 0) {
L6:
        _t38 =  *((intOrPtr*)(_t37 + 4));
        if(_t38 == 0 ||  *_t38 != __edx) {
L19:
            return _t34;
        } else {
            if(_v112 < 0) {
L13:
                caml_stat_free(_t38);
                _t34 =  *(__eax + 72);
                if(_t34 <= 0 ||  *((intOrPtr*)(__eax + 4 + _t34 * 4)) != 0) {
                    goto L19;
                } else {
                    while(1) {
                        _t34 = _t34 - 1;
                        if(_t34 <= 0) {
                            break;
                        }
                        if( *((intOrPtr*)(__eax + 4 + _t34 * 4)) == 0) {
                            continue;
                        }
                         *(__eax + 72) = _t34;
                        return _t34;
                    }
                     *(__eax + 72) = _t34;
                    return _t34;
                }
            }
            _t36 = 0;
            do {
                _t40 =  *((intOrPtr*)( &_v96 + _t36 * 4));
                if( *((intOrPtr*)(_t40 + 4 + _t36 * 4)) == _t38) {
                     *((intOrPtr*)(_t40 + 4 + _t36 * 4)) =  *((intOrPtr*)(_t38 + 4 + _t36 * 4));
                }
                _t36 = _t36 + 1;
            } while( *(__eax + 72) >= _t36);
            goto L13;
        }
    } else {
        _t44 = _t34;
        goto L2;
        do {
            do {
L2:
                _t34 =  *(_t37 + 4 + _t44 * 4);
            } while(_t34 != 0 &&  *_t34 < __edx);
             *((intOrPtr*)( &_v96 + _t44 * 4)) = _t37;
            _t44 = _t44 - 1;
        } while(_t44 != -1);
        goto L6;
    }
}

unsigned int caml_modify_generational_global_root(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    unsigned int* _a4,                     // _cfa_4
    unsigned int _a8                       // _cfa_8
)
{// addr = 0x0805D009
    intOrPtr _v8;                          // _cfa_fffffff8
    unsigned int _t23;                     // _t23
    unsigned int _t36;                     // _t36
    signed int _t39;                       // _t39
    signed int _t41;                       // _t41
    signed int _t51;                       // _t51
    unsigned int* _t56;                    // _t56

     *__esp = __ebx;
    _v8 = __esi;
    _t56 = _a4;
    _t36 = _a8;
    _t23 =  *_t56;
    _t39 = _t36 & 1;
    if(_t39 != 0 || _t36 >= caml_young_end || _t36 <= caml_young_start) {
        if((_t23 & 1) == 0) {
            if(_t39 != 0) {
                if(_t23 >= caml_young_end || _t23 <= caml_young_start) {
                    _t41 = _t23 >> 23;
                    _t23 = _t23 >> 12 & 2047;
                    if(( *( *((intOrPtr*)(_t41 * 4 +  &caml_page_table)) + _t23) & 1) != 0) {
                        _t23 = caml_delete_global_root( &caml_global_roots_old, _t56);
                    }
                } else {
                    _t23 = caml_delete_global_root( &caml_global_roots_young, _t56);
                }
            }
            goto L17;
        }
        if(_t39 != 0) {
            goto L17;
        }
        goto L8;
    } else {
        if((_t23 & 1) != 0) {
L8:
            if(_t36 >= caml_young_end || _t36 <= caml_young_start) {
                _t23 = _t36 >> 12 & 2047;
                if(( *( *((intOrPtr*)((_t36 >> 23) * 4 +  &caml_page_table)) + _t23) & 1) != 0) {
                    _t23 = caml_insert_global_root( &caml_global_roots_old, _t56);
                }
            } else {
                _t23 = caml_insert_global_root( &caml_global_roots_young, _t56);
            }
            goto L17;
        } else {
            _t51 = _t23 >> 23;
            _t23 = _t23 >> 12 & 2047;
            if(( *( *((intOrPtr*)(_t51 * 4 +  &caml_page_table)) + _t23) & 1) != 0) {
                caml_delete_global_root( &caml_global_roots_old, _t56);
                _t23 = caml_insert_global_root( &caml_global_roots_young, _t56);
            }
L17:
             *_t56 = _t36;
            return _t23;
        }
    }
}

unsigned int caml_remove_generational_global_root(
    unsigned int* _a4                      // _cfa_4
)
{// addr = 0x0805D116
    unsigned int _t8;                      // _t8
    signed int _t15;                       // _t15

    __edx = _a4;
    _t8 =  *__edx;
    if((_t8 & 1) != 0) {
L6:
        return _t8;
    }
    if(_t8 >= caml_young_end || _t8 <= caml_young_start) {
        _t15 = _t8 >> 23;
        _t8 = _t8 >> 12 & 2047;
        if(( *( *((intOrPtr*)(_t15 * 4 +  &caml_page_table)) + _t8) & 1) != 0) {
            return caml_delete_global_root( &caml_global_roots_old, __edx);
        }
        goto L6;
    } else {
        return caml_delete_global_root( &caml_global_roots_young, __edx);
    }
}

caml_remove_global_root(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805D169
    __edx = _a4;
    return caml_delete_global_root( &caml_global_roots, _a4);
}

caml_record_signal(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805D180
    intOrPtr _t5;                          // _t5

     *((intOrPtr*)(_a4 * 4 +  &caml_pending_signals)) = 1;
    caml_signals_are_pending = 1;
    _t5 = caml_young_end;
    caml_young_limit = _t5;
    return _t5;
}

caml_enter_blocking_section_default(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805D1A7
    __eax = __eax;
    caml_async_signal_mode = 1;
    return __eax;
}

caml_leave_blocking_section_default(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805D1B6
    __eax = __eax;
    caml_async_signal_mode = 0;
    return __eax;
}

caml_try_leave_blocking_section_default()
{// addr = 0x0805D1C5
    asm("xchg [0x8074898], eax");
    return 0;
}

caml_urge_major_slice()
{// addr = 0x0805D1D2
    caml_force_major_slice = 1;
    __eax = caml_young_end;
    caml_young_limit = __eax;
    return __eax;
}

signed int caml_convert_signal_number(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805D1EB
    signed int _t4;                        // _t4

    _t4 = _a4;
    if(_t4 >= 0 || _t4 <= -22) {
        return _t4;
    } else {
        return  *((intOrPtr*)( !_t4 * 4 +  &posix_signals));
    }
}

signed int caml_rev_convert_signal_number(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805D205
    intOrPtr _t4;                          // _t4

    _t4 = _a4;
    __edx = 1;
    if(_t4 == 6) {
L3:
        return  !__edx;
    }
L2:
    while( *((intOrPtr*)( &posix_signals + __edx * 4)) != _t4) {
        __edx = __edx + 1;
        if(__edx != 21) {
            continue;
        }
        return _t4;
    }
    goto L3;
}

signed int caml_execute_signal(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D233
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v156;                            // _cfa_ffffff64
    signed int _v164;                      // _cfa_ffffff5c
    signed int _v168;                      // _cfa_ffffff58 (outparam)
    signed int _t28;                       // _t28
    signed int _t29;                       // _t29
    signed int _t33;                       // _t33
    signed int _t36;                       // _t36

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t33 = _a4;
     *__esp =  &_v156;
    sigemptyset();
    _v168 = _t33;
     *__esp =  &_v156;
    sigaddset();
    _v164 =  &_v156;
    _v168 =  &_v156;
     *__esp = 0;
    sigprocmask();
    _t28 = caml_callback_exn( *((intOrPtr*)(caml_signal_handlers + _t33 * 4)), caml_rev_convert_signal_number(_t33) + _t24 + 1);
    _t36 = _t28;
    if(_a8 != 0) {
        _t29 = _t28 & 3;
        if(_t29 == 2) {
            _v168 = _t33;
             *__esp =  &_v156;
            sigdelset();
            _v164 = 0;
            _v168 =  &_v156;
             *__esp = 2;
            sigprocmask();
            goto L5;
        }
    } else {
        _v164 = 0;
        _v168 =  &_v156;
         *__esp = 2;
        sigprocmask();
        _t29 = _t36 & 3;
        if(_t29 == 2) {
L5:
             *__esp = _t36 & -4;
            _t29 = caml_raise();
        }
    }
    return _t29;
}

signed int caml_process_pending_signals()
{// addr = 0x0805D30C
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int __ebx;                      // r1
    char* __esi;                           // r5

    __eax = caml_signals_are_pending;
    if(__eax != 0) {
        caml_signals_are_pending = 0;
        __ebx = 0;
        __esi =  &caml_pending_signals;
        do {
            __eax =  *( &caml_pending_signals + __ebx * 4);
            if(__eax != 0) {
                 *( &caml_pending_signals + __ebx * 4) = 0;
                __eax = caml_execute_signal(__ebx, __edi,  &caml_pending_signals, __ebx, 0);
            }
            __ebx = __ebx + 1;
        } while(__ebx != 65);
    }
    return __eax;
}

caml_install_signal_handler(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805D35E
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    _unknown_ _v64;                        // _cfa_ffffffc0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    char* __ebx;                           // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t42;                       // _t42
    _unknown_ _t43;                        // _t43
    intOrPtr* _t51;                        // _t51
    intOrPtr _t53;                         // _t53
    signed int _t56;                       // _t56

    __ebx = caml_local_roots;
    _v60 = __ebx;
    _v52 = 1;
    _v56 = 2;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v64 = 0;
    _v96 =  &_v60;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 1;
    _v84 =  &_v64;
    _t42 = caml_convert_signal_number(_a4 >> 1);
    _t56 = _t42;
    if(_t42 > 64) {
         *__esp = "Sys.signal: unavailable signal";
        _t42 = caml_invalid_argument();
    }
    __ecx = _a8;
    __edi = __ecx - 1;
    _t53 = 2;
    if(__edi <= 2) {
        _t53 =  *((intOrPtr*)(134658512 + __ecx * 4));
    }
    _t43 = caml_set_signal_action(_t42, _t53);
    if(_t43 == 1) {
        _v64 = 3;
    } else {
        if(_t43 == 2) {
            _t51 = caml_alloc_small(__ebx, _t56, 1, 0);
            _v64 = _t51;
             *_t51 =  *((intOrPtr*)(caml_signal_handlers + _t56 * 4));
        } else {
            if(_t43 != 0) {
                 *__esp = 1;
                caml_sys_error(__edi);
            } else {
                _v64 = 1;
            }
        }
    }
    if((_a8 & 1) == 0) {
        if(caml_signal_handlers == 0) {
            caml_signal_handlers = caml_alloc(__ebx, __edi, _t56, __fp0, 65, 0);
            caml_register_global_root( &caml_signal_handlers);
        }
        caml_modify(__ebx, __edi, (_t56 << 2) + caml_signal_handlers, (_t56 << 2) + caml_signal_handlers,  *_a8);
    }
    caml_process_pending_signals();
    caml_local_roots = __ebx;
    return _v64;
}

caml_leave_blocking_section()
{// addr = 0x0805D4AA
    caml_leave_blocking_section_hook();
    return caml_process_pending_signals();
}

caml_enter_blocking_section()
{// addr = 0x0805D4BD
    intOrPtr _t2;                          // _t2

    while(1) {
        caml_process_pending_signals();
        caml_enter_blocking_section_hook();
        _t2 = caml_signals_are_pending;
        if(_t2 == 0) {
            break;
        }
        caml_leave_blocking_section_hook();
    }
    return _t2;
}

caml_init_signals()
{// addr = 0x0805D4F0
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v20;                            // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    intOrPtr _v32;                         // _cfa_ffffffe0
    char _v160;                            // _cfa_ffffff60
    char _v164;                            // _cfa_ffffff5c
    intOrPtr _v180;                        // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48

    _v24 =  &sig_alt_stack;
    _v16 = 8192;
    _v20 = 0;
    _v164 = segv_handler;
    _v32 = 1207959552;
     *__esp =  &_v160;
    sigemptyset();
    system_stack_top =  &_v164;
    _v184 = 0;
     *__esp =  &_v24;
    sigaltstack();
    if( &_v24 == 0) {
        _v180 = 0;
        _v184 =  &_v164;
         *__esp = 11;
        sigaction();
        return  &_v24;
    }
    return  &_v24;
}

signed int caml_set_signal_action(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D572
    intOrPtr _v20;                         // _cfa_ffffffec
    char _v148;                            // _cfa_ffffff6c
    char _v152;                            // _cfa_ffffff68
    char _v292;                            // _cfa_fffffedc
    char* _v308;                           // _cfa_fffffecc
    char* _v312;                           // _cfa_fffffec8
    intOrPtr _t15;                         // _t15
    intOrPtr _t18;                         // _t18
    _unknown_ _t19;                        // _t19
    intOrPtr _t23;                         // _t23

    _t15 = _a8;
    if(_t15 == 0) {
        _v152 = 0;
        _v20 = 0;
    } else {
        if(_t15 != 1) {
            _v152 = handle_signal;
            _v20 = 0;
        } else {
            _v152 = 1;
            _v20 = 0;
        }
    }
     *__esp =  &_v148;
    sigemptyset();
    _v308 =  &_v292;
    _v312 =  &_v152;
    _t18 = _a4;
     *__esp = _t18;
    sigaction();
    _t19 = -1;
    if(_t18 != -1) {
        _t23 = _v292;
        _t19 = 2;
        if(_t23 != handle_signal) {
            return _t23 == 1 & 255;
        }
    }
    return _t19;
}

char segv_handler(
    signed char _a92                       // _cfa_5c
)
{// addr = 0x0805D61F
    char _v28;                             // _cfa_ffffffe4
    intOrPtr _v36;                         // _cfa_ffffffdc
    char _v164;                            // _cfa_ffffff5c
    char _v168;                            // _cfa_ffffff58
    intOrPtr _v180;                        // _cfa_ffffff4c
    char* _v184;                           // _cfa_ffffff48
    _unknown_ __ebx;                       // r1
    char* _t16;                            // _t16
    signed char _t20;                      // _t20

    _t20 = _a92;
    if((_t20 & 3) == 0) {
        _v184 =  &_v28;
         *__esp = 3;
        getrlimit64();
        if( &_v28 == 0) {
            _t16 = system_stack_top;
            if(_t20 < _t16 && _t20 >= _t16 - _v28 - 8192) {
                caml_raise_stack_overflow();
            }
        }
    }
    _v168 = 0;
    _v36 = 0;
     *__esp =  &_v164;
    sigemptyset();
    _v180 = 0;
    _v184 =  &_v168;
     *__esp = 11;
    sigaction();
    return  &_v164;
}

char handle_signal(
    _unknown_ __eax,                       // r0
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805D6A9
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int __ebx;                      // r1
    signed int _t5;                        // _t5

    __esi = __esi;
    __edi = __edi;
    __ebx = _a4;
    if(__ebx <= 64) {
        caml_try_leave_blocking_section_hook();
        if(__eax == 0) {
            return caml_record_signal(__ebx);
        }
        _t5 = caml_execute_signal(__ebx, __edi, __esi, __ebx, 1);
        caml_enter_blocking_section_hook();
        return _t5;
    }
    return __eax;
}

caml_garbage_collection()
{// addr = 0x0805D6EB
    intOrPtr _t1;                          // _t1

    _t1 = caml_young_start;
    caml_young_limit = _t1;
    if(_t1 > caml_young_ptr || caml_force_major_slice != 0) {
        caml_minor_collection(__ebx, __esi, __fp0);
    }
    return caml_process_pending_signals();
}

caml_ext_table_free(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D718
    signed int __ebx;                      // r1
    intOrPtr* __esi;                       // r5

    __esi = _a4;
    if(_a8 == 0 ||  *__esi <= 0) {
L4:
        return caml_stat_free(__esi[2]);
    } else {
        __ebx = 0;
        do {
            caml_stat_free( *((intOrPtr*)(__esi[2] + __ebx * 4)));
            __ebx = __ebx + 1;
        } while( *__esi > __ebx);
        goto L4;
    }
}

signed int caml_ext_table_add(
    signed int* _a4,                       // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D75A
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int* __ebx;                     // r1
    signed int _t12;                       // _t12
    signed int _t13;                       // _t13

    __ebx = _a4;
    _t12 = __ebx[1];
    if( *__ebx >= _t12) {
        __ebx[1] = _t12 + _t12;
        __ebx[2] = caml_stat_resize(__ebx[2], _t12 << 3);
    }
    _t13 =  *__ebx;
     *((intOrPtr*)(__ebx[2] + _t13 * 4)) = _a8;
     *__ebx =  *__ebx + 1;
    return _t13;
}

caml_ext_table_init(
    intOrPtr* _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805D79A
    intOrPtr* __ebx;                       // r1
    signed int _t5;                        // _t5
    intOrPtr _t7;                          // _t7

    __ebx = _a4;
    _t5 = _a8;
     *__ebx = 0;
     *(__ebx + 4) = _t5;
    _t7 = caml_stat_alloc(_t5 << 2, _t5 << 2);
    __ebx[2] = _t7;
    return _t7;
}

caml_aligned_malloc(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr* _a12                         // _cfa_c
)
{// addr = 0x0805D7C4
    intOrPtr __ebx;                        // r1
    intOrPtr _t6;                          // _t6
    intOrPtr _t11;                         // _t11

    __ebx = _a8;
    _t6 = _a4 + 4096;
     *__esp = _t6;
    malloc();
    _t11 = _t6;
    if(_t11 != 0) {
         *_a12 = _t11;
        return (_t11 + __ebx & -4096) + 4096 - __ebx;
    }
    return 0;
}

signed int caml_fatal_error_arg2(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    signed int _a12,                       // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0805D804
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v4;                          // _cfa_fffffffc
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    intOrPtr _v48;                         // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v80;                       // _cfa_ffffffb0
    intOrPtr _v104;                        // _cfa_ffffff98
    intOrPtr _v108;                        // _cfa_ffffff94
    signed int _t33;                       // _t33
    signed int _t37;                       // _t37
    _unknown_ _t38;                        // _t38
    signed int* _t39;                      // _t39
    signed int* _t40;                      // _t40

    _v20 = _a8;
    _v24 = _a4;
     *__esp = __imp__stderr;
    fprintf();
    _v20 = _a16;
    _v24 = _a12;
     *__esp = __imp__stderr;
    fprintf();
     *__esp = 2;
    exit();
    _push(_t38);
    _t39 = __esp;
    __esp = __esp - 24;
    _v48 = _v20;
    _v52 = _v24;
     *__esp = __imp__stderr;
    fprintf();
     *__esp = 2;
    exit();
    _push(_t39);
    _t40 = __esp;
    __esp = __esp - 24;
    _v80 = __imp__stderr;
     *__esp = _v52;
    fputs();
     *__esp = 2;
    exit();
    _push(_t40);
    __esp = __esp - 24;
    _t33 = _v80;
    if(_t33 < 0 || (caml_verb_gc & _t33) != 0) {
        _v104 = _v0;
        _v108 = _v4;
         *__esp = __imp__stderr;
        fprintf();
        _t37 = __imp__stderr;
         *__esp = _t37;
        fflush();
        return _t37;
    }
    return _t33;
}

signed int caml_fatal_error_arg(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D84C
    intOrPtr _v0;                          // _cfa_0
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v76;                       // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    signed int _t19;                       // _t19
    signed int _t23;                       // _t23
    _unknown_ _t24;                        // _t24
    signed int* _t25;                      // _t25

    _v20 = _a8;
    _v24 = _a4;
     *__esp = __imp__stderr;
    fprintf();
     *__esp = 2;
    exit();
    _push(_t24);
    _t25 = __esp;
    __esp = __esp - 24;
    _v52 = __imp__stderr;
     *__esp = _v24;
    fputs();
     *__esp = 2;
    exit();
    _push(_t25);
    __esp = __esp - 24;
    _t19 = _v52;
    if(_t19 < 0 || (caml_verb_gc & _t19) != 0) {
        _v76 = _a4;
        _v80 = _v0;
         *__esp = __imp__stderr;
        fprintf();
        _t23 = __imp__stderr;
         *__esp = _t23;
        fflush();
        return _t23;
    }
    return _t19;
}

signed int caml_fatal_error(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805D879
    signed int _v24;                       // _cfa_ffffffe8
    intOrPtr _v48;                         // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _t12;                       // _t12
    signed int _t16;                       // _t16
    _unknown_ _t17;                        // _t17

    _v24 = __imp__stderr;
     *__esp = _a4;
    fputs();
     *__esp = 2;
    exit();
    _push(_t17);
    __esp = __esp - 24;
    _t12 = _v24;
    if(_t12 < 0 || (caml_verb_gc & _t12) != 0) {
        _v48 = _a8;
        _v52 = _a4;
         *__esp = __imp__stderr;
        fprintf();
        _t16 = __imp__stderr;
         *__esp = _t16;
        fflush();
        return _t16;
    }
    return _t12;
}

signed int caml_gc_message(
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805D89F
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _t8;                        // _t8
    signed int _t12;                       // _t12

    _t8 = _a4;
    if(_t8 < 0 || (caml_verb_gc & _t8) != 0) {
        _v20 = _a12;
        _v24 = _a8;
         *__esp = __imp__stderr;
        fprintf();
        _t12 = __imp__stderr;
         *__esp = _t12;
        fflush();
        return _t12;
    } else {
        return _t8;
    }
}

allocate_block(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr* __ecx,                       // r2
    intOrPtr __edx,                        // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805D8E0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    signed int _t25;                       // _t25
    intOrPtr* _t31;                        // _t31
    signed int _t45;                       // _t45
    unsigned int* _t48;                    // _t48
    intOrPtr _t50;                         // _t50
    intOrPtr _t51;                         // _t51

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v20 = __edx;
    _t31 = _a4;
    _t48 = _t31 - 4;
    _t25 =  *_t48 >> 10;
    if(_t25 >= __eax + 1) {
        caml_fl_cur_size = caml_fl_cur_size - __eax;
         *_t48 = (_t25 - __eax << 10) + 512;
L8:
        if(caml_allocation_policy == 0) {
            fl_prev = __ecx;
        }
L10:
        return _t31 + (_t25 - __eax) * 4;
    }
    caml_fl_cur_size = caml_fl_cur_size +  !_t25;
     *__ecx =  *_t31;
    _t43 = caml_fl_merge == _t31 ? __ecx : caml_fl_merge;
    caml_fl_merge = caml_fl_merge == _t31 ? __ecx : caml_fl_merge;
     *_t48 = 0;
    if(caml_allocation_policy != 1) {
        goto L8;
    }
    _t45 = _v20 + 1;
    _t50 = flp_size;
    if(_t45 >= _t50 ||  *((intOrPtr*)(_t45 * 4 +  &flp)) != _t31) {
        _t51 = _t50 - 1;
        if(_t51 != _v20) {
            goto L8;
        }
        _t29 = __ecx == 134694056 ? 0 : __ecx;
        beyond = __ecx == 134694056 ? 0 : __ecx;
        flp_size = _t51;
    } else {
         *((intOrPtr*)(_t45 * 4 +  &flp)) = __ecx;
    }
}

caml_fl_init_merge(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805D9B2
    __eax = __eax;
    last_fragment = 0;
    caml_fl_merge = 134694056;
    return __eax;
}

truncate_flp(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805D9CB
    signed int _t7;                        // _t7
    signed int _t8;                        // _t8
    signed int _t9;                        // _t9

    __eax = __eax;
    if(__eax == 134694056) {
        flp_size = 0;
        beyond = 0;
        return __eax;
    }
    _t8 = flp_size;
    if(_t8 > 0) {
        _t9 = _t8 - 1;
        if(__eax <=  *((intOrPtr*)( *((intOrPtr*)(_t9 * 4 +  &flp))))) {
            while(_t9 > 0) {
                _t7 = _t9 - 1;
                if(__eax <=  *((intOrPtr*)( *((intOrPtr*)( &flp + _t7 * 4))))) {
                    _t9 = _t7;
                    continue;
                } else {
                    flp_size = _t9;
                }
                goto L10;
            }
            flp_size = _t9;
        } else {
        }
    }
L10:
    if(__eax <= beyond) {
        beyond = 0;
        return __eax;
    }
    return __eax;
}

caml_fl_reset()
{// addr = 0x0805DA40
    intOrPtr _t1;                          // _t1

     *134694056 = 0;
    _t1 = caml_allocation_policy;
    if(_t1 == 0) {
        fl_prev = 134694056;
    } else {
        if(_t1 == 1) {
            _t1 = truncate_flp(134694056);
        }
    }
    caml_fl_cur_size = 0;
    return caml_fl_init_merge(_t1);
}

signed int caml_fl_merge_block(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805DA84
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int* _v28;                      // _cfa_ffffffe4
    signed int* _v32;                      // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t42;                       // _t42
    signed int _t47;                       // _t47
    signed int _t55;                       // _t55
    signed int* _t58;                      // _t58
    signed int _t63;                       // _t63
    signed int _t67;                       // _t67
    unsigned int _t71;                     // _t71
    signed int _t73;                       // _t73
    unsigned int* _t74;                    // _t74
    signed int _t80;                       // _t80
    signed int _t81;                       // _t81
    signed int _t83;                       // _t83
    signed int _t85;                       // _t85
    unsigned int _t88;                     // _t88

    _t81 = _a4;
    _t42 = _t81 - 4;
    _v20 = _t42;
    _t88 =  *_t42;
    caml_fl_cur_size = caml_fl_cur_size + (_t88 >> 10) + 1;
    _t58 = caml_fl_merge;
    _v28 = _t58;
    _v24 =  *_t58;
    if(caml_allocation_policy == 1) {
        truncate_flp(_t58);
    }
    _t80 = _t81 - 4;
    if(_t80 != last_fragment) {
L5:
        _t80 = _t81;
        goto L6;
    } else {
        _t55 = ( *_v20 >> 10) + 1;
        if(_t55 > 4194303) {
            goto L5;
        }
        _t88 = _t55 << 10;
         *(_t80 - 4) = _t88;
        caml_fl_cur_size = caml_fl_cur_size + 1;
L6:
        _t83 = _t88 >> 10;
        _t67 = _t80 + _t83 * 4;
        _t47 = _v24 - 4;
        if(_t47 == _t67) {
            _v20 =  *_v24;
            _t71 =  *(_v24 - 4);
            _v36 = _t71;
            _t73 = _t83 + (_t71 >> 10) + 1;
            if(_t73 <= 4194303) {
                 *_v28 = _v20;
                if(caml_allocation_policy == 0) {
                    _t52 = fl_prev == _v24 ? _t58 : fl_prev;
                    fl_prev = fl_prev == _v24 ? _t58 : fl_prev;
                }
                _t88 = (_t73 << 10) + 512;
                 *(_t80 - 4) = _t88;
                _t47 = _t80 + (_t88 >> 10) * 4;
                _v24 = _v20;
            }
        } else {
            _t47 = _t67;
        }
        _t74 = _t58 - 4;
        _t85 =  *_t74 >> 10;
        _v20 = _t85;
        _v32 =  &(_t58[_t85]);
        if(_v32 != _t80 - 4) {
L15:
            if(_t88 >> 10 == 0) {
                last_fragment = _t80;
                caml_fl_cur_size = caml_fl_cur_size - 1;
                return _t47;
            }
             *((signed int*)(_t80 - 4)) = _t88 & -769 | 512;
             *_t80 = _v24;
             *_v28 = _t80;
            caml_fl_merge = _t80;
            return _t47;
        } else {
            _t63 = _t85 + (_t88 >> 10) + 1;
            if(_t63 > 4194302) {
                goto L15;
            }
             *_t74 = (_t63 << 10) + 512;
            return _t47;
        }
    }
}

signed int caml_fl_add_blocks(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805DBE9
    signed int* __ebx;                     // r1
    signed int _t9;                        // _t9
    signed int _t11;                       // _t11
    signed int* _t13;                      // _t13
    signed int* _t17;                      // _t17
    signed int* _t18;                      // _t18
    signed int* _t20;                      // _t20

    _t9 = _a4;
    caml_fl_cur_size = caml_fl_cur_size + ( *(_t9 - 4) >> 10) + 1;
    _t17 = fl_last;
    if(_t9 <= _t17) {
        _t13 =  *134694056;
        if(_t13 == 0 || _t9 <= _t13) {
            __ebx = 134694056;
            goto L14;
        } else {
            while(1) {
                _t20 =  *_t13;
                if(_t20 == 0 || _t9 <= _t20) {
                    break;
                }
                _t13 = _t20;
            }
            __ebx = _t13;
            _t13 = _t20;
L14:
            _t18 = _t9 + 4;
             *( *_t18) = _t13;
             *__ebx = _t9;
            if(__ebx == caml_fl_merge && _t9 < caml_gc_sweep_hp) {
                caml_fl_merge =  *_t18;
            }
            if(caml_allocation_policy != 1) {
L19:
                return _t9;
            } else {
                return truncate_flp(_t9);
            }
        }
    }
     *_t17 = _t9;
    if(_t17 == caml_fl_merge) {
        if(_t9 < caml_gc_sweep_hp) {
            _t9 =  *(_t9 + 4);
            caml_fl_merge = _t9;
        }
    }
    if(caml_allocation_policy != 1) {
        goto L19;
    }
    _t9 = flp_size;
    if(_t9 > 999) {
        goto L19;
    }
     *(_t9 * 4 +  &flp) = _t17;
    _t11 = _t9 + 1;
    flp_size = _t11;
    return _t11;
}

signed int caml_make_free_blocks(
    signed int* _a4,                       // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805DCA9
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    signed int* __esi;                     // r5
    signed int _t9;                        // _t9
    signed int _t13;                       // _t13

    __esi = _a4;
    __edi = _a8;
    if(__edi != 0) {
        while(1) {
            _t13 = __edi - 4194304 <= 0 ? __edi : 4194304;
            _t9 = 0x3fffff << 10;
             *__esi = _t9;
            if(_a12 != 0) {
                _t9 = caml_fl_merge_block( &(__esi[1]));
            }
            __edi = __edi - _t13;
            if(__edi == 0) {
                goto L5;
            }
            __esi =  &(__esi[_t13]);
        }
    }
L5:
    return _t9;
}

caml_set_allocation_policy(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805DCF4
    __eax = _a4;
    if(__eax == 0) {
        fl_prev = 134694056;
    } else {
        if(__eax == 1) {
            flp_size = 0;
            beyond = 0;
        }
    }
    caml_allocation_policy = __eax;
    return __eax;
}

signed int caml_fl_allocate(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805DD2C
    char _v4028;                           // _cfa_fffff044
    signed int _v4032;                     // _cfa_fffff040
    signed int _v4036;                     // _cfa_fffff03c
    signed int _v4040;                     // _cfa_fffff038
    signed int _v4044;                     // _cfa_fffff034
    signed int _v4052;                     // _cfa_fffff02c
    char* _v4056;                          // _cfa_fffff028
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    intOrPtr _t91;                         // _t91
    signed int _t101;                      // _t101
    signed int _t102;                      // _t102
    intOrPtr* _t103;                       // _t103
    signed int _t105;                      // _t105
    signed int _t107;                      // _t107
    signed int _t133;                      // _t133
    signed int _t143;                      // _t143
    signed int _t144;                      // _t144
    signed int _t145;                      // _t145
    signed int _t146;                      // _t146
    unsigned int _t148;                    // _t148
    signed int _t149;                      // _t149
    signed int _t150;                      // _t150
    signed int _t151;                      // _t151
    signed int _t152;                      // _t152
    intOrPtr _t154;                        // _t154
    signed int _t155;                      // _t155
    signed int _t156;                      // _t156
    unsigned int _t157;                    // _t157
    unsigned int _t159;                    // _t159
    intOrPtr _t163;                        // _t163
    signed int _t164;                      // _t164
    signed int _t165;                      // _t165
    unsigned int _t168;                    // _t168
    signed int _t171;                      // _t171
    signed int _t174;                      // _t174
    intOrPtr _t179;                        // _t179
    _unknown_ _t195;                       // _t195
    signed int _t196;                      // _t196
    unsigned int _t198;                    // _t198
    intOrPtr _t200;                        // _t200
    _unknown_ _t202;                       // _t202
    signed int _t203;                      // _t203
    unsigned int _t205;                    // _t205
    unsigned int _t207;                    // _t207
    unsigned int _t208;                    // _t208

    _t91 = _a4;
    _t163 = caml_allocation_policy;
    if(_t163 == 0) {
        _t151 = fl_prev;
        _t164 =  *_t151;
        if(_t164 == 0) {
L11:
            fl_last = _t151;
            _t152 = 134694056;
            _t165 =  *134694056;
            _t203 = fl_prev;
            if(134694056 == _t203) {
L69:
                _t196 = 0;
L70:
                return _t196;
            }
            _t138 =  *(_t165 - 4) >> 10;
            if(_t91 >  *(_t165 - 4) >> 10) {
                while(1) {
                    _t152 = _t165;
                    _t165 =  *_t165;
                    if(_t203 == _t152) {
                        break;
                    }
                    _t138 =  *(_t165 - 4) >> 10;
                    if(_t91 >  *(_t165 - 4) >> 10) {
                        continue;
                    }
L15:
                    _t196 = allocate_block(_t91 + 1, _t138, _t152, 0, _t195, _t203, _t165);
                    goto L70;
                }
                goto L69;
            }
            goto L15;
        }
        _t141 =  *(_t164 - 4) >> 10;
        if(_t91 >  *(_t164 - 4) >> 10) {
            while(1) {
                _t151 = _t164;
                _t164 =  *_t164;
                if(_t164 == 0) {
                    goto L11;
                }
                _t141 =  *(_t164 - 4) >> 10;
                if( *(_t164 - 4) >> 10 < _t91) {
                    continue;
                }
L9:
                _t196 = allocate_block(_t91 + 1, _t141, _t151, 0, _t195, _t202, _t164);
                goto L70;
            }
            goto L11;
        }
        goto L9;
    }
    if(_t163 != 1) {
        goto L69;
    }
    _t168 = flp_size;
    _v4032 = _t168;
    if(_t168 <= 0) {
L21:
        if(_v4032 != 0) {
            _t154 =  *((intOrPtr*)( *((intOrPtr*)(134703356 + _v4032 * 4))));
            _t198 =  *(_t154 - 4) >> 10;
            _t155 = beyond != 0 ? beyond : _t154;
        } else {
            _t155 = 134694056;
            _t198 = 0;
        }
        _t171 = 0;
        while(1) {
            _t143 = flp_size;
            if(_t143 > 999) {
                break;
            }
            _t171 =  *_t155;
            if(_t171 != 0) {
                _t205 =  *(_t171 - 4) >> 10;
                if(_t198 >= _t205) {
L31:
                    _t155 = _t171;
                    continue;
                }
                 *(_t143 * 4 +  &flp) = _t155;
                _t144 = flp_size;
                _t199 = _t144 + 1;
                flp_size = _t144 + 1;
                if(_t91 > _t205) {
                    _t198 = _t205;
                    goto L31;
                }
                beyond = _t171;
                _t196 = allocate_block(_t91 + 1, _t144, _t155, _t144, _t199, _t205, _t171);
L44:
                _t101 = flp_size;
                if(_t144 >= _t101) {
                    goto L70;
                }
                _t157 = 0;
                if(_t144 > 0) {
                    _t157 =  *( *((intOrPtr*)( *((intOrPtr*)(134703356 + _t144 * 4)))) - 4) >> 10;
                }
                _t102 = _t101 - 1;
                if(_t102 != _t144) {
                    _t103 =  *((intOrPtr*)( &flp + _t144 * 4));
                    _v4036 = 0;
                    _v4032 = _t205;
                    _t208 = _t157;
                    _v4040 = _t144;
                    _t145 = 0;
                    _v4044 = _t196;
                    _t200 =  *((intOrPtr*)( &flp + 4 + _t144 * 4));
                    while(_t200 != _t103) {
                        _t179 =  *_t103;
                        _t159 =  *(_t179 - 4) >> 10;
                        if(_t208 >= _t159) {
L55:
                            _t103 = _t179;
                            continue;
                        }
                         *((intOrPtr*)(__ebp + _t145 * 4 - 4024)) = _t103;
                        _t145 = _t145 + 1;
                        if(_v4032 <= _t159) {
                            break;
                        }
                        _t208 = _t159;
                        goto L55;
                    }
                    _v4036 = _t145;
                    _t146 = _v4040;
                    _t196 = _v4044;
                    _t105 = flp_size - 1;
                    if(_t105 + _v4036 > 1000) {
                        _t107 = _v4036 + _t146;
                        if(_t107 > 999) {
                            if(_t146 != 1000) {
                                _v4052 = 1000 - _t146 << 2;
                                _v4056 =  &_v4028;
                                 *__esp = _t146 * 4 +  &flp;
                                memmove();
                            }
L68:
                            flp_size = 999;
                            beyond =  *( *134707356);
                            goto L70;
                        }
                        if(_v4036 == 1) {
L65:
                            _v4052 = _v4036 << 2;
                            _v4056 =  &_v4028;
                             *__esp = _t146 * 4 +  &flp;
                            memmove();
                            goto L68;
                        }
                        _v4052 = 1000 - _t146 - _v4036 << 2;
                        _v4056 = 134703364 + _t146 * 4;
                         *__esp = _t107 * 4 +  &flp;
                        memmove();
                        if(_v4036 <= 0) {
                            goto L68;
                        }
                        goto L65;
                    }
                    if(_v4036 == 1) {
L60:
                        _v4052 = _v4036 << 2;
                        _v4056 =  &_v4028;
                         *__esp = _t146 * 4 +  &flp;
                        memmove();
L61:
                        flp_size = _v4036 + flp_size - 1;
                        goto L70;
                    }
                    _v4052 = _t105 - _t146 << 2;
                    _v4056 = 134703364 + _t146 * 4;
                     *__esp = (_v4036 + _t146) * 4 +  &flp;
                    memmove();
                    if(_v4036 <= 0) {
                        goto L61;
                    }
                    goto L60;
                } else {
                    _t133 =  *( *(_t102 * 4 +  &flp));
                    if(_t157 <  *(_t133 - 4) >> 10) {
                        beyond = 0;
                    } else {
                        beyond = _t133;
                        flp_size = flp_size - 1;
                    }
                    goto L70;
                }
            }
            fl_last = _t155;
            _t161 = _t155 == 134694056 ? 0 : _t155;
            beyond = _t155 == 134694056 ? 0 : _t155;
            _t196 = 0;
            goto L70;
        }
        beyond = _t171;
        _t156 = _t171;
        if(_t171 == 0) {
            _t156 =  *(134703356 + _t143 * 4);
        }
        _t207 =  *((unsigned int*)( *( *134707356) - 4)) >> 10;
        _t174 =  *_t156;
        if(_t174 == 0) {
L43:
            fl_last = _t156;
            _t196 = 0;
            goto L70;
        } else {
            while(1) {
                _t148 =  *(_t174 - 4) >> 10;
                if(_t207 <= _t148) {
                    goto L38;
                }
                beyond = _t174;
L40:
                _t149 =  *_t174;
                if(_t149 == 0) {
                    _t156 = _t174;
                    goto L43;
                }
                _t156 = _t174;
                _t174 = _t149;
                continue;
L38:
                if(_t91 > _t148) {
                    goto L40;
                }
                _t196 = allocate_block(_t91 + 1, _t148, _t156, flp_size, _t198, _t207, _t174);
                goto L70;
            }
        }
    }
    _t162 = flp;
    _t193 =  *flp;
    _t150 = 0;
    if(_t91 >  *( *flp - 4) >> 10) {
        while(1) {
            _t150 = _t150 + 1;
            if(_t150 >= _v4032) {
                goto L21;
            }
            _t162 =  *((intOrPtr*)( &flp + _t150 * 4));
            _t193 =  *((intOrPtr*)( *((intOrPtr*)( &flp + _t150 * 4))));
            _t205 =  *( *((intOrPtr*)( *((intOrPtr*)( &flp + _t150 * 4)))) - 4) >> 10;
            if(_t91 > _t205) {
                continue;
            }
            goto L19;
        }
        goto L21;
    } else {
L19:
        _t196 = allocate_block(_t91 + 1, _t150, _t162, _t150,  &flp, _t205, _t193);
        goto L44;
    }
}

signed int clip_heap_chunk_size(
    _unknown_ __eax                        // r0
)
{// addr = 0x0805E1B0
    _t3 = __eax - 8191 <= 0 ? 8192 : __eax;
    _t4 = (__eax - 8191 <= 0 ? 8192 : __eax) + 4095;
    _t5 = (__eax - 8191 <= 0 ? 8192 : __eax) + 4095 & -4096;
    return (__eax - 8191 <= 0 ? 8192 : __eax) + 4095 & -4096;
}

caml_init_major_heap(
    long long __fp0,                       // r28
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805E1CC
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    unsigned int _t10;                     // _t10
    signed int _t11;                       // _t11
    signed int _t18;                       // _t18
    intOrPtr _t19;                         // _t19

    __fp0 = __fp0;
    _t10 = clip_heap_chunk_size(_a4);
    caml_stat_heap_size = _t10;
    caml_stat_top_heap_size = _t10;
    _t11 = caml_alloc_for_heap(_t10);
    caml_heap_start = _t11;
    if(_t11 == 0) {
        _t11 = caml_fatal_error("Fatal error: not enough memory for the initial heap.\n");
    }
     *((intOrPtr*)(_t11 - 4)) = 0;
    caml_stat_heap_chunks = 1;
    if(caml_page_table_add(1, caml_heap_start, caml_heap_start + caml_stat_heap_size) != 0) {
        _t13 = caml_fatal_error("Fatal error: not enough memory for the initial page table.\n");
    }
    caml_fl_init_merge(_t13);
    _t18 = caml_make_free_blocks(caml_heap_start, caml_stat_heap_size >> 2, 1);
    caml_gc_phase = 2;
    gray_vals_size = 2048;
     *__esp = 8192;
    malloc();
    gray_vals = _t18;
    if(_t18 == 0) {
        _t18 = caml_fatal_error("Fatal error: not enough memory for the gray cache.\n");
    }
    gray_vals_cur = _t18;
    _t19 = _t18 + gray_vals_size * 4;
    gray_vals_end = _t19;
    heap_is_pure = 1;
    caml_allocated_words = 0;
    asm("fldz");
    caml_extra_heap_resources = __fp0;
    return _t19;
}

caml_round_heap_chunk_size(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805E2CF
    intOrPtr __ebx;                        // r1
    signed int _t5;                        // _t5

    __ebx = _a4;
    _t4 = __ebx - caml_major_heap_increment >= 0 ? __ebx : caml_major_heap_increment;
    _t5 = clip_heap_chunk_size(__ebx - caml_major_heap_increment >= 0 ? __ebx : caml_major_heap_increment);
    if(__ebx > _t5) {
        return caml_raise_out_of_memory();
    }
    return _t5;
}

start_cycle()
{// addr = 0x0805E2F7
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ _t4;                         // _t4

    caml_gc_message(1, "Starting new major GC cycle\n", 0);
    _t4 = caml_darken_all_roots();
    caml_gc_phase = 0;
    caml_gc_subphase = 10;
    markhp = 0;
    return _t4;
}

signed int realloc_gray_vals()
{// addr = 0x0805E33E
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    signed int _v24;                       // _cfa_ffffffe8 (outparam)
    unsigned int _t13;                     // _t13
    signed int _t15;                       // _t15
    signed int _t19;                       // _t19
    intOrPtr _t20;                         // _t20
    signed int _t22;                       // _t22
    signed int _t26;                       // _t26
    signed int _t32;                       // _t32

    _t26 = gray_vals_size;
    _t13 = caml_stat_heap_size;
    _t14 = _t13 < 0 ? _t13 + 127 : _t13;
    _t15 = (_t13 < 0 ? _t13 + 127 : _t13) >> 7;
    if(_t15 <= _t26) {
        gray_vals_cur = (_t26 >> 1 << 2) + gray_vals;
        heap_is_pure = 0;
        return _t15;
    }
    caml_gc_message(8, "Growing gray_vals to %luk bytes\n", _t26 << 2 >> 9);
    _v24 = gray_vals_size << 3;
    _t19 = gray_vals;
     *__esp = _t19;
    realloc();
    if(_t19 != 0) {
        gray_vals = _t19;
        _t32 = gray_vals_size;
        gray_vals_cur = _t19 + _t32 * 4;
        gray_vals_size = _t32 + _t32;
        _t20 = _t19 + _t32 * 8;
        gray_vals_end = _t20;
        return _t20;
    }
    caml_gc_message(8, "No room for growing gray_vals\n", 0);
    _t22 = gray_vals;
    gray_vals_cur = _t22;
    heap_is_pure = 0;
    return _t22;
}

signed int mark_slice(
    intOrPtr __eax                         // r0
)
{// addr = 0x0805E413
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t120;                      // _t120
    signed int _t121;                      // _t121
    unsigned int _t123;                    // _t123
    unsigned int _t125;                    // _t125
    unsigned int _t129;                    // _t129
    unsigned int _t131;                    // _t131
    signed char _t133;                     // _t133
    signed int _t136;                      // _t136
    signed int _t138;                      // _t138
    signed int _t142;                      // _t142
    signed int _t145;                      // _t145
    signed int _t154;                      // _t154
    signed int _t160;                      // _t160
    unsigned int _t162;                    // _t162
    signed int _t166;                      // _t166
    unsigned int* _t167;                   // _t167
    unsigned int _t169;                    // _t169
    signed int _t172;                      // _t172
    unsigned int _t180;                    // _t180
    signed char _t181;                     // _t181
    signed char _t185;                     // _t185
    signed int _t188;                      // _t188
    signed int _t189;                      // _t189
    _unknown_ _t191;                       // _t191
    unsigned int _t192;                    // _t192
    signed int _t194;                      // _t194
    signed int _t197;                      // _t197
    unsigned int _t199;                    // _t199
    unsigned int _t200;                    // _t200

    _v40 = __eax;
    caml_gc_message(64, "Marking %ld words\n", __eax);
    _t120 = caml_gc_message(64, "Subphase = %ld\n", caml_gc_subphase);
    _t194 = gray_vals_cur;
    if(_v40 <= 0) {
L74:
        gray_vals_cur = _t194;
        return _t120;
    } else {
        goto L1;
    }
    do {
L1:
        if(gray_vals >= _t194) {
            _t121 = markhp;
            if(_t121 == 0) {
                if(heap_is_pure != 0) {
                    _t120 = caml_gc_subphase;
                    if(_t120 == 11) {
                        _t120 =  *weak_prev;
                        _v56 = _t120;
                        if(_t120 == 0) {
                            caml_gc_subphase = 12;
                            weak_prev =  &caml_weak_list_head;
                            goto L73;
                        }
                        _v44 = _t120;
                        _t129 =  *(_t120 - 4) >> 10;
                        _v52 = _t129;
                        if(_t129 <= 1) {
L64:
                            weak_prev = _v56;
                            _t120 =  !_v52;
                            _v40 = _v40 + _t120;
                            goto L73;
                        }
                        _v36 = 1;
                        _v60 = _t194;
                        do {
                            _t131 =  *((intOrPtr*)(_v44 + _v36 * 4));
                            _t192 = caml_weak_none;
                            if(_t131 != _t192 && (_t131 & 1) == 0 && ( *( *((intOrPtr*)((_t131 >> 23) * 4 +  &caml_page_table)) + (_t131 >> 12 & 2047)) & 1) != 0) {
                                _t180 = _t131 - 4;
                                if( *_t180 != 250) {
L60:
                                    if(( *_t180 & 768) == 0) {
                                         *((intOrPtr*)(_v44 + _v36 * 4)) = _t192;
                                    }
                                    goto L62;
                                }
                                _t133 =  *_t131;
                                if((_t133 & 1) == 0) {
                                    while(1) {
                                        _v48 = _t180;
                                        _t181 = _t133;
                                        _t197 = _t133 >> 23;
                                        _t145 = _t133 >> 12 & 2047;
                                        if(( *( *((intOrPtr*)(_t197 * 4 +  &caml_page_table)) + _t145) & 7) == 0) {
                                            break;
                                        }
                                        _t180 = _t181 - 4;
                                        _v32 = _t180;
                                        _t154 =  *_t180 & 255;
                                        if(_t154 == 250 || _t154 == 246 || _t154 == 253) {
                                            break;
                                        } else {
                                             *(_v44 + _v36 * 4) = _t133;
                                            _t192 = caml_weak_none;
                                            if(_t133 != _t192) {
                                                if((_t133 & 1) != 0 || ( *( *((intOrPtr*)(_t197 * 4 +  &caml_page_table)) + _t145) & 1) == 0) {
                                                    goto L62;
                                                } else {
                                                    if( *_v32 != 250) {
                                                        goto L60;
                                                    }
                                                    _t133 =  *_t133;
                                                    if((_t133 & 1) != 0) {
                                                        goto L60;
                                                    }
                                                    continue;
                                                }
                                            }
                                            goto L62;
                                        }
                                    }
                                    _t180 = _v48;
                                    goto L60;
                                }
                                goto L60;
                            }
L62:
                            _v36 = _v36 + 1;
                        } while(_v36 != _v52);
                        _t194 = _v60;
                        goto L64;
                    }
                    if(_t120 > 11) {
                        if(_t120 == 12) {
                            _t172 = weak_prev;
                            _t120 =  *_t172;
                            if(_t120 == 0) {
                                gray_vals_cur = _t194;
                                _t120 = caml_final_update();
                                _t194 = gray_vals_cur;
                                caml_gc_subphase = 13;
                            } else {
                                if(( *(_t120 - 4) & 768) != 0) {
                                    weak_prev = _t120;
                                } else {
                                    _t120 =  *_t120;
                                     *_t172 = _t120;
                                }
                                _v40 = _v40 - 1;
                            }
                            goto L73;
                        }
                        if(_t120 != 13) {
                            goto L73;
                        }
                        gray_vals_cur = _t194;
                        caml_gc_sweep_hp = caml_heap_start;
                        caml_fl_init_merge(caml_heap_start);
                        caml_gc_phase = 1;
                        _t136 = caml_heap_start;
                        chunk = _t136;
                        caml_gc_sweep_hp = _t136;
                        limit = _t136 +  *(_t136 - 8);
                        _t120 = caml_fl_cur_size;
                        caml_fl_size_at_phase_change = _t120;
                        goto L74;
                    }
                    if(_t120 == 10) {
                        caml_gc_subphase = 11;
                        weak_prev =  &caml_weak_list_head;
                    }
                    goto L73;
                }
                heap_is_pure = 1;
                _t138 = caml_heap_start;
                chunk = _t138;
                markhp = _t138;
                _t120 = _t138 +  *(_t138 - 8);
                limit = _t120;
            } else {
                if(_t121 != limit) {
                    if(( *_t121 & 768) == 256) {
                         *_t194 = _t121 + 4;
                        _t194 = _t194 + 4;
                    }
                    _t120 = markhp + 4 + ( *markhp >> 10) * 4;
                    markhp = _t120;
                } else {
                    _t120 =  *(chunk - 4);
                    chunk = _t120;
                    if(_t120 != 0) {
                        markhp = _t120;
                        _t120 = _t120 +  *(_t120 - 8);
                        limit = _t120;
                    } else {
                        markhp = 0;
                    }
                }
            }
            goto L73;
        }
        _t194 = _t194 - 4;
        _t191 =  *_t194;
        _t167 = _t191 - 4;
        _t123 =  *_t167;
         *_t167 = _t123 | 3;
        _t169 = _t123 >> 10;
        _v32 = _t169;
        if(_t123 > 250) {
L21:
            _t120 =  !_v32;
            _v40 = _v40 + _t120;
            goto L73;
        }
        if(_t169 == 0) {
            goto L21;
        } else {
            _t142 = 0;
            _v56 = _t194;
            goto L5;
            do {
L19:
                _t142 = _t142 + 1;
                if(_v32 > _t142) {
L5:
                    _t125 =  *(_t191 + _t142 * 4);
                    if((_t125 & 1) != 0) {
                        continue;
                    }
                    break;
                } else {
                    _t194 = _v56;
                    goto L21;
                }
            } while();
            _t199 = _t125;
            if(( *( *((intOrPtr*)((_t125 >> 23) * 4 +  &caml_page_table)) + (_t125 >> 12 & 2047)) & 1) == 0) {
                goto L19;
            }
            _t185 =  *(_t125 - 4);
            _t160 = _t185 & 255;
            if(_t160 != 250) {
                if(_t160 == 249) {
                    _t200 = _t199 - (_t185 >> 10) * 4;
                    _t125 = _t200;
                    _t185 =  *((signed char*)(_t200 - 4));
                }
L16:
                if((_t185 & 3) == 0) {
                     *(_t125 - 4) = _t185 & 252 | 1;
                    _t188 = _v56;
                     *_t188 = _t125;
                    _t189 = _t188 + 4;
                    _v56 = _t189;
                    if(_t189 >= gray_vals_end) {
                        gray_vals_cur = _t189;
                        realloc_gray_vals();
                        _v56 = gray_vals_cur;
                    }
                }
                goto L19;
            }
            _t162 =  *_t125;
            _v36 = _t162;
            if((_t162 & 1) != 0) {
L13:
                 *(_t191 + _t142 * 4) = _v36;
                goto L16;
            }
            _v48 = _t162;
            if(( *( *((intOrPtr*)((_t162 >> 23) * 4 +  &caml_page_table)) + (_t162 >> 12 & 2047)) & 7) == 0) {
                goto L16;
            }
            _t166 =  *(_v48 - 4) & 255;
            if(_t166 == 250 || _t166 == 246 || _t166 == 253) {
                goto L16;
            } else {
                goto L13;
            }
            goto L19;
        }
L73:
    } while(_v40 > 0);
    goto L74;
}

intOrPtr* caml_darken(
    unsigned int _a4                       // _cfa_4
)
{// addr = 0x0805E860
    _unknown_ __ebx;                       // r1
    unsigned int _t17;                     // _t17
    unsigned int _t20;                     // _t20
    unsigned int _t21;                     // _t21
    signed int _t25;                       // _t25
    signed char _t29;                      // _t29
    unsigned int _t33;                     // _t33

    _t17 = _a4;
    if((_t17 & 1) == 0) {
        _t20 = _t17;
        if(( *( *((intOrPtr*)((_t17 >> 23) * 4 +  &caml_page_table)) + (_t17 >> 12 & 2047)) & 1) != 0) {
            _t29 =  *(_t17 - 4);
            _t25 = _t29 & 255;
            if(_t25 == 249) {
                _t21 = _t20 - (_t29 >> 10) * 4;
                _t17 = _t21;
                _t29 =  *((signed char*)(_t21 - 4));
                _t25 = _t29 & 255;
            }
            if((_t29 & 3) == 0) {
                if(_t25 > 250) {
                     *(_t17 - 4) = _t29 | 3;
                    return _t17;
                }
                 *(_t17 - 4) = _t29 & 252 | 1;
                _t33 = gray_vals_cur;
                 *_t33 = _t17;
                _t17 = _t33 + 4;
                gray_vals_cur = _t17;
                if(_t17 >= gray_vals_end) {
                    return realloc_gray_vals();
                }
            }
        }
    }
    return _t17;
}

sweep_slice(
    intOrPtr __eax                         // r0
)
{// addr = 0x0805E8F0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    intOrPtr __esi;                        // r5
    signed int _t13;                       // _t13
    signed int* _t15;                      // _t15
    signed int* _t18;                      // _t18
    signed int _t21;                       // _t21
    signed int _t24;                       // _t24

    __esi = __eax;
    _t11 = caml_gc_message(64, "Sweeping %ld words\n", __eax);
    if(__esi <= 0) {
L15:
        return;
    } else {
        goto L1;
    }
    do {
L1:
        _t15 = caml_gc_sweep_hp;
        if(_t15 >= limit) {
            _t13 =  *(chunk - 4);
            chunk = _t13;
            if(_t13 != 0) {
                caml_gc_sweep_hp = _t13;
                _t11 = _t13 +  *(_t13 - 8);
                limit = _t13 +  *(_t13 - 8);
                goto L14;
            }
            caml_stat_major_collections = caml_stat_major_collections + 1;
            caml_gc_phase = 2;
            return;
        } else {
            _t18 = _t15;
            _t11 =  *_t15;
            _t21 = _t11 >> 10;
            __esi = __esi +  !_t21;
            caml_gc_sweep_hp = _t15 + 4 + _t21 * 4;
            _t24 = _t11 & 768;
            if(_t24 == 0) {
                if(_t11 == 255) {
                    _t11 =  *(_t15[1] + 4);
                    if(_t11 != 0) {
                         *__esp =  &(_t18[1]);
                         *_t11();
                    }
                }
                caml_fl_merge_block( &(_t15[1]));
                caml_gc_sweep_hp = _t11;
            } else {
                if(_t24 != 512) {
                     *_t15 = _t13 +  *(_t13 - 8);
                } else {
                    caml_fl_merge =  &(_t15[1]);
                }
            }
        }
L14:
    } while(__esi > 0);
    goto L15;
}

caml_finish_major_cycle(
    _unknown_ __fp0                        // r28
)
{// addr = 0x0805E9D1
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _t3;                          // _t3

    if(caml_gc_phase == 2) {
        start_cycle();
    }
    while(caml_gc_phase == 0) {
        mark_slice(2147483647);
    }
    while(caml_gc_phase == 1) {
        sweep_slice(2147483647);
    }
    _t3 = caml_allocated_words;
    _v20 = _t3;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    caml_stat_major_words = __fp0 + caml_stat_major_words;
    caml_allocated_words = 0;
    return _t3;
}

caml_major_collection_slice(
    signed int __fp0,                      // r28
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805EA48
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    _unknown_ _v38;                        // _cfa_ffffffda
    short _v40;                            // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    signed int _v52;                       // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    intOrPtr _t87;                         // _t87
    intOrPtr _t88;                         // _t88
    unsigned int _t93;                     // _t93
    unsigned int _t96;                     // _t96
    intOrPtr _t105;                        // _t105
    signed long long _t116;                // _t116
    signed long long _t118;                // _t118
    signed long long _t122;                // _t122
    signed long long _t125;                // _t125
    signed long long _t126;                // _t126

    _t87 = _a4;
    if(caml_gc_phase == 2) {
        start_cycle();
    }
    _t56 = caml_allocated_words;
    _t93 = caml_percent_free;
    _v36 = _t93 + 100;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    _v36 = _t93;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    _v36 = caml_allocated_words;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    _v36 = caml_stat_heap_size >> 2;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    asm("fdivp st1, st0");
    _t116 = __fp0 *  *134658988 * st2 / st1 *  *134658992;
    _v52 = _t116;
    _t96 = caml_dependent_size;
    if(_t96 != 0) {
        _v36 = caml_dependent_allocated;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        asm("fmulp st2, st0");
        _v36 = _t96;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        asm("fdivp st2, st0");
        asm("fdivp st1, st0");
    } else {
        st0 = _t116;
        st0 = _t116;
        asm("fldz");
    }
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    asm("fcmovbe st0, st1");
    st1 = _v52;
    _t118 = caml_extra_heap_resources;
    asm("fucomi st0, st1");
    asm("fcmovbe st0, st1");
    st1 = _t118;
    _v52 = _t118;
    caml_gc_message(64, "allocated_words = %lu\n", _t56);
    asm("fnstcw word [ebp-0x22]");
    _v40 = 12;
    asm("fldcw word [ebp-0x24]");
    asm("fistp qword [ebp-0x20]");
    asm("fldcw word [ebp-0x22]");
    caml_gc_message(64, "extra_heap_resources = %luu\n", _v36);
    _t122 =  *134658000 * _v52;
    asm("fnstcw word [ebp-0x22]");
    _v40 = 12;
    asm("fldcw word [ebp-0x24]");
    asm("fistp qword [ebp-0x20]");
    asm("fldcw word [ebp-0x22]");
    caml_gc_message(64, "amount of work to do = %luu\n", _v36);
    if(caml_gc_phase != 0) {
        _v36 = caml_stat_heap_size >> 2;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        _t125 = _t122 * _v52 *  *134659000 /  *134658988;
        asm("fnstcw word [ebp-0x22]");
        _v40 = 12;
        asm("fldcw word [ebp-0x24]");
        asm("fistp dword [ebp-0x28]");
        asm("fldcw word [ebp-0x22]");
        _t105 = _v44;
    } else {
        _v36 = caml_stat_heap_size >> 2;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        _t125 = _t122 * _v52 *  *134658996;
        _v36 = caml_percent_free + 100;
        _v32 = 0;
        asm("fild qword [ebp-0x20]");
        asm("fdivp st1, st0");
        asm("fnstcw word [ebp-0x22]");
        _v40 = 12;
        asm("fldcw word [ebp-0x24]");
        asm("fistp dword [ebp-0x28]");
        asm("fldcw word [ebp-0x22]");
        _t105 = _v44;
    }
    caml_gc_message(64, "ordered work = %ld words\n", _t87);
    caml_gc_message(64, "computed work = %ld words\n", _t105);
    _t88 = _t87 == 0 ? _t105 : _t87;
    if(caml_gc_phase != 0) {
        sweep_slice(_t88);
        caml_gc_message(2, 134658983, 0);
    } else {
        mark_slice(_t88);
        caml_gc_message(2, L"!$", 0);
    }
    if(caml_gc_phase == 2) {
        caml_compact_heap_maybe(_t125);
    }
    _v36 = caml_allocated_words;
    _v32 = 0;
    asm("fild qword [ebp-0x20]");
    _t126 = _t125 + caml_stat_major_words;
    caml_stat_major_words = _t126;
    caml_allocated_words = 0;
    caml_dependent_allocated = 0;
    asm("fldz");
    caml_extra_heap_resources = _t126;
    return _t105;
}

clear_table(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0805ED1C
    __eax = __eax;
     *((intOrPtr*)(__eax + 12)) =  *__eax;
     *((intOrPtr*)(__eax + 16)) =  *((intOrPtr*)(__eax + 8));
    return __eax;
}

intOrPtr caml_oldify_one(
    unsigned int _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805ED2C
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t32;                       // _t32
    unsigned int _t33;                     // _t33
    signed int _t37;                       // _t37
    intOrPtr _t39;                         // _t39
    _unknown_ _t40;                        // _t40
    _unknown_ _t41;                        // _t41
    unsigned int _t42;                     // _t42
    signed int _t43;                       // _t43
    unsigned int _t44;                     // _t44
    unsigned int _t45;                     // _t45
    signed int _t49;                       // _t49
    unsigned int _t50;                     // _t50
    signed int _t57;                       // _t57
    unsigned int _t58;                     // _t58
    unsigned int _t60;                     // _t60
    unsigned int _t61;                     // _t61
    unsigned int _t64;                     // _t64

    _t42 = _a4;
    __edi = _a8;
    while((_t42 & 1) == 0 && _t42 < caml_young_end && _t42 > caml_young_start) {
        _t60 = _t42;
        _t33 = _t42 - 4;
        _v32 = _t33;
        _t50 =  *_t33;
        if(_t50 == 0) {
            _t41 =  *_t42;
             *__edi = _t41;
            return _t41;
        }
        _t32 = _t50 & 255;
        if(_t32 > 248) {
            if(_t32 <= 250) {
                if(_t32 != 249) {
                    _t61 = _t42;
                    _t42 =  *_t42;
                    if((_t42 & 1) != 0) {
                        continue;
                    }
                    _t45 = _t42;
                    if(( *( *((intOrPtr*)((_t42 >> 23) * 4 +  &caml_page_table)) + (_t42 >> 12 & 2047)) & 7) == 0) {
L25:
                        _t32 = caml_alloc_shr(_t42, __edi, _t61, 1, 250);
                         *__edi = _t32;
                         *_v32 = 0;
                         *_t61 = _t32;
                        __edi = _t32;
                        continue;
                    }
                    _t49 = _t45 - 4;
                    _t37 = _t49;
                    if( *_t49 == 0) {
                        _t37 =  *_t42 - 4;
                    }
                    _t32 =  *_t37 & 255;
                    if(_t32 == 250 || _t32 == 246 || _t32 == 253) {
                        goto L25;
                    } else {
                        continue;
                    }
                }
                _t43 = (_t50 >> 10) * 4;
                _t39 = caml_oldify_one(_t60 - _t43, __edi);
                 *__edi =  *__edi + _t43;
                return _t39;
            }
            _v36 = _t50 >> 10;
            _t40 = caml_alloc_shr(_t42, __edi, _t60, _t50 >> 10, _t32);
            if(_v36 == 0) {
L15:
                 *_v32 = 0;
                 *_t42 = _t40;
                 *__edi = _t40;
                return _t40;
            }
            _t57 = 0;
            _v40 = _t42;
            _t44 = _v36;
            do {
                 *((intOrPtr*)(_t40 + _t57 * 4)) =  *((intOrPtr*)(_t60 + _t57 * 4));
                _t57 = _t57 + 1;
            } while(_t44 > _t57);
            _t42 = _v40;
            goto L15;
        } else {
            _t64 = _t50 >> 10;
            _t32 = caml_alloc_shr(_t42, __edi, _t64, _t64, _t32);
             *__edi = _t32;
            _t58 =  *_t42;
             *_v32 = 0;
             *_t42 = _t32;
            if(_t64 > 1) {
                 *_t32 = _t58;
                 *(_t32 + 4) = oldify_todo_list;
                oldify_todo_list = _t42;
                return _t32;
            }
            __edi = _t32;
            _t42 = _t58;
            continue;
        }
    }
     *__edi = _t42;
    return _t32;
}

unsigned int caml_oldify_mopup(
    unsigned int __eax                     // r0
)
{// addr = 0x0805EEBB
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    signed char** __edi;                   // r4
    signed char* __esi;                    // r5
    unsigned int _t15;                     // _t15
    signed char _t17;                      // _t17
    signed char _t19;                      // _t19
    signed char* _t23;                     // _t23
    unsigned int* _t24;                    // _t24

    _t15 = __eax;
    while(1) {
        __edi = oldify_todo_list;
        if(__edi == 0) {
            break;
        }
        _t23 =  *__edi;
        __esi =  &(_t23[4]);
        oldify_todo_list =  *__esi;
        _t17 =  *_t23;
        if((_t17 & 1) == 0 && _t17 < caml_young_end) {
            if(_t17 > caml_young_start) {
                caml_oldify_one(_t17, _t23);
            }
        }
        _t24 = _t23 - 4;
        _t15 =  *_t24 >> 10;
        if(_t15 <= 1) {
            continue;
        }
        _v32 = 1;
        do {
            _t19 = __edi[_v32];
            if((_t19 & 1) != 0 || _t19 >= caml_young_end || _t19 <= caml_young_start) {
                 *__esi = _t19;
            } else {
                caml_oldify_one(_t19, __esi);
            }
            _v32 = _v32 + 1;
            __esi =  &(__esi[4]);
            _t15 =  *_t24 >> 10;
        } while(_t15 > _v32);
    }
    return _t15;
}

caml_empty_minor_heap(
    _unknown_ __fp0                        // r28
)
{// addr = 0x0805EF59
    intOrPtr _v16;                         // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    unsigned int _t15;                     // _t15
    signed char** _t17;                    // _t17
    intOrPtr _t18;                         // _t18
    intOrPtr _t19;                         // _t19
    intOrPtr* _t28;                        // _t28
    signed char* _t33;                     // _t33
    signed char _t38;                      // _t38

    if(caml_young_ptr == caml_young_end) {
L14:
        return caml_final_empty_young();
    }
    caml_in_minor_collection = 1;
    caml_gc_message(2, 134659004, 0);
    _t15 = caml_oldify_local_roots();
    _t28 = caml_ref_table;
    if(_t28 >=  *134707432) {
L4:
        caml_oldify_mopup(_t15);
        _t17 = caml_weak_ref_table;
        if(_t17 >=  *134707460) {
L13:
            _t18 = caml_young_start;
            _t35 = caml_young_ptr - _t18 < 0 ? _t18 : caml_young_ptr;
            _t19 = caml_young_end;
            _t31 = _t19 - (caml_young_ptr - _t18 < 0 ? _t18 : caml_young_ptr);
            _t36 = _t19 - (caml_young_ptr - _t18 < 0 ? _t18 : caml_young_ptr);
            _t37 = _t19 - (caml_young_ptr - _t18 < 0 ? _t18 : caml_young_ptr) >> 2;
            _v20 = _t19 - (caml_young_ptr - _t18 < 0 ? _t18 : caml_young_ptr) >> 2;
            _v16 = 0;
            asm("fild qword [ebp-0x10]");
            caml_stat_minor_words = __fp0 + caml_stat_minor_words;
            caml_young_ptr = _t19;
            caml_young_limit = caml_young_start;
            clear_table( &caml_ref_table);
            clear_table( &caml_weak_ref_table);
            caml_gc_message(2, 134660647, 0);
            caml_in_minor_collection = 0;
            goto L14;
        } else {
            do {
                _t33 =  *_t17;
                _t38 =  *_t33;
                if((_t38 & 1) == 0 && _t38 < caml_young_end && _t38 > caml_young_start) {
                    if( *(_t38 - 4) != 0) {
                         *_t33 = caml_weak_none;
                    } else {
                         *_t33 =  *_t38;
                    }
                }
                _t17 =  &(_t17[1]);
            } while( *134707460 > _t17);
            goto L13;
        }
    } else {
        do {
            _t15 = caml_oldify_one( *((intOrPtr*)( *_t28)), _t26);
            _t28 = _t28 + 4;
        } while( *134707432 > _t28);
        goto L4;
    }
}

caml_minor_collection(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    _unknown_ __fp0                        // r28
)
{// addr = 0x0805F0A3
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec

    _v12 = __ebx;
    _v8 = __esi;
    caml_empty_minor_heap(__fp0);
    _v20 = caml_allocated_words - caml_allocated_words;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    _t20 = __fp0 + caml_stat_promoted_words;
    caml_stat_promoted_words = __fp0 + caml_stat_promoted_words;
    caml_stat_minor_collections = caml_stat_minor_collections + 1;
    caml_major_collection_slice(__fp0 + caml_stat_promoted_words, 0);
    caml_force_major_slice = 0;
    caml_final_do_calls();
    return caml_empty_minor_heap(_t20);
}

caml_check_urgent_gc(
    char _a4                               // _cfa_4
)
{// addr = 0x0805F10C
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    char* __ebx;                           // r1

    __ebx = caml_local_roots;
    caml_local_roots =  &_v44;
    if(caml_force_major_slice != 0) {
        _v44 = __ebx;
        _v36 = 1;
        _v40 = 1;
        _v32 =  &_a4;
        caml_minor_collection(__ebx, __esi, __fp0);
    }
    caml_local_roots = __ebx;
    return _a4;
}

reset_table(
    intOrPtr* __eax                        // r0
)
{// addr = 0x0805F155
    intOrPtr _t8;                          // _t8

     *((intOrPtr*)(__eax + 20)) = 0;
     *((intOrPtr*)(__eax + 24)) = 0;
    _t8 =  *__eax;
    if(_t8 != 0) {
        _t8 = caml_stat_free(_t8);
    }
     *((intOrPtr*)(__eax + 4)) = 0;
     *((intOrPtr*)(__eax + 16)) = 0;
     *((intOrPtr*)(__eax + 8)) = 0;
     *((intOrPtr*)(__eax + 12)) = 0;
     *__eax = 0;
    return _t8;
}

caml_set_minor_heap_size(
    _unknown_ __fp0,                       // r28
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F1A2
    char _v32;                             // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    _unknown_ __esi;                       // r5
    intOrPtr _t13;                         // _t13
    intOrPtr _t15;                         // _t15
    intOrPtr _t25;                         // _t25
    intOrPtr _t26;                         // _t26
    intOrPtr _t27;                         // _t27
    intOrPtr _t28;                         // _t28

    __fp0 = __fp0;
    __edi = _a4;
    if(caml_young_ptr != caml_young_end) {
        caml_minor_collection(_t25, _t27, __fp0);
    }
    _t13 = caml_aligned_malloc(__edi, 0,  &_v32);
    _t26 = _t13;
    if(_t13 == 0) {
        _t13 = caml_raise_out_of_memory();
    }
    _t28 = _t13 + __edi;
    if(caml_page_table_add(2, _t13, _t28) != 0) {
        caml_raise_out_of_memory();
    }
    _t15 = caml_young_start;
    if(_t15 != 0) {
        caml_page_table_remove(2, _t15, caml_young_end);
         *__esp = caml_young_base;
        free();
    }
    caml_young_base = _v32;
    caml_young_start = _t26;
    caml_young_end = _t28;
    caml_young_limit = _t26;
    caml_young_ptr = _t28;
    caml_minor_heap_size = __edi;
    reset_table( &caml_ref_table);
    return reset_table( &caml_weak_ref_table);
}

caml_alloc_table(
    intOrPtr* _a4,                         // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805F274
    intOrPtr* __ebx;                       // r1
    intOrPtr __esi;                        // r5
    signed int _t22;                       // _t22
    intOrPtr _t24;                         // _t24
    intOrPtr _t27;                         // _t27

    __ebx = _a4;
    _t17 = _a8;
    _t26 = _a12;
     *(__ebx + 20) = _a8;
    __ebx[6] = _a12;
    __esi = caml_stat_alloc(_t26 + _t17 << 2, _t26 + _t17 << 2);
    _t21 =  *__ebx;
    if( *__ebx != 0) {
        caml_stat_free(_t21);
    }
     *__ebx = __esi;
    __ebx[3] = __esi;
    _t22 =  *(__ebx + 20);
    _t27 = __esi + _t22 * 4;
    __ebx[2] = _t27;
    __ebx[4] = _t27;
    _t24 = __esi + (_t22 + __ebx[6]) * 4;
    __ebx[1] = _t24;
    return _t24;
}

caml_realloc_ref_table(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0805F2CA
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    signed int _v56;                       // _cfa_ffffffc8 (outparam)
    signed int _t43;                       // _t43
    intOrPtr _t44;                         // _t44
    intOrPtr* _t50;                        // _t50
    signed int _t52;                       // _t52
    intOrPtr _t58;                         // _t58
    intOrPtr _t60;                         // _t60
    signed int _t66;                       // _t66
    signed int _t68;                       // _t68

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t50 = _a4;
    _t60 =  *_t50;
    if(_t60 != 0) {
        if(_t50[4] != _t50[2]) {
            _v32 = _t50[3];
            _t66 =  *(_t50 + 20) +  *(_t50 + 20);
             *(_t50 + 20) = _t66;
            _t68 = _t66 + _t50[6] << 2;
            _t40 = _t68 >= 0 ? _t68 : _t68 + 1023;
            _t41 = (_t68 >= 0 ? _t68 : _t68 + 1023) >> 10;
            caml_gc_message(8, "Growing ref_table to %ldk bytes\n", (_t68 >= 0 ? _t68 : _t68 + 1023) >> 10);
            _v56 = _t68;
            _t43 =  *_t50;
             *__esp = _t43;
            realloc();
             *_t50 = _t43;
            if(_t43 == 0) {
                _t43 = caml_fatal_error("Fatal error: ref_table overflow\n");
            }
            _t52 =  *(_t50 + 20);
            _t58 = _t43 + (_t50[6] + _t52) * 4;
            _t50[1] = _t58;
            _t50[2] = _t43 + _t52 * 4;
            _t44 = _t43 + (_v32 - _t60 & -4);
            _t50[3] = _t44;
            _t50[4] = _t58;
        } else {
            caml_gc_message(8, "ref_table threshold crossed\n", 0);
            _t50[4] = _t50[1];
            _t44 = caml_urge_major_slice();
        }
    } else {
        _t44 = caml_alloc_table(_t50, caml_minor_heap_size >> 5, 256);
    }
    return _t44;
}

signed int caml_page_table_initialize()
{// addr = 0x0805F3D0
    signed int _t3;                        // _t3

    _t3 = 0;
    do {
         *((intOrPtr*)( &caml_page_table + _t3 * 4)) =  &caml_page_table_empty;
        _t3 = _t3 + 1;
    } while(_t3 != 512);
    return 0;
}

caml_allocation_color(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F3F4
    intOrPtr _t2;                          // _t2

    _t2 = caml_gc_phase;
    if(_t2 == 0 || _t2 == 1 && _a4 >= caml_gc_sweep_hp) {
        return 768;
    }
    return 0;
}

unsigned int caml_alloc_dependent_memory(
    unsigned int _a4                       // _cfa_4
)
{// addr = 0x0805F41E
    unsigned int _t3;                      // _t3

    _t3 = _a4 >> 2;
    caml_dependent_size = caml_dependent_size + _t3;
    caml_dependent_allocated = caml_dependent_allocated + _t3;
    return _t3;
}

unsigned int caml_free_dependent_memory(
    unsigned int _a4                       // _cfa_4
)
{// addr = 0x0805F435
    unsigned int _t3;                      // _t3
    unsigned int _t4;                      // _t4

    _t3 = _a4 >> 2;
    _t4 = caml_dependent_size;
    if(_t3 <= _t4) {
        caml_dependent_size = _t4 - _t3;
        return _t3;
    }
    caml_dependent_size = 0;
    return _t3;
}

caml_stat_resize(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805F45E
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t5;                          // _t5

    _v24 = _a8;
    _t5 = _a4;
     *__esp = _t5;
    realloc();
    if(_t5 == 0) {
        return caml_raise_out_of_memory();
    }
    return _t5;
}

caml_stat_free(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F481
    __eax = _a4;
     *__esp = __eax;
    free();
    return __eax;
}

caml_free_for_heap(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F494
    intOrPtr _t4;                          // _t4

    _t4 =  *((intOrPtr*)(_a4 - 16));
     *__esp = _t4;
    free();
    return _t4;
}

caml_stat_alloc(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F4AA
    intOrPtr __ebx;                        // r1

    __ebx = _a4;
     *__esp = __ebx;
    malloc();
    if(__eax != 0 || __ebx == 0) {
        return __eax;
    } else {
        return caml_raise_out_of_memory();
    }
}

signed int caml_modify(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    unsigned int _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805F4CF
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _t21;                       // _t21
    unsigned int _t25;                     // _t25
    intOrPtr _t30;                         // _t30
    unsigned int* _t31;                    // _t31
    signed int _t34;                       // _t34
    signed int _t37;                       // _t37

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t25 = _a4;
    _t37 = _a8;
    _t34 =  *_t25;
     *_t25 = _t37;
    _t21 = _t25 >> 12 & 2047;
    if(( *( *((intOrPtr*)((_t25 >> 23) * 4 +  &caml_page_table)) + _t21) & 1) != 0) {
        if(caml_gc_phase == 0) {
            _v40 = 0;
            _t21 = caml_darken(_t34);
        }
        if((_t37 & 1) == 0) {
            _t21 = caml_young_end;
            if(_t37 < _t21) {
                _t30 = caml_young_start;
                if(_t37 > _t30 && ((_t34 & 1) != 0 || _t21 <= _t34 || _t30 >= _t34)) {
                    if( *134707432 >=  *134707436) {
                        caml_realloc_ref_table(_t25, _t34, _t37,  &caml_ref_table);
                    }
                    _t21 = 134707432;
                    _t31 =  *134707432;
                     *_t31 = _t25;
                     *134707432 =  &(_t31[1]);
                }
            }
        }
    }
    return _t21;
}

signed int caml_initialize(
    unsigned int _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805F57C
    unsigned int __ebx;                    // r1
    signed int _t9;                        // _t9
    unsigned int* _t18;                    // _t18

    __ebx = _a4;
    _t9 = _a8;
     *__ebx = _t9;
    if((_t9 & 1) != 0 || _t9 >= caml_young_end || _t9 <= caml_young_start) {
L7:
        return _t9;
    } else {
        _t9 = __ebx >> 12 & 2047;
        if(( *( *((intOrPtr*)((__ebx >> 23) * 4 +  &caml_page_table)) + _t9) & 1) == 0) {
            goto L7;
        }
        if( *134707432 >=  *134707436) {
            caml_realloc_ref_table(__ebx, __edi, __esi,  &caml_ref_table);
        }
        _t18 =  *134707432;
         *_t18 = __ebx;
         *134707432 =  &(_t18[1]);
        return 134707432;
    }
}

unsigned int caml_adjust_gc_speed(
    _unknown_ __fp0,                       // r28
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805F5E8
    intOrPtr _v16;                         // _cfa_fffffff0
    unsigned int _v20;                     // _cfa_ffffffec
    unsigned int _t14;                     // _t14
    unsigned int _t18;                     // _t18
    intOrPtr _t23;                         // _t23
    _unknown_ _t29;                        // _t29
    long long _t32;                        // _t32

    _t23 = _a4;
    _t14 = _a8 == 0 ? 1 : _a8;
    _t29 = _t14 - _t23;
    _t24 = _t29 <= 0 ? _t14 : _t23;
    _v20 = _t29 <= 0 ? _t14 : _t23;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    _v20 = _t14;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    asm("fdivp st1, st0");
    _t32 = __fp0 + caml_extra_heap_resources;
    asm("fst qword [0x807b4a0]");
    asm("fld1");
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    st0 = _t32;
    if(_t29 > 0) {
        asm("fld1");
        caml_extra_heap_resources = _t32;
        caml_urge_major_slice();
    }
    _v20 = caml_minor_heap_size >> 2;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    _t18 = caml_stat_heap_size >> 2;
    _v20 = _t18;
    _v16 = 0;
    asm("fild qword [ebp-0x10]");
    asm("fdivp st1, st0");
    asm("fucomip st0, st1");
    st0 = caml_extra_heap_resources;
    if(_t18 > 0) {
        return caml_urge_major_slice();
    }
    return _t18;
}

caml_alloc_for_heap(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805F68B
    char _v16;                             // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    intOrPtr __ebx;                        // r1
    _unknown_ _t11;                        // _t11
    _unknown_ _t12;                        // _t12

    __ebx = _a4;
    _t11 = caml_aligned_malloc(__ebx + 16, 16,  &_v16);
    if(_t11 != 0) {
        _t12 = _t11 + 16;
        __edx = _t12 - 16;
        __edx[2] = __ebx;
         *__edx = _v16;
        return _t12;
    }
    return _t11;
}

caml_page_table_modify(
    unsigned int __eax,                    // r0
    intOrPtr __ebx,                        // r1
    signed int __ecx,                      // r2
    signed int __edx,                      // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0805F6C7
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ _t21;                        // _t21
    signed int _t35;                       // _t35

    __ecx = __ecx;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v32 = __ecx;
    _t35 = __eax >> 23;
    if( *((intOrPtr*)(_t35 * 4 +  &caml_page_table)) !=  &caml_page_table_empty) {
L3:
         *((__eax >> 12 & 2047) +  *((intOrPtr*)(_t35 * 4 +  &caml_page_table))) =  !__edx &  *((__eax >> 12 & 2047) +  *((intOrPtr*)(_t35 * 4 +  &caml_page_table))) | _v32;
        _t21 = 0;
    } else {
        _v56 = 1;
         *__esp = 2048;
        calloc();
        _t21 = -1;
        if(__eax != 0) {
             *((intOrPtr*)(_t35 * 4 +  &caml_page_table)) = __eax;
            goto L3;
        }
    }
    return _t21;
}

caml_page_table_remove(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805F742
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t9;                        // _t9
    signed int _t12;                       // _t12

    __edi = _a4;
    _t9 = _a8 & -4096;
    _t12 = _a12 - 1 & -4096;
    if(_t9 > _t12) {
L4:
        return 0;
    } else {
        goto L1;
    }
    while(1) {
L1:
        __ecx = 0;
        __edx = __edi;
        if(caml_page_table_modify(_t9, _t9, 0, __edi, __edi, _t12) != 0) {
            break;
        }
        _t9 = _t9 + 4096;
        if(_t12 >= _t9) {
            continue;
        }
        goto L4;
    }
    return -1;
}

caml_shrink_heap(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805F797
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int __ebx;                      // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t12;                        // _t12
    signed int* _t17;                      // _t17

    __ebx = _a4;
    if(__ebx != caml_heap_start) {
        __esi = __ebx - 16;
        _t14 = caml_stat_heap_size -  *((intOrPtr*)(__esi + 8));
        caml_stat_heap_size = caml_stat_heap_size -  *((intOrPtr*)(__esi + 8));
        caml_gc_message(4, "Shrinking heap to %luk bytes\n", _t14 >> 10);
        caml_stat_heap_chunks = caml_stat_heap_chunks - 1;
        _t17 = caml_heap_start;
        __edx =  &caml_heap_start;
        if(__ebx == _t17) {
L3:
             *__edx =  *((intOrPtr*)(__esi + 12));
            caml_page_table_remove(1, __ebx, __ebx +  *((intOrPtr*)(__esi + 8)));
            return caml_free_for_heap(__ebx);
        } else {
            goto L2;
        }
        do {
L2:
            __edx = _t17 - 4;
            _t17 =  *((intOrPtr*)(_t17 - 4));
        } while(__ebx != _t17);
        goto L3;
    }
    return _t12;
}

caml_page_table_add(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0805F821
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t9;                        // _t9
    signed int _t12;                       // _t12

    __edi = _a4;
    _t9 = _a8 & -4096;
    _t12 = _a12 - 1 & -4096;
    if(_t9 > _t12) {
L4:
        return 0;
    } else {
        goto L1;
    }
    while(1) {
L1:
        __ecx = __edi;
        __edx = 0;
        if(caml_page_table_modify(_t9, _t9, __edi, 0, __edi, _t12) != 0) {
            break;
        }
        _t9 = _t9 + 4096;
        if(_t12 >= _t9) {
            continue;
        }
        goto L4;
    }
    return -1;
}

caml_add_to_heap(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805F876
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int __ebx;                      // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t19;                        // _t19
    signed int* _t21;                      // _t21
    intOrPtr* _t23;                        // _t23
    unsigned int _t25;                     // _t25

    __ebx = _a4;
    __esi = __ebx - 16;
    caml_gc_message(4, "Growing heap to %luk bytes\n", caml_stat_heap_size +  *((intOrPtr*)(__esi + 8)) >> 10);
    _t19 = caml_page_table_add(1, __ebx, __ebx +  *((intOrPtr*)(__esi + 8)));
    _t20 = -1;
    if(_t19 != 0) {
L8:
        return _t20;
    }
    _t21 = caml_heap_start;
    if(_t21 == 0 || __ebx <= _t21) {
        _t23 =  &caml_heap_start;
L6:
         *((intOrPtr*)(__esi + 12)) = _t21;
         *_t23 = __ebx;
        caml_stat_heap_chunks = caml_stat_heap_chunks + 1;
        _t25 = caml_stat_heap_size +  *((intOrPtr*)(__esi + 8));
        caml_stat_heap_size = _t25;
        _t20 = 0;
        if(_t25 <= caml_stat_top_heap_size) {
            goto L8;
        }
        caml_stat_top_heap_size = _t25;
        return 0;
    } else {
        do {
            _t23 = _t21 - 4;
            _t21 =  *((intOrPtr*)(_t21 - 4));
        } while(_t21 != 0 && __ebx > _t21);
        goto L6;
    }
}

caml_alloc_shr(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805F922
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _t28;                       // _t28
    intOrPtr _t29;                         // _t29
    intOrPtr _t34;                         // _t34
    intOrPtr* _t45;                        // _t45
    signed int _t55;                       // _t55
    unsigned int _t57;                     // _t57
    intOrPtr* _t58;                        // _t58
    intOrPtr* _t59;                        // _t59
    signed int _t69;                       // _t69
    intOrPtr _t70;                         // _t70
    signed int _t77;                       // _t77
    signed int _t79;                       // _t79

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t79 = _a4;
    if(_t79 > 4194303) {
        caml_raise_out_of_memory();
    }
    _t28 = caml_fl_allocate(_t79);
    _t55 = _t28;
    if(_t28 != 0) {
L21:
        _t29 = caml_gc_phase;
        if(_t29 == 0 || _t29 == 1 && _t55 >= caml_gc_sweep_hp) {
             *_t55 = _a8 + (_t79 << 10) + 768;
        } else {
             *_t55 = (_t79 << 10) + _a8;
        }
        _t34 = _t79 + caml_allocated_words + 1;
        caml_allocated_words = _t34;
        if(_t34 > caml_minor_heap_size >> 2) {
            caml_urge_major_slice();
        }
        return _t55 + 4;
    }
    _t57 = caml_round_heap_chunk_size(_t79 + (_t79 * 1374389535 >> 32 >> 5) * caml_percent_free + 1 << 2);
    _t45 = caml_alloc_for_heap(_t44);
    _t77 = _t45;
    if(_t45 == 0) {
        caml_gc_message(4, "No room for growing heap\n", 0);
L17:
        if(caml_in_minor_collection != 0) {
            caml_fatal_error("Fatal error: out of memory.\n");
        }
        caml_raise_out_of_memory();
L20:
        caml_fl_add_blocks(_t77);
        _t55 = caml_fl_allocate(_t79);
        goto L21;
    }
    _t69 = (_t57 >> 2) - 1;
    _t58 = _t45;
    if(_t69 > 4194303) {
        while(1) {
             *_t45 = -512;
            _t45 = _t45 + 16777216;
            _t57 = _t57 - 16777216;
            _t70 = _t45 + 4;
            _t58[1] = _t70;
             *((intOrPtr*)(_t77 + 8)) = _t70;
            _t69 = (_t57 >> 2) - 1;
            if(_t69 <= 4194303) {
                break;
            }
            _t58 = _t45;
        }
        _t58 = _t45;
        goto L10;
    } else {
L10:
        if(_t57 <= 1) {
            _t58[1] = 0;
            if(_t57 == 1) {
                 *_t45 = 0;
            }
        } else {
             *_t45 = (_t69 << 10) + 512;
            _t59 = _t58 + 4;
             *((intOrPtr*)(_t77 + 8)) = _t59;
             *_t59 = 0;
        }
        if(caml_add_to_heap(_t77) == 0) {
            if(_t77 != 0) {
                goto L20;
            }
        } else {
            caml_free_for_heap(_t77);
        }
        goto L17;
    }
}

signed int caml_convert_flag_list(
    signed int* _a4,                       // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805FAC4
    intOrPtr __ebx;                        // r1

    __edx = _a4;
    __ebx = _a8;
    __eax = 0;
    while(__edx != 1) {
        __eax = __eax |  *(__ebx + ( *__edx >> 1) * 4);
        __edx = __edx[1];
    }
    return __eax;
}

caml_update_dummy(
    unsigned int _a4,                      // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805FAEA
    unsigned int _v32;                     // _cfa_ffffffe0
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    signed int __ebx;                      // r1
    intOrPtr __edi;                        // r4
    unsigned int __esi;                    // r5
    unsigned int* _t14;                    // _t14
    signed int _t16;                       // _t16
    unsigned int _t19;                     // _t19
    unsigned int _t20;                     // _t20
    signed int _t21;                       // _t21
    unsigned int _t23;                     // _t23

    __edi = _a8;
    _t14 = __edi - 4;
    _t19 =  *_t14;
    _t21 =  *_t14 & 255;
    __esi = _a4;
     *((char*)(__esi - 4)) = _t21;
    if(_t21 == 254) {
        _t23 =  *_t14 >> 11;
        if(_t23 != 0) {
            _t16 = 0;
            do {
                 *((long long*)(__esi + _t16 * 8)) =  *((long long*)(__edi + _t16 * 8));
                _t16 = _t16 + 1;
            } while(_t23 > _t16);
        }
    } else {
        _t20 = _t19 >> 10;
        _v32 = _t20;
        __ebx = 0;
        if(_t20 != 0) {
            do {
                caml_modify(__ebx, __edi, __esi, __esi,  *((intOrPtr*)(__edi + __ebx * 4)));
                __ebx = __ebx + 1;
                __esi = __esi + 4;
            } while(_v32 > __ebx);
        } else {
        }
    }
    return 1;
}

caml_alloc_final(
    _unknown_ __edi,                       // r4
    _unknown_ __fp0,                       // r28
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0805FB5E
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __fp0 = __fp0;
    __edi = __edi;
    return caml_alloc_custom(__edi, __fp0, caml_final_custom_operations(_a8), _a4 << 2, _a12, _a16);
}

caml_alloc_small(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    signed int _a4,                        // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0805FB91
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _t10;                         // _t10
    signed int _t19;                       // _t19
    signed int _t21;                       // _t21
    signed int _t24;                       // _t24

     *__esp = __ebx;
    _v8 = __esi;
    _t24 = _a4;
    _t21 = 4 + _t24 * 4;
    _t19 =  ~_t21;
    _t10 = _t19 + caml_young_ptr;
    caml_young_ptr = _t10;
    if(_t10 < caml_young_limit) {
        caml_young_ptr = _t10 + _t21;
        caml_minor_collection(_t19, _t24, __fp0);
        caml_young_ptr = caml_young_ptr + _t19;
    }
     *caml_young_ptr = _a8 + (_t24 << 10) + 768;
    return caml_young_ptr + 4;
}

caml_alloc_string(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    _unknown_ __fp0,                       // r28
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805FBFA
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    _unknown_ _t16;                        // _t16
    intOrPtr _t18;                         // _t18
    signed int _t25;                       // _t25
    signed int _t26;                       // _t26
    signed int _t31;                       // _t31
    signed int _t38;                       // _t38
    intOrPtr _t40;                         // _t40

    __fp0 = __fp0;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t40 = _a4;
    _t25 = _t40 + 4 >> 2;
    if(_t25 > 256) {
        _t16 = caml_check_urgent_gc(caml_alloc_shr(_t25, __edi, _t40, _t25, 252));
    } else {
        _t31 = 4 + _t25 * 4;
        _t38 =  ~_t31;
        _t18 = _t38 + caml_young_ptr;
        caml_young_ptr = _t18;
        if(_t18 < caml_young_limit) {
            caml_young_ptr = _t18 + _t31;
            caml_minor_collection(_t25, _t40, __fp0);
            caml_young_ptr = caml_young_ptr + _t38;
        }
         *caml_young_ptr = (_t25 << 10) + 1020;
        _t16 = caml_young_ptr + 4;
    }
    _t26 = _t25 << 2;
     *((intOrPtr*)(_t16 + _t26 - 4)) = 0;
     *((char*)(_t16 + _t26 - 1)) = _t26 - 1 - _t40;
    return _t16;
}

caml_copy_string(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805FCA4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v36;                       // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _t17;                       // _t17
    intOrPtr _t25;                         // _t25

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    asm("repne scasb");
    _t17 =  !-1 - 1;
    _t25 = caml_alloc_string(_t17, _a4, __esi, __fp0, _t17);
    _v36 = _t17;
    _v40 = _a4;
     *__esp = _t25;
    memmove();
    return _t25;
}

caml_alloc(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    _unknown_ __fp0,                       // r28
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0805FCF3
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8 (outparam)
    _unknown_ _t22;                        // _t22
    char _t23;                             // _t23
    intOrPtr _t25;                         // _t25
    signed int _t32;                       // _t32
    signed int _t35;                       // _t35
    signed int _t37;                       // _t37
    char _t40;                             // _t40
    signed int _t42;                       // _t42
    signed int _t44;                       // _t44

    __fp0 = __fp0;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t32 = _a4;
    _t44 = _a8;
    _t22 = 134721380 + _t44 * 4;
    if(_t32 != 0) {
        if(_t32 > 256) {
            _t23 = caml_alloc_shr(_t32, __edi, _t44, _t32, _t44);
            _t40 = _t23;
            if(_t44 <= 250) {
                _v36 = _t32 << 2;
                _v40 = 0;
                 *__esp = _t23;
                memset();
            }
            _t22 = caml_check_urgent_gc(_t40);
        } else {
            _t35 = 4 + _t32 * 4;
            _t42 =  ~_t35;
            _t25 = _t42 + caml_young_ptr;
            caml_young_ptr = _t25;
            if(_t25 < caml_young_limit) {
                caml_young_ptr = _t25 + _t35;
                caml_minor_collection(_t32, _t44, __fp0);
                caml_young_ptr = caml_young_ptr + _t42;
            }
             *caml_young_ptr = _t44 + (_t32 << 10) + 768;
            __ecx = caml_young_ptr;
            _t22 = __ecx + 4;
            if(_t44 <= 250) {
                _t37 = 0;
                do {
                     *(__ecx + 4 + _t37 * 4) = 0;
                    _t37 = _t37 + 1;
                } while(_t37 != _t32);
            }
        }
    }
    return _t22;
}

caml_alloc_dummy_float(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805FDCD
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _t6 = _a4 & -2;
    if((_a4 & -2) != 0) {
        return caml_alloc(__ebx, __edi, __esi, __fp0, _t6, 0);
    }
    return 134721380;
}

caml_alloc_dummy(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0805FDF2
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int _t6;                        // _t6

    _t6 = _a4 >> 1;
    if(__eflags != 0) {
        return caml_alloc(__ebx, __edi, __esi, __fp0, _t6, 0);
    }
    return 134721380;
}

signed int caml_alloc_array(
    intOrPtr _a4,                          // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x0805FE16
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    char _v68;                             // _cfa_ffffffbc
    char* _v80;                            // _cfa_ffffffb0
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    signed int __ebx;                      // r1
    _unknown_ __edi;                       // r4
    signed int* __esi;                     // r5
    _unknown_ _t25;                        // _t25
    signed int _t31;                       // _t31
    intOrPtr _t36;                         // _t36
    signed int _t37;                       // _t37

    __esi = _a8;
    _t25 = caml_local_roots;
    _v80 = _t25;
    _v32 = 0;
    _v36 = 0;
    _v68 = _t25;
    caml_local_roots =  &_v68;
    _v60 = 1;
    _v64 = 2;
    _v56 =  &_v32;
    _v52 =  &_v36;
    if( *__esi == 0) {
L4:
        caml_local_roots = _v80;
        return 134721380;
    }
    __ebx = 0;
    do {
        __ebx = __ebx + 1;
    } while(__esi[__ebx] != 0);
    if(__ebx != 0) {
        _v36 = caml_alloc(__ebx, _t36, __esi, __fp0, __ebx, 0);
        _t37 = 0;
        do {
            _t31 =  *__esi;
             *__esp = _t31;
            _a4();
            _v32 = _t31;
            caml_modify(__ebx, _t37, __esi, _t37 * 4 + _v36, _t31);
            _t37 = _t37 + 1;
            __esi =  &(__esi[1]);
        } while(_t37 < __ebx);
        caml_local_roots = _v80;
        return _v36;
    }
    goto L4;
}

caml_copy_string_array(
    signed int* _a4                        // _cfa_4
)
{// addr = 0x0805FEDA
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_alloc_array(caml_copy_string, _a4);
}

caml_alloc_tuple(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0805FEF5
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_alloc(__ebx, __edi, __esi, __fp0, _a4, 0);
}

compare_free_stack()
{// addr = 0x0805FF10
    __eax = compare_stack;
    if(__eax !=  &compare_stack_init) {
         *__esp = __eax;
        free();
        compare_stack =  &compare_stack_init;
        compare_stack_limit =  &locale_is_set.2848;
        return __eax;
    }
    return __eax;
}

signed int compare_stack_overflow(
    signed int __ecx                       // r2
)
{// addr = 0x0805FF40
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int _v36;                       // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v112;                      // _cfa_ffffff90
    signed int _v116;                      // _cfa_ffffff8c
    _unknown_ __ebx;                       // r1
    unsigned int* __edi;                   // r4
    signed int __esi;                      // r5
    signed int _t146;                      // _t146
    signed int _t148;                      // _t148
    signed int* _t149;                     // _t149
    signed int* _t151;                     // _t151
    signed int _t154;                      // _t154
    signed int _t155;                      // _t155
    unsigned int _t161;                    // _t161
    char* _t164;                           // _t164
    signed int _t170;                      // _t170
    signed int _t174;                      // _t174
    signed int _t175;                      // _t175
    signed int _t178;                      // _t178
    signed int _t179;                      // _t179
    signed int _t181;                      // _t181
    signed int _t187;                      // _t187
    signed int _t188;                      // _t188
    signed int _t192;                      // _t192
    signed int _t193;                      // _t193
    _unknown_ _t197;                       // _t197
    signed int _t198;                      // _t198
    intOrPtr _t204;                        // _t204
    unsigned int _t206;                    // _t206
    unsigned int _t209;                    // _t209
    signed int _t212;                      // _t212
    unsigned int _t214;                    // _t214
    intOrPtr _t216;                        // _t216
    signed int _t219;                      // _t219
    signed int _t221;                      // _t221
    signed int _t222;                      // _t222
    signed int _t229;                      // _t229
    unsigned int _t230;                    // _t230
    signed int _t232;                      // _t232
    intOrPtr _t237;                        // _t237
    intOrPtr _t240;                        // _t240
    signed int _t244;                      // _t244
    signed int _t250;                      // _t250
    signed int _t251;                      // _t251
    signed char _t252;                     // _t252
    signed int _t256;                      // _t256
    signed int _t257;                      // _t257
    signed int _t263;                      // _t263
    _unknown_ _t267;                       // _t267

    caml_gc_message(4, "Stack overflow in structural comparison\n", 0);
    compare_free_stack();
    _t146 = caml_raise_out_of_memory();
    _push(_t267);
    _push(_t263);
    _push(__esi);
    _push(_t197);
    __esp = __esp - 76;
    _v60 = _t146;
    _v64 = _t229;
    _v68 = __ecx;
    _t198 = compare_stack;
    while(1) {
        _t148 = _v36 == _v40;
        if(_t148 == 0 && _v44 != 0) {
        }
L105:
        __eflags = _t198 - compare_stack;
        if(_t198 != compare_stack) {
            _t149 =  *_t198;
            _v36 =  *_t149;
             *_t198 =  &(_t149[1]);
            _t151 =  *(_t198 + 4);
            _v40 =  *_t151;
             *(_t198 + 4) =  &(_t151[1]);
            _t154 =  *(_t198 + 8) - 1;
             *(_t198 + 8) = _t154;
            __eflags = _t154;
            _t198 = _t154 == 0 ? _t198 - 12 : _t198;
            while(1) {
                _t148 = _v36 == _v40;
                if(_t148 == 0 && _v44 != 0) {
                }
                goto L4;
            }
            goto L105;
        }
        _t155 = 0;
L121:
        __esp =  &(__esp[0x13]);
        _pop(__ebx);
        _pop(__esi);
        _pop(__edi);
        return _t155;
L4:
        if((_v36 & 1) == 0) {
            __eflags = _v40 & 1;
            if((_v40 & 1) == 0) {
                _t230 = _v36;
                _v48 = _t230;
                _t232 = _t230 >> 12 & 2047;
                _t204 =  *((intOrPtr*)((_t230 >> 23) * 4 +  &caml_page_table));
                __eflags =  *(_t204 + _t232) & 7;
                if(( *(_t204 + _t232) & 7) == 0) {
L31:
                    __eflags = _t148;
                    if(_t148 != 0) {
                        goto L105;
                    }
                    _t155 = (_v36 >> 1) - (_v40 >> 1);
                    goto L121;
                }
                _t214 = _v40;
                _v52 = _t214;
                _t250 = _v40 >> 12 & 2047;
                _t216 =  *((intOrPtr*)((_t214 >> 23) * 4 +  &caml_page_table));
                __eflags =  *(_t216 + _t250) & 7;
                if(( *(_t216 + _t250) & 7) != 0) {
                    _t263 = _v48 - 4;
                    __esi =  *_t263 & 255;
                    _t251 = __esi & 255;
                    _t219 = _v52 - 4;
                    _v56 = _t219;
                    _v60 =  *_t219 & 255;
                    __eflags = _t251 - 250;
                    if(_t251 != 250) {
                        _t221 = _v60 & 255;
                        __eflags = _t221 - 250;
                        if(_t221 != 250) {
                            __eflags = _t251 - _t221;
                            if(_t251 == _t221) {
                                _t252 = __esi + 9;
                                __eflags = _t252 - 8;
                                if(__eflags > 0) {
L88:
                                    _v60 =  *_t263 >> 10;
                                    _t161 =  *_v56 >> 10;
                                    __eflags = _v60 - _t161;
                                    if(_v60 == _t161) {
                                        __eflags = _v60;
                                        if(_v60 == 0) {
                                            goto L105;
                                        }
                                        __eflags = _v60 - 1;
                                        if(_v60 > 1) {
                                            _t198 = _t198 + 12;
                                            _t164 = compare_stack_limit;
                                            __eflags = _t198 - _t164;
                                            if(_t198 >= _t164) {
                                                _t256 = compare_stack;
                                                _v68 = _t256;
                                                _t174 = (_t164 - _t256 >> 2) * -1431655765 + (_t164 - _t256 >> 2) * -1431655765;
                                                _v64 = _t174;
                                                __eflags = _t174 - 1048575;
                                                if(_t174 > 1048575) {
                                                    compare_stack_overflow(_t221);
                                                }
                                                _t257 = compare_stack;
                                                __eflags = _t257 -  &compare_stack_init;
                                                if(_t257 !=  &compare_stack_init) {
                                                    _t175 = _v64 * 12;
                                                    _v116 = _t175;
                                                     *__esp = _t257;
                                                    realloc();
                                                    _v56 = _t175;
                                                    __eflags = _t175;
                                                    if(_t175 == 0) {
                                                        compare_stack_overflow(_t221);
                                                    }
                                                } else {
                                                    _t178 = _v64 * 12;
                                                     *__esp = _t178;
                                                    malloc();
                                                    _v56 = _t178;
                                                    __eflags = _t178;
                                                    if(_t178 == 0) {
                                                        compare_stack_overflow(_t221);
                                                    }
                                                    __esi =  &compare_stack_init;
                                                    _push(768 << 2);
                                                    _push( &compare_stack_init);
                                                    _push(_v56);
                                                    memcpy();
                                                    __esp =  &(__esp[3]);
                                                    _t263 =  &compare_stack_init + 0x600;
                                                }
                                                _t222 = _v56;
                                                compare_stack = _t222;
                                                compare_stack_limit = _v64 * 12 + _t222;
                                                _t198 = (_t198 - _v68 & -4) + _t222;
                                                __eflags = _t198;
                                            }
                                             *_t198 = _v48 + 4;
                                             *(_t198 + 4) = _v52 + 4;
                                            _t170 = _v60 - 1;
                                            __eflags = _t170;
                                             *(_t198 + 8) = _t170;
                                        }
                                        _v36 =  *_v36;
                                        _v40 =  *_v40;
                                        continue;
                                    }
                                    _t155 = _v60 - _t161;
                                    goto L121;
                                }
                                switch( *((intOrPtr*)((_t252 & 255) * 4 +  &M0806BCEC))) {
                                    case 0:
L76:
                                        compare_free_stack();
                                         *__esp = "equal: functional value";
                                        caml_invalid_argument();
                                        goto L77;
                                    case 1:
L77:
                                        __eax = _v48;
                                        __edx =  *(__eax + 4);
                                        __edx =  *(__eax + 4) >> 1;
                                        __ecx = _v52;
                                        __eax =  *(__ecx + 4);
                                        __eax =  *(__ecx + 4) >> 1;
                                        __eflags = __edx - __eax;
                                        if(__edx == __eax) {
                                            goto L105;
                                        }
                                        __eax = __edx;
                                        goto L121;
                                    case 2:
                                        goto L88;
                                    case 3:
                                        compare_free_stack();
                                         *__esp = "equal: abstract value";
                                        caml_invalid_argument();
                                        goto L76;
                                    case 4:
                                        __eflags = _t148;
                                        if(_t148 != 0) {
                                            goto L105;
                                        }
                                        caml_string_length(_v36);
                                        __esi = _t148;
                                        _t179 = _v40;
                                        caml_string_length(_t179);
                                        _t263 = _t179;
                                        __eflags = _t179 - __esi;
                                        _t181 = _t179 - __esi <= 0 ? _t263 : __esi;
                                        _v112 = _t181;
                                        _v116 = _v40;
                                         *__esp = _v36;
                                        memcmp();
                                        __eflags = _t181;
                                        if(_t181 < 0) {
                                            goto L114;
                                        }
                                        __eflags = _t181;
                                        if(_t181 > 0) {
                                            goto L120;
                                        }
                                        __eflags = __esi - _t263;
                                        if(__esi == _t263) {
                                            goto L105;
                                        }
                                        _t155 = __esi - _t263;
                                        goto L121;
                                    case 5:
                                        __eax = _v36;
                                        __fp0 =  *_v36;
                                        __edx = _v40;
                                        __fp0 =  *_v40;
                                        asm("fucomi st0, st1");
                                        if(__eflags > 0) {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L114;
                                        }
                                        asm("fxch st0, st1");
                                        asm("fucomi st0, st1");
                                        if(__eflags > 0) {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L120;
                                        }
                                        asm("fucomi st0, st1");
                                        if(__eflags != 0 || __eflags != 0) {
                                            __eflags = _v44;
                                            if(__eflags == 0) {
                                                st0 = __fp0;
                                                st0 = __fp0;
                                                goto L110;
                                            }
                                            asm("fucomip st0, st0");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fucomip st0, st0");
                                                if(__eflags != 0) {
                                                    goto L105;
                                                }
                                                if(__eflags != 0) {
                                                    goto L114;
                                                }
                                                goto L105;
                                            } else {
                                                st0 = __fp0;
                                                goto L120;
                                            }
                                        } else {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L105;
                                        }
                                    case 6:
                                        __edx =  *__edi;
                                        __edx =  *__edi >> 11;
                                        __ecx = _v56;
                                        __eax =  *__ecx;
                                        __eax =  *__ecx >> 11;
                                        __eflags = __edx - __eax;
                                        if(__edx != __eax) {
                                            __eax = __edx;
                                            goto L121;
                                        }
                                        __eflags = __edx;
                                        if(__eflags == 0) {
                                            goto L105;
                                        }
                                        __eax = _v48;
                                        __fp0 =  *_v48;
                                        __ecx = _v52;
                                        __fp0 =  *__ecx;
                                        asm("fucomi st0, st1");
                                        if(__eflags > 0) {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L114;
                                        }
                                        asm("fxch st0, st1");
                                        asm("fucomi st0, st1");
                                        if(__eflags > 0) {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L120;
                                        }
                                        __eax = 0;
                                        __esi = _v48;
                                        do {
                                            asm("fucomi st0, st1");
                                            if(__eflags != 0 || __eflags != 0) {
                                                __eflags = _v44;
                                                if(__eflags == 0) {
                                                    st0 = __fp0;
                                                    st0 = __fp0;
                                                    goto L110;
                                                }
                                                asm("fucomip st0, st0");
                                                if(__eflags != 0 || __eflags != 0) {
                                                    asm("fucomip st0, st0");
                                                    if(__eflags != 0) {
                                                        goto L73;
                                                    }
                                                    if(__eflags == 0) {
                                                        goto L114;
                                                    }
                                                    goto L73;
                                                } else {
                                                    st0 = __fp0;
                                                    goto L120;
                                                }
                                            } else {
                                                st0 = __fp0;
                                                st0 = __fp0;
L73:
                                                __eax = __eax + 1;
                                                __eflags = __edx - __eax;
                                                if(__eflags > 0) {
                                                    __fp0 =  *((long long*)(__esi + __eax * 8));
                                                    __fp0 =  *((long long*)(__ecx + __eax * 8));
                                                    asm("fucomi st0, st1");
                                                    if(__eflags > 0) {
                                                        st0 = __fp0;
                                                        st0 = __fp0;
                                                        goto L114;
                                                    }
                                                    goto L63;
                                                }
                                                goto L105;
                                            }
L63:
                                            asm("fxch st0, st1");
                                            asm("fucomi st0, st1");
                                        } while(__eflags <= 0);
                                        st0 = __fp0;
                                        st0 = __fp0;
                                        goto L120;
                                    case 7:
                                        __eax = _v36;
                                        __ecx =  *_v36;
                                        __edx = _v40;
                                        __eax =  *_v40;
                                        __edx =  *(__eax + 8);
                                        __eflags = __edx -  *((intOrPtr*)(__ecx + 8));
                                        if(__edx ==  *((intOrPtr*)(__ecx + 8))) {
                                            __eflags = __edx;
                                            if(__edx == 0) {
                                                compare_free_stack();
                                                 *__esp = "equal: abstract value";
                                                caml_invalid_argument();
                                            }
                                            caml_compare_unordered = 0;
                                            __ecx = _v40;
                                            _v116 = __ecx;
                                            __eax = _v36;
                                             *__esp = __eax;
                                             *__edx();
                                            __eflags = caml_compare_unordered;
                                            if(caml_compare_unordered == 0) {
L86:
                                                __eflags = __eax;
                                                if(__eax == 0) {
                                                    goto L105;
                                                }
                                                goto L121;
                                            } else {
                                                __eflags = _v44;
                                                if(_v44 == 0) {
L110:
                                                    _t155 = -2147483648;
                                                    goto L121;
                                                }
                                                goto L86;
                                            }
                                        }
                                        __edx =  *__ecx;
                                        __eax =  *__eax;
                                        _v116 = __eax;
                                         *__esp =  *__ecx;
                                        strcmp();
                                        __eflags = __eax;
                                        if(__eax >= 0) {
L120:
                                            _t155 = 1;
                                            goto L121;
                                        }
L114:
                                        _t155 = -1;
                                        goto L121;
                                }
                            }
                            _t155 = _t251 - _t221;
                            goto L121;
                        }
                        _v40 =  *_v40;
                        continue;
                    }
                    _v36 =  *_v36;
                    continue;
                }
                goto L31;
            }
            _t206 = _v36;
            _t187 = _t206 >> 12 & 2047;
            _t237 =  *((intOrPtr*)((_t206 >> 23) * 4 +  &caml_page_table));
            __eflags =  *(_t237 + _t187) & 7;
            if(( *(_t237 + _t187) & 7) == 0) {
                goto L120;
            }
            _t188 =  *(_t206 - 4) & 255;
            __eflags = _t188 - 250;
            if(_t188 == 250) {
L23:
                _v36 =  *_v36;
                continue;
            }
            __eflags = _t188 - 255;
            if(_t188 != 255) {
                goto L120;
            }
            _t244 = _v36;
            _t155 =  *( *_t244 + 24);
            __eflags = _t155;
            if(_t155 == 0) {
                goto L120;
            } else {
                caml_compare_unordered = 0;
                _v116 = _v40;
                 *__esp = _t244;
                 *_t155();
                __eflags = caml_compare_unordered;
                if(caml_compare_unordered == 0) {
L27:
                    __eflags = _t155;
                    if(_t155 == 0) {
                        goto L105;
                    }
                    goto L121;
                }
                __eflags = _v44;
                if(_v44 == 0) {
                    goto L110;
                }
                goto L27;
            }
            goto L23;
        }
        if(_t148 != 0) {
            goto L105;
        }
        if((_v40 & 1) == 0) {
            _t209 = _v40;
            _t192 = _t209 >> 12 & 2047;
            _t240 =  *((intOrPtr*)((_t209 >> 23) * 4 +  &caml_page_table));
            __eflags =  *(_t240 + _t192) & 7;
            if(( *(_t240 + _t192) & 7) == 0) {
                goto L114;
            }
            _t193 =  *(_t209 - 4) & 255;
            __eflags = _t193 - 250;
            if(_t193 == 250) {
                _v40 =  *_v40;
                continue;
            }
            __eflags = _t193 - 255;
            if(_t193 != 255) {
                goto L114;
            }
            _t212 = _v40;
            _t155 =  *( *_t212 + 24);
            __eflags = _t155;
            if(_t155 == 0) {
                goto L114;
            } else {
                caml_compare_unordered = 0;
                _v116 = _t212;
                 *__esp = _v36;
                 *_t155();
                __eflags = caml_compare_unordered;
                if(caml_compare_unordered == 0) {
L16:
                    __eflags = _t155;
                    if(_t155 == 0) {
                        goto L105;
                    }
                    goto L121;
                }
                __eflags = _v44;
                if(_v44 == 0) {
                    goto L110;
                }
                goto L16;
            }
        } else {
            _t155 = (_v36 >> 1) - (_v40 >> 1);
            goto L121;
        }
    }
}

signed int compare_val(
    signed int __eax,                      // r0
    signed int __ecx,                      // r2
    signed int __edx                       // r3
)
{// addr = 0x0805FF6C
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    unsigned int* __edi;                   // r4
    signed int __esi;                      // r5
    signed int _t144;                      // _t144
    signed int* _t145;                     // _t145
    unsigned int* _t147;                   // _t147
    signed int _t150;                      // _t150
    unsigned int _t158;                    // _t158
    char* _t161;                           // _t161
    signed int _t167;                      // _t167
    signed int _t171;                      // _t171
    signed int _t172;                      // _t172
    signed int _t175;                      // _t175
    unsigned int _t177;                    // _t177
    signed int _t179;                      // _t179
    signed int _t189;                      // _t189
    signed int _t190;                      // _t190
    signed int _t192;                      // _t192
    signed int _t196;                      // _t196
    signed int _t197;                      // _t197
    signed int _t199;                      // _t199
    signed int _t203;                      // _t203
    intOrPtr _t209;                        // _t209
    unsigned int _t211;                    // _t211
    unsigned int _t214;                    // _t214
    signed int _t217;                      // _t217
    unsigned int _t219;                    // _t219
    intOrPtr _t221;                        // _t221
    signed int _t224;                      // _t224
    signed int _t226;                      // _t226
    signed int _t227;                      // _t227
    unsigned int _t235;                    // _t235
    signed int _t237;                      // _t237
    intOrPtr _t242;                        // _t242
    intOrPtr _t245;                        // _t245
    signed int _t249;                      // _t249
    signed int _t255;                      // _t255
    signed int _t256;                      // _t256
    signed char _t257;                     // _t257
    signed int _t261;                      // _t261
    signed int _t262;                      // _t262
    signed int _t269;                      // _t269
    unsigned int _t273;                    // _t273
    signed int _t274;                      // _t274
    signed int _t276;                      // _t276

    _v32 = __eax;
    _v36 = __edx;
    _v40 = __ecx;
    _t203 = compare_stack;
    while(1) {
        _t144 = _v32 == _v36;
        if(_t144 == 0 && _v40 != 0) {
        }
L104:
        __eflags = _t203 - compare_stack;
        if(_t203 != compare_stack) {
            _t145 =  *_t203;
            _v32 =  *_t145;
             *_t203 =  &(_t145[1]);
            _t147 =  *(_t203 + 4);
            _v36 =  *_t147;
             *(_t203 + 4) =  &(_t147[1]);
            _t150 =  *(_t203 + 8) - 1;
             *(_t203 + 8) = _t150;
            __eflags = _t150;
            _t203 = _t150 == 0 ? _t203 - 12 : _t203;
            while(1) {
                _t144 = _v32 == _v36;
                if(_t144 == 0 && _v40 != 0) {
                }
                goto L3;
            }
            goto L104;
        }
        return 0;
L3:
        if((_v32 & 1) == 0) {
            __eflags = _v36 & 1;
            if((_v36 & 1) == 0) {
                _t235 = _v32;
                _v44 = _t235;
                _t237 = _t235 >> 12 & 2047;
                _t209 =  *((intOrPtr*)((_t235 >> 23) * 4 +  &caml_page_table));
                __eflags =  *(_t209 + _t237) & 7;
                if(( *(_t209 + _t237) & 7) == 0) {
L30:
                    __eflags = _t144;
                    if(_t144 != 0) {
                        goto L104;
                    }
                    return (_v32 >> 1) - (_v36 >> 1);
                }
                _t219 = _v36;
                _v48 = _t219;
                _t255 = _v36 >> 12 & 2047;
                _t221 =  *((intOrPtr*)((_t219 >> 23) * 4 +  &caml_page_table));
                __eflags =  *(_t221 + _t255) & 7;
                if(( *(_t221 + _t255) & 7) != 0) {
                    _t269 = _v44 - 4;
                    _t274 =  *_t269 & 255;
                    _t256 = _t274 & 255;
                    _t224 = _v48 - 4;
                    _v52 = _t224;
                    _v56 =  *_t224 & 255;
                    __eflags = _t256 - 250;
                    if(_t256 != 250) {
                        _t226 = _v56 & 255;
                        __eflags = _t226 - 250;
                        if(_t226 != 250) {
                            __eflags = _t256 - _t226;
                            if(_t256 == _t226) {
                                _t257 = _t274 + 9;
                                __eflags = _t257 - 8;
                                if(__eflags > 0) {
L87:
                                    _v56 =  *_t269 >> 10;
                                    _t158 =  *_v52 >> 10;
                                    __eflags = _v56 - _t158;
                                    if(_v56 == _t158) {
                                        __eflags = _v56;
                                        if(_v56 == 0) {
                                            goto L104;
                                        }
                                        __eflags = _v56 - 1;
                                        if(_v56 > 1) {
                                            _t203 = _t203 + 12;
                                            _t161 = compare_stack_limit;
                                            __eflags = _t203 - _t161;
                                            if(_t203 >= _t161) {
                                                _t261 = compare_stack;
                                                _v64 = _t261;
                                                _t171 = (_t161 - _t261 >> 2) * -1431655765 + (_t161 - _t261 >> 2) * -1431655765;
                                                _v60 = _t171;
                                                __eflags = _t171 - 1048575;
                                                if(_t171 > 1048575) {
                                                    compare_stack_overflow(_t226);
                                                }
                                                _t262 = compare_stack;
                                                __eflags = _t262 -  &compare_stack_init;
                                                if(_t262 !=  &compare_stack_init) {
                                                    _t172 = _v60 * 12;
                                                    _v88 = _t172;
                                                     *__esp = _t262;
                                                    realloc();
                                                    _v52 = _t172;
                                                    __eflags = _t172;
                                                    if(_t172 == 0) {
                                                        compare_stack_overflow(_t226);
                                                    }
                                                } else {
                                                    _t175 = _v60 * 12;
                                                     *__esp = _t175;
                                                    malloc();
                                                    _v52 = _t175;
                                                    __eflags = _t175;
                                                    if(_t175 == 0) {
                                                        compare_stack_overflow(_t226);
                                                    }
                                                    _push(768 << 2);
                                                    _push( &compare_stack_init);
                                                    _push(_v52);
                                                    memcpy();
                                                    __esp =  &(__esp[3]);
                                                }
                                                _t227 = _v52;
                                                compare_stack = _t227;
                                                compare_stack_limit = _v60 * 12 + _t227;
                                                _t203 = (_t203 - _v64 & -4) + _t227;
                                                __eflags = _t203;
                                            }
                                             *_t203 = _v44 + 4;
                                             *(_t203 + 4) = _v48 + 4;
                                            _t167 = _v56 - 1;
                                            __eflags = _t167;
                                             *(_t203 + 8) = _t167;
                                        }
                                        _v32 =  *_v32;
                                        _v36 =  *_v36;
                                        continue;
                                    }
                                    return _v56 - _t158;
                                }
                                switch( *((intOrPtr*)((_t257 & 255) * 4 +  &M0806BCEC))) {
                                    case 0:
L75:
                                        compare_free_stack();
                                         *__esp = "equal: functional value";
                                        caml_invalid_argument();
                                        goto L76;
                                    case 1:
L76:
                                        __eax = _v44;
                                        __edx =  *(__eax + 4);
                                        __edx =  *(__eax + 4) >> 1;
                                        __ecx = _v48;
                                        __eax =  *(__ecx + 4);
                                        __eax =  *(__ecx + 4) >> 1;
                                        __eflags = __edx - __eax;
                                        if(__edx == __eax) {
                                            goto L104;
                                        }
                                        __edx = __edx - __eax;
                                        __eax = __edx;
                                        return __edx;
                                    case 2:
                                        goto L87;
                                    case 3:
                                        compare_free_stack();
                                         *__esp = "equal: abstract value";
                                        caml_invalid_argument();
                                        goto L75;
                                    case 4:
                                        __eflags = _t144;
                                        if(_t144 != 0) {
                                            goto L104;
                                        }
                                        caml_string_length(_v32);
                                        _t276 = _t144;
                                        _t177 = _v36;
                                        caml_string_length(_t177);
                                        _t273 = _t177;
                                        __eflags = _t177 - _t276;
                                        _t179 = _t177 - _t276 <= 0 ? _t273 : _t276;
                                        _v84 = _t179;
                                        _v88 = _v36;
                                         *__esp = _v32;
                                        memcmp();
                                        __eflags = _t179;
                                        if(_t179 < 0) {
                                            goto L113;
                                        }
                                        __eflags = _t179;
                                        if(_t179 > 0) {
                                            goto L119;
                                        }
                                        __eflags = _t276 - _t273;
                                        if(_t276 == _t273) {
                                            goto L104;
                                        }
                                        return _t276 - _t273;
                                    case 5:
                                        __eax = _v32;
                                        __fp0 =  *_v32;
                                        __edx = _v36;
                                        __fp0 =  *_v36;
                                        asm("fucomi st0, st1");
                                        if(__eflags > 0) {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L113;
                                        }
                                        asm("fxch st0, st1");
                                        asm("fucomi st0, st1");
                                        if(__eflags > 0) {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L119;
                                        }
                                        asm("fucomi st0, st1");
                                        if(__eflags != 0 || __eflags != 0) {
                                            __eflags = _v40;
                                            if(__eflags == 0) {
                                                st0 = __fp0;
                                                st0 = __fp0;
                                                goto L109;
                                            }
                                            asm("fucomip st0, st0");
                                            if(__eflags != 0 || __eflags != 0) {
                                                asm("fucomip st0, st0");
                                                if(__eflags != 0) {
                                                    goto L104;
                                                }
                                                if(__eflags != 0) {
                                                    goto L113;
                                                }
                                                goto L104;
                                            } else {
                                                st0 = __fp0;
                                                goto L119;
                                            }
                                        } else {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L104;
                                        }
                                    case 6:
                                        __edx =  *__edi;
                                        __edx =  *__edi >> 11;
                                        __ecx = _v52;
                                        __eax =  *__ecx;
                                        __eax =  *__ecx >> 11;
                                        __eflags = __edx - __eax;
                                        if(__edx != __eax) {
                                            __edx = __edx - __eax;
                                            __eax = __edx;
                                            return __edx;
                                        }
                                        __eflags = __edx;
                                        if(__eflags == 0) {
                                            goto L104;
                                        }
                                        __eax = _v44;
                                        __fp0 =  *_v44;
                                        __ecx = _v48;
                                        __fp0 =  *__ecx;
                                        asm("fucomi st0, st1");
                                        if(__eflags > 0) {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L113;
                                        }
                                        asm("fxch st0, st1");
                                        asm("fucomi st0, st1");
                                        if(__eflags > 0) {
                                            st0 = __fp0;
                                            st0 = __fp0;
                                            goto L119;
                                        }
                                        __eax = 0;
                                        __esi = _v44;
                                        do {
                                            asm("fucomi st0, st1");
                                            if(__eflags != 0 || __eflags != 0) {
                                                __eflags = _v40;
                                                if(__eflags == 0) {
                                                    st0 = __fp0;
                                                    st0 = __fp0;
                                                    goto L109;
                                                }
                                                asm("fucomip st0, st0");
                                                if(__eflags != 0 || __eflags != 0) {
                                                    asm("fucomip st0, st0");
                                                    if(__eflags != 0) {
                                                        goto L72;
                                                    }
                                                    if(__eflags == 0) {
                                                        goto L113;
                                                    }
                                                    goto L72;
                                                } else {
                                                    st0 = __fp0;
                                                    goto L119;
                                                }
                                            } else {
                                                st0 = __fp0;
                                                st0 = __fp0;
L72:
                                                __eax = __eax + 1;
                                                __eflags = __edx - __eax;
                                                if(__eflags > 0) {
                                                    __fp0 =  *((long long*)(__esi + __eax * 8));
                                                    __fp0 =  *((long long*)(__ecx + __eax * 8));
                                                    asm("fucomi st0, st1");
                                                    if(__eflags > 0) {
                                                        st0 = __fp0;
                                                        st0 = __fp0;
                                                        goto L113;
                                                    }
                                                    goto L62;
                                                }
                                                goto L104;
                                            }
L62:
                                            asm("fxch st0, st1");
                                            asm("fucomi st0, st1");
                                        } while(__eflags <= 0);
                                        st0 = __fp0;
                                        st0 = __fp0;
                                        goto L119;
                                    case 7:
                                        __eax = _v32;
                                        __ecx =  *_v32;
                                        __edx = _v36;
                                        __eax =  *_v36;
                                        __edx =  *(__eax + 8);
                                        __eflags = __edx -  *((intOrPtr*)(__ecx + 8));
                                        if(__edx ==  *((intOrPtr*)(__ecx + 8))) {
                                            __eflags = __edx;
                                            if(__edx == 0) {
                                                compare_free_stack();
                                                 *__esp = "equal: abstract value";
                                                caml_invalid_argument();
                                            }
                                            caml_compare_unordered = 0;
                                            __ecx = _v36;
                                            _v88 = __ecx;
                                            __eax = _v32;
                                             *__esp = __eax;
                                             *__edx();
                                            __eflags = caml_compare_unordered;
                                            if(caml_compare_unordered == 0) {
L85:
                                                __eflags = __eax;
                                                if(__eax == 0) {
                                                    goto L104;
                                                }
                                                return __eax;
                                            } else {
                                                __eflags = _v40;
                                                if(_v40 == 0) {
L109:
                                                    return -2147483648;
                                                }
                                                goto L85;
                                            }
                                        }
                                        __edx =  *__ecx;
                                        __eax =  *__eax;
                                        _v88 = __eax;
                                         *__esp =  *__ecx;
                                        strcmp();
                                        __eflags = __eax;
                                        if(__eax >= 0) {
L119:
                                            return 1;
                                        }
L113:
                                        return -1;
                                }
                            }
                            return _t256 - _t226;
                        }
                        _v36 =  *_v36;
                        continue;
                    }
                    _v32 =  *_v32;
                    continue;
                }
                goto L30;
            }
            _t211 = _v32;
            _t189 = _t211 >> 12 & 2047;
            _t242 =  *((intOrPtr*)((_t211 >> 23) * 4 +  &caml_page_table));
            __eflags =  *(_t242 + _t189) & 7;
            if(( *(_t242 + _t189) & 7) == 0) {
                goto L119;
            }
            _t190 =  *(_t211 - 4) & 255;
            __eflags = _t190 - 250;
            if(_t190 == 250) {
L22:
                _v32 =  *_v32;
                continue;
            }
            __eflags = _t190 - 255;
            if(_t190 != 255) {
                goto L119;
            }
            _t249 = _v32;
            _t192 =  *( *_t249 + 24);
            __eflags = _t192;
            if(_t192 == 0) {
                goto L119;
            } else {
                caml_compare_unordered = 0;
                _v88 = _v36;
                 *__esp = _t249;
                 *_t192();
                __eflags = caml_compare_unordered;
                if(caml_compare_unordered == 0) {
L26:
                    __eflags = _t192;
                    if(_t192 == 0) {
                        goto L104;
                    }
                    return _t192;
                }
                __eflags = _v40;
                if(_v40 == 0) {
                    goto L109;
                }
                goto L26;
            }
            goto L22;
        }
        if(_t144 != 0) {
            goto L104;
        }
        if((_v36 & 1) != 0) {
            return (_v32 >> 1) - (_v36 >> 1);
        }
        _t214 = _v36;
        _t196 = _t214 >> 12 & 2047;
        _t245 =  *((intOrPtr*)((_t214 >> 23) * 4 +  &caml_page_table));
        __eflags =  *(_t245 + _t196) & 7;
        if(( *(_t245 + _t196) & 7) == 0) {
            goto L113;
        } else {
            _t197 =  *(_t214 - 4) & 255;
            __eflags = _t197 - 250;
            if(_t197 == 250) {
                _v36 =  *_v36;
                continue;
            }
            __eflags = _t197 - 255;
            if(_t197 != 255) {
                goto L113;
            }
            _t217 = _v36;
            _t199 =  *( *_t217 + 24);
            __eflags = _t199;
            if(_t199 == 0) {
                goto L113;
            } else {
                caml_compare_unordered = 0;
                _v88 = _t217;
                 *__esp = _v32;
                 *_t199();
                __eflags = caml_compare_unordered;
                if(caml_compare_unordered == 0) {
L15:
                    __eflags = _t199;
                    if(_t199 == 0) {
                        goto L104;
                    }
                    return _t199;
                }
                __eflags = _v40;
                if(_v40 == 0) {
                    goto L109;
                }
                goto L15;
            }
        }
    }
}

caml_greaterequal(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060562
    signed int __ebx;                      // r1

    __ecx = 0;
    __edx = _a8;
    __ebx = compare_val(_a4, 0, _a8);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    return (__ebx >> 31 & -2) + 3;
}

caml_greaterthan(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806059D
    signed int __ebx;                      // r1

    __ecx = 0;
    __edx = _a8;
    __ebx = compare_val(_a4, 0, _a8);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    return (__ebx > 0 & 255) + (__ebx > 0 & 255) + 1;
}

caml_lessequal(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080605D9
    signed int __ebx;                      // r1

    __ecx = 0;
    __ebx = compare_val(_a4, 0, _a8);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    return (__ebx != -2147483648 & 255 & __ebx <= 0) + (__ebx != -2147483648 & 255 & __ebx <= 0) + 1;
}

caml_lessthan(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060621
    _unknown_ __ebx;                       // r1
    signed int _t4;                        // _t4

    __ecx = 0;
    __edx = _a8;
    _t4 = compare_val(_a4, 0, _a8);
    if(compare_stack !=  &compare_stack_init) {
        _t4 = compare_free_stack();
    }
    asm("sbb eax, eax");
    return (_t4 & 2) + 1;
}

caml_notequal(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060665
    signed int _t4;                        // _t4

    __ecx = 0;
    __edx = _a8;
    _t4 = compare_val(_a4, 0, _a8);
    if(compare_stack !=  &compare_stack_init) {
        _t4 = compare_free_stack();
    }
    asm("sbb eax, eax");
    return (_t4 & -2) + 3;
}

caml_equal(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080606A0
    signed int _t4;                        // _t4

    __ecx = 0;
    __edx = _a8;
    _t4 = compare_val(_a4, 0, _a8);
    if(compare_stack !=  &compare_stack_init) {
        _t4 = compare_free_stack();
    }
    asm("sbb eax, eax");
    return (_t4 & 2) + 1;
}

unsigned int caml_compare(
    signed int _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080606DB
    signed int __ebx;                      // r1

    __ecx = 1;
    __edx = _a8;
    __ebx = compare_val(_a4, 1, _a8);
    if(compare_stack !=  &compare_stack_init) {
        compare_free_stack();
    }
    if(__ebx >= 0) {
        return (__ebx > 0 & 255) + (__ebx > 0 & 255) + 1;
    }
    return -1;
}

parse_sign_and_base(
    char* __eax,                           // r0
    intOrPtr* __ecx,                       // r2
    intOrPtr* __edx                        // r3
)
{// addr = 0x08060720
    signed char _t8;                       // _t8

    __edx = __edx;
    _t4 = __eax;
     *__ecx = 1;
    if( *__eax == 45) {
         *__ecx = -1;
        _t4 = __eax + 1;
    }
     *__edx = 10;
    if( *_t4 == 48) {
        _t8 = ( *(_t4 + 1) & 255) - 66;
        if(_t8 <= 54) {
            switch( *((intOrPtr*)((_t8 & 255) * 4 +  &M0806BD10))) {
                case 0:
                     *__edx = 2;
                    return __eax;
                case 1:
                    goto L8;
                case 2:
                     *__edx = 8;
                    return __eax;
                case 3:
                     *__edx = 16;
                    return _t4 + 2;
            }
        }
    }
L8:
    return _t4;
}

parse_digit(
    _unknown_ __eax                        // r0
)
{// addr = 0x08060779
    if(__eax - 48 <= 9) {
        return __eax - 48;
    }
    if(__eax - 65 <= 5) {
        return __eax - 55;
    }
    if(__eax - 97 <= 5) {
        return __eax - 87;
    }
    return -1;
}

caml_int_compare(
    _unknown_ __ecx,                       // r2
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080607B3
    _t12 = _a4;
    return (_a4 - _a8 > 0 & 255) - (_t12 - _a8 < 0 & 255) + (_a4 - _a8 > 0 & 255) - (_t12 - _a8 < 0 & 255) + 1;
}

int32_cmp(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080607D6
    return ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) > 0 & 255) - ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) < 0 & 255);
}

int32_hash(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080607F9
    return  *((intOrPtr*)(_a4 + 4));
}

caml_int32_to_int(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060804
    return  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_a4 + 4)) + 1;
}

caml_int32_compare(
    _unknown_ __ecx,                       // r2
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060813
    return ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) > 0 & 255) - ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) < 0 & 255) + ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) > 0 & 255) - ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) < 0 & 255) + 1;
}

int64_cmp(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806083C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t11;                         // _t11
    _unknown_ _t12;                        // _t12
    _unknown_ _t15;                        // _t15
    intOrPtr _t17;                         // _t17
    intOrPtr _t18;                         // _t18
    intOrPtr _t20;                         // _t20
    intOrPtr _t23;                         // _t23
    _unknown_ _t25;                        // _t25
    _unknown_ _t27;                        // _t27

     *__esp = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t17 = _a4;
    _t11 = _a8;
    _t23 =  *((intOrPtr*)(_t17 + 4));
    __ecx =  *((intOrPtr*)(_t17 + 8));
    _t20 =  *((intOrPtr*)(_t11 + 4));
    _t18 =  *((intOrPtr*)(_t11 + 8));
    _t12 = 1;
    _t25 = __ecx - _t18;
    if(_t25 <= 0) {
        if(_t25 < 0 || _t23 <= _t20) {
            _t12 = 0;
        }
    }
    _t15 = 1;
    _t27 = __ecx - _t18;
    if(_t27 >= 0 && (_t27 > 0 || _t23 >= _t20)) {
        _t15 = 0;
    }
    return _t12 - _t15;
}

int64_hash(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060898
    return  *((intOrPtr*)(_a4 + 4));
}

caml_int64_to_int(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080608A3
    return  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_a4 + 4)) + 1;
}

caml_int64_compare(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080608B2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t13;                         // _t13
    intOrPtr _t14;                         // _t14
    intOrPtr _t17;                         // _t17
    intOrPtr _t19;                         // _t19
    intOrPtr _t20;                         // _t20
    _unknown_ _t22;                        // _t22
    intOrPtr _t26;                         // _t26
    _unknown_ _t28;                        // _t28
    _unknown_ _t30;                        // _t30

     *__esp = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t19 = _a4;
    _t13 = _a8;
    _t17 =  *((intOrPtr*)(_t19 + 4));
    _t20 =  *((intOrPtr*)(_t19 + 8));
    _t26 =  *((intOrPtr*)(_t13 + 4));
    _t14 =  *((intOrPtr*)(_t13 + 8));
    _t22 = 1;
    _t28 = _t20 - _t14;
    if(_t28 <= 0) {
        if(_t28 < 0 || _t17 <= _t26) {
            _t22 = 0;
        }
    }
    __ecx = 1;
    _t30 = _t20 - _t14;
    if(_t30 >= 0 && (_t30 > 0 || _t17 >= _t26)) {
        __ecx = 0;
    }
    return _t22 - __ecx + _t22 - __ecx + 1;
}

nativeint_cmp(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060912
    return ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) > 0 & 255) - ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) < 0 & 255);
}

nativeint_hash(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060935
    return  *((intOrPtr*)(_a4 + 4));
}

caml_nativeint_to_int(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060940
    return  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_a4 + 4)) + 1;
}

caml_nativeint_compare(
    _unknown_ __ecx,                       // r2
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806094F
    return ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) > 0 & 255) - ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) < 0 & 255) + ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) > 0 & 255) - ( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)) < 0 & 255) + 1;
}

int32_deserialize(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08060978
     *_a4 = caml_deserialize_sint_4();
    return 4;
}

nativeint_deserialize(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x0806098F
    _unknown_ _t2;                         // _t2

    _t2 = caml_deserialize_uint_1();
    if(_t2 == 1) {
         *_a4 = caml_deserialize_sint_4();
    } else {
        if(_t2 != 2) {
             *__esp = "input_value: ill-formed native integer";
            caml_deserialize_error();
        } else {
             *__esp = "input_value: native integer value too large";
            caml_deserialize_error();
        }
    }
    return 4;
}

nativeint_serialize(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr* _a12                         // _cfa_c
)
{// addr = 0x080609D3
    intOrPtr* _t9;                         // _t9

    caml_serialize_int_1(1);
    caml_serialize_int_4( *((intOrPtr*)(_a4 + 4)));
     *_a8 = 4;
    _t9 = _a12;
     *_t9 = 8;
    return _t9;
}

int32_serialize(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr* _a12                         // _cfa_c
)
{// addr = 0x08060A0C
    intOrPtr* _t9;                         // _t9

    caml_serialize_int_4( *((intOrPtr*)(_a4 + 4)));
     *_a12 = 4;
    _t9 = _a8;
     *_t9 = 4;
    return _t9;
}

int64_deserialize(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08060A34
    intOrPtr _t3;                          // _t3
    intOrPtr _t5;                          // _t5
    intOrPtr* _t6;                         // _t6

    _t3 = caml_deserialize_sint_8();
    _t6 = _a4;
     *_t6 = _t3;
    _t6[1] = _t5;
    return 8;
}

int64_serialize(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr* _a8,                         // _cfa_8
    intOrPtr* _a12                         // _cfa_c
)
{// addr = 0x08060A57
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr* _t11;                        // _t11

    caml_serialize_int_8( *((intOrPtr*)(_a4 + 4)),  *((intOrPtr*)(_t7 + 8)));
     *_a12 = 8;
    _t11 = _a8;
     *_t11 = 8;
    return _t11;
}

signed int parse_intnat(
    char* __eax,                           // r0
    signed char __edx                      // r3
)
{// addr = 0x08060A86
    char _v32;                             // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ __ebx;                       // r1
    signed int __edi;                      // r4
    _unknown_ __esi;                       // r5
    signed int _t28;                       // _t28
    _unknown_ _t31;                        // _t31
    char* _t49;                            // _t49
    signed char* _t50;                     // _t50
    signed int _t61;                       // _t61

    _v56 = __eax;
    _v60 = __edx;
    _t49 = parse_sign_and_base(__eax,  &_v32,  &_v36);
    __edi = _v36;
    _v52 = __edi;
    _v48 = -1 / __edi;
    _t28 = parse_digit( *_t49);
    if(_t28 < 0 || __edi <= _t28) {
         *__esp = "int_of_string";
        _t28 = caml_failwith();
    }
    _t50 = _t49 + 1;
    _t61 = _t28;
    while(1) {
        _t29 =  *_t50 & 255;
        if(( *_t50 & 255) == 95) {
            goto L11;
        }
        _t31 = parse_digit(_t29);
        if(_t31 < 0 || __edi <= _t31) {
            if(_t50 != caml_string_length(_v56) + _v56) {
                 *__esp = "int_of_string";
                caml_failwith();
            }
            if(_v36 != 10) {
L20:
                if(_v60 <= 31 && 1 << (_v60 & 255) <= _t61) {
                     *__esp = "int_of_string";
                    caml_failwith();
                }
                if(_v32 >= 0) {
                    goto L25;
                } else {
                    goto L24;
                }
            } else {
                if(_v32 < 0) {
L18:
                    if(1 << _v60 - 1 >= _t61) {
L24:
                        return  ~_t61;
                    }
                     *__esp = "int_of_string";
                    caml_failwith();
                    goto L20;
                }
                if(1 << _v60 - 1 > _t61) {
L25:
                    return _t61;
                }
                 *__esp = "int_of_string";
                caml_failwith();
                goto L18;
            }
        } else {
            if(_t61 > _v48) {
                 *__esp = "int_of_string";
                _t31 = caml_failwith();
            }
            _t61 = _t61 * _v52 + _t31;
            if(_t61 < 0) {
                 *__esp = "int_of_string";
                caml_failwith();
            }
        }
L11:
        _t50 =  &(_t50[1]);
    }
}

intOrPtr caml_int_of_string(
    char* _a4                              // _cfa_4
)
{// addr = 0x08060BB4
    __edx = 31;
    return parse_intnat(_a4, 31) + _t5 + 1;
}

parse_format(
    signed char* __eax,                    // r0
    signed char* __ecx,                    // r2
    signed char* __edx,                    // r3
    intOrPtr _a4,                          // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x08060BCD
    signed char* _v32;                     // _cfa_ffffffe0
    signed char* _v36;                     // _cfa_ffffffdc
    signed char* _v40;                     // _cfa_ffffffd8
    signed int _v52;                       // _cfa_ffffffcc
    signed char* _v56;                     // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    signed int _t32;                       // _t32
    signed char* _t34;                     // _t34
    signed int _t41;                       // _t41
    signed char* _t42;                     // _t42
    signed char* _t43;                     // _t43
    signed char* _t52;                     // _t52
    signed int _t54;                       // _t54
    signed int _t56;                       // _t56
    signed int _t60;                       // _t60

    _v32 = __eax;
    _v36 = __edx;
    _v40 = __ecx;
    _t41 = caml_string_length(__eax);
    asm("repne scasb");
    __esi =  !-1 - 1;
    if(__esi + _t41 + 1 > 31) {
         *__esp = "format_int: format too long";
        caml_invalid_argument();
    }
    _v52 = _t41;
    _v56 = _v32;
     *__esp = _v40;
    memmove();
    _t42 =  &(_v40[_t41 - 1]);
    _t60 =  *_t42 & 255;
    _t52 = _t42 - 1;
    _t32 =  *_t52 & 255;
    if(_t32 == 108 || _t32 == 110 || _t32 == 76) {
        _t42 = _t52;
    }
    _v52 = __esi;
    _v56 = _v36;
     *__esp = _t42;
    memmove();
    _t43 =  &(_t42[__esi]);
     *_t43 = _t60;
    _t43[1] = 0;
    _t34 = _v32;
    _t54 =  *_t34 & 255;
    if(_t54 == 0) {
L16:
         *_a8 = _t60;
L15:
        return _a4;
    }
    if(_t54 - 48 > 9) {
        while(1) {
            _t34 =  &(_t34[1]);
            _t56 =  *_t34 & 255;
            if(_t56 == 0) {
                break;
            }
            if(_t56 - 48 > 9) {
                continue;
            }
L10:
            _v52 = 10;
            _v56 = 0;
             *__esp = _t34;
            strtol();
            _t37 =  &(_t34[5]);
             *_a8 = _t60;
            if( &(_t34[5]) > 31) {
                _a4 = caml_stat_alloc( &(_t37[1]),  &(_t37[1]));
            }
            goto L15;
        }
        goto L16;
    }
    goto L10;
}

caml_nativeint_format(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed char* _a4,                      // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060CD6
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v60;                             // _cfa_ffffffc4
    char _v92;                             // _cfa_ffffffa4
    char _v93;                             // _cfa_ffffffa3
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    intOrPtr _t25;                         // _t25
    intOrPtr _t32;                         // _t32

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v120 =  &_v93;
     *__esp =  &_v92;
    __ecx =  &_v60;
    __edx = 134661795;
    _t25 = parse_format(_a4,  &_v60, 134661795);
    _v116 =  *((intOrPtr*)(_a8 + 4));
    _v120 =  &_v60;
     *__esp = _t25;
    sprintf();
    _t32 = caml_copy_string(_t25,  &_v92,  &_v60, _t25);
    if(_t25 !=  &_v92) {
        caml_stat_free(_t25);
    }
    return _t32;
}

caml_int64_format(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed char* _a4,                      // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060D41
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v60;                             // _cfa_ffffffc4
    char _v92;                             // _cfa_ffffffa4
    char _v93;                             // _cfa_ffffffa3
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    intOrPtr _t21;                         // _t21
    intOrPtr _t27;                         // _t27
    intOrPtr _t36;                         // _t36

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v120 =  &_v93;
     *__esp =  &_v92;
    __ecx =  &_v60;
    _t27 = parse_format(_a4,  &_v60, 134657246);
    _t21 = _a8;
    _v116 =  *((intOrPtr*)(_t21 + 4));
    _v112 =  *((intOrPtr*)(_t21 + 8));
    _v120 =  &_v60;
     *__esp = _t27;
    sprintf();
    _t36 = caml_copy_string(_t27,  &_v92,  &_v60, _t27);
    if(_t27 !=  &_v92) {
        caml_stat_free(_t27);
    }
    return _t36;
}

caml_int32_format(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed char* _a4,                      // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08060DB3
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v60;                             // _cfa_ffffffc4
    char _v92;                             // _cfa_ffffffa4
    char _v93;                             // _cfa_ffffffa3
    intOrPtr _v116;                        // _cfa_ffffff8c
    char* _v120;                           // _cfa_ffffff88
    intOrPtr _t25;                         // _t25
    intOrPtr _t32;                         // _t32

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v120 =  &_v93;
     *__esp =  &_v92;
    __ecx =  &_v60;
    __edx = 134661416;
    _t25 = parse_format(_a4,  &_v60, 134661416);
    _v116 =  *((intOrPtr*)(_a8 + 4));
    _v120 =  &_v60;
     *__esp = _t25;
    sprintf();
    _t32 = caml_copy_string(_t25,  &_v92,  &_v60, _t25);
    if(_t25 !=  &_v92) {
        caml_stat_free(_t25);
    }
    return _t32;
}

caml_format_int(
    intOrPtr __edi,                        // r4
    signed char* _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060E1E
    char _v44;                             // _cfa_ffffffd4
    char _v76;                             // _cfa_ffffffb4
    signed char _v77;                      // _cfa_ffffffb3
    signed int _v100;                      // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    intOrPtr __ebx;                        // r1
    _unknown_ __esi;                       // r5
    signed int _t19;                       // _t19
    signed int _t26;                       // _t26
    intOrPtr _t28;                         // _t28

    __edi = __edi;
    _t26 = _a8;
    __ecx =  &_v44;
    _v104 =  &_v77;
     *__esp =  &_v76;
    __edx = 134661795;
    __ebx = parse_format(_a4,  &_v44, 134661795);
    _t19 = _v77 & 255;
    if(_t19 == 111) {
L6:
        _t27 = _t26 >> 1;
        _v100 = _t26 >> 1;
        _v104 =  &_v44;
         *__esp = __ebx;
        sprintf();
L8:
        _t28 = caml_copy_string(__ebx, __edi, _t27, __ebx);
        if(__ebx !=  &_v76) {
            caml_stat_free(__ebx);
        }
        return _t28;
    }
    if(_t19 > 111) {
        if(_t19 == 117 || _t19 == 120) {
            goto L6;
        } else {
L7:
            _t27 = _t26 >> 1;
            _v100 = _t26 >> 1;
            _v104 =  &_v44;
             *__esp = __ebx;
            sprintf();
            goto L8;
        }
    }
    if(_t19 != 88) {
        goto L7;
    }
    goto L6;
}

caml_nativeint_to_float(
    long long __fp0,                       // r28
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060EB4
    __fp0 = __fp0;
    asm("fild dword [eax+0x4]");
     *__esp = __fp0;
    return caml_copy_double();
}

intOrPtr caml_int64_float_of_bits(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060ECA
     *__esp =  *((long long*)(_a4 + 4));
    return caml_copy_double();
}

caml_int64_to_float(
    long long __fp0,                       // r28
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060EE0
    __fp0 = __fp0;
    asm("fild qword [eax+0x4]");
     *__esp = __fp0;
    return caml_copy_double();
}

caml_int32_float_of_bits(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060EF6
     *__esp =  *((intOrPtr*)(_a4 + 4));
    return caml_copy_double();
}

caml_int32_to_float(
    long long __fp0,                       // r28
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060F0C
    __fp0 = __fp0;
    asm("fild dword [eax+0x4]");
     *__esp = __fp0;
    return caml_copy_double();
}

caml_copy_nativeint(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060F22
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __eax = caml_alloc_custom(__edi, __fp0,  &caml_nativeint_ops, 4, 0, 1);
     *((intOrPtr*)(__eax + 4)) = _a4;
    return __eax;
}

caml_nativeint_of_string(
    char* _a4                              // _cfa_4
)
{// addr = 0x08060F54
    __edx = 32;
    return caml_copy_nativeint(parse_intnat(_a4, 32));
}

caml_nativeint_of_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08060F71
    return caml_copy_nativeint( *((intOrPtr*)(_a4 + 4)));
}

caml_nativeint_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08060F87
    _unknown_ _v14;                        // _cfa_fffffff2
    short _v16;                            // _cfa_fffffff0

    asm("fnstcw word [ebp-0xa]");
    _v16 = 12;
    asm("fldcw word [ebp-0xc]");
    asm("fistp dword [esp]");
    asm("fldcw word [ebp-0xa]");
    return caml_copy_nativeint();
}

caml_nativeint_of_int(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08060FAF
    return caml_copy_nativeint(_a4 >> 1);
}

caml_nativeint_shift_right_unsigned(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060FC4
    return caml_copy_nativeint( *(_a4 + 4) >> _a8 >> 1);
}

caml_nativeint_shift_right(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060FE1
    return caml_copy_nativeint( *(_a4 + 4) >> _a8 >> 1);
}

caml_nativeint_shift_left(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08060FFE
    return caml_copy_nativeint( *(_a4 + 4) << _a8 >> 1);
}

caml_nativeint_xor(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806101B
    return caml_copy_nativeint( *(_a8 + 4) ^  *(_a4 + 4));
}

caml_nativeint_or(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061037
    return caml_copy_nativeint( *(_a8 + 4) |  *(_a4 + 4));
}

caml_nativeint_and(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061053
    return caml_copy_nativeint( *(_a8 + 4) &  *(_a4 + 4));
}

caml_nativeint_mod(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806106F
    signed int _t14;                       // _t14

    _t14 =  *(_a4 + 4);
    __ecx =  *(_a8 + 4);
    if(__ecx == 0) {
        caml_raise_zero_divide();
    }
    if(_t14 != -2147483648 || __ecx != -1) {
        return caml_copy_nativeint(_t14 % __ecx);
    } else {
        return caml_copy_nativeint(0);
    }
}

caml_nativeint_div(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080610B6
    intOrPtr _t7;                          // _t7
    signed int _t12;                       // _t12
    signed int _t13;                       // _t13

    _t7 = _a4;
    _t13 =  *(_t7 + 4);
    _t12 =  *(_a8 + 4);
    if(_t12 == 0) {
        _t7 = caml_raise_zero_divide();
    }
    if(_t13 != -2147483648 || _t12 != -1) {
        return caml_copy_nativeint(_t13 / _t12);
    } else {
        return _t7;
    }
}

caml_nativeint_mul(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080610EF
    return caml_copy_nativeint( *(_a8 + 4) *  *(_a4 + 4));
}

caml_nativeint_sub(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806110C
    return caml_copy_nativeint( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)));
}

caml_nativeint_add(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061128
    return caml_copy_nativeint( *((intOrPtr*)(_a8 + 4)) +  *((intOrPtr*)(_a4 + 4)));
}

caml_nativeint_neg(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08061144
    return caml_copy_nativeint( ~( *(_a4 + 4)));
}

caml_int64_to_nativeint(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806115C
    return caml_copy_nativeint( *((intOrPtr*)(_a4 + 4)));
}

caml_copy_int64(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061172
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _v12 = __ebx;
    _v8 = __esi;
    __eax = caml_alloc_custom(__edi, __fp0,  &caml_int64_ops, 8, 0, 1);
     *((intOrPtr*)(__eax + 4)) = _a4;
     *((intOrPtr*)(__eax + 8)) = _a8;
    return __eax;
}

caml_int64_bits_of_float(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080611B8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_copy_int64(__ebx, __esi,  *_a4,  *((intOrPtr*)(_t4 + 4)));
}

caml_int64_of_string(
    char* _a4                              // _cfa_4
)
{// addr = 0x080611D4
    char _v32;                             // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v80;                       // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    signed int _v96;                       // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    _unknown_ _v112;                       // _cfa_ffffff90 (outparam)
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t45;                       // _t45
    signed int _t48;                       // _t48
    signed int _t51;                       // _t51
    _unknown_ _t52;                        // _t52
    _unknown_ _t55;                        // _t55
    signed int _t58;                       // _t58
    signed int _t60;                       // _t60
    signed int _t63;                       // _t63
    signed int _t71;                       // _t71
    _unknown_ _t73;                        // _t73
    signed int _t79;                       // _t79
    char* _t80;                            // _t80
    signed char* _t81;                     // _t81
    signed int _t83;                       // _t83
    _unknown_ _t92;                        // _t92

    _t80 = parse_sign_and_base(_a4,  &_v32,  &_v36);
    _t45 = _v36;
    _v60 = _t45;
    _t71 = _t45 >> 31;
    _v52 = _t45;
    _v48 = _t71;
    _v64 = __udivdi3(-1, -1, _t45, _t71);
    _v56 = _t71;
    _t48 = parse_digit( *_t80);
    _t63 = _t48;
    if(_t48 < 0 || _v60 <= _t48) {
         *__esp = "int_of_string";
        _t48 = caml_failwith();
    }
    _t83 = _t48 >> 31;
    _t81 = _t80 + 1;
    while(1) {
        _t49 =  *_t81 & 255;
        if(( *_t81 & 255) == 95) {
            goto L15;
        }
        _t51 = parse_digit(_t49);
        _v80 = _t51;
        if(_t51 < 0 || _v60 <= _t51) {
            _v52 = _t63;
            _v48 = _t83;
            _t52 = caml_string_length(_a4);
            __eflags = _t81 - _t52 + _a4;
            if(_t81 != _t52 + _a4) {
                 *__esp = "int_of_string";
                caml_failwith();
            }
            __eflags = _v36 - 10;
            if(_v36 != 10) {
L25:
                __eflags = _v32;
                if(_v32 < 0) {
                    _t63 =  ~_v52;
                    asm("adc esi, 0x0");
                    _t83 =  ~_v48;
                }
                return caml_copy_int64(_t63, _t83, _t63, _t83);
            } else {
                _t55 = -1;
                _t73 = 2147483647;
                __eflags = _v32;
                if(_v32 < 0) {
                    _t55 = 0;
                    _t73 = -2147483648;
                }
                __eflags = _t73 - _v48;
                if(__eflags > 0) {
                    goto L25;
                } else {
                    if(__eflags < 0) {
L24:
                         *__esp = "int_of_string";
                        caml_failwith();
                        goto L25;
                    }
                    __eflags = _t55 - _v52;
                    if(_t55 >= _v52) {
                        goto L25;
                    }
                    goto L24;
                }
            }
        } else {
            _t92 = _t83 - _v56;
            if(_t92 >= 0) {
                if(_t92 > 0 || _t63 > _v64) {
                     *__esp = "int_of_string";
                    caml_failwith();
                }
            }
            _v84 = _v52 * _t83 + _v48 * _t63;
            _t58 = _v52;
            _t83 = (_t58 * _t63 >> 32) + _v84;
            _t60 = _v80;
            _t79 = _t60 >> 31;
            _v100 = _t60;
            _v96 = _t79;
            _t63 = _t58 * _t63 + _t60;
            asm("adc esi, edx");
            if(_t79 >= _t83 && (_v96 > _t83 || _t60 > _t63)) {
                 *__esp = "int_of_string";
                caml_failwith();
            }
        }
L15:
        _t81 =  &(_t81[1]);
    }
}

caml_int64_of_nativeint(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08061351
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_copy_int64(__ebx, __esi,  *(_a4 + 4),  *(_a4 + 4) >> 31);
}

caml_int64_of_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08061370
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_copy_int64(__ebx, __esi,  *(_a4 + 4),  *(_a4 + 4) >> 31);
}

caml_int64_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x0806138F
    _unknown_ _v14;                        // _cfa_fffffff2
    short _v16;                            // _cfa_fffffff0

    asm("fnstcw word [ebp-0xa]");
    _v16 = 12;
    asm("fldcw word [ebp-0xc]");
    asm("fistp qword [esp]");
    asm("fldcw word [ebp-0xa]");
    return caml_copy_int64(__ebx, __esi);
}

caml_int64_of_int(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080613B7
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_copy_int64(__ebx, __esi, _a4 >> 1, _t4 >> 31);
}

caml_int64_shift_right_unsigned(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080613D5
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr _t12;                         // _t12
    signed int _t14;                       // _t14
    signed char _t17;                      // _t17
    unsigned int _t18;                     // _t18
    unsigned int _t19;                     // _t19

    _t17 = _a8 >> 1;
    _t12 = _a4;
    _t18 =  *(_t12 + 8);
    _t14 = (_t18 << 32 |  *(_t12 + 4)) >> _t17;
    _t19 = _t18 >> _t17;
    if((_t17 & 32) != 0) {
        _t14 = _t19;
        _t19 = 0;
    }
    return caml_copy_int64(__ebx, __esi, _t14, _t19);
}

caml_int64_shift_right(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061405
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr _t12;                         // _t12
    signed int _t14;                       // _t14
    signed char _t17;                      // _t17
    signed int _t18;                       // _t18
    signed int _t19;                       // _t19

    _t17 = _a8 >> 1;
    _t12 = _a4;
    _t18 =  *(_t12 + 8);
    _t14 = (_t18 << 32 |  *(_t12 + 4)) >> _t17;
    _t19 = _t18 >> _t17;
    if((_t17 & 32) != 0) {
        _t14 = _t19;
        _t19 = _t19 >> 31;
    }
    return caml_copy_int64(__ebx, __esi, _t14, _t19);
}

caml_int64_shift_left(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061436
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr _t12;                         // _t12
    signed int _t13;                       // _t13
    signed int _t14;                       // _t14
    signed char _t17;                      // _t17
    signed int _t19;                       // _t19

    _t17 = _a8 >> 1;
    _t12 = _a4;
    _t13 =  *(_t12 + 4);
    _t19 = ( *(_t12 + 8) << 32 | _t13) << _t17;
    _t14 = _t13 << _t17;
    if((_t17 & 32) != 0) {
        _t19 = _t14;
        _t14 = 0;
    }
    return caml_copy_int64(__ebx, __esi, _t14, _t19);
}

caml_int64_xor(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061466
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _t8 = _a4;
    return caml_copy_int64(__ebx, __esi,  *(_a8 + 4) ^  *(_a4 + 4),  *(_a8 + 8) ^  *(_t8 + 8));
}

caml_int64_or(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806148C
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _t8 = _a4;
    return caml_copy_int64(__ebx, __esi,  *(_a8 + 4) |  *(_a4 + 4),  *(_a8 + 8) |  *(_t8 + 8));
}

caml_int64_and(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080614B2
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    _t8 = _a4;
    return caml_copy_int64(__ebx, __esi,  *(_a8 + 4) &  *(_a4 + 4),  *(_a8 + 8) &  *(_t8 + 8));
}

caml_int64_mod(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080614D8
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int __ebx;                      // r1
    _unknown_ __esi;                       // r5
    intOrPtr _t13;                         // _t13
    signed int _t14;                       // _t14
    intOrPtr _t18;                         // _t18
    signed int _t19;                       // _t19

    _t18 = _a4;
    _t13 = _a8;
    __ebx =  *(_t18 + 4);
    __ecx =  *((intOrPtr*)(_t18 + 8));
    _t19 =  *(_t13 + 4);
    _t14 =  *(_t13 + 8);
    if((_t14 | _t19) == 0) {
        _t14 = caml_raise_zero_divide();
    }
    _t23 = __ecx - -2147483648 | __ebx;
    if((__ecx - -2147483648 | __ebx) != 0) {
L5:
        return caml_copy_int64(__ebx, _t23, __moddi3(__ebx, __ecx, _t19, _t14), _t19);
    } else {
        _t23 = _t19 & _t14;
        if((_t19 & _t14) != -1) {
            goto L5;
        }
        return caml_copy_int64(__ebx, _t23, 0, 0);
    }
}

caml_int64_div(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806154D
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v32;                        // _cfa_ffffffe0 (outparam)
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    intOrPtr _t18;                         // _t18
    intOrPtr _t21;                         // _t21
    intOrPtr _t23;                         // _t23
    signed int _t24;                       // _t24
    signed int _t34;                       // _t34

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t18 = _a4;
    _t23 = _a8;
    _t34 =  *(_t18 + 4);
    _t21 =  *((intOrPtr*)(_t18 + 8));
    __ecx =  *(_t23 + 4);
    _t24 =  *(_t23 + 8);
    if((_t24 | __ecx) == 0) {
        _t18 = caml_raise_zero_divide();
    }
    if((_t21 - -2147483648 | _t34) != 0 || (__ecx & _t24) != -1) {
        _t18 = caml_copy_int64(_t21, _t34, __divdi3(_t34, _t21, __ecx, _t24), _t24);
    }
    return _t18;
}

caml_int64_mul(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080615B9
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1

    _t16 = _a4;
    _t25 = _a8;
    return caml_copy_int64( *(_t16 + 8) *  *(_a8 + 4), __esi,  *(_a4 + 4) *  *(_t25 + 4),  *(_t25 + 8) *  *(_t16 + 4) +  *(_t16 + 8) *  *(_a8 + 4) + ( *(_a4 + 4) *  *(_t25 + 4) >> 32));
}

caml_int64_sub(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080615F1
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    asm("sbb edi, [edx+0x8]");
    return caml_copy_int64( *((intOrPtr*)(_a4 + 8)),  *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(_a4 + 8)));
}

caml_int64_add(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806162F
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr __ebx;                        // r1

    _t8 = _a8;
    __ebx =  *((intOrPtr*)(_a8 + 8));
    _t12 = _a4;
    asm("adc edx, ebx");
    return caml_copy_int64( *((intOrPtr*)(_a8 + 8)), __esi,  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_t8 + 4)),  *((intOrPtr*)(_t12 + 8)));
}

caml_int64_neg(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806165E
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr _t5;                          // _t5

    _t5 = _a4;
    asm("adc edx, 0x0");
    return caml_copy_int64(__ebx, __esi,  ~( *(_t5 + 4)),  ~( *(_t5 + 8)));
}

caml_copy_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08061682
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __eax = caml_alloc_custom(__edi, __fp0,  &caml_int32_ops, 4, 0, 1);
     *((intOrPtr*)(__eax + 4)) = _a4;
    return __eax;
}

caml_nativeint_to_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080616B4
    return caml_copy_int32( *((intOrPtr*)(_a4 + 4)));
}

caml_int64_to_int32(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080616CA
    return caml_copy_int32( *((intOrPtr*)(_a4 + 4)));
}

caml_int32_bits_of_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x080616E0
    long long _v20;                        // _cfa_ffffffec

    _v20 =  *_a4;
    return caml_copy_int32(_v20);
}

caml_int32_of_string(
    char* _a4                              // _cfa_4
)
{// addr = 0x080616FB
    __edx = 32;
    return caml_copy_int32(parse_intnat(_a4, 32));
}

caml_int32_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061718
    _unknown_ _v14;                        // _cfa_fffffff2
    short _v16;                            // _cfa_fffffff0

    asm("fnstcw word [ebp-0xa]");
    _v16 = 12;
    asm("fldcw word [ebp-0xc]");
    asm("fistp dword [esp]");
    asm("fldcw word [ebp-0xa]");
    return caml_copy_int32();
}

caml_int32_of_int(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08061740
    return caml_copy_int32(_a4 >> 1);
}

caml_int32_shift_right_unsigned(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061755
    return caml_copy_int32( *(_a4 + 4) >> _a8 >> 1);
}

caml_int32_shift_right(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061772
    return caml_copy_int32( *(_a4 + 4) >> _a8 >> 1);
}

caml_int32_shift_left(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806178F
    return caml_copy_int32( *(_a4 + 4) << _a8 >> 1);
}

caml_int32_xor(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080617AC
    return caml_copy_int32( *(_a8 + 4) ^  *(_a4 + 4));
}

caml_int32_or(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080617C8
    return caml_copy_int32( *(_a8 + 4) |  *(_a4 + 4));
}

caml_int32_and(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080617E4
    return caml_copy_int32( *(_a8 + 4) &  *(_a4 + 4));
}

caml_int32_mod(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061800
    signed int _t14;                       // _t14

    _t14 =  *(_a4 + 4);
    __ecx =  *(_a8 + 4);
    if(__ecx == 0) {
        caml_raise_zero_divide();
    }
    if(_t14 != -2147483648 || __ecx != -1) {
        return caml_copy_int32(_t14 % __ecx);
    } else {
        return caml_copy_int32(0);
    }
}

caml_int32_div(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061847
    intOrPtr _t7;                          // _t7
    signed int _t12;                       // _t12
    signed int _t13;                       // _t13

    _t7 = _a4;
    _t13 =  *(_t7 + 4);
    _t12 =  *(_a8 + 4);
    if(_t12 == 0) {
        _t7 = caml_raise_zero_divide();
    }
    if(_t13 != -2147483648 || _t12 != -1) {
        return caml_copy_int32(_t13 / _t12);
    } else {
        return _t7;
    }
}

caml_int32_mul(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08061880
    return caml_copy_int32( *(_a8 + 4) *  *(_a4 + 4));
}

caml_int32_sub(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806189D
    return caml_copy_int32( *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_a8 + 4)));
}

caml_int32_add(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080618B9
    return caml_copy_int32( *((intOrPtr*)(_a8 + 4)) +  *((intOrPtr*)(_a4 + 4)));
}

caml_int32_neg(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080618D5
    return caml_copy_int32( ~( *(_a4 + 4)));
}

caml_int_of_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x080618F0
    _unknown_ _v6;                         // _cfa_fffffffa
    short _v8;                             // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4

    asm("fnstcw word [ebp-0x2]");
    _v8 = 12;
    asm("fldcw word [ebp-0x4]");
    asm("fistp dword [ebp-0x8]");
    asm("fldcw word [ebp-0x2]");
    return _v12 + _v12 + 1;
}

caml_eq_float(
    _unknown_ __edx,                       // r3
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x0806191A
    asm("fucomip st0, st1");
    st0 =  *_a8;
    return (__eflags == 0 & __eflags ?_? 0 & 255) + (__eflags == 0 & __eflags ?_? 0 & 255) + 1;
}

caml_neq_float(
    _unknown_ __edx,                       // r3
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x0806193C
    asm("fucomip st0, st1");
    st0 =  *_a8;
    return ((__eflags != 0 | __eflags ?_? 0) & 255) + ((__eflags != 0 | __eflags ?_? 0) & 255) + 1;
}

caml_le_float(
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806195E
    signed int _t4;                        // _t4

    _t4 = _a8;
    asm("fucomip st0, st1");
    st0 =  *_t4;
    asm("sbb eax, eax");
    return (_t4 & -2) + 3;
}

caml_lt_float(
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x08061979
    asm("fucomip st0, st1");
    st0 =  *_a8;
    return (__eflags > 0 & 255) + (__eflags > 0 & 255) + 1;
}

caml_ge_float(
    _unknown_ _a4,                         // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061996
    signed int _t4;                        // _t4

    _t4 = _a8;
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    st0 =  *_t4;
    asm("sbb eax, eax");
    return (_t4 & -2) + 3;
}

caml_gt_float(
    _unknown_ __eflags,                    // r9
    _unknown_ _a4,                         // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x080619B3
    asm("fxch st0, st1");
    asm("fucomip st0, st1");
    st0 =  *_a8;
    return (__eflags > 0 & 255) + (__eflags > 0 & 255) + 1;
}

caml_float_compare(
    _unknown_ _a4,                         // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x080619D2
    long long _t9;                         // _t9

    _t9 =  *_a8;
    asm("fxch st0, st1");
    asm("fucomi st0, st1");
    if(__eflags != 0) {
        asm("fxch st0, st1");
L4:
        asm("fucomi st0, st1");
        if(__eflags > 0) {
            st0 = _t9;
            st0 = _t9;
L14:
            return -1;
        }
        asm("fxch st0, st1");
        asm("fucomi st0, st1");
        if(__eflags > 0) {
            st0 = _t9;
            st0 = _t9;
L17:
            return 3;
        }
        asm("fucomip st0, st0");
        if(__eflags != 0 || __eflags != 0) {
            asm("fucomip st0, st0");
            if(__eflags != 0) {
L12:
                return 1;
            }
            if(__eflags == 0) {
                goto L14;
            }
            goto L12;
        } else {
            st0 = _t9;
            goto L17;
        }
    }
    if(__eflags == 0) {
        st0 = _t9;
        st0 = _t9;
        goto L12;
    }
    asm("fxch st0, st1");
    goto L4;
}

caml_init_ieee_floats(
    _unknown_ __eax                        // r0
)
{// addr = 0x08061A37
    __eax = __eax;
    return __eax;
}

caml_classify_float(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08061A3C
    signed int _t4;                        // _t4

    _t4 = _a4;
     *__esp =  *_t4;
    __fpclassify();
    __edx = _t4;
    if(__edx <= 3) {
        return  *((intOrPtr*)(__edx * 4 + "\t"));
    }
    return 1;
}

caml_log1p(
    _unknown_ __eax,                       // r0
    long long _a4                          // _cfa_4
)
{// addr = 0x08061A64
    __eax = __eax;
     *__esp = _a4;
    log1p();
    return __eax;
}

caml_expm1(
    _unknown_ __eax,                       // r0
    long long _a4                          // _cfa_4
)
{// addr = 0x08061A77
    __eax = __eax;
     *__esp = _a4;
    expm1();
    return __eax;
}

intOrPtr caml_format_float(
    signed char* _a4,                      // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x08061A8A
    char _v398;                            // _cfa_fffffe72
    long long _v420;                       // _cfa_fffffe5c
    signed char* _v424;                    // _cfa_fffffe58
    _unknown_ __ebx;                       // r1
    signed char* __edi;                    // r4
    _unknown_ __esi;                       // r5
    signed int _t17;                       // _t17
    signed int _t21;                       // _t21
    signed int _t22;                       // _t22
    signed int _t24;                       // _t24
    signed char* _t30;                     // _t30
    intOrPtr _t32;                         // _t32
    intOrPtr _t33;                         // _t33
    signed char* _t35;                     // _t35

    __edi = _a4;
    _t30 = __edi;
    _t17 =  *__edi & 255;
    if(_t17 == 0) {
L16:
        _v420 =  *_a8;
        _v424 = __edi;
         *__esp =  &_v398;
        sprintf();
        _t32 = caml_copy_string( &_v398, __edi, _t33,  &_v398);
L15:
        return _t32;
    }
    _t21 = _t17 - 48;
    if(_t21 > 9) {
        while(1) {
            _t30 =  &(_t30[1]);
            _t22 =  *_t30 & 255;
            if(_t22 == 0) {
                break;
            }
            _t21 = _t22 - 48;
            if(_t21 > 9) {
                continue;
            }
L4:
            _v420 = 10;
            _v424 = 0;
             *__esp = _t30;
            strtol();
            _t33 = _t21 + 350 - 350 < 0 ? 350 : _t21 + 350;
            _t24 =  *_t30 & 255;
            if(_t24 == 0) {
L12:
                if(_t33 <= 369) {
                    goto L16;
                }
                _t35 = caml_stat_alloc(_t24, _t33);
                _v420 =  *_a8;
                _v424 = __edi;
                 *__esp = _t35;
                sprintf();
                _t32 = caml_copy_string(_t30, __edi, _t35, _t35);
                if(_t35 !=  &_v398) {
                    caml_stat_free(_t35);
                }
                goto L15;
            }
            if(_t24 != 46) {
                while(1) {
                    _t30 =  &(_t30[1]);
                    _t24 =  *_t30 & 255;
                    if(_t24 == 0) {
                        goto L12;
                    }
                    if(_t24 != 46) {
                        continue;
                    }
L10:
                    _v420 = 10;
                    _v424 = 0;
                     *__esp = _t30;
                    strtol();
                    _t33 = _t33 - _t24 < 0 ? _t24 : _t33;
                    goto L12;
                }
                goto L12;
            }
            goto L10;
        }
        goto L16;
    }
    goto L4;
}

caml_copy_double(
    long long _a4                          // _cfa_4
)
{// addr = 0x08061BAA
    long long _v20;                        // _cfa_ffffffec
    intOrPtr _t5;                          // _t5
    long long* _t8;                        // _t8

    _t13 = _a4;
    _v20 = _a4;
    __edx = caml_young_ptr;
    _t5 = __edx - 12;
    caml_young_ptr = _t5;
    if(_t5 < caml_young_limit) {
        caml_young_ptr = __edx;
        caml_minor_collection(__ebx, __esi, _t13);
        caml_young_ptr = caml_young_ptr - 12;
    }
     *caml_young_ptr = 3069;
    _t8 = caml_young_ptr + 4;
     *_t8 = _v20;
    return _t8;
}

caml_log1p_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061BF8
    __fp0 =  *_a4;
     *__esp =  *_a4;
    caml_log1p(_a4);
     *__esp = __fp0;
    return caml_copy_double();
}

caml_expm1_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061C15
    __fp0 =  *_a4;
     *__esp =  *_a4;
    caml_expm1(_a4);
     *__esp = __fp0;
    return caml_copy_double();
}

caml_ceil_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061C32
    __fp0 =  *_a4;
     *__esp = __fp0;
    ceil();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_atan2_float(
    long long* _a4,                        // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x08061C4F
    long long _v20;                        // _cfa_ffffffec
    long long _t8;                         // _t8

    _v20 =  *_a8;
    _t8 =  *_a4;
     *__esp = _t8;
    atan2();
     *__esp = _t8;
    return caml_copy_double();
}

caml_atan_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061C75
    __fp0 =  *_a4;
     *__esp = __fp0;
    atan();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_acos_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061C92
    __fp0 =  *_a4;
     *__esp = __fp0;
    acos();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_asin_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061CAF
    __fp0 =  *_a4;
     *__esp = __fp0;
    asin();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_tanh_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061CCC
    __fp0 =  *_a4;
     *__esp = __fp0;
    tanh();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_tan_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061CE9
    __fp0 =  *_a4;
     *__esp = __fp0;
    tan();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_cosh_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061D06
    __fp0 =  *_a4;
     *__esp = __fp0;
    cosh();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_cos_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061D23
    __fp0 =  *_a4;
     *__esp = __fp0;
    cos();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_sinh_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061D40
    __fp0 =  *_a4;
     *__esp = __fp0;
    sinh();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_sin_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061D5D
    __fp0 =  *_a4;
     *__esp = __fp0;
    sin();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_power_float(
    long long* _a4,                        // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x08061D7A
    long long _v20;                        // _cfa_ffffffec
    long long _t8;                         // _t8

    _v20 =  *_a8;
    _t8 =  *_a4;
     *__esp = _t8;
    pow();
     *__esp = _t8;
    return caml_copy_double();
}

caml_sqrt_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061DA0
    long long _t5;                         // _t5

    _t5 = st0;
    asm("fsqrt");
    asm("fucomi st0, st0");
    if(__eflags != 0) {
        st0 = _t5;
        goto L4;
    } else {
        if(__eflags == 0) {
            st1 = _t5;
        } else {
            st0 = _t5;
L4:
             *__esp = _t5;
            sqrt();
        }
    }
     *__esp = _t5;
    return caml_copy_double();
}

caml_modf_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061DD1
    long long _v20;                        // _cfa_ffffffec
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    _unknown_ _v56;                        // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    char* _v76;                            // _cfa_ffffffb4
    char* _v80;                            // _cfa_ffffffb0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    char* _v116;                           // _cfa_ffffff8c
    char* __ebx;                           // r1
    intOrPtr* _t42;                        // _t42
    long long _t47;                        // _t47

    __ebx = caml_local_roots;
    _v52 = __ebx;
    _v44 = 1;
    _v48 = 1;
    _v40 =  &_a4;
    _v56 = 0;
    _v60 = 0;
    _v64 = 0;
    _v96 =  &_v52;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 3;
    _v84 =  &_v56;
    _v80 =  &_v60;
    _v76 =  &_v64;
    _v116 =  &_v20;
    _t47 =  *_a4;
     *__esp = _t47;
    modf();
     *__esp = _t47;
    _v60 = caml_copy_double();
     *__esp = _v20;
    _v64 = caml_copy_double();
    _t42 = caml_alloc_tuple(2);
    _v56 = _t42;
     *_t42 = _v60;
     *((intOrPtr*)(_v56 + 4)) = _v64;
    caml_local_roots = __ebx;
    return _v56;
}

caml_log10_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061E91
    __fp0 =  *_a4;
     *__esp = __fp0;
    log10();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_log_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061EAE
    __fp0 =  *_a4;
     *__esp = __fp0;
    log();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_ldexp_float(
    long long* _a4,                        // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08061ECB
    signed int _v20;                       // _cfa_ffffffec

    _v20 = _a8 >> 1;
    __fp0 =  *_a4;
     *__esp = __fp0;
    ldexp();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_frexp_float(
    _unknown_ _a4                          // _cfa_4
)
{// addr = 0x08061EF1
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v48;                        // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    char _v84;                             // _cfa_ffffffac
    char _v88;                             // _cfa_ffffffa8
    char* _v100;                           // _cfa_ffffff9c
    char* __ebx;                           // r1
    intOrPtr* _t37;                        // _t37

    __ebx = caml_local_roots;
    _v44 = __ebx;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    _v48 = 0;
    _v52 = 0;
    _v84 =  &_v44;
    caml_local_roots =  &_v84;
    _v76 = 1;
    _v80 = 2;
    _v72 =  &_v48;
    _v68 =  &_v52;
    _v100 =  &_v88;
    __fp0 =  *_a4;
     *__esp = __fp0;
    frexp();
     *__esp = __fp0;
    _v52 = caml_copy_double();
    _t37 = caml_alloc_tuple(2);
    _v48 = _t37;
     *_t37 = _v52;
     *((intOrPtr*)(_v48 + 4)) = _v88 + _v88 + 1;
    caml_local_roots = __ebx;
    return _v48;
}

caml_fmod_float(
    _unknown_ _a4,                         // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x08061F9A
    long long _v20;                        // _cfa_ffffffec
    long long _t10;                        // _t10

    _t10 = st2;
    do {
        asm("fprem");
        asm("fnstsw ax");
        asm("sahf");
    } while(__eflags != 0);
    st1 = _t10;
    asm("fucomi st0, st0");
    if(__eflags != 0) {
        st0 = _t10;
        goto L6;
    } else {
        if(__eflags == 0) {
            st1 = _t10;
            st1 = _t10;
        } else {
            st0 = _t10;
L6:
            _v20 = _t10;
             *__esp = _t10;
            fmod();
        }
    }
     *__esp = _t10;
    return caml_copy_double();
}

caml_floor_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061FE0
    __fp0 =  *_a4;
     *__esp = __fp0;
    floor();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_exp_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08061FFD
    __fp0 =  *_a4;
     *__esp = __fp0;
    exp();
     *__esp = __fp0;
    return caml_copy_double();
}

caml_div_float(
    signed long long* _a4,                 // _cfa_4
    signed long long* _a8                  // _cfa_8
)
{// addr = 0x0806201A
     *__esp =  *_a4 /  *_a8;
    return caml_copy_double();
}

caml_mul_float(
    signed long long* _a4,                 // _cfa_4
    signed long long* _a8                  // _cfa_8
)
{// addr = 0x08062034
     *__esp =  *_a4 *  *_a8;
    return caml_copy_double();
}

caml_sub_float(
    long long* _a4,                        // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x0806204E
     *__esp =  *_a4 -  *_a8;
    return caml_copy_double();
}

caml_add_float(
    long long* _a4,                        // _cfa_4
    long long* _a8                         // _cfa_8
)
{// addr = 0x08062068
     *__esp =  *_a4 +  *_a8;
    return caml_copy_double();
}

caml_abs_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08062082
    asm("fabs");
     *__esp =  *_a4;
    return caml_copy_double();
}

caml_neg_float(
    long long* _a4                         // _cfa_4
)
{// addr = 0x08062099
    asm("fchs");
     *__esp =  *_a4;
    return caml_copy_double();
}

caml_float_of_int(
    long long __fp0,                       // r28
    signed int _a4                         // _cfa_4
)
{// addr = 0x080620B0
    signed int _v16;                       // _cfa_fffffff0

    __fp0 = __fp0;
    _v16 = _a4 >> 1;
    asm("fild dword [ebp-0xc]");
     *__esp = __fp0;
    return caml_copy_double();
}

signed int caml_float_of_string(
    _unknown_ __eax,                       // r0
    _unknown_ __ebx,                       // r1
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    signed char* __fp0,                    // r28
    signed char* _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080620CB
    intOrPtr _v0;                          // _cfa_0
    char _v92;                             // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    signed char* _v116;                    // _cfa_ffffff8c
    signed char* _v120;                    // _cfa_ffffff88
    signed int _v132;                      // _cfa_ffffff7c
    signed char* _v136;                    // _cfa_ffffff78
    char* _v276;                           // _cfa_fffffeec
    signed char* _t32;                     // _t32
    signed char* _t35;                     // _t35
    signed char* _t37;                     // _t37
    _unknown_ _t47;                        // _t47
    _unknown_ _t55;                        // _t55
    _unknown_ _t60;                        // _t60
    signed int _t61;                       // _t61
    signed int _t63;                       // _t63
    signed int _t64;                       // _t64
    signed char* _t68;                     // _t68
    signed char* _t69;                     // _t69
    signed char* _t71;                     // _t71
    signed char* _t72;                     // _t72
    signed int _t74;                       // _t74
    signed char* _t75;                     // _t75
    _unknown_ _t76;                        // _t76
    signed char** _t77;                    // _t77

    _push(__edi);
    _push(__esi);
    _push(__ebx);
    __esp = __esp - 124;
    _t71 = _a4;
     *__esp = _t71;
    L36();
    _t60 = __eax;
    _t68 =  &_v92;
    if(__eax > 63) {
        _t68 = caml_stat_alloc(__eax + 1, __eax + 1);
    }
    _t32 = _t71;
    _t72 = _t68;
    while(_t60 != 0) {
        _t63 =  *_t32 & 255;
        if(_t63 != 95) {
             *_t72 = _t63;
            _t72 =  &(_t72[1]);
        }
        _t32 =  &(_t32[1]);
        _t60 = _t60 - 1;
    }
     *_t72 = 0;
    if(_t72 == _t68) {
L12:
        if(_t68 !=  &_v92) {
            caml_stat_free(_t68);
        }
         *__esp = "float_of_string";
        caml_failwith();
        _push(_t76);
        _t77 = __esp;
        _push(_t68);
        _push(_t72);
        _push(_t60);
        __esp = __esp - 124;
        _t74 = _v132 >> 1;
        _t35 = _v136;
         *__esp = _t35;
        L36();
        if(_t74 < 0 || _t35 <= _t74) {
L22:
            _t61 = 0;
            _t69 =  &_v96;
        } else {
            _t61 = _a8 >> 1;
            if(_t61 <= 0 || _t61 > _t35 - _t74) {
                goto L22;
            } else {
                if(_t61 > 63) {
                    _t69 = caml_stat_alloc(_t61 + 1, _t61 + 1);
                } else {
                    _t69 =  &_v96;
                }
            }
        }
        _t37 = _t74 + _v0;
        _t75 = _t69;
        while(_t61 != 0) {
            _t64 =  *_t37 & 255;
            if(_t64 != 95) {
                 *_t75 = _t64;
                _t75 =  &(_t75[1]);
            }
            _t37 =  &(_t37[1]);
            _t61 = _t61 - 1;
        }
         *_t75 = 0;
        if(_t75 == _t69) {
L33:
            if(_t69 !=  &_v96) {
                caml_stat_free(_t69);
            }
             *__esp = "float_of_string";
            caml_failwith();
            _push(_t77);
            return ( *(_v276 - 4) >> 10) * 4 - 1 -  *((char*)(( *(_v276 - 4) >> 10) * 4 - 1 + _v276));
        } else {
            _v276 =  &_v100;
             *__esp = _t69;
            strtod();
            _v120 = __fp0;
            if(_v100 != _t75) {
                goto L33;
            } else {
                if(_t69 !=  &_v96) {
                    caml_stat_free(_t69);
                }
                 *__esp = _v120;
                _t47 = caml_copy_double();
                __esp =  &(__esp[0x1f]);
                _pop(__ebx);
                _pop(__esi);
                _pop(__edi);
                return _t47;
            }
        }
    } else {
        _v136 =  &_v96;
         *__esp = _t68;
        strtod();
        _v116 = __fp0;
        if(_v96 != _t72) {
            goto L12;
        } else {
            if(_t68 !=  &_v92) {
                caml_stat_free(_t68);
            }
             *__esp = _v116;
            _t55 = caml_copy_double();
            __esp =  &(__esp[0x1f]);
            _pop(__ebx);
            _pop(__esi);
            _pop(__edi);
            return _t55;
        }
    }
}

signed int caml_float_of_substring(
    _unknown_ __ebx,                       // r1
    _unknown_ __edi,                       // r4
    _unknown_ __esi,                       // r5
    long long __fp0,                       // r28
    long long _a4,                         // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x0806216E
    char _v92;                             // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    long long _v116;                       // _cfa_ffffff8c
    char* _v136;                           // _cfa_ffffff78
    long long _t21;                        // _t21
    signed char* _t23;                     // _t23
    _unknown_ _t33;                        // _t33
    signed int _t39;                       // _t39
    signed int _t41;                       // _t41
    signed int _t48;                       // _t48
    char* _t49;                            // _t49
    _unknown_ _t50;                        // _t50

    _push(__edi);
    _push(__esi);
    _push(__ebx);
    __esp = __esp - 124;
    _t48 = _a8 >> 1;
    _t21 = _a4;
     *__esp = _t21;
    L21();
    if(_t48 < 0 || _t21 <= _t48) {
L7:
        _t39 = 0;
        _t45 =  &_v92;
    } else {
        _t39 = _a12 >> 1;
        if(_t39 <= 0 || _t39 > _t21 - _t48) {
            goto L7;
        } else {
            if(_t39 > 63) {
                 &_v92 = caml_stat_alloc(_t39 + 1, _t39 + 1);
            } else {
                _t45 =  &_v92;
            }
        }
    }
    _t23 = _t48 + _a4;
    _t49 =  &_v92;
    while(_t39 != 0) {
        _t41 =  *_t23 & 255;
        if(_t41 != 95) {
             *_t49 = _t41;
            _t49 = _t49 + 1;
        }
        _t23 =  &(_t23[1]);
        _t39 = _t39 - 1;
    }
     *_t49 = 0;
    if(_t49 == _t45) {
L18:
        if(_t45 !=  &_v92) {
            caml_stat_free( &_v92);
        }
         *__esp = "float_of_string";
        caml_failwith();
        _push(_t50);
        return ( *(_v136 - 4) >> 10) * 4 - 1 -  *((char*)(( *(_v136 - 4) >> 10) * 4 - 1 + _v136));
    } else {
        _v136 =  &_v96;
         *__esp =  &_v92;
        strtod();
        _v116 = __fp0;
        if(_v96 != _t49) {
            goto L18;
        } else {
            if(_t45 !=  &_v92) {
                caml_stat_free( &_v92);
            }
             *__esp = _v116;
            _t33 = caml_copy_double();
            __esp = __esp + 124;
            _pop(__ebx);
            _pop(__esi);
            _pop(__edi);
            return _t33;
        }
    }
}

signed int caml_string_length(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062240
    return ( *(_a4 - 4) >> 10) * 4 - 1 -  *((char*)(( *(_a4 - 4) >> 10) * 4 - 1 + _a4));
}

caml_ml_string_length(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806225B
    return ( *(_a4 - 4) >> 10) * 4 - 1 -  *((char*)(( *(_a4 - 4) >> 10) * 4 - 1 + _a4)) + ( *(_a4 - 4) >> 10) * 4 - 1 -  *((char*)(( *(_a4 - 4) >> 10) * 4 - 1 + _a4)) + 1;
}

caml_string_equal(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr* _a8                          // _cfa_8
)
{// addr = 0x0806227A
    _unknown_ __ebx;                       // r1
    unsigned int _t7;                      // _t7

    __ecx = _a4;
    __edx = _a8;
    if(__ecx == __edx) {
L7:
        return 3;
    }
    _t7 =  *(__ecx - 4) >> 10;
    if(_t7 !=  *(__edx - 4) >> 10) {
L8:
        return 1;
    }
    if(_t7 == 0) {
        goto L7;
    }
    if( *__ecx ==  *__edx) {
        while(1) {
            _t7 = _t7 - 1;
            if(_t7 == 0) {
                goto L7;
            }
            __ecx = __ecx + 4;
            __edx = __edx + 4;
            if( *__ecx !=  *__edx) {
                goto L8;
            }
        }
        goto L7;
    }
    goto L8;
}

caml_string_notequal(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr* _a8                          // _cfa_8
)
{// addr = 0x080622C4
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return 4 - caml_string_equal(_a4, _a8);
}

caml_bitvect_test(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080622E7
    return ( *((_a8 >> 4) + _a4) & 255 & 1 << (_a8 >> 1 & 7)) + ( *((_a8 >> 4) + _a4) & 255 & 1 << (_a8 >> 1 & 7)) + 1;
}

caml_is_printable(
    intOrPtr* __eax,                       // r0
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806230D
    intOrPtr _v24;                         // _cfa_ffffffe8

    if(locale_is_set.2848 == 0) {
        _v24 = 134661416;
         *__esp = 0;
        setlocale();
        locale_is_set.2848 = 1;
    }
    __ctype_b_loc();
    asm("sbb eax, eax");
    return ( *( *__eax + (_a4 >> 1) * 2) & 0x4000) + 3;
}

caml_fill_string(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806235C
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8

    _v20 = _a12 >> 1;
    _v24 = _a16 >> 1;
     *__esp = (_a8 >> 1) + _a4;
    memset();
    return 1;
}

caml_blit_string(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    signed int _a16,                       // _cfa_10
    signed int _a20                        // _cfa_14
)
{// addr = 0x0806238B
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8

    _v20 = _a20 >> 1;
    _v24 = (_a8 >> 1) + _a4;
     *__esp = (_a16 >> 1) + _a12;
    memmove();
    return 1;
}

caml_string_compare(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080623BD
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ _t14;                        // _t14
    signed int _t16;                       // _t16
    _unknown_ _t21;                        // _t21
    _unknown_ _t38;                        // _t38

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t23 = _a4;
    _t28 = _a8;
    if(_a4 == _a8) {
L5:
        _t14 = 1;
    } else {
        _v20 = caml_string_length(_t23);
        _t16 = caml_string_length(_t28);
        __edx = _t16;
        _t35 = (_t16 - _v20 <= 0 ? __edx : _v20) - (_t16 - _v20 <= 0 ? __edx : _v20);
        asm("repe cmpsb");
        _t21 = ((_t16 - _v20 <= 0 ? __edx : _v20) - (_t16 - _v20 <= 0 ? __edx : _v20) > 0) - (_t35 > 0);
        if(_t21 < 0) {
L6:
            _t14 = -1;
        } else {
            if(_t21 > 0) {
L7:
                _t14 = 3;
            } else {
                _t38 = _v20 - __edx;
                if(_t38 < 0) {
                    goto L6;
                } else {
                    if(_t38 > 0) {
                        goto L7;
                    } else {
                        goto L5;
                    }
                }
            }
        }
    }
    return _t14;
}

caml_string_greaterequal(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08062436
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return (caml_string_compare(__ebx, __edi, __esi, _a4, _a8) > 0 & 255) + (caml_string_compare(__ebx, __edi, __esi, _a4, _a8) > 0 & 255) + 1;
}

caml_string_greaterthan(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806245C
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return (caml_string_compare(__ebx, __edi, __esi, _a4, _a8) - 1 > 0 & 255) + (caml_string_compare(__ebx, __edi, __esi, _a4, _a8) - 1 > 0 & 255) + 1;
}

caml_string_lessequal(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08062483
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return (caml_string_compare(__ebx, __edi, __esi, _a4, _a8) - 2 < 0 & 255) + (caml_string_compare(__ebx, __edi, __esi, _a4, _a8) - 2 < 0 & 255) + 1;
}

caml_string_lessthan(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080624AA
    _unknown_ _v8;                         // _cfa_fffffff8 (outparam)

    return (caml_string_compare(__ebx, __edi, __esi, _a4, _a8) <= 0 & 255) + (caml_string_compare(__ebx, __edi, __esi, _a4, _a8) <= 0 & 255) + 1;
}

caml_string_set(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080624D0
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _t16;                       // _t16
    intOrPtr _t19;                         // _t19

    _v12 = __ebx;
    _v8 = __esi;
    _t19 = _a4;
    _t16 = _a8 >> 1;
    if(__eflags < 0 || _t16 >= caml_string_length(_t19)) {
        caml_array_bound_error();
    }
     *((char*)(_t16 + _t19)) = _a12 >> 1;
    return 1;
}

caml_string_get(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806250E
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _t16;                       // _t16
    intOrPtr _t19;                         // _t19

    _v12 = __ebx;
    _v8 = __esi;
    _t19 = _a4;
    _t16 = _a8 >> 1;
    if(__eflags < 0 || _t16 >= caml_string_length(_t19)) {
        caml_array_bound_error();
    }
    return ( *(_t16 + _t19) & 255) + ( *(_t16 + _t19) & 255) + 1;
}

intOrPtr caml_create_string(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    _unknown_ __fp0,                       // r28
    signed int _a4                         // _cfa_4
)
{// addr = 0x08062547
    __fp0 = __fp0;
    __esi = __esi;
    __edi = __edi;
    __ebx = __ebx;
    _t3 = _a4 >> 1;
    if(_a4 >> 1 > 16777211) {
         *__esp = "String.create";
        _t3 = caml_invalid_argument();
    }
    return caml_alloc_string(__ebx, __edi, __esi, __fp0, _t3);
}

caml_array_unsafe_set_float(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    long long* _a12                        // _cfa_c
)
{// addr = 0x08062570
     *((long long*)(_a4 + (_a8 >> 1) * 8)) =  *_a12;
    return 1;
}

signed int caml_make_array(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806258A
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    unsigned int _v64;                     // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    signed int _t49;                       // _t49
    signed int _t52;                       // _t52
    char* _t54;                            // _t54
    unsigned int _t59;                     // _t59
    unsigned int _t70;                     // _t70

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t54 = caml_local_roots;
    _v60 = _t54;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _v64 = 0;
    _v68 = 0;
    _v100 =  &_v60;
    caml_local_roots =  &_v100;
    _v92 = 1;
    _v96 = 2;
    _v88 =  &_v64;
    _v84 =  &_v68;
    _t49 = _a4;
    _t70 =  *(_t49 - 4) >> 10;
    if(_t70 != 0) {
        _t59 =  *_t49;
        if((_t59 & 1) != 0) {
L5:
            caml_local_roots = _t54;
L9:
            return _t49;
        }
        _v64 = _t59;
        if(( *( *((intOrPtr*)((_t59 >> 23) * 4 +  &caml_page_table)) + (_t59 >> 12 & 2047)) & 7) == 0 ||  *(_t59 - 4) != 253) {
            goto L5;
        } else {
            _v68 = caml_alloc_small(_t54, _t70, _t70 + _t70, 254);
            _t52 = 0;
            do {
                 *((long long*)(_v68 + _t52 * 8)) =  *((long long*)( *((intOrPtr*)(_a4 + _t52 * 4))));
                _t52 = _t52 + 1;
            } while(_t70 > _t52);
            caml_local_roots = _t54;
            _t49 = _v68;
            goto L9;
        }
    }
    caml_local_roots = _t54;
    goto L9;
}

caml_array_unsafe_get_float(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806267C
    long long _v20;                        // _cfa_ffffffec
    intOrPtr _t8;                          // _t8
    intOrPtr _t9;                          // _t9
    long long* _t12;                       // _t12
    signed int _t15;                       // _t15
    intOrPtr* _t16;                        // _t16

    _t15 = _a8 >> 1;
    _t8 = _a4;
    _t20 =  *((long long*)(_t8 + _t15 * 8));
    _v20 =  *((long long*)(_t8 + _t15 * 8));
    _t16 = caml_young_ptr;
    _t9 = _t16 - 12;
    caml_young_ptr = _t9;
    if(_t9 < caml_young_limit) {
        caml_young_ptr = _t16;
        caml_minor_collection(__ebx, __esi, _t20);
        caml_young_ptr = caml_young_ptr - 12;
    }
     *caml_young_ptr = 3069;
    _t12 = caml_young_ptr + 4;
     *_t12 = _v20;
    return _t12;
}

caml_array_unsafe_get(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080626D2
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr _t7;                          // _t7
    signed int _t10;                       // _t10

    _t7 = _a4;
    _t10 = _a8;
    if( *((char*)(_t7 - 4)) != 254) {
        return  *((intOrPtr*)(_t7 + (_t10 >> 1) * 4));
    }
    return caml_array_unsafe_get_float(_t7, _t10);
}

signed int caml_make_vect(
    signed int __eflags,                   // r9
    char _a4,                              // _cfa_4
    unsigned int _a8                       // _cfa_8
)
{// addr = 0x080626F9
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    unsigned int _v116;                    // _cfa_ffffff8c
    _unknown_ _v136;                       // _cfa_ffffff78 (outparam)
    _unknown_ __ebx;                       // r1
    char* __edi;                           // r4
    _unknown_ __esi;                       // r5
    unsigned int _t60;                     // _t60
    signed int _t71;                       // _t71
    signed int _t75;                       // _t75
    _unknown_ _t76;                        // _t76
    signed int _t78;                       // _t78
    intOrPtr _t79;                         // _t79
    signed int _t80;                       // _t80
    signed int _t87;                       // _t87
    signed int _t89;                       // _t89
    signed int _t94;                       // _t94
    signed int _t95;                       // _t95
    signed int _t96;                       // _t96
    _unknown_ _t97;                        // _t97

    __eflags = __eflags;
    __edi = caml_local_roots;
    _v64 = 0;
    _v96 =  &_v60;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 1;
    _v84 =  &_v64;
    _t94 = _a4 >> 1;
    if(__eflags != 0) {
        _v60 = __edi;
        _v52 = 1;
        _v56 = 2;
        _v48 =  &_a4;
        _v44 =  &_a8;
        _t60 = _a8;
        _t89 = _t60 & 1;
        __eflags = _t89;
        if(_t89 != 0) {
L10:
            __eflags = _t94 - 4194303;
            if(_t94 > 4194303) {
                 *__esp = "Array.make";
                _t60 = caml_invalid_argument();
            }
            __eflags = _t94 - 255;
            if(_t94 > 255) {
                __eflags = _t89;
                if(_t89 != 0) {
L22:
                    _v64 = caml_alloc_shr(_t79, __edi, _t94, _t94, 0);
                    _t80 = 0;
                    do {
                        caml_initialize(_t80 * 4 + _v64, _a8);
                        _t80 = _t80 + 1;
                        __eflags = _t94 - _t80;
                    } while(_t94 > _t80);
                    _v64 = caml_check_urgent_gc(_v64);
                } else {
                    __eflags = _t60 - caml_young_end;
                    if(_t60 >= caml_young_end) {
                        goto L22;
                    } else {
                        __eflags = _t60 - caml_young_start;
                        if(_t60 <= caml_young_start) {
                            goto L22;
                        } else {
                            caml_minor_collection(_t79, _t94, _t97);
                            _v64 = caml_alloc_shr(_t79, __edi, _t94, _t94, 0);
                            _t95 = _t94 << 2;
                            __eflags = _t95;
                            _t71 = 0;
                            do {
                                 *(_v64 + _t71) = _a8;
                                _t71 = _t71 + 4;
                                __eflags = _t71 - _t95;
                            } while(_t71 != _t95);
                            _v64 = caml_check_urgent_gc(_v64);
                        }
                    }
                }
            } else {
                _v64 = caml_alloc_small(_t79, _t94, _t94, 0);
                _t96 = _t94 << 2;
                __eflags = _t96;
                _t75 = 0;
                do {
                     *(_t75 + _v64) = _a8;
                    _t75 = _t75 + 4;
                    __eflags = _t75 - _t96;
                } while(_t75 != _t96);
            }
        } else {
            _v116 = _t60;
            _t87 = _t60 >> 12 & 2047;
            _t79 =  *((intOrPtr*)((_t60 >> 23) * 4 +  &caml_page_table));
            __eflags =  *(_t79 + _t87) & 7;
            if(( *(_t79 + _t87) & 7) == 0) {
                goto L10;
            } else {
                __eflags =  *(_t60 - 4) - 253;
                if( *(_t60 - 4) != 253) {
                    goto L10;
                } else {
                    _t98 =  *_t60;
                    _v116 =  *_t60;
                    _t76 = _t94 + _t94;
                    __eflags = _t76 - 4194303;
                    if(_t76 > 4194303) {
                         *__esp = "Array.make";
                        _t76 = caml_invalid_argument();
                    }
                    _v64 = caml_alloc(_t79, __edi, _t94, _t98, _t76, 254);
                    _t78 = 0;
                    do {
                         *((long long*)(_v64 + _t78 * 8)) = _v116;
                        _t78 = _t78 + 1;
                        __eflags = _t94 - _t78;
                    } while(_t94 > _t78);
                }
            }
        }
    } else {
        _v64 = 134721380;
    }
    caml_local_roots = __edi;
    return _v64;
}

caml_array_unsafe_set_addr(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080628D1
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _t24;                         // _t24
    unsigned int _t33;                     // _t33
    intOrPtr _t38;                         // _t38
    unsigned int* _t39;                    // _t39
    signed int _t42;                       // _t42
    signed int _t45;                       // _t45

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t45 = _a12;
    _t33 = (_a8 >> 1 << 2) + _a4;
    _t42 =  *_t33;
     *_t33 = _t45;
    if(( *( *((intOrPtr*)((_t33 >> 23) * 4 +  &caml_page_table)) + (_t33 >> 12 & 2047)) & 1) != 0) {
        if(caml_gc_phase == 0) {
            _v40 = 0;
            caml_darken(_t42);
        }
        if((_t45 & 1) == 0) {
            _t24 = caml_young_end;
            if(_t45 < _t24) {
                _t38 = caml_young_start;
                if(_t45 > _t38 && ((_t42 & 1) != 0 || _t24 <= _t42 || _t38 >= _t42)) {
                    if( *134707432 >=  *134707436) {
                        caml_realloc_ref_table(_t33, _t42, _t45,  &caml_ref_table);
                    }
                    _t39 =  *134707432;
                     *_t39 = _t33;
                     *134707432 =  &(_t39[1]);
                }
            }
        }
    }
    return 1;
}

caml_array_unsafe_set(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    long long* _a12                        // _cfa_c
)
{// addr = 0x0806298B
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr _t9;                          // _t9

    __esi = __esi;
    __edi = __edi;
    __ebx = __ebx;
    _t9 = _a4;
    __edx = _a8;
    __ecx = _a12;
    if( *((char*)(_t9 - 4)) != 254) {
        return caml_array_unsafe_set_addr(__ebx, __edi, __esi, _t9, __edx, __ecx);
    }
    return caml_array_unsafe_set_float(_t9, __edx, __ecx);
}

caml_array_set_float(
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    long long* _a12                        // _cfa_c
)
{// addr = 0x080629C4
    signed int _t8;                        // _t8

    _t8 = _a8 >> 1;
    if(__eflags < 0) {
L2:
        _t8 = caml_array_bound_error();
    } else {
        __edx = _a4;
        if(_t8 >=  *(__edx - 4) >> 11) {
            goto L2;
        }
    }
     *((long long*)(__edx + _t8 * 8)) =  *_a12;
    return 1;
}

caml_array_set_addr(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080629F2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8
    signed int _t24;                       // _t24
    intOrPtr _t29;                         // _t29
    unsigned int _t35;                     // _t35
    intOrPtr _t39;                         // _t39
    intOrPtr _t43;                         // _t43
    unsigned int* _t44;                    // _t44
    signed int _t47;                       // _t47
    signed int _t50;                       // _t50

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t50 = _a12;
    _t24 = _a8 >> 1;
    if(__eflags < 0) {
L2:
        _t24 = caml_array_bound_error();
L3:
        _t35 = _t39 + _t24 * 4;
        _t47 =  *_t35;
         *_t35 = _t50;
        if(( *( *((intOrPtr*)((_t35 >> 23) * 4 +  &caml_page_table)) + (_t35 >> 12 & 2047)) & 1) != 0) {
            if(caml_gc_phase == 0) {
                _v40 = 0;
                caml_darken(_t47);
            }
            if((_t50 & 1) == 0) {
                _t29 = caml_young_end;
                if(_t50 < _t29) {
                    _t43 = caml_young_start;
                    if(_t50 > _t43 && ((_t47 & 1) != 0 || _t29 <= _t47 || _t43 >= _t47)) {
                        if( *134707432 >=  *134707436) {
                            caml_realloc_ref_table(_t35, _t47, _t50,  &caml_ref_table);
                        }
                        _t44 =  *134707432;
                         *_t44 = _t35;
                         *134707432 =  &(_t44[1]);
                    }
                }
            }
        }
        return 1;
    }
    _t39 = _a4;
    if(_t24 <  *(_t39 - 4) >> 10) {
        goto L3;
    }
    goto L2;
}

caml_array_set(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08062ABD
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr _t9;                          // _t9

    __esi = __esi;
    __edi = __edi;
    __ebx = __ebx;
    _t9 = _a4;
    __edx = _a8;
    __ecx = _a12;
    __eflags =  *((char*)(_t9 - 4)) - 254;
    if(__eflags != 0) {
        return caml_array_set_addr(__ebx, __edi, __esi, __eflags, _t9, __edx, __ecx);
    }
    return caml_array_set_float(__eflags, _t9, __edx, __ecx);
}

caml_array_get_float(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08062AF6
    long long _v20;                        // _cfa_ffffffec
    signed int _t10;                       // _t10
    intOrPtr _t11;                         // _t11
    long long* _t14;                       // _t14
    intOrPtr _t18;                         // _t18
    intOrPtr* _t19;                        // _t19

    __esi = __esi;
    __ebx = __ebx;
    _t10 = _a8 >> 1;
    if(__eflags < 0) {
L2:
        _t10 = caml_array_bound_error();
    } else {
        _t18 = _a4;
        if(_t10 >=  *(_t18 - 4) >> 11) {
            goto L2;
        }
    }
    _t25 =  *((long long*)(_t18 + _t10 * 8));
    _v20 =  *((long long*)(_t18 + _t10 * 8));
    _t19 = caml_young_ptr;
    _t11 = _t19 - 12;
    caml_young_ptr = _t11;
    if(_t11 < caml_young_limit) {
        caml_young_ptr = _t19;
        caml_minor_collection(__ebx, __esi, _t25);
        caml_young_ptr = caml_young_ptr - 12;
    }
     *caml_young_ptr = 3069;
    _t14 = caml_young_ptr + 4;
     *_t14 = _v20;
    return _t14;
}

caml_array_get_addr(
    _unknown_ __eflags,                    // r9
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08062B5D
    signed int _t7;                        // _t7

    _t7 = _a8 >> 1;
    if(__eflags < 0) {
L2:
        _t7 = caml_array_bound_error();
    } else {
        __edx = _a4;
        if(_t7 >=  *(__edx - 4) >> 10) {
            goto L2;
        }
    }
    return  *((intOrPtr*)(__edx + _t7 * 4));
}

caml_array_get(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08062B81
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __esi = __esi;
    __ebx = __ebx;
    _t6 = _a4;
    __edx = _a8;
    __eflags =  *((char*)(_a4 - 4)) - 254;
    if(__eflags != 0) {
        return caml_array_get_addr(__eflags, _t6, __edx);
    }
    return caml_array_get_float(__ebx, __esi, __eflags, _t6, __edx);
}

unlink_channel(
    intOrPtr __eax                         // r0
)
{// addr = 0x08062BB0
    intOrPtr _t9;                          // _t9
    intOrPtr _t10;                         // _t10
    intOrPtr _t12;                         // _t12
    intOrPtr _t13;                         // _t13

    _t9 = __eax;
    _t12 =  *((intOrPtr*)(__eax + 32));
    if(_t12 != 0) {
         *((intOrPtr*)(_t12 + 28)) =  *((intOrPtr*)(__eax + 28));
        _t13 =  *((intOrPtr*)(__eax + 28));
        if(_t13 != 0) {
            _t10 =  *((intOrPtr*)(__eax + 32));
             *((intOrPtr*)(_t13 + 32)) = _t10;
            return _t10;
        }
    } else {
        _t9 =  *((intOrPtr*)(caml_all_opened_channels + 28));
        caml_all_opened_channels = _t9;
        if(_t9 != 0) {
             *((intOrPtr*)(_t9 + 32)) = 0;
            return _t9;
        }
    }
    return _t9;
}

caml_channel_binary_mode()
{// addr = 0x08062BE9
    return 1;
}

caml_pos_out(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062BF3
    _unknown_ __ebx;                       // r1

    _t13 = _a4;
    asm("adc edx, ebx");
    return  *((intOrPtr*)(_a4 + 4)) +  *((intOrPtr*)(_t13 + 16)) - _t13 + 52;
}

caml_pos_in(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062C14
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4

    _v12 = __ebx;
    _v8 = __esi;
    _t10 = _a4;
    asm("sbb esi, ecx");
    return  *((intOrPtr*)(_a4 + 4)) -  *((intOrPtr*)(_t10 + 20)) -  *((intOrPtr*)(_t10 + 16));
}

compare_channel(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08062C46
    if( *((intOrPtr*)(_a4 + 4)) !=  *((intOrPtr*)(_a8 + 4))) {
        asm("sbb eax, eax");
        return 1;
    }
    return 0;
}

caml_ml_set_binary_mode()
{// addr = 0x08062C67
    return 1;
}

caml_ml_pos_in_64(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062C71
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_copy_int64(__ebx, __esi, caml_pos_in(__ebx, __esi,  *((intOrPtr*)(_a4 + 4))), __edx);
}

caml_ml_pos_out_64(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062C93
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __esi = __esi;
    __ebx = __ebx;
    return caml_copy_int64(__ebx, __esi, caml_pos_out( *((intOrPtr*)(_a4 + 4))), __edx);
}

caml_ml_pos_in(
    _unknown_ __edi,                       // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062CB5
    _unknown_ __ebx;                       // r1
    intOrPtr* _t7;                         // _t7
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11

    __esi = __esi;
    __edi = __edi;
    _t7 = caml_pos_in(_t10, __esi,  *((intOrPtr*)(_a4 + 4)));
    _t11 = _t7;
    if(__edx >= 0 && (__edx > 0 || _t7 > 1073741823)) {
        __errno_location();
         *_t7 = 75;
         *__esp = 1;
        caml_sys_error(__edi);
    }
    return _t11 + _t11 + 1;
}

caml_ml_pos_out(
    _unknown_ __edi,                       // r4
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062CFC
    intOrPtr* __ebx;                       // r1
    intOrPtr* _t7;                         // _t7

    __edi = __edi;
    _t7 = caml_pos_out( *((intOrPtr*)(_a4 + 4)));
    __ebx = _t7;
    if(__edx >= 0 && (__edx > 0 || _t7 > 1073741823)) {
        __errno_location();
         *_t7 = 75;
         *__esp = 1;
        caml_sys_error(__edi);
    }
    return __ebx + __ebx + 1;
}

caml_channel_descriptor(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062D43
    intOrPtr __ebx;                        // r1
    intOrPtr* _t6;                         // _t6

    _t6 =  *((intOrPtr*)(_a4 + 4));
    __ebx =  *_t6;
    if(__ebx == -1) {
        __errno_location();
         *_t6 = 9;
         *__esp = 1;
        caml_sys_error(__edi);
    }
    return __ebx + __ebx + 1;
}

intOrPtr* caml_ml_close_channel(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062D78
    _unknown_ __ebx;                       // r1
    intOrPtr* _t10;                        // _t10
    _unknown_ _t12;                        // _t12
    intOrPtr _t15;                         // _t15
    intOrPtr _t17;                         // _t17
    intOrPtr _t18;                         // _t18

    _t10 =  *((intOrPtr*)(_a4 + 4));
    _t15 =  *_t10;
    if(_t15 == -1) {
        _t17 = _t10[3];
        _t10[5] = _t17;
        _t10[4] = _t17;
    } else {
         *_t10 = -1;
        _t18 = _t10[3];
        _t10[5] = _t18;
        _t10[4] = _t18;
        _t12 = caml_enter_blocking_section();
         *__esp = _t15;
        close();
        caml_leave_blocking_section();
        if(_t12 == -1) {
             *__esp = 1;
            caml_sys_error(__edi);
        }
    }
    return 1;
}

caml_alloc_channel(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062DD6
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr __ebx;                        // r1

    __ebx = _a4;
     *((intOrPtr*)(__ebx + 44)) =  *((intOrPtr*)(__ebx + 44)) + 1;
    __eax = caml_alloc_custom(__edi, __fp0,  &channel_operations, 4, 1, 1000);
     *((intOrPtr*)(__eax + 4)) = __ebx;
    return __eax;
}

intOrPtr* caml_ml_out_channels_list()
{// addr = 0x08062E11
    _unknown_ _v16;                        // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char _v24;                             // _cfa_ffffffe8
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char _v56;                             // _cfa_ffffffc8
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    intOrPtr __ebx;                        // r1
    char* __esi;                           // r5
    intOrPtr* _t33;                        // _t33

    __esi = caml_local_roots;
    caml_local_roots =  &_v56;
    _v16 = 1;
    __ebx = caml_all_opened_channels;
    if(__ebx != 0) {
        _v20 = 0;
        _v24 = 0;
        _v56 = __esi;
        _v48 = 1;
        _v52 = 3;
        _v44 =  &_v16;
        _v40 =  &_v20;
        _v36 =  &_v24;
        do {
            if( *((intOrPtr*)(__ebx + 20)) == 0) {
                _v24 = caml_alloc_channel(__ebx);
                _v20 = _v16;
                _t33 = caml_alloc_small(__ebx, __esi, 2, 0);
                _v16 = _t33;
                 *_t33 = _v24;
                 *((intOrPtr*)(_v16 + 4)) = _v20;
            }
            __ebx =  *((intOrPtr*)(__ebx + 28));
        } while(__ebx != 0);
    }
    caml_local_roots = __esi;
    return _v16;
}

caml_finalize_channel(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08062EBC
    intOrPtr __ebx;                        // r1
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8

    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t7 =  *((intOrPtr*)(__ebx + 44)) - 1;
     *((intOrPtr*)(__ebx + 44)) = _t7;
    if(_t7 <= 0) {
        _t8 = caml_channel_mutex_free;
        if(_t8 != 0) {
             *__esp = __ebx;
             *_t8();
        }
        unlink_channel(__ebx);
        caml_stat_free(__ebx);
        return;
    }
}

caml_close_channel(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08062EF9
    intOrPtr* __ebx;                       // r1
    intOrPtr* _t4;                         // _t4

    __ebx = _a4;
     *__esp =  *__ebx;
    close();
    if( *((intOrPtr*)(__ebx + 44)) <= 0) {
        _t4 = caml_channel_mutex_free;
        if(_t4 != 0) {
             *__esp = __ebx;
             *_t4();
        }
        unlink_channel(__ebx);
        caml_stat_free(__ebx);
        return;
    }
}

signed int caml_seek_in(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int* _a4,                       // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08062F36
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int* _v40;                      // _cfa_ffffffd8
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v64;                         // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8
    signed int _t41;                       // _t41
    signed int _t43;                       // _t43
    signed int _t46;                       // _t46
    signed int* _t52;                      // _t52
    signed int* _t57;                      // _t57
    signed int _t58;                       // _t58
    signed int _t59;                       // _t59
    signed int _t63;                       // _t63
    signed int _t66;                       // _t66
    _unknown_ _t71;                        // _t71

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t52 = _a4;
    _t63 = _a8;
    _t66 = _a12;
    _v52 = _t52[1];
    _v48 = _t52[2];
    _t57 = _t52[5];
    _v40 = _t57;
    _t58 = _t57 -  &(_t52[0xd]);
    _v36 = _t58;
    _v32 = _t58 >> 31;
    _t59 = _v48;
    _t41 = _v52 - _v36;
    asm("sbb edx, [ebp-0x1c]");
    _v36 = _t41;
    _v32 = _t59;
    if(_t59 > _t66 || _v32 >= _t66 && _t41 > _t63) {
L7:
        caml_enter_blocking_section();
        _v64 = 0;
        _v72 = _t63;
        _v68 = _t66;
        _t43 =  *_t52;
         *__esp = _t43;
        lseek64();
        if((_t59 ^ _t66 | _t43 ^ _t63) != 0) {
            caml_leave_blocking_section();
             *__esp = 1;
            caml_sys_error(_t63);
        }
        caml_leave_blocking_section();
        _t52[1] = _t63;
        _t52[2] = _t66;
        _t46 =  &(_t52[0xd]);
        _t52[5] = _t46;
        _t52[4] = _t46;
        goto L10;
    } else {
        _t71 = _v48 - _t66;
        if(_t71 < 0 || _t71 <= 0 && _v52 < _t63) {
            goto L7;
        } else {
            _t46 = _v40 + _t63 - _v52;
            _t52[4] = _t46;
L10:
            return _t46;
        }
    }
}

caml_ml_seek_in_64(
    char _a4,                              // _cfa_4
    char _a8                               // _cfa_8
)
{// addr = 0x08063001
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    signed int* __ebx;                     // r1
    char* __esi;                           // r5
    intOrPtr* _t20;                        // _t20
    intOrPtr* _t23;                        // _t23

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t20 = caml_channel_mutex_lock;
    if(_t20 != 0) {
         *__esp = __ebx;
         *_t20();
    }
    caml_seek_in(__ebx, __edi, __esi, __ebx,  *((intOrPtr*)(_a8 + 4)),  *((intOrPtr*)(_a8 + 8)));
    _t23 = caml_channel_mutex_unlock;
    if(_t23 != 0) {
         *__esp = __ebx;
         *_t23();
    }
    caml_local_roots = __esi;
    return 1;
}

caml_ml_seek_in(
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063081
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    signed int* __ebx;                     // r1
    char* __esi;                           // r5
    intOrPtr* _t18;                        // _t18
    intOrPtr* _t21;                        // _t21

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t18 = caml_channel_mutex_lock;
    if(_t18 != 0) {
         *__esp = __ebx;
         *_t18();
    }
    caml_seek_in(__ebx, __edi, __esi, __ebx, _a8 >> 1, _a8 >> 1 >> 31);
    _t21 = caml_channel_mutex_unlock;
    if(_t21 != 0) {
         *__esp = __ebx;
         *_t21();
    }
    caml_local_roots = __esi;
    return 1;
}

signed int caml_channel_size(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08063102
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    intOrPtr* _t22;                        // _t22
    signed int _t24;                       // _t24
    signed int _t30;                       // _t30
    intOrPtr _t33;                         // _t33
    signed int _t35;                       // _t35
    signed int _t37;                       // _t37
    signed int _t41;                       // _t41
    signed int _t44;                       // _t44

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t22 = _a4;
    _t33 =  *_t22;
    _t35 =  *(_t22 + 4);
    _v32 = _t35;
    _v36 =  *(_t22 + 8);
    _t24 = caml_enter_blocking_section();
    _v48 = 2;
    _v56 = 0;
    _v52 = 0;
     *__esp = _t33;
    lseek64();
    _t44 = _t24;
    _t41 = _t35;
    if((_t24 & _t35) == -1) {
L2:
        caml_leave_blocking_section();
         *__esp = 1;
        caml_sys_error(_t41);
    } else {
        _v48 = 0;
        _t30 = _v32;
        _v56 = _t30;
        _t37 = _v36;
        _v52 = _t37;
         *__esp = _t33;
        lseek64();
        if((_t37 ^ _v36 | _t30 ^ _v32) != 0) {
            goto L2;
        }
    }
    caml_leave_blocking_section();
    return _t44;
}

caml_ml_channel_size_64(
    intOrPtr __edi,                        // r4
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080631A1
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __edi = __edi;
    return caml_copy_int64(__ebx, __esi, caml_channel_size(__ebx, __edi, __esi,  *((intOrPtr*)(_a4 + 4))), __edx);
}

caml_ml_channel_size(
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080631C3
    _unknown_ __ebx;                       // r1
    intOrPtr* _t7;                         // _t7
    intOrPtr _t10;                         // _t10
    intOrPtr* _t11;                        // _t11

    __esi = __esi;
    _t7 = caml_channel_size(_t10, __edi, __esi,  *((intOrPtr*)(_a4 + 4)));
    _t11 = _t7;
    if(__edx >= 0 && (__edx > 0 || _t7 > 1073741823)) {
        __errno_location();
         *_t7 = 75;
         *__esp = 1;
        caml_sys_error(__edi);
    }
    return _t11 + _t11 + 1;
}

caml_do_read(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0806320A
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr __ebx;                        // r1
    intOrPtr __edi;                        // r4
    intOrPtr __esi;                        // r5
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8

    __esi = _a4;
    __edi = _a8;
    while(1) {
        caml_enter_blocking_section();
        _t7 = _a12;
        _v36 = _t7;
        _v40 = __edi;
         *__esp = __esi;
        read();
        __ebx = _t7;
        _t8 = caml_leave_blocking_section();
        if(__ebx != -1) {
            break;
        }
        __errno_location();
        if( *_t8 == 4) {
            continue;
        } else {
            caml_sys_io_error(_t8, __edi, 1);
        }
        break;
    }
    return __ebx;
}

signed int caml_ml_input(
    char _a4,                              // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806325D
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    signed int _v84;                       // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr* __ebx;                       // r1
    char* __edi;                           // r4
    _unknown_ __esi;                       // r5
    intOrPtr* _t65;                        // _t65
    intOrPtr _t68;                         // _t68
    intOrPtr _t71;                         // _t71
    intOrPtr* _t77;                        // _t77
    signed int _t83;                       // _t83
    intOrPtr _t84;                         // _t84
    signed int _t91;                       // _t91
    intOrPtr _t92;                         // _t92

    __edi = caml_local_roots;
    _v60 = __edi;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 4;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v36 =  &_a16;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t65 = caml_channel_mutex_lock;
    if(_t65 != 0) {
         *__esp = __ebx;
         *_t65();
    }
    _v68 = _a12 >> 1;
    _v64 = _a16 >> 1;
    _t68 = __ebx[4];
    _t91 = __ebx[5] - _t68;
    if(_v64 > _t91) {
        if(_t91 <= 0) {
            _t84 = __ebx + 52;
            _v72 = _t84;
            _v84 = __ebx[3] - _t84;
            _v88 = _t84;
            _t71 =  *__ebx;
             *__esp = _t71;
            caml_do_read();
            _t92 = _t71;
             *((intOrPtr*)(__ebx + 4)) =  *((intOrPtr*)(__ebx + 4)) + _t71;
            asm("adc [ebx+0x8], edx");
             *((intOrPtr*)(__ebx + 20)) = __ebx + _t92 + 52;
            _t91 = _t92 - _v64 > 0 ? _v64 : _t92;
            _v84 = _t91;
            _v88 = _v72;
             *__esp = _v68 + _a8;
            memmove();
             *((intOrPtr*)(__ebx + 16)) = __ebx + _t91 + 52;
        } else {
            _v84 = _t91;
            _v88 = _t68;
             *__esp = _v68 + _a8;
            memmove();
             *((intOrPtr*)(__ebx + 16)) =  *((intOrPtr*)(__ebx + 16)) + _t91;
        }
    } else {
        _v84 = _v64;
        _v88 = _t68;
         *__esp = _v68 + _a8;
        memmove();
        _t83 = _v64;
         *((intOrPtr*)(__ebx + 16)) =  *((intOrPtr*)(__ebx + 16)) + _t83;
        _t91 = _t83;
    }
    _t77 = caml_channel_mutex_unlock;
    if(_t77 != 0) {
         *__esp = __ebx;
         *_t77();
    }
    caml_local_roots = __edi;
    return _t91 + _t91 + 1;
}

signed int caml_input_scan_line(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08063388
    signed char* _v32;                     // _cfa_ffffffe0
    signed char* _v36;                     // _cfa_ffffffdc
    signed int _v52;                       // _cfa_ffffffcc (outparam)
    signed char* _v56;                     // _cfa_ffffffc8 (outparam)
    intOrPtr* __ebx;                       // r1
    signed char* __edi;                    // r4
    signed char* __esi;                    // r5
    signed char* _t29;                     // _t29
    signed int _t30;                       // _t30
    signed int _t36;                       // _t36
    signed int _t44;                       // _t44
    signed char* _t47;                     // _t47
    signed char* _t48;                     // _t48

    __ebx = _a4;
    __esi =  *(__ebx + 16);
    __edi = __ebx + 52;
    _v36 = __edi;
    _v32 = __edi;
    do {
        _t29 =  *(__ebx + 20);
        if(__esi < _t29) {
            goto L9;
        }
        _t47 =  *(__ebx + 16);
        if(_t47 > __edi) {
            _v52 = _t29 - _t47;
            _v56 = _t47;
             *__esp = _v36;
            memmove();
            _t44 = _v32 -  *(__ebx + 16);
             *(__ebx + 16) = _v32;
             *(__ebx + 20) =  &(( *(__ebx + 20))[_t44]);
            __esi =  &(__esi[_t44]);
        }
        _t48 =  *(__ebx + 20);
        _t33 =  *(__ebx + 12);
        if(_t48 <  *(__ebx + 12)) {
            _t36 = caml_do_read( *__ebx, _t48, _t33 - _t48);
            if(_t36 != 0) {
                __ebx[1] = __ebx[1] + _t36;
                asm("adc [ebx+0x8], ecx");
                 *(__ebx + 20) =  &(( *(__ebx + 20))[_t36]);
                goto L9;
            }
            return  *(__ebx + 16) -  *(__ebx + 20);
        } else {
            return  *(__ebx + 16) - _t48;
        }
L9:
        _t30 =  *__esi & 255;
        __esi =  &(__esi[1]);
    } while(_t30 != 10);
    return __esi -  *(__ebx + 16);
}

signed int caml_ml_input_scan_line(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x0806342A
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    intOrPtr* _t20;                        // _t20
    intOrPtr* _t21;                        // _t21
    intOrPtr* _t24;                        // _t24
    intOrPtr* _t27;                        // _t27
    char* _t30;                            // _t30

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t30 = caml_local_roots;
    _v60 = _t30;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t24 =  *((intOrPtr*)(_a4 + 4));
    _t20 = caml_channel_mutex_lock;
    if(_t20 != 0) {
         *__esp = _t24;
         *_t20();
    }
    caml_input_scan_line(_t24);
    _t27 = _t20;
    _t21 = caml_channel_mutex_unlock;
    if(_t21 != 0) {
         *__esp = _t24;
         *_t21();
    }
    caml_local_roots = _t30;
    return _t27 + _t27 + 1;
}

caml_getblock(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080634A1
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc (outparam)
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    intOrPtr _t41;                         // _t41
    _unknown_ _t47;                        // _t47
    intOrPtr* _t55;                        // _t55
    intOrPtr _t60;                         // _t60
    intOrPtr _t64;                         // _t64

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t55 = _a4;
    _t60 = _a12;
    _t41 = _t55[4];
    _t64 = _t55[5] - _t41;
    if(_t60 > _t64) {
        if(_t64 <= 0) {
            _v32 = _t55 + 52;
            _t47 = caml_do_read( *_t55, _v32, _t55[3] - _v32);
            _t55[1] = _t55[1] + _t47;
            asm("adc [ebx+0x8], ecx");
            _t55[5] = _t55 + _t47 + 52;
            _t64 = _t47 - _t60 <= 0 ? _t47 : _t60;
            _v52 = _t64;
            _v56 = _v32;
             *__esp = _a8;
            memmove();
            _t55[4] = _t55 + _t64 + 52;
        } else {
            _v52 = _t64;
            _v56 = _t41;
             *__esp = _a8;
            memmove();
            _t55[4] = _t55[4] + _t64;
        }
    } else {
        _v52 = _t60;
        _v56 = _t41;
         *__esp = _a8;
        memmove();
        _t55[4] = _t55[4] + _t60;
        _t64 = _t60;
    }
    return _t64;
}

signed int caml_really_getblock(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0806355E
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    intOrPtr __ebx;                        // r1
    intOrPtr* __edi;                       // r4
    intOrPtr __esi;                        // r5
    _unknown_ _t8;                         // _t8

    __edi = _a4;
    __esi = _a8;
    __ebx = _a12;
    if(__ebx > 0) {
        while(1) {
            _t8 = caml_getblock(__ebx, __edi, __esi, __edi, __esi, __ebx);
            if(_t8 == 0) {
                goto L4;
            }
            __ebx = __ebx - _t8;
            if(__ebx > 0) {
                __esi = __esi + _t8;
                continue;
            }
            goto L4;
        }
    }
L4:
    return __ebx == 0 & 255;
}

signed int caml_refill(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080635A2
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr* __ebx;                       // r1
    _unknown_ _t16;                        // _t16

    __ebx = _a4;
    _t16 = caml_do_read( *__ebx, __ebx + 52,  *(__ebx + 12) - __ebx + 52);
    if(_t16 == 0) {
        _t16 = caml_raise_end_of_file();
    }
    __ebx[1] = __ebx[1] + _t16;
    asm("adc [ebx+0x8], ecx");
    __ebx[5] = __ebx + _t16 + 52;
    __ebx[4] = __ebx + 53;
    return  *(__ebx + 52) & 255;
}

signed int caml_ml_input_char(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x080635F1
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    intOrPtr* _t23;                        // _t23
    signed int _t24;                       // _t24
    intOrPtr* _t26;                        // _t26
    intOrPtr* _t29;                        // _t29
    signed int _t32;                       // _t32
    char* _t36;                            // _t36

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t36 = caml_local_roots;
    _v60 = _t36;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t29 =  *((intOrPtr*)(_a4 + 4));
    _t23 = caml_channel_mutex_lock;
    if(_t23 != 0) {
         *__esp = _t29;
         *_t23();
    }
    _t24 =  *(_t29 + 16);
    if(_t24 < _t29[5]) {
        _t32 =  *_t24 & 255;
         *(_t29 + 16) = _t24 + 1;
    } else {
        caml_refill(_t29);
        _t32 = _t24;
    }
    _t26 = caml_channel_mutex_unlock;
    if(_t26 != 0) {
         *__esp = _t29;
         *_t26();
    }
    caml_local_roots = _t36;
    return (_t32 & 255) + (_t32 & 255) + 1;
}

signed int caml_getword(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08063681
    intOrPtr* __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    signed char* _t11;                     // _t11
    signed int _t13;                       // _t13

    __ebx = _a4;
     *__esp = __ebx;
    if(caml_channel_binary_mode() == 0) {
         *__esp = "input_binary_int: not a binary channel";
        caml_failwith();
    }
    _t13 = 0;
    __esi = 0;
    do {
        _t11 =  *(__ebx + 16);
        if(_t11 < __ebx[5]) {
            _t7 =  *_t11 & 255;
             *(__ebx + 16) =  &(_t11[1]);
        } else {
             *_t11 & 255 = caml_refill(__ebx) & 255;
        }
        _t13 = _t7 + (_t13 << 8);
        __esi = __esi + 1;
    } while(__esi != 4);
    return _t13;
}

caml_ml_input_int(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x080636E5
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    intOrPtr* _t20;                        // _t20
    intOrPtr* _t21;                        // _t21
    intOrPtr* _t24;                        // _t24
    intOrPtr* _t27;                        // _t27
    char* _t30;                            // _t30

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t30 = caml_local_roots;
    _v60 = _t30;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t24 =  *((intOrPtr*)(_a4 + 4));
    _t20 = caml_channel_mutex_lock;
    if(_t20 != 0) {
         *__esp = _t24;
         *_t20();
    }
    caml_getword(_t24);
    _t27 = _t20;
    _t21 = caml_channel_mutex_unlock;
    if(_t21 != 0) {
         *__esp = _t24;
         *_t21();
    }
    caml_local_roots = _t30;
    return _t27 + _t27 + 1;
}

do_write(
    intOrPtr __eax,                        // r0
    intOrPtr __ecx,                        // r2
    intOrPtr __edx                         // r3
)
{// addr = 0x0806375C
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr __ebx;                        // r1
    intOrPtr __edi;                        // r4
    intOrPtr __esi;                        // r5
    intOrPtr _t7;                          // _t7
    intOrPtr* _t8;                         // _t8
    intOrPtr _t10;                         // _t10

    __edx = __edx;
    __ecx = __ecx;
    __edi = __eax;
    _v32 = __edx;
    __esi = __ecx;
    while(1) {
        caml_enter_blocking_section();
        _v52 = __esi;
        _t7 = _v32;
        _v56 = _t7;
         *__esp = __eax;
        write();
        __ebx = _t7;
        _t8 = caml_leave_blocking_section();
        if(__ebx != -1) {
            break;
        }
        __errno_location();
        _t10 =  *_t8;
        if(_t10 == 4) {
            continue;
        }
        if(_t10 != 11 || __esi <= 1) {
            caml_sys_io_error(_t10, __eax, 1);
            break;
        } else {
            __esi = 1;
            continue;
        }
    }
    return __ebx;
}

caml_putblock(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080637C3
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _t34;                         // _t34
    intOrPtr _t37;                         // _t37
    signed int _t39;                       // _t39
    intOrPtr _t40;                         // _t40
    intOrPtr* _t47;                        // _t47
    intOrPtr _t49;                         // _t49
    intOrPtr _t54;                         // _t54
    signed int _t55;                       // _t55
    intOrPtr _t61;                         // _t61

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t47 = _a4;
    _t49 = _a8;
    _t54 = _a12;
    _t34 = _t47[4];
    _t61 = _t47[3] - _t34;
    if(_t54 >= _t61) {
        _v52 = _t61;
        _v56 = _t49;
         *__esp = _t34;
        memmove();
        _v32 = _t47 + 52;
        _t37 = _t47[3] - _v32;
        _v36 = _t37;
        __ecx = _t37;
        _t39 = do_write( *_t47, _t37, _v32);
        _t55 = _t39;
        if(_v36 > _t39) {
            _v52 = _v36 - _t55;
            _v56 = _v32 + _t55;
             *__esp = _v32;
            memmove();
        }
        _t47[1] = _t47[1] + _t55;
        asm("adc [ebx+0x8], edx");
        _t47[4] =  ~_t55 + _t47[3];
        _t40 = _t61;
    } else {
        _v52 = _t54;
        _v56 = _t49;
         *__esp = _t34;
        memmove();
        _t47[4] = _t47[4] + _t54;
        _t40 = _t54;
    }
    return _t40;
}

caml_ml_output(
    char _a4,                              // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806386F
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    signed int _v84;                       // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t22;                        // _t22
    intOrPtr* _t29;                        // _t29
    intOrPtr* _t30;                        // _t30
    intOrPtr _t34;                         // _t34
    signed int _t36;                       // _t36
    signed int _t37;                       // _t37
    signed int _t38;                       // _t38

    _t22 = caml_local_roots;
    _v64 = _t22;
    _v60 = _t22;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 4;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v36 =  &_a16;
    __edi =  *((intOrPtr*)(_a4 + 4));
    _t37 = _a12;
    _t36 = _a16 >> 1;
    _t29 = caml_channel_mutex_lock;
    if(_t29 != 0) {
         *__esp = __edi;
         *_t29();
    }
    if(_t36 > 0) {
        _t38 = _t37 >> 1;
        do {
            _v84 = _t36;
            _t34 = _t38 + _a8;
            _v88 = _t34;
             *__esp = __edi;
            caml_putblock(_t36, __edi, _t38);
            _t38 = _t38 + _t34;
            _t36 = _t36 - _t34;
        } while(_t36 > 0);
    }
    _t30 = caml_channel_mutex_unlock;
    if(_t30 != 0) {
         *__esp = __edi;
         *_t30();
    }
    caml_local_roots = _v64;
    return 1;
}

caml_ml_output_partial(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4,                              // _cfa_4
    char _a8,                              // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x08063913
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v68;                       // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr* _t34;                        // _t34
    intOrPtr _t39;                         // _t39
    intOrPtr* _t40;                        // _t40
    intOrPtr _t43;                         // _t43
    intOrPtr _t46;                         // _t46
    char* _t49;                            // _t49

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t49 = caml_local_roots;
    _v60 = _t49;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 4;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    _v36 =  &_a16;
    _t43 =  *((intOrPtr*)(_a4 + 4));
    _t34 = caml_channel_mutex_lock;
    if(_t34 != 0) {
         *__esp = _t43;
         *_t34();
    }
    _v68 = _a16 >> 1;
    _t39 = (_a12 >> 1) + _a8;
    _v72 = _t39;
     *__esp = _t43;
    caml_putblock(_t43, __edi, _t49);
    _t46 = _t39;
    _t40 = caml_channel_mutex_unlock;
    if(_t40 != 0) {
         *__esp = _t43;
         *_t40();
    }
    caml_local_roots = _t49;
    return _t46 + _t46 + 1;
}

caml_really_putblock(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x080639B1
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    intOrPtr __ebx;                        // r1
    intOrPtr* __edi;                       // r4
    intOrPtr __esi;                        // r5

    __edi = _a4;
    __esi = _a8;
    __ebx = _a12;
    while(__ebx > 0) {
        __eax = caml_putblock(__ebx, __edi, __esi, __edi, __esi, __ebx);
        __esi = __esi + __eax;
        __ebx = __ebx - __eax;
    }
    return __eax;
}

signed int caml_flush_partial(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x080639E7
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _t21;                         // _t21
    _unknown_ _t26;                        // _t26
    intOrPtr* _t31;                        // _t31
    _unknown_ _t38;                        // _t38
    intOrPtr _t41;                         // _t41

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t31 = _a4;
    _t21 = _t31 + 52;
    _v32 = _t21;
    _t41 = _t31[4] - _t21;
    if(_t41 > 0) {
        __ecx = _t41;
        _t26 = do_write( *_t31, _t41, _t21);
        _t38 = _t26;
        _t31[1] = _t31[1] + _t26;
        asm("adc [ebx+0x8], edx");
        if(_t41 > _t38) {
            _v52 = _t41 - _t38;
            _v56 = _v32 + _t38;
             *__esp = _v32;
            memmove();
        }
        _t31[4] = _t31[4] - _t38;
    }
    return _t31[4] == _t31 + 52 & 255;
}

caml_ml_output_char(
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063A5A
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    intOrPtr* __ebx;                       // r1
    char* __esi;                           // r5
    intOrPtr* _t20;                        // _t20
    char* _t22;                            // _t22
    intOrPtr* _t24;                        // _t24

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t20 = caml_channel_mutex_lock;
    if(_t20 != 0) {
         *__esp = __ebx;
         *_t20();
    }
    if(__ebx[4] >= __ebx[3]) {
        caml_flush_partial(__ebx, __edi, __esi, __ebx);
    }
    _t22 =  *((intOrPtr*)(__ebx + 16));
     *_t22 = _a8 >> 1;
     *((intOrPtr*)(__ebx + 16)) = _t22 + 1;
    _t24 = caml_channel_mutex_unlock;
    if(_t24 != 0) {
         *__esp = __ebx;
         *_t24();
    }
    caml_local_roots = __esi;
    return 1;
}

caml_ml_flush_partial(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x08063AE1
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    intOrPtr* _t19;                        // _t19
    signed int _t20;                       // _t20
    _unknown_ _t22;                        // _t22
    intOrPtr* _t24;                        // _t24
    char* _t30;                            // _t30

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t30 = caml_local_roots;
    _v60 = _t30;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t24 =  *((intOrPtr*)(_a4 + 4));
    if( *_t24 != -1) {
        _t19 = caml_channel_mutex_lock;
        if(_t19 != 0) {
             *__esp = _t24;
             *_t19();
        }
        caml_flush_partial(_t24, __edi, _t30, _t24);
        _t20 = caml_channel_mutex_unlock;
        if(_t20 != 0) {
             *__esp = _t24;
             *_t20();
        }
        asm("sbb eax, eax");
        caml_local_roots = _t30;
        _t22 = (_t20 & -2) + 3;
    } else {
        caml_local_roots = _t30;
        _t22 = 3;
    }
    return _t22;
}

caml_putword(
    intOrPtr __edi,                        // r4
    intOrPtr* _a4,                         // _cfa_4
    unsigned int _a8                       // _cfa_8
)
{// addr = 0x08063B71
    intOrPtr* __ebx;                       // r1
    unsigned int __esi;                    // r5
    char* _t18;                            // _t18
    intOrPtr _t19;                         // _t19
    char* _t20;                            // _t20
    intOrPtr _t21;                         // _t21
    char* _t22;                            // _t22
    intOrPtr _t23;                         // _t23
    char* _t24;                            // _t24
    intOrPtr _t25;                         // _t25

    __edi = __edi;
    __ebx = _a4;
    __esi = _a8;
     *__esp = __ebx;
    if(caml_channel_binary_mode() == 0) {
         *__esp = "output_binary_int: not a binary channel";
        caml_failwith();
    }
    if(__ebx[4] >= __ebx[3]) {
        caml_flush_partial(__ebx, __edi, __esi, __ebx);
    }
    _t18 = __ebx[4];
     *_t18 = __esi >> 24;
    _t19 = _t18 + 1;
    __ebx[4] = _t19;
    if(_t19 >= __ebx[3]) {
        caml_flush_partial(__ebx, __edi, __esi, __ebx);
    }
    _t20 = __ebx[4];
     *_t20 = __esi >> 16;
    _t21 = _t20 + 1;
    __ebx[4] = _t21;
    if(_t21 >= __ebx[3]) {
        caml_flush_partial(__ebx, __edi, __esi, __ebx);
    }
    _t22 = __ebx[4];
     *_t22 = __esi >> 8;
    _t23 = _t22 + 1;
    __ebx[4] = _t23;
    if(_t23 >= __ebx[3]) {
        caml_flush_partial(__ebx, __edi, __esi, __ebx);
    }
    _t24 = __ebx[4];
     *_t24 = __esi;
    _t25 = _t24 + 1;
    __ebx[4] = _t25;
    return _t25;
}

caml_ml_output_int(
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063C12
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    intOrPtr* __ebx;                       // r1
    char* __esi;                           // r5
    intOrPtr* _t17;                        // _t17
    intOrPtr* _t20;                        // _t20

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t17 = caml_channel_mutex_lock;
    if(_t17 != 0) {
         *__esp = __ebx;
         *_t17();
    }
    caml_putword(__edi, __ebx, _a8 >> 1);
    _t20 = caml_channel_mutex_unlock;
    if(_t20 != 0) {
         *__esp = __ebx;
         *_t20();
    }
    caml_local_roots = __esi;
    return 1;
}

caml_flush(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08063C8A
    intOrPtr* __ebx;                       // r1

    __ebx = _a4;
    do {
        __eax = caml_flush_partial(__ebx, __edi, __esi, __ebx);
    } while(__eax == 0);
    return __eax;
}

intOrPtr* caml_ml_flush(
    char _a4                               // _cfa_4
)
{// addr = 0x08063CA6
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    intOrPtr* __ebx;                       // r1
    char* __esi;                           // r5
    intOrPtr* _t12;                        // _t12
    intOrPtr* _t13;                        // _t13

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    if( *__ebx != -1) {
        _t12 = caml_channel_mutex_lock;
        if(_t12 != 0) {
             *__esp = __ebx;
             *_t12();
        }
        caml_flush(__ebx);
        _t13 = caml_channel_mutex_unlock;
        if(_t13 != 0) {
             *__esp = __ebx;
             *_t13();
        }
        caml_local_roots = __esi;
    } else {
        caml_local_roots = __esi;
    }
    return 1;
}

caml_seek_out(
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int* _a4,                       // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08063D1C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _t17;                       // _t17
    _unknown_ _t19;                        // _t19
    signed int* _t23;                      // _t23
    signed int _t29;                       // _t29
    signed int _t32;                       // _t32

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t23 = _a4;
    _t32 = _a8;
    _t29 = _a12;
    caml_flush(_t23);
    caml_enter_blocking_section();
    _v32 = 0;
    _v40 = _t32;
    _v36 = _t29;
    _t17 =  *_t23;
     *__esp = _t17;
    lseek64();
    if((__edx ^ _t29 | _t17 ^ _t32) != 0) {
        caml_leave_blocking_section();
         *__esp = 1;
        caml_sys_error(_t29);
    }
    _t19 = caml_leave_blocking_section();
    _t23[1] = _t32;
    _t23[2] = _t29;
    return _t19;
}

caml_ml_seek_out_64(
    char _a4,                              // _cfa_4
    char _a8                               // _cfa_8
)
{// addr = 0x08063D8C
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    signed int* __ebx;                     // r1
    char* __esi;                           // r5
    intOrPtr* _t20;                        // _t20
    intOrPtr* _t23;                        // _t23

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t20 = caml_channel_mutex_lock;
    if(_t20 != 0) {
         *__esp = __ebx;
         *_t20();
    }
    _t21 = _a8;
    caml_seek_out(__ebx,  *((intOrPtr*)(_a8 + 8)), __edi, __esi, __ebx,  *((intOrPtr*)(_t21 + 4)),  *((intOrPtr*)(_a8 + 8)));
    _t23 = caml_channel_mutex_unlock;
    if(_t23 != 0) {
         *__esp = __ebx;
         *_t23();
    }
    caml_local_roots = __esi;
    return 1;
}

caml_ml_seek_out(
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08063E0C
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    signed int* __ebx;                     // r1
    char* __esi;                           // r5
    intOrPtr* _t18;                        // _t18
    intOrPtr* _t21;                        // _t21

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t18 = caml_channel_mutex_lock;
    if(_t18 != 0) {
         *__esp = __ebx;
         *_t18();
    }
    caml_seek_out(__ebx, _a8 >> 1 >> 31, __edi, __esi, __ebx, _t20, _a8 >> 1 >> 31);
    _t21 = caml_channel_mutex_unlock;
    if(_t21 != 0) {
         *__esp = __ebx;
         *_t21();
    }
    caml_local_roots = __esi;
    return 1;
}

caml_open_descriptor_in(
    intOrPtr __edx,                        // r3
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08063E8D
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr* __ebx;                       // r1
    intOrPtr __esi;                        // r5
    _unknown_ _t20;                        // _t20
    intOrPtr* _t21;                        // _t21
    intOrPtr _t22;                         // _t22
    intOrPtr _t24;                         // _t24
    intOrPtr _t27;                         // _t27

    __edx = __edx;
    __esi = _a4;
    _t21 = caml_stat_alloc(_t20, 4148);
    __ebx = _t21;
     *_t21 = __esi;
    _t22 = caml_enter_blocking_section();
    _v16 = 1;
    _v24 = 0;
    _v20 = 0;
     *__esp = __esi;
    lseek64();
     *((intOrPtr*)(__ebx + 4)) = _t22;
     *((intOrPtr*)(__ebx + 8)) = __edx;
    caml_leave_blocking_section();
    _t24 = __ebx + 52;
     *((intOrPtr*)(__ebx + 20)) = _t24;
     *((intOrPtr*)(__ebx + 16)) = _t24;
     *((intOrPtr*)(__ebx + 12)) = __ebx + 4148;
     *((intOrPtr*)(__ebx + 24)) = 0;
     *((intOrPtr*)(__ebx + 36)) = 0;
     *((intOrPtr*)(__ebx + 40)) = 0;
     *((intOrPtr*)(__ebx + 44)) = 0;
     *((intOrPtr*)(__ebx + 48)) = 0;
     *((intOrPtr*)(__ebx + 28)) = caml_all_opened_channels;
     *((intOrPtr*)(__ebx + 32)) = 0;
    _t27 = caml_all_opened_channels;
    if(_t27 != 0) {
         *((intOrPtr*)(_t27 + 32)) = __ebx;
    }
    caml_all_opened_channels = __ebx;
    return __ebx;
}

intOrPtr caml_ml_open_descriptor_in(
    intOrPtr __edx,                        // r3
    signed int _a4                         // _cfa_4
)
{// addr = 0x08063F37
    __edx = __edx;
    return caml_alloc_channel(caml_open_descriptor_in(__edx, _a4 >> 1));
}

caml_open_descriptor_out(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08063F54
    _unknown_ _t4;                         // _t4

    _t4 = caml_open_descriptor_in(__edx, _a4);
     *((intOrPtr*)(_t4 + 20)) = 0;
    return _t4;
}

intOrPtr caml_ml_open_descriptor_out(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08063F6E
    return caml_alloc_channel(caml_open_descriptor_out(_a4 >> 1));
}

signed int* extern_replay_trail()
{// addr = 0x08063F90
    intOrPtr* _v32;                        // _cfa_ffffffe0
    _unknown_ __ebx;                       // r1
    intOrPtr __edi;                        // r4
    _unknown_ __esi;                       // r5
    signed int* _t11;                      // _t11
    intOrPtr* _t12;                        // _t12
    intOrPtr _t13;                         // _t13
    signed int _t14;                       // _t14
    signed int _t21;                       // _t21

    _v32 = extern_trail_block;
    __edi = extern_trail_cur;
    while(1) {
        _t11 = _v32 + 4;
        if(__edi <= _t11) {
            goto L3;
        } else {
            goto L2;
        }
        do {
L2:
            _t14 =  *_t11;
            _t21 = _t14 & -4;
             *(_t21 - 4) = (_t14 & 3) << 8 |  *(_t21 - 4) & -769;
             *_t21 = _t11[1];
            _t11 =  &(_t11[2]);
        } while(__edi > _t11);
L3:
        if(_v32 !=  &extern_trail_first) {
            _t12 = _v32;
            _t13 =  *_t12;
             *__esp = _t12;
            free();
            __edi = _t13 + 8204;
            _v32 = _t13;
            continue;
        }
        extern_trail_block =  &extern_trail_first;
        extern_trail_cur = 134712676;
        return _t11;
    }
}

free_extern_output()
{// addr = 0x08064016
    intOrPtr* __ebx;                       // r1
    _unknown_ _t1;                         // _t1
    intOrPtr* _t2;                         // _t2

    if(extern_userprovided_output == 0) {
        _t2 = extern_output_first;
        if(_t2 == 0) {
L4:
            extern_output_first = 0;
            return _t2;
        } else {
            goto L2;
        }
        while(1) {
L2:
            __ebx =  *_t2;
             *__esp = _t2;
            free();
            if(__ebx == 0) {
                goto L4;
            }
            _t2 = __ebx;
        }
        goto L4;
    }
    return _t1;
}

extern_out_of_memory()
{// addr = 0x08064051
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t9;                         // _t9
    intOrPtr* _t10;                        // _t10
    intOrPtr _t13;                         // _t13
    _unknown_ _t16;                        // _t16
    intOrPtr* _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    _unknown_ _t20;                        // _t20
    _unknown_ _t21;                        // _t21

    extern_replay_trail();
    free_extern_output();
    _t9 = caml_raise_out_of_memory();
    _push(_t21);
    _push(_t18);
    _push(_t16);
    __esp = __esp - 16;
    if(extern_userprovided_output != 0) {
        extern_replay_trail();
         *__esp = "Marshal.to_buffer: buffer overflow";
        _t9 = caml_failwith();
    }
    extern_output_block[1] = extern_ptr;
    _t20 = _t9 - 4051 >= 0 ? _t9 : 0;
    _t10 = 0x1fac;
     *__esp = _t10;
    malloc();
    _t17 = _t10;
    if(_t10 == 0) {
        extern_out_of_memory();
    }
     *extern_output_block = _t17;
    extern_output_block = _t17;
     *_t17 = 0;
    extern_ptr = _t17 + 8;
    _t13 = _t17 + _t20 + 8108;
    extern_limit = _t13;
    __esp = __esp + 16;
    _pop(__ebx);
    _pop(__esi);
    return _t13;
}

grow_extern_output()
{// addr = 0x08064066
    intOrPtr* __ebx;                       // r1
    _unknown_ __esi;                       // r5
    _unknown_ _t7;                         // _t7
    intOrPtr* _t8;                         // _t8
    intOrPtr _t11;                         // _t11
    _unknown_ _t15;                        // _t15

    if(extern_userprovided_output != 0) {
        extern_replay_trail();
         *__esp = "Marshal.to_buffer: buffer overflow";
        _t7 = caml_failwith();
    }
    extern_output_block[1] = extern_ptr;
    _t15 = _t7 - 4051 >= 0 ? _t7 : 0;
    _t8 = 0x1fac;
     *__esp = _t8;
    malloc();
    __ebx = _t8;
    if(_t8 == 0) {
        extern_out_of_memory();
    }
     *extern_output_block = __ebx;
    extern_output_block = __ebx;
     *__ebx = 0;
    extern_ptr = __ebx + 8;
    _t11 = __ebx + _t15 + 8108;
    extern_limit = _t11;
    return _t11;
}

caml_serialize_block_float_8(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080640EB
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int __ebx;                      // r1
    signed int _t6;                        // _t6
    intOrPtr _t8;                          // _t8

    _t6 = _a8 << 3;
    __ebx = _t6;
    if(extern_limit < _t6 + extern_ptr) {
        grow_extern_output();
    }
    _v20 = __ebx;
    _v24 = _a4;
    _t8 = extern_ptr;
     *__esp = _t8;
    memmove();
    extern_ptr = extern_ptr + __ebx;
    return _t8;
}

caml_serialize_float_8(
    char _a4,                              // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08064133
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v20 = _a4;
    _v16 = _a8;
    return caml_serialize_block_float_8( &_v20, 1);
}

signed int caml_serialize_block_8(
    signed char* _a4,                      // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806415A
    intOrPtr _v32;                         // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t28;                       // _t28
    char* _t29;                            // _t29
    signed char* _t41;                     // _t41
    char* _t42;                            // _t42

    _t28 = _a8 << 3;
    if(extern_limit < _t28 + extern_ptr) {
        _t28 = grow_extern_output();
    }
    _t42 = extern_ptr;
    if(_a8 > 0) {
        _t41 = _a4;
        _t29 = _t42;
        _v48 = _a8;
        _v32 = _t42;
        do {
             *_t29 = _t41[7] & 255;
            _t29[1] = _t41[6] & 255;
            _t29[7] =  *_t41 & 255;
            _t29[6] = _t41[1] & 255;
            _t29[2] = _t41[5] & 255;
            _t29[3] = _t41[4] & 255;
            _t29[5] = _t41[2] & 255;
            _t29[4] = _t41[3] & 255;
            _t41 =  &(_t41[8]);
            _t29 = _t29 + 8;
            _v48 = _v48 - 1;
        } while(_v48 != 0);
        _t28 = _a8;
        _t42 = _v32 + _t28 * 8;
    }
    extern_ptr = _t42;
    return _t28;
}

caml_serialize_int_8(
    char _a4,                              // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080641FD
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    _v20 = _a4;
    _v16 = _a8;
    return caml_serialize_block_8( &_v20, 1);
}

signed int caml_serialize_block_4(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08064224
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr __ebx;                        // r1
    signed int _t26;                       // _t26
    _unknown_ _t27;                        // _t27
    intOrPtr _t35;                         // _t35

    __ebx = _a4;
    _t26 = _a8 << 2;
    if(extern_limit < _t26 + extern_ptr) {
        _t26 = grow_extern_output();
    }
    _t35 = extern_ptr;
    if(_a8 > 0) {
        _t27 = 0;
        _v32 = _a8;
        do {
             *((char*)(_t35 + _t27)) =  *(__ebx + _t27 + 3) & 255;
             *((char*)(_t35 + _t27 + 1)) =  *(__ebx + _t27 + 2) & 255;
             *((char*)(_t35 + _t27 + 3)) =  *(__ebx + _t27) & 255;
             *((char*)(_t35 + _t27 + 2)) =  *(__ebx + _t27 + 1) & 255;
            _t27 = _t27 + 4;
            _v32 = _v32 - 1;
        } while(_v32 != 0);
        _t26 = _a8;
        _t35 = _t35 + _t26 * 4;
    }
    extern_ptr = _t35;
    return _t26;
}

caml_serialize_float_4(
    char _a4                               // _cfa_4
)
{// addr = 0x080642A5
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_serialize_block_4( &_a4, 1);
}

caml_serialize_block_2(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080642C0
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    intOrPtr __ebx;                        // r1
    _unknown_ __edi;                       // r4
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t23;                       // _t23

    __ebx = _a4;
    _t23 = _a8;
    _t17 = _t23 + _t23;
    if(extern_limit < _t17 + extern_ptr) {
        _t17 = grow_extern_output();
    }
    __ecx = extern_ptr;
    if(_t23 > 0) {
        _t18 = 0;
        _v48 = _t23;
        _v32 = _t23;
        do {
             *((char*)(__ecx + _t18)) =  *(__ebx + _t18 + 1) & 255;
             *((char*)(__ecx + _t18 + 1)) =  *(__ebx + _t18) & 255;
            _t18 = _t18 + 2;
            _v48 = _v48 - 1;
        } while(_v48 != 0);
        __ecx = __ecx + _v32 * 2;
    }
    extern_ptr = __ecx;
    return _t17;
}

caml_serialize_block_1(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806432D
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    intOrPtr _t5;                          // _t5
    intOrPtr _t7;                          // _t7

    _t5 = _a8;
    __ebx = _t5;
    if(extern_limit < _t5 + extern_ptr) {
        grow_extern_output();
    }
    _v20 = __ebx;
    _v24 = _a4;
    _t7 = extern_ptr;
     *__esp = _t7;
    memmove();
    extern_ptr = extern_ptr + __ebx;
    return _t7;
}

caml_serialize_int_4(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08064372
    signed int __ebx;                      // r1
    char* _t7;                             // _t7
    intOrPtr _t8;                          // _t8

    __ebx = _a4;
    if(extern_limit < extern_ptr + 4) {
        grow_extern_output();
    }
    _t7 = extern_ptr;
     *_t7 = __ebx >> 24;
    _t7[1] = __ebx >> 16;
    _t7[2] = __ebx >> 8;
    _t7[3] = __bl;
    _t8 = _t7 + 4;
    extern_ptr = _t8;
    return _t8;
}

caml_serialize_int_2(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080643C3
    signed int __ebx;                      // r1
    char* _t5;                             // _t5
    intOrPtr _t6;                          // _t6

    __ebx = _a4;
    if(extern_limit < extern_ptr + 2) {
        grow_extern_output();
    }
    _t5 = extern_ptr;
     *_t5 = __ebx >> 8;
    _t5[1] = __bl;
    _t6 = _t5 + 2;
    extern_ptr = _t6;
    return _t6;
}

caml_serialize_int_1(
    char _a4                               // _cfa_4
)
{// addr = 0x08064404
    char* _t4;                             // _t4
    intOrPtr _t5;                          // _t5

    if(extern_limit < extern_ptr + 1) {
        grow_extern_output();
    }
    _t4 = extern_ptr;
     *_t4 = _a4;
    _t5 = _t4 + 1;
    extern_ptr = _t5;
    return _t5;
}

writecode16(
    char __eax,                            // r0
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x08064438
    intOrPtr _v8;                          // _cfa_fffffff8
    char* _t8;                             // _t8
    intOrPtr _t9;                          // _t9

     *__esp = __ebx;
    _v8 = __esi;
    if(extern_limit < extern_ptr + 3) {
        grow_extern_output();
    }
    _t8 = extern_ptr;
     *_t8 = __eax;
    _t8[1] = __edx >> 8;
    _t8[2] = __edx;
    _t9 = _t8 + 3;
    extern_ptr = _t9;
    return _t9;
}

writecode8(
    char __eax,                            // r0
    intOrPtr __ebx,                        // r1
    char __edx,                            // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x0806448A
    intOrPtr _v8;                          // _cfa_fffffff8
    char* _t7;                             // _t7
    intOrPtr _t8;                          // _t8

     *__esp = __ebx;
    _v8 = __esi;
    if(extern_limit < extern_ptr + 2) {
        grow_extern_output();
    }
    _t7 = extern_ptr;
     *_t7 = __eax;
    _t7[1] = __edx;
    _t8 = _t7 + 2;
    extern_ptr = _t8;
    return _t8;
}

writecode32(
    char __eax,                            // r0
    intOrPtr __ebx,                        // r1
    signed int __edx,                      // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x080644D4
    intOrPtr _v8;                          // _cfa_fffffff8
    char* _t10;                            // _t10
    intOrPtr _t11;                         // _t11

     *__esp = __ebx;
    _v8 = __esi;
    if(extern_limit < extern_ptr + 5) {
        grow_extern_output();
    }
    _t10 = extern_ptr;
     *_t10 = __eax;
    _t10[1] = __edx >> 24;
    _t10[2] = __edx >> 16;
    _t10[3] = __edx >> 8;
    _t10[4] = __edx;
    _t11 = _t10 + 5;
    extern_ptr = _t11;
    return _t11;
}

writeblock(
    intOrPtr __eax,                        // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edx,                        // r3
    intOrPtr __esi                         // r5
)
{// addr = 0x08064536
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t10;                         // _t10

    __edx = __edx;
    _v12 = __ebx;
    _v8 = __esi;
    if(extern_limit < __edx + extern_ptr) {
        grow_extern_output();
    }
    _v20 = __edx;
    _v24 = __eax;
    _t10 = extern_ptr;
     *__esp = _t10;
    memmove();
    extern_ptr = extern_ptr + __edx;
    return _t10;
}

write32(
    signed int __eax                       // r0
)
{// addr = 0x08064582
    signed int __ebx;                      // r1
    char* _t7;                             // _t7
    intOrPtr _t8;                          // _t8

    __ebx = __eax;
    if(extern_limit < extern_ptr + 4) {
        grow_extern_output();
    }
    _t7 = extern_ptr;
     *_t7 = __eax >> 24;
    _t7[1] = __eax >> 16;
    _t7[2] = __eax >> 8;
    _t7[3] = __bl;
    _t8 = _t7 + 4;
    extern_ptr = _t8;
    return _t8;
}

signed int extern_record_location(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x080645D2
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _t8;                        // _t8
    signed int* _t9;                       // _t9
    signed int* _t10;                      // _t10
    signed int _t12;                       // _t12
    signed char _t19;                      // _t19
    signed int* _t29;                      // _t29

    _t8 = __eax;
    _v12 = __ebx;
    _v8 = __esi;
    if(extern_ignore_sharing == 0) {
        _t9 = extern_trail_cur;
        if(_t9 == extern_trail_limit) {
             *__esp = 8204;
            malloc();
            _t29 = _t9;
            if(_t9 == 0) {
                extern_out_of_memory();
            }
             *_t29 = extern_trail_block;
            extern_trail_block = _t29;
            extern_trail_cur =  &(_t29[1]);
            extern_trail_limit =  &(_t29[0x803]);
        }
        __edx = __eax - 4;
        _t19 =  *__edx;
        _t10 = extern_trail_cur;
         *_t10 = _t19 >> 8 & 3 | __eax;
        _t10[1] =  *__eax;
        extern_trail_cur =  &(_t10[2]);
         *__edx = _t19 & 252 | 2;
        _t12 = obj_counter;
         *__eax = _t12;
        _t8 = _t12 + 1;
        obj_counter = _t8;
    }
    return _t8;
}

init_extern_output(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08064672
    intOrPtr* _t2;                         // _t2
    intOrPtr _t3;                          // _t3

    _t2 = __eax;
    extern_userprovided_output = 0;
     *__esp = 8108;
    malloc();
    extern_output_first = __eax;
    if(__eax == 0) {
        _t2 = caml_raise_out_of_memory();
    }
    extern_output_block = _t2;
     *_t2 = 0;
    extern_ptr = _t2 + 8;
    _t3 = _t2 + 8108;
    extern_limit = _t3;
    return _t3;
}

unsigned int extern_invalid_argument(
    signed int __eax                       // r0
)
{// addr = 0x080646BC
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v40;                     // _cfa_ffffffd8
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v56;                     // _cfa_ffffffc8
    unsigned int _v84;                     // _cfa_ffffffac
    char* _v128;                           // _cfa_ffffff80
    char* _v132;                           // _cfa_ffffff7c
    signed int __ebx;                      // r1
    signed int __edi;                      // r4
    signed int __esi;                      // r5
    unsigned int _t75;                     // _t75
    unsigned int _t79;                     // _t79
    signed int _t83;                       // _t83
    unsigned int _t90;                     // _t90
    unsigned int _t96;                     // _t96
    unsigned int _t102;                    // _t102
    char _t105;                            // _t105
    unsigned int _t119;                    // _t119
    unsigned int _t128;                    // _t128
    unsigned int _t131;                    // _t131
    signed int _t135;                      // _t135
    _unknown_ _t136;                       // _t136
    unsigned int _t138;                    // _t138
    signed int _t139;                      // _t139
    unsigned int _t141;                    // _t141
    unsigned int _t142;                    // _t142
    signed char _t152;                     // _t152
    char _t167;                            // _t167
    char _t172;                            // _t172
    _unknown_ _t174;                       // _t174

    _push(_t136);
    __esp = __esp - 20;
    extern_replay_trail();
    free_extern_output();
     *__esp = __eax;
    _t75 = caml_invalid_argument();
    _push(_t174);
    _push(_t169);
    _push(_t171);
    _push(__eax);
    __esp = __esp - 92;
    _t138 = _t75;
L3:
L3:
    if((_t138 & 1) == 0) {
        goto L13;
    } else {
        _t138 = _t138 >> 1;
        _t90 = _t138;
        if(_t138 > 63) {
            if(_t138 + 128 > 255) {
                if(_t90 + 32768 > 65535) {
                    _t79 = writecode32(2, _t138, _t138, _t171);
                } else {
                    _t79 = writecode16(1, _t138, _t138, _t171);
                }
            } else {
                _t79 = writecode8(0, _t138, _t138, _t171);
            }
        } else {
            if(extern_ptr >= extern_limit) {
                grow_extern_output();
            }
            _t96 = extern_ptr;
             *_t96 = _t138;
            _t79 = _t96 + 1;
            extern_ptr = _t79;
        }
    }
L73:
    __esp =  &(__esp[0x17]);
    _pop(__ebx);
    _pop(__esi);
    _pop(__edi);
    return _t79;
L13:
    _t171 = _t138;
    if(( *( *((intOrPtr*)((_t138 >> 23) * 4 +  &caml_page_table)) + (_t138 >> 12 & 2047)) & 7) == 0) {
        if(_t138 < caml_code_area_start || _t138 >= caml_code_area_end) {
            _t79 = "output_value: abstract value (outside heap)";
            extern_invalid_argument(_t79);
        } else {
            if(extern_closures == 0) {
                extern_invalid_argument("output_value: functional value");
            }
            _t79 = 16;
            writecode32(16, _t138, _t138 - caml_code_area_start, _t171);
            caml_code_checksum();
            writeblock(16, _t138, 16, _t171);
        }
        goto L73;
    }
    _t152 =  *(_t138 - 4);
    _t169 = _t152 & 255;
    if(_t169 != 250) {
L20:
        _t141 = _t152 >> 10;
        _v52 = _t141;
        if(_t141 != 0) {
            if((_t152 & 768) != 512) {
                _t83 = _t169 - 249;
                if(_t83 > 6) {
L56:
                    if(_t169 > 15 || _v52 > 7) {
                        writecode32(8, _t138, _t152 & 252, _t171);
                    } else {
                        if(extern_ptr >= extern_limit) {
                            grow_extern_output();
                        }
                        _t102 = extern_ptr;
                         *_t102 = ((_v52 & 255) << 4) + _t169 - 128;
                        extern_ptr = _t102 + 1;
                    }
                    _t142 = _v52;
                    size_32 = _t142 + size_32 + 1;
                    size_64 = _t142 + size_64 + 1;
                    _t169 =  *_t138;
                    extern_record_location(_t138, _t138, _t171);
                    _t138 =  *_t138;
                    if(_v52 == 1) {
                        goto L3;
                    } else {
                        L1();
                        _t169 = _v52 - 1;
                        _t139 = 1;
                        if(_t169 > 1) {
                            do {
                                L1();
                                _t139 = _t139 + 1;
                            } while(_t169 > _t139);
L66:
                            _t138 =  *(_t171 + _t169 * 4);
                            goto L3;
                        }
                        _t169 = 1;
                        goto L66;
                    }
                }
                switch( *((intOrPtr*)(_t83 * 4 +  &M0806BFEC))) {
                    case 0:
                        __ebx = _v52;
                        __ebx = _v52 << 2;
                        __edx = __ebx;
                        17 = writecode32(17, __ebx, __ebx, __esi);
                        __esi = __esi - __ebx;
                        L1();
                        goto L73;
                    case 1:
                        goto L56;
                    case 2:
                        "output_value: abstract value (Abstract)" = extern_invalid_argument("output_value: abstract value (Abstract)");
                        goto L73;
                    case 3:
                        _t105 = caml_string_length(_t138);
                        _t172 = _t105;
                        if(_t105 > 31) {
                            if(_t105 > 255) {
                                writecode32(10, _t138, _t105, _t172);
                            } else {
                                writecode8(9, _t138, _t105, _t172);
                            }
                        } else {
                            if(extern_ptr >= extern_limit) {
                                grow_extern_output();
                            }
                            _t119 = extern_ptr;
                             *_t119 = _t172 + 32;
                            extern_ptr = _t119 + 1;
                        }
                        writeblock(_t138, _t138, _t172, _t172);
                        size_32 = size_32 + (_t172 + 4 >> 2) + 1;
                        _t171 = _t172 + 8 >> 3;
                        size_64 = size_64 + (_t172 + 8 >> 3) + 1;
                        _t79 = extern_record_location(_t138, _t138, _t172 + 8 >> 3);
                        goto L73;
                    case 4:
                        __eax = extern_ptr;
                        if(extern_ptr >= extern_limit) {
                            1 = grow_extern_output();
                        }
                        __eax = extern_ptr;
                         *__eax = 12;
                        extern_ptr = __eax;
                        __edx = 8;
                        __ebx = writeblock(__ebx, __ebx, 8, __esi);
                        size_32 = size_32 + 3;
                        size_64 = size_64 + 2;
                        __ebx = extern_record_location(__ebx, __ebx, __esi);
                        goto L73;
                    case 5:
                        __esi = _v52;
                        __esi = _v52 >> 1;
                        if(__esi > 255) {
                            __edx = __esi;
                            7 = writecode32(7, __ebx, __esi, __esi);
                        } else {
                            __edx = __esi;
                            14 = writecode8(14, __ebx, __esi, __esi);
                        }
                        __edx = __esi * 8;
                        __ebx = writeblock(__ebx, __ebx, __esi * 8, __esi);
                        size_32 = size_32 + 1 + __esi * 2;
                        size_32 = size_32 + 1 + __esi * 2;
                        size_64 = __esi + size_64 + 1;
                        size_64 = __esi + size_64 + 1;
                        __ebx = extern_record_location(__ebx, __ebx, __esi);
                        goto L73;
                    case 6:
                        _v52 = __ebx;
                        __eax =  *__ebx;
                        __esi =  *__eax;
                        if( *((intOrPtr*)(__eax + 16)) == 0) {
                            "output_value: abstract value (Custom)" = extern_invalid_argument("output_value: abstract value (Custom)");
                        }
                        __eax = extern_ptr;
                        if(extern_ptr >= extern_limit) {
                            1 = grow_extern_output();
                        }
                        __eax = extern_ptr;
                         *__eax = 18;
                        extern_ptr = __eax;
                        __edi = __esi;
                        __eax = 0;
                        asm("repne scasb");
                        __edx = -1;
                        __edx =  !-1;
                        __esi = writeblock(__esi, __ebx,  !-1, __esi);
                        __edx = _v52;
                        __eax =  *_v52;
                        __edx =  &_v40;
                        _v128 =  &_v40;
                        __edx =  &_v36;
                        _v132 =  &_v36;
                         *__esp = __ebx;
                         *((intOrPtr*)( *_v52 + 16))();
                        _v36 = _v36 + 3;
                        __eax = _v36 + 3 >> 2;
                        __edx = size_32;
                        __eax = size_32 + (_v36 + 3 >> 2) + 2;
                        size_32 = size_32 + (_v36 + 3 >> 2) + 2;
                        _v40 = _v40 + 7;
                        __eax = _v40 + 7 >> 3;
                        __edx = size_64;
                        __eax = size_64 + (_v40 + 7 >> 3) + 2;
                        size_64 = size_64 + (_v40 + 7 >> 3) + 2;
                        __eax = __ebx;
                        extern_record_location(__ebx, __ebx, __esi);
                        goto L73;
                }
            }
            _t167 = obj_counter -  *_t138;
            if(_t167 > 255) {
                if(_t167 > 65535) {
                    _t79 = writecode32(6, _t138, _t167, _t171);
                } else {
                    _t79 = writecode16(5, _t138, _t167, _t171);
                }
            } else {
                _t79 = writecode8(4, _t138, _t167, _t171);
            }
            goto L73;
        }
        if(_t169 > 15) {
            _t79 = writecode32(8, _t138, _t152, _t171);
        } else {
            if(extern_ptr >= extern_limit) {
                grow_extern_output();
            }
            _t128 = extern_ptr;
             *_t128 = _t169 - 128;
            _t79 = _t128 + 1;
            extern_ptr = _t79;
        }
        goto L73;
    }
    _t131 =  *_t138;
    _v84 = _t131;
    if((_t131 & 1) != 0) {
L2:
        _t138 = _v84;
        goto L3;
    }
    _v56 = _t131;
    if(( *( *((intOrPtr*)((_t131 >> 23) * 4 +  &caml_page_table)) + (_v84 >> 12 & 2047)) & 7) == 0) {
        goto L20;
    }
    _t135 =  *(_v56 - 4) & 255;
    _v52 = _t135;
    if(_t135 == 250 || _t135 == 246 || _t135 == 253) {
        goto L20;
    } else {
        goto L2;
    }
}

unsigned int extern_rec(
    signed int __eax                       // r0
)
{// addr = 0x080646D7
    unsigned int _v32;                     // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    unsigned int _v48;                     // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    unsigned int _v80;                     // _cfa_ffffffb0
    char* _v100;                           // _cfa_ffffff9c
    char* _v104;                           // _cfa_ffffff98
    unsigned int __ebx;                    // r1
    signed int __esi;                      // r5
    signed int _t76;                       // _t76
    signed int _t81;                       // _t81
    signed int _t88;                       // _t88
    unsigned int _t97;                     // _t97
    unsigned int _t98;                     // _t98
    unsigned int _t104;                    // _t104
    char _t107;                            // _t107
    unsigned int _t122;                    // _t122
    unsigned int _t135;                    // _t135
    unsigned int _t136;                    // _t136
    unsigned int _t139;                    // _t139
    signed int _t143;                      // _t143
    signed int _t144;                      // _t144
    signed int _t145;                      // _t145
    signed int _t146;                      // _t146
    unsigned int _t149;                    // _t149
    unsigned int _t150;                    // _t150
    signed char _t160;                     // _t160
    char _t175;                            // _t175
    signed int _t177;                      // _t177
    signed int _t180;                      // _t180
    signed int _t181;                      // _t181
    char _t182;                            // _t182

    _t144 = __eax;
    while((_t144 & 1) == 0) {
        _t181 = _t144;
        if(( *( *((intOrPtr*)((_t144 >> 23) * 4 +  &caml_page_table)) + (_t144 >> 12 & 2047)) & 7) == 0) {
            if(_t144 < caml_code_area_start || _t144 >= caml_code_area_end) {
                _t76 = "output_value: abstract value (outside heap)";
                extern_invalid_argument(_t76);
                return _t76;
            } else {
                if(extern_closures == 0) {
                    extern_invalid_argument("output_value: functional value");
                }
                writecode32(16, _t144, _t144 - caml_code_area_start, _t181);
                caml_code_checksum();
                writeblock(16, _t144, 16, _t181);
                return 16;
            }
        }
        _t160 =  *(_t144 - 4);
        _t177 = _t160 & 255;
        if(_t177 != 250) {
L19:
            _t149 = _t160 >> 10;
            _v48 = _t149;
            if(_t149 != 0) {
                if((_t160 & 768) != 512) {
                    _t81 = _t177 - 249;
                    if(_t81 > 6) {
L55:
                        if(_t177 > 15 || _v48 > 7) {
                            writecode32(8, _t144, _t160 & 252, _t181);
                        } else {
                            if(extern_ptr >= extern_limit) {
                                grow_extern_output();
                            }
                            _t104 = extern_ptr;
                             *_t104 = ((_v48 & 255) << 4) + _t177 - 128;
                            extern_ptr = _t104 + 1;
                        }
                        _t150 = _v48;
                        size_32 = _t150 + size_32 + 1;
                        size_64 = _t150 + size_64 + 1;
                        _t178 =  *_t144;
                        extern_record_location(_t144, _t144, _t181);
                        _t144 =  *_t144;
                        if(_v48 == 1) {
                            continue;
                        } else {
                            extern_rec(_t178);
                            _t180 = _v48 - 1;
                            _t145 = 1;
                            if(_t180 > 1) {
                                do {
                                    extern_rec( *((intOrPtr*)(_t181 + _t145 * 4)));
                                    _t145 = _t145 + 1;
                                } while(_t180 > _t145);
L65:
                                _t144 =  *(_t181 + _t180 * 4);
                                continue;
                            }
                            _t180 = 1;
                            goto L65;
                        }
                    }
                    switch( *((intOrPtr*)(_t81 * 4 +  &M0806BFEC))) {
                        case 0:
                            __ebx = _v48;
                            __ebx = _v48 << 2;
                            __edx = __ebx;
                            17 = writecode32(17, __ebx, __ebx, __esi);
                            __eax = __esi;
                            __eax = __esi - __ebx;
                            return extern_rec(__esi - __ebx);
                        case 1:
                            goto L55;
                        case 2:
                            __eax = "output_value: abstract value (Abstract)";
                            return extern_invalid_argument("output_value: abstract value (Abstract)");
                        case 3:
                            _t107 = caml_string_length(_t144);
                            _t182 = _t107;
                            if(_t107 > 31) {
                                if(_t107 > 255) {
                                    writecode32(10, _t144, _t107, _t182);
                                } else {
                                    writecode8(9, _t144, _t107, _t182);
                                }
                            } else {
                                if(extern_ptr >= extern_limit) {
                                    grow_extern_output();
                                }
                                _t122 = extern_ptr;
                                 *_t122 = _t182 + 32;
                                extern_ptr = _t122 + 1;
                            }
                            writeblock(_t144, _t144, _t182, _t182);
                            size_32 = size_32 + (_t182 + 4 >> 2) + 1;
                            size_64 = size_64 + (_t182 + 8 >> 3) + 1;
                            return extern_record_location(_t144, _t144, _t182 + 8 >> 3);
                        case 4:
                            __eax = extern_ptr;
                            if(extern_ptr >= extern_limit) {
                                1 = grow_extern_output();
                            }
                            __eax = extern_ptr;
                             *__eax = 12;
                            extern_ptr = __eax;
                            __edx = 8;
                            __ebx = writeblock(__ebx, __ebx, 8, __esi);
                            size_32 = size_32 + 3;
                            size_64 = size_64 + 2;
                            __eax = __ebx;
                            return extern_record_location(__ebx, __ebx, __esi);
                        case 5:
                            __esi = _v48;
                            __esi = _v48 >> 1;
                            if(__esi > 255) {
                                __edx = __esi;
                                7 = writecode32(7, __ebx, __esi, __esi);
                            } else {
                                __edx = __esi;
                                14 = writecode8(14, __ebx, __esi, __esi);
                            }
                            __edx = __esi * 8;
                            __ebx = writeblock(__ebx, __ebx, __esi * 8, __esi);
                            size_32 = size_32 + 1 + __esi * 2;
                            size_32 = size_32 + 1 + __esi * 2;
                            size_64 = __esi + size_64 + 1;
                            size_64 = __esi + size_64 + 1;
                            __eax = __ebx;
                            return extern_record_location(__ebx, __ebx, __esi);
                        case 6:
                            _v48 = __ebx;
                            __eax =  *__ebx;
                            __esi =  *__eax;
                            if( *((intOrPtr*)(__eax + 16)) == 0) {
                                "output_value: abstract value (Custom)" = extern_invalid_argument("output_value: abstract value (Custom)");
                            }
                            __eax = extern_ptr;
                            if(extern_ptr >= extern_limit) {
                                1 = grow_extern_output();
                            }
                            __eax = extern_ptr;
                             *__eax = 18;
                            extern_ptr = __eax;
                            __eax = 0;
                            asm("repne scasb");
                            __edx = -1;
                            __edx =  !-1;
                            __esi = writeblock(__esi, __ebx,  !-1, __esi);
                            __edx = _v48;
                            __eax =  *_v48;
                            __edx =  &_v36;
                            _v100 =  &_v36;
                            __edx =  &_v32;
                            _v104 =  &_v32;
                             *__esp = __ebx;
                             *((intOrPtr*)( *_v48 + 16))();
                            _v32 = _v32 + 3;
                            __eax = _v32 + 3 >> 2;
                            __edx = size_32;
                            __eax = size_32 + (_v32 + 3 >> 2) + 2;
                            size_32 = size_32 + (_v32 + 3 >> 2) + 2;
                            _v36 = _v36 + 7;
                            __eax = _v36 + 7 >> 3;
                            __edx = size_64;
                            __eax = size_64 + (_v36 + 7 >> 3) + 2;
                            size_64 = size_64 + (_v36 + 7 >> 3) + 2;
                            __eax = __ebx;
                            extern_record_location(__eax, __ebx, __esi);
                            return __eax;
                    }
                }
                _t175 = obj_counter -  *_t144;
                if(_t175 > 255) {
                    if(_t175 > 65535) {
                        return writecode32(6, _t144, _t175, _t181);
                    }
                    return writecode16(5, _t144, _t175, _t181);
                }
                return writecode8(4, _t144, _t175, _t181);
            }
            if(_t177 > 15) {
                return writecode32(8, _t144, _t160, _t181);
            }
            if(extern_ptr >= extern_limit) {
                grow_extern_output();
            }
            _t135 = extern_ptr;
             *_t135 = _t177 - 128;
            _t136 = _t135 + 1;
            extern_ptr = _t136;
            return _t136;
        }
        _t139 =  *_t144;
        _v80 = _t139;
        if((_t139 & 1) != 0) {
L1:
            _t144 = _v80;
            continue;
        }
        _v52 = _t139;
        if(( *( *((intOrPtr*)((_t139 >> 23) * 4 +  &caml_page_table)) + (_v80 >> 12 & 2047)) & 7) == 0) {
            goto L19;
        }
        _t143 =  *(_v52 - 4) & 255;
        _v48 = _t143;
        if(_t143 == 250 || _t143 == 246 || _t143 == 253) {
            goto L19;
        } else {
            goto L1;
        }
    }
    _t146 = _t144 >> 1;
    _t88 = _t146;
    if(_t146 <= 63) {
        if(extern_ptr >= extern_limit) {
            grow_extern_output();
        }
        _t97 = extern_ptr;
         *_t97 = _t146 + 64;
        _t98 = _t97 + 1;
        extern_ptr = _t98;
        return _t98;
    }
    if(_t146 + 128 > 255) {
        if(_t88 + 32768 > 65535) {
            return writecode32(2, _t146, _t146, _t181);
        }
        return writecode16(1, _t146, _t146, _t181);
    } else {
        return writecode8(0, _t146, _t146, _t181);
    }
}

extern_value(
    signed int __eax,                      // r0
    signed int* __edx                      // r3
)
{// addr = 0x08064BCD
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1
    signed int _t9;                        // _t9
    intOrPtr _t16;                         // _t16
    intOrPtr* _t27;                        // _t27
    intOrPtr _t31;                         // _t31
    intOrPtr* _t33;                        // _t33

    _t9 = caml_convert_flag_list(__edx,  &extern_flags);
    extern_ignore_sharing = _t9 & 1;
    extern_closures = _t9 & 2;
    extern_trail_block =  &extern_trail_first;
    extern_trail_cur = 134712676;
    extern_trail_limit =  &extern_trail_block;
    obj_counter = 0;
    size_32 = 0;
    size_64 = 0;
    write32(-2070567234);
    extern_ptr = extern_ptr + 16;
    extern_rec(__eax);
    if(extern_userprovided_output == 0) {
        extern_output_block[1] = extern_ptr;
    }
    extern_replay_trail();
    _t16 = extern_userprovided_output;
    if(_t16 == 0) {
        _t33 = extern_output_first;
        _t31 = 0;
        if(_t33 != 0) {
            _t27 = _t33;
            do {
                _t31 = _t27[1] - _t27 + _t31 - 8;
                _t27 =  *_t27;
            } while(_t27 != 0);
        }
        extern_ptr = _t33 + 12;
        extern_limit = _t33 + 8108;
    } else {
        _t31 = extern_ptr - _t16;
        extern_ptr = _t16 + 4;
    }
    write32(_t31 - 20);
    write32(obj_counter);
    write32(size_32);
    write32(size_64);
    return _t31;
}

caml_output_value_to_block(
    signed int _a4,                        // _cfa_4
    signed int* _a8,                       // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x08064CEA
    intOrPtr _t5;                          // _t5

    _t5 = _a12;
    extern_userprovided_output = _t5;
    extern_ptr = _t5;
    extern_limit = _t5 + _a16;
    __edx = _a8;
    return extern_value(_a4, _a8);
}

caml_output_value_to_malloc(
    signed int _a4,                        // _cfa_4
    signed int* _a8,                       // _cfa_8
    intOrPtr* _a12,                        // _cfa_c
    intOrPtr* _a16                         // _cfa_10
)
{// addr = 0x08064D12
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    intOrPtr __esi;                        // r5
    intOrPtr* _t9;                         // _t9
    intOrPtr _t12;                         // _t12
    intOrPtr _t16;                         // _t16
    intOrPtr _t18;                         // _t18
    intOrPtr* _t19;                        // _t19
    intOrPtr _t21;                         // _t21

    init_extern_output(_t9);
    __edx = _a8;
    _t12 = extern_value(_a4, _a8);
    _t18 = _t12;
     *__esp = _t12;
    malloc();
    __esi = _t12;
    if(_t12 == 0) {
        extern_out_of_memory();
    }
     *_a12 = __esi;
     *_a16 = _t18;
    _t19 = extern_output_first;
    while(_t19 != 0) {
        _t16 = _t19 + 8;
        _t21 = _t19[1] - _t16;
        _v36 = _t21;
        _v40 = _t16;
         *__esp = __esi;
        memmove();
        __esi = __esi + _t21;
        _t19 =  *_t19;
    }
    return free_extern_output();
}

caml_output_value_to_buffer(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16,                       // _cfa_10
    signed int* _a20                       // _cfa_14
)
{// addr = 0x08064D81
    intOrPtr _t10;                         // _t10

    _t10 = (_a8 >> 1) + _a4;
    extern_userprovided_output = _t10;
    extern_ptr = _t10;
    extern_limit = _t10 + (_a12 >> 1);
    return extern_value(_a16, _a20) + _t13 + 1;
}

caml_output_value_to_string(
    _unknown_ __fp0,                       // r28
    signed int _a4,                        // _cfa_4
    signed int* _a8                        // _cfa_8
)
{// addr = 0x08064DB6
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr* __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    intOrPtr* _t11;                        // _t11
    _unknown_ _t14;                        // _t14
    intOrPtr _t17;                         // _t17
    intOrPtr _t20;                         // _t20
    _unknown_ _t21;                        // _t21
    intOrPtr _t22;                         // _t22
    intOrPtr _t24;                         // _t24
    intOrPtr* _t25;                        // _t25

    __fp0 = __fp0;
    init_extern_output(_t11);
    __edx = _a8;
    _t14 = extern_value(_a4, _a8);
    __ebx = extern_output_first;
    _v32 = caml_alloc_string(__ebx, _t20, _t22, __fp0, _t14);
    if(__ebx != 0) {
        _t21 = 0;
        while(1) {
            _t17 = __ebx + 8;
            _t24 = __ebx[1] - _t17;
            _v52 = _t24;
            _v56 = _t17;
             *__esp = _t21 + _v32;
            memmove();
            _t21 = _t21 + _t24;
            _t25 =  *__ebx;
             *__esp = __ebx;
            free();
            if(_t25 == 0) {
                goto L4;
            }
            __ebx = _t25;
        }
    }
L4:
    return _v32;
}

caml_output_val(
    intOrPtr* _a4,                         // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int* _a12                       // _cfa_c
)
{// addr = 0x08064E26
    _unknown_ _v36;                        // _cfa_ffffffdc (outparam)
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    intOrPtr* __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ _t11;                        // _t11

    __edi = _a4;
     *__esp = __edi;
    if(caml_channel_binary_mode() == 0) {
         *__esp = "output_value: not a binary channel";
        _t8 = caml_failwith();
    }
    init_extern_output(_t8);
    _t11 = extern_value(_a8, _a12);
    __ebx = extern_output_first;
    if(__ebx != 0) {
        while(1) {
            _t11 = caml_really_putblock(__edi, __ebx + 8, __ebx[1] - _t12);
            __esi =  *__ebx;
             *__esp = __ebx;
            free();
            if(__esi == 0) {
                goto L5;
            }
            __ebx = __esi;
        }
    }
L5:
    return _t11;
}

caml_output_value(
    char _a4,                              // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    _unknown_ _a12                         // _cfa_c
)
{// addr = 0x08064E96
    char* _v24;                            // _cfa_ffffffe8
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    intOrPtr* __ebx;                       // r1
    char* __esi;                           // r5
    intOrPtr* _t22;                        // _t22
    intOrPtr* _t25;                        // _t25

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 3;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _v24 =  &_a12;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _t22 = caml_channel_mutex_lock;
    if(_t22 != 0) {
         *__esp = __ebx;
         *_t22();
    }
    caml_output_val(__ebx, _a8, _a12);
    _t25 = caml_channel_mutex_unlock;
    if(_t25 != 0) {
         *__esp = __ebx;
         *_t25();
    }
    caml_local_roots = __esi;
    return 1;
}

signed int caml_deserialize_uint_1()
{// addr = 0x08064F1C
    signed char* _t1;                      // _t1

    _t1 = intern_src;
    intern_src =  &(_t1[1]);
    return  *_t1 & 255;
}

caml_deserialize_sint_1()
{// addr = 0x08064F33
    char* _t1;                             // _t1

    _t1 = intern_src;
    intern_src = _t1 + 1;
    return  *_t1;
}

caml_deserialize_uint_2()
{// addr = 0x08064F4A
    signed char* _t4;                      // _t4

    __edx = intern_src;
    _t4 =  &(__edx[2]);
    intern_src = _t4;
    return ( *(_t4 - 1) & 255) + (( *__edx & 255) << 8);
}

caml_deserialize_sint_2()
{// addr = 0x08064F6A
    signed char* _t3;                      // _t3
    signed char* _t7;                      // _t7

    _t3 = intern_src;
    _t7 =  &(_t3[2]);
    intern_src = _t7;
    return ( *_t3 << 8) + ( *(_t7 - 1) & 255);
}

caml_deserialize_uint_4()
{// addr = 0x08064F89
    signed char* _t11;                     // _t11
    signed char* _t14;                     // _t14

    _t11 = intern_src;
    _t14 =  &(_t11[4]);
    intern_src = _t14;
    return ( *(_t14 - 1) & 255) + (( *_t11 & 255) << 24) + (( *(_t14 - 3) & 255) << 16) + (( *(_t14 - 2) & 255) << 8);
}

caml_deserialize_sint_4()
{// addr = 0x08064FBE
    signed char* _t11;                     // _t11
    signed char* _t14;                     // _t14

    _t11 = intern_src;
    _t14 =  &(_t11[4]);
    intern_src = _t14;
    return ( *(_t14 - 1) & 255) + (( *_t11 & 255) << 24) + (( *(_t14 - 3) & 255) << 16) + (( *(_t14 - 2) & 255) << 8);
}

caml_deserialize_block_2(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08064FF3
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    _unknown_ __edi;                       // r4
    _unknown_ _t16;                        // _t16
    _unknown_ _t17;                        // _t17
    signed int _t20;                       // _t20

    __ebx = _a4;
    _t20 = _a8;
    __ecx = intern_src;
    if(_t20 > 0) {
        _t17 = 0;
        _v24 = _t20;
        _v20 = _t20;
        do {
             *((char*)(__ebx + _t17)) =  *(__ecx + _t17 + 1) & 255;
             *((char*)(__ebx + _t17 + 1)) =  *(__ecx + _t17) & 255;
            _t17 = _t17 + 2;
            _v24 = _v24 - 1;
        } while(_v24 != 0);
        __ecx = __ecx + _v20 * 2;
    }
    intern_src = __ecx;
    return _t16;
}

signed int caml_deserialize_block_4(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08065048
    signed int _v20;                       // _cfa_ffffffec
    _unknown_ __ebx;                       // r1
    signed int _t24;                       // _t24
    _unknown_ _t25;                        // _t25

    __ecx = _a4;
    __edx = intern_src;
    if(_a8 > 0) {
        _t25 = 0;
        _v20 = _a8;
        do {
             *((char*)(__ecx + _t25)) =  *(__edx + _t25 + 3) & 255;
             *((char*)(__ecx + _t25 + 1)) =  *(__edx + _t25 + 2) & 255;
             *((char*)(__ecx + _t25 + 3)) =  *(__edx + _t25) & 255;
             *((char*)(__ecx + _t25 + 2)) =  *(__edx + _t25 + 1) & 255;
            _t25 = _t25 + 4;
            _v20 = _v20 - 1;
        } while(_v20 != 0);
        _t24 = _a8;
        __edx = __edx + _t24 * 4;
    }
    intern_src = __edx;
    return _t24;
}

caml_deserialize_float_4()
{// addr = 0x080650AE
    char _v8;                              // _cfa_fffffff8
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_deserialize_block_4( &_v8, 1);
}

signed int caml_deserialize_block_8(
    char* _a4,                             // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x080650CC
    signed char* _v20;                     // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t26;                       // _t26
    signed char* _t27;                     // _t27
    signed char* _t37;                     // _t37

    _t37 = intern_src;
    if(_a8 > 0) {
        __edx = _a4;
        _t27 = _t37;
        _v24 = _a8;
        _v20 = _t37;
        do {
             *__edx = _t27[7] & 255;
            __edx[1] = _t27[6] & 255;
            __edx[7] =  *_t27 & 255;
            __edx[6] = _t27[1] & 255;
            __edx[2] = _t27[5] & 255;
            __edx[3] = _t27[4] & 255;
            __edx[5] = _t27[2] & 255;
            __edx[4] = _t27[3] & 255;
            _t27 =  &(_t27[8]);
            __edx = __edx + 8;
            _v24 = _v24 - 1;
        } while(_v24 != 0);
        _t26 = _a8;
        _t37 = _v20 + _t26 * 8;
    }
    intern_src = _t37;
    return _t26;
}

caml_deserialize_sint_8()
{// addr = 0x08065154
    _unknown_ _v8;                         // _cfa_fffffff8
    char _v12;                             // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    caml_deserialize_block_8( &_v12, 1);
    return _v12;
}

caml_deserialize_uint_8()
{// addr = 0x08065175
    _unknown_ _v8;                         // _cfa_fffffff8
    char _v12;                             // _cfa_fffffff4
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    caml_deserialize_block_8( &_v12, 1);
    return _v12;
}

caml_marshal_data_size(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08065196
    signed char* _t15;                     // _t15
    signed char* _t16;                     // _t16
    signed char* _t30;                     // _t30

    _t30 = (_a8 >> 1) + _a4;
    intern_input_malloced = 0;
    _t15 =  &(_t30[4]);
    intern_src = _t15;
    if(( *(_t15 - 1) & 255) + (( *_t30 & 255) << 24) + (( *(_t15 - 3) & 255) << 16) + (( *(_t15 - 2) & 255) << 8) != -2070567234) {
         *__esp = "Marshal.data_size: bad object";
        _t15 = caml_failwith();
    }
    _t16 =  &(_t15[4]);
    intern_src = _t16;
    return (( *(_t16 - 4) & 255) << 24) + ( *(_t16 - 1) & 255) + (( *(_t16 - 3) & 255) << 16) + (( *(_t16 - 2) & 255) << 8) + (( *(_t16 - 4) & 255) << 24) + ( *(_t16 - 1) & 255) + (( *(_t16 - 3) & 255) << 16) + (( *(_t16 - 2) & 255) << 8) + 1;
}

intern_cleanup()
{// addr = 0x08065217
    intOrPtr _t4;                          // _t4

    if(intern_input_malloced != 0) {
        caml_stat_free(intern_input);
    }
    _t2 = intern_obj_table;
    if(intern_obj_table != 0) {
        caml_stat_free(_t2);
    }
    _t3 = intern_extra_block;
    if(intern_extra_block != 0) {
        return caml_free_for_heap(_t3);
    }
    _t4 = intern_block;
    if(_t4 != 0) {
         *((intOrPtr*)(_t4 - 4)) = intern_header;
        return _t4;
    }
    return _t4;
}

caml_deserialize_error(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806526B
    signed int _v20;                       // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    signed int _v48;                       // _cfa_ffffffd0
    signed char* _v52;                     // _cfa_ffffffcc
    _unknown_ __ebx;                       // r1
    intOrPtr _t10;                         // _t10
    _unknown_ _t11;                        // _t11
    signed int _t13;                       // _t13
    _unknown_ _t14;                        // _t14

    intern_cleanup();
     *__esp = _a4;
    caml_failwith();
    _push(_t14);
    _push(_t11);
    __esp = __esp - 20;
    _t13 = _v20 << 3;
    _v48 = _t13;
    _v52 = intern_src;
    _t10 = _v24;
     *__esp = _t10;
    memmove();
    intern_src = intern_src + _t13;
    __esp = __esp + 20;
    _pop(__ebx);
    return _t10;
}

caml_deserialize_block_float_8(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08065281
    signed int _v20;                       // _cfa_ffffffec
    signed char* _v24;                     // _cfa_ffffffe8
    _unknown_ __ebx;                       // r1
    intOrPtr _t6;                          // _t6
    signed int _t8;                        // _t8

    _t8 = _a8 << 3;
    _v20 = _t8;
    _v24 = intern_src;
    _t6 = _a4;
     *__esp = _t6;
    memmove();
    intern_src = intern_src + _t8;
    return _t6;
}

caml_deserialize_float_8()
{// addr = 0x080652B2
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)

    return caml_deserialize_block_float_8( &_v20, 1);
}

caml_deserialize_block_1(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x080652D0
    intOrPtr _v20;                         // _cfa_ffffffec
    signed char* _v24;                     // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    intOrPtr _t6;                          // _t6

    __ebx = _a8;
    _v20 = __ebx;
    _v24 = intern_src;
    _t6 = _a4;
     *__esp = _t6;
    memmove();
    intern_src = intern_src + __ebx;
    return _t6;
}

caml_code_checksum()
{// addr = 0x080652FE
    char _v100;                            // _cfa_ffffff9c
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)

    if(checksum_computed.3405 == 0) {
        caml_MD5Init( &_v100);
        caml_MD5Update( &_v100, caml_code_area_start, caml_code_area_end - caml_code_area_start);
        caml_MD5Final( &checksum.3404,  &_v100);
        checksum_computed.3405 = 1;
    }
    return  &checksum.3404;
}

signed int intern_alloc(
    signed int __eax,                      // r0
    signed int __edx,                      // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0806535B
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1
    signed int* _t9;                       // _t9
    signed int* _t10;                      // _t10
    signed int* _t14;                      // _t14
    signed int _t19;                       // _t19
    signed int _t20;                       // _t20

    __esi = __esi;
    __edi = __edi;
    if(__eax != 0) {
        _t19 = __eax - 1;
        if(_t19 <= 4194303) {
            if(_t19 != 0) {
                if(_t19 > 256) {
                    intern_block = caml_alloc_shr(__edx, __edi, __esi, _t19, 252);
                } else {
                    intern_block = caml_alloc_small(__edx, __esi, _t19, 252);
                }
            } else {
                intern_block = 134722388;
            }
            _t9 = intern_block - 4;
            _t20 =  *_t9;
            intern_header = _t20;
            intern_color = _t20 & 768;
            intern_dest = _t9;
            intern_extra_block = 0;
        } else {
            _t14 = caml_alloc_for_heap(4095 + __eax * 4 & -4096);
            intern_extra_block = _t14;
            if(_t14 == 0) {
                _t14 = caml_raise_out_of_memory();
            }
            intern_color = caml_allocation_color(_t14);
            _t9 = intern_extra_block;
            intern_dest = _t9;
        }
        obj_counter = 0;
        if(__edx == 0) {
            intern_obj_table = 0;
            return _t9;
        } else {
            _t10 = caml_stat_alloc(_t9, __edx << 2);
            intern_obj_table = _t10;
            return _t10;
        }
    }
    intern_obj_table = 0;
    intern_extra_block = 0;
    intern_block = 0;
    return __eax;
}

signed char* intern_rec(
    intOrPtr* __eax                        // r0
)
{// addr = 0x08065470
    intOrPtr* _v64;                        // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    signed int _v84;                       // _cfa_ffffffac
    signed char* _v88;                     // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    intOrPtr __esi;                        // r5
    signed char* _t39;                     // _t39
    signed char* _t40;                     // _t40
    signed int _t43;                       // _t43
    signed int _t44;                       // _t44
    intOrPtr _t47;                         // _t47
    intOrPtr* _t48;                        // _t48
    signed int _t53;                       // _t53
    signed int _t54;                       // _t54
    signed int _t57;                       // _t57
    signed int _t61;                       // _t61
    intOrPtr _t64;                         // _t64
    signed char _t68;                      // _t68
    intOrPtr _t70;                         // _t70
    signed int _t78;                       // _t78
    intOrPtr _t84;                         // _t84
    signed int _t85;                       // _t85
    signed int _t86;                       // _t86

    _v64 = __eax;
    __esi = 134660516;
    while(1) {
        _t39 = intern_src;
        _t68 =  *_t39 & 255;
        _t53 = _t68 & 255;
        _t40 =  &(_t39[1]);
        intern_src = _t40;
        if(_t53 <= 63) {
            break;
        }
        if(_t53 <= 127) {
            __esi = (_t53 & 63) + (_t53 & 63) + 1;
        } else {
            _t78 = _t53 & 15;
            _t57 = _t53 >> 4 & 7;
            if(_t57 != 0) {
                _t64 = intern_dest + 4;
                 *_v64 = _t64;
                _t47 = intern_obj_table;
                if(_t47 != 0) {
                    _t86 = obj_counter;
                     *((intOrPtr*)(_t47 + _t86 * 4)) = _t64;
                    obj_counter = _t86 + 1;
                }
                _t48 = intern_dest;
                _v64 = _t48 + 4;
                 *_t48 = _t78 + intern_color + (_t57 << 10);
                intern_dest = intern_dest + 4 + _t57 * 4;
                if(_t57 > 1) {
                    _t85 = _t57;
                    _v68 = _v64;
                    do {
                        intern_rec(_v68);
                        _t85 = _t85 - 1;
                        _v68 = _v68 + 4;
                    } while(_t85 > 1);
                    _v64 = _v64 + _t57 * 4 - 4;
                }
                continue;
L20:
            } else {
                __esi = 134721380 + _t78 * 4;
            }
        }
L19:
         *_v64 = __esi;
        return _t40;
        goto L20;
    }
    if(_t53 <= 31) {
        if(_t68 <= 19) {
            goto ( *((intOrPtr*)(__esi + (_t68 & 255) * 4)));
        }
        intern_cleanup();
         *__esp = "input_value: ill-formed message";
        _t40 = caml_failwith();
    } else {
        _t54 = _t53 & 31;
        _t43 = _t54 + 4 >> 2;
        _t84 = intern_dest + 4;
        __esi = _t84;
        _t70 = intern_obj_table;
        if(_t70 != 0) {
            _t61 = obj_counter;
             *((intOrPtr*)(_t70 + _t61 * 4)) = _t84;
            obj_counter = _t61 + 1;
        }
         *intern_dest = intern_color + (_t43 << 10) + 252;
        intern_dest = intern_dest + 4 + _t43 * 4;
        _t44 = _t43 << 2;
         *((intOrPtr*)(__esi + _t44 - 4)) = 0;
         *((char*)(_t44 - 1 + __esi)) = _t44 - 1 - _t54;
        _v84 = _t54;
        _t40 = intern_src;
        _v88 = _t40;
         *__esp = _t84;
        memmove();
        intern_src =  &(intern_src[_t54]);
    }
    goto L19;
}

signed int intern_add_to_heap(
    signed int __eax                       // r0
)
{// addr = 0x08065AD6
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int _t12;                       // _t12

    _t12 = intern_extra_block;
    if(_t12 != 0) {
        _t13 = _t12 + (4095 + __eax * 4 & -4096);
        _t8 = intern_dest;
        if(_t12 + (4095 + __eax * 4 & -4096) > intern_dest) {
            caml_make_free_blocks(_t8, _t13 - _t8 >> 2, 0);
        }
        caml_allocated_words = caml_allocated_words + (intern_dest - intern_extra_block >> 2);
        return caml_add_to_heap(intern_extra_block);
    }
    return __eax;
}

input_val_from_block(
    intOrPtr __edi                         // r4
)
{// addr = 0x08065B36
    char _v16;                             // _cfa_fffffff0
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed char* _t13;                     // _t13

    __edi = __edi;
    _t13 = intern_src;
    _t35 =  &(_t13[8]);
    intern_src =  &(_t13[0xc]);
    intern_alloc((( *( &(_t13[8]) - 4) & 255) << 24) + ( *( &(_t13[8]) - 1) & 255) + (( *( &(_t13[8]) - 3) & 255) << 16) + (( *(_t35 - 2) & 255) << 8), ( *( &(_t13[4]) - 1) & 255) + (( *_t13 & 255) << 24) + (( *( &(_t13[4]) - 3) & 255) << 16) + (( *( &(_t13[4]) - 2) & 255) << 8), __edi, ( *( &(_t13[8]) - 3) & 255) << 16);
    intern_rec( &_v16);
    intern_add_to_heap((( *( &(_t13[8]) - 4) & 255) << 24) + ( *( &(_t13[8]) - 1) & 255) + (( *( &(_t13[8]) - 3) & 255) << 16) + (( *(_t35 - 2) & 255) << 8));
    _t21 = intern_obj_table;
    if(intern_obj_table != 0) {
        caml_stat_free(_t21);
    }
    return _v16;
}

caml_input_value_from_block(
    intOrPtr __edi,                        // r4
    signed char* _a4,                      // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08065BC0
    signed char* _t16;                     // _t16
    signed char* _t17;                     // _t17
    signed char* _t30;                     // _t30

    __edi = __edi;
    _t30 = _a4;
    intern_input = _t30;
    intern_input_malloced = 0;
    _t16 =  &(_t30[4]);
    intern_src = _t16;
    if(( *(_t16 - 1) & 255) + (( *_t30 & 255) << 24) + (( *(_t16 - 3) & 255) << 16) + (( *(_t16 - 2) & 255) << 8) != -2070567234) {
         *__esp = "input_value_from_block: bad object";
        _t16 = caml_failwith();
    }
    _t17 =  &(_t16[4]);
    intern_src = _t17;
    if(( *(_t17 - 1) & 255) + (( *(_t17 - 4) & 255) << 24) + 20 + (( *(_t17 - 3) & 255) << 16) + (( *(_t17 - 2) & 255) << 8) > _a8) {
         *__esp = "input_value_from_block: bad block length";
        caml_failwith();
    }
    return input_val_from_block(__edi);
}

caml_input_value_from_malloc(
    intOrPtr __edi,                        // r4
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08065C57
    signed char* _t8;                      // _t8
    _unknown_ _t10;                        // _t10
    intOrPtr _t19;                         // _t19
    signed char* _t20;                     // _t20

    __edi = __edi;
    _t19 = _a4;
    intern_input = _t19;
    _t20 = _t19 + _a8;
    intern_input_malloced = 1;
    _t8 =  &(_t20[4]);
    intern_src = _t8;
    if(( *(_t8 - 1) & 255) + (( *_t20 & 255) << 24) + (( *(_t8 - 3) & 255) << 16) + (( *(_t8 - 2) & 255) << 8) != -2070567234) {
         *__esp = "input_value_from_malloc: bad object";
        _t8 = caml_failwith();
    }
    intern_src =  &(_t8[4]);
    _t10 = input_val_from_block(__edi);
    caml_stat_free(intern_input);
    return _t10;
}

caml_input_val_from_string(
    char _a4,                              // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08065CD3
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    char* _v84;                            // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    signed int _v112;                      // _cfa_ffffff90
    char* __ebx;                           // r1
    _unknown_ __edi;                       // r4
    char* __esi;                           // r5
    signed char* _t43;                     // _t43
    signed char* _t57;                     // _t57

    __ebx = caml_local_roots;
    _v60 = __ebx;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _v64 = 0;
    _v96 =  &_v60;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 1;
    __esi =  &_v64;
    _v84 =  &_v64;
    _t43 = _a8 + _a4 + 8;
    intern_input_malloced = 0;
    _t56 =  &(_t43[4]);
    _t57 =  &(_t43[8]);
    _v112 = ( *(_t57 - 4) & 255) << 24;
    _v112 = ( *(_t57 - 1) & 255) + _v112;
    _t79 = (( *(_t57 - 3) & 255) << 16) + _v112 + (( *(_t57 - 2) & 255) << 8);
    intern_src =  &(_t43[0xc]);
    intern_alloc((( *(_t57 - 3) & 255) << 16) + _v112 + (( *(_t57 - 2) & 255) << 8), ( *( &(_t43[4]) - 1) & 255) + (( *_t43 & 255) << 24) + (( *(_t56 - 3) & 255) << 16) + (( *(_t56 - 2) & 255) << 8), (( *(_t57 - 3) & 255) << 16) + _v112 + (( *(_t57 - 2) & 255) << 8),  &_v64);
    intern_src = _a8 + _a4 + 20;
    intern_rec( &_v64);
    intern_add_to_heap(_t79);
    _t53 = intern_obj_table;
    if(intern_obj_table != 0) {
        caml_stat_free(_t53);
    }
    caml_local_roots = __ebx;
    return _v64;
}

caml_input_value_from_string(
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08065DD2
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_input_val_from_string(_a4, _a8 >> 1);
}

caml_input_val(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08065DEE
    char _v32;                             // _cfa_ffffffe0
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    _unknown_ _v68;                        // _cfa_ffffffbc (outparam)
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    intOrPtr* __ebx;                       // r1
    signed int __edi;                      // r4
    signed char* __esi;                    // r5
    signed char* _t17;                     // _t17

    __ebx = _a4;
     *__esp = __ebx;
    if(caml_channel_binary_mode() == 0) {
         *__esp = "input_value: not a binary channel";
        caml_failwith();
    }
    if(caml_getword(__ebx) != -2070567234) {
         *__esp = "input_value: bad object";
        caml_failwith();
    }
    __edi = caml_getword(__ebx);
    _v52 = caml_getword(__ebx);
    _v48 = caml_getword(__ebx);
    _t17 = caml_stat_alloc(caml_getword(__ebx), __edi);
    __esi = _t17;
    if(caml_really_getblock(__ebx, _t17, __edi) == 0) {
        caml_stat_free(__esi);
         *__esp = "input_value: truncated object";
        caml_failwith();
    }
    intern_input = __esi;
    intern_input_malloced = 1;
    intern_src = __esi;
    __edx = _v52;
    intern_alloc(_v48, _v52, __edi, __esi);
    intern_rec( &_v32);
    intern_add_to_heap(_v48);
    caml_stat_free(intern_input);
    _t27 = intern_obj_table;
    if(intern_obj_table != 0) {
        caml_stat_free(_t27);
    }
    return _v32;
}

caml_input_value(
    char _a4                               // _cfa_4
)
{// addr = 0x08065EE1
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    intOrPtr* __ebx;                       // r1
    char* __esi;                           // r5
    intOrPtr* _t21;                        // _t21
    intOrPtr* _t22;                        // _t22

    __esi = caml_local_roots;
    _v44 = __esi;
    caml_local_roots =  &_v44;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    __ebx =  *((intOrPtr*)(_a4 + 4));
    _v48 = 0;
    _v80 =  &_v44;
    caml_local_roots =  &_v80;
    _v72 = 1;
    _v76 = 1;
    _v68 =  &_v48;
    _t21 = caml_channel_mutex_lock;
    if(_t21 != 0) {
         *__esp = __ebx;
         *_t21();
    }
    caml_input_val(__ebx);
    _v48 = _t21;
    _t22 = caml_channel_mutex_unlock;
    if(_t22 != 0) {
         *__esp = __ebx;
         *_t22();
    }
    caml_local_roots = __esi;
    return _v48;
}

signed int caml_hash_variant(
    signed char* _a4                       // _cfa_4
)
{// addr = 0x08065F80
    signed int _t4;                        // _t4

    __edx = _a4;
    _t4 = 1;
    while( *__edx != 0) {
        _t4 = (_t4 >> 1) * 223 + ( *__edx & 255) + (_t4 >> 1) * 223 + ( *__edx & 255) + 1;
        __edx =  &(__edx[1]);
    }
    return _t4;
}

signed int hash_aux(
    unsigned int __eax                     // r0
)
{// addr = 0x08065FAB
    signed int _v32;                       // _cfa_ffffffe0
    signed int __ebx;                      // r1
    signed int __edi;                      // r4
    unsigned int __esi;                    // r5
    signed int _t49;                       // _t49
    signed int _t52;                       // _t52
    intOrPtr _t56;                         // _t56
    signed int _t58;                       // _t58
    unsigned int _t64;                     // _t64
    intOrPtr _t68;                         // _t68
    signed char _t72;                      // _t72
    signed char _t73;                      // _t73
    signed int _t76;                       // _t76
    signed int _t78;                       // _t78
    signed int _t81;                       // _t81

    _t78 = __eax;
    _t68 = hash_univ_limit - 1;
    hash_univ_limit = _t68;
    _t49 = hash_univ_count;
    if(_t49 < 0 || _t68 < 0) {
L32:
        return _t49;
    } else {
        if((__eax & 1) != 0) {
L5:
            hash_univ_count = _t49 - 1;
            _t52 = (_t78 >> 1) + hash_accu * 65599;
            hash_accu = _t52;
            return _t52;
        }
        if(( *( *((intOrPtr*)((__eax >> 23) * 4 +  &caml_page_table)) + (__eax >> 12 & 2047)) & 7) != 0) {
            while(1) {
L7:
                _t64 = __eax - 4;
                _t72 =  *_t64 & 255;
                __edi = _t72 & 255;
                _v32 = _t72 & 255;
                _t73 = _t72 + 8;
                if(_t73 > 7) {
                    break;
                }
                switch( *((intOrPtr*)((_t73 & 255) * 4 +  &M0806C1F4))) {
                    case 0:
                        hash_univ_count = __eax;
                         *(__ebx + 4) =  *(__ebx + 4) >> 1;
                        __edx = hash_accu * 65599;
                        __eax = ( *(__ebx + 4) >> 1) + hash_accu * 65599;
                        hash_accu = __eax;
                        return __eax;
                    case 1:
                         *__ecx =  *__ecx >> 10;
                        __eax =  *__ecx >> 10 << 2;
                        __eax = __ebx;
                        return hash_aux(__ebx);
                    case 2:
                        __esi =  *__esi;
                        if((__esi & 1) == 0) {
                            __ebx = __esi;
                            __esi = __esi >> 23;
                            __esi = __esi >> 12;
                            __edx = __esi >> 12 & 2047;
                            __ecx =  *((__esi >> 23) * 4 +  &caml_page_table);
                            if(( *(__ecx + (__esi >> 12 & 2047)) & 7) == 0) {
L31:
                                _t58 = hash_accu * 65599;
                                hash_accu = __eax + _t58;
                                return _t58;
                            }
                            goto L7;
                        }
                        goto L5;
                    case 3:
                        goto L32;
                    case 4:
                        hash_univ_count = _t49 - 1;
                        _t49 = caml_string_length(_t78);
                        if(_t49 == 0) {
                            goto L32;
                        }
                        _t76 = hash_accu;
                        do {
                            _t76 = _t76 + (_t76 + _t76 * 8) * 2 + ( *_t78 & 255);
                            _t78 = _t78 + 1;
                            _t49 = _t49 - 1;
                        } while(_t49 != 0);
                        hash_accu = _t76;
                        return _t49;
                    case 5:
                        hash_univ_count = __eax;
                        __eax = hash_accu;
                        __ecx = __esi + 8;
                        do {
                            __edx = __eax + __eax * 8;
                            __edx = __eax + (__eax + __eax * 8) * 2;
                            __eax =  *__esi & 255;
                            __eax = __edx + ( *__esi & 255);
                            __esi = __esi + 1;
                        } while(__esi != __ecx);
                        hash_accu = __eax;
                        return __eax;
                    case 6:
                        hash_univ_count = __eax;
                         *__ecx =  *__ecx >> 10;
                        __eax =  *__ecx >> 10 << 2;
                        _v32 = __eax;
                        if(__eax == 0) {
                            goto L32;
                        }
                        __edx = hash_accu;
                        __esi = 0;
                        do {
                            __eax = __ebx;
                            __ebx = __ebx + 8;
                            __ecx = __ebx;
                            do {
                                __edi = __edx + __edx * 8;
                                __edi = __edx + (__edx + __edx * 8) * 2;
                                __edx =  *__eax & 255;
                                __edx = __edi + ( *__eax & 255);
                                __eax = __eax + 1;
                            } while(__ecx != __eax);
                            __esi = __esi + 8;
                        } while(__esi < _v32);
                        hash_accu = __edx;
                        return __eax;
                    case 7:
                        __edx =  *__esi;
                        __edx =  *( *__esi + 12);
                        if(__edx == 0) {
                            goto L32;
                        }
                        __eax = __eax - 1;
                        hash_univ_count = __eax;
                        __ebx = hash_accu * 65599;
                         *__esp = __esi;
                         *__edx();
                        __ebx = __eax + hash_accu * 65599;
                        hash_accu = __eax + hash_accu * 65599;
                        return __eax;
                }
            }
            hash_univ_count = _t49 - 1;
            _t49 = hash_accu + (hash_accu + _t54 * 8) * 2 + _v32;
            hash_accu = _t49;
            _t81 =  *_t64 >> 10;
            if(_t81 == 0) {
                goto L32;
            } else {
                goto L29;
            }
            do {
L29:
                _t81 = _t81 - 1;
                _t56 =  *((intOrPtr*)(__eax + _t81 * 4));
                hash_aux(_t56);
            } while(_t81 != 0);
            return _t56;
        }
        goto L31;
    }
}

caml_hash_univ_param(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    unsigned int _a12                      // _cfa_c
)
{// addr = 0x080661EF
    hash_univ_limit = _a8 >> 1;
    hash_univ_count = _a4 >> 1;
    hash_accu = 0;
    hash_aux(_a12);
    return (hash_accu & 1073741823) + (hash_accu & 1073741823) + 1;
}

caml_sys_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08066230
    intOrPtr _t4;                          // _t4

    caml_exe_name = _a4;
    _t4 = _a8;
    caml_main_argv = _t4;
    return _t4;
}

intOrPtr* caml_sys_get_config(
    intOrPtr __edi                         // r4
)
{// addr = 0x08066245
    _unknown_ _v16;                        // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    char* __ebx;                           // r1
    intOrPtr* _t22;                        // _t22

    __edi = __edi;
    __ebx = caml_local_roots;
    _v16 = 0;
    _v20 = 0;
    _v52 = __ebx;
    caml_local_roots =  &_v52;
    _v44 = 1;
    _v48 = 2;
    _v40 =  &_v16;
    _v36 =  &_v20;
    _v20 = caml_copy_string(__ebx, __edi, __esi, 134660628);
    _t22 = caml_alloc_small(__ebx, __esi, 2, 0);
    _v16 = _t22;
     *_t22 = _v20;
     *((intOrPtr*)(_v16 + 4)) = 65;
    caml_local_roots = __ebx;
    return _v16;
}

intOrPtr* caml_sys_get_argv(
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x080662C9
    char _v16;                             // _cfa_fffffff0
    char _v20;                             // _cfa_ffffffec
    _unknown_ _v24;                        // _cfa_ffffffe8
    char* _v36;                            // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    char _v56;                             // _cfa_ffffffc8
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    char* __ebx;                           // r1
    intOrPtr* _t31;                        // _t31

    __esi = __esi;
    __edi = __edi;
    __ebx = caml_local_roots;
    _v16 = 0;
    _v20 = 0;
    _v24 = 0;
    _v56 = __ebx;
    caml_local_roots =  &_v56;
    _v48 = 1;
    _v52 = 3;
    _v44 =  &_v16;
    _v40 =  &_v20;
    _v36 =  &_v24;
    _v16 = caml_copy_string(__ebx, __edi, __esi, caml_exe_name);
    _v20 = caml_copy_string_array(caml_main_argv);
    _t31 = caml_alloc_small(__ebx, __esi, 2, 0);
    _v24 = _t31;
     *_t31 = _v16;
     *((intOrPtr*)(_v24 + 4)) = _v20;
    caml_local_roots = __ebx;
    return _v24;
}

caml_sys_random_seed(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0806636A
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v32;                       // _cfa_ffffffe0
    _unknown_ _v36;                        // _cfa_ffffffdc
    intOrPtr _v56;                         // _cfa_ffffffc8

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _v56 = 0;
     *__esp =  &_v36;
    gettimeofday();
    getppid();
    getpid();
    return (_v32 ^ _v36 ^  &_v36 ^  &_v36 << 16) + (_v32 ^ _v36 ^  &_v36 ^  &_v36 << 16) + 1;
}

caml_sys_time()
{// addr = 0x080663BC
    char _v84;                             // _cfa_ffffffac
    char* _v104;                           // _cfa_ffffff98

    _v104 =  &_v84;
     *__esp = 0;
    getrusage();
    asm("fild dword [ebp-0x50]");
    asm("fild dword [ebp-0x4c]");
    asm("fxch st0, st1");
    asm("faddp st2, st0");
    asm("fild dword [ebp-0x48]");
    asm("faddp st2, st0");
    asm("fild dword [ebp-0x44]");
    asm("fdivrp st1, st0");
    asm("faddp st1, st0");
     *__esp =  *134657160 / st0;
    return caml_copy_double();
}

caml_sys_getenv(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080663FD
    intOrPtr _t2;                          // _t2

    __esi = __esi;
    __edi = __edi;
    __ebx = __ebx;
    _t2 = _a4;
     *__esp = _t2;
    getenv();
    if(_t2 == 0) {
        _t2 = caml_raise_not_found();
    }
    return caml_copy_string(__ebx, __edi, __esi, _t2);
}

caml_sys_file_exists(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08066421
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    signed int _t6;                        // _t6

    _v116 =  &_v108;
    _t6 = _a4;
    _v120 = _t6;
     *__esp = 3;
    __xstat64();
    asm("sbb eax, eax");
    return (_t6 & 2) + 1;
}

caml_sys_close(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806644E
     *__esp = _a4 >> 1;
    close();
    return 1;
}

caml_sys_exit(
    intOrPtr __edi,                        // r4
    _unknown_ __fp0,                       // r28
    signed int _a4                         // _cfa_4
)
{// addr = 0x08066468
    signed int _v0;                        // _cfa_0
    signed int _v4;                        // _cfa_fffffffc
    char _v24;                             // _cfa_ffffffe8
    intOrPtr _v56;                         // _cfa_ffffffc8
    signed int _v68;                       // _cfa_ffffffbc
    char* _v76;                            // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    char _v88;                             // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    char _v100;                            // _cfa_ffffff9c
    char* _v112;                           // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    char _v124;                            // _cfa_ffffff84
    signed int _v144;                      // _cfa_ffffff70
    signed int _v148;                      // _cfa_ffffff6c
    char* _v184;                           // _cfa_ffffff48
    intOrPtr _v188;                        // _cfa_ffffff44
    intOrPtr _v192;                        // _cfa_ffffff40
    char _v196;                            // _cfa_ffffff3c
    char _v200;                            // _cfa_ffffff38
    char* _v220;                           // _cfa_ffffff24
    intOrPtr _v224;                        // _cfa_ffffff20
    intOrPtr _v228;                        // _cfa_ffffff1c
    char _v232;                            // _cfa_ffffff18
    char _v244;                            // _cfa_ffffff0c
    _unknown_ _v256;                       // _cfa_ffffff00 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t63;                       // _t63
    signed int _t67;                       // _t67
    signed int _t89;                       // _t89
    signed int _t98;                       // _t98
    _unknown_ _t99;                        // _t99
    signed int _t100;                      // _t100
    char* _t101;                           // _t101
    _unknown_ _t102;                       // _t102
    signed int* _t103;                     // _t103

    __fp0 = __fp0;
     *__esp = _a4 >> 1;
    exit();
    _push(_t102);
    _t103 = __esp;
    _push(__edi);
    _push(_t99);
    _push(_t89);
    __esp = __esp - 108;
    _v88 = caml_local_roots;
    _v80 = 1;
    _v84 = 1;
    _v76 =  &_v24;
    _v92 = 0;
    _v124 =  &_v88;
    caml_local_roots =  &_v124;
    _v116 = 1;
    _v120 = 1;
    _v112 =  &_v92;
    __errno_location();
    _t63 = _v92;
     *__esp = _t63;
    strerror();
    _t100 = _t63;
    _t94 = _v24;
    if(_v24 != 1) {
        asm("repne scasb");
        _t98 =  !-1 - 1;
        _t89 = caml_string_length(_t94);
        _t67 = caml_alloc_string(_t89, _t98, _t100, __fp0, _t65 + _t98 + 2);
        _v68 = _t67;
        _v144 = _t89;
        _v148 = _v0;
         *__esp = _t67;
        memmove();
         *((short*)(_t89 + _v68)) = 8250;
        _v144 = _t98;
        _v148 = _t100;
         *__esp = _t89 + _v68 + 2;
        memmove();
    } else {
        _v68 = caml_copy_string(_t89, __edi, _t100, _t63);
    }
     *__esp = _v68;
    caml_raise_sys_error();
    _push(_t103);
    _push(_t100);
    _push(_t89);
    __esp = __esp - 96;
    _t101 = caml_local_roots;
    _v196 = _t101;
    _v188 = 1;
    _v192 = 1;
    _v184 =  &_v148;
    _v200 = 0;
    _v232 =  &_v196;
    caml_local_roots =  &_v232;
    _v224 = 1;
    _v228 = 1;
    _v220 =  &_v200;
    caml_ext_table_init( &_v244, 50);
    if(caml_read_directory(_v148,  &_v244) == -1) {
        caml_ext_table_free( &_v244, 1);
         *__esp = _v4;
        L1();
    }
    caml_ext_table_add( &_v100, 0);
    _v56 = caml_copy_string_array(_v92);
    caml_ext_table_free( &_v100, 1);
    caml_local_roots = _t101;
    __esp =  &(__esp[0x18]);
    _pop(__ebx);
    _pop(__esi);
    return _v56;
}

caml_sys_error(
    signed int __edi,                      // r4
    char _a4                               // _cfa_4
)
{// addr = 0x0806647B
    intOrPtr _v0;                          // _cfa_0
    char* _v48;                            // _cfa_ffffffd0
    signed int* _v52;                      // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    intOrPtr* _v84;                        // _cfa_ffffffac
    signed int* _v88;                      // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    char _v96;                             // _cfa_ffffffa0
    signed int _v116;                      // _cfa_ffffff8c
    char _v120;                            // _cfa_ffffff88
    char* _v156;                           // _cfa_ffffff64
    intOrPtr _v160;                        // _cfa_ffffff60
    intOrPtr _v164;                        // _cfa_ffffff5c
    char _v168;                            // _cfa_ffffff58
    char _v172;                            // _cfa_ffffff54
    char* _v192;                           // _cfa_ffffff40
    intOrPtr _v196;                        // _cfa_ffffff3c
    intOrPtr _v200;                        // _cfa_ffffff38
    char _v204;                            // _cfa_ffffff34
    char _v216;                            // _cfa_ffffff28
    _unknown_ _v228;                       // _cfa_ffffff1c (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    char _t60;                             // _t60
    intOrPtr _t64;                         // _t64
    signed int _t87;                       // _t87
    _unknown_ _t96;                        // _t96
    char _t97;                             // _t97
    char* _t98;                            // _t98
    _unknown_ _t99;                        // _t99

    _t94 = __edi;
    _push(__edi);
    _push(_t96);
    _push(_t87);
    __esp = __esp - 108;
    _v60 = caml_local_roots;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _v64 = 0;
    _v96 =  &_v60;
    caml_local_roots =  &_v96;
    _v88 = 1;
    _v92 = 1;
    _v84 =  &_v64;
    __errno_location();
    _t60 = _v64;
     *__esp = _t60;
    strerror();
    _t97 = _t60;
    _t92 = _a4;
    if(_a4 != 1) {
        asm("repne scasb");
        _t94 =  !-1 - 1;
        _t87 = caml_string_length(_t92);
        _t64 = caml_alloc_string(_t87, _t94, _t97, __fp0, _t62 + _t94 + 2);
        _v64 = _t64;
        _v116 = _t87;
        _v120 = _a4;
         *__esp = _t64;
        memmove();
         *((short*)(_t87 + _v64)) = 8250;
        _v116 = _t94;
        _v120 = _t97;
         *__esp = _t87 + _v64 + 2;
        memmove();
    } else {
        _v64 = caml_copy_string(_t87, __edi, _t97, _t60);
    }
     *__esp = _v64;
    caml_raise_sys_error();
    _push(_t99);
    _push(_t97);
    _push(_t87);
    __esp = __esp - 96;
    _t98 = caml_local_roots;
    _v168 = _t98;
    _v160 = 1;
    _v164 = 1;
    _v156 =  &_v120;
    _v172 = 0;
    _v204 =  &_v168;
    caml_local_roots =  &_v204;
    _v196 = 1;
    _v200 = 1;
    _v192 =  &_v172;
    caml_ext_table_init( &_v216, 50);
    if(caml_read_directory(_v120,  &_v216) == -1) {
        caml_ext_table_free( &_v216, 1);
         *__esp = _v0;
        caml_sys_error(_t94);
    }
    caml_ext_table_add( &_v96, 0);
    _v52 = caml_copy_string_array(_v88);
    caml_ext_table_free( &_v96, 1);
    caml_local_roots = _t98;
    __esp = __esp + 96;
    _pop(__ebx);
    _pop(__esi);
    return _v52;
}

caml_sys_read_directory(
    char _a4                               // _cfa_4
)
{// addr = 0x0806655A
    char* _v32;                            // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    char* _v68;                            // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    char _v80;                             // _cfa_ffffffb0
    signed int* _v84;                      // _cfa_ffffffac
    char _v92;                             // _cfa_ffffffa4
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    _unknown_ __ebx;                       // r1
    char* __esi;                           // r5

    __esi = caml_local_roots;
    _v44 = __esi;
    _v36 = 1;
    _v40 = 1;
    _v32 =  &_a4;
    _v48 = 0;
    _v80 =  &_v44;
    caml_local_roots =  &_v80;
    _v72 = 1;
    _v76 = 1;
    _v68 =  &_v48;
    caml_ext_table_init( &_v92, 50);
    if(caml_read_directory(_a4,  &_v92) == -1) {
        caml_ext_table_free( &_v92, 1);
         *__esp = _a4;
        caml_sys_error(__edi);
    }
    caml_ext_table_add( &_v92, 0);
    _v48 = caml_copy_string_array(_v84);
    caml_ext_table_free( &_v92, 1);
    caml_local_roots = __esi;
    return _v48;
}

caml_sys_system_command(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    char _a4                               // _cfa_4
)
{// addr = 0x0806662B
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    signed int _t29;                       // _t29
    signed int _t32;                       // _t32
    intOrPtr _t37;                         // _t37
    _unknown_ _t40;                        // _t40
    intOrPtr _t43;                         // _t43
    signed int _t44;                       // _t44

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t40 = caml_local_roots;
    _v60 = _t40;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _t43 = caml_string_length(_a4) + 1;
    _t37 = caml_stat_alloc(_t26, _t43);
    _v68 = _t43;
    _v72 = _a4;
     *__esp = _t37;
    memmove();
    _t29 = caml_enter_blocking_section();
     *__esp = _t37;
    system();
    _t44 = _t29;
    caml_leave_blocking_section();
    caml_stat_free(_t37);
    if(_t44 != -1) {
        _t32 = 255;
        if((_t44 & 127) == 0) {
            _t32 = _t44 & 255;
        }
    } else {
         *__esp = _a4;
        caml_sys_error(_t40);
        _t32 = 255;
    }
    caml_local_roots = _t40;
    return _t32 + _t32 + 1;
}

caml_sys_getcwd(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi                         // r5
)
{// addr = 0x080666E6
    char _v4108;                           // _cfa_ffffeff4
    intOrPtr _v4120;                       // _cfa_ffffefe8

    __esi = __esi;
    __ebx = __ebx;
    _v4120 = 4096;
     *__esp =  &_v4108;
    getcwd();
    if( &_v4108 == 0) {
         *__esp = 1;
        caml_sys_error(__edi);
    }
    return caml_copy_string(__ebx, __edi, __esi,  &_v4108);
}

caml_sys_chdir(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x08066725
    intOrPtr __ebx;                        // r1

    __ebx = _a4;
     *__esp = __ebx;
    chdir();
    if(__eax != 0) {
         *__esp = __ebx;
        caml_sys_error(__edi);
    }
    return 1;
}

caml_sys_rename(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806674E
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t5;                          // _t5

    _v24 = _a8;
    _t5 = _a4;
     *__esp = _t5;
    rename();
    if(_t5 != 0) {
         *__esp = 1;
        caml_sys_error(__edi);
    }
    return 1;
}

caml_sys_remove(
    _unknown_ __eax,                       // r0
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806677D
    intOrPtr __ebx;                        // r1

    __ebx = _a4;
     *__esp = __ebx;
    unlink();
    if(__eax != 0) {
         *__esp = __ebx;
        caml_sys_error(__edi);
    }
    return 1;
}

caml_sys_is_directory(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080667A6
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr __ebx;                        // r1

    __ebx = _a4;
    _v116 =  &_v108;
    _v120 = __ebx;
     *__esp = 3;
    __xstat64();
    if( &_v108 == -1) {
         *__esp = __ebx;
        caml_sys_error(__edi);
    }
    return ((_v92 & 61440) == 16384 & 255) + ((_v92 & 61440) == 16384 & 255) + 1;
}

caml_sys_open(
    signed int _a4,                        // _cfa_4
    _unknown_ _a8,                         // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080667F1
    char* _v40;                            // _cfa_ffffffd8
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v84;                       // _cfa_ffffffac
    signed int _v88;                       // _cfa_ffffffa8 (outparam)
    signed int __ebx;                      // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t36;                       // _t36
    signed int _t40;                       // _t40
    signed int _t49;                       // _t49

    __edi = caml_local_roots;
    _v60 = __edi;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 3;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v40 =  &_a12;
    __ebx = caml_stat_alloc(caml_string_length(_a4) + 1, caml_string_length(_a4) + 1);
    _v88 = _a4;
     *__esp = __ebx;
    strcpy();
    _t36 = caml_convert_flag_list(_a8,  &sys_open_flags);
    _v64 = _a12 >> 1;
    caml_enter_blocking_section();
    _t40 = _v64;
    _v84 = _t40;
    _v88 = _t36;
     *__esp = __ebx;
    open64();
    _t49 = _t40;
    if(_t40 == -1) {
        caml_leave_blocking_section();
        caml_stat_free(__ebx);
         *__esp = _a4;
        caml_sys_error(__edi);
    } else {
        _v84 = 1;
        _v88 = 2;
         *__esp = _t40;
        fcntl();
        caml_leave_blocking_section();
        caml_stat_free(__ebx);
    }
    caml_local_roots = __edi;
    return _t49 + _t49 + 1;
}

caml_sys_io_error(
    intOrPtr* __eax,                       // r0
    signed int __edi,                      // r4
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x080668E2
    __edi = __edi;
    __errno_location();
    if( *__eax == 11) {
        caml_raise_sys_blocked_io();
    }
     *__esp = _a4;
    return caml_sys_error(__edi);
}

caml_set_parser_trace(
    signed int __eax,                      // r0
    signed int _a4                         // _cfa_4
)
{// addr = 0x08066904
    asm("sbb eax, eax");
    caml_parser_trace = _a4 >> 1;
    return (__eax & -2) + 3;
}

token_name(
    char* __eax,                           // r0
    _unknown_ __edx                        // r3
)
{// addr = 0x08066923
    char* __ebx;                           // r1

    __edx = __edx;
    __ebx = __eax;
    if(__edx > 0) {
        if( *__eax != 0) {
            while(1) {
                asm("repne scasb");
                __ebx = __ebx +  !-1;
                __edx = __edx - 1;
                if(__edx <= 0) {
                    break;
                }
                if( *__ebx == 0) {
                    goto L6;
                } else {
                    continue;
                }
                goto L7;
            }
        } else {
L6:
            __ebx = "<unknown token>";
        }
    }
L7:
    return __ebx;
}

signed int caml_parse_engine(
    intOrPtr _a4,                          // _cfa_4
    signed int* _a8,                       // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x08066964
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int _v48;                       // _cfa_ffffffd0
    signed int _v64;                       // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    signed int _v72;                       // _cfa_ffffffb8 (outparam)
    signed int* __ebx;                     // r1
    signed int __edi;                      // r4
    intOrPtr __esi;                        // r5
    signed int _t280;                      // _t280
    signed int _t283;                      // _t283
    _unknown_ _t285;                       // _t285
    short _t287;                           // _t287
    short _t289;                           // _t289
    short _t304;                           // _t304
    short _t306;                           // _t306
    short _t312;                           // _t312
    _unknown_ _t371;                       // _t371
    _unknown_ _t373;                       // _t373
    signed int _t375;                      // _t375
    signed int _t377;                      // _t377
    signed int _t379;                      // _t379
    signed int _t386;                      // _t386
    short _t388;                           // _t388
    _unknown_ _t394;                       // _t394
    signed int _t401;                      // _t401
    _unknown_ _t403;                       // _t403
    signed int _t405;                      // _t405
    _unknown_ _t410;                       // _t410
    signed int _t412;                      // _t412
    signed int _t414;                      // _t414

    __esi = _a4;
    __ebx = _a8;
    _t280 = _a12 >> 1;
    if(_t280 > 5) {
L70:
        return 3;
    }
    switch( *((intOrPtr*)(_t280 * 4 +  &M0806C304))) {
        case 0:
            _t412 = __ebx[0xd] >> 1;
            _v40 = 0;
            _v36 = 0;
            goto L3;
        case 1:
            __edi = __ebx[0xd];
            __edi = __ebx[0xd] >> 1;
            __ebx[0xe] = __ebx[0xe] >> 1;
            _v36 = __ebx[0xe] >> 1;
            __ebx[0xf] = __ebx[0xf] >> 1;
            _v40 = __ebx[0xf] >> 1;
            __eax = _a16;
            __eax = _a16 & 1;
            _v44 = __eax;
            if(__eax != 0) {
                _a16 = _a16 >> 1;
                 *(__esi + 4) =  *( *(__esi + 4) + (_a16 >> 1) * 4);
                __ebx[6] =  *( *(__esi + 4) + (_a16 >> 1) * 4);
                _v72 = 1;
                __eax =  &(__ebx[7]);
                 *__esp =  &(__ebx[7]);
                __eax = caml_modify(__ebx, __edi, __esi);
            } else {
                __ecx = _a16;
                __edx =  *(__ecx - 4) & 255;
                 *(__esi + 8) =  *( *(__esi + 8) + ( *(__ecx - 4) & 255) * 4);
                __ebx[6] =  *( *(__esi + 8) + ( *(__ecx - 4) & 255) * 4);
                __eax =  *__ecx;
                _v72 =  *__ecx;
                __eax =  &(__ebx[7]);
                 *__esp =  &(__ebx[7]);
                __eax = caml_modify(__ebx, __edi, __esi);
            }
            if(caml_parser_trace == 0) {
L20:
                _t375 = _v36 + _v36;
                _v44 = _t375;
                _t304 =  *((short*)( *((intOrPtr*)(__esi + 28)) + _t375));
                _t377 = __ebx[6] >> 1;
                _t401 = _t304 + _t377;
                _v32 = _t401;
                if(_t304 == 0 || _t401 < 0 || _t401 >  *(__esi + 40) >> 1 || _t377 !=  *((short*)( *((intOrPtr*)(__esi + 48)) + _t401 * 2))) {
                    _t306 =  *((short*)( *((intOrPtr*)(__esi + 32)) + _v44));
                    _t403 = _t306 + _t377;
                    if(_t306 == 0 || _t403 < 0 || _t403 >  *(__esi + 40) >> 1) {
L29:
                        if(_v40 > 0) {
                            goto L32;
                        }
                        __ebx[0xd] = _t412 + _t412 + 1;
                        __ebx[0xe] = _v36 + _v36 + 1;
                        __ebx[0xf] = _v40 + _v40 + 1;
                        return 11;
                    } else {
                        _t410 = _t403 + _t403;
                        if(_t377 !=  *((short*)( *((intOrPtr*)(__esi + 48)) + _t410))) {
                            goto L29;
                        }
                        _v32 =  *((short*)( *((intOrPtr*)(__esi + 44)) + _t410));
                        goto L56;
                    }
                } else {
                    __ebx[6] = -1;
                    _v40 = _v40 - (_v40 > 0 & 255);
                    goto L50;
                }
            }
            if(_v44 == 0) {
                __ecx = _a16;
                __edx =  *(_a16 - 4) & 255;
                __eax =  *(__esi + 60);
                _v64 = token_name( *(__esi + 60),  *(_a16 - 4) & 255);
                __eax = _v36;
                _v68 = _v36;
                _v72 = "State %d: read token %s(";
                __eax = __imp__stderr;
                 *__esp = __imp__stderr;
                fprintf();
                __edx = _a16;
                __eax =  *_a16;
                if(( *_a16 & 1) == 0) {
                    if(__dl != 252) {
                        if(__dl != 253) {
                            __eax = __imp__stderr;
                            _v72 = __imp__stderr;
                             *__esp = 95;
                            fputc();
                        } else {
                            _v68 =  *__eax;
                            _v72 = "%g";
                            __eax = __imp__stderr;
                             *__esp = __imp__stderr;
                            fprintf();
                        }
                    } else {
                        __edx = __imp__stderr;
                        _v72 = __imp__stderr;
                         *__esp = __eax;
                        fputs();
                    }
                } else {
                    _v68 = __eax;
                    _v72 = "%ld";
                    __eax = __imp__stderr;
                     *__esp = __imp__stderr;
                    fprintf();
                }
                __eax = __imp__stderr;
                _v64 = __imp__stderr;
                _v68 = 2;
                _v72 = 1;
                 *__esp = ")\n";
                fwrite();
            } else {
                __edx = _a16;
                __edx = _a16 >> 1;
                __eax =  *(__esi + 56);
                _v64 = token_name( *(__esi + 56), _a16 >> 1);
                __eax = _v36;
                _v68 = _v36;
                _v72 = "State %d: read token %s\n";
                __eax = __imp__stderr;
                 *__esp = __imp__stderr;
                fprintf();
            }
            goto L20;
        case 2:
            __edi = __ebx[0xd];
            __edi = __ebx[0xd] >> 1;
            __ebx[0xe] = __ebx[0xe] >> 1;
            _v36 = __ebx[0xe] >> 1;
            __ebx[0xf] = __ebx[0xf] >> 1;
            _v40 = __ebx[0xf] >> 1;
            goto L55;
        case 3:
            __ebx[0xd] = __ebx[0xd] >> 1;
            __ebx[0xe] = __ebx[0xe] >> 1;
            __ebx[0xf] = __ebx[0xf] >> 1;
            _v40 = __ebx[0xf] >> 1;
            goto L67;
        case 4:
            __edi = __ebx[0xd];
            __edi = __ebx[0xd] >> 1;
            __ebx[0xe] = __ebx[0xe] >> 1;
            _v36 = __ebx[0xe] >> 1;
            __ebx[0xf] = __ebx[0xf] >> 1;
            _v40 = __ebx[0xf] >> 1;
            __ecx = __edi * 4;
            _v44 = __edi * 4;
            __edx =  *__ebx;
            __ecx = _v36;
            __eax = _v36 + _v36 + 1;
            __ecx = _v44;
             *(__ecx +  *__ebx) = _v36 + _v36 + 1;
            __eax = _a16;
            _v72 = _a16;
             *__esp = __ecx + __ebx[1];
            caml_modify(__ebx, __edi, __esi) = __ebx[0xa];
            __eax = __ebx[0xa] >> 1;
            _v32 = __eax;
            _v48 = __eax;
            __eax = __ebx[3];
            __ecx = _v48;
            __edx =  *(__ecx + __eax);
            _v72 =  *(__ecx + __eax);
             *__esp = __eax;
            __eax = caml_modify(__ebx, __edi, __esi);
            if(__edi > _v32) {
                __eax = __ebx[3];
                __edx = _v48;
                __eax =  *(_v48 + __ebx[3]);
                _v72 =  *(_v48 + __ebx[3]);
                _v44 = _v44 + __ebx[2];
                 *__esp = _v44 + __ebx[2];
                __eax = caml_modify(__ebx, __edi, __esi);
            }
            goto L3;
        case 5:
            __edi = __ebx[0xd];
            __edi = __ebx[0xd] >> 1;
            __ebx[0xe] = __ebx[0xe] >> 1;
            _v36 = __ebx[0xe] >> 1;
            __ebx[0xf] = __ebx[0xf] >> 1;
            _v40 = __ebx[0xf] >> 1;
L32:
            if(_v40 > 2) {
                if(__ebx[6] >> 1 == 0) {
                    goto L70;
                }
                if(caml_parser_trace != 0) {
                    _v64 = __imp__stderr;
                    _v68 = 27;
                    _v72 = 1;
                     *__esp = "Discarding last token read\n";
                    fwrite();
                }
                __ebx[6] = -1;
L3:
                _t386 = _v36;
                _t283 =  *((short*)( *((intOrPtr*)(__esi + 20)) + _t386 * 2));
                _v32 = _t283;
                if(_t283 != 0) {
L56:
                    if(caml_parser_trace != 0) {
                        _v64 = _v32;
                        _v68 = _v36;
                        _v72 = "State %d: reduce by rule %d\n";
                         *__esp = __imp__stderr;
                        fprintf();
                    }
                    _t285 = _v32 + _v32;
                    _t388 =  *((short*)( *((intOrPtr*)(__esi + 16)) + _t285));
                    __ebx[0xa] = _t412 + _t412 + 1;
                    __ebx[0xc] = _t285 + 1;
                    __ebx[0xb] = _t388 + _t388 + 1;
                    _t414 = _t412 + 1 - _t388;
                    _v36 =  *( *__ebx + _t414 * 4 - 4) >> 1;
                    _t394 =  *((short*)( *((intOrPtr*)(__esi + 12)) + _t285)) +  *((short*)( *((intOrPtr*)(__esi + 12)) + _t285));
                    _t287 =  *((short*)( *((intOrPtr*)(__esi + 36)) + _t394));
                    _t371 = _v36 + _t287;
                    if(_t287 == 0 || _t371 < 0 || _t371 >  *(__esi + 40) >> 1) {
L63:
                        _t289 =  *((short*)( *((intOrPtr*)(__esi + 24)) + _t394));
                        goto L64;
                    } else {
                        _t373 = _t371 + _t371;
                        if( *((short*)( *((intOrPtr*)(__esi + 48)) + _t373)) != _v36) {
                            goto L63;
                        }
                        _t289 =  *((short*)( *((intOrPtr*)(__esi + 44)) + _t373));
L64:
                        if(_t414 < __ebx[4] >> 1) {
L67:
                            __ebx[0xd] = _t414 + _t414 + 1;
                            __ebx[0xe] = _t289 + _t289 + 1;
                            __ebx[0xf] = _v40 + _v40 + 1;
                            return 9;
                        }
                        __ebx[0xd] = _t414 + _t414 + 1;
                        __ebx[0xe] = _t289 + _t289 + 1;
                        __ebx[0xf] = _v40 + _v40 + 1;
                        return 7;
                    }
                } else {
                    if(__ebx[6] >= 0) {
                        goto L20;
                    } else {
                        __ebx[0xd] = _t412 + _t412 + 1;
                        __ebx[0xe] = _t386 + _t386 + 1;
                        __ebx[0xf] = _v40 + _v40 + 1;
                        return 1;
                    }
                }
            } else {
                goto L33;
            }
            while(1) {
L33:
                _t405 =  *( *__ebx + _t412 * 4) >> 1;
                _t312 =  *((short*)( *((intOrPtr*)(__esi + 28)) + _t405 * 2));
                _t379 = _t312 + 256;
                if(_t312 != 0 && _t379 >= 0 && _t379 <=  *(__esi + 40) >> 1 &&  *((short*)( *((intOrPtr*)(__esi + 48)) + _t379 * 2)) == 256) {
                    break;
                }
                if(caml_parser_trace != 0) {
                    _v68 = _t405;
                    _v72 = "Discarding state %d\n";
                     *__esp = __imp__stderr;
                    fprintf();
                }
                if(_t412 > __ebx[5] >> 1) {
                    _t412 = _t412 - 1;
                    continue;
                } else {
                    if(caml_parser_trace == 0) {
                        goto L70;
                    }
                    _v64 = __imp__stderr;
                    _v68 = 26;
                    _v72 = 1;
                     *__esp = "No more states to discard\n";
                    fwrite();
                    return 3;
                }
            }
            _v32 = _t379;
            _v40 = 3;
            if(caml_parser_trace == 0) {
L52:
                _v36 =  *((short*)( *((intOrPtr*)(__esi + 44)) + _v32 * 2));
                _t412 = _t412 + 1;
                if(_t412 < __ebx[4] >> 1) {
L55:
                    _v32 = _t412 * 4;
                     *((intOrPtr*)(_v32 +  *__ebx)) = _v36 + _v36 + 1;
                    caml_modify(__ebx, _t412, __esi, _v32 + __ebx[1], __ebx[7]);
                    caml_modify(__ebx, _t412, __esi, _v32 + __ebx[2], __ebx[8]);
                    caml_modify(__ebx, _t412, __esi, _v32 + __ebx[3], __ebx[9]);
                    goto L3;
                }
                __ebx[0xd] = _t412 + _t412 + 1;
                __ebx[0xe] = _v36 + _v36 + 1;
                __ebx[0xf] = _v40 + _v40 + 1;
                return 5;
            }
            _v68 = _t405;
            _v72 = "Recovering in state %d\n";
             *__esp = __imp__stderr;
            fprintf();
            _v40 = 3;
L50:
            if(caml_parser_trace != 0) {
                _v64 =  *((short*)( *((intOrPtr*)(__esi + 44)) + _v32 * 2));
                _v68 = _v36;
                _v72 = "State %d: shift to state %d\n";
                 *__esp = __imp__stderr;
                fprintf();
            }
            goto L52;
    }
}

norm_pfree(
    _unknown_ __eax                        // r0
)
{// addr = 0x08066FD0
    _t3 = __eax == 0 ? 1 : __eax;
    return __eax == 0 ? 1 : __eax;
}

norm_pmax(
    _unknown_ __eax                        // r0
)
{// addr = 0x08066FDF
    __eax = __eax;
    return __eax;
}

norm_heapincr(
    _unknown_ __eax                        // r0
)
{// addr = 0x08066FE4
    signed int _t4;                        // _t4

    _t4 = __eax + 1023 & -1024;
    _t5 = _t4 - 2047 <= 0 ? 2048 : _t4;
    return _t4 - 2047 <= 0 ? 2048 : _t4;
}

norm_minsize(
    _unknown_ __eax                        // r0
)
{// addr = 0x08067000
    _unknown_ _t4;                         // _t4

    _t4 = __eax - 4095 <= 0 ? 4096 : __eax;
    _t5 = _t4 - 268435456 > 0 ? 268435456 : _t4;
    return _t4 - 268435456 > 0 ? 268435456 : _t4;
}

caml_init_gc(
    long long __fp0,                       // r28
    signed int _a4,                        // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16,                         // _cfa_10
    intOrPtr _a20                          // _cfa_14
)
{// addr = 0x0806701F
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1
    signed int __esi;                      // r5

    __fp0 = __fp0;
    __esi = _a4;
    _t51 = norm_heapincr(_a8) * 4;
     *__esp = norm_heapincr(_a8) * 4 + _a4 * 4;
    if(caml_page_table_initialize() != 0) {
        caml_fatal_error("OCaml runtime error: cannot initialize page table\n");
    }
    caml_set_minor_heap_size(__fp0, norm_minsize(__esi) << 2);
    caml_major_heap_increment = norm_heapincr(_a12) << 2;
    caml_percent_free = norm_pfree(_a16);
    caml_percent_max = norm_pmax(_a20);
    caml_init_major_heap(__fp0, _t51);
    caml_gc_message(32, "Initial minor heap size: %luk bytes\n", caml_minor_heap_size >> 10);
    caml_gc_message(32, "Initial major heap size: %luk bytes\n", _t51 >> 10);
    caml_gc_message(32, "Initial space overhead: %lu%%\n", caml_percent_free);
    caml_gc_message(32, "Initial max overhead: %lu%%\n", caml_percent_max);
    caml_gc_message(32, "Initial heap increment: %luk bytes\n", caml_major_heap_increment >> 10);
    return caml_gc_message(32, "Initial allocation policy: %d\n", caml_allocation_policy);
}

caml_gc_compaction(
    _unknown_ __fp0                        // r28
)
{// addr = 0x08067151
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __fp0 = __fp0;
    caml_gc_message(16, "Heap compaction requested\n", 0);
    caml_empty_minor_heap(__fp0);
    caml_finish_major_cycle(__fp0);
    caml_final_do_calls();
    caml_empty_minor_heap(__fp0);
    caml_finish_major_cycle(__fp0);
    caml_compact_heap();
    caml_final_do_calls();
    return 1;
}

unsigned int test_and_compact(
    signed int __fp0                       // r28
)
{// addr = 0x080671A1
    intOrPtr _v24;                         // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    _unknown_ _v30;                        // _cfa_ffffffe2
    short _v32;                            // _cfa_ffffffe0
    signed long long _v36;                 // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    unsigned int _t17;                     // _t17
    unsigned int _t23;                     // _t23
    unsigned int _t28;                     // _t28

    _t17 = caml_fl_cur_size;
    _v28 = _t17;
    _v24 = 0;
    asm("fild qword [ebp-0x18]");
    _t28 = (caml_stat_heap_size >> 2) - _t17;
    _v28 = _t28;
    _v24 = 0;
    asm("fild qword [ebp-0x18]");
    asm("fdivp st1, st0");
    _v36 = __fp0 *  *134661468;
    asm("fucomi st0, st1");
    asm("fcmovnbe st0, st1");
    st1 = _v36;
    asm("fst dword [ebp-0x20]");
    asm("fnstcw word [ebp-0x1a]");
    _v32 = 12;
    asm("fldcw word [ebp-0x1c]");
    asm("fistp qword [ebp-0x18]");
    asm("fldcw word [ebp-0x1a]");
    caml_gc_message(512, "Estimated overhead (lower bound) = %lu%%\n", _v28);
    _t23 = caml_percent_max;
    _v28 = _t23;
    _v24 = 0;
    asm("fild qword [ebp-0x18]");
    asm("fucomip st0, st1");
    st0 = _v36;
    if(_t28 < 0 || caml_stat_heap_chunks <= 1) {
        return _t23;
    } else {
        caml_gc_message(512, "Automatic compaction triggered.\n", 0);
        return caml_compact_heap();
    }
}

caml_gc_full_major(
    signed int __fp0                       // r28
)
{// addr = 0x0806726B
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __fp0 = __fp0;
    caml_gc_message(1, "Full major GC cycle requested\n", 0);
    caml_empty_minor_heap(__fp0);
    caml_finish_major_cycle(__fp0);
    caml_final_do_calls();
    caml_empty_minor_heap(__fp0);
    caml_finish_major_cycle(__fp0);
    test_and_compact(__fp0);
    caml_final_do_calls();
    return 1;
}

caml_gc_major(
    signed int __fp0                       // r28
)
{// addr = 0x080672BC
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    __fp0 = __fp0;
    caml_gc_message(1, "Major GC cycle requested\n", 0);
    caml_empty_minor_heap(__fp0);
    caml_finish_major_cycle(__fp0);
    test_and_compact(__fp0);
    caml_final_do_calls();
    return 1;
}

caml_gc_major_slice(
    signed int _a4                         // _cfa_4
)
{// addr = 0x080672FC
    caml_empty_minor_heap(__fp0);
    return caml_major_collection_slice(__fp0, _a4 >> 1) + _t7 + 1;
}

caml_gc_minor()
{// addr = 0x0806731A
    caml_minor_collection(__ebx, __esi, __fp0);
    return 1;
}

caml_gc_set(
    _unknown_ __fp0,                       // r28
    signed int* _a4                        // _cfa_4
)
{// addr = 0x0806732C
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    _unknown_ __ebx;                       // r1
    signed int* __esi;                     // r5
    unsigned int _t22;                     // _t22
    intOrPtr _t25;                         // _t25
    unsigned int _t29;                     // _t29
    unsigned int _t34;                     // _t34
    signed int* _t45;                      // _t45
    unsigned int _t49;                     // _t49

    __fp0 = __fp0;
    __esi = _a4;
    _t45 = __esi;
    caml_verb_gc = __esi[3] >> 1;
    _t22 = norm_pfree(__esi[2] >> 1);
    if(_t22 != caml_percent_free) {
        caml_percent_free = _t22;
        caml_gc_message(32, "New space overhead: %d%%\n", _t22);
    }
    _t25 = norm_pmax(_t45[4] >> 1);
    if(_t25 != caml_percent_max) {
        caml_percent_max = _t25;
        caml_gc_message(32, "New max overhead: %d%%\n", _t25);
    }
    _t29 = norm_heapincr(_t45[1] >> 1) << 2;
    if(_t29 != caml_major_heap_increment) {
        caml_major_heap_increment = _t29;
        caml_gc_message(32, "New heap increment size: %luk bytes\n", _t29 >> 10);
    }
    _t48 = _t45[6] >> 1 - 2 >= 0 ? 1 : _t45[6] >> 1;
    if((_t45[6] >> 1 - 2 >= 0 ? 1 : _t45[6] >> 1) != caml_allocation_policy) {
        caml_gc_message(32, "New allocation policy: %d\n", _t48);
        caml_set_allocation_policy(_t48);
    }
    _t34 = norm_minsize( *__esi >> 1 << 2);
    _t49 = _t34;
    if(_t34 != caml_minor_heap_size) {
        caml_gc_message(32, "New minor heap size: %luk bytes\n", _t34 >> 10);
        caml_set_minor_heap_size(__fp0, _t49);
    }
    return 1;
}

caml_gc_get(
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x08067453
    char _v16;                             // _cfa_fffffff0
    char* _v36;                            // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    char* __ebx;                           // r1

    __esi = __esi;
    __edi = __edi;
    __ebx = caml_local_roots;
    _v16 = 0;
    _v48 = __ebx;
    caml_local_roots =  &_v48;
    _v40 = 1;
    _v44 = 1;
    _v36 =  &_v16;
    _v16 = caml_alloc_tuple(7);
    caml_modify(__ebx, __edi, __esi, _t37, (caml_minor_heap_size >> 2) + (caml_minor_heap_size >> 2) + 1);
    caml_modify(__ebx, __edi, __esi, _v16 + 4, (caml_major_heap_increment >> 2) + (caml_major_heap_increment >> 2) + 1);
    caml_modify(__ebx, __edi, __esi, _v16 + 8, caml_percent_free + caml_percent_free + 1);
    caml_modify(__ebx, __edi, __esi, _v16 + 12, caml_verb_gc + caml_verb_gc + 1);
    caml_modify(__ebx, __edi, __esi, _v16 + 16, caml_percent_max + caml_percent_max + 1);
    caml_modify(__ebx, __edi, __esi, _v16 + 20, 1);
    caml_modify(__ebx, __edi, __esi, _v16 + 24, caml_allocation_policy + caml_allocation_policy + 1);
    caml_local_roots = __ebx;
    return _v16;
}

caml_gc_counters(
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    _unknown_ __fp0                        // r28
)
{// addr = 0x0806755D
    _unknown_ _v16;                        // _cfa_fffffff0
    char* _v36;                            // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    char _v48;                             // _cfa_ffffffd0
    intOrPtr _v64;                         // _cfa_ffffffc0
    unsigned int _v68;                     // _cfa_ffffffbc
    long long _v76;                        // _cfa_ffffffb4
    long long _v84;                        // _cfa_ffffffac
    long long _v92;                        // _cfa_ffffffa4
    _unknown_ _v104;                       // _cfa_ffffff98 (outparam)
    char* __ebx;                           // r1
    long long _t49;                        // _t49

    __esi = __esi;
    __edi = __edi;
    __ebx = caml_local_roots;
    _v16 = 0;
    _v48 = __ebx;
    caml_local_roots =  &_v48;
    _v40 = 1;
    _v44 = 1;
    _v36 =  &_v16;
    _v68 = caml_young_end - caml_young_ptr >> 2;
    _v64 = 0;
    asm("fild qword [ebp-0x40]");
    _v92 = __fp0 + caml_stat_minor_words;
    _t49 = caml_stat_promoted_words;
    _v84 = _t49;
    _v68 = caml_allocated_words;
    _v64 = 0;
    asm("fild qword [ebp-0x40]");
    _v76 = _t49 + caml_stat_major_words;
    _v16 = caml_alloc_tuple(3);
     *__esp = _v92;
    caml_modify(__ebx, __edi, __esi, _v16, caml_copy_double());
     *__esp = _v84;
    caml_modify(__ebx, __edi, __esi, _v16 + 4, caml_copy_double());
     *__esp = _v76;
    caml_modify(__ebx, __edi, __esi, _v16 + 8, caml_copy_double());
    caml_local_roots = __ebx;
    return _v16;
}

caml_gc_quick_stat(
    _unknown_ __fp0                        // r28
)
{// addr = 0x0806764C
    _unknown_ _v32;                        // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    intOrPtr _v80;                         // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    unsigned int _v96;                     // _cfa_ffffffa0
    unsigned int _v100;                    // _cfa_ffffff9c
    long long _v108;                       // _cfa_ffffff94
    long long _v116;                       // _cfa_ffffff8c
    long long _v124;                       // _cfa_ffffff84
    _unknown_ _v136;                       // _cfa_ffffff78 (outparam)
    char* __ebx;                           // r1
    intOrPtr __edi;                        // r4
    intOrPtr __esi;                        // r5
    long long _t154;                       // _t154

    __ebx = caml_local_roots;
    _v32 = 0;
    _v64 = __ebx;
    caml_local_roots =  &_v64;
    _v56 = 1;
    _v60 = 1;
    _v52 =  &_v32;
    _v84 = caml_young_end - caml_young_ptr >> 2;
    _v80 = 0;
    asm("fild qword [ebp-0x50]");
    _v124 = __fp0 + caml_stat_minor_words;
    _t154 = caml_stat_promoted_words;
    _v116 = _t154;
    _v84 = caml_allocated_words;
    _v80 = 0;
    asm("fild qword [ebp-0x50]");
    _v108 = _t154 + caml_stat_major_words;
    __esi = caml_stat_minor_collections;
    __edi = caml_stat_major_collections;
    _v100 = caml_stat_heap_size >> 2;
    _v96 = caml_stat_top_heap_size >> 2;
    _v92 = caml_stat_compactions;
    _v88 = caml_stat_heap_chunks;
    _v32 = caml_alloc_tuple(16);
     *__esp = _v124;
    caml_modify(__ebx, __edi, __esi, _v32, caml_copy_double());
     *__esp = _v116;
    caml_modify(__ebx, __edi, __esi, _v32 + 4, caml_copy_double());
     *__esp = _v108;
    caml_modify(__ebx, __edi, __esi, _v32 + 8, caml_copy_double());
    caml_modify(__ebx, __edi, __esi, _v32 + 12, __esi + __esi + 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 16, __edi + __edi + 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 20, _v100 + _v100 + 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 24, _v88 + _v88 + 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 28, 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 32, 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 36, 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 40, 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 44, 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 48, 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 52, _v92 + _v92 + 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 56, _v96 + _v96 + 1);
    caml_modify(__ebx, __edi, __esi, _v32 + 60, caml_stack_usage() + _t139 + 1);
    caml_local_roots = __ebx;
    return _v32;
}

caml_gc_stat(
    _unknown_ __fp0                        // r28
)
{// addr = 0x080678A1
    _unknown_ _v32;                        // _cfa_ffffffe0
    char* _v52;                            // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    char _v64;                             // _cfa_ffffffc0
    intOrPtr _v80;                         // _cfa_ffffffb0
    unsigned int _v84;                     // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    long long _v108;                       // _cfa_ffffff94
    intOrPtr _v112;                        // _cfa_ffffff90
    intOrPtr _v116;                        // _cfa_ffffff8c
    long long _v124;                       // _cfa_ffffff84
    long long _v132;                       // _cfa_ffffff7c
    char* _v136;                           // _cfa_ffffff78
    unsigned int _v140;                    // _cfa_ffffff74
    unsigned int _v144;                    // _cfa_ffffff70
    intOrPtr _v148;                        // _cfa_ffffff6c
    unsigned int _v152;                    // _cfa_ffffff68
    _unknown_ _v168;                       // _cfa_ffffff58 (outparam)
    intOrPtr __ebx;                        // r1
    _unknown_ __edi;                       // r4
    intOrPtr __esi;                        // r5
    unsigned int* _t149;                   // _t149
    signed int _t231;                      // _t231
    unsigned int _t242;                    // _t242
    unsigned int _t244;                    // _t244
    unsigned int _t254;                    // _t254
    unsigned int _t258;                    // _t258
    unsigned int _t265;                    // _t265
    long long _t272;                       // _t272

    _v136 = caml_local_roots;
    _t149 = caml_heap_start;
    if(_t149 != 0) {
        _v124 = caml_gc_phase;
        _v132 = caml_gc_sweep_hp;
        _v112 = 0;
        __esi = 0;
        _v96 = 0;
        _v92 = 0;
        _v88 = 0;
        __ebx = 0;
        _v116 = 0;
        do {
            _v116 = _v116 + 1;
            _v108 = _t149 - 16;
            _t258 = _t149 +  *((intOrPtr*)(_v108 + 8));
            if(_t258 > _t149) {
                _v144 = _t258;
                do {
                    _t254 =  *_t149;
                    _t231 = _t254 & 768;
                    if(_t231 == 256) {
L18:
                        _v88 = _v88 + 1;
                        __ebx = __ebx + (_t254 >> 10) + 1;
                        goto L20;
                    }
                    if(_t231 > 256) {
                        if(_t231 == 512) {
                            _v96 = _v96 + 1;
                            _t265 = _t254 >> 10;
                            _v92 = _t265 + _v92 + 1;
                            __esi = _t265 + 1 - __esi > 0 ? _t265 + 1 : __esi;
                            goto L20;
                        }
                        if(_t231 != 768) {
                            goto L20;
                        }
                        goto L18;
                    }
                    if(_t231 == 0) {
                        _t242 = _t254 >> 10;
                        _v140 = _t242;
                        if(_t242 != 0) {
                            if(_v124 != 1 || _v132 > _t149) {
                                _v88 = _v88 + 1;
                                __ebx = _v140 + __ebx + 1;
                            } else {
                                _v96 = _v96 + 1;
                                _t244 = _v140;
                                _v92 = _t244 + _v92 + 1;
                                __esi = _t244 + 1 - __esi > 0 ? _t244 + 1 : __esi;
                            }
                        } else {
                            _v112 = _v112 + 1;
                        }
                    }
L20:
                    _t149 = _t149 + 4 + (_t254 >> 10) * 4;
                } while(_v144 > _t149);
            }
            _t149 =  *(_v108 + 12);
        } while(_t149 != 0);
        goto L22;
    } else {
        _v112 = 0;
        __esi = 0;
        _v96 = 0;
        _v92 = 0;
        _v88 = 0;
        __ebx = 0;
        _v116 = 0;
L22:
        _v32 = 0;
        _v64 = _v136;
        caml_local_roots =  &_v64;
        _v56 = 1;
        _v60 = 1;
        _v52 =  &_v32;
        _v84 = caml_young_end - caml_young_ptr >> 2;
        _v80 = 0;
        asm("fild qword [ebp-0x50]");
        _v108 = __fp0 + caml_stat_minor_words;
        _t272 = caml_stat_promoted_words;
        _v124 = _t272;
        _v84 = caml_allocated_words;
        _v80 = 0;
        asm("fild qword [ebp-0x50]");
        _v132 = _t272 + caml_stat_major_words;
        _t260 = caml_stat_minor_collections;
        _v140 = caml_stat_major_collections;
        _v144 = caml_stat_heap_size >> 2;
        _v148 = caml_stat_compactions;
        _v152 = caml_stat_top_heap_size >> 2;
        _v32 = caml_alloc_tuple(16);
         *__esp = _v108;
        caml_modify(__ebx, caml_stat_minor_collections, __esi, _v32, caml_copy_double());
         *__esp = _v124;
        caml_modify(__ebx, caml_stat_minor_collections, __esi, _v32 + 4, caml_copy_double());
         *__esp = _v132;
        caml_modify(__ebx, _t260, __esi, _v32 + 8, caml_copy_double());
        caml_modify(__ebx, _t260, __esi, _v32 + 12, _t260 + _t260 + 1);
        caml_modify(__ebx, _t260, __esi, _v32 + 16, _v140 + _v140 + 1);
        caml_modify(__ebx, _t260, __esi, _v32 + 20, _v144 + _v144 + 1);
        _t261 = _v116;
        caml_modify(__ebx, _v116, __esi, _v32 + 24, _v116 + _v116 + 1);
        caml_modify(__ebx, _t261, __esi, _v32 + 28, __ebx + __ebx + 1);
        caml_modify(__ebx, _t261, __esi, _v32 + 32, _v88 + _v88 + 1);
        caml_modify(__ebx, _t261, __esi, _v32 + 36, _v92 + _v92 + 1);
        _t262 = _v96;
        caml_modify(__ebx, _v96, __esi, _v32 + 40, _v96 + _v96 + 1);
        caml_modify(__ebx, _t262, __esi, _v32 + 44, __esi + __esi + 1);
        caml_modify(__ebx, _t262, __esi, _v32 + 48, _v112 + _v112 + 1);
        caml_modify(__ebx, _t262, __esi, _v32 + 52, _v148 + _v148 + 1);
        _t263 = _v152;
        caml_modify(__ebx, _v152, __esi, _v32 + 56, _v152 + _v152 + 1);
        caml_modify(__ebx, _t263, __esi, _v32 + 60, caml_stack_usage() + _t222 + 1);
        caml_local_roots = _v136;
        return _v32;
    }
}

caml_MD5Init(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08067C98
    __eax = _a4;
     *__eax = 1732584193;
    __eax[1] = -271733879;
    __eax[2] = -1732584194;
    __eax[3] = 271733878;
    __eax[4] = 0;
    __eax[5] = 0;
    return __eax;
}

signed int* caml_MD5Transform(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr* _a8                          // _cfa_8
)
{// addr = 0x08067CC9
    intOrPtr _v20;                         // _cfa_ffffffec
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _v28;                         // _cfa_ffffffe4
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr _v64;                         // _cfa_ffffffc0
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    signed int* _v80;                      // _cfa_ffffffb0
    signed int* _v84;                      // _cfa_ffffffac
    signed int* _v88;                      // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    signed int _v100;                      // _cfa_ffffff9c
    signed int _v104;                      // _cfa_ffffff98
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    intOrPtr* _t334;                       // _t334
    signed int _t342;                      // _t342
    signed int _t349;                      // _t349
    signed int _t356;                      // _t356
    signed int _t378;                      // _t378
    signed int _t386;                      // _t386
    signed int _t395;                      // _t395
    signed int _t405;                      // _t405
    signed int _t411;                      // _t411
    signed int* _t418;                     // _t418
    signed int* _t420;                     // _t420
    intOrPtr _t421;                        // _t421
    signed int _t427;                      // _t427
    signed int _t434;                      // _t434
    signed int _t441;                      // _t441
    intOrPtr _t443;                        // _t443
    intOrPtr _t444;                        // _t444
    signed int _t450;                      // _t450
    signed int _t457;                      // _t457
    signed int _t463;                      // _t463
    signed int _t470;                      // _t470
    signed int _t476;                      // _t476
    signed int _t482;                      // _t482
    signed int _t488;                      // _t488
    signed int _t495;                      // _t495
    signed int _t501;                      // _t501
    signed int _t508;                      // _t508
    signed int _t516;                      // _t516
    signed int _t522;                      // _t522
    signed int* _t527;                     // _t527
    signed int _t528;                      // _t528
    signed int _t535;                      // _t535
    signed int _t542;                      // _t542
    signed int _t549;                      // _t549
    intOrPtr _t551;                        // _t551
    signed int _t558;                      // _t558
    signed int _t564;                      // _t564
    signed int _t568;                      // _t568
    signed int _t575;                      // _t575
    signed int _t582;                      // _t582
    signed int _t589;                      // _t589
    signed int _t596;                      // _t596
    signed int _t603;                      // _t603
    signed int _t610;                      // _t610
    signed int _t617;                      // _t617
    signed int _t623;                      // _t623
    signed int _t629;                      // _t629
    signed int _t637;                      // _t637
    signed int _t645;                      // _t645
    signed int _t652;                      // _t652
    signed int _t659;                      // _t659
    signed int _t665;                      // _t665
    signed int _t671;                      // _t671
    signed int* _t673;                     // _t673
    intOrPtr _t676;                        // _t676
    intOrPtr _t677;                        // _t677
    intOrPtr _t678;                        // _t678
    intOrPtr _t679;                        // _t679
    intOrPtr _t680;                        // _t680
    intOrPtr _t681;                        // _t681
    intOrPtr _t682;                        // _t682
    intOrPtr _t683;                        // _t683
    intOrPtr _t684;                        // _t684
    intOrPtr _t685;                        // _t685
    intOrPtr _t686;                        // _t686
    intOrPtr _t687;                        // _t687
    signed int _t693;                      // _t693
    signed int _t718;                      // _t718
    signed int _t724;                      // _t724
    signed int _t731;                      // _t731
    signed int _t737;                      // _t737
    signed int _t748;                      // _t748
    signed int _t757;                      // _t757
    signed int _t764;                      // _t764
    signed int _t771;                      // _t771
    signed int _t778;                      // _t778
    signed int _t784;                      // _t784
    signed int _t791;                      // _t791
    signed int _t798;                      // _t798
    signed int _t808;                      // _t808
    signed int _t815;                      // _t815
    signed int _t821;                      // _t821
    signed int _t827;                      // _t827
    signed int _t834;                      // _t834
    signed int _t841;                      // _t841

    _t334 = _a8;
    _v96 =  *_a4;
    _t527 = _a4 + 4;
    _v88 = _t527;
    _t757 =  *_t527;
    _t420 = _a4 + 8;
    _v84 = _t420;
    _t528 =  *_t420;
    _t673 = _a4 + 12;
    _v80 = _t673;
    _t568 =  *_t673;
    _t421 =  *_t334;
    _v76 = _t421;
    asm("ror ebx, 0x19");
    _t427 = ((_t568 ^ _t528) & _t757 ^ _t568) + _v96 + _t421 - 680876936 + _t757;
    _t676 = _t334[1];
    _v72 = _t676;
    _v20 = _t568 + _t676 - 389564586;
    asm("ror edx, 0x14");
    _t575 = ((_t528 ^ _t757) & _t427 ^ _t528) + _v20 + _t427;
    _t677 = _t334[2];
    _v68 = _t677;
    _v20 = _t528 + _t677 + 606105819;
    asm("ror ecx, 0xf");
    _t535 = ((_t427 ^ _t757) & _t575 ^ _t757) + _v20 + _t575;
    _t678 = _t334[3];
    _v64 = _t678;
    _v20 = _t757 + _t678 - 1044525330;
    asm("ror esi, 0xa");
    _t764 = ((_t575 ^ _t427) & _t535 ^ _t427) + _v20 + _t535;
    _t679 = _t334[4];
    _v60 = _t679;
    _v20 = _t427 + _t679 - 176418897;
    asm("ror ebx, 0x19");
    _t434 = ((_t535 ^ _t575) & _t764 ^ _t575) + _v20 + _t764;
    _t680 = _t334[5];
    _v56 = _t680;
    _v20 = _t575 + _t680 + 1200080426;
    asm("ror edx, 0x14");
    _t582 = ((_t764 ^ _t535) & _t434 ^ _t535) + _v20 + _t434;
    _t681 = _t334[6];
    _v52 = _t681;
    _v20 = _t535 + _t681 - 1473231341;
    asm("ror ecx, 0xf");
    _t542 = ((_t434 ^ _t764) & _t582 ^ _t764) + _v20 + _t582;
    _t682 = _t334[7];
    _v48 = _t682;
    _v20 = _t764 + _t682 - 45705983;
    asm("ror esi, 0xa");
    _t771 = ((_t582 ^ _t434) & _t542 ^ _t434) + _v20 + _t542;
    _t683 = _t334[8];
    _v44 = _t683;
    _v20 = _t434 + _t683 + 1770035416;
    asm("ror ebx, 0x19");
    _t441 = ((_t542 ^ _t582) & _t771 ^ _t582) + _v20 + _t771;
    _t684 = _t334[9];
    _v40 = _t684;
    _v20 = _t582 + _t684 - 1958414417;
    asm("ror edx, 0x14");
    _t589 = ((_t771 ^ _t542) & _t441 ^ _t542) + _v20 + _t441;
    _t685 = _t334[0xa];
    _v36 = _t685;
    _v20 = _t542 + _t685 - 42063;
    asm("ror ecx, 0xf");
    _t549 = ((_t441 ^ _t771) & _t589 ^ _t771) + _v20 + _t589;
    _t686 = _t334[0xb];
    _v32 = _t686;
    _v20 = _t771 + _t686 - 1990404162;
    asm("ror esi, 0xa");
    _t778 = ((_t589 ^ _t441) & _t549 ^ _t441) + _v20 + _t549;
    _t687 = _t334[0xc];
    _v28 = _t687;
    asm("ror edi, 0x19");
    _t693 = _t441 + _t687 + 1804603682 + ((_t549 ^ _t589) & _t778 ^ _t589) + _t778;
    _t443 = _t334[0xd];
    _v24 = _t443;
    _v20 = _t589 + _t443 - 40341101;
    asm("ror edx, 0x14");
    _t596 = ((_t778 ^ _t549) & _t693 ^ _t549) + _v20 + _t693;
    _t444 = _t334[0xe];
    _v20 = _t444;
    asm("ror ebx, 0xf");
    _t450 = _t549 + _t444 - 1502002290 + ((_t693 ^ _t778) & _t596 ^ _t778) + _t596;
    _t551 = _t334[0xf];
    asm("ror esi, 0xa");
    _t784 = _t778 + _t551 + 1236535329 + ((_t596 ^ _t693) & _t450 ^ _t693) + _t450;
    asm("ror eax, 0x1b");
    _t342 = _t693 + _v72 - 165796510 + ((_t784 ^ _t450) & _t596 ^ _t450) + _t784;
    _v92 = _t596 + _v52 - 1069501632;
    asm("ror edx, 0x17");
    _t603 = ((_t342 ^ _t784) & _t450 ^ _t784) + _v92 + _t342;
    _v92 = _t450 + _v32 + 643717713;
    asm("ror ebx, 0x12");
    _t457 = ((_t603 ^ _t342) & _t784 ^ _t342) + _v92 + _t603;
    _v92 = _t784 + _v76 - 373897302;
    asm("ror esi, 0xc");
    _t791 = ((_t457 ^ _t603) & _t342 ^ _t603) + _v92 + _t457;
    _v92 = _t342 + _v56 - 701558691;
    asm("ror eax, 0x1b");
    _t349 = ((_t791 ^ _t457) & _t603 ^ _t457) + _v92 + _t791;
    _v92 = _t603 + _v36 + 38016083;
    asm("ror edx, 0x17");
    _t610 = ((_t349 ^ _t791) & _t457 ^ _t791) + _v92 + _t349;
    asm("ror ebx, 0x12");
    _t463 = _t457 + _t551 - 660478335 + ((_t610 ^ _t349) & _t791 ^ _t349) + _t610;
    _v92 = _t791 + _v60 - 405537848;
    asm("ror esi, 0xc");
    _t798 = ((_t463 ^ _t610) & _t349 ^ _t610) + _v92 + _t463;
    _v92 = _t349 + _v40 + 568446438;
    asm("ror eax, 0x1b");
    _t356 = ((_t798 ^ _t463) & _t610 ^ _t463) + _v92 + _t798;
    _v92 = _t610 + _v20 - 1019803690;
    asm("ror edx, 0x17");
    _t617 = ((_t356 ^ _t798) & _t463 ^ _t798) + _v92 + _t356;
    _v92 = _t463 + _v64 - 187363961;
    asm("ror ebx, 0x12");
    _t470 = ((_t617 ^ _t356) & _t798 ^ _t356) + _v92 + _t617;
    asm("ror edi, 0xc");
    _v92 = _t798 + _v44 + 1163531501 + ((_t470 ^ _t617) & _t356 ^ _t617) + _t470;
    asm("ror eax, 0x1b");
    _v100 = _t356 + _v24 - 1444681467 + ((_v92 ^ _t470) & _t617 ^ _t470) + _v92;
    asm("ror edx, 0x17");
    _t623 = _t617 + _v68 - 51403784 + ((_v100 ^ _v92) & _t470 ^ _v92) + _v100;
    asm("ror ebx, 0x12");
    _t476 = _t470 + _v48 + 1735328473 + ((_v100 ^ _t623) & _v92 ^ _v100) + _t623;
    _v104 = _t476 ^ _t623;
    asm("ror edi, 0xc");
    _t718 = _v92 + _v28 - 1926607734 + (_v100 & _v104 ^ _t623) + _t476;
    _v92 = _v100 + _v56 - 378558;
    asm("ror esi, 0x1c");
    _t808 = (_v104 ^ _t718) + _v92 + _t718;
    _v92 = _t623 + _v44 - 2022574463;
    asm("ror edx, 0x15");
    _t629 = (_t718 ^ _t476 ^ _t808) + _v92 + _t808;
    _v92 = _t476 + _v32 + 1839030562;
    asm("ror ebx, 0x10");
    _t482 = (_t808 ^ _t718 ^ _t629) + _v92 + _t629;
    _v92 = _t718 + _v20 - 35309556;
    asm("ror edi, 0x9");
    _t724 = (_t629 ^ _t808 ^ _t482) + _v92 + _t482;
    asm("ror eax, 0x1c");
    _t378 = _t808 + _v72 - 1530992060 + (_t482 ^ _t629 ^ _t724) + _t724;
    asm("ror esi, 0x15");
    _t815 = _t629 + _v60 + 1272893353 + (_t724 ^ _t482 ^ _t378) + _t378;
    _v92 = _t482 + _v48 - 155497632;
    asm("ror ebx, 0x10");
    _t488 = (_t378 ^ _t724 ^ _t815) + _v92 + _t815;
    asm("ror edx, 0x9");
    _t637 = _t724 + _v36 - 1094730640 + (_t815 ^ _t378 ^ _t488) + _t488;
    asm("ror edi, 0x1c");
    _t731 = _t378 + _v24 + 681279174 + (_t488 ^ _t815 ^ _t637) + _t637;
    _v92 = _t815 + _v76 - 358537222;
    asm("ror esi, 0x15");
    _t821 = (_t637 ^ _t488 ^ _t731) + _v92 + _t731;
    asm("ror eax, 0x10");
    _t386 = _t488 + _v64 - 722521979 + (_t731 ^ _t637 ^ _t821) + _t821;
    asm("ror ebx, 0x9");
    _t495 = _t637 + _v52 + 76029189 + (_t821 ^ _t731 ^ _t386) + _t386;
    _v92 = _t731 + _v40 - 640364487;
    asm("ror edi, 0x1c");
    _t737 = (_t386 ^ _t821 ^ _t495) + _v92 + _t495;
    asm("ror edx, 0x15");
    _t645 = _t821 + _v28 - 421815835 + (_t495 ^ _t386 ^ _t737) + _t737;
    asm("ror esi, 0x10");
    _t827 = _t386 + _t551 + 530742520 + (_t737 ^ _t495 ^ _t645) + _t645;
    _v92 = _t495 + _v68 - 995338651;
    asm("ror ebx, 0x9");
    _t501 = (_t645 ^ _t737 ^ _t827) + _v92 + _t827;
    asm("ror eax, 0x1a");
    _t395 = _t737 + _v76 - 198630844 + (( !_t645 | _t501) ^ _t827) + _t501;
    _v48 = _t645 + _v48 + 1126891415;
    asm("ror edx, 0x16");
    _t652 = (( !_t827 | _t395) ^ _t501) + _v48 + _t395;
    _v20 = _t827 + _v20 - 1416354905;
    asm("ror esi, 0x11");
    _t834 = (( !_t501 | _t652) ^ _t395) + _v20 + _t652;
    _v20 = _t501 + _v56 - 57434055;
    asm("ror ebx, 0xb");
    _t508 = (( !_t395 | _t834) ^ _t652) + _v20 + _t834;
    asm("ror edi, 0x1a");
    _t748 = _t395 + _v28 + 1700485571 + (( !_t652 | _t508) ^ _t834) + _t508;
    _v20 = _t652 + _v64 - 1894986606;
    asm("ror edx, 0x16");
    _t659 = (( !_t834 | _t748) ^ _t508) + _v20 + _t748;
    _v20 = _t834 + _v36 - 1051523;
    asm("ror esi, 0x11");
    _t841 = (( !_t508 | _t659) ^ _t748) + _v20 + _t659;
    asm("ror eax, 0xb");
    _t405 = _t508 + _v72 - 2054922799 + (( !_t748 | _t841) ^ _t659) + _t841;
    asm("ror ebx, 0x1a");
    _t516 = _t748 + _v44 + 1873313359 + (( !_t659 | _t405) ^ _t841) + _t405;
    asm("ror edx, 0x16");
    _t665 = _t659 + _t551 - 30611744 + (( !_t841 | _t516) ^ _t405) + _t516;
    asm("ror ecx, 0x11");
    _t558 = _t841 + _v52 - 1560198380 + (( !_t405 | _t665) ^ _t516) + _t665;
    asm("ror eax, 0xb");
    _t411 = _t405 + _v24 + 1309151649 + (( !_t516 | _t558) ^ _t665) + _t558;
    asm("ror ebx, 0x1a");
    _t522 = _t516 + _v60 - 145523070 + (( !_t665 | _t411) ^ _t558) + _t411;
    asm("ror edx, 0x16");
    _t671 = _t665 + _v32 - 1120210379 + (( !_t558 | _t522) ^ _t411) + _t522;
    asm("ror ecx, 0x11");
    _t564 = _t558 + _v68 + 718787259 + (( !_t411 | _t671) ^ _t522) + _t671;
     *_a4 = _t522 + _v96;
    asm("ror eax, 0xb");
     *_v88 = _t564 +  *_v88 + _t411 + _v40 - 343485551 + (( !_t522 | _t564) ^ _t671);
    _t418 = _v84;
     *_t418 =  *_t418 + _t564;
     *_v80 =  *_v80 + _t671;
    return _t418;
}

caml_MD5Final(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr* _a8                          // _cfa_8
)
{// addr = 0x08068428
    signed char _v36;                      // _cfa_ffffffdc
    char _v40;                             // _cfa_ffffffd8 (outparam)
    intOrPtr* __ebx;                       // r1
    _unknown_ __edi;                       // r4
    intOrPtr* __esi;                       // r5
    signed int _t37;                       // _t37
    intOrPtr* _t40;                        // _t40
    intOrPtr _t45;                         // _t45
    intOrPtr _t49;                         // _t49
    signed int _t51;                       // _t51
    intOrPtr _t53;                         // _t53
    signed int _t57;                       // _t57
    char* _t58;                            // _t58

    __esi = _a4;
    __ebx = _a8;
    _t37 =  *(__ebx + 16) >> 3 & 63;
     *((char*)(__ebx + _t37 + 24)) = 128;
    _t53 = __ebx + _t37 + 25;
    _t49 = 63 - _t37;
    if(63 > 7) {
        _v36 = 0x37;
        _v40 = 0;
         *__esp = _t53;
        memset();
    } else {
        _v36 = _t49;
        _v40 = 0;
         *__esp = _t53;
        memset();
        _t57 = __ebx + 24;
        caml_MD5Transform(__ebx, _t57);
        _t56 = 56;
        if((_t57 & 1) != 0) {
             *_t57 = 0;
            _t57 = _t57 + 1;
            _t56 = 0x37;
        }
        if((_t57 & 2) != 0) {
             *_t57 = 0;
            _t57 = _t57 + 2;
            _t56 = _t56 - 2;
        }
        _t51 = _t56 >> 2;
        _push(_t51 << 2);
        _push(0);
        _push(_t57);
        memset();
        __esp = __esp + 12;
        _t58 = _t57 + _t51;
        if((_t56 & 2) != 0) {
             *_t58 = 0;
            _t58 = _t58 + 2;
        }
        if((_t56 & 1) != 0) {
             *_t58 = 0;
        }
    }
    _t40 = __ebx + 24;
     *(_t40 + 56) =  *(__ebx + 16);
    _t40[0xf] = __ebx[5];
    caml_MD5Transform(__ebx, _t40);
     *__esi =  *__ebx;
    __esi[1] = __ebx[1];
    __esi[2] = __ebx[2];
    _t45 = __ebx[3];
    __esi[3] = _t45;
     *__ebx = 0;
    return _t45;
}

caml_MD5Update(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x08068516
    intOrPtr* _v32;                        // _cfa_ffffffe0
    intOrPtr* _v36;                        // _cfa_ffffffdc
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    intOrPtr _t73;                         // _t73
    intOrPtr _t77;                         // _t77
    intOrPtr* _t79;                        // _t79
    intOrPtr _t87;                         // _t87
    unsigned int _t92;                     // _t92
    signed int _t94;                       // _t94
    intOrPtr* _t96;                        // _t96
    intOrPtr _t98;                         // _t98
    intOrPtr _t99;                         // _t99
    signed int _t121;                      // _t121
    signed int _t124;                      // _t124
    signed int _t125;                      // _t125

    _t124 = _a12;
    _t92 =  *(_a4 + 16);
    _t73 = _t92 + _t124 * 8;
    _t98 = _a4;
     *((intOrPtr*)(_t98 + 16)) = _t73;
    if(_t92 > _t73) {
         *((intOrPtr*)(_t98 + 20)) =  *((intOrPtr*)(_t98 + 20)) + 1;
    }
    _t99 = _a4;
     *((intOrPtr*)(_t99 + 20)) =  *((intOrPtr*)(_t99 + 20)) + (_t124 >> 29);
    _t94 = _t92 >> 3 & 63;
    if(_t94 == 0) {
L6:
        if(_t124 <= 63) {
L10:
            _t77 = _a4 + 24;
            _v52 = _t124;
            _v56 = _a8;
             *__esp = _t77;
            memcpy();
            return _t77;
        }
        _t96 = _a4 + 24;
        _v36 = _t96;
        _v32 = _a4;
        __esi = 0;
        do {
            _t79 = _a8 + __esi;
             *_t96 =  *_t79;
            _t96[1] = _t79[1];
            _t96[2] = _t79[2];
            _t96[3] = _t79[3];
            _t96[4] = _t79[4];
            _t96[5] = _t79[5];
            _t96[6] = _t79[6];
            _t96[7] = _t79[7];
            _t96[8] = _t79[8];
            _t96[9] = _t79[9];
            _t96[0xa] = _t79[0xa];
            _t96[0xb] = _t79[0xb];
            _t96[0xc] = _t79[0xc];
            _t96[0xd] = _t79[0xd];
            _t96[0xe] = _t79[0xe];
            _t96[0xf] = _t79[0xf];
            caml_MD5Transform(_v32, _v36);
            __esi = __esi + 64;
        } while(_t124 - __esi > 63);
        _t125 = _t124 - 64;
        _a8 = _a8 + (_t125 & -64) + 64;
        _t124 = _t125 & 63;
        goto L10;
    } else {
        _t87 = _t99 + _t94 + 24;
        _t121 = 64 - _t94;
        if(_t124 >= 64) {
            _v52 = _t121;
            _v56 = _a8;
             *__esp = _t87;
            memcpy();
            caml_MD5Transform(_a4, _a4 + 24);
            _a8 = _a8 + 64;
            _t124 = _t124 - 64;
            goto L6;
        }
        _v52 = _t124;
        _v56 = _a8;
         *__esp = _t87;
        memcpy();
        return _t87;
    }
}

caml_md5_chan(
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806867A
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    char _v148;                            // _cfa_ffffff6c
    char _v4244;                           // _cfa_ffffef6c
    intOrPtr* _v4256;                      // _cfa_ffffef60
    char* _v4260;                          // _cfa_ffffef5c
    intOrPtr _v4276;                       // _cfa_ffffef4c (outparam)
    signed int _v4280;                     // _cfa_ffffef48 (outparam)
    _unknown_ __ebx;                       // r1
    char* __edi;                           // r4
    intOrPtr* __esi;                       // r5
    _unknown_ _t35;                        // _t35
    intOrPtr* _t40;                        // _t40
    intOrPtr* _t41;                        // _t41
    intOrPtr* _t43;                        // _t43
    intOrPtr _t47;                         // _t47
    signed int _t49;                       // _t49
    intOrPtr* _t50;                        // _t50
    intOrPtr* _t55;                        // _t55

    _t35 = caml_local_roots;
    _v4260 = _t35;
    _v60 = _t35;
    caml_local_roots =  &_v60;
    _v52 = 1;
    _v56 = 2;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v4256 =  *((intOrPtr*)(_a4 + 4));
    _t40 = caml_channel_mutex_lock;
    _t55 = _t40;
    if(_t55 != 0) {
         *__esp = _v4256;
         *_t40();
    }
    _t41 =  &_v148;
    caml_MD5Init( &_v148);
    _t49 = _a8 >> 1;
    if(_t55 < 0) {
        _t49 =  &_v4244;
        __esi =  &_v148;
        while(1) {
            _v4276 = 4096;
            _v4280 = _t49;
            _t41 = _v4256;
             *__esp = _t41;
            caml_getblock(_t49,  &_v4244, __esi);
            if(_t41 == 0) {
                goto L11;
            }
            caml_MD5Update(__esi, _t49, _t41);
        }
    } else {
        __edi =  &_v4244;
        if(_t49 > 0) {
            do {
                _t47 = _t49 - 4096 <= 0 ? _t49 : 4096;
                caml_getblock(_t49,  &_v4244, __esi, _v4256,  &_v4244, _t47);
                __esi = _t47;
                if(_t47 == 0) {
                    caml_raise_end_of_file();
                }
                _v4276 = _t47;
                _v4280 =  &_v4244;
                _t41 =  &_v148;
                 *__esp =  &_v148;
                caml_MD5Update();
                _t49 = _t49 - __esi;
            } while(_t49 > 0);
        } else {
        }
    }
L11:
    caml_alloc_string(_t49,  &_v4244, __esi, __fp0, 16);
    _t50 = _t41;
    caml_MD5Final(_t50,  &_v148);
    _t43 = caml_channel_mutex_unlock;
    if(_t43 != 0) {
         *__esp = _v4256;
         *_t43();
    }
    caml_local_roots = _v4260;
    return _t50;
}

caml_md5_string(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    _unknown_ __fp0,                       // r28
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12                        // _cfa_c
)
{// addr = 0x080687CD
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    char _v100;                            // _cfa_ffffff9c
    _unknown_ _v116;                       // _cfa_ffffff8c (outparam)
    _unknown_ _v120;                       // _cfa_ffffff88 (outparam)
    intOrPtr* _t19;                        // _t19

    __fp0 = __fp0;
    __edi = __edi;
    _v12 = __ebx;
    _v8 = __esi;
    caml_MD5Init( &_v100);
    caml_MD5Update( &_v100, (_a8 >> 1) + _a4, _a12 >> 1);
    _t19 = caml_alloc_string( &_v100, __edi, __esi, __fp0, 16);
    caml_MD5Final(_t19,  &_v100);
    return _t19;
}

add_char(
    intOrPtr* __eax,                       // r0
    char __edx                             // r3
)
{// addr = 0x08068828
    char* _t2;                             // _t2

    __edx = __edx;
    __eax = __eax;
    _t2 =  *__eax;
    if(_t2 <  *((intOrPtr*)(__eax + 4))) {
         *_t2 = __edx;
         *__eax = _t2 + 1;
        return __eax;
    }
    return __eax;
}

add_string(
    intOrPtr* __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edx,                        // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0806883B
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    intOrPtr _t16;                         // _t16
    intOrPtr _t19;                         // _t19

    __edx = __edx;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    asm("repne scasb");
    _t16 =  *__eax;
    _t19 =  *((intOrPtr*)(__eax + 4)) - _t16 +  !-1 - 1 < 0 ?  *((intOrPtr*)(__eax + 4)) - _t16 :  !-1 - 1;
    if(_t19 > 0) {
        _v52 = _t19;
        _v56 = __edx;
         *__esp = _t16;
        memmove();
    }
     *__eax =  *__eax + _t19;
    return _t16;
}

caml_format_exception(
    signed int _a4                         // _cfa_4
)
{// addr = 0x08068892
    char _v28;                             // _cfa_ffffffe4
    char _v29;                             // _cfa_ffffffe3
    char _v284;                            // _cfa_fffffee4
    char* _v288;                           // _cfa_fffffee0
    char _v292;                            // _cfa_fffffedc
    char _v356;                            // _cfa_fffffe9c
    signed int _v368;                      // _cfa_fffffe90
    signed int _v372;                      // _cfa_fffffe8c
    signed char _v388;                     // _cfa_fffffe7c
    char* _v392;                           // _cfa_fffffe78
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    unsigned int _t46;                     // _t46
    intOrPtr _t49;                         // _t49
    signed int _t73;                       // _t73
    intOrPtr _t74;                         // _t74
    signed char _t75;                      // _t75
    intOrPtr _t90;                         // _t90
    signed int _t92;                       // _t92
    intOrPtr _t93;                         // _t93
    signed char _t94;                      // _t94
    signed int _t95;                       // _t95
    signed int _t96;                       // _t96

    _t73 = _a4;
    _v292 =  &_v284;
    _v288 =  &_v29;
    add_string( &_v292, _t73,  *((intOrPtr*)( *_t73)), _t90, _t93);
    _t46 =  *(_t73 - 4) >> 10;
    if(_t46 <= 1) {
L16:
         *_v292 = 0;
        _t49 = _v292 -  &_v28;
        _t94 = _t49 + 257;
         *__esp = _t94;
        malloc();
        _t74 = _t49;
        if(_t49 != 0) {
            _v388 = _t94;
            _v392 =  &_v284;
             *__esp = _t74;
            memmove();
        }
        return _t74;
    }
    if(_t46 != 2) {
L4:
        _t95 = _t73;
        _v368 = 1;
L5:
        add_char( &_v292, 40);
        _v372 = _t95;
        _t92 = _t95 - 4;
        if(_v368 >=  *_t92 >> 10) {
L15:
            add_char( &_v292, 41);
            goto L16;
        } else {
            _t96 = _v368;
            while(1) {
                _t75 =  *(_v372 + _t96 * 4);
                if((_t75 & 1) == 0) {
                    if( *(_t75 - 4) != 252) {
                        add_char( &_v292, 95);
                    } else {
                        add_char( &_v292, 34);
                        add_string( &_v292, _t75, _t75, _t92, _t96);
                        add_char( &_v292, 34);
                    }
                } else {
                    _v388 = _t75;
                    _v392 = "%ld";
                     *__esp =  &_v356;
                    sprintf();
                    add_string( &_v292, _t75,  &_v356, _t92, _t96);
                }
                _t96 = _t96 + 1;
                if( *_t92 >> 10 <= _t96) {
                    goto L15;
                }
                if(_v368 < _t96) {
                    add_string( &_v292, _t75, 134661476, _t92, _t96);
                }
            }
            goto L15;
        }
    }
    _t95 =  *(_t73 + 4);
    if((_t95 & 1) != 0) {
        goto L4;
    }
    _v368 = 0;
    if( *(_t95 - 4) == 0) {
        goto L5;
    }
    goto L4;
}

signed int caml_fatal_uncaught_exception(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x08068A39
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int _v36;                       // _cfa_ffffffdc
    char* _v40;                            // _cfa_ffffffd8 (outparam)
    signed int _t23;                       // _t23
    signed int _t34;                       // _t34
    signed int _t35;                       // _t35
    signed int _t38;                       // _t38
    intOrPtr _t43;                         // _t43
    signed int _t45;                       // _t45
    _unknown_ _t46;                        // _t46

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t33 = caml_format_exception(_a4);
    _t45 = caml_backtrace_active;
    _t43 = caml_backtrace_pos;
    caml_backtrace_active = 0;
    if(caml_named_value("Pervasives.do_at_exit") != 0) {
        caml_callback_exn( *_t22, 1);
    }
    caml_backtrace_active = _t45;
    caml_backtrace_pos = _t43;
    _v36 = _t33;
    _v40 = "Fatal error: exception %s\n";
    _t23 = __imp__stderr;
     *__esp = _t23;
    fprintf();
     *__esp = _t33;
    free();
    if(caml_backtrace_active != 0) {
        _t23 = caml_print_exception_backtrace();
    }
     *__esp = 2;
    exit();
    0;
    0;
    _push(_t46);
    _push(_t33);
    _t38 =  *_t23 & 255;
    _t35 = 0;
    while(_t38 != 0) {
        _t34 = _t35 + _t35 * 8;
        _t33 = _t35 + _t34 * 2;
        _t35 = _t38 + _t35 + _t34 * 2;
        _t23 = _t23 + 1;
        _t38 =  *_t23 & 255;
    }
    _t27 = _t35 * 1321528399 >> 32 >> 2;
    _pop(__ebx);
    return _t35 - (_t35 * 1321528399 >> 32 >> 2) + (_t27 + _t27 * 2) * 4;
}

signed int hash_value_name(
    signed char* __eax                     // r0
)
{// addr = 0x08068AE0
    _unknown_ __ebx;                       // r1
    signed char* _t13;                     // _t13
    signed int _t22;                       // _t22
    signed int _t25;                       // _t25

    _t13 = __eax;
    _t25 =  *__eax & 255;
    _t22 = 0;
    while(_t25 != 0) {
        _t22 = _t25 + _t22 + (_t22 + _t22 * 8) * 2;
        _t13 =  &(_t13[1]);
        _t25 =  *_t13 & 255;
    }
    return _t22 - (_t22 * 1321528399 >> 32 >> 2) + ((_t22 * 1321528399 >> 32 >> 2) + _t17 * 2) * 4;
}

caml_named_value(
    signed char* _a4                       // _cfa_4
)
{// addr = 0x08068B20
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr __ebx;                        // r1
    signed char* __esi;                    // r5
    intOrPtr _t10;                         // _t10

    __esi = _a4;
    __ebx =  *((intOrPtr*)(hash_value_name(__esi) * 4 +  &named_value_table));
    if(__ebx == 0) {
L4:
        return 0;
    } else {
        goto L1;
    }
    while(1) {
L1:
        _t10 = __ebx + 8;
        _v24 = _t10;
         *__esp = __esi;
        strcmp();
        if(_t10 == 0) {
            break;
        }
        __ebx =  *((intOrPtr*)(__ebx + 4));
        if(__ebx != 0) {
            continue;
        }
        goto L4;
    }
    return __ebx;
}

caml_register_named_value(
    signed char* _a4,                      // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08068B67
    signed int _v32;                       // _cfa_ffffffe0
    intOrPtr _v56;                         // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    signed char* __esi;                    // r5
    signed int _t19;                       // _t19
    intOrPtr* _t21;                        // _t21
    intOrPtr _t26;                         // _t26
    intOrPtr* _t28;                        // _t28
    intOrPtr* _t29;                        // _t29
    signed int _t33;                       // _t33

    __esi = _a4;
    _t19 = hash_value_name(__esi);
    _v32 = _t19;
    _t28 =  *((intOrPtr*)(_t19 * 4 +  &named_value_table));
    if(_t28 == 0) {
L4:
        asm("repne scasb");
        _t21 = caml_stat_alloc(0,  !-1 + 11);
        _t29 = _t21;
        _v56 = __esi;
         *__esp = _t21 + 8;
        strcpy();
         *_t29 = _a8;
        _t33 = _v32;
         *((intOrPtr*)(_t29 + 4)) =  *((intOrPtr*)( &named_value_table + _t33 * 4));
         *((intOrPtr*)( &named_value_table + _t33 * 4)) = _t29;
        caml_register_global_root(_t29);
    } else {
        while(1) {
            _t26 = _t28 + 8;
            _v56 = _t26;
             *__esp = __esi;
            strcmp();
            if(_t26 == 0) {
                break;
            }
            _t28 = _t28[1];
            if(_t28 != 0) {
                continue;
            } else {
                goto L4;
            }
            goto L5;
        }
         *_t28 = _a8;
    }
L5:
    return 1;
}

signed int caml_callback3(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x08068C00
    _unknown_ _v16;                        // _cfa_fffffff0 (outparam)
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int _t12;                       // _t12

    _t12 = caml_callback3_exn(_a4, _a8, _a12, _a16);
    if((_t12 & 3) == 2) {
         *__esp = _t12 & -4;
        return caml_raise();
    }
    return _t12;
}

signed int caml_callback2(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08068C3D
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int _t9;                        // _t9

    _t9 = caml_callback2_exn(_a4, _a8, _a12);
    if((_t9 & 3) == 2) {
         *__esp = _t9 & -4;
        return caml_raise();
    }
    return _t9;
}

signed int caml_callback(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x08068C73
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int _t6;                        // _t6

    _t6 = caml_callback_exn(_a4, _a8);
    if((_t6 & 3) == 2) {
         *__esp = _t6 & -4;
        return caml_raise();
    }
    return _t6;
}

signed int caml_callbackN_exn(
    char _a4,                              // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08068CA2
    char* _v48;                            // _cfa_ffffffd0
    intOrPtr _v52;                         // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    char _v92;                             // _cfa_ffffffa4
    signed int _v96;                       // _cfa_ffffffa0
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    _unknown_ _v128;                       // _cfa_ffffff80
    char* _v144;                           // _cfa_ffffff70
    _unknown_ _v160;                       // _cfa_ffffff60 (outparam)
    _unknown_ _v164;                       // _cfa_ffffff5c (outparam)
    _unknown_ _v168;                       // _cfa_ffffff58 (outparam)
    signed int __ebx;                      // r1
    intOrPtr __edi;                        // r4
    intOrPtr __esi;                        // r5
    _unknown_ _t66;                        // _t66
    signed int _t69;                       // _t69
    signed int _t74;                       // _t74
    signed int _t78;                       // _t78

    __edi = _a8;
    __esi = _a12;
    _v144 = caml_local_roots;
    caml_local_roots =  &_v128;
    _v96 = _a4;
    if(__edi <= 0) {
L15:
        caml_local_roots = _v144;
        return _v96;
    }
    _v60 = _v144;
    _v52 = 1;
    _v56 = 1;
    _v48 =  &_a4;
    _v92 =  &_v60;
    _v84 = __edi;
    _v88 = 1;
    _v80 = __esi;
    _v128 =  &_v92;
    _v120 = 1;
    _v124 = 1;
    _v116 =  &_v96;
    __ebx = 0;
    do {
        _t66 = __edi - __ebx;
        if(_t66 == 1) {
            _t69 = caml_callback_exn(_v96,  *((intOrPtr*)(__esi + __ebx * 4)));
            if((_t69 & 3) != 2) {
                _v96 = _t69;
                __ebx = __ebx + 1;
                goto L14;
            }
            caml_local_roots = _v144;
            return _t69;
        }
        if(_t66 != 2) {
            _t74 = caml_callback3_exn(_v96,  *((intOrPtr*)(__esi + __ebx * 4)),  *((intOrPtr*)(__esi + 4 + __ebx * 4)),  *((intOrPtr*)(__esi + 8 + __ebx * 4)));
            if((_t74 & 3) != 2) {
                _v96 = _t74;
                __ebx = __ebx + 3;
                goto L14;
            }
            caml_local_roots = _v144;
            return _t74;
        }
        _t78 = caml_callback2_exn(_v96,  *((intOrPtr*)(__esi + __ebx * 4)),  *((intOrPtr*)(__esi + 4 + __ebx * 4)));
        if((_t78 & 3) != 2) {
            _v96 = _t78;
            __ebx = __ebx + 2;
            goto L14;
        }
        caml_local_roots = _v144;
        return _t78;
L14:
    } while(__edi > __ebx);
    goto L15;
}

signed int caml_callbackN(
    char _a4,                              // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x08068E04
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int _t9;                        // _t9

    _t9 = caml_callbackN_exn(_a4, _a8, _a12);
    if((_t9 & 3) == 2) {
         *__esp = _t9 & -4;
        return caml_raise();
    }
    return _t9;
}

caml_weak_check(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08068E40
    signed int _t10;                       // _t10

    _t10 = (_a8 >> 1) + 1;
    if(_t10 == 0) {
L2:
         *__esp = "Weak.get";
        _t10 = caml_invalid_argument();
    } else {
        __edx = _a4;
        if(_t10 >=  *(__edx - 4) >> 10) {
            goto L2;
        }
    }
    return ( *((intOrPtr*)(__edx + _t10 * 4)) != caml_weak_none & 255) + ( *((intOrPtr*)(__edx + _t10 * 4)) != caml_weak_none & 255) + 1;
}

signed char do_set(
    _unknown_ __eax,                       // r0
    signed int __ecx,                      // r2
    signed int __edx                       // r3
)
{// addr = 0x08068E7E
    signed char* __ebx;                    // r1
    signed char _t10;                      // _t10
    signed char** _t15;                    // _t15

    __ecx = __ecx;
    if((__ecx & 1) != 0 || __ecx >= caml_young_end || __ecx <= caml_young_start) {
         *(__eax + __edx * 4) = __ecx;
        return __eax;
    } else {
        __ebx = __eax + __edx * 4;
        _t10 =  *__ebx;
         *__ebx = __ecx;
        if((_t10 & 1) != 0 || _t10 >= caml_young_end || _t10 <= caml_young_start) {
            if( *134707460 >=  *134707464) {
                caml_realloc_ref_table(__ebx, __edi, __esi,  &caml_weak_ref_table);
            }
            _t15 =  *134707460;
             *_t15 = __ebx;
             *134707460 =  &(_t15[1]);
            return 134707460;
        }
        return _t10;
    }
}

caml_weak_blit(
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    signed int _a16,                       // _cfa_10
    signed int _a20                        // _cfa_14
)
{// addr = 0x08068EE7
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v52;                     // _cfa_ffffffcc
    intOrPtr _v80;                         // _cfa_ffffffb0
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t52;                       // _t52
    signed int _t55;                       // _t55
    signed int _t56;                       // _t56
    _unknown_ _t66;                        // _t66
    signed int _t70;                       // _t70
    intOrPtr* _t73;                        // _t73
    _unknown_ _t74;                        // _t74
    unsigned int _t75;                     // _t75
    unsigned int _t81;                     // _t81
    _unknown_ _t84;                        // _t84
    _unknown_ _t86;                        // _t86
    unsigned int* _t88;                    // _t88
    intOrPtr _t93;                         // _t93
    signed int _t94;                       // _t94
    intOrPtr _t96;                         // _t96
    signed int _t98;                       // _t98
    _unknown_ _t100;                       // _t100

    _t52 = _a8 >> 1;
    _v44 = _t52;
    _t96 = _t52 + 1;
    if(_t96 == 0) {
L2:
         *__esp = "Weak.blit";
        caml_invalid_argument();
L3:
        _t55 = _a16 >> 1;
        _v40 = _t55;
        _t56 = _t55 + 1;
        _v36 = _t56;
        if(_t56 == 0 || _v32 + _v36 >  *(_a12 - 4) >> 10) {
             *__esp = "Weak.blit";
            caml_invalid_argument();
        }
        if(caml_gc_phase != 0 || caml_gc_subphase != 11) {
L17:
            if(_t96 <= _v36) {
                _t98 = _v32 - 1;
                _v36 = _t98;
                if(_t98 < 0) {
L25:
                    return 1;
                }
                _t73 = _t93 + (_v32 + _v44) * 4;
                _t100 = _v32 + _v40;
                _t94 = _v36;
                do {
                    do_set(_a12,  *_t73, _t100);
                    _t73 = _t73 - 4;
                    _t100 = _t100 - 1;
                    _t94 = _t94 - 1;
                } while(_t94 >= 0);
                goto L25;
            }
            if(_v32 == 0) {
                goto L25;
            }
            _t84 = 0;
            _t74 = 0;
            do {
                do_set(_a12,  *((intOrPtr*)(_t93 + (_t84 + _t96) * 4)), _t84 + _v36);
                _t74 = _t74 + 1;
                _t84 = _t74;
            } while(_v32 > _t74);
            goto L25;
        } else {
            if(_v32 == 0) {
                goto L17;
            } else {
                _t86 = 0;
                _t66 = 0;
                _v80 = _t96;
                goto L10;
                do {
L15:
                    _t66 = _t66 + 1;
                    _t86 = _t66;
                    if(_v32 > _t66) {
L10:
                        _t88 = _t93 + (_t86 + _v80) * 4;
                        _t75 =  *_t88;
                        _t81 = caml_weak_none;
                        if(_t75 != _t81 && (_t75 & 1) == 0) {
                            _v52 = _t75;
                            if(( *( *((intOrPtr*)((_t75 >> 23) * 4 +  &caml_page_table)) + (_t75 >> 12 & 2047)) & 1) != 0 && ( *(_v52 - 4) & 768) == 0) {
                                 *_t88 = _t81;
                            }
                        }
                        continue;
                    } else {
                        _t96 = _v80;
                        goto L17;
                    }
                } while();
                goto L15;
            }
        }
    }
    _t70 = _a20 >> 1;
    _v32 = _t70;
    _t93 = _a4;
    if(_t70 + _t96 <=  *(_t93 - 4) >> 10) {
        goto L3;
    }
    goto L2;
}

caml_weak_set(
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    signed int _a8,                        // _cfa_8
    signed char _a12                       // _cfa_c
)
{// addr = 0x0806903B
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _t13;                         // _t13
    signed char _t21;                      // _t21
    signed int _t25;                       // _t25
    intOrPtr _t26;                         // _t26

    _t26 = __esi;
    _v12 = __ebx;
    _v8 = __esi;
    _t13 = _a4;
    _t21 = _a12;
    _t25 = (_a8 >> 1) + 1;
    if(_t25 == 0) {
L2:
         *__esp = "Weak.set";
        _t13 = caml_invalid_argument();
L3:
        if(_t21 == 1 || (_t21 & 1) != 0) {
             *((intOrPtr*)(_t26 + _t25 * 4)) = caml_weak_none;
        } else {
            do_set(_t13,  *_t21, _t25);
        }
        return 1;
    }
    _t26 = _t13;
    if(_t25 <  *(_t13 - 4) >> 10) {
        goto L3;
    }
    goto L2;
}

signed int caml_weak_get_copy(
    _unknown_ __fp0,                       // r28
    char _a4,                              // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x08069099
    char* _v44;                            // _cfa_ffffffd4
    char* _v48;                            // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    intOrPtr _v56;                         // _cfa_ffffffc8
    char _v60;                             // _cfa_ffffffc4
    signed int _v64;                       // _cfa_ffffffc0
    unsigned int _v68;                     // _cfa_ffffffbc
    char* _v84;                            // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    signed int _v92;                       // _cfa_ffffffa4
    intOrPtr _v96;                         // _cfa_ffffffa0
    char _v100;                            // _cfa_ffffff9c
    signed int _v112;                      // _cfa_ffffff90
    unsigned int* _v116;                   // _cfa_ffffff8c
    signed int _v120;                      // _cfa_ffffff88
    intOrPtr _v124;                        // _cfa_ffffff84
    signed int _v132;                      // _cfa_ffffff7c
    signed int _v136;                      // _cfa_ffffff78 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    intOrPtr _t80;                         // _t80
    unsigned int _t81;                     // _t81
    signed int _t82;                       // _t82
    unsigned int _t87;                     // _t87
    signed char* _t92;                     // _t92
    intOrPtr _t99;                         // _t99
    intOrPtr* _t101;                       // _t101
    char* _t112;                           // _t112
    signed char _t113;                     // _t113
    unsigned int* _t117;                   // _t117
    signed char _t121;                     // _t121
    signed int _t129;                      // _t129
    intOrPtr _t138;                        // _t138
    unsigned int _t143;                    // _t143
    signed int _t145;                      // _t145
    signed int _t149;                      // _t149
    signed int _t150;                      // _t150
    signed int _t151;                      // _t151

    __fp0 = __fp0;
    _t112 = caml_local_roots;
    _v60 = _t112;
    _v52 = 1;
    _v56 = 2;
    _v48 =  &_a4;
    _v44 =  &_a8;
    _v64 = 0;
    _v68 = 0;
    _v100 =  &_v60;
    caml_local_roots =  &_v100;
    _v92 = 1;
    _v96 = 2;
    _v88 =  &_v64;
    _v84 =  &_v68;
    _t149 = (_a8 >> 1) + 1;
    if(_t149 == 0) {
L2:
         *__esp = "Weak.get";
        _t80 = caml_invalid_argument();
L3:
        _t150 = _t149 << 2;
        _t81 =  *(_t150 + _t80);
        if(_t81 == caml_weak_none) {
            caml_local_roots = _t112;
            return 1;
        }
        if((_t81 & 1) != 0) {
L31:
            _v68 = _t81;
            goto L32;
        } else {
            _t143 = _t81;
            if(( *( *((intOrPtr*)((_t81 >> 23) * 4 +  &caml_page_table)) + (_t81 >> 12 & 2047)) & 3) == 0) {
                goto L31;
            }
            _t87 = caml_alloc(_t112, _t143 - 4, _t150, __fp0,  *(_t143 - 4) >> 10,  *_t144 & 255);
            _v68 = _t87;
            _t129 =  *(_t150 + _a4);
            if(_t129 != caml_weak_none) {
                _v120 = _t129;
                _t117 = _t129 - 4;
                if( *_t117 > 250) {
                    _v132 =  *_t117 >> 10 << 2;
                    _v136 = _t129;
                     *__esp = _t87;
                    memmove();
L32:
                    _t82 = caml_alloc_small(_t112, _t150, 1, 0);
                    _v64 = _t82;
                     *_t82 = _v68;
                    caml_local_roots = _t112;
                    return _v64;
                }
                _v116 = _t117;
                if( *_t117 >> 10 == 0) {
                    goto L32;
                }
                _t151 = 0;
                _v124 = _t112;
                do {
                    _t145 = _t151 * 4;
                    _t113 =  *(_v120 + _t151 * 4);
                    if(caml_gc_phase == 0 && (_t113 & 1) == 0 && ( *( *((intOrPtr*)((_t113 >> 23) * 4 +  &caml_page_table)) + (_t113 >> 12 & 2047)) & 1) != 0) {
                        _v136 = 0;
                        caml_darken(_t113);
                    }
                    _t92 = _t145 + _v68;
                    _v112 =  *_t92;
                     *_t92 = _t113;
                    if(( *( *((intOrPtr*)((_t145 + _v68 >> 23) * 4 +  &caml_page_table)) + (_t145 + _v68 >> 12 & 2047)) & 1) != 0) {
                        if(caml_gc_phase == 0) {
                            _v136 = 0;
                            caml_darken(_v112);
                        }
                        if((_t113 & 1) != 0) {
                            goto L28;
                        } else {
                            _t99 = caml_young_end;
                            if(_t113 >= _t99) {
                                goto L28;
                            }
                            _t138 = caml_young_start;
                            if(_t113 <= _t138) {
                                goto L28;
                            }
                            if((_v112 & 1) != 0) {
L25:
                                if( *134707432 >=  *134707436) {
                                    caml_realloc_ref_table(_t113, _t145, _t151,  &caml_ref_table);
                                }
                                _t101 =  *134707432;
                                 *_t101 = _t145 + _v68;
                                 *134707432 = _t101 + 4;
                                goto L28;
                            }
                            _t121 = _v112;
                            if(_t99 <= _t121 || _t138 >= _t121) {
                                goto L25;
                            } else {
                                goto L28;
                            }
                        }
                    }
L28:
                    _t151 = _t151 + 1;
                } while( *_v116 >> 10 > _t151);
                _t112 = _v124;
                goto L32;
            }
            caml_local_roots = _t112;
            return 1;
        }
    }
    _t80 = _a4;
    if(_t149 <  *(_t80 - 4) >> 10) {
        goto L3;
    }
    goto L2;
}

unsigned int caml_weak_get(
    intOrPtr __esi,                        // r5
    char* _a4,                             // _cfa_4
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806930B
    char* _v28;                            // _cfa_ffffffe4
    char* _v32;                            // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    char _v44;                             // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    char* _v68;                            // _cfa_ffffffbc
    char* _v72;                            // _cfa_ffffffb8
    unsigned int _v76;                     // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    char _v84;                             // _cfa_ffffffac
    unsigned int _v104;                    // _cfa_ffffff98 (outparam)
    char* __ebx;                           // r1
    signed int _t42;                       // _t42
    unsigned int _t43;                     // _t43
    unsigned int _t44;                     // _t44
    char* _t55;                            // _t55

    __esi = __esi;
    __ebx = caml_local_roots;
    _v44 = __ebx;
    _v36 = 1;
    _v40 = 2;
    _v32 =  &_a4;
    _v28 =  &_a8;
    _v48 = 0;
    _v52 = 0;
    _v84 =  &_v44;
    caml_local_roots =  &_v84;
    _v76 = 1;
    _v80 = 2;
    _v72 =  &_v48;
    _t55 =  &_v52;
    _v68 =  &_v52;
    _t42 = (_a8 >> 1) + 1;
    if(_t42 == 0) {
L2:
         *__esp = "Weak.get";
        _t42 = caml_invalid_argument();
L3:
        _t43 =  *(_t55 + _t42 * 4);
        if(_t43 != caml_weak_none) {
            _v52 = _t43;
            if(caml_gc_phase == 0 && (_t43 & 1) == 0 && ( *( *((intOrPtr*)((_t43 >> 23) * 4 +  &caml_page_table)) + (_t43 >> 12 & 2047)) & 1) != 0) {
                _v104 = 0;
                caml_darken(_t43);
            }
            _t44 = caml_alloc_small(__ebx, __esi, 1, 0);
            _v48 = _t44;
             *_t44 = _v52;
        } else {
            _v48 = 1;
        }
        caml_local_roots = __ebx;
        return _v48;
    }
    _t55 = _a4;
    if(_t42 <  *(_t55 - 4) >> 10) {
        goto L3;
    }
    goto L2;
}

caml_weak_create(
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806940B
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int __ebx;                      // r1
    signed int _t7;                        // _t7
    _unknown_ _t8;                         // _t8
    signed int _t11;                       // _t11

    __esi = __esi;
    __edi = __edi;
    _t7 = _a4 >> 1;
    __ebx = _t7 + 1;
    if(_t7 > 4194302) {
         *__esp = "Weak.create";
        caml_invalid_argument();
    }
    _t8 = caml_alloc_shr(__ebx, __edi, __esi, __ebx, 251);
    if(__ebx > 1) {
        _t11 = 1;
        do {
             *((intOrPtr*)(_t8 + _t11 * 4)) = caml_weak_none;
            _t11 = _t11 + 1;
        } while(__ebx > _t11);
    }
     *_t8 = caml_weak_list_head;
    caml_weak_list_head = _t8;
    return _t8;
}

signed int invert_pointer_at(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x08069470
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    signed int* _v24;                      // _cfa_ffffffe8
    signed char* _t40;                     // _t40
    signed int* _t44;                      // _t44
    unsigned int _t45;                     // _t45
    signed int _t54;                       // _t54
    _unknown_ _t56;                        // _t56
    signed char _t57;                      // _t57
    unsigned int _t64;                     // _t64
    _unknown_ _t67;                        // _t67
    unsigned int _t70;                     // _t70

    _t28 = __eax;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t45 =  *__eax;
    if((_t45 & 3) != 0 || ( *( *((intOrPtr*)((_t45 >> 23) * 4 +  &caml_page_table)) + (_t45 >> 12 & 2047)) & 1) == 0) {
L14:
        return _t28;
    } else {
        _t70 = _t45 - 4;
        _t64 =  *_t70;
        _t54 = _t64 & 3;
        if(_t54 == 1) {
            _t56 = _t45 - (_t64 >> 10 << 2);
            _t67 = _t56;
            _t40 = _t56 - 4;
            _v24 = _t40;
            _t57 =  *_t40;
            if((_t57 & 3) != 0) {
L10:
                if(_t57 >> 2 != 247) {
                     *_t28 = _t67 + (_t57 >> 10) * 4 | 1;
                     *_t70 = _t28 | 2;
                    _t28 = (_t45 - _t67 >> 2) - 1 << 10 | 999;
                     *_v24 = _t28;
                } else {
                     *_t28 = _t57;
                     *_t70 = _t28 | 2;
                    _t28 = (_t45 - _t67 >> 2) - 1 << 10 | 999;
                     *_v24 = _t28;
                }
                goto L14;
            } else {
                goto L8;
            }
            do {
            } while();
            goto L10;
L8:
            _t44 = _t57;
            _t57 =  *_t57;
            if((_t57 & 3) == 0) {
                goto L8;
            } else {
                _v24 = _t44;
            }
            goto L10;
        }
        if(_t54 < 1) {
L6:
             *_t28 = _t64;
             *_t70 = _t28;
            goto L14;
        }
        if(_t54 == 2) {
             *__eax = _t64;
            _t28 = __eax | 2;
             *_t70 = _t28;
            goto L14;
        }
        if(_t54 != 3) {
            goto L14;
        }
        goto L6;
    }
}

invert_root(
    signed int _a8                         // _cfa_8
)
{// addr = 0x0806955F
    return invert_pointer_at(_a8, __ebx, __edi, __esi);
}

init_compact_allocate()
{// addr = 0x0806956C
    signed int* _t3;                       // _t3
    signed int* _t4;                       // _t4
    _unknown_ _t5;                         // _t5

    _t3 = caml_heap_start;
    while(_t3 != 0) {
        _t5 = _t3 - 16;
         *((intOrPtr*)(_t5 + 4)) = 0;
        _t3 =  *((intOrPtr*)(_t5 + 12));
    }
    _t4 = caml_heap_start;
    compact_fl = _t4;
    return _t4;
}

compact_allocate(
    _unknown_ __eax                        // r0
)
{// addr = 0x08069595
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    intOrPtr _t27;                         // _t27
    intOrPtr _t30;                         // _t30
    _unknown_ _t31;                        // _t31
    _unknown_ _t32;                        // _t32
    _unknown_ _t33;                        // _t33
    intOrPtr _t40;                         // _t40

    __ecx = compact_fl;
    _t31 = __ecx - 16;
    if( *((intOrPtr*)(_t31 + 8)) -  *((intOrPtr*)(_t31 + 4)) <= 16) {
        _t40 =  *((intOrPtr*)(_t31 + 12));
        _t33 = _t40 - 16;
        if( *((intOrPtr*)(_t33 + 8)) -  *((intOrPtr*)(_t33 + 4)) <= 16) {
            __ecx = _t40;
            while(1) {
                _t30 =  *((intOrPtr*)(_t33 + 12));
                _t33 = _t30 - 16;
                if( *((intOrPtr*)(_t33 + 8)) -  *((intOrPtr*)(_t33 + 4)) > 16) {
                    break;
                }
                _t40 = _t30;
                __ecx = _t30;
            }
            compact_fl = _t40;
        } else {
        }
    }
    _t32 = __ecx - 16;
    _t27 =  *((intOrPtr*)(_t32 + 4));
    if(__eax >  *((intOrPtr*)(_t32 + 8)) - _t27) {
        do {
            __ecx =  *((intOrPtr*)(_t32 + 12));
            _t32 = __ecx - 16;
            _t27 =  *((intOrPtr*)(_t32 + 4));
        } while( *((intOrPtr*)(_t32 + 8)) - _t27 < __eax);
    }
     *((intOrPtr*)(_t32 + 4)) = _t27 + __eax;
    return __ecx + _t27;
}

caml_compact_heap()
{// addr = 0x08069610
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed char* _v44;                     // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    intOrPtr _v68;                         // _cfa_ffffffbc (outparam)
    unsigned int* _v72;                    // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int* _t117;                     // _t117
    signed int _t120;                      // _t120
    unsigned int _t125;                    // _t125
    signed int _t127;                      // _t127
    signed int _t130;                      // _t130
    intOrPtr _t140;                        // _t140
    unsigned int _t143;                    // _t143
    signed int _t145;                      // _t145
    _unknown_ _t147;                       // _t147
    signed int _t149;                      // _t149
    signed int _t157;                      // _t157
    signed int _t161;                      // _t161
    signed char _t162;                     // _t162
    signed int _t164;                      // _t164
    signed int _t166;                      // _t166
    signed int _t169;                      // _t169
    signed char* _t172;                    // _t172
    unsigned int* _t173;                   // _t173
    signed int _t174;                      // _t174
    signed int _t175;                      // _t175
    signed int _t176;                      // _t176
    signed int _t178;                      // _t178
    signed int _t183;                      // _t183
    signed int _t185;                      // _t185
    intOrPtr _t186;                        // _t186
    signed char _t188;                     // _t188
    signed int _t191;                      // _t191
    signed int _t195;                      // _t195
    signed int _t196;                      // _t196
    signed int _t197;                      // _t197
    signed int _t198;                      // _t198
    signed char _t205;                     // _t205
    signed int _t213;                      // _t213
    signed int _t230;                      // _t230
    signed int _t233;                      // _t233
    signed int _t235;                      // _t235
    signed int _t242;                      // _t242
    signed int _t255;                      // _t255
    intOrPtr _t256;                        // _t256
    signed int _t258;                      // _t258
    signed char _t259;                     // _t259
    signed int _t260;                      // _t260
    unsigned int _t261;                    // _t261
    signed int _t264;                      // _t264
    _unknown_ _t267;                       // _t267
    intOrPtr _t268;                        // _t268
    _unknown_ _t270;                       // _t270
    unsigned int _t271;                    // _t271
    signed int _t273;                      // _t273
    signed int _t274;                      // _t274
    signed int _t279;                      // _t279
    signed int _t281;                      // _t281
    signed int _t284;                      // _t284
    intOrPtr _t285;                        // _t285
    intOrPtr _t286;                        // _t286

    caml_gc_message(16, "Compacting heap...\n", 0);
    _t117 = caml_heap_start;
    if(_t117 == 0) {
L7:
        caml_do_roots(invert_root);
        caml_final_do_weak_roots(invert_root);
        _t120 = caml_heap_start;
        if(_t120 == 0) {
L21:
            _t183 = caml_weak_list_head;
            _v32 = _t183;
            if(_t183 == 0) {
L31:
                init_compact_allocate();
                _t172 = caml_heap_start;
                if(_t172 == 0) {
L55:
                    init_compact_allocate();
                    _t173 = caml_heap_start;
                    if(_t173 == 0) {
L79:
                        caml_fl_reset();
L78:
                        caml_stat_compactions = caml_stat_compactions + 1;
                        return caml_gc_message(16, "done.\n", 0);
                    } else {
                        goto L56;
                    }
                    do {
L56:
                        _t196 = _t173 - 16;
                        _v32 = _t196;
                        _t270 = _t173 +  *((intOrPtr*)(_t196 + 8));
                        while(_t270 > _t173) {
                            _t125 =  *_t173;
                            if((_t125 & 3) != 0) {
                                _t173 = _t173 + 4 + (_t125 >> 10) * 4;
                            } else {
                                _t256 = 4 + (_t125 >> 10) * 4;
                                _t140 = compact_allocate(_t256);
                                _v68 = _t256;
                                _v72 = _t173;
                                 *__esp = _t140;
                                memmove();
                                _t173 = _t173 + _t256;
                            }
                        }
                        _t173 =  *(_v32 + 12);
                    } while(_t173 != 0);
                    _t185 = caml_heap_start;
                    if(_t185 == 0) {
                        goto L79;
                    }
                    _t197 = _t185;
                    _t127 = 0;
                    do {
                        _t198 = _t197 - 16;
                        _t271 =  *(_t198 + 4);
                        if(_t271 != 0) {
                            _t127 = _t127 + (_t271 >> 2);
                            _t173 = _t173 + ( *((intOrPtr*)(_t198 + 8)) - _t271 >> 2);
                        }
                        _t197 =  *(_t198 + 12);
                    } while(_t197 != 0);
                    _t255 = (_t127 / 100 + 1) * caml_percent_free;
                    while(1) {
                        _t130 = _t185 - 16;
                        _t273 =  *(_t130 + 12);
                        if( *((intOrPtr*)(_t130 + 4)) == 0) {
                            if(_t255 <= _t173) {
                                caml_shrink_heap(_t185);
                            } else {
                                _t173 = _t173 + ( *(_t130 + 8) >> 2);
                            }
                        }
                        if(_t273 == 0) {
                            break;
                        }
                        _t185 = _t273;
                    }
                    _t174 = caml_heap_start;
                    caml_fl_reset();
                    if(_t174 == 0) {
                        goto L78;
                    } else {
                        goto L75;
                    }
                    do {
L75:
                        _t274 = _t174 - 16;
                        _t201 =  *((intOrPtr*)(_t274 + 8));
                        _t132 =  *((intOrPtr*)(_t274 + 4));
                        if( *((intOrPtr*)(_t274 + 8)) >  *((intOrPtr*)(_t274 + 4))) {
                            caml_make_free_blocks(_t174 + _t132, _t201 - _t132 >> 2, 1);
                        }
                        _t174 =  *(_t274 + 12);
                    } while(_t174 != 0);
                    goto L78;
                } else {
                    goto L32;
                }
                do {
L32:
                    _t186 = _t172 - 16;
                    _v48 = _t186;
                    _v44 =  &(_t172[ *(_t186 + 8)]);
                    while(_v44 > _t172) {
                        _t143 =  *_t172;
                        if((_t143 & 3) == 0) {
                            do {
                                _t143 =  *_t143;
                            } while((_t143 & 3) == 0);
                            _t279 = (_t143 >> 10) + 1;
                            _t145 = _t143 >> 2 & 255;
                            _v40 = _t145;
                            _v36 = 0;
                            if(_t145 != 249) {
L41:
                                _v32 = _t279 * 4;
                                _t147 = compact_allocate(_t279 * 4);
                                _t205 =  *_t172;
                                if((_t205 & 3) != 0) {
L45:
                                     *_t172 = (_t279 << 10) + _v40 - 1024;
                                    if(_v36 == 0) {
L51:
                                        _t172 =  &(_t172[_v32]);
                                        continue;
                                    }
                                    _t191 = _v36;
                                    if((_t191 & 3) == 3) {
                                        goto L51;
                                    } else {
                                        goto L47;
                                    }
                                    do {
L47:
                                        _t258 = _t191 & -4;
                                        _t191 =  *_t258;
                                        if((_t191 & 3) != 2) {
                                            goto L50;
                                        }
                                        _t284 = _t147 + 4 + (_t258 - _t172 >> 2) * 4;
                                        do {
                                            _t230 = _t191 & -4;
                                            _t191 =  *_t230;
                                             *_t230 = _t284;
                                        } while((_t191 & 3) == 2);
L50:
                                         *_t258 = (_t258 - _t172 >> 2 << 10) + 249;
                                    } while((_t191 & 3) != 3);
                                    goto L51;
                                }
                                _t259 = _t147 + 4;
                                while(1) {
                                    _t188 =  *_t205;
                                     *_t205 = _t259;
                                    if((_t188 & 3) != 0) {
                                        goto L45;
                                    }
                                    _t205 = _t188;
                                }
                                goto L45;
                            }
L38:
                            _t281 = _t172 + _t279 * 4;
                            _v36 = _t281;
                            _t149 =  *_t281;
                            if((_t149 & 3) == 3) {
L40:
                                _t279 = (_t149 >> 10) + 1;
                                _v40 = _t149 >> 2 & 255;
                                goto L41;
                            } else {
                                goto L39;
                            }
                            do {
L39:
                                _t149 =  *(_t149 & -4);
                            } while((_t149 & 3) != 3);
                            goto L40;
                        }
                        _t213 = _t143 >> 2 & 255;
                        if(_t213 != 249) {
                             *_t172 = _t213 + (_t143 & -1024) + 512;
                            _t172 =  &(_t172[4 + (_t143 >> 10) * 4]);
                            continue;
                        }
                        _t279 = (_t143 >> 10) + 1;
                        goto L38;
                    }
                    _t172 =  *(_v48 + 12);
                } while(_t172 != 0);
                goto L55;
            }
            _v36 =  &caml_weak_list_head;
            do {
                _t175 = _v32;
                _t260 =  *((signed int*)(_t175 - 4));
                if((_t260 & 3) != 0) {
L25:
                    _t261 = _t260 >> 10;
                    if(_t261 <= 1) {
                        goto L30;
                    }
                    _t176 = _t175 + 4;
                    _t285 = 1;
                    do {
                        if( *_t176 != caml_weak_none) {
                            invert_pointer_at(_t176, _t176, _t261, _t285);
                        }
                        _t285 = _t285 + 1;
                        _t176 = _t176 + 4;
                    } while(_t261 > _t285);
                    goto L30;
                } else {
                    goto L24;
                }
                do {
L24:
                    _t260 =  *_t260;
                } while((_t260 & 3) == 0);
                goto L25;
L30:
                invert_pointer_at(_v36, _t175, _t261, _t268);
                _t157 = _v32;
                _v36 = _t157;
                _t233 =  *_t157;
                _v32 = _t233;
            } while(_t233 != 0);
            goto L31;
        } else {
            goto L8;
        }
        do {
L8:
            _v32 = _t120;
            _t161 = _t120 - 16;
            _v40 = _t161;
            _t235 = _v32 +  *((intOrPtr*)(_t161 + 8));
            _v36 = _t235;
            if(_t235 <= _v32) {
                goto L20;
            } else {
                goto L9;
            }
            do {
L9:
                _t162 =  *_v32;
                if((_t162 & 3) != 0) {
L11:
                    _t264 = (_t162 >> 10) + 1;
                    _t164 = _t162 >> 2 & 255;
                    if(_t164 != 249) {
L15:
                        if(_t164 <= 250 && _t264 > 1) {
                            _t178 = _v32 + 4;
                            _t286 = 1;
                            do {
                                invert_pointer_at(_t178, _t178, _t264, _t286);
                                _t286 = _t286 + 1;
                                _t178 = _t178 + 4;
                            } while(_t264 > _t286);
                        }
                        goto L19;
                    }
                    _t169 =  *(_v32 + _t264 * 4);
                    if((_t169 & 3) == 3) {
L14:
                        _t264 = (_t169 >> 10) + 1;
                        _t164 = _t169 >> 2 & 255;
                        goto L15;
                    } else {
                        goto L13;
                    }
                    do {
L13:
                        _t169 =  *(_t169 & -4);
                    } while((_t169 & 3) != 3);
                    goto L14;
                } else {
                    goto L10;
                }
                do {
L10:
                    _t162 =  *_t162;
                } while((_t162 & 3) == 0);
                goto L11;
L19:
                _t166 = _v32 + _t264 * 4;
                _v32 = _t166;
            } while(_v36 > _t166);
L20:
            _t120 =  *(_v40 + 12);
        } while(_t120 != 0);
        goto L21;
    } else {
        goto L1;
    }
    do {
L1:
        _t267 = _t117 - 16;
        _t268 = _t117 +  *((intOrPtr*)(_t267 + 8));
        if(_t268 <= _t117) {
            goto L6;
        } else {
            goto L2;
        }
        do {
L2:
            _t242 =  *_t117;
            _t195 = _t242 >> 10;
            if((_t242 & 768) != 512) {
                 *_t117 = (_t242 & 255) << 2 | _t195 << 10 | 3;
            } else {
                 *_t117 = _t195 << 10 | 1011;
            }
            _t117 = _t117 + 4 + _t195 * 4;
        } while(_t268 > _t117);
L6:
        _t117 =  *(_t267 + 12);
    } while(_t117 != 0);
    goto L7;
}

unsigned int caml_compact_heap_maybe(
    signed int __fp0                       // r28
)
{// addr = 0x08069AA5
    _unknown_ _v16;                        // _cfa_fffffff0
    intOrPtr _v24;                         // _cfa_ffffffe8
    unsigned int _v28;                     // _cfa_ffffffe4
    _unknown_ _v30;                        // _cfa_ffffffe2
    short _v32;                            // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ _v52;                        // _cfa_ffffffcc (outparam)
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    _unknown_ __ebx;                       // r1
    unsigned int _t39;                     // _t39
    unsigned int _t60;                     // _t60
    unsigned int _t62;                     // _t62
    _unknown_ _t68;                        // _t68
    unsigned int _t69;                     // _t69
    signed int _t74;                       // _t74
    signed int _t78;                       // _t78

    if(caml_percent_max > 999999 || caml_stat_major_collections <= 2) {
L10:
        return _t39;
    } else {
        _t68 = caml_stat_heap_chunks - 2;
        if(_t68 <= 0) {
            goto L10;
        }
        _t60 = caml_fl_cur_size;
        _t40 = caml_fl_size_at_phase_change;
        _v28 = _t60;
        _v24 = 0;
        asm("fild qword [ebp-0x18]");
        _v28 = caml_fl_size_at_phase_change;
        _v24 = 0;
        asm("fild qword [ebp-0x18]");
        asm("faddp st1, st0");
        _v16 = __fp0 *  *134658988 *  *134661684;
        _t74 = _v16;
        asm("fldz");
        asm("fucomip st0, st1");
        if(_t68 > 0) {
            st0 = _t74;
            _v28 = _t60;
            _v24 = 0;
            asm("fild qword [ebp-0x18]");
        }
        _t62 = caml_stat_heap_size >> 2;
        _t69 = _t62;
        _v28 = _t62;
        _v24 = 0;
        asm("fild qword [ebp-0x18]");
        asm("fxch st0, st1");
        asm("fucomi st0, st1");
        if(_t69 < 0) {
            asm("fxch st0, st1");
            asm("fsubp st2, st0");
            asm("fdivrp st1, st0");
            _v36 = st0 *  *134661468;
            _t78 = _v36;
            asm("fucomi st0, st1");
            asm("fcmovnbe st0, st1");
            st1 = _t78;
            _v36 = _t78;
        } else {
            st0 = _t74;
            st0 = _t74;
            _v36 =  *134657160;
        }
        caml_gc_message(512, "FL size at phase change = %lu\n", _t40);
        asm("fnstcw word [ebp-0x1a]");
        _v32 = 12;
        asm("fldcw word [ebp-0x1c]");
        asm("fistp qword [ebp-0x18]");
        asm("fldcw word [ebp-0x1a]");
        caml_gc_message(512, "Estimated overhead = %lu%%\n", _v28);
        _t39 = caml_percent_max;
        _v28 = _t39;
        _v24 = 0;
        asm("fild qword [ebp-0x18]");
        _t80 = _v36;
        asm("fucomip st0, st1");
        st0 = _v36;
        if(_t69 < 0) {
            goto L10;
        } else {
            caml_gc_message(512, "Automatic compaction triggered.\n", 0);
            caml_finish_major_cycle(_t80);
            _v28 = caml_fl_cur_size;
            _v24 = 0;
            asm("fild qword [ebp-0x18]");
            _v28 = caml_stat_heap_size >> 2;
            _v24 = 0;
            asm("fild qword [ebp-0x18]");
            asm("fsubrp st2, st0");
            asm("fdivrp st1, st0");
            _v16 = st0 *  *134661468;
            asm("fnstcw word [ebp-0x1a]");
            _v32 = 12;
            asm("fldcw word [ebp-0x1c]");
            asm("fistp qword [ebp-0x18]");
            asm("fldcw word [ebp-0x1a]");
            caml_gc_message(512, "Measured overhead: %lu%%\n", _v28);
            return caml_compact_heap();
        }
    }
}

caml_final_do_strong_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08069C80
    intOrPtr* _v32;                        // _cfa_ffffffe0
    intOrPtr* _v56;                        // _cfa_ffffffc8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    intOrPtr* _t28;                        // _t28
    intOrPtr _t30;                         // _t30
    signed int _t31;                       // _t31
    intOrPtr _t34;                         // _t34
    _unknown_ _t35;                        // _t35
    intOrPtr* _t37;                        // _t37
    signed int _t38;                       // _t38
    signed int _t39;                       // _t39

    if(old != 0) {
        _t31 = 0;
        _t39 = 0;
        _t37 = _a4;
        do {
            _t28 = _t31 + final_table;
            _v56 = _t28;
             *__esp =  *_t28;
             *_t37();
            _t39 = _t39 + 1;
            _t31 = _t31 + 12;
        } while(old > _t39);
    }
    _t22 = to_do_hd;
    _v32 = _t22;
    if(_t22 != 0) {
        goto L7;
    } else {
        return;
    }
    do {
        goto L7;
L6:
        _t34 =  *_v32;
        _v32 = _t34;
    } while(_t34 != 0);
    return;
L10:
L7:
    _t30 = _v32;
    _t38 = 0;
    if( *((intOrPtr*)(_t30 + 4)) != 0) {
        do {
            _t35 = _v32 + (_t38 + _t38 * 2) * 4;
            _v56 = _t35 + 8;
             *__esp =  *((intOrPtr*)(_t30 + 8));
            _a4();
            _v56 = _t35 + 12;
             *__esp =  *((intOrPtr*)(_t30 + 12));
            _a4();
            _t38 = _t38 + 1;
            _t30 = _t30 + 12;
            _t22 = _v32;
        } while( *((intOrPtr*)(_v32 + 4)) > _t38);
    } else {
    }
}

caml_final_do_weak_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08069D29
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t7;                         // _t7

    __edi = _a4;
    if(old != 0) {
        __ebx = 0;
        __esi = 0;
        do {
            _t7 = __ebx + final_table;
            _v40 = _t7 + 4;
             *__esp =  *((intOrPtr*)(_t7 + 4));
             *__edi();
            __esi = __esi + 1;
            __ebx = __ebx + 12;
        } while(old > __esi);
    }
}

caml_final_do_young_roots(
    intOrPtr* _a4                          // _cfa_4
)
{// addr = 0x08069D75
    intOrPtr* _v40;                        // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    intOrPtr* __edi;                       // r4
    signed int __esi;                      // r5
    intOrPtr* _t10;                        // _t10
    _unknown_ _t13;                        // _t13
    signed int _t15;                       // _t15

    __edi = _a4;
    __esi = old;
    if(__esi < young) {
        _t15 = __esi + __esi * 2 << 2;
        do {
            _t10 = _t15 + final_table;
            _v40 = _t10;
             *__esp =  *_t10;
             *__edi();
            _t13 = _t15 + final_table;
            _v40 = _t13 + 4;
             *__esp =  *((intOrPtr*)(_t13 + 4));
             *__edi();
            __esi = __esi + 1;
            _t15 = _t15 + 12;
        } while(young > __esi);
    }
}

caml_final_empty_young()
{// addr = 0x08069DD5
    __eax = young;
    old = __eax;
    return __eax;
}

caml_final_release()
{// addr = 0x08069DE4
    running_finalisation_function = 0;
    return 1;
}

caml_final_register(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    unsigned int __esi,                    // r5
    intOrPtr _a4,                          // _cfa_4
    unsigned int _a8                       // _cfa_8
)
{// addr = 0x08069DF8
    intOrPtr _v8;                          // _cfa_fffffff8
    unsigned int _v12;                     // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    _unknown_ _v40;                        // _cfa_ffffffd8 (outparam)
    signed int _t28;                       // _t28
    signed int _t29;                       // _t29
    unsigned int _t40;                     // _t40
    unsigned int _t46;                     // _t46
    intOrPtr* _t52;                        // _t52
    signed int _t59;                       // _t59
    unsigned int _t60;                     // _t60

    _t60 = __esi;
    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t40 = _a8;
    if((_t40 & 1) != 0) {
L2:
         *__esp = "Gc.finalise";
        caml_invalid_argument();
L3:
        _t28 = size;
        if(young >= _t28) {
            _t53 = final_table;
            if(final_table != 0) {
                _t59 = _t28 + _t28;
                final_table = caml_stat_resize(_t53, _t59 + _t28 * 4 << 2);
                size = _t59;
            } else {
                final_table = caml_stat_alloc(_t28, 360);
                size = 30;
            }
        }
        _t29 = young;
        _t52 = (_t29 + _t29 * 2 << 2) + final_table;
         *_t52 = _a4;
        _t46 = _t60 - 4;
        if( *_t46 != 249) {
             *(_t52 + 8) = 0;
             *(_t52 + 4) = _t40;
        } else {
             *(_t52 + 8) =  *_t46 >> 10 << 2;
             *(_t52 + 4) = _t60 - ( *_t46 >> 10 << 2);
        }
        young = _t29 + 1;
        return 1;
    }
    _t60 = _t40;
    if(( *( *((intOrPtr*)((_t40 >> 23) * 4 +  &caml_page_table)) + (_t40 >> 12 & 2047)) & 3) != 0) {
        goto L3;
    }
    goto L2;
}

caml_final_do_calls()
{// addr = 0x08069EE9
    _unknown_ _v20;                        // _cfa_ffffffec (outparam)
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    signed int __ebx;                      // r1
    _unknown_ _t15;                        // _t15
    signed int _t17;                       // _t17
    signed int _t22;                       // _t22
    signed int _t25;                       // _t25
    signed int _t26;                       // _t26

    if(running_finalisation_function != 0 || to_do_hd == 0) {
        return _t15;
    } else {
        caml_gc_message(128, "Calling finalisation functions.\n", 0);
        while(1) {
            _t17 = to_do_hd;
            if(_t17 == 0) {
                break;
            }
            _t25 =  *(_t17 + 4);
            if(_t25 == 0) {
                __ebx =  *_t17;
                 *__esp = _t17;
                free();
                to_do_hd = __ebx;
                if(__ebx == 0) {
                    to_do_tl = 0;
                }
                continue;
            }
            _t26 = _t25 - 1;
             *(_t17 + 4) = _t26;
            _t19 = _t17 + (_t26 + _t26 * 2) * 4;
            running_finalisation_function = 1;
            _t22 = caml_callback_exn( *((intOrPtr*)(_t17 + (_t26 + _t26 * 2) * 4 + 8)),  *((intOrPtr*)(_t17 + (_t26 + _t26 * 2) * 4 + 12)) +  *((intOrPtr*)(_t19 + 16)));
            running_finalisation_function = 0;
            if((_t22 & 3) != 2) {
                continue;
            }
             *__esp = _t22 & -4;
            caml_raise();
            break;
        }
        return caml_gc_message(128, "Done calling finalisation functions.\n", 0);
    }
}

signed int caml_final_update()
{// addr = 0x08069FC4
    signed int _v32;                       // _cfa_ffffffe0
    unsigned int _v36;                     // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    signed int* _v48;                      // _cfa_ffffffd0
    signed int _v52;                       // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    intOrPtr _v60;                         // _cfa_ffffffc4
    intOrPtr* _v64;                        // _cfa_ffffffc0
    signed int _v88;                       // _cfa_ffffffa8
    _unknown_ __ebx;                       // r1
    _unknown_ __esi;                       // r5
    signed int _t85;                       // _t85
    signed int _t86;                       // _t86
    signed int* _t88;                      // _t88
    signed int _t89;                       // _t89
    signed int* _t90;                      // _t90
    signed int* _t91;                      // _t91
    signed int _t93;                       // _t93
    intOrPtr* _t98;                        // _t98
    signed int _t100;                      // _t100
    unsigned int _t101;                    // _t101
    intOrPtr _t104;                        // _t104
    signed int* _t106;                     // _t106
    signed int _t108;                      // _t108
    signed int _t110;                      // _t110
    unsigned int* _t115;                   // _t115
    signed int _t120;                      // _t120
    signed int _t126;                      // _t126
    signed int _t127;                      // _t127
    intOrPtr* _t128;                       // _t128
    signed int* _t129;                     // _t129
    intOrPtr* _t130;                       // _t130
    signed int _t132;                      // _t132
    intOrPtr* _t133;                       // _t133
    intOrPtr* _t135;                       // _t135
    signed int _t137;                      // _t137

    _t132 = old;
    if(_t132 != 0) {
        _t128 = final_table;
        _t86 = 0;
        do {
            asm("adc ebx, 0x0");
            _t86 = _t86 + 1;
            _t128 = _t128 + 12;
        } while(_t86 < _t132);
        if(0 != 0) {
            _t88 = 0x14;
             *__esp = _t88;
            malloc();
            if(_t88 == 0) {
                _t88 = caml_fatal_error("out of memory");
            }
             *_t88 = 0;
            _t88[1] = 0;
            _t129 = to_do_tl;
            if(_t129 != 0) {
                 *_t129 = _t88;
                to_do_tl = _t88;
            } else {
                to_do_hd = _t88;
                to_do_tl = _t88;
            }
            _t89 = old;
            _v52 = _t89;
            if(_t89 == 0) {
                old = 0;
                young = 0;
                _t90 = to_do_tl;
                _t90[1] = 0;
                return _t90;
            }
            _t130 = final_table;
            _v60 = _t130;
            _v48 = to_do_tl;
            _v40 = 0;
            _v56 = 0;
            _v44 = 0;
            do {
                _v64 = _t130;
                while(1) {
                    _t115 =  *(_t130 + 4);
                    _t91 = _t115 - 4;
                    if(( *_t91 & 768) != 0) {
                        break;
                    }
                    if( *_t91 != 250) {
                        _t135 = _v64;
                        goto L25;
                    } else {
                        _t101 =  *_t115;
                        if((_t101 & 1) != 0) {
                            _t135 = _v64;
                             *(_t135 + 4) = _t101;
                            goto L25;
                        } else {
                            _v36 = _t101;
                            _t108 = _t101 >> 23;
                            _t126 = _t101 >> 12 & 2047;
                            _v32 = _t126;
                            if(( *( *((intOrPtr*)( &caml_page_table + _t108 * 4)) + _t126) & 7) == 0) {
                                _t135 = _v64;
                                goto L25;
                            } else {
                                _t127 =  *(_t101 - 4) & 255;
                                if(_t127 == 250) {
                                    _t135 = _v64;
                                    goto L25;
                                } else {
                                    if(_t127 == 246) {
                                        _t135 = _v64;
                                        goto L25;
                                    } else {
                                        if(_t127 != 253) {
                                             *(_t130 + 4) = _t101;
                                            if(( *( *((intOrPtr*)( &caml_page_table + _t108 * 4)) + _v32) & 1) != 0) {
                                                continue;
                                            } else {
                                                _t135 = _v64;
                                                goto L25;
                                            }
                                            goto L35;
                                        } else {
                                            _t135 = _v64;
L25:
                                            _t100 = _v40 + _v40 * 2 << 2;
                                            _t106 = _v48;
                                             *((intOrPtr*)( &(_t106[2]) + _t100)) =  *_t135;
                                             *( &(_t106[3]) + _t100) =  *(_t135 + 4);
                                             *((intOrPtr*)( &(_t106[4]) + _t100)) = _t135[2];
                                            _v40 = _v40 + 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    goto L27;
                }
                _t133 = _v64;
                _t93 = _v56 + _v56 * 2 << 2;
                _t104 = _v60;
                 *((intOrPtr*)(_t93 + _t104)) =  *_t133;
                 *((intOrPtr*)(_t93 + _t104 + 4)) = _t133[1];
                 *((intOrPtr*)(_t93 + _t104 + 8)) = _t133[2];
                _v56 = _v56 + 1;
L27:
                _v44 = _v44 + 1;
                _t130 = _t130 + 12;
            } while(_v52 > _v44);
            _t85 = _v56;
            old = _t85;
            young = _t85;
            _t120 = _v40;
            _v48[1] = _t120;
            if(_t120 != 0) {
                _t110 = 0;
                _t137 = _t120;
                do {
                    _v88 = 0;
                    _t98 = caml_darken(( &(to_do_tl[_t110 + _t110 * 2]))[3]);
                    _t110 = _t110 + 1;
                } while(_t110 < _t137);
                return _t98;
            }
        }
    }
L35:
    return _t85;
}

caml_final_custom_operations(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806A1F4
    intOrPtr* __ebx;                       // r1
    intOrPtr __esi;                        // r5
    intOrPtr* _t11;                        // _t11
    intOrPtr* _t12;                        // _t12
    intOrPtr* _t13;                        // _t13

    __esi = _a4;
    _t11 = custom_ops_final_table;
    if(_t11 == 0) {
L5:
        _t12 = caml_stat_alloc(_t11, 28);
        __ebx = _t12;
         *_t12 = "_final";
        _t12[1] = __esi;
        _t12[2] = 0;
        _t12[3] = 0;
        _t12[4] = 0;
        _t12[5] = 0;
        _t13 = caml_stat_alloc(_t12, 8);
         *_t13 = __ebx;
         *((intOrPtr*)(_t13 + 4)) = custom_ops_final_table;
        custom_ops_final_table = _t13;
    } else {
        __ebx =  *_t11;
        if( *((intOrPtr*)(__ebx + 4)) != __esi) {
            while(1) {
                _t11 = _t11[1];
                if(_t11 == 0) {
                    goto L5;
                }
                __ebx =  *_t11;
                if(__ebx[1] != __esi) {
                    continue;
                }
                goto L6;
            }
            goto L5;
        } else {
        }
    }
L6:
    return __ebx;
}

caml_register_custom_operations(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806A277
    _unknown_ _t3;                         // _t3
    intOrPtr* _t4;                         // _t4

    _t4 = caml_stat_alloc(_t3, 8);
     *_t4 = _a4;
     *((intOrPtr*)(_t4 + 4)) = custom_ops_table;
    custom_ops_table = _t4;
    return _t4;
}

caml_init_custom_operations()
{// addr = 0x0806A29E
    caml_register_custom_operations( &caml_int32_ops);
    caml_register_custom_operations( &caml_nativeint_ops);
    return caml_register_custom_operations( &caml_int64_ops);
}

caml_find_custom_operations(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806A2CA
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr* __ebx;                       // r1
    intOrPtr __edi;                        // r4
    intOrPtr* __esi;                       // r5
    intOrPtr _t5;                          // _t5

    __edi = _a4;
    __ebx = custom_ops_table;
    if(__ebx == 0) {
L3:
        __esi = 0;
    } else {
        while(1) {
            __esi =  *__ebx;
            _t5 =  *__esi;
            _v40 = __edi;
             *__esp = _t5;
            strcmp();
            if(_t5 == 0) {
                goto L4;
            }
            __ebx = __ebx[1];
            if(__ebx != 0) {
                continue;
            } else {
                goto L3;
            }
            goto L4;
        }
    }
L4:
    return __esi;
}

caml_alloc_custom(
    intOrPtr __edi,                        // r4
    _unknown_ __fp0,                       // r28
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0806A30A
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)
    intOrPtr __ebx;                        // r1
    _unknown_ __esi;                       // r5
    signed int _t12;                       // _t12
    intOrPtr* _t18;                        // _t18
    intOrPtr _t19;                         // _t19

    __fp0 = __fp0;
    __edi = __edi;
    __ebx = _a4;
    _t12 = (_a8 + 3 >> 2) + 1;
    if( *((intOrPtr*)(__ebx + 4)) != 0 || _t12 > 256) {
         *((intOrPtr*)(caml_alloc_shr(__ebx, __edi, _t19, _t12, 255))) = __ebx;
        caml_adjust_gc_speed(__fp0, _a12, _a16);
        return caml_check_urgent_gc(_t13);
    } else {
        _t18 = caml_alloc_small(__ebx, _t19, _t12, 255);
         *_t18 = __ebx;
        return _t18;
    }
}

caml_executable_name(
    _unknown_ __eax,                       // r0
    intOrPtr __ebx,                        // r1
    intOrPtr __esi,                        // r5
    intOrPtr _a4,                          // _cfa_4
    char* _a8                              // _cfa_8
)
{// addr = 0x0806A380
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _v92;                       // _cfa_ffffffa4
    char _v108;                            // _cfa_ffffff94
    char* _v116;                           // _cfa_ffffff8c
    intOrPtr _v120;                        // _cfa_ffffff88
    char* _t15;                            // _t15
    intOrPtr _t17;                         // _t17
    char* _t22;                            // _t22

    _v12 = __ebx;
    _v8 = __esi;
    _t17 = _a4;
    _t22 = _a8;
    _v116 = _t22;
    _v120 = _t17;
     *__esp = "/proc/self/exe";
    readlink();
    if(__eax == -1 || _t22 <= __eax) {
L4:
        _t15 = -1;
        goto L5;
    } else {
         *((char*)(_t17 + __eax)) = 0;
        _t15 =  &_v108;
        _v116 =  &_v108;
        _v120 = _t17;
         *__esp = 3;
        __xstat64();
        if( &_v108 != 0 || (_v92 & 61440) != 32768) {
            goto L4;
        } else {
L5:
            return _t15;
        }
    }
}

signed char* caml_decompose_path(
    signed int* _a4,                       // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806A3EE
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int* __esi;                     // r5
    signed char* _t9;                      // _t9
    signed int _t10;                       // _t10
    signed char* _t12;                     // _t12
    intOrPtr _t13;                         // _t13
    signed char* _t14;                     // _t14
    signed char* _t17;                     // _t17
    signed char* _t18;                     // _t18

    __esi = _a4;
    _t13 = _a8;
    _t18 = 0;
    if(_t13 == 0) {
L10:
        return _t18;
    } else {
        asm("repne scasb");
        _t9 = caml_stat_alloc(0,  !-1);
        _t18 = _t9;
        _v40 = _t13;
         *__esp = _t9;
        strcpy();
        _t17 = _t18;
        while(1) {
            _t10 =  *_t17 & 255;
            if(_t10 == 0 || _t10 == 58) {
                goto L4;
            }
            _t12 =  &(_t17[1]);
            do {
                _t14 = _t12;
                __edx =  *_t12 & 255;
                _t12 =  &(_t12[1]);
            } while(__dl != 0 && __dl != 58);
L8:
            caml_ext_table_add(__esi, _t17);
            if( *_t14 == 0) {
                goto L10;
            }
             *_t14 = 0;
            _t17 =  &(_t14[1]);
            continue;
L4:
            _t14 = _t17;
            goto L8;
        }
    }
}

caml_read_directory(
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a8                          // _cfa_8
)
{// addr = 0x0806A474
    intOrPtr _v32;                         // _cfa_ffffffe0
    _unknown_ _v72;                        // _cfa_ffffffb8 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    intOrPtr _t15;                         // _t15
    intOrPtr _t17;                         // _t17
    _unknown_ _t20;                        // _t20
    _unknown_ _t30;                        // _t30
    _unknown_ _t33;                        // _t33

    _t15 = _a4;
     *__esp = _t15;
    opendir();
    _v32 = _t15;
    if(_v32 == 0) {
        return -1;
    } else {
        do {
            _t17 = _v32;
             *__esp = _t17;
            readdir64();
        } while(_t17 != 0);
         *__esp = _v32;
        closedir();
        return 0;
    }
}

caml_dlerror(
    _unknown_ __eax                        // r0
)
{// addr = 0x0806A53D
    __eax = __eax;
    dlerror();
    return __eax;
}

caml_dlsym(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806A54A
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t5;                          // _t5

    _v24 = _a8;
    _t5 = _a4;
     *__esp = _t5;
    dlsym();
    return _t5;
}

caml_globalsym(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806A564
    _unknown_ _v24;                        // _cfa_ffffffe8 (outparam)

    return caml_dlsym(0, _a4);
}

caml_dlclose(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806A57F
    __eax = _a4;
     *__esp = __eax;
    dlclose();
    return __eax;
}

caml_dlopen(
    intOrPtr _a4,                          // _cfa_4
    _unknown_ _a12                         // _cfa_c
)
{// addr = 0x0806A592
    intOrPtr _v24;                         // _cfa_ffffffe8
    intOrPtr _t7;                          // _t7

    asm("sbb eax, eax");
    _v24 = 0x1102;
    _t7 = _a4;
     *__esp = _t7;
    dlopen();
    return _t7;
}

signed char* caml_search_in_path(
    intOrPtr* _a4,                         // _cfa_4
    signed char* _a8                       // _cfa_8
)
{// addr = 0x0806A5B8
    signed int _v108;                      // _cfa_ffffff94
    char _v124;                            // _cfa_ffffff84
    signed int _v128;                      // _cfa_ffffff80
    signed int _v132;                      // _cfa_ffffff7c
    char* _v148;                           // _cfa_ffffff6c
    signed char* _v152;                    // _cfa_ffffff68
    signed char* __ebx;                    // r1
    _unknown_ __edi;                       // r4
    intOrPtr* __esi;                       // r5
    signed char* _t27;                     // _t27
    signed char* _t29;                     // _t29
    signed char* _t36;                     // _t36
    signed int _t49;                       // _t49
    signed int _t58;                       // _t58

    __esi = _a4;
    _t27 = _a8;
    _t49 =  *_t27 & 255;
    if(_t49 == 0) {
L5:
        if( *__esi <= 0) {
L12:
            asm("repne scasb");
            _t29 = caml_stat_alloc(0,  !-1);
            __ebx = _t29;
            _v152 = _a8;
             *__esp = _t29;
            strcpy();
L13:
            return __ebx;
        }
        _v128 = 0;
        while(1) {
            _v132 = _v128 << 2;
            asm("repne scasb");
            asm("repne scasb");
            __ebx = caml_stat_alloc(0,  !-1 +  !-1);
            _v152 =  *(__esi[2] + _v132);
             *__esp = __ebx;
            strcpy();
            if( *__ebx != 0) {
                asm("repne scasb");
                __ebx[ !-1 - 1] = 47;
            }
            _t36 = _a8;
            _v152 = _t36;
             *__esp = __ebx;
            strcat();
            _v148 =  &_v124;
            _v152 = __ebx;
             *__esp = 3;
            __xstat64();
            if(_t36 == 0 && (_v108 & 61440) == 32768) {
                goto L13;
            }
            caml_stat_free(__ebx);
            _v128 = _v128 + 1;
            if( *__esi > _v128) {
                continue;
            }
            goto L12;
        }
        goto L13;
    }
    if(_t49 != 47) {
        while(1) {
            _t27 =  &(_t27[1]);
            _t58 =  *_t27 & 255;
            if(_t58 == 0) {
                goto L5;
            }
            if(_t58 == 47) {
                goto L12;
            }
        }
        goto L5;
    }
    goto L12;
}

caml_search_dll_in_path(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806A6EF
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    intOrPtr _v40;                         // _cfa_ffffffd8 (outparam)
    signed char* _t15;                     // _t15
    signed char* _t18;                     // _t18

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    asm("repne scasb");
    _t15 = caml_stat_alloc(0,  !-1 + 3);
    _t22 = _t15;
    _v40 = _a8;
     *__esp = _t15;
    strcpy();
    asm("repne scasb");
     *((intOrPtr*)(_t15 +  !-1 - 1)) = 7303982;
    _t18 = caml_search_in_path(_a4, _t15);
    caml_stat_free(_t15);
    return _t18;
}

caml_search_exe_in_path(
    intOrPtr __ebx,                        // r1
    intOrPtr __edi,                        // r4
    intOrPtr __esi,                        // r5
    signed char* _a4                       // _cfa_4
)
{// addr = 0x0806A76C
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    intOrPtr _v16;                         // _cfa_fffffff0
    char _v40;                             // _cfa_ffffffd8
    _unknown_ _v56;                        // _cfa_ffffffc8 (outparam)
    intOrPtr _t13;                         // _t13
    signed char* _t14;                     // _t14
    signed char* _t16;                     // _t16

    _v16 = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    _t13 = caml_ext_table_init( &_v40, 8);
     *__esp = "PATH";
    getenv();
    _t14 = caml_decompose_path( &_v40, _t13);
    _t16 = caml_search_in_path( &_v40, _a4);
    caml_stat_free(_t14);
    caml_ext_table_free( &_v40, 0);
    return _t16;
}

caml_backtrace_status(
    signed int __eax                       // r0
)
{// addr = 0x0806A7E0
    asm("sbb eax, eax");
    return (__eax & -2) + 3;
}

signed int extract_location_info(
    signed int __eax,                      // r0
    intOrPtr __ebx,                        // r1
    signed int* __edx,                     // r3
    intOrPtr __edi,                        // r4
    intOrPtr __esi                         // r5
)
{// addr = 0x0806A7F4
    intOrPtr _v8;                          // _cfa_fffffff8
    intOrPtr _v12;                         // _cfa_fffffff4
    signed int _t22;                       // _t22
    signed int _t28;                       // _t28
    signed int _t37;                       // _t37
    unsigned int _t41;                     // _t41

    __edx = __edx;
    _t22 = __eax;
     *__esp = __ebx;
    _v12 = __esi;
    _v8 = __edi;
    if(( *(__eax + 4) & 1) != 0) {
        _t28 = __eax + 11 + ( *(__eax + 6) & 65535) * 2 & -4;
        _t41 =  *_t28;
        _t37 =  *(_t28 + 4);
         *__edx = 1;
        __edx[1] = (_t41 & 3) != 0 & 255;
        __edx[2] = (_t41 & 67108860) + _t28;
        __edx[3] = _t37 >> 12;
        __edx[4] = _t37 >> 4 & 255;
        _t22 = _t41 >> 26 | (_t37 & 15) << 6;
        __edx[5] = _t22;
    } else {
         *__edx = 0;
        __edx[1] = 1;
    }
    return _t22;
}

signed int caml_get_exception_backtrace(
    _unknown_ __fp0                        // r28
)
{// addr = 0x0806A887
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    char* _v52;                            // _cfa_ffffffcc
    char* _v56;                            // _cfa_ffffffc8
    char* _v60;                            // _cfa_ffffffc4
    char* _v64;                            // _cfa_ffffffc0
    signed int _v68;                       // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    char _v76;                             // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    intOrPtr _v88;                         // _cfa_ffffffa8
    intOrPtr _v92;                         // _cfa_ffffffa4
    _unknown_ _v96;                        // _cfa_ffffffa0
    _unknown_ _v100;                       // _cfa_ffffff9c
    char* _v112;                           // _cfa_ffffff90
    signed int _v136;                      // _cfa_ffffff78 (outparam)
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ _t58;                        // _t58
    signed int _t66;                       // _t66
    signed int _t72;                       // _t72
    signed int _t77;                       // _t77
    intOrPtr _t85;                         // _t85
    signed int _t86;                       // _t86
    intOrPtr _t97;                         // _t97
    signed int _t100;                      // _t100

    __fp0 = __fp0;
    _t58 = caml_local_roots;
    _v112 = _t58;
    _v32 = 0;
    _v36 = 0;
    _v40 = 0;
    _v44 = 0;
    _v76 = _t58;
    caml_local_roots =  &_v76;
    _v68 = 1;
    _v72 = 4;
    _v64 =  &_v32;
    _v60 =  &_v36;
    _v56 =  &_v40;
    _v52 =  &_v44;
    _v36 = caml_alloc(_t85, _t97, _t99, __fp0, caml_backtrace_pos, 0);
    if(caml_backtrace_pos > 0) {
        _t86 = 0;
        do {
            _t100 = _t86 * 4;
            extract_location_info( *((intOrPtr*)(caml_backtrace_buffer + _t100)), _t86,  &_v100,  &_v100, _t100);
            if(_v100 == 0) {
                _t72 = caml_alloc_small(_t86, _t100, 1, 1);
                asm("sbb edx, edx");
                _v40 = _t72;
                 *_t72 = ( &_v100 & -2) + 3;
            } else {
                _v44 = caml_copy_string(_t86,  &_v100, _t100, _v92);
                _t77 = caml_alloc_small(_t86, _t100, 5, 0);
                asm("sbb edx, edx");
                _v40 = _t77;
                 *_t77 = ( &_v100 & -2) + 3;
                 *(_v40 + 4) = _v44;
                 *((intOrPtr*)(_v40 + 8)) = _v88 + _v88 + 1;
                 *((intOrPtr*)(_v40 + 12)) = _v84 + _v84 + 1;
                 *((intOrPtr*)(_v40 + 16)) = _v80 + _v80 + 1;
            }
            _v136 = _v40;
            _t99 = _t100 + _v36;
             *__esp = _t100 + _v36;
            caml_modify(_t86,  &_v100, _t100 + _v36);
            _t86 = _t86 + 1;
        } while(caml_backtrace_pos > _t86);
    }
    _t66 = caml_alloc_small(_t85, _t99, 1, 0);
    _v32 = _t66;
     *_t66 = _v36;
    caml_local_roots = _v112;
    return _v32;
}

signed int caml_print_exception_backtrace()
{// addr = 0x0806AA08
    intOrPtr _v32;                         // _cfa_ffffffe0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    intOrPtr _v44;                         // _cfa_ffffffd4
    intOrPtr _v48;                         // _cfa_ffffffd0
    char _v52;                             // _cfa_ffffffcc
    intOrPtr _v68;                         // _cfa_ffffffbc
    intOrPtr _v72;                         // _cfa_ffffffb8
    intOrPtr _v76;                         // _cfa_ffffffb4
    intOrPtr _v80;                         // _cfa_ffffffb0
    intOrPtr _v84;                         // _cfa_ffffffac
    char* _v88;                            // _cfa_ffffffa8
    signed int __ebx;                      // r1
    char* __edi;                           // r4
    char* __esi;                           // r5
    signed int _t17;                       // _t17
    char* _t20;                            // _t20

    if(caml_backtrace_pos > 0) {
        __ebx = 0;
        __esi =  &_v52;
        __edi = "Re-raised at";
        do {
            _t17 = extract_location_info( *((intOrPtr*)(caml_backtrace_buffer + __ebx * 4)), __ebx,  &_v52, __edi,  &_v52);
            if(_v52 != 0) {
                _t20 = "Raised at";
                if(__ebx != 0) {
                    _t20 = _v48 != 0 ? __edi : "Called from";
                }
                _v68 = _v32;
                _v72 = _v36;
                _v76 = _v40;
                _v80 = _v44;
                _v84 = _t20;
                _v88 = "%s file "%s", line %d, characters %d-%d\n";
                _t17 = __imp__stderr;
                 *__esp = _t17;
                fprintf();
            }
            __ebx = __ebx + 1;
        } while(caml_backtrace_pos > __ebx);
    }
    return _t17;
}

signed int caml_stash_backtrace(
    signed int _a4,                        // _cfa_4
    unsigned int _a8,                      // _cfa_8
    intOrPtr _a12,                         // _cfa_c
    intOrPtr _a16                          // _cfa_10
)
{// addr = 0x0806AA99
    unsigned int __ebx;                    // r1
    signed int __edi;                      // r4
    intOrPtr __esi;                        // r5
    signed int _t16;                       // _t16
    intOrPtr _t19;                         // _t19
    signed int _t23;                       // _t23
    signed int _t25;                       // _t25

    _t16 = _a4;
    __ebx = _a8;
    __esi = _a12;
    if(_t16 != caml_backtrace_last_exn) {
        caml_backtrace_pos = 0;
        caml_backtrace_last_exn = _t16;
    }
    if(caml_backtrace_buffer != 0) {
L4:
        if(caml_frame_descriptors == 0) {
            caml_init_frame_descriptors();
        }
        while(1) {
L6:
            __edi = caml_frame_descriptors_mask;
            _t23 = __ebx >> 3 & __edi;
            _t19 = caml_frame_descriptors;
            _t16 =  *(_t19 + _t23 * 4);
            if(_t16 == 0) {
                goto L17;
            }
            if( *_t16 != __ebx) {
                while(1) {
                    _t23 = _t23 + 1 & __edi;
                    _t16 =  *(_t19 + _t23 * 4);
                    if(_t16 == 0) {
                        break;
                    }
                    if( *_t16 == __ebx) {
L12:
                        if( *(_t16 + 4) == 65535) {
                            _t16 = __esi + 8;
                            __esi =  *_t16;
                            __ebx =  *(_t16 + 4);
                            if(__esi == 0) {
                                goto L17;
                            }
L16:
                            if(__esi <= _a16) {
                                goto L6;
                            }
                            goto L17;
                        }
                        _t25 = caml_backtrace_pos;
                        if(_t25 > 1023) {
                            goto L17;
                        }
                         *(caml_backtrace_buffer + _t25 * 4) = _t16;
                        caml_backtrace_pos = _t25 + 1;
                        _t16 =  *(_t16 + 4) & 0xfffc;
                        __esi = __esi + _t16;
                        __ebx =  *(__esi - 4);
                        goto L16;
                    }
                }
                return _t16;
            }
            goto L12;
        }
        goto L17;
    } else {
         *__esp = 4096;
        malloc();
        caml_backtrace_buffer = _t16;
        if(_t16 == 0) {
L17:
            return _t16;
        }
        goto L4;
    }
}

caml_record_backtrace(
    signed int _a4                         // _cfa_4
)
{// addr = 0x0806AB74
    signed int _t3;                        // _t3

    _t3 = _a4 >> 1;
    if(_t3 != caml_backtrace_active) {
        caml_backtrace_active = _t3;
        caml_backtrace_pos = 0;
        if(_t3 == 0) {
            caml_remove_global_root( &caml_backtrace_last_exn);
        } else {
            caml_register_global_root( &caml_backtrace_last_exn);
        }
    }
    return 1;
}

caml_debugger_init(
    _unknown_ __eax                        // r0
)
{// addr = 0x0806ABBC
    __eax = __eax;
    return __eax;
}

caml_debugger(
    _unknown_ __eax                        // r0
)
{// addr = 0x0806ABC1
    __eax = __eax;
    return __eax;
}

caml_debugger_cleanup_fork(
    _unknown_ __eax                        // r0
)
{// addr = 0x0806ABC6
    __eax = __eax;
    return __eax;
}

caml_call_gc(
    char _a4                               // _cfa_4
)
{// addr = 0x0806ABCC
    _unknown_ __ebx;                       // r1
    _unknown_ __ecx;                       // r2
    _unknown_ __edx;                       // r3
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    _unknown_ __ebp;                       // r6
    _unknown_ _t4;                         // _t4

    caml_last_return_address =  *__esp;
    caml_bottom_of_stack =  &_a4;
    _push(__ebp);
    _push(__edi);
    _push(__esi);
    _push(__edx);
    _push(__ecx);
    _push(__ebx);
    _push( &_a4);
    caml_gc_regs = __esp;
    _t4 = caml_garbage_collection();
    _pop(__eax);
    _pop(__ebx);
    _pop(__ecx);
    _pop(__edx);
    _pop(__esi);
    _pop(__edi);
    _pop(__ebp);
    return _t4;
}

L0806ABDD(
    _unknown_ __eax                        // r0
)
{
    _unknown_ __ebx;                       // r1
    _unknown_ __ecx;                       // r2
    _unknown_ __edx;                       // r3
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5

    caml_gc_regs = __esp;
    return caml_garbage_collection();
}

caml_alloc1(
    char _a4                               // _cfa_4
)
{// addr = 0x0806ABF8
    intOrPtr _t3;                          // _t3

L0:
    while(1) {
L0:
        _t3 = caml_young_ptr - 8;
        caml_young_ptr = _t3;
        if(_t3 >= caml_young_limit) {
            break;
        }
L2:
        caml_last_return_address =  *__esp;
        caml_bottom_of_stack =  &_a4;
        L0806ABDD( &_a4);
    }
L1:
    return _t3;
}

caml_alloc3(
    char _a4                               // _cfa_4
)
{// addr = 0x0806AC60
    intOrPtr _t3;                          // _t3

L0:
    while(1) {
L0:
        _t3 = caml_young_ptr - 16;
        caml_young_ptr = _t3;
        if(_t3 >= caml_young_limit) {
            break;
        }
L2:
        caml_last_return_address =  *__esp;
        caml_bottom_of_stack =  &_a4;
        L0806ABDD( &_a4);
    }
L1:
    return _t3;
}

signed int caml_allocN(
    _unknown_ __eax,                       // r0
    char _a4                               // _cfa_4
)
{// addr = 0x0806AC94
    char _v0;                              // _cfa_0
    signed int _t5;                        // _t5
    signed int _t7;                        // _t7

L0:
    while(1) {
L0:
        _t5 =  ~(__eax - caml_young_ptr);
        if(_t5 >= caml_young_limit) {
            break;
        }
L2:
        _t7 =  ~(_t5 - caml_young_ptr);
        _push(_t7);
        caml_young_ptr = caml_young_ptr - _t7;
        caml_last_return_address = _v0;
        caml_bottom_of_stack =  &_a4;
        L0806ABDD( &_a4);
        _pop(__eax);
    }
L1:
    caml_young_ptr = _t5;
    return _t5;
}

caml_c_call(
    char _a4                               // _cfa_4
)
{// addr = 0x0806ACD8
    caml_last_return_address =  *__esp;
    caml_bottom_of_stack =  &_a4;
    goto __eax;
}

caml_start_program()
{// addr = 0x0806ACF0
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4

    _push(caml_gc_regs);
    _push(caml_last_return_address);
    _push(caml_bottom_of_stack);
    _push(134655294);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_startup__code_begin();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _pop(caml_bottom_of_stack);
    _pop(caml_last_return_address);
    _pop(caml_gc_regs);
}

caml_raise_exn(
    _unknown_ __eax,                       // r0
    char _a4                               // _cfa_4
)
{// addr = 0x0806AD44
    intOrPtr _t5;                          // _t5

    if((caml_backtrace_active & 1) != 0) {
        __esi = __eax;
        __edi = caml_exception_pointer;
        _t5 =  *__esp;
        _push(__edi);
        _push( &_a4);
        _push(_t5);
        _push(__eax);
        caml_stash_backtrace();
        __esp = __edi;
        _pop(caml_exception_pointer);
        return __esi;
    } else {
        __esp = caml_exception_pointer;
        _pop(caml_exception_pointer);
        return __eax;
    }
}

caml_raise_exception(
    intOrPtr _a4                           // _cfa_4
)
{// addr = 0x0806AD80
    if((caml_backtrace_active & 1) != 0) {
        __esi = _a4;
        _push(caml_exception_pointer);
        _push(caml_bottom_of_stack);
        _push(caml_last_return_address);
        _push(__esi);
        caml_stash_backtrace();
        __esp = caml_exception_pointer;
        _pop(caml_exception_pointer);
        return __esi;
    } else {
        __esp = caml_exception_pointer;
        _pop(caml_exception_pointer);
        return _a4;
    }
}

caml_callback_exn(
    intOrPtr* _a4,                         // _cfa_4
    intOrPtr _a8                           // _cfa_8
)
{// addr = 0x0806ADC8
    _unknown_ __edi;                       // r4
    intOrPtr* __esi;                       // r5
    _unknown_ __ebp;                       // r6

    __eax = _a8;
    __esi =  *_a4;
    _push(caml_gc_regs);
    _push(caml_last_return_address);
    _push(caml_bottom_of_stack);
    _push(134655294);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
     *__esi();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _pop(caml_bottom_of_stack);
    _pop(caml_last_return_address);
    _pop(caml_gc_regs);
    return __eax;
}

caml_callback2_exn(
    _unknown_ _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    _unknown_ _a12                         // _cfa_c
)
{// addr = 0x0806ADDC
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6

    __eax = _a8;
    _push(caml_gc_regs);
    _push(caml_last_return_address);
    _push(caml_bottom_of_stack);
    _push(134655294);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_apply2();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _pop(caml_bottom_of_stack);
    _pop(caml_last_return_address);
    _pop(caml_gc_regs);
    return __eax;
}

caml_callback3_exn(
    _unknown_ _a4,                         // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    _unknown_ _a12,                        // _cfa_c
    _unknown_ _a16                         // _cfa_10
)
{// addr = 0x0806ADF8
    _unknown_ __edi;                       // r4
    _unknown_ __ebp;                       // r6

    __eax = _a8;
    _push(caml_gc_regs);
    _push(caml_last_return_address);
    _push(caml_bottom_of_stack);
    _push(134655294);
    _push(caml_exception_pointer);
    caml_exception_pointer = __esp;
    caml_apply2();
    _pop(caml_exception_pointer);
    __esp = __esp + 4;
    _pop(caml_bottom_of_stack);
    _pop(caml_last_return_address);
    _pop(caml_gc_regs);
    return __eax;
}

signed int caml_ml_array_bound_error(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806AE18
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t68;                       // _t68
    signed int _t72;                       // _t72
    signed int _t73;                       // _t73
    signed int _t74;                       // _t74
    signed int _t75;                       // _t75
    signed int _t84;                       // _t84
    signed int _t91;                       // _t91
    signed int _t98;                       // _t98
    signed int _t99;                       // _t99
    signed int _t107;                      // _t107
    _unknown_ _t119;                       // _t119
    signed int _t121;                      // _t121
    signed int _t124;                      // _t124
    _unknown_ _t126;                       // _t126
    signed int _t129;                      // _t129
    _unknown_ _t134;                       // _t134

    asm("ffree st0");
    asm("ffree st1");
    asm("ffree st2");
    asm("ffree st3");
    asm("ffree st4");
    asm("ffree st5");
    asm("ffree st6");
    asm("ffree st7");
    caml_last_return_address =  *__esp;
    caml_bottom_of_stack =  &_a4;
    caml_array_bound_error();
    _push(_t134);
    _push(_t119);
    _push(_t126);
    __esp = __esp - 32;
    _t84 = _a8;
    _t98 = _a4;
    _v20 = _a12;
    _v16 = _a16;
    _v24 = 0;
    if(_t84 < 0) {
        _t98 =  ~_t98;
        asm("adc ecx, 0x0");
        _t84 =  ~_t84;
        _v24 = -1;
        if(_v16 >= 0) {
            goto L3;
        }
        goto L19;
    } else {
        if(_v16 < 0) {
L19:
            _v20 =  ~_v20;
            asm("adc dword [ebp-0xc], 0x0");
            _v24 =  !_v24;
            _v16 =  ~_v16;
        }
L3:
        _t68 = _v16;
        _t121 = _t84;
        _t129 = _v20;
        _v20 = _t98;
        if(_t68 != 0) {
            if(_t68 <= _t84) {
                asm("bsr edx, eax");
                _t99 = _t98 ^ 31;
                _v28 = _t99;
                if(_t99 != 0) {
                    _v32 = _t68 << (_v28 & 255);
                    _v36 = _t129 << (_v28 & 255);
                    _v32 = _t129 >> 32 | _v32;
                    _t72 = _t121 << (_v28 & 255) | _v20 >> 32 - _v28;
                    _t73 = _t72 / _v32;
                    _t129 = _t72 % _v32;
                    _t124 = _t73;
                    _t107 = _t73 * _v36 >> 32;
                    _t74 = _t73 * _v36;
                    _v32 = _t107;
                    if(_t129 < _t107 || _v20 << (_v28 & 255) < _t74 && _t129 == _v32) {
                        _t91 = _t124 - 1;
                    } else {
                        _t91 = _t124;
                    }
                    goto L8;
                }
                if(_t129 <= _v20 || _t68 < _t84) {
                    _t91 = 1;
                    goto L8;
                } else {
                    goto L7;
                }
            }
L7:
            _t91 = 0;
            goto L8;
        } else {
            if(_t129 <= _t84) {
                if(_t129 == 0) {
                    _t129 = 1 / _t129;
                }
                _t91 = _v20 / _t129;
            } else {
                _t91 = _t98 / _t129;
            }
L8:
            _t75 = _t91;
            if(_v24 != 0) {
                _t75 =  ~_t75;
                asm("adc edx, 0x0");
            }
            __esp = __esp + 32;
            _pop(__esi);
            _pop(__edi);
            _pop(__ebp);
            return _t75;
        }
    }
}

signed int __divdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806AE40
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t66;                       // _t66
    signed int _t70;                       // _t70
    signed int _t71;                       // _t71
    signed int _t72;                       // _t72
    signed int _t73;                       // _t73
    signed int _t83;                       // _t83
    signed int _t90;                       // _t90
    signed int _t95;                       // _t95
    signed int _t96;                       // _t96
    signed int _t104;                      // _t104
    signed int _t117;                      // _t117
    signed int _t120;                      // _t120
    signed int _t124;                      // _t124
    signed int _t128;                      // _t128

    _t83 = _a8;
    _t95 = _a4;
    _v20 = _a12;
    _v16 = _a16;
    _v24 = 0;
    if(_t83 < 0) {
        _t95 =  ~_t95;
        asm("adc ecx, 0x0");
        _t83 =  ~_t83;
        _v24 = -1;
        if(_v16 >= 0) {
L2:
            _t66 = _v16;
            _t117 = _t83;
            _t124 = _v20;
            _v20 = _t95;
            if(_t66 != 0) {
                if(_t66 <= _t83) {
                    asm("bsr edx, eax");
                    _t96 = _t95 ^ 31;
                    _v28 = _t96;
                    if(_t96 != 0) {
                        _v32 = _t66 << (_v28 & 255);
                        _v36 = _t124 << (_v28 & 255);
                        _v32 = _t124 >> 32 | _v32;
                        _t70 = _t117 << (_v28 & 255) | _v20 >> 32 - _v28;
                        _t71 = _t70 / _v32;
                        _t128 = _t70 % _v32;
                        _t120 = _t71;
                        _t104 = _t71 * _v36 >> 32;
                        _t72 = _t71 * _v36;
                        _v32 = _t104;
                        if(_t128 < _t104 || _v20 << (_v28 & 255) < _t72 && _t128 == _v32) {
                            _t90 = _t120 - 1;
                        } else {
                            _t90 = _t120;
                        }
                        goto L7;
                    }
                    if(_t124 <= _v20 || _t66 < _t83) {
                        _t90 = 1;
                        goto L7;
                    } else {
                        goto L6;
                    }
                }
L6:
                _t90 = 0;
                goto L7;
            } else {
                if(_t124 <= _t83) {
                    if(_t124 == 0) {
                        _t124 = 1 / _t124;
                    }
                    _t90 = _v20 / _t124;
                } else {
                    _t90 = _t95 / _t124;
                }
L7:
                _t73 = _t90;
                if(_v24 != 0) {
                    asm("adc edx, 0x0");
                    return  ~_t73;
                }
                return _t73;
            }
        }
L18:
        _v20 =  ~_v20;
        asm("adc dword [ebp-0xc], 0x0");
        _v24 =  !_v24;
        _v16 =  ~_v16;
        goto L2;
    }
    if(_v16 < 0) {
        goto L18;
    }
    goto L2;
}

signed int __moddi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed char _a12,                      // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806AFC0
    _unknown_ _v16;                        // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v32;                       // _cfa_ffffffe0
    signed int _v36;                       // _cfa_ffffffdc
    signed int _v40;                       // _cfa_ffffffd8
    signed int _v44;                       // _cfa_ffffffd4
    unsigned int _v48;                     // _cfa_ffffffd0
    unsigned int _v52;                     // _cfa_ffffffcc
    signed int _v56;                       // _cfa_ffffffc8
    signed int _v60;                       // _cfa_ffffffc4
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t99;                       // _t99
    signed int _t109;                      // _t109
    signed int _t110;                      // _t110
    signed int _t111;                      // _t111
    signed int _t128;                      // _t128
    signed int _t143;                      // _t143
    signed int _t144;                      // _t144
    signed int _t150;                      // _t150
    signed int _t161;                      // _t161
    signed int _t167;                      // _t167
    unsigned int _t171;                    // _t171

    _t128 = _a8;
    _t143 = _a4;
    _v36 = _a12;
    _v32 = _a16;
    _v48 = 0;
    if(_t128 < 0) {
        _t143 =  ~_t143;
        asm("adc ecx, 0x0");
        _t128 =  ~_t128;
        _v48 = -1;
    }
    if(_v32 < 0) {
        _v36 =  ~_v36;
        asm("adc dword [ebp-0x1c], 0x0");
        _v32 =  ~_v32;
    }
    _t99 = _v32;
    _v52 = _t143;
    _v44 = _t143;
    _v40 = _v36;
    _t167 = _t128;
    if(_t99 != 0) {
        if(_t99 <= _t128) {
            asm("bsr edx, eax");
            _t144 = _t143 ^ 31;
            _v36 = _t144;
            if(_t144 != 0) {
                _v44 = 32 - _v36;
                _v60 = _v40 >> (_v44 & 255) | _t99 << (_v36 & 255);
                _v56 = _v40 << (_v36 & 255);
                _t109 = _v52 >> (_v44 & 255) | _t167 << (_v36 & 255);
                _t110 = _t109 / _v60;
                _v40 = _v52 << (_v36 & 255);
                _t171 = _t109 % _v60;
                _t150 = _t110 * _v56 >> 32;
                _t111 = _t110 * _v56;
                if(_t171 < _t150) {
L25:
                    _t111 = _t111 - _v56;
                    asm("sbb edx, [ebp-0x38]");
                } else {
                    if(_v40 < _t111) {
                        if(_t171 == _t150) {
                            goto L25;
                        }
                    }
                }
                asm("sbb edi, edx");
                _v20 = _t171 << (_v44 & 255) | _v40 - _t111 >> (_v36 & 255);
                ((char*)( &_v20))[1] = _t171 >> (_v36 & 255);
            } else {
                if(_v40 <= _v44 || _t99 < _t167) {
                    asm("sbb edi, eax");
                    _v44 = _v44 - _v40;
                }
                ((char*)( &_v20))[1] = _t167;
                _v20 = _v44;
            }
        } else {
            _v20 = _t143;
            ((char*)( &_v20))[1] = _t128;
        }
        if(_v48 == 0) {
            goto L6;
        } else {
            goto L10;
        }
    } else {
        if(_v40 <= _t128) {
            if(_v40 == 0) {
                _v40 = 1 / _v40;
            }
            _t161 = _v44 % _v40;
        } else {
            _t161 = _t143 % _v40;
        }
        _v20 = _t161;
        ((char*)( &_v20))[1] = 0;
        if(_v48 != 0) {
L10:
            asm("adc edx, 0x0");
            return  ~_v20;
        } else {
L6:
            return _v20;
        }
    }
}

signed int __udivdi3(
    signed int _a4,                        // _cfa_4
    signed int _a8,                        // _cfa_8
    signed int _a12,                       // _cfa_c
    signed int _a16                        // _cfa_10
)
{// addr = 0x0806B190
    signed int _v16;                       // _cfa_fffffff0
    signed int _v20;                       // _cfa_ffffffec
    signed int _v24;                       // _cfa_ffffffe8
    signed int _v28;                       // _cfa_ffffffe4
    _unknown_ __edi;                       // r4
    _unknown_ __esi;                       // r5
    signed int _t51;                       // _t51
    signed int _t56;                       // _t56
    signed int _t57;                       // _t57
    signed int _t58;                       // _t58
    signed int _t70;                       // _t70
    signed int _t83;                       // _t83
    signed int _t85;                       // _t85
    signed int _t93;                       // _t93
    signed int _t106;                      // _t106
    signed int _t110;                      // _t110
    signed int _t114;                      // _t114
    signed int _t118;                      // _t118

    _t51 = _a16;
    _t83 = _a4;
    _t114 = _a12;
    _t106 = _a8;
    _v20 = _t83;
    if(_t51 != 0) {
        if(_t51 > _t106) {
L9:
            _t70 = 0;
            goto L10;
        } else {
            asm("bsr edx, eax");
            _t85 = _t83 ^ 31;
            _v16 = _t85;
            if(_t85 != 0) {
                _v24 = _t51 << (_v16 & 255);
                _v28 = _t114 << (_v16 & 255);
                _v24 = _t114 >> 32 | _v24;
                _t56 = _t106 << (_v16 & 255) | _v20 >> 32 - _v16;
                _t57 = _t56 / _v24;
                _t118 = _t56 % _v24;
                _t110 = _t57;
                _t93 = _t57 * _v28 >> 32;
                _t58 = _t57 * _v28;
                _v24 = _t93;
                if(_t118 < _t93 || _v20 << (_v16 & 255) < _t58 && _t118 == _v24) {
                    return _t110 - 1;
                } else {
                    _t70 = _t110;
                    goto L10;
                }
            } else {
                if(_t114 <= _v20 || _t51 < _t106) {
                    _t70 = 1;
                } else {
                    goto L9;
                }
L10:
                return _t70;
            }
        }
    } else {
        if(_t114 > _t106) {
            return _t83 / _t114;
        } else {
            if(_t114 == 0) {
                _t114 = 1 / _t114;
            }
            return _v20 / _t114;
        }
    }
}

__libc_csu_fini(
    _unknown_ __eax                        // r0
)
{// addr = 0x0806B2C0
    __eax = __eax;
    return __eax;
}

__libc_csu_init(
    intOrPtr _a4,                          // _cfa_4
    intOrPtr _a8,                          // _cfa_8
    intOrPtr _a12                          // _cfa_c
)
{// addr = 0x0806B2D0
    intOrPtr _v36;                         // _cfa_ffffffdc
    intOrPtr _v40;                         // _cfa_ffffffd8
    _unknown_ __ebx;                       // r1
    _unknown_ __edi;                       // r4
    signed int __esi;                      // r5
    _unknown_ _t11;                        // _t11
    _unknown_ _t17;                        // _t17
    _unknown_ _t18;                        // _t18
    signed int _t21;                       // _t21

    __i686.get_pc_thunk.bx(_t11);
    _t18 = _t17 + 9929;
    __esp = __esp - 28;
    _init();
    _t21 = _t18 - 332 - _t18 - 332 >> 2;
    if(_t21 != 0) {
        __esi = 0;
        do {
            _v36 = _a12;
            _v40 = _a8;
             *__esp = _a4;
             *((intOrPtr*)(_t18 + __esi * 4 - 332))();
            __esi = __esi + 1;
        } while(__esi < _t21);
    }
    __esp = __esp + 28;
}

__do_global_ctors_aux()
{// addr = 0x0806B330
    intOrPtr* __ebx;                       // r1

    __eax = __CTOR_LIST__;
    if(__eax != -1) {
        __ebx =  &__CTOR_LIST__;
        do {
            __ebx = __ebx - 4;
             *__eax();
            __eax =  *__ebx;
        } while(__eax != -1);
    }
}

_fini()
{// addr = 0x0806B35C
    _unknown_ __ebx;                       // r1
    _unknown_ _t1;                         // _t1

    __esp = __esp - 4;
    L1();
    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    return __eax;
}

L0806B368()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = __do_global_dtors_aux();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

L0806B368()
{
    _unknown_ _t1;                         // _t1

    _pop(__ebx);
    __eax = @rec __do_global_dtors_aux@__do_global_dtors_aux@();
    _pop(__ecx);
    _pop(__ebx);
    __esp = __ebp;
    _pop(__ebp);
    return __eax;
}

// Statistics:
//   18465 Register nodes
//   19018 Temporaries nodes
//    1888 Casts
//   10865 Statements
//    2194 Labels
//    1270 Gotos
//    1313 Blocks
//  142281 Nodes
//     450 Assembly nodes
//    1862 Unknown Types


Total time: 6 seconds.
